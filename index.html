<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hshz21.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content=豪哥博客 name=description><meta content=website property=og:type><meta content=豪哥博客 property=og:title><meta content=https://hshz21.gitee.io/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content=豪哥博客 property=og:description><meta content=zh_CN property=og:locale><meta content=豪哥 property=article:author><meta content=HG property=article:tag><meta content=summary name=twitter:card><link href=https://hshz21.gitee.io/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script><script class=next-config data-name=calendar type=application/json>""</script><title>豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <h1 class=site-title>豪哥博客</h1> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>116</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>35</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>128</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/10/12/%E6%97%A5%E5%BF%97%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/10/12/%E6%97%A5%E5%BF%97%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/ itemprop=url>Java系列-日志基础</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-10-12 11:29:59 / 修改时间：11:29:50" datetime=2024-10-12T11:29:59+08:00>2024-10-12</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E6%97%A5%E5%BF%97/ itemprop=url rel=index><span itemprop=name>日志</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=诞生历史和背景><a class=headerlink href=#诞生历史和背景 title=诞生历史和背景></a>诞生历史和背景</h1><p>先通过一张表汇总一下：<table><thead><tr><th align=center>日志<th align=center>作者<th align=center>时间<tbody><tr><td align=center>System.out<td align=center>Java<td align=center>1995<tr><td align=center>Log4J<td align=center>Apache/Ceki<td align=center>2001<tr><td align=center>JUL（Java Util Logging）<td align=center>Java1.4<td align=center>2002.2<tr><td align=center>JCL（Jakarta Commons Logging）<td align=center>Apache<td align=center>2002.8<tr><td align=center>Slf4j（Simple Logging Facade For Java）<td align=center>Ceki<td align=center>2005<tr><td align=center>Logback<td align=center>Ceki<td align=center>2006<tr><td align=center>Log4j2<td align=center>Apache<td align=center>2012</table><h2 id=System-out><a class=headerlink href=#System-out title=System.out></a>System.out</h2><p>2001年以前，Java是没有日志库的，打印日志全凭 System.out 和 System.err，缺点很多，详情如下：<ul><li>产生大量的IO操作 同时在生产环境中 无法合理的控制是否需要输出<li>输出的内容不能保存到文件<li>只打印在控制台，打印完就过去了，也就是说除非你一直盯着程序跑<li>无法定制化，且日志粒度不够细</ul><h2 id=Log4J><a class=headerlink href=#Log4J title=Log4J></a>Log4J</h2><p>1996年，一个欧盟赞助的<code>SEMPER</code>项目打算记录操作API的行为，以便于追溯问题。N. Asokan、Ceki Gülcü 和 Michael Steiner 就提出了分层记录器的想法，这也就是日志级别的由来。<p>2001年，切基古尔库公开了Log4j，拉开了大战的序幕，Log4j加入Apache，切基古尔库也成为了Apache中的一员。<p>Apache盯上了Java，建议Sun把Log4j加入到Java体系中，Sun拒绝了。<h2 id=JUL><a class=headerlink href=#JUL title=JUL></a>JUL</h2><p>Sun早就坐不住了，在2002年2月发布了Java1.4，在util包中加入了自己的Logging，JUL腾空出世。<h2 id=JCL><a class=headerlink href=#JCL title=JCL></a>JCL</h2><p>现在市面上有两款 Java 日志标准库，分别是 Log4j 与 JUL 。此时，Apache想统一日志标准接口规范（就像 JDBC统一数据库访问层），让其它日志标准库去实现该抽象接口。<p>2002 年 8 月 Apache 推出了 JCL（Jakarta Commons Logging） ，也就是日志抽象层，支持运行时动态加载日志组件的实现，当然也提供一个默认实现 Simple Log（在 ClassLoader 中进行查找，如果能找到 Log4j 则默认使用 log4j 实现，如果没有则使用 JUL 实现，再没有则使用JCL内部提供的 Simple Log 实现 ）。<p>但是JCL有几个缺点：<ol><li>效率较低。<li>容易引发混乱。<li>在使用了自定义ClassLoader的程序中使用JCL会引发内存泄露。</ol><h2 id=SLF4J><a class=headerlink href=#SLF4J title=SLF4J></a>SLF4J</h2><p>2005年Ceki离开了Apache，自立门户，随即推出了另一款Interface，也就是鼎鼎大名的<code>Simple Logging Facade for Java</code>，Slf4J是一套接口规范。<p>Slf4j只是一个接口，没有实现的日志库也很让人头疼，于是Ceki发话了，Sum 和 Apache 这两个组织不来实现我的接口没关系，我来实现就好了。后面 Ceki 提供了一系列的桥接包来帮助 Slf4j 接口与其他日志库建立关系，这种方式称为桥接设计模式。<p>Slf4j桥接日志标准库：<ul><li>Slf4J到Log4j：<code>slf4j-log4j12.jar</code><li>Slf4J到Log4j2：<code>log4j-slf4j-impl.jar</code><li>Slf4J到JUL：<code>slf4j-jdk14.jar</code><li>Slf4J到JCL：<code>slf4j-jcl.jar</code></ul><p>其它日志框架桥接Slf4j<ul><li>Log4j到Slf4J：<code>log4j-over-slf4j.jar</code><li>JUL到Slf4J：<code>jul-to-slf4j.jar</code><li>JCL到Slf4J：<code>jcl-over-slf4j.jar</code></ul><h2 id=Logback><a class=headerlink href=#Logback title=Logback></a>Logback</h2><p>Ceki 觉得市场上的日志标准库都是间接实现 Slf4j 接口，也就是说每次都需要配合桥接包，因此在 2006 年， Ceki 基于 Slf4j 接口撸出了 Logback 日志标准库，做为 Slf4j接口的默认实现， Logback 也十分给力，在功能完整度和性能上超越了所有已有的日志标准库。<h2 id=Log4j2><a class=headerlink href=#Log4j2 title=Log4j2></a>Log4j2</h2><p>自从 Logback 出来后，可以说 Slf4j+Logback 组合如日中天，很冲击 JCL+Log4j 组合， Apache 眼看有被 Logback 反超的势头。于是，2012年Apache 推出新项目 Log4j2 （不兼容 Log4j）， Log4j2 全面借鉴 Slf4j+Logback。<p><strong>到目前为止 Java 日志体系被划分为两大阵营，分别是 Apache 阵营和 Ceki 阵营</strong>。</div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/10/12/Java%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%AF%87/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/10/12/Java%E4%B9%8B%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%AF%87/ itemprop=url>Java系列-多线程与高并发</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-10-12 11:23:46" datetime=2024-10-12T11:23:46+08:00>2024-10-12</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2024-10-10 23:30:22" datetime=2024-10-10T23:30:22+08:00 itemprop=dateModified>2024-10-10</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E5%B9%B6%E5%8F%91/ itemprop=url rel=index><span itemprop=name>并发</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、并发编程基础><a class=headerlink href=#1、并发编程基础 title=1、并发编程基础></a>1、并发编程基础</h1><h2 id=1-1、重要概念><a class=headerlink href=#1-1、重要概念 title=1.1、重要概念></a>1.1、重要概念</h2><h3 id=1-1-1、进程><a class=headerlink href=#1-1-1、进程 title=1.1.1、进程></a>1.1.1、进程</h3><h4 id=1-1-1-1、定义><a class=headerlink href=#1-1-1-1、定义 title=1.1.1.1、定义></a>1.1.1.1、定义</h4><p><strong>系统资源分配的基本单位</strong>。<p>进程是程序的一次执行实例，它是动态的活动实体，由操作系统管理。进程不仅包括程序代码，还包括程序运行时的状态、数据、内存、CPU时间等。简单来说，程序是静态的代码，而进程是其运行时的动态表现。<h4 id=1-1-1-2、特点><a class=headerlink href=#1-1-1-2、特点 title=1.1.1.2、特点></a>1.1.1.2、特点</h4><p>进程有如下特点：<ul><li><strong>独立性</strong>：每个进程都有自己独立的地址空间，彼此间不共享内存，不同进程的资源互不干扰。<li><strong>并发性</strong>：多个进程可以同时存在并运行在一个系统中，共享处理器资源。即使在单核处理器上，通过操作系统的调度，也能表现出多个进程“同时”运行。<li><strong>动态性</strong>：进程是程序的执行过程，是动态产生和消亡的实体。程序是静态的，进程是其执行的结果，是活跃的、动态的存在。<li><strong>异步性</strong>：进程的执行是不可预测的，受系统调度的控制。即使两个相同的进程，也可能因为资源调度、优先级等原因以不同的顺序执行。<li><strong>占用资源</strong>：进程需要占用计算机的资源，包括CPU、内存、I/O设备等。</ul><h4 id=1-1-1-3、功能><a class=headerlink href=#1-1-1-3、功能 title=1.1.1.3、功能></a>1.1.1.3、功能</h4><p>进程有如下功能：<ul><li><strong>资源分配</strong>：操作系统为每个进程分配所需的资源，如内存、CPU时间、I/O设备等。<strong>进程是操作系统进行资源分配的最小单位</strong>。<li><strong>独立执行</strong>：每个进程可以独立于其他进程运行，操作系统通过调度管理多个进程的执行。<li><strong>进程间通信</strong>：为了实现合作，进程之间需要通过进程间通信（IPC）机制交换数据，比如管道、共享内存、消息队列等。<li><strong>多任务处理</strong>：通过多个进程，操作系统可以同时处理多个任务，提升系统的并发性和响应速度。</ul><h4 id=1-1-14、优缺点><a class=headerlink href=#1-1-14、优缺点 title=1.1.14、优缺点></a>1.1.14、优缺点</h4><p>优点：<ol><li><strong>提高系统效率</strong>：通过进程的并发执行，可以更好地利用CPU和其他资源，减少等待时间，提高处理效率。<li><strong>独立性和安全性</strong>：每个进程独立拥有自己的内存空间，不同进程间不直接干涉，因此进程之间的错误不会互相影响。<li><strong>多任务处理</strong>：支持并发的进程模型使得操作系统可以处理多个任务，增强系统的多任务能力。</ol><p>缺点：<ol><li><strong>开销较大</strong>：进程是独立的个体，占用大量资源，如内存、CPU时间和系统管理的开销。在频繁创建、销毁进程时，系统的性能会受到影响。<li><strong>通信复杂</strong>：进程间的通信（IPC）相对复杂，因为它们不能直接共享内存，需要通过专门的机制来传递数据，这增加了系统的复杂性和通信开销。<li><strong>切换开销高</strong>：操作系统在进程间进行上下文切换时，需要保存当前进程的状态并加载下一个进程的状态，这一操作会带来一定的时间和资源开销。</ol><blockquote><p>并发：同一时刻 只有一个进程或线程 在运行，但因 切换较快 而带给人的感觉像同时在运行。<p>并行：同一时刻 有多个进程或线程 在运行。</blockquote><h3 id=1-1-2、线程><a class=headerlink href=#1-1-2、线程 title=1.1.2、线程></a>1.1.2、线程</h3><h4 id=1-1-2-1、定义><a class=headerlink href=#1-1-2-1、定义 title=1.1.2.1、定义></a>1.1.2.1、定义</h4><p><strong>CPU调度的基本单位</strong>，它是在进程内运行的实体。每个线程都有自己的寄存器、堆栈和程序计数器，但同一个进程的多个线程共享该进程的内存地址空间和系统资源。<h4 id=1-1-2-2、特点><a class=headerlink href=#1-1-2-2、特点 title=1.1.2.2、特点></a>1.1.2.2、特点</h4><p>线程有如下特点：<ul><li><strong>轻量级</strong>：线程相比进程更轻量，它共享进程的资源，创建和销毁的开销较小，切换速度快。<li><strong>并发性</strong>：在一个进程内，多个线程可以并发运行，利用多核CPU同时执行多个线程任务，提高系统并发处理能力。<li><strong>共享性</strong>：同一进程中的多个线程共享进程的地址空间、全局变量和资源，这使得线程间通信更加高效。<li><strong>独立性</strong>：虽然线程共享内存空间，但每个线程都有自己独立的堆栈和寄存器，不同线程的执行互不干扰。</ul><h4 id=1-1-2-3、功能><a class=headerlink href=#1-1-2-3、功能 title=1.1.2.3、功能></a>1.1.2.3、功能</h4><p>线程有如下功能：<ul><li><strong>并发执行任务</strong>：通过多线程，一个进程可以同时执行多个任务，比如一个应用程序可以在后台进行文件下载，同时用户还能继续操作界面。<li><strong>高效利用多核CPU</strong>：现代多核处理器可以真正并行运行多个线程，通过多线程，程序可以同时利用多个CPU核心，提升执行效率。<li><strong>资源共享与协调</strong>：线程可以共享进程的资源和数据，便于线程间的高效通信和数据交换，适合处理需要高频数据交互的任务。<li><strong>响应式编程</strong>：多线程技术可以用于提高应用程序的响应性，比如UI主线程处理用户交互，后台线程执行耗时任务。</ul><h4 id=1-1-2-4、优缺点><a class=headerlink href=#1-1-2-4、优缺点 title=1.1.2.4、优缺点></a>1.1.2.4、优缺点</h4><p>优点：<ol><li><strong>开销小</strong>：与进程相比，线程的创建和销毁所需的系统资源较少，执行时的切换开销也较小。<li><strong>资源共享</strong>：多个线程共享同一进程的资源，这使得线程间通信非常高效，不需要像进程间通信那样使用复杂的机制。<li><strong>提高并发性能</strong>：通过多线程，应用程序可以同时执行多个任务，有效提升系统的并发处理能力，尤其是在多核处理器环境中。<li><strong>提高响应性</strong>：多线程技术使得应用程序可以快速响应用户请求，同时在后台执行其他任务，提高用户体验。</ol><p>缺点：<ol><li><strong>安全问题</strong>：由于线程共享进程的地址空间，多个线程之间的错误操作可能导致数据竞争或死锁等问题，给编程带来复杂性。<li><strong>调试难度大</strong>：多线程程序比单线程程序更难调试，因为线程的并发执行会导致无法预测的行为。<li><strong>同步开销</strong>：为了防止多个线程同时修改共享数据，需要使用同步机制（如锁、信号量），这些机制可能引入额外的开销，并导致线程间竞争。</ol><h4 id=1-1-2-5、总结><a class=headerlink href=#1-1-2-5、总结 title=1.1.2.5、总结></a>1.1.2.5、总结</h4><p>线程与进程的区别与对比如下表所示：<table><thead><tr><th align=center>特性<th align=center>进程<th align=center>线程<tbody><tr><td align=center>内存<td align=center>拥有独立的地址空间<td align=center>共享进程的地址空间<tr><td align=center>创建开销<td align=center>创建和销毁开销较大，分配资源多<td align=center>开销小，创建速度块<tr><td align=center>切换开销<td align=center>需要切换内存地址空间<td align=center>只需要少量上下文切换<tr><td align=center>通信方式<td align=center>进程间通信复杂，需要专门的机制<td align=center>线程间通信简单，直接共享数据<tr><td align=center>独立性<td align=center>进程相对独立，错误互不影响<td align=center>线程共享进程资源，错误可能会相互影响</table><h3 id=1-1-3、协程（Coroutine）><a class=headerlink href=#1-1-3、协程（Coroutine） title=1.1.3、协程（Coroutine）></a>1.1.3、协程（Coroutine）</h3><h4 id=1-1-3-1、定义><a class=headerlink href=#1-1-3-1、定义 title=1.1.3.1、定义></a>1.1.3.1、定义</h4><p><strong>最初多数用户线程被设计成协同式调度 （Cooperative Scheduling），故起名为协程（Coroutine）</strong>。由于协程会做调用栈保护、恢复工作，故又称为有栈协程（Stackfull Coroutine），相反也有无栈协程（Stackless Coroutine）。<blockquote><p>有栈协程有一种实现称为 纤程（Fiber）。</blockquote><p>协程是一种可以在执行过程中暂停、并在将来某个时间点继续执行的程序组件。与线程不同，协程的切换由程序显式控制，而不是由操作系统调度器决定。协程的设计使得它非常适合用于非阻塞异步编程。<h4 id=1-1-3-2、特点><a class=headerlink href=#1-1-3-2、特点 title=1.1.3.2、特点></a>1.1.3.2、特点</h4><p>协程有如下特点：<ul><li><strong>轻量性</strong>：协程比线程更轻量，因为它不需要操作系统内核的调度和上下文切换，创建和切换的开销更小。<li><strong>非抢占式</strong>：协程的切换由程序员显式控制，只有协程主动让出执行权时才会发生切换。这与线程的抢占式调度不同，线程的切换由操作系统控制。<li><strong>单线程并发</strong>：协程通常在一个单线程环境中实现并发，它在同一个线程内切换，而不会真正同时运行多个任务。协程通过快速切换来实现高效的任务调度。<li><strong>更高效的资源利用</strong>：由于协程不需要系统内核参与调度，减少了上下文切换和系统调用的开销，因此它能更高效地利用CPU和内存资源。</ul><h4 id=1-1-3-3、功能><a class=headerlink href=#1-1-3-3、功能 title=1.1.3.3、功能></a>1.1.3.3、功能</h4><p>协程有如下功能：<ul><li><strong>异步任务处理</strong>：协程适用于处理大量的异步I/O操作，如网络请求、文件操作等。协程可以在等待I/O操作完成时让出执行权，避免阻塞整个程序。<li><strong>简化并发编程</strong>：相比传统的多线程或回调方式，协程的代码结构更加线性和清晰，避免了回调地狱等问题。<li><strong>高效协作</strong>：协程之间可以通过显式的调用相互切换，实现高效的任务协作。它们在需要时暂停，而不需要等待整个线程或进程完成。<li><strong>并行处理</strong>：通过协程，多个任务可以在一个线程内并发执行，协程快速切换任务以达到并行处理的效果。</ul><h4 id=1-1-3-4、优缺点><a class=headerlink href=#1-1-3-4、优缺点 title=1.1.3.4、优缺点></a>1.1.3.4、优缺点</h4><p>优点：<ol><li><strong>开销小</strong>：协程切换只发生在用户态，不涉及操作系统内核，因此切换的开销非常小。协程也不需要操作系统为其分配额外的资源，像内存、CPU等资源共享单个线程。<li><strong>更简单的并发模型</strong>：协程使得代码结构更直观，开发者可以像写同步代码一样处理异步操作，避免了回调地狱问题。<li><strong>高效处理I/O密集型任务</strong>：协程在执行I/O密集型任务时表现尤为优异，因为它可以在等待I/O时切换到其他任务执行，最大化CPU利用率。<li><strong>避免线程安全问题</strong>：由于协程通常运行在单线程环境中，不涉及多线程并发问题，因此不需要像线程那样使用锁或其他同步机制来保证数据一致性。</ol><p>缺点：<ol><li><strong>不适合CPU密集型任务</strong>：协程在处理CPU密集型任务时表现不如多线程，因为它不能利用多核处理器的并行性。在这种情况下，线程或进程可能更合适。<li><strong>需要显式控制切换</strong>：协程的切换是显式的，由程序员控制。如果编写不当，可能导致协程阻塞或无法切换，影响程序执行。<li><strong>依赖语言和库的支持</strong>：并不是所有的编程语言都原生支持协程，某些语言需要通过第三方库或框架来实现协程功能。</ol><h4 id=1-1-3-5、示例代码><a class=headerlink href=#1-1-3-5、示例代码 title=1.1.3.5、示例代码></a>1.1.3.5、示例代码</h4><p>在Java中，传统上并没有原生的协程支持，但可以通过类似的机制来实现类似协程的效果。Java 19引入了<strong>Project Loom</strong>，它提供了一种称为<strong>虚拟线程（Virtual Threads）</strong>的轻量级线程，它们的行为和协程非常相似。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.ExecutorService;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.Executors;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CoroutineDemo</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> InterruptedException {</span><br><span class=line>        <span class=comment>// 创建一个虚拟线程的执行器</span></span><br><span class=line>        <span class=keyword>try</span> (<span class=type>ExecutorService</span> <span class=variable>executor</span> <span class=operator>=</span> Executors.newVirtualThreadPerTaskExecutor()) {</span><br><span class=line></span><br><span class=line>            <span class=comment>// 启动第一个虚拟线程</span></span><br><span class=line>            executor.submit(() -> {</span><br><span class=line>                System.out.println(<span class=string>"Coroutine 1: 开始执行"</span>);</span><br><span class=line>                <span class=keyword>try</span> {</span><br><span class=line>                    Thread.sleep(<span class=number>1000</span>); <span class=comment>// 模拟协程中的挂起</span></span><br><span class=line>                } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>                    e.printStackTrace();</span><br><span class=line>                }</span><br><span class=line>                System.out.println(<span class=string>"Coroutine 1: 结束执行"</span>);</span><br><span class=line>            });</span><br><span class=line></span><br><span class=line>            <span class=comment>// 启动第二个虚拟线程</span></span><br><span class=line>            executor.submit(() -> {</span><br><span class=line>                System.out.println(<span class=string>"Coroutine 2: 开始执行"</span>);</span><br><span class=line>                <span class=keyword>try</span> {</span><br><span class=line>                    Thread.sleep(<span class=number>2000</span>); <span class=comment>// 模拟协程中的挂起</span></span><br><span class=line>                } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>                    e.printStackTrace();</span><br><span class=line>                }</span><br><span class=line>                System.out.println(<span class=string>"Coroutine 2: 结束执行"</span>);</span><br><span class=line>            });</span><br><span class=line>            </span><br><span class=line>            System.out.println(<span class=string>"主线程: 正在等待协程完成"</span>);</span><br><span class=line>            <span class=comment>// 注意：虚拟线程会自动调度，因此主线程可以等待所有任务完成</span></span><br><span class=line>        }</span><br><span class=line>        System.out.println(<span class=string>"主线程: 所有协程已完成"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h4 id=1-1-3-6、总结><a class=headerlink href=#1-1-3-6、总结 title=1.1.3.6、总结></a>1.1.3.6、总结</h4><p>协程与线程的区别与对比如下表所示：<table><thead><tr><th align=center>特性<th align=center>线程<th align=center>协程<tbody><tr><td align=center>调度方式<td align=center>操作系统内核调度，抢占式。<td align=center>用户态调度，非抢占式。<tr><td align=center>创建开销<td align=center>需要操作系统分配资源。<td align=center>在用户态中创建，开销小。<tr><td align=center>切换开销<td align=center>需要内核态上下文切换。<td align=center>在用户态中完成切换，开销小。<tr><td align=center>并发模型<td align=center>多线程并发，通过多核CPU实现。<td align=center>单线程并发，适合IO密集型任务。<tr><td align=center>资源占用<td align=center>每个线程占用独立的系统资源。<td align=center>多个协程共用同一个线程资源。<tr><td align=center>安全性<td align=center>需要处理多线程并发问题，如死锁。<td align=center>协程一般运行在单线程中，不涉及锁问题。</table><h3 id=1-1-4、纤程（Fiber）><a class=headerlink href=#1-1-4、纤程（Fiber） title=1.1.4、纤程（Fiber）></a>1.1.4、纤程（Fiber）</h3><h4 id=1-1-4-1、定义><a class=headerlink href=#1-1-4-1、定义 title=1.1.4.1、定义></a>1.1.4.1、定义</h4><p>纤程（Fiber）是一种用户态实现的轻量级线程，它是多任务执行的基本单位，可以在用户态下进行调度，而不依赖操作系统内核的线程调度。与传统的操作系统线程不同，纤程的切换完全由应用程序自行控制。它们通常运行在单一的操作系统线程中，由用户空间库或运行时系统调度。<p><strong>纤程本质上是协程的实现方式之一</strong>，它通过手动控制上下文切换实现任务的并发。相比线程，纤程更加轻量，因此可以在一个系统线程中运行大量纤程。<h4 id=1-1-4-2、特点><a class=headerlink href=#1-1-4-2、特点 title=1.1.4.2、特点></a>1.1.4.2、特点</h4><p>纤程有如下特点：<ul><li><strong>用户态调度</strong>：与线程不同，纤程的调度完全由用户空间库或程序控制，而不依赖于操作系统内核。这种自主调度减少了上下文切换的开销。<li><strong>轻量级</strong>：纤程是比线程更轻量的执行单元。它的创建、销毁、切换开销极小，因此可以在一个线程中管理成千上万的纤程。<li><strong>非抢占式</strong>：纤程的切换是非抢占式的，也就是说纤程必须显式地让出CPU（类似于协程的<code>yield</code>操作）。这意味着程序员需要手动控制何时切换到其他纤程。<li><strong>与操作系统线程并存</strong>：纤程通常是在单个操作系统线程中实现并发的，这意味着操作系统只能看到这个线程在运行，而无法感知线程内纤程的调度。<li><strong>栈共享和切换</strong>：每个纤程通常有自己的栈，但相对于操作系统线程，栈的大小要小得多。纤程的上下文切换仅涉及保存和恢复寄存器状态，以及栈指针的切换，这使得切换非常高效。</ul><h4 id=1-1-4-3、功能><a class=headerlink href=#1-1-4-3、功能 title=1.1.4.3、功能></a>1.1.4.3、功能</h4><p>纤程有如下特点：<ul><li><strong>并发任务处理</strong>：纤程允许程序在一个线程中并发执行大量任务，例如I/O操作或计算任务。它特别适合在处理I/O密集型任务时实现并发处理。<li><strong>高效利用单核CPU</strong>：纤程在单核CPU上非常有效，因为它避免了线程调度带来的上下文切换开销，可以快速在任务之间切换。<li><strong>复杂任务调度</strong>：通过用户态调度机制，纤程可以让程序更精确地控制任务切换和执行顺序，特别适用于一些对任务调度有特殊需求的场景，比如游戏开发或仿真系统。<li><strong>资源共享和协作</strong>：由于纤程是在一个线程中运行的，它们可以轻松地共享数据，且不需要使用锁等复杂的同步机制，从而减少了线程竞争带来的问题。</ul><h4 id=1-1-4-4、优缺点><a class=headerlink href=#1-1-4-4、优缺点 title=1.1.4.4、优缺点></a>1.1.4.4、优缺点</h4><p>优点：<ol><li><strong>更小的开销</strong>：相比线程，纤程的创建、销毁和切换开销极小，因为它们运行在用户态，不需要操作系统内核参与。这使得纤程可以在一个线程中管理成千上万个任务。<li><strong>高并发处理</strong>：纤程特别适用于I/O密集型任务，可以实现非常高的并发，且不会像线程那样消耗大量的系统资源（如内存和CPU）。<li><strong>避免锁和同步问题</strong>：因为纤程通常在同一个线程中执行，不涉及多线程并发问题，因此不需要复杂的同步机制，如锁、信号量等。这使得开发者可以编写更简单的并发代码。<li><strong>用户态控制</strong>：纤程的调度完全由程序控制，开发者可以精确决定何时让出执行权，从而可以根据应用的特定需求优化性能。</ol><p>缺点：<ol><li><strong>不能利用多核CPU</strong>：纤程通常运行在单个线程中，因此它们无法充分利用多核CPU的并行能力。如果需要利用多核，通常需要结合多线程或多进程来使用纤程。<li><strong>非抢占式调度</strong>：纤程是非抢占式的，这意味着如果某个纤程没有显式让出执行权，其他纤程就无法得到执行机会。编写纤程程序时，开发者需要非常小心地控制任务切换，否则可能导致程序阻塞。<li><strong>依赖用户库</strong>：纤程通常依赖于特定的编程语言或用户态库的支持，不同的语言和运行时对纤程的支持情况有所不同。这可能导致可移植性的问题。</ol><h4 id=1-1-4-5、应用场景><a class=headerlink href=#1-1-4-5、应用场景 title=1.1.4.5、应用场景></a>1.1.4.5、应用场景</h4><p>纤程应用场景如下：<ul><li><strong>高并发网络服务</strong>：纤程在处理高并发网络请求时非常高效。例如，使用纤程模型的服务器可以在单个线程中同时处理数以万计的网络连接，而不会像线程模型那样消耗大量的内存。<li><strong>嵌入式系统和游戏开发</strong>：纤程可以用于嵌入式系统和游戏开发中，在这些场景下，任务的调度和执行往往需要精细控制，纤程的用户态调度和轻量性非常适合。<li><strong>仿真和模拟系统</strong>：在仿真和模拟系统中，多个任务的并行和精细调度至关重要。纤程可以在单线程中高效处理多个独立的仿真任务。</ul><h4 id=1-1-4-6、示例代码><a class=headerlink href=#1-1-4-6、示例代码 title=1.1.4.6、示例代码></a>1.1.4.6、示例代码</h4><p>在Java中，纤程（Fiber）并不是原生支持的概念，但你可以使用一些第三方库来实现类似的功能。一个常用的库是 <strong>Quasar</strong>，它允许你在Java中使用纤程。<p>加入依赖：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.knowm<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>quasar-core<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>0.8.0<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><p>Java代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> co.paralleluniverse.fibers.Fiber;</span><br><span class=line><span class=keyword>import</span> co.paralleluniverse.fibers.Suspendable;</span><br><span class=line><span class=keyword>import</span> co.paralleluniverse.strands.Strand;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">FiberDemo</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=comment>// 创建并启动第一个纤程</span></span><br><span class=line>        Fiber&LTVoid> fiber1 = <span class=keyword>new</span> <span class="title class_">Fiber</span><>(FiberDemo::runFiber1);</span><br><span class=line>        fiber1.start();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 创建并启动第二个纤程</span></span><br><span class=line>        Fiber&LTVoid> fiber2 = <span class=keyword>new</span> <span class="title class_">Fiber</span><>(FiberDemo::runFiber2);</span><br><span class=line>        fiber2.start();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 等待纤程完成</span></span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            fiber1.join();</span><br><span class=line>            fiber2.join();</span><br><span class=line>        } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>            e.printStackTrace();</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        System.out.println(<span class=string>"主线程: 所有纤程已完成"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Suspendable</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">runFiber1</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"纤程 1: 开始执行"</span>);</span><br><span class=line>        Strand.sleep(<span class=number>1000</span>); <span class=comment>// 模拟挂起</span></span><br><span class=line>        System.out.println(<span class=string>"纤程 1: 结束执行"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Suspendable</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">runFiber2</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"纤程 2: 开始执行"</span>);</span><br><span class=line>        Strand.sleep(<span class=number>2000</span>); <span class=comment>// 模拟挂起</span></span><br><span class=line>        System.out.println(<span class=string>"纤程 2: 结束执行"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>如果你在命令行中运行此代码，需要使用 Quasar 的 <code>java -javaagent</code> 参数来激活纤程支持。例如：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -javaagent:path/to/quasar-core-0.8.0.jar -<span class=built_in>cp</span> your-classpath FiberDemo</span><br></pre></table></figure><h3 id=1-1-5、管程（Monitor）><a class=headerlink href=#1-1-5、管程（Monitor） title=1.1.5、管程（Monitor）></a>1.1.5、管程（Monitor）</h3><h4 id=1-1-5-1、定义><a class=headerlink href=#1-1-5-1、定义 title=1.1.5.1、定义></a>1.1.5.1、定义</h4><p>管程是一种<strong>高层次的同步原语</strong>，可以看作是一个对象，它包括以下部分：<ol><li><strong>共享资源</strong>：需要多个线程访问的变量或资源。<li><strong>入口程序（Entry procedures）</strong>：对共享资源的操作函数，这些函数是同步的，也就是说一次只能有一个线程执行其中的操作。<li><strong>条件变量（Condition variables）</strong>：用于线程间通信，使线程可以等待某个条件的发生或通知其他线程某个条件已经发生。<li><strong>互斥锁</strong>：确保同一时刻只能有一个线程进入管程执行。</ol><p>通过管程，多个线程可以对共享资源进行<strong>互斥访问</strong>，并且可以通过条件变量协调对资源的访问顺序，从而避免死锁和竞态条件等问题。比如，生产者与消费者模型就可以很好的体现。<h4 id=1-1-5-2、特点><a class=headerlink href=#1-1-5-2、特点 title=1.1.5.2、特点></a>1.1.5.2、特点</h4><p>管程的特点如下：<ul><li><strong>互斥访问</strong>：管程确保在任何时刻，只有一个线程可以进入并执行管程内的代码。这是通过隐式的锁机制实现的，用户不需要显式地加锁和解锁。<li><strong>条件同步</strong>：管程提供了条件变量来协调线程之间的等待和唤醒。当某个线程在等待某个条件时，它可以通过管程的条件变量进行等待，直到条件满足后被其他线程唤醒。<li><strong>自动锁管理</strong>：管程通常自动管理锁的获取和释放，当线程进入管程时，自动获取锁；当线程退出管程时，自动释放锁。这简化了线程同步的操作，减少了手动处理锁的复杂性。</ul><h4 id=1-1-5-3、工作原理><a class=headerlink href=#1-1-5-3、工作原理 title=1.1.5.3、工作原理></a>1.1.5.3、工作原理</h4><p>管程工厂原理描述如下：<ul><li>当线程需要访问共享资源时，它会调用管程的入口程序。<li>进入管程时，线程会自动获取管程的锁，保证对共享资源的互斥访问。<li>在管程的入口程序中，线程可以使用条件变量进行等待或被唤醒。<li>当线程退出管程时，锁会自动释放，使得其他等待的线程可以进入管程。<li>如果一个线程由于条件未满足而需要等待，它会在管程的条件变量上调用<code>wait()</code>，释放当前锁并等待其他线程的通知。当条件满足时，线程会被唤醒并重新尝试获取锁。</ul><h4 id=1-1-5-4、功能><a class=headerlink href=#1-1-5-4、功能 title=1.1.5.4、功能></a>1.1.5.4、功能</h4><p>管程有如下功能：<ul><li><p><strong>互斥访问控制</strong>：管程确保多个线程对共享资源的互斥访问，防止数据竞争和不一致问题。</p><li><p><strong>同步线程执行</strong>：通过条件变量，管程可以协调多个线程的执行顺序，确保特定条件得到满足后再执行某些操作。</p><li><p><strong>简化并发编程</strong>：管程隐藏了底层的锁和条件变量的实现细节，提供了简单的接口，开发者不必显式管理锁的获取与释放，减少了编写并发程序的复杂性。</p></ul><h4 id=1-1-5-5、优缺点><a class=headerlink href=#1-1-5-5、优缺点 title=1.1.5.5、优缺点></a>1.1.5.5、优缺点</h4><p>优点：<ol><li><strong>简化并发控制</strong>：管程封装了同步机制，减少了程序员管理互斥锁和条件变量的复杂性，大大简化了并发编程。<li><strong>互斥和同步的有机结合</strong>：管程集成了互斥锁和条件变量，能够同时解决多个线程对共享资源的互斥访问和条件同步问题，提供了结构化的并发控制方式。<li><strong>更高的安全性</strong>：管程的自动锁管理和对条件变量的支持减少了手动编写同步代码时可能引发的死锁、竞态条件等错误。</ol><p>缺点：<ol><li><strong>局限性</strong>：管程在处理大规模并发场景时，可能面临性能瓶颈，因为它只能保证一次一个线程进入管程执行。如果管程内的操作较为耗时，其他线程就会处于阻塞状态，影响系统的并发性。<li><strong>条件变量的复杂性</strong>：尽管管程减少了锁的使用复杂度，但条件变量的使用仍然需要程序员手动处理。错误使用条件变量可能导致死锁或条件丢失问题。<li><strong>性能开销</strong>：管程通过互斥锁保证互斥访问，锁的竞争可能带来一定的性能开销，特别是在高并发场景中。</ol><h4 id=1-1-5-6、应用场景><a class=headerlink href=#1-1-5-6、应用场景 title=1.1.5.6、应用场景></a>1.1.5.6、应用场景</h4><p>管程应用场景如下：<ul><li><strong>生产者-消费者问题</strong>：生产者-消费者问题是典型的多线程同步问题，管程可以通过互斥访问缓冲区和条件变量的等待与通知，来实现生产者与消费者之间的协调。<li><strong>读者-写者问题</strong>：在解决读者写者问题时，管程可以用来确保多个读者能够同时读，而写者在写入时独占资源。管程通过条件变量实现对读写操作的同步。<li><strong>并发数据结构</strong>：管程可用于构建并发数据结构，例如并发队列、并发栈等。通过管程对共享资源的封装，确保多个线程对数据结构的安全操作。</ul><h3 id=1-1-6、超线程><a class=headerlink href=#1-1-6、超线程 title=1.1.6、超线程></a>1.1.6、超线程</h3><p><strong>超线程（Hyper-Threading，简写HT）是Intel公司为CPU设计的一项技术，旨在提高每个处理器核心的性能</strong>。超线程技术允许单个物理核心模拟多个逻辑核心，从而能够并行处理多个线程。<p>背景：传统单核CPU中，当一个线程等待数据时核心会处于闲置状态。超线程的出现就是为了利用这种等待时间，使得CPU可以处理另一个线程，提高CPU的利用率。<p>工作原理：<ol><li>超线程技术允许CPU具有多于一个的线程执行单元，使得单个物理核心可以执行多个线程。<li>当一个线程因等待数据或其它原因被阻塞时，另一个线程可以使用该核心的资源，增加了核心利用率。<li>通过超线程技术进一步提升了处理器的工作效率和吞吐量。</ol><h2 id=1-2、线程基础><a class=headerlink href=#1-2、线程基础 title=1.2、线程基础></a>1.2、线程基础</h2><h3 id=1-2-1、线程优先级><a class=headerlink href=#1-2-1、线程优先级 title=1.2.1、线程优先级></a>1.2.1、线程优先级</h3><p>如今的操作系统基本<strong>采用时间片规则来调度运行线程</strong>，操作系统会分出多个时间片，然后分配给每个线程，当线程的时间片用完了就会发生线程调度，并等待着下次分配。线程得到时间片的多少就决定了线程能使用处理器资源的多少，而线程优先级就可以<strong>一定程度</strong>上决定线程得到时间片的多少。<p><strong>Java线程可通过变量<code>priority</code>来控制优先级，优先级范围从1至10。创建线程时可通过方法<code>setPriority(int)</code>来设置优先级，默认优先级为5，优先级高的线程得到时间片的数量要多于优先级低的线程</strong>。<p>针对频繁阻塞（休眠或I/O操作）的线程需要设置较高的优先级，而偏重计算（需要较多CPU时间）的线程则可以设置较低的优先级，以确保处理器不会被独占，如此一来，就可以尽可能实现时间片的公平。<p><font color=red>注意：线程优先级的设定并非一定起作用，因为操作系统不一定会重视。</font><h3 id=1-2-2、线程状态><a class=headerlink href=#1-2-2、线程状态 title=1.2.2、线程状态></a>1.2.2、线程状态</h3><p><img alt=image-20210426211305027 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210426211305027.png?token=AIGEF3PT62JG3PZWEBS73BLEZZXC4><p>Java线程在整个生命周期中有6种不同的状态，某一个时间， 线程只能处于其中的一个状态。<ol><li><p><strong>NEW（初始状态）</strong>：线程被构建，但没有调用start方法。</p><li><p><strong>RUNNABLE（运行状态）</strong>：Java线程将就绪和运行两种状态统称为“运行中”。</p><li><p><strong>BLOCKED（阻塞状态）</strong>：表示线程阻塞于锁。</p><li><p><strong>WAITING（等待状态）</strong>：表示当前线程需要等待其它线程做出一些特定操作（通知或中断）。</p><li><p><strong>TIME_WAITING（超时等待状态）</strong>：该状态不同于WAITING，它可以在指定时间内自动返回。</p><li><p><strong>TERMINATED（终止状态）</strong>：表示当前线程已经执行完毕。</p></ol><h3 id=1-2-3、daemon线程><a class=headerlink href=#1-2-3、daemon线程 title=1.2.3、daemon线程></a>1.2.3、daemon线程</h3><p>Daemon（守护）线程是一种支持型线程，主要被用于程序后台调度及支持性工作。当Java虚拟机中不存在非Daemon线程时，Java虚拟机将会退出。可通过调用<code>Thread.setDaemon(true)</code>将线程设置为Daemon线程。<p><font color=red>注意：Daemon属性需要在线程启动之前设置。Java虚拟机退出时Daemon线程中的finally块并不一定会执行。</font><h3 id=1-2-4、启动线程><a class=headerlink href=#1-2-4、启动线程 title=1.2.4、启动线程></a>1.2.4、启动线程</h3><h4 id=1-2-4-1、启动方式><a class=headerlink href=#1-2-4-1、启动方式 title=1.2.4.1、启动方式></a>1.2.4.1、启动方式</h4><p>启动一个线程的示例代码如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.Callable;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.ExecutorService;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.Executors;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.FutureTask;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">T02_HowToCreateThread</span> {</span><br><span class=line>    <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">MyThread</span> <span class=keyword>extends</span> <span class="title class_">Thread</span> {</span><br><span class=line>        <span class=meta>@Override</span></span><br><span class=line>        <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">run</span><span class=params>()</span> {</span><br><span class=line>            System.out.println(<span class=string>"Hello MyThread!"</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">MyRun</span> <span class=keyword>implements</span> <span class="title class_">Runnable</span> {</span><br><span class=line>        <span class=meta>@Override</span></span><br><span class=line>        <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">run</span><span class=params>()</span> {</span><br><span class=line>            System.out.println(<span class=string>"Hello MyRun!"</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">MyCall</span> <span class=keyword>implements</span> <span class="title class_">Callable</span>&LTString> {</span><br><span class=line>        <span class=meta>@Override</span></span><br><span class=line>        <span class=keyword>public</span> String <span class="title function_">call</span><span class=params>()</span> {</span><br><span class=line>            System.out.println(<span class=string>"Hello MyCall"</span>);</span><br><span class=line>            <span class=keyword>return</span> <span class=string>"success"</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>//启动线程的5种方式</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=comment>// 方式1：继承thread类</span></span><br><span class=line>        <span class=keyword>new</span> <span class="title class_">MyThread</span>().start();</span><br><span class=line>        <span class=comment>// 方式2：实现runnable接口</span></span><br><span class=line>        <span class=keyword>new</span> <span class="title class_">Thread</span>(<span class=keyword>new</span> <span class="title class_">MyRun</span>()).start();</span><br><span class=line>        <span class=comment>// 方式3：匿名类</span></span><br><span class=line>        <span class=keyword>new</span> <span class="title class_">Thread</span>(()->{</span><br><span class=line>            System.out.println(<span class=string>"Hello Lambda!"</span>);</span><br><span class=line>        }).start();</span><br><span class=line>		<span class=comment>// 方式4：实现callable接口</span></span><br><span class=line>        <span class=type>Thread</span> <span class=variable>t</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Thread</span>(<span class=keyword>new</span> <span class="title class_">FutureTask</span>&LTString>(<span class=keyword>new</span> <span class="title class_">MyCall</span>()));</span><br><span class=line>        t.start();</span><br><span class=line>        <span class=comment>// 方式5：通过线程池启动</span></span><br><span class=line>        <span class=type>ExecutorService</span> <span class=variable>service</span> <span class=operator>=</span> Executors.newCachedThreadPool();</span><br><span class=line>        service.execute(()->{</span><br><span class=line>            System.out.println(<span class=string>"Hello ThreadPool"</span>);</span><br><span class=line>        });</span><br><span class=line>        service.shutdown();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h4 id=1-2-4-2、Callable的使用><a class=headerlink href=#1-2-4-2、Callable的使用 title=1.2.4.2、Callable的使用></a>1.2.4.2、Callable的使用</h4><p>接口Callable是一个单独的接口，与之相关的类内部结构图可参考如下：<p><img alt=image-20210706113047202 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210706113047202.png?token=AIGEF3IIKOSDUDGRO73RRQTEZZXEK><p>Callable使用示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">MyCallable</span> <span class=keyword>implements</span> <span class="title class_">Callable</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">call</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>int</span> <span class=variable>sum</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>1</span>; i <= <span class=number>100</span>; i++){</span><br><span class=line>            <span class=keyword>if</span> (i % <span class=number>2</span> == <span class=number>0</span>){</span><br><span class=line>                sum += i;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> sum;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=comment>// 启动类</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">StartThreadByCallable</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>MyCallable</span> <span class=variable>callable</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">MyCallable</span>();</span><br><span class=line>        <span class=type>FutureTask</span> <span class=variable>futureTask</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">FutureTask</span><>(callable);</span><br><span class=line>        <span class=keyword>new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class=line></span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            <span class=type>Object</span> <span class=variable>result</span> <span class=operator>=</span> futureTask.get();</span><br><span class=line>            System.out.println(<span class=string>"result: "</span> + result);</span><br><span class=line>        }<span class=keyword>catch</span> (InterruptedException | ExecutionException e){</span><br><span class=line>            e.printStackTrace();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-5、理解中断><a class=headerlink href=#1-2-5、理解中断 title=1.2.5、理解中断></a>1.2.5、理解中断</h3><p>中断可理解为线程的标识位属性，它表示一个运行中的线程是否被其他线程执行了中断操作。通过调用线程的<code>interrupt()</code>方法可以实现中断线程的操作。<p>线程通过检查自身是否被中断来进行响应，方法<code>isInterrupted()</code>返回线程是否被中断，静态方法<code>Thread.interrupted()</code>返回当前线程的中断状态，并将中断标识设为false。<p><font color=red>注意：终结状态下的线程，即使曾经被中断过，那么方法 isInterrupted() 依旧会返回false。</font><h3 id=1-2-6、过期方法><a class=headerlink href=#1-2-6、过期方法 title=1.2.6、过期方法></a>1.2.6、过期方法</h3><p>suspend()、resume() 和 stop()方法可以实现线程的暂停、恢复和终止。但这些API已经过期，不建议使用。<p>不推荐原因：<font color=red>调用方法suspend()后线程会占用资源进入睡眠状态，易引发死锁问题。stop()方法在终结线程时不能保证正常释放线程资源。</font><blockquote><p>暂停和恢复操作可以用 等待/通知 机制来替代。</blockquote><h3 id=1-2-7、安全终止线程><a class=headerlink href=#1-2-7、安全终止线程 title=1.2.7、安全终止线程></a>1.2.7、安全终止线程</h3><p><strong>通过 标识位或中断操作  可以实现线程终止时有机会清理资源，而非立即停止。这种方法更加安全和优雅</strong>。<h3 id=1-2-8、小结><a class=headerlink href=#1-2-8、小结 title=1.2.8、小结></a>1.2.8、小结</h3><p>可中断的场景如下：<ol><li>Lock<li>Object相关方法（wait）<li>Thread相关方法（join、sleep）</ol><p>不可中断场景如下：<ol><li>synchronized锁</ol><h2 id=1-3、线程通信><a class=headerlink href=#1-3、线程通信 title=1.3、线程通信></a>1.3、线程通信</h2><h3 id=1-3-1、volatile-synchronized><a class=headerlink href=#1-3-1、volatile-synchronized title=1.3.1、volatile/synchronized></a>1.3.1、volatile/synchronized</h3><ul><li><p><strong>volatile</strong>：关键字volatile 可修饰字段，访问该变量时需要从共享内存中获取，对该变量的修改必须同步刷新至共享内存，它能保证所有线程对变量访问的可见性。</p><li><p><strong>synchronized</strong>：关键字synchronized可修饰方法 或 以同步块形式使用，可保证多个线程在同一时刻只能有一个线程可以处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p></ul><h3 id=1-3-2、等待-通知机制及范式><a class=headerlink href=#1-3-2、等待-通知机制及范式 title=1.3.2、等待/通知机制及范式></a>1.3.2、等待/通知机制及范式</h3><h4 id=1-3-2-1、等待通知机制><a class=headerlink href=#1-3-2-1、等待通知机制 title=1.3.2.1、等待通知机制></a>1.3.2.1、等待通知机制</h4><p>等待/通知机制是指：<strong>线程A调用对象O的wait()方法后会进入等待状态，线程B调用对象O的notify()或notifyAll()方法后会通知线程A结束等待继续执行</strong>。<p>调用wait()、notify()、notifyAll()时的注意事项如下：<ol><li>使用 wait()、notify() 和 notifyAll() 时需要先对调用对象加锁。<li>调用 wait() 方法后，会将当前线程放入对象的 等待队列，线程状态由RUNNING变为WAITING。<li>调用 notify()、notifyAll() 方法的线程释放锁之后，等待锁的线程才会从wait()返回。<li>notify()方法会将等待队列中的一个等待线程移到同步队列中，而notifyAll() 方法会作用于全部线程，被移动线程的状态会由WAITING变为 BLOCKED。<li>获得调用对象的锁后才能从wait()方法返回。</ol><h4 id=1-3-2-2、等待通知范式><a class=headerlink href=#1-3-2-2、等待通知范式 title=1.3.2.2、等待通知范式></a>1.3.2.2、等待通知范式</h4><p><strong>范式分为两部分：等待方（消费者）、通知方（生产者）</strong>。<p>（1）等待方<ol><li>获取对象的锁；<li>如果条件不满足，那么调用对象的wait方法，被通知后仍要检查条件；<li>条件满足则执行对应的逻辑；</ol><p>（2）通知方<ol><li>获得对象的锁；<li>改变条件；<li>通知所有等待在对象上的线程；</ol><h3 id=1-3-3、管道输入-输出流><a class=headerlink href=#1-3-3、管道输入-输出流 title=1.3.3、管道输入/输出流></a>1.3.3、管道输入/输出流</h3><p><strong>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流的不同之处在于，基于内存实现线程间的数据传输</strong>。<p>管道输入/输出流主要包括了4种具体实现：<ul><li>面向字节：PipedInputStream、PipedOutputStream；<li>面向字符：PipedReader、PipedWriter；</ul><h3 id=1-3-4、Thread-join><a class=headerlink href=#1-3-4、Thread-join title=1.3.4、Thread.join></a>1.3.4、Thread.join</h3><p><strong>线程A执行thread.join()方法表示：线程A等待thread线程终止之后才从thread.join()返回</strong>。<p>除了<code>join()</code>方法外，还提供了<code>join(long millis)</code>和<code>join(long millis, int nanos)</code>两个超时方法。两个超时方法作用：如果线程在给定的超时时间内没有终止，那么会直接返回。<h3 id=1-3-5、ThreadLocal><a class=headerlink href=#1-3-5、ThreadLocal title=1.3.5、ThreadLocal></a>1.3.5、ThreadLocal</h3><p>ThreadLocal是一个以ThreadLocal对象为键、任意对象为值的存储结构。该结构存在于线程上，故一个线程可以依据一个ThreadLocal对象来查询绑定在该线程上的数据。<p>对于线程A，可以通过A.set(T)方法来设置一个值，然后通过A.get()方法获取到原先设置的值。<h1 id=2、CPU><a class=headerlink href=#2、CPU title=2、CPU></a>2、CPU</h1><h2 id=2-1、缓存行><a class=headerlink href=#2-1、缓存行 title=2.1、缓存行></a>2.1、缓存行</h2><h3 id=2-1-1、概述><a class=headerlink href=#2-1-1、概述 title=2.1.1、概述></a>2.1.1、概述</h3><p><strong>CPU缓存行是计算机体系架构中的一个概念，用于描述主存储器和CPU缓存之间的数据传输单位</strong>。缓存行是CPU缓存中最小的可寻址单位，也是一次从主存储器中读取数据块的大小。<p><strong>缓存行的大小是固定的，通常为32字节或64字节，具体取决于CPU设计。缓存行是按连续的内存地址来分割主存储器，且在CPU缓存中以相同方式进行组织。</strong><blockquote><p>为何CPU缓存行大小通常为64字节？原因分析有以下几点：<ul><li><strong>空间局部性</strong>。相邻数据被访问的可能性较大，一次加载连续的内存数据到缓存行中，可以利用这种局部性，减少对主存储器的访问次数，提高数据访问效率。<li><strong>数据传输效率</strong>。CPU与主存储器之间的数据传递是通过总线进行了，总线传输带宽是有限的，一次性加载较大的缓存行可以充分利用总线的宽度，减少数据传输的次数，提高数据传输效率。<li><strong>缓存行对齐</strong>。通常来说，数据的访问需要满足对齐要求。对齐要求是指数据存储在内存中的起始地址必需是某个值（缓存行大小）的倍数。如果不满足对齐要求，CPU需要做额外的工作来获取正确的数据，这增加了访问延迟。通过设定缓存行大小为64字节，可以确保大多数数据类型都能满足对齐要求。<li><strong>缓存容量与成本均衡</strong>。增加缓存行的大小可以提高缓存命中率，提高数据访问效率。但较大的缓存行也会占用更多的缓存容量。通过选择适当的缓存行大小，可以在缓存容量和性能之间取得平衡。</ul></blockquote><p><strong>当CPU需要从主存储器中读取数据时，它会以缓存行为单位进行操作。</strong>如果要读取的数据位于缓存行中，CPU会一次性将整个缓存行加载到CPU缓存中，后期需要读取相邻数据时可直接从缓存中读取，提高了读取效率。<p><strong>缓存行的引入是为了解决主存储器与CPU之间速度差异的问题。</strong>但缓存行的引入也带来了一些问题，第一个问题就是缓存行对内存的占用，加载到缓存的数据可能只使用了部分，而剩余的空间被浪费了，这也被称为缓存行浪费或缓存行膨胀。第二个问题就是缓存一致性问题，当多个CPU访问共享内存时，由于每个CPU都有自己的缓存，可能造成缓存的不一致，而这可以通过缓存一致性协议来解决。<h3 id=2-1-2、四个状态><a class=headerlink href=#2-1-2、四个状态 title=2.1.2、四个状态></a>2.1.2、四个状态</h3><p><strong>Modified（修改）、Exclusive（独占）、Shared（共享）、Invalid（无效）。</strong><h2 id=2-2、用户态与内核态><a class=headerlink href=#2-2、用户态与内核态 title=2.2、用户态与内核态></a>2.2、用户态与内核态</h2><h3 id=2-2-1、概述><a class=headerlink href=#2-2-1、概述 title=2.2.1、概述></a>2.2.1、概述</h3><p><strong>用户态与内核态是操作系统中的两种执行模式，用于区分运行在不同特权级别下的程序和系统内核。</strong><p><strong>用户态是为用户应用程序提供的一种执行缓存。</strong>用户态下的程序只能访问有限的资源和执行有限的操作。<p><strong>内核态是操作系统的特权执行模式，拥有对操作系统核心和硬件资源的完全控制权。</strong>内核态下的系统内核程序可以执行任何指令和访问任何资源。内核态程序可以执行特权指令、管理内存、调度任务等。<p>当用户程序需要执行特权操作时，会触发一次用户态到内核态的转变，系统内核会接管特权并执行相关操作，操作完成后，再交给用户程序，用户程序继续执行。<h3 id=2-2-2、ring-0-1-2-3><a title="2.2.2、ring 0  1  2  3" class=headerlink href=#2-2-2、ring-0-1-2-3></a>2.2.2、ring 0 1 2 3</h3><p><strong>CPU Ring 0、1、2、3是一种权限级别划分，这种划分通常用于X86体系结构中的操作系统和处理器。</strong><p>X86体系结构中，特权级别使用4个环（Ring）来表示，每个环对应一种特权级别，这些环被称为Ring0、1、2、3，也被称为内核态、系统态、用户态、应用态。<ul><li><p><strong>Ring 0（内核态）</strong>：是操作系统内核运行的特权级别，拥有最高的特权和访问权限。系统内核可以执行所有指令，访问系统的所有资源和硬件设备。</p><li><p><strong>Ring 1（系统态）</strong>：是保留给操作系统的第二特权级别，拥有较高的特权和访问权限。系统可以执行受限的指令集和访问部分授权的资源。</p><li><p><strong>Ring 2（用户态）</strong>：是保留给操作系统的第三特权级别，比Ring 3有更高的特权。系统可以执行受限的指令集和访问部分授权的资源。</p><li><p><strong>Ring 3（应用态）</strong>：是用户程序运行的特权级别，拥有最低的特权和访问权限。程序只能执行授权的指令集，访问有限的资源和执行授权动作。</p></ul><p><strong>CPU运行级别在 Ring3 和 Ring0 间的切换称为用户态和内核态的切换</strong>。<h3 id=2-2-3、上下文切换><a class=headerlink href=#2-2-3、上下文切换 title=2.2.3、上下文切换></a>2.2.3、上下文切换</h3><h4 id=2-2-3-1、简介><a class=headerlink href=#2-2-3-1、简介 title=2.2.3.1、简介></a>2.2.3.1、简介</h4><p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个 任务。在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以<strong>任务从保存到再加载的过程就是一次上下文切换。</strong><p>上下文切换会影响多线程执行速度。<h4 id=2-2-3-2、测试上下文切换><a class=headerlink href=#2-2-3-2、测试上下文切换 title=2.2.3.2、测试上下文切换></a>2.2.3.2、测试上下文切换</h4><p>使用<code>Lmbench3</code>可以测量上下文切换时长。使用<code>vmstat</code>可以测量上下文切换次数。<h4 id=2-2-3-3、减少上下文切换><a class=headerlink href=#2-2-3-3、减少上下文切换 title=2.2.3.3、减少上下文切换></a>2.2.3.3、减少上下文切换</h4><p><strong>减少上下文切换的方法：无锁并发编程、CAS算法、使用最少线程和使用协程。</strong><p>实战示例：<ol><li><p>用<code>jstack</code>命令 dump 线程信息，看看 pid 为 3117 的进程中的线程在做什么。</p> <figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>sudo</span> -u admin /opt/ifeve/java/bin/jstack 31177 > /home/tengfei.fangtf/dump17</span><br></pre></table></figure><li><p>统计所有线程分别处于什么状态，发现300多个线程处于 WAITING 状态。</p> <figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>grep java.lang.Thread.State dump17 | awk <span class=string>'{print $2$3$4$5}'</span> | <span class=built_in>sort</span> | <span class=built_in>uniq</span> -c</span><br></pre></table></figure><li><p>打开dump文件查看处于 WAITING 线程在做什么。发现线程池中的线程接收任务太少，大量线程都闲着。</p><li><p>减少线程池中的线程数量。</p><li><p>重新启动服务并测试查看效果。</p></ol><h2 id=2-3、缓存一致性协议><a class=headerlink href=#2-3、缓存一致性协议 title=2.3、缓存一致性协议></a>2.3、缓存一致性协议</h2><h3 id=2-3-1、种类><a class=headerlink href=#2-3-1、种类 title=2.3.1、种类></a>2.3.1、种类</h3><p>协议类型主要有：MSI、MESI、MOSI、Synapse Firefly Dragon。<strong>intel CPU 使用的是MESI协议</strong>。<h3 id=2-3-2、MESI><a class=headerlink href=#2-3-2、MESI title=2.3.2、MESI></a>2.3.2、MESI</h3><p>M、E、S、I 标记 高速缓存行 四种独占状态（使用两个附加位编码）：<ol><li><strong>修改（M）</strong>：高速缓存行仅存在于当前高速缓存中，并且是脏的 - 它已从主存储器中的值修改（M状态）。在允许对（不再有效）主存储器状态的任何其他读取之前，需要高速缓存在将来的某个时间将数据写回主存储器。回写将该行更改为共享状态（S）。<li><strong>独占（E）</strong>：缓存行仅存在于当前缓存中，但是干净 - 它与主内存匹配。它可以随时更改为共享状态，以响应读取请求。或者，可以在写入时将其改变为修改状态。<li><strong>共享（S）</strong>：表示此高速缓存行可能存储在计算机的其他高速缓存中并且是干净的 - 它与主存储器匹配。可以随时丢弃该行（更改为无效状态）。<li><strong>无效（I）</strong>：表示此缓存行无效（未使用）。</ol><p>对于任何给定的高速缓存对，给定高速缓存行的允许状态如图：<p><img alt=image-20201008205937219 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20201008205937219.png?token=AIGEF3IXUJ63WEXUW5FGKLDEZZXHC><p><strong>当块被标记为M（已修改）时，其他高速缓存中关于该块的副本将会被标记为I（无效）</strong>。<h3 id=2-3-3、优缺点><a class=headerlink href=#2-3-3、优缺点 title=2.3.3、优缺点></a>2.3.3、优缺点</h3><h4 id=优点><a class=headerlink href=#优点 title=优点></a>优点</h4><p>MESI多了一个E——“独占”状态。独占状态有许多优点。<p>加入独占状态的缘由：<ol><li>对于“某个处理器需要读取其他处理器没有的块然后写入它”这种情况，会导致 MSI 下发生的两个总线事务（首先是BusRd请求，然后是BusRdX请求）中的第二个请求事务失效。而 MESI 通过添加Exclusive状态解决了这个问题。<li>MSI不适用于顺序执行的应用程序，MESI适用于高度并行的应用程序。</ol><h4 id=缺点><a class=headerlink href=#缺点 title=缺点></a>缺点</h4><p><font color=red>如果由特定块上的各种高速缓存执行 连续读取和写入 操作，则必须每次都将数据刷新到总线上。MOESI协议克服了这一问题。</font><h2 id=2-4、内存屏障><a class=headerlink href=#2-4、内存屏障 title=2.4、内存屏障></a>2.4、内存屏障</h2><h3 id=2-4-1、硬件屏障><a class=headerlink href=#2-4-1、硬件屏障 title=2.4.1、硬件屏障></a>2.4.1、硬件屏障</h3><ul><li>sfence：sava，sfence指令前写 先于 sfence指令后写。<li>lfence：load，lfence指令前读 先于 lfence指令后读。<li>mfence：modify/mix，mfence指令前读写 先于 mfence指令后读写。</ul><h3 id=2-4-2、JVM内存屏障><a class=headerlink href=#2-4-2、JVM内存屏障 title=2.4.2、JVM内存屏障></a>2.4.2、JVM内存屏障</h3><p><img alt=image-20200902211143739 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200902211143739.png?token=AIGEF3JUF3VDP2K4ZX3FWR3EZZXII><h1 id=3、JAVA对象><a class=headerlink href=#3、JAVA对象 title=3、JAVA对象></a>3、JAVA对象</h1><h2 id=3-1、JAVA对象组成><a class=headerlink href=#3-1、JAVA对象组成 title=3.1、JAVA对象组成></a>3.1、JAVA对象组成</h2><h3 id=3-1-1、对象结构><a class=headerlink href=#3-1-1、对象结构 title=3.1.1、对象结构></a>3.1.1、对象结构</h3><p>Java对象保存在内存中时，由以下三部分组成：<p><strong>（1）对象头</strong><ul><li>普通对象头：无压缩16字节，压缩后12字节；<li>数组对象头：无压缩24字节，压缩后16字节；</ul><p><strong>（2）实例数据</strong><p>HotSpot中，对象的实例数据会在对象头后分配空间。<p>字段的分配顺序受源码声明顺序以及HotSpot分配策略的影响。无论哪种分配策略，宽度相同的字段总是相邻分配的；不同宽度间的字段可能存在对齐填充；<p>笼统说，基类声明的实例字段会出现在派生类声明的实例字段之前。但开启指针压缩后，派生类的较窄字段可能会插入到基类实例字段之间的对其填充部分。<p>相关参数：FieldsAllocationStyle CompactFields。<p><strong>（3）对齐填充（使得最终对象大小是8的倍数）</strong><p>HotSpot中，GC堆上的对象要求在8字节边界上分配；也就是说对象的起始地址必须是8的倍数，对象占用的空间也必须是8的倍数。<p>若对象实际需要的大小不足8的倍数，则用0填充不足的部分，直到8字节边界为止。<p>对齐填充可能出现在不同宽度的字段之间，也可能出现在对象的末尾；或者当不存在未对齐的数据时则不会出现对齐填充。<h3 id=3-1-2、对象头><a class=headerlink href=#3-1-2、对象头 title=3.1.2、对象头></a>3.1.2、对象头</h3><h4 id=3-1-2-1、Mark-Word><a title="3.1.2.1、Mark Word" class=headerlink href=#3-1-2-1、Mark-Word></a>3.1.2.1、Mark Word</h4><p><strong>Mark Word（普通对象头无压缩为8字节，压缩后不变；数组对象头为8字节；）</strong><p>HotSpot中，GC堆上的对象需要维持一些状态信息，如：<ul><li>身份哈希码（identity hash code）。<li>是否已被GC标记（GC过程中需要）。<li>当前对象年龄。<li>当前是否被当作锁同步。<li>持有对象锁的线程ID（用于偏向锁）。<li>…….等。</ul><p>该部分会根据对象当前状态有选择性的记录其中一部分。<p>64位如下：<p><img alt=image-20230805145739393 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805145739393.png?token=AIGEF3L3JWHMKR3UAOTMM33EZZXJU><p>32位如下：<p><img alt=32位Java对象内存布局图01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/32%E4%BD%8DJava%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%9B%BE01.png?token=AIGEF3PUMAZYIJ32BFWNLNDEZZXLO><p>对于hashcode值来说，存在两种情况：<p><strong>（1）没有重写hashcode方法</strong><p>没有重写过hashcode方法时调用System.identityHashCode(…)方法可以拿到由os:random生成的hashcode。<p>os::random生成hashcode的规则为：<code>next_rand = (16807seed) mod (2^31 - 1)</code>，因此可以在对象的markword中用31位空间存储它。<p><strong>（2）重写过hashcode方法</strong><p>重写过的hashcode方法其计算结果不会存储在这里。<h4 id=3-1-2-2、Klass-Point><a title="3.1.2.2、Klass Point" class=headerlink href=#3-1-2-2、Klass-Point></a>3.1.2.2、Klass Point</h4><p><strong>Klass Point（普通对象头无压缩为8字节，压缩后4字节；数组对象头4字节）</strong><p>开启压缩功能的参数：<code>-XX:+UseCompressedClassPointers</code>。<p>HotSpot中，堆中的对象从C++角度看都是oopDesc子类的实例。每个对象都有一个_klass字段，指向一个描述自身元数据的对象。<p>Java对象与数组的Klass并不是Java语言级的java.lang.class。Klass用于运行，而java.lang.class用于Java的反射API；前者中有_java_mirror字段指向后者。<h4 id=3-1-2-3、数组长度><a class=headerlink href=#3-1-2-3、数组长度 title=3.1.2.3、数组长度></a>3.1.2.3、数组长度</h4><p><strong>数组长度（数组对象才会存在该项）（数组对象长度占用4字节）</strong><h3 id=3-1-3、测试案例><a class=headerlink href=#3-1-3、测试案例 title=3.1.3、测试案例></a>3.1.3、测试案例</h3><p>工具：JOL（Java Object Layout）<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>    <span class=comment>&LT!-- https://mvnrepository.com/artifact/org.openjdk.jol/jol-core --></span></span><br><span class=line>    <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>        <span class=tag><<span class=name>groupId</span>></span>org.openjdk.jol<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>artifactId</span>></span>jol-core<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>version</span>></span>0.9<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencies</span>></span></span><br></pre></table></figure><p>jdk8u: markOop.hpp<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=comment>// Bit-format of an object header (most significant first, big endian layout below):</span></span><br><span class=line><span class=comment>//</span></span><br><span class=line><span class=comment>//  32 bits:</span></span><br><span class=line><span class=comment>//  --------</span></span><br><span class=line><span class=comment>//             hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class=line><span class=comment>//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class=line><span class=comment>//             size:32 ------------------------------------------>| (CMS free block)</span></span><br><span class=line><span class=comment>//             PromotedObject*:29 ---------->| promo_bits:3 ----->| (CMS promoted object)</span></span><br><span class=line><span class=comment>//</span></span><br><span class=line><span class=comment>//  64 bits:</span></span><br><span class=line><span class=comment>//  --------</span></span><br><span class=line><span class=comment>//  unused:25 hash:31 -->| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class=line><span class=comment>//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class=line><span class=comment>//  PromotedObject*:61 --------------------->| promo_bits:3 ----->| (CMS promoted object)</span></span><br><span class=line><span class=comment>//  size:64 ----------------------------------------------------->| (CMS free block)</span></span><br><span class=line><span class=comment>//</span></span><br><span class=line><span class=comment>//  unused:25 hash:31 -->| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && normal object)</span></span><br><span class=line><span class=comment>//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && biased object)</span></span><br><span class=line><span class=comment>//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 ----->| (COOPs && CMS promoted object)</span></span><br><span class=line><span class=comment>//  unused:21 size:35 -->| cms_free:1 unused:7 ------------------>| (COOPs && CMS free block)</span></span><br></pre></table></figure><h2 id=3-2、Java数据类型><a class=headerlink href=#3-2、Java数据类型 title=3.2、Java数据类型></a>3.2、Java数据类型</h2><h3 id=3-2-1、类型占用字节><a class=headerlink href=#3-2-1、类型占用字节 title=3.2.1、类型占用字节></a>3.2.1、类型占用字节</h3><p><img alt=类型占用字节大小 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200915220817535.png?token=AIGEF3LFVBZGJEJXP4OIP4LEZZXNK><h4 id=3-2-1-1、扩展><a class=headerlink href=#3-2-1-1、扩展 title=3.2.1.1、扩展></a>3.2.1.1、扩展</h4><p>32位操作系统可以寻址到4G内存，因为 2^32 = 4 * 1024 * 1024 = 4G。64位近似无穷大（18EB）。<p>使用64位会有新问题：<strong>64位过长，给我们寻址带宽和对象内引用造成了负担。故引出了指针压缩技术。</strong><h3 id=3-2-2、指针压缩><a class=headerlink href=#3-2-2、指针压缩 title=3.2.2、指针压缩></a>3.2.2、指针压缩</h3><h4 id=3-2-2-1、底层实现><a class=headerlink href=#3-2-2-1、底层实现 title=3.2.2.1、底层实现></a>3.2.2.1、底层实现</h4><p><strong>JVM实现指针压缩的原理就是：每8个字节划分为一组，只记录每组的地址，要获取组内地址时，只需乘8即可得到。</strong>例如，原来保存每个引用0、1、2…，现在只保存0、8、16…。<p>当引用被存入64位寄存器时，JVM会将其左移3位（相当于末尾添加3个0），例如0x0、0x1、0x2…分别被转换为0x0、0x8、0x10。当从寄存器中读出时，JVM又可以右移3位，丢弃末尾的0。（oop在堆中是32位，在寄存器中是35位，2的35次方=32G。也就是说，使用32位，来达到35位oop所能引用的堆内存空间）。<h4 id=3-2-2-2、指针压缩失效><a class=headerlink href=#3-2-2-2、指针压缩失效 title=3.2.2.2、指针压缩失效></a>3.2.2.2、指针压缩失效</h4><p>指针压缩后，一个引用占用4个字节，4个字节可表示的大小为2^32次方，即可以寻址2^32次方个组，又因底层以8个字节为一组，所以，4个字节的引用可以寻址到的最大空间为：<strong>2^3 * 2^32 = 2^35 = 32G</strong>。<p><strong>当内存大小超过32GB时，如果想要寻址到所有空间，那么显然4个字节的引用就无法满足，也就是说当内存大小超过32G时，只能使用大于4个字节的引用才能定位到所有地址，而指针压缩固然就没了作用，只能关闭指针压缩，使用8个字节来寻址</strong>。<p>指针压缩失效后为何非要改用8个字节寻址，按理说只要大于4个字节且够用就行，比如为何不是5个字节、6个字节、7个字节？这是因为JVM对于类对象在内存中8字节倍数对齐的规定。<h4 id=3-2-2-3、被压缩的数据><a class=headerlink href=#3-2-2-3、被压缩的数据 title=3.2.2.3、被压缩的数据></a>3.2.2.3、被压缩的数据</h4><ol><li>对象的全局静态变量(即类属性)。<li>对象头信息：64位平台下，原生对象头大小为16字节，压缩后为12字节。<li>对象引用：64位平台下，引用本身大小为8字节，压缩后为4字节。<li>对象数组：64位平台下，数组本身大小为24字节，压缩后16字节。</ol><h4 id=3-2-2-4、不会被压缩的数据><a class=headerlink href=#3-2-2-4、不会被压缩的数据 title=3.2.2.4、不会被压缩的数据></a>3.2.2.4、不会被压缩的数据</h4><ol><li>指向非Heap的对象指针。<li>局部变量、传参、返回值、NULL指针。</ol><h2 id=3-3、Java集合容器><a class=headerlink href=#3-3、Java集合容器 title=3.3、Java集合容器></a>3.3、Java集合容器</h2><h3 id=3-3-1、概述><a class=headerlink href=#3-3-1、概述 title=3.3.1、概述></a>3.3.1、概述</h3><p>Java集合容器整体结构如下图：<p>版本1：<p><img alt=Collection体系架构01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/Collection%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%8401.png?token=AIGEF3IOEOZ2Y5TSXSC4OSDEZZXP4><p>版本2：<p><img alt=集合结构图 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84%E5%9B%BE.jpg?token=AIGEF3POOXUNH77WTUNZZZTEZZXRS><h3 id=3-3-2、Collection><a class=headerlink href=#3-3-2、Collection title=3.3.2、Collection></a>3.3.2、Collection</h3><h4 id=3-3-2-1、List><a class=headerlink href=#3-3-2-1、List title=3.3.2.1、List></a>3.3.2.1、List</h4><h5 id=ArrayList><a class=headerlink href=#ArrayList title=ArrayList></a>ArrayList</h5><ol><li>数据结构：动态数组，需要连续内存。<li>元素特点：<ul><li>数组定义：<code>transient Object[] elementData;</code> 序列化时不考虑其存储元素；<li>允许为null值；</ul><li>增删改查：<ul><li>随机访问快；<li>首部插入速度较linkedlist要慢40%左右，尾部插入较linkedlist要快10%左右，中间插入较linkedlist要快65%左右，其它部分插入删除都会移动数据，性能较低；<li>可以利用CPU缓存，局部性原理。</ul><li>初始容量：<ul><li>JDK7：初始容量为10。<li>JDK8：初始为0，当第一次执行添加操作后才会扩容，扩容后容量为10；</ul><li>扩容：添加数据前已存在元素数量 等于 数组长度时，则扩大为原来的1.5倍，但底层并非是乘上1.5，而是根据公式：<code>原容量>>1+原容量</code>获得。<li>是否同步：非同步，线程不安全；但可以通过<code>Collections.synchronizedList(list)</code>返回一个线程安全的ArrayList，也可以使用concurrent包下的<code>CopyOnWriteArrayList</code>；<li>复杂度：添加n个元素需要O(n)时间；<li>使用场景：快速访问数据；单线程环境；</ol><h5 id=LinkedList><a class=headerlink href=#LinkedList title=LinkedList></a>LinkedList</h5><ol><li>数据结构：双向链表，不需要连续内存。<li>元素特点：<ul><li>链表节点底层实现就是内部类Node，变量Node first、Node last；<li>允许为null值；占用内存多；</ul><li>增删改查：<ul><li>随机访问慢，顺序访问性能还行；<li>首尾插入删除快，中间插入删除慢；</ul><li>初始容量：不需要指定容量；<li>扩容：随插入数据数量扩大；<li>是否同步：非同步，线程不安全；<li>复杂度：<li>使用场景：快速频繁增删数据场景；按顺序访问数据的场景；单线程环境；<li>扩展：可以实现栈、队列和双向队列；</ol><h5 id=Vector><a class=headerlink href=#Vector title=Vector></a>Vector</h5><ol><li>底层数据结构：动态数组；<li>元素特点：数组定义如：<code>Object[] elementData</code>；允许有空值；不支持序列化；<li>增删改查：插入删除效率低，查询效率高；<li>初始容量：默认10；<li>扩容：添加数据前先判断已存在元素数量 是否等于 数组长度，若等于则默认扩大为原来的2倍。如果显式设置了扩容量则按指定的扩容量来扩容。如果扩容后还是不够用，则直接根据要插入的元素数量长度来扩容；（默认容量为10，若首次发生扩容，则默认扩容后的容量为20。如果初始容量为10，然后直接一次性添加21个元素，那么扩容后的容量为21，而并非是40。容量21空闲为0的环境下，此时再添加1个元素，那么会再次扩容为原来的2倍，也即扩容为42）<li>是否同步：同步，线程安全，因其基于synchronized实现线程安全，故效率较差；可以使用concurrent包下的CopyOnWriteArrayList 来代替 Vector；<li>复杂度：<li>使用场景：多线程环境；</ol><h6 id=Stack><a class=headerlink href=#Stack title=Stack></a>Stack</h6><ol><li><p>底层数据结构：数组</p><li><p>元素特点：先进后出；</p><li><p>增删改查：</p> <ol><li>push方法：将元素推入栈底，即数组末尾；<li>pop方法：取出栈顶元素后并删除栈顶元素。<li>peek方法：取出栈顶元素，即数组首个元素。<li>empty方法：判断栈是否为空。<li>search方法：获取指定元素在栈中的位置。</ol> <p>注意：因其继承于Vector，所以其拥有Vector全部功能；</p><li><p>初始容量：空栈。</p><li><p>扩容：继承于vector，与之相同；</p><li><p>是否同步：线程安全；</p><li><p>复杂度：</p><li><p>使用场景：</p></ol><h5 id=CopyOnWriteArrayList><a class=headerlink href=#CopyOnWriteArrayList title=CopyOnWriteArrayList></a>CopyOnWriteArrayList</h5><ol><li>简介：写操作时（写操作加了锁，否则会拷贝多个副本），将原数组拷贝一份出来，然后在拷贝的新数组中执行写操作，操作完后再将原数组引用指向新数组；<li>底层数据结构：动态数组；<li>元素特点：<li>增删改查：<li>初始容量：<li>扩容：<li>是否同步：线程安全；<li>复杂度：<li>使用场景：读多写少，比如缓存；<li>注意事项：<ol><li>写操作需要拷贝数组，比较消耗内存，如果原数组容量比较大，则可能频繁发生YGC和FGC；<li>不能保证实时一致性，只能保证最终一致性；</ol></ol><h4 id=3-3-2-2、Set><a class=headerlink href=#3-3-2-2、Set title=3.3.2.2、Set></a>3.3.2.2、Set</h4><h5 id=HashSet><a class=headerlink href=#HashSet title=HashSet></a>HashSet</h5><ol><li>底层数据结构：基于HashMap和LinkedHashMap实现。具体实现方式：通过一个HashMap来存储元素，元素存放在HashMap的key中，而value统一使用一个Object对象。<li>元素特点：<ol><li>无序不重复；<li>只允许1个null元素；</ol><li>增删改查：<li>初始容量：因基于HashMap实现，故规则参考HashMap实现规则；<li>扩容：因基于HashMap实现，故规则参考HashMap实现规则；<li>是否同步：线程不安全；<li>复杂度：<li>使用场景：去重，无需排序场景；</ol><h5 id=LinkedHashSet><a class=headerlink href=#LinkedHashSet title=LinkedHashSet></a>LinkedHashSet</h5><ol><li>底层数据结构：<ol><li>数组+双向链表；<li>基于LinkedHashMap和HashSet机制实现，所以可保证迭代顺序和元素的不重复；</ol><li>元素特点：<ol><li>Entry结构：before/hash/key/value/next/after；before和after用于维护整个双向链表；<li>元素不重复；<li>可以保证插入顺序和访问顺序；</ol><li>增删改查：<li>初始容量：因基于LinkedHashMap实现，参考其实现规则；<li>扩容：因基于LinkedHashMap实现，参考其实现规则；<li>是否同步：线程不安全；<li>复杂度：<li>使用场景：去重，需要保证插入或访问顺序；</ol><h5 id=SortedSet><a class=headerlink href=#SortedSet title=SortedSet></a>SortedSet</h5><ul><li>TreeSet<ol><li>底层实现：基于TreeMap实现。<li>元素特点：元素有序。支持两种排序方式：自然排序和定制排序，默认是自然排序。使用 无参构造时 默认自然排序；当需要使用定制排序时，需要使用 有参构造 来显式指定比较器实现定制排序。<li>存储：通过compare和compareTo来判断是否相等。compare通过判断两个对象的id，相同id则认为是重复元素，不会加入到集合中。</ol></ul><h5 id=EnumSet><a class=headerlink href=#EnumSet title=EnumSet></a>EnumSet</h5><h5 id=CopyOnWriteSet><a class=headerlink href=#CopyOnWriteSet title=CopyOnWriteSet></a>CopyOnWriteSet</h5><ol><li>简介：写操作时（写操作加了锁，否则会拷贝多个副本），将原数组拷贝一份，然后在拷贝的那份数组中执行写操作，操作完后再将原数组引用指向新数组；<li>数组结构：动态数组；<li>原理：通过CopyOnWriteList机制实现；<li>是否同步：线程安全；<li>使用场景：读多写少，比如缓存；<li>注意事项：<ol><li>写操作需要拷贝数组，比较消耗内存，如果原数组容量比较大，则可能频繁发生YGC和FGC；<li>不能保证实时一致性（读取到的数据可能是旧的），只能保证最终一致性；</ol></ol><h5 id=CopyOnWriteArraySet><a class=headerlink href=#CopyOnWriteArraySet title=CopyOnWriteArraySet></a>CopyOnWriteArraySet</h5><ol><li>底层数据结构：动态数组；并非是散列表；<li>元素特点：不能存储重复元素；<li>增删改查>：<li>初始容量：<li>扩容：<li>是否同步：线程安全；<li>复杂度：<li>使用场景：读多写少，比如缓存；</ol><h5 id=ConcurrentSkipListSet><a class=headerlink href=#ConcurrentSkipListSet title=ConcurrentSkipListSet></a>ConcurrentSkipListSet</h5><h4 id=3-3-2-3、Queue><a class=headerlink href=#3-3-2-3、Queue title=3.3.2.3、Queue></a>3.3.2.3、Queue</h4><p>简介：offer()-添加数据后会返回一个布尔类型来表示是否添加成功；peek()-取数据；poll()-取数据后进行remove；<h5 id=Deque><a class=headerlink href=#Deque title=Deque></a>Deque</h5><ul><li>ArrayDeque<li>BlockingDeque<ul><li>LinkedBlockingDeque</ul></ul><h5 id=BlockingQueue（阻塞队列）><a class=headerlink href=#BlockingQueue（阻塞队列） title=BlockingQueue（阻塞队列）></a>BlockingQueue（阻塞队列）</h5><p>简介：在Queue的基础上添加<code>put()</code>和<code>take()</code>方法，这两个是阻塞方法。put装数据装满了会阻塞当前线程，take拿数据拿完了会阻塞当前线程。<ul><li><p>ArrayBlockingQueue</p> <p>简介：它是一个有界阻塞队列，且可以设置有界值，也就是容器的容量。注意本类实现的offer方法可以设置时间，在指定时间过后还是添加不进去再返回。</p><li><p>PriorityBlockingQueue</p><li><p>LinkedBlockingQueue</p> <p>简介：基于链表实现的无界阻塞队列，它可以一直装数据到你内存满为止。</p><li><p>TransferQueue</p> <p>简介：传递的意思，实际上是其它各种Queue的一个组合，它可以给线程传递任务且可以通过列表传递多个。该Queue新增了一个transfer()方法——其逻辑就是装完数据得等着，有线程把它拿走我才可以回去继续干我的事。</p> <p>应用场景：做了一件事，该事需要一个结果才能继续做下一件事。比如网购，我付钱成功后才能给发货，不成功不能发货。</p> <ul><li>LinkedTransferQueue</ul><li><p>SynchronousQueue</p> <p>简介：容量为0，它并非用来装数据，而是专门用来两个线程间传递数据和线程下达任务。该Queue用来进行阻塞式put调用，要求有线程从里面取数据时才能往里面装，相当于直接把数据递给取数据线程的手中。该Queue看似无用，其实不然，其在线程池中用处非常大，多线程取任务，互相间进行任务调度时用的就是这个Queue。</p></ul><h5 id=PriorityQueue><a class=headerlink href=#PriorityQueue title=PriorityQueue></a>PriorityQueue</h5><p>简介：内部结构是一个二叉树，该二叉树可以认为是堆排序里面的小顶堆（最小值为根节点）。PriorityQueue的特点是向里面装数据时不是按顺序装的，而是在内部进行了一个排序，按照优先级，最小的优先。<h5 id=ConcurrentLinkedQueue><a class=headerlink href=#ConcurrentLinkedQueue title=ConcurrentLinkedQueue></a>ConcurrentLinkedQueue</h5><h5 id=DelayQueue（双端队列）><a class=headerlink href=#DelayQueue（双端队列） title=DelayQueue（双端队列）></a>DelayQueue（双端队列）</h5><p>简介：DelayQueue可以基于时间排序。它是阻塞的队列的一种实现，这个阻塞队列在装数据时必须实现Delayed接口，也要实现Comparable接口并重写compareTo方法来实现任务排序的自定义逻辑；<h3 id=3-3-3、Map><a class=headerlink href=#3-3-3、Map title=3.3.3、Map></a>3.3.3、Map</h3><h4 id=3-3-3-1、HashMap><a class=headerlink href=#3-3-3-1、HashMap title=3.3.3.1、HashMap></a>3.3.3.1、HashMap</h4><ol><li><p>底层数据结构：JDK7是数组+单链表；JDK8是数组+单链表+红黑树；</p><li><p>元素特点：无序的key-value键值对；允许null key和null value；</p><li><p>增删改：插入、删除、查询效率较高；</p><li><p>初始容量：默认16（2的N次方）；</p><li><p>扩容：put后判断是否需要扩容；负载因子0.75，当容量 = (总容量*0.75)时触发扩容，扩大为原来的2倍；</p><li><p>是否同步：线程不安全；</p><li><p>复杂度：</p><li><p>使用场景：快速增删改查；随机读取；缓存；</p><li><p>哈希冲突对策：</p> <ul><li>开放定址法；<li>再散列函数法；<li>链地址法（拉链法，HashMap基于此实现）；</ul></ol><h5 id=3-3-3-1-1、LinkedHashMap><a class=headerlink href=#3-3-3-1-1、LinkedHashMap title=3.3.3.1.1、LinkedHashMap></a>3.3.3.1.1、LinkedHashMap</h5><ol><li>底层数据结构：数组+双向链表；<li>元素特点：<ol><li>entry结构：before/hash/key/value/next/after，before和after用于维护整个双向链表；<li>允许一个null key（多个覆盖），允许多个null value；</ol><li>增删改查：<ol><li>在HashMap基础上添加before和after两个属性保证迭代顺序；<li>迭代顺序可以是插入顺序，也可以是访问顺序；<li>使用LRU算法实现访问顺序排序；</ol><li>初始容量：<li>扩容：<li>是否同步：线程不安全；<li>复杂度：<li>使用场景：保证插入和访问顺序；</ol><h4 id=3-3-3-2、IdentityHashMap><a class=headerlink href=#3-3-3-2、IdentityHashMap title=3.3.3.2、IdentityHashMap></a>3.3.3.2、IdentityHashMap</h4><h4 id=3-3-3-3、TreeMap><a class=headerlink href=#3-3-3-3、TreeMap title=3.3.3.3、TreeMap></a>3.3.3.3、TreeMap</h4><ol><li><p>底层数据结构：红黑树（高效检索二叉树）；</p><li><p>元素特点：</p> <ol><li>有序的key-value集合，每一个元素都存储于红黑树的一个节点上；<li>Entry结构：key/value/left/right/parent/color；<li>不允许null key，但可允许多个null value；</ol><li><p>增删改查：默认自然排序，也可定制排序；</p><li><p>初始容量：</p><li><p>扩容：</p><li><p>是否同步：线程不安全；</p><li><p>复杂度：</p><li><p>使用场景：</p><li><p>存储：TreeMap存储时会进行排序，会根据key来对key-value键值对进行排序，其排序方式分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法。</p> <p>自然排序：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。</p> <p>定制排序：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。</p><li><p>获取：</p><li><p>检测元素异同：TreeMap判断两个元素相等的标准：两个key执行equals返回true，且执行<code>compareTo()</code>方法返回0，则认为这两个key相等。</p><li><p>是否同步：非同步。</p><li><p>注意事项：如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的<code>equals()</code>方法，TreeMap中判断相等的标准是：两个key通过<code>equals()</code>方法返回为true，并且通过<code>compareTo()</code>方法比较应该返回为0。</p></ol><h4 id=3-3-3-4、WeakHashMap><a class=headerlink href=#3-3-3-4、WeakHashMap title=3.3.3.4、WeakHashMap></a>3.3.3.4、WeakHashMap</h4><h4 id=3-3-3-5、HashTable><a class=headerlink href=#3-3-3-5、HashTable title=3.3.3.5、HashTable></a>3.3.3.5、HashTable</h4><ol><li><font color=orange>底层数据结构</font>：数组 + 单链表；<li><font color=orange>元素特点</font>：无序的key-value键值对，不允许null key 和 null value；<li><font color=orange>增删改查</font>：插入、删除、查询效率较低，因为被synchronized修饰；<li><font color=orange>初始容量</font>：默认11；<li><font color=orange>扩容</font>：put前判断是否需要扩容；负载因子0.75，当容量 >= (总容量*0.75)时触发扩容，扩大为2倍+1；<li><font color=orange>是否同步</font>：线程安全；基于重入锁synchronized实现线程安全；<li><font color=orange>复杂度</font>：<li><font color=orange>使用场景</font>：无序、不重复元素的存储。</ol><h4 id=3-3-3-6、IdentityHashMap><a class=headerlink href=#3-3-3-6、IdentityHashMap title=3.3.3.6、IdentityHashMap></a>3.3.3.6、IdentityHashMap</h4><h4 id=3-3-3-7、ConcurrentHashMap（JDK8）><a class=headerlink href=#3-3-3-7、ConcurrentHashMap（JDK8） title=3.3.3.7、ConcurrentHashMap（JDK8）></a>3.3.3.7、ConcurrentHashMap（JDK8）</h4><ol><li><font color=orange>底层数据结构</font>：数组+单链表+红黑树；<li><font color=orange>锁实现</font>：CAS+Synchronized；<li><font color=orange>元素特点</font>：Node改名为HashEntry；<li><font color=orange>增删改查</font>：<li><font color=orange>初始容量</font>：默认16；<li><font color=orange>扩容</font>：数据等于容量3/4时就扩容为原容量的2倍。<li><font color=orange>是否同步</font>：线程安全；基于 CAS+Synchronized 实现安全；<li><font color=orange>复杂度</font>：<li><font color=orange>使用场景</font>：多线程，高并发场景；</ol><h4 id=3-3-3-8、ConcurrentKipListMap><a class=headerlink href=#3-3-3-8、ConcurrentKipListMap title=3.3.3.8、ConcurrentKipListMap></a>3.3.3.8、ConcurrentKipListMap</h4><h3 id=3-3-4、Iterator><a class=headerlink href=#3-3-4、Iterator title=3.3.4、Iterator></a>3.3.4、Iterator</h3><ul><li><p>Iterator</p> <ol><li>简介：是接口，是集合迭代器。<li>API：<ol><li>boolean hashNext()：判断集合中是否存在下一个元素，若存在，则返回true。<li>Object next()：返回集合中下一个元素。<li>void remove()：删除集合上一次next方法返回的元素。</ol><li>注意事项：<ol><li>iterator()只能单向移动。<li>iterator.remove()可以唯一安全修改迭代过程中集合元素的方法；如果在迭代过程中以任何其它的方式修改了集合，那么将会产生未知行为。且每调用一次<code>next()</code>方法，<code>remove()</code>方法只能被调用一次，如果违反这个规则将抛出一个异常。</ol></ol> <ul><li>ListIterator<ol><li>简介：是一个 功能更强 的迭代器，继承于Iterator接口，只能适用于List。可以通过调用<code>listIterator()</code>方法产生一个指向List开始处的ListIterator，还可以调用<code>listIterator(n)</code>方法创建一个一开始就指向列表索引为n的元素的ListIterator。<li>特点：<ol><li>双向移动（向前向后遍历）<li>产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引。<li>可以使用set方法替换它访问过的最后一个元素。<li>可以使用add方法在next方法返回的元素之前或previous方法返回元素之后插入一个元素。</ol></ol></ul></ul><h3 id=3-3-5、Collection-Collections><a title="3.3.5、Collection / Collections" class=headerlink href=#3-3-5、Collection-Collections></a>3.3.5、Collection / Collections</h3><h4 id=3-3-5-1、Collection><a class=headerlink href=#3-3-5-1、Collection title=3.3.5.1、Collection></a>3.3.5.1、Collection</h4><p><strong>Collection是集合类顶级接口。提供操作集合的通用方法，其继承接口有List与Set</strong>。<h4 id=3-3-5-2、Collections><a class=headerlink href=#3-3-5-2、Collections title=3.3.5.2、Collections></a>3.3.5.2、Collections</h4><p>java.util.Collections 是<strong>集合工具类</strong>。拥有多种操作集合的静态方法，可对集合中的元素执行排序、搜索以及线程安全等操作，服务于Java的Collection框架。<h3 id=3-3-6、总结><a class=headerlink href=#3-3-6、总结 title=3.3.6、总结></a>3.3.6、总结</h3><h4 id=3-3-6-1、HashMap原理><a class=headerlink href=#3-3-6-1、HashMap原理 title=3.3.6.1、HashMap原理></a>3.3.6.1、HashMap原理</h4><h5 id=底层数据结构><a class=headerlink href=#底层数据结构 title=底层数据结构></a>底层数据结构</h5><p>（1）JDK7<p>JDK7底层基于数组 + 单链表实现。<p>JDK7中底层使用HashMap的静态内部类Entry来存储数据：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">Entry</span>&LTK,V> <span class=keyword>implements</span> <span class="title class_">Map</span>.Entry&LTK,V> {</span><br><span class=line>    <span class=keyword>final</span> K key;</span><br><span class=line>    V value;</span><br><span class=line>    Entry&LTK,V> next;</span><br><span class=line>    <span class=type>int</span> hash;</span><br><span class=line>    <span class=comment>// method...</span></span><br><span class=line>}</span><br></pre></table></figure><p>（2）JDK8<p>JDK8底层基于数组 + 单链表 + 红黑树实现。<p>JDK8中底层使用HashMap的静态内部类Node来存储数据：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">Node</span>&LTK,V> <span class=keyword>implements</span> <span class="title class_">Map</span>.Entry&LTK,V>{</span><br><span class=line>    <span class=keyword>final</span> <span class=type>int</span> hash;</span><br><span class=line>    <span class=keyword>final</span> K key;</span><br><span class=line>    V value;</span><br><span class=line>    Node&LTK,V> next;</span><br><span class=line>    <span class=comment>// method...</span></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>解决哈希冲突的常见方法：开放地址法、链地址法等。HashMap采用了链地址法。</blockquote><h5 id=元素特点><a class=headerlink href=#元素特点 title=元素特点></a>元素特点</h5><p><strong>HashMap支持一个null key 和多个 null value</strong>，原因如下：<ol><li><p>对于 null key 来说，在求hash值时会直接返回0，故只能有一个 null key。</p><li><p>对于 null value 来说，在执行put方法时不会对之进行校验，故可以有多个 null value。</p> <p>这里要注意，HashMap 的get方法执行逻辑是：如果没有查询到指定key的键值对时会返回 null 对象。故get(key)方法的返回结果为null有两种可能：</p> <ol><li>HashMap中不存在这个 key 对应的键值对；<li>HashMap中这个key对应的value为null；</ol> <p>故，在判断HashMap中是否存在某个key时，应该使用containsKey方法；</p></ol><h5 id=常见字段><a class=headerlink href=#常见字段 title=常见字段></a>常见字段</h5><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=comment>/** 保存Node&LTK,V>节点的数组，该表在首次使用时初始化，并根据需要调整大小。 分配时，长度始终是2的幂。 */</span></span><br><span class=line><span class=keyword>transient</span> Node&LTK,V>[] table;</span><br><span class=line><span class=comment>/** 存放具体元素的集合 */</span></span><br><span class=line><span class=keyword>transient</span> Set&LTMap.Entry&LTK,V>> entrySet;</span><br><span class=line></span><br><span class=line><span class=comment>/** 默认初始容量16 */</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=type>int</span> <span class=variable>DEFAULT_INITIAL_CAPACITY</span> <span class=operator>=</span> <span class=number>1</span> << <span class=number>4</span>;</span><br><span class=line><span class=comment>/** 最大容量 */</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=type>int</span> <span class=variable>MAXIMUM_CAPACITY</span> <span class=operator>=</span> <span class=number>1</span> << <span class=number>30</span>;</span><br><span class=line><span class=comment>/** 加载因子，用来计算threshold */</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=type>float</span> <span class=variable>DEFAULT_LOAD_FACTOR</span> <span class=operator>=</span> <span class=number>0.75f</span>;</span><br><span class=line><span class=comment>/** 触发扩容的阈值，实际大小（容量*加载因子）超过该阈值时会触发扩容  */</span></span><br><span class=line><span class=type>int</span> threshold;</span><br><span class=line><span class=comment>/** 负载因子：要调整大小的下一个大小值（容量*加载因子）。</span></span><br><span class=line><span class=comment>通过调节负载因子，可使 HashMap 在时间和空间复杂度上有不同表现。调低负载因子时，扩容效率增高，扩容过程中hash碰撞减少、链表长度变短，这是典型的拿空间换时间； 调高负载因子时，容纳键值对数量变多、空间利用率增高，但碰撞也增高了，最终效率下降。故一般使用默认值即可。*/</span></span><br><span class=line><span class=keyword>final</span> <span class=type>float</span> loadFactor;</span><br><span class=line></span><br><span class=line><span class=comment>/** 进行resize操作时，若桶中数量少于6则从树转成链表 */</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=type>int</span> <span class=variable>UNTREEIFY_THRESHOLD</span> <span class=operator>=</span> <span class=number>6</span>;</span><br><span class=line><span class=comment>/** 链表长度大于8时转化为红黑树 */</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=type>int</span> <span class=variable>TREEIFY_THRESHOLD</span> <span class=operator>=</span> <span class=number>8</span>;</span><br><span class=line><span class=comment>/** 链表转为红黑树时，需先判断当前数组容量是否小于64。若小于64且hash冲突太多，则不进行红黑树转化，而要通过resize函数继续扩容。 */</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=type>int</span> <span class=variable>MIN_TREEIFY_CAPACITY</span> <span class=operator>=</span> <span class=number>64</span>;</span><br><span class=line></span><br><span class=line><span class=comment>/** 记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。 */</span></span><br><span class=line><span class=type>int</span> modCount;  </span><br><span class=line><span class=comment>/** HashMap当前存储的元素数量  */</span></span><br><span class=line><span class=type>int</span> size;</span><br></pre></table></figure><p><strong>HashMap中哈希桶数组table的长度length大小必须为2的n次方（合数）</strong>。<h5 id=hash方法><a class=headerlink href=#hash方法 title=hash方法></a>hash方法</h5><ul><li><p>key为空，则hashcode为0，这也是HashMap只允许存在一个key为null的原因。</p><li><p>key不为空，则计算公式如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>int</span> <span class=variable>hash</span> <span class=operator>=</span> (h = key.hashCode()) ^ (h >>> <span class=number>16</span>); 	<span class=comment>// 求hash值</span></span><br><span class=line><span class=type>int</span> <span class=variable>index</span> <span class=operator>=</span> (n - <span class=number>1</span>) & hash; 					<span class=comment>// 定位下标</span></span><br></pre></table></figure></ul><h5 id=put-操作><a class=headerlink href=#put-操作 title=put()操作></a>put()操作</h5><p><strong>JDK1.7采用头插法，JDK1.8采用尾插法</strong>。<p>JDK8执行流程如下：<ol><li>计算待新增数据key的hash值；<li>判断Node[]是否为空，若为空需要进行初始化；<li>通过运算(hash &(len-e))得出待插入元素要存储在数组中的下标位置idx，如果该位置idx没有数据，那么该元素数据添加成功。如果该位置idx有数据，则继续判断：<ol><li>如果该位置idx处Node节点的key与待插入数据的key相等，则直接覆盖已存在的值，然后返回旧值；<li>如果该结构是树形，则按照树的方式插入数据；<li>如果该结构是链表，则从上到下遍历该链表。如果当前节点的下一节点为null，则将待插入数据放在这个null位置，然后判断链表长度是否大于阈值8，如果 >= 8 且数组长度 >= 64 才转为红黑树，如果 >= 8 且数组长度 < 64 则仅仅进行链表的扩容；如果当前节点的下一个节点不为null，且该节点hash、key与待插入元素数据的hash和key都相同，则将待插入数据替换该节点，然后返回旧值。如果该节点hash、key与待插入数据的hash和key不一样，那就继续遍历该链表。</ol><li>判断数组长度是否大于阈值，如果是则进入扩容阶段；</ol><h5 id=resize-操作><a class=headerlink href=#resize-操作 title=resize()操作></a>resize()操作</h5><p><strong>当数组元素数量 = 数组长度*0.75时触发扩容，扩容后数组长度是旧的2倍。</strong><p>Java8与Java7的迁移算法不一样，Java8不需要每一个元素都重新计算hash值；JDK8只需根据原hash值与oldCap的与运算结果来确定元素的新位置，当计算结果为0时，元素放在原位置上，当计算结果为1时，元素放在 旧位置+oldCap 位置上。<p><font color=red>注意：JDK1.7中旧链表迁移至新链表时，如果与新表数组索引位置相同，则链表元素会倒置；而JDK1.8不会倒置。</font><h5 id=get-key-操作><a class=headerlink href=#get-key-操作 title=get(key)操作></a>get(key)操作</h5><ol><li>根据put()方法中计算hash的方式得到一个数组下标index；<li>遍历数组下标为index所对应的链表，若找到key和hash值同时相等的就返回该值，否则返回null；</ol><h5 id=remove-操作><a class=headerlink href=#remove-操作 title=remove()操作></a>remove()操作</h5><ol><li>根据get()方法中的方式计算出要删除的key对应的Node节点；<li>如果待删除节点是头节点，则将它的next节点作为头节点；<li>如果待删除节点是红黑树，则直接调用红黑树的删除算法进行删除；<li>如果待删除节点是链表中的一个节点，则将待删除节点的前一个节点的next属性指向待删除节点的下一个节点即可；<li>如果删除成功则返回被删除节点的value，否则返回null；</ol><p><font color=red>注意：删除单个key时，返回的是键值对中的value；</font><h5 id=iterator迭代器><a class=headerlink href=#iterator迭代器 title=iterator迭代器></a>iterator迭代器</h5><p><code>Hashtable</code> 和 <code>HashMap</code> 有相同的迭代器 Iterator，<code>HashMap</code>和<code>Hashtable</code> 的 Iterator 都是快速失败 fail-fast。但<code>Hashtable</code> 还有另外一个迭代器 Enumeration，该迭代器是 安全失败 fail-safe，<code>HashTable</code> 中有一个 keys 方法可以返回 Enumeration 迭代器。<blockquote><p><strong>fail-safe 和 fail-fast 是一种思想，一种机制，属于系统设计范畴，并非 Java 集合所特有</strong>。<p><strong>（1）快速失败 fail-fast</strong><p>一种快速发现系统故障的机制。一旦发生异常，立即停止当前操作，并上报给上层的系统来处理这些故障。<p>当 Iterator 这个迭代器被创建后，除了迭代器本身的方法 remove 可以改变集合的结构外，其他的因素若改变了集合的结构（改变只包含插入和删除），都将会抛出 <code>ConcurrentModificationException</code> 异常。<p><strong>java.util 包下的集合类都是 fail-fast 的</strong>。<p><strong>（2）安全失败 fail-safe</strong><p>在故障发生之后会维持系统继续运行。 fail-safe 不会抛出异常的原因如下：<ol><li>当集合的结构被改变时，fail-safe 机制会复制一份原集合数据，然后在复制的那份数据上进行遍历。</ol><p>虽然 fail-safe 不会抛出异常，但存在以下缺点：<ol><li>不能保证遍历的是最新内容。也就是说迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的；<li>复制时需要额外的空间和时间开销。</ol><p>顾名思义，和 fail-fast 恰恰相反，当我们对集合的结构做出改变的时候，fail-safe 机制不会抛出异常。<p><strong>java.util.concurrent 包下的容器都是 fail-safe 的。</strong></blockquote><h5 id=线程安全><a class=headerlink href=#线程安全 title=线程安全></a>线程安全</h5><p>HashMap非线程安全，而ConcurrentHashMap线程安全。<p>ConcurrentHashMap底层结构在JDK1.7和1.8中也不同：<ul><li>JDK1.7： 分段锁；<li>JDK1.8：CAS + Synchronized；</ul><h5 id=并发问题><a class=headerlink href=#并发问题 title=并发问题></a>并发问题</h5><p>常见问题如下：<ol><li>多线程扩容，引起死循环问题；<li>多线程put时可能导致元素丢失；<li>put非null元素后get出来的是null；</ol><p>应对措施：使用HashTable 或者 ConcurrentHashMap。<h5 id=Key取值问题><a class=headerlink href=#Key取值问题 title=Key取值问题></a>Key取值问题</h5><ol><li><p>key只允许有一个null，value允许有多个null；（key为null时hashcode总是0）</p><li><p>key取值范围有哪些？</p> <p>一般使用String、Integer，且String最常用。原因如下：</p> <ol><li>字符串是不可变的，它在被创建时其hashcode就缓存了，无需计算，且效率要比其它对象高。<li>获取对象时需要用到equals方法和hashCode方法，而String已经规范的重写过了。</ol><li><p>可变类可以作为key使用吗？</p> <p>不可以，因为hashcode可能会发生变化，导致put进去的值，无法get出来。</p><li><p>如何自定义一个类，其可以作为HashMap的key？</p> <p>该问题考察两个知识点：</p> <ol><li><p>如何重写equals方法和hashCode方法？</p> <p>根据如下4条规则来设计即可：</p> <ol><li>两个对象相等，hashcode⼀定相等；<li>两个对象不等，hashcode不⼀定不等；<li>hashcode相等，两个对象不⼀定相等；<li>hashcode不等，两个对象⼀定不等；</ol><li><p>如何设计一个不变类？</p> <ol><li>使用final修饰类，保证类不能被继承。<li>将所有成员变量访问权限设为私有，且加上final修饰，保证成员变量不可变；<li>不提供修改成员变量的方法；<li>通过构造器初始化所有成员，进行深拷贝；<li>getter方法中不要直接返回对象本身，而要返回克隆对象，防止逃逸。</ol></ol></ol><h5 id=位运算-VS-取模运算><a title="位运算 VS 取模运算" class=headerlink href=#位运算-VS-取模运算></a>位运算 VS 取模运算</h5><p>HashMap采用 位运算 的原因如下<ol><li><strong>效率高。</strong>位运算直接对内存数据进行操作，不需要转换为十进制，因此处理速度快；<li><strong>可以解决取模运算的负数问题。</strong>比如：-15 % 10 = -5；</ol><h5 id=JDK7和JDK8下HashMap的异同><a class=headerlink href=#JDK7和JDK8下HashMap的异同 title=JDK7和JDK8下HashMap的异同></a>JDK7和JDK8下HashMap的异同</h5><ol><li>存放数据的节点名称不同；JDK7使用 Entry 命名；JDK8使用 Node 命名；<li>定位数组下标位置方法不同；<ul><li>JDK7：计算key的hash，然后进行四次扰动，再与数组长度取模得出；<li>JDK8：计算key的hash，将hash值进行高低16位异或操作，再与数组长度-1后取模得出；</ul><li>扩容时机不同：JDK7添加数据前先判断是否需要扩容；JDK8添加数据后再判断是否需要扩容；<li>扩容迁移定位方法不同；<ul><li>JDK7：扩容后需要重新计算hash；<li>JDK8：扩容后不需要重新计算hash；</ul><li>put方法插入链表位置不同：<ul><li>JDK7：头插法；<li>JDK8：尾插法；</ul><li>红黑树升级和退化<ul><li>链表升级为红黑树：<strong>JDK8引入红黑树，当链表长度 >= 8 且 数组长度 >= 64 时，链表转为红黑树；</strong><li>红黑树退化为链表：有两个地方会判断并退化成链表：<ol><li><strong>remove时退化；</strong><li><strong>扩容时会调用<code>split()</code>进行红黑树的扩容移动处理。</strong>split方法中，会将当前红黑树左右子树分别放入low，high两个w变量（treeNode类型）中。可理解为两条链表，当low链表中元素<=6时会将low转换为真正的链表（Node类型），当low链表中元素>6时会进行树化处理， 例如对链表中节点的left、right等进行赋值，high链表同理。</ol></ul></ol><h5 id=HashMap-VS-HashTable><a title="HashMap VS HashTable" class=headerlink href=#HashMap-VS-HashTable></a>HashMap VS HashTable</h5><table><thead><tr><th align=center>HM VS HT<th align=center>HashMap<th align=center>HashTable<tbody><tr><td align=center>初始容量<td align=center>16<td align=center>11<tr><td align=center>计算数组下标<td align=center>hashcode & (len - 1)<td align=center>hashcode % (len - 1)<tr><td align=center>扩容时机<td align=center>put后判断<td align=center>put前判断<tr><td align=center>扩容大小<td align=center>原容量2倍<td align=center>原容量2倍+1<tr><td align=center>null key/value<td align=center>1个null key，多个null value<td align=center>没有null key 和 null value<tr><td align=center>线程安全<td align=center>线程不安全<td align=center>线程安全<tr><td align=center>接口实现<td align=center>实现Map接口且继承AbstractMap类<td align=center>实现Map接口且继承Dictionary类</table><h5 id=HashMap-VS-TreeMap><a title="HashMap VS TreeMap" class=headerlink href=#HashMap-VS-TreeMap></a>HashMap VS TreeMap</h5><table><thead><tr><th align=center>HM VS TM<th align=center>HashMap<th align=center>TreeMap<tbody><tr><td align=center>数据结构<td align=center>数组+链表+红黑树<td align=center>红黑树<tr><td align=center>存储方式<td align=center>基于hash和相关算法来存储<td align=center>按key的字典升序排序存储<tr><td align=center>null key/value<td align=center>1个null key，多个null value<td align=center>没有null key，多个null value<tr><td align=center>效率<td align=center>效率高<td align=center>效率低</table><h4 id=3-3-6-2、HashTable原理><a class=headerlink href=#3-3-6-2、HashTable原理 title=3.3.6.2、HashTable原理></a>3.3.6.2、HashTable原理</h4><h5 id=底层数据结构-1><a class=headerlink href=#底层数据结构-1 title=底层数据结构></a>底层数据结构</h5><p>使用哈希表来存储键值对，数据结构创建了一个继承<code>Map.Entry</code>的私有静态内部类<code>Entry</code>，每一个Entry对象表示存储在哈希表中的一个键值对。<h5 id=元素特点-1><a class=headerlink href=#元素特点-1 title=元素特点></a>元素特点</h5><p><strong>HashTable不支持 null key和null value</strong>，原因如下：<ol><li>对于 null value 来说，在执行put方法时会直接抛出异常NullPointerException。<li>对于 null key 来说，在定位元素时会执行key.hashCode方法，会抛出NullPointerException。<li>若允许 null key 和 null value，则多线程环境下会出现问题。（ConcurrentHashMap也不允许null key 和 null value。）</ol><h5 id=rehash方法（扩容）><a class=headerlink href=#rehash方法（扩容） title=rehash方法（扩容）></a>rehash方法（扩容）</h5><p><strong>当前容量 >=（总容量 * 负载因子）时，Hashtable 扩大为旧容量的2倍+1；</strong><h4 id=3-3-6-3、ArrayList原理><a class=headerlink href=#3-3-6-3、ArrayList原理 title=3.3.6.3、ArrayList原理></a>3.3.6.3、ArrayList原理</h4><h5 id=add-element-操作><a class=headerlink href=#add-element-操作 title=add(element)操作></a>add(element)操作</h5><ol><li><p>判断当前数组是否为空，若是则创建长度为10的数组，因为new ArrayList 时没有初始化；</p><li><p>判断是否需要扩容，即：当前数组中元素数+1后（size+1）判断其是否大于当前数组长度，是则进行扩容（执行grow()方法）;</p> <p>grow()方法流程如下：</p> <ol><li>创建新数组，其长度为原数组长度的1.5倍；<li>如果扩大1.5倍后依然不够，则根据实际长度来扩容，比如addAll()场景；<li>将原数组的数据通过<code>System.arraycopy</code>方法（native方法）复制到新数组中；</ol><li><p>在数组末尾添加数据，并将size+1；</p></ol><h5 id=add-index-element-操作><a title="add(index, element)操作" class=headerlink href=#add-index-element-操作></a>add(index, element)操作</h5><ol><li>检查index是否在数组范围内，假如数组长度是2，则index必须 >= 0 且 <= 2，否则抛出异常IndexOutOfBoundsException异常；<li>扩容检查；<li>通过拷贝方式，把数组位置为index至size-1的元素都往后移动一位，腾出位置后放入元素，并将size+1；</ol><h5 id=set-index-element-操作><a title="set(index, element)操作" class=headerlink href=#set-index-element-操作></a>set(index, element)操作</h5><ol><li>检查index是否在数组范围内，加入数组长度为2，则index必须 >= 0 且 < 2；<li>保存被覆盖的值，因为最终需要返回旧值；<li>新元素放至index位置，并返回该位置旧值；</ol><h5 id=remove-index-操作><a class=headerlink href=#remove-index-操作 title=remove(index)操作></a>remove(index)操作</h5><ol><li>检查index是否在数组范围内，假如数组长度是2，则index必须 >= 0 且 <= 2；<li>保留要删除的值，因为最终要返回该值（旧值）；<li>计算需要移动元素的个数，再通过拷贝使数组中位置为 index+1 到 size-1 的元素向前移动一位，然后把数组最后一位元素设为null，返回旧值；</ol><h5 id=注意事项><a class=headerlink href=#注意事项 title=注意事项></a>注意事项</h5><ol><li><strong>new ArrayList创建对象时，如果没有指定容量则初始化为0；如果有指定，则按照指定大小进行初始化；</strong><li><strong>扩容时，将容量扩大1.5倍，如果还是不够则根据实际元素数量来扩大，保证能存储所有数据，比如addAll场景；</strong><li><strong>若扩容后数组长度大于 (Integer.MAX_VALUE - 8)，则抛出异常OutOfMemoryError。</strong></ol><h5 id=ArrayList-VS-Vector><a title="ArrayList VS Vector" class=headerlink href=#ArrayList-VS-Vector></a>ArrayList VS Vector</h5><ol><li>线程安全：ArrayList不安全；Vector安全；<li>扩容倍数：ArrayList默认1.5倍；Vector默认扩大为原容量的2倍，创建时也可显式设置扩容量；<li>支持序列化：ArrayList支持序列化；Vector不支持；<li>indexOf()接口支持：ArrayList提供了indexOf(obj, start)接口；Vector没有提供；<li>指定扩容系数：ArrayList不可以指定；Vector可以指定；</ol><h5 id=ArrayList-VS-LinkedList><a title="ArrayList VS LinkedList" class=headerlink href=#ArrayList-VS-LinkedList></a>ArrayList VS LinkedList</h5><ol><li>底层数据结构：ArrayList是动态数组；LinkedList是双向链表；<li>增删改查特点：ArrayList查询快增删慢；LinkedList随机查询慢，顺序查询快，增删快；<li>空间浪费：ArrayList会在数组末尾保留一定空间；LinkedList会在每一个节点都要消耗空间来存储prev、next信息；</ol><h4 id=3-3-6-4、LinkedList原理><a class=headerlink href=#3-3-6-4、LinkedList原理 title=3.3.6.4、LinkedList原理></a>3.3.6.4、LinkedList原理</h4><h5 id=add-操作><a class=headerlink href=#add-操作 title=add()操作></a>add()操作</h5><ol><li>创建一个新节点，节点元素为传入的参数，前继节点是 当前节点的last节点，后继节点next为null；<li>判断当前链表last节点是否为null，如果是，则把新建的节点作为头节点，否则把新建的节点作为last节点；<li>最后返回true；</ol><h5 id=get-index-element-操作><a title="get(index, element)操作" class=headerlink href=#get-index-element-操作></a>get(index, element)操作</h5><ol><li>检擦index是否在数组长度范围内，假如数组长度为2，则index必须 >= 0 且 < 2；<li>如果 index 小于 (双向链表长度的1/2)，则从头开始遍历查找，否则从链表末尾向前遍历查找；</ol><h5 id=remove-操作-1><a class=headerlink href=#remove-操作-1 title=remove()操作></a>remove()操作</h5><ol><li>判断first节点是否为空，如果是则抛出异常NoSuchElementException；<li>如果不为空，则把待删除节点的next节点的prev属性值设为null，达到 删除头节点的效果；<li>返回删除值；</ol><h4 id=3-3-6-5、ConcurrentHashMap><a class=headerlink href=#3-3-6-5、ConcurrentHashMap title=3.3.6.5、ConcurrentHashMap></a>3.3.6.5、ConcurrentHashMap</h4><h5 id=put-操作-1><a class=headerlink href=#put-操作-1 title=put()操作></a>put()操作</h5><ol><li>判断待插入数据key和value是否为空，如果是则抛出空指针异常；<li>判断Node[] 数组是否为空，若是则需要初始化；<li>根据hash值通过位运算计算出Node数组的下标，判断该数组第一个Node节点是否有数据，如果没有数据则通过CAS将新值插入；<li>如果有数据则判断头节点的hashcode是否等于MOVED（即-1），即检查是否正在扩容，如果等于-1则帮助扩容；<li>若有数据，则对头节点进行加锁，如果头节点的hashcode >= 0，则说明是链表，遍历链表。如果找到key和hahs同时相等，则进行覆盖；若没有找到，则将新值插入到链表的最后面；如果hashCode < 0，说明红黑树，调用红黑树的 插值方法 插入新节点；<li>插值完成后，判断链表元素是否 >= 8，如果 >=8 且数组长度 > 64则转为红黑树。如果 >= 8 且数组长度 < 64 则仅仅进行扩容；</ol><h5 id=resize-操作-1><a class=headerlink href=#resize-操作-1 title=resize()操作></a>resize()操作</h5><p>创建新数组，其长度为原数组长度的2倍；多线程环境下旧数组迁移至新数组时会发生线程安全问题；<h5 id=get-操作><a class=headerlink href=#get-操作 title=get()操作></a>get()操作</h5><ol><li>计算获取数据key的hash值；<li>根据hashCode并通过位运算得到Node数组的下标，即得到头节点；<li>如果头节点为空，则返回null；<li>如果头节点的key与参数key可以相等，则返回头节点的值；<li>如果头节点的hashcode小于0，说明是红黑树，则调用find方法按照树的方式获取值；<li>如果不满足3、4、5条件，说明是链表，则按照链表的方式遍历获取值，整个过程不需要加锁；</ol><p>注意：整个过程无需加锁，因为读取的数据被volatile修饰，实现线程可见性；<h5 id=remove-操作-2><a class=headerlink href=#remove-操作-2 title=remove()操作></a>remove()操作</h5><ol><li>计算待插入数据key的hash值；<li>判断Node[]数组是否为空，如果是则返回null；如果不是，则根据hashCode通过位运算定位到数组下标，即得到头节点；<li>判断头节点hashCode是否等于MOVED（即-1），检查是否正在扩容，如果是则帮助扩容；<li>如果2、3条件都不满足，则加锁进行删除操作；<li>首先判断头节点有无发生变化，如果有改变则返回null；<li>如果头节点hashCode大于0，说明是链表，则按照链表方式遍历删除值；<li>如果头节点是TreeBin类型，说明是红黑树，则按照红黑树方式删除值；</ol><p><font color=red>注意：remove()底层是调用replaceNode()函数实现节点删除；</font><h5 id=JDK7、JDK8-下ConcurrentHashMap的区别><a title="JDK7、JDK8 下ConcurrentHashMap的区别" class=headerlink href=#JDK7、JDK8-下ConcurrentHashMap的区别></a>JDK7、JDK8 下ConcurrentHashMap的区别</h5><ol><li><font color=orange>底层结构</font><ul><li>JDK7：<strong>以 segment 作为每组数据的容器，对segment加锁只能锁住当前segment，segment数量等于并发度。 segment数组 + entry数组 + 链表。</strong><li>JDK8：<strong>没有segment数组。 直接 entry数组 + 链表，锁粒度为entry数组中每个索引节点。</strong></ul><li><font color=orange>初始化</font>：JDK7直接初始化。JDK8会在第一次put时初始化。<li><font color=orange>锁实现</font>：JDK7<strong>使用分段锁Segment；</strong>JDK8<strong>使用CAS+Synchronized；</strong><li><font color=orange>查询遍历</font>：JDK7基于链表实现，遍历效率低；JDK8基于红黑树实现，遍历效率高；<li><font color=orange>数据存放命名</font>：JDK7使用HashEntry容器来存储数据；JDK8改名为Node容器来存储数据；<li><font color=orange>数据插入</font><ul><li>JDK7：<strong>头插法</strong>；<ol><li>segment下标位置：并发度为16，因 2^4 = 16，故下标位置就是二次hash值的二进制位的 高4位 对应的 十进制数值。<li>数组索引位置：数组长度为8，因2^3 = 8，故索引位置就是二次hash值的二进制位的 低3位 对应的 十进制数值。</ol><li>JDK8：<strong>尾插法；</strong><ol><li>1.8 中的capacity不再表示全部容量，而是一定会放入的数据数量。如果capacity为16，那么第一次会初始化一个容量为32的数组，因为容量为16，加载因子为0.75，超过12（16*0.75）才扩容，而你直接放入16个元素，那更应该扩容了。</ol></ul><li><font color=orange>扩容</font><ul><li>JDK7：<strong>容量超过3/4时才扩容，先扩容再插入值；</strong>在其它segment中创建数组时会以segment[0]中的数组大小为原型来创建。segment[0]位置初始容量：总容量 / 并发度。<li>JDK8：<strong>容量等于3/4时就扩容，先插入值再扩容；</strong>迁移数据时，从旧数组中拿数据的顺序是从右到左。</ul><li><font color=orange>锁的粒度</font><ul><li>JDK7：<strong>最大并发数是Segment的个数，默认16，锁住整个段，不影响其它段；</strong><li>JDK8：<strong>去掉分段锁，更细粒度，只锁住一个Node节点，不影响其它Node节点；</strong></ul><li><font color=orange>读写限制及扩容</font><ul><li>JDK7：扩容时锁住一个段，当前段可读不可写，其它段可读写，只开启1个线程进行扩容；<li>JDK8：锁住一个Node节点，当前节点可读不可写，其它节点可读写，1个线程+可能多个put/remove线程帮助扩容；</ul></ol><h4 id=3-3-6-6、TreeMap><a class=headerlink href=#3-3-6-6、TreeMap title=3.3.6.6、TreeMap></a>3.3.6.6、TreeMap</h4><h5 id=put-操作-2><a class=headerlink href=#put-操作-2 title=put()操作></a>put()操作</h5><p>主要分为两个步骤：<ol><li><strong>构建排序二叉树</strong><ol><li>从根节点root开始查找；<li>如果root节点比待插入节点值小，则在root节点左子树查找，如果大于，则在右子树查找；<li>递归循步骤2，找到合适节点为止；<li>把待插入节点与步骤3中查找到的节点进行对比，如果待插入节点小于找到节点，则把待插入节点作为找到节点的左子树，否则作为右子树；</ol><li><strong>构建平衡二叉树</strong></ol><h5 id=remove-操作-3><a class=headerlink href=#remove-操作-3 title=remove()操作></a>remove()操作</h5><p>比put操作复杂，同样分为两个步骤：<ol><li><strong>删除节点</strong><ol><li>待删除节点，如果没有左和右子树时，则直接删除；<li>待删除节点，如果有一个字节点时，则把它的子节点指向它的上级节点（父节点）；<li>待删除节点，如果有两个非空的子节点时，流程复杂，暂不解释；</ol><li><strong>着色旋转</strong><ol><li>进行颜色对调和旋转，达到红黑树的特征；</ol></ol><h2 id=3-4、JAVA引用><a class=headerlink href=#3-4、JAVA引用 title=3.4、JAVA引用></a>3.4、JAVA引用</h2><h3 id=3-4-1、强引用><a class=headerlink href=#3-4-1、强引用 title=3.4.1、强引用></a>3.4.1、强引用</h3><p>3.4.1.1、简介<p>JVM中默认的引用关系就是强引用，即对象被局部变量、静态变量等GC Root关联的对象引用，只要强引用存在，对象就不会被回收。<p>回收时机：<strong>当对象的引用为null时，这个对象就成为了垃圾，垃圾回收器就会回收该对象</strong>。<p>代码示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// new创建出来的对象就是强引用对象</span></span><br><span class=line><span class=type>Person</span> <span class=variable>p</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Person</span>();</span><br><span class=line><span class=comment>// 当对象引用为null时，对象就变成了垃圾</span></span><br><span class=line>p = <span class=literal>null</span>;</span><br><span class=line><span class=comment>// 调用gc方法请求垃圾回收器来回收，要注意的是垃圾回收器不一定100%会回收。</span></span><br><span class=line>System.gc(); </span><br></pre></table></figure><blockquote><p>new一个对象，这个引用就是强引用。代码中的<code>p</code>就是一个强引用。当p = null时，GC就可以回收它了。</blockquote><h3 id=3-4-2、软引用><a class=headerlink href=#3-4-2、软引用 title=3.4.2、软引用></a>3.4.2、软引用</h3><h4 id=3-4-2-1、简介><a class=headerlink href=#3-4-2-1、简介 title=3.4.2.1、简介></a>3.4.2.1、简介</h4><p>创建的SoftReference类的对象就是一个软引用。<p>回收时机：当程序内存不足时，会回收软引用对象。<p>代码示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>byte</span>[] _1M = <span class=keyword>new</span> <span class="title class_">byte</span>[<span class=number>1024</span>*<span class=number>1024</span>*<span class=number>1</span>]</span><br><span class=line>SoftReference<<span class=type>byte</span>[]> softReference = <span class=keyword>new</span> <span class="title class_">SoftReference</span>(_1M);</span><br></pre></table></figure><p>应用场景：软引用通常用于缓存框架<h3 id=3-4-3、弱引用><a class=headerlink href=#3-4-3、弱引用 title=3.4.3、弱引用></a>3.4.3、弱引用</h3><h4 id=3-4-3-1、简介><a class=headerlink href=#3-4-3-1、简介 title=3.4.3.1、简介></a>3.4.3.1、简介</h4><p>创建的WeakReference类的对象就是一个弱引用。<p>回收时机：<strong>无论当前内存是否足够，都会回收弱引用对象</strong>。<p>代码示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>byte</span>[] _1M = <span class=keyword>new</span> <span class="title class_">byte</span>[<span class=number>1024</span>*<span class=number>1024</span>*<span class=number>1</span>]</span><br><span class=line>WeakReference<<span class=type>byte</span>[]> weakReference = <span class=keyword>new</span> <span class="title class_">WeakReference</span>(_1M);</span><br></pre></table></figure><p>应用场景：弱引用在ThreadLocal中有使用。<h3 id=3-4-4、虚引用><a class=headerlink href=#3-4-4、虚引用 title=3.4.4、虚引用></a>3.4.4、虚引用</h3><h4 id=3-4-4-1、简介><a class=headerlink href=#3-4-4-1、简介 title=3.4.4.1、简介></a>3.4.4.1、简介</h4><p>创建的PhantomReference类的对象就是一个虚引用，与其他引用不同的是，虚引用会关联一个引用队列，当引用指向的对象被回收时，该引用会被放进引用队列中。无法通过虚引用获取包括在里面的对象，虚引用的作用就是在回收垃圾对象时接收到对应的通知。<p>直接内存中为了及时知道直接内存对象不再使用时进行回收，就使用了虚引用。<p>回收时机：垃圾回收器执行垃圾回收任务时就会回收，且会将该引用放入到一个引用队列中。<p>代码示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>ReferenceQueue&LTPerson> rq = <span class=keyword>new</span> <span class="title class_">ReferenceQueue</span><>();</span><br><span class=line>PhantomReference&LTPerson> phantomReference = <span class=keyword>new</span> <span class="title class_">PhantomReference</span>(<span class=keyword>new</span> <span class="title class_">Person</span>(), rq);</span><br></pre></table></figure><p>PhantomReference的构造函数有两个参数，第二个参数必须是一个队列。虚引用就是给你一个通知，通知时放在队列中，你只需判断队列是否为null，如果队列不为 null 说明虚引用已被回收。<p>应用场景：处理堆外内存。（参考NIO中的DirectByteBuffer，即直接内存，直接内存不受JVM管理，而是被系统管理，故又叫堆外内存。堆外内存的回收可以使用虚引用来实现。）<h3 id=3-4-5、终结器引用><a class=headerlink href=#3-4-5、终结器引用 title=3.4.5、终结器引用></a>3.4.5、终结器引用</h3><h4 id=3-4-5-1、简介><a class=headerlink href=#3-4-5-1、简介 title=3.4.5.1、简介></a>3.4.5.1、简介</h4><p>终结器引用指的是在对象需要被回收时，终结器引用会关联对象并放到Finalizer类中的引用队列中，稍后会有一个FinalizerThread线程从队列中获取对象，然后执行对象的finalize方法，在对象被第二次回收时，该对象才会被真正的回收。<h1 id=4、Java内存模型><a class=headerlink href=#4、Java内存模型 title=4、Java内存模型></a>4、Java内存模型</h1><h2 id=4-1、简介><a class=headerlink href=#4-1、简介 title=4.1、简介></a>4.1、简介</h2><h3 id=4-1-1、前言><a class=headerlink href=#4-1-1、前言 title=4.1.1、前言></a>4.1.1、前言</h3><p>并发编程中，需要处理两个关键问题：<strong>线程之间如何通信及线程之间如何同步。</strong><p><strong>（1）通信</strong><p>通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：<ul><li><p>共享内存</p> <p>在共享内存的并发模型里，线程之间共享程序的公共状态，通过写-读内存中的公共状态 进行隐式通信。</p><li><p>消息传递。</p> <p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。</p></ul><p><strong>（2）同步</strong><p>同步是指程序中用于控制不同线程间操作发生相对顺序的机制。<p>在共享内存并发模型里，同步显式进行。在消息传递的并发模型里，由于消息发送必须在消息接收前，因此同步是隐式进行的。<p><strong>Java并发采用的是共享内存模型，Java线程间的通信是隐式进行，整个通信过程对程序员完全透明。</strong><h3 id=4-1-2、认识JMM><a class=headerlink href=#4-1-2、认识JMM title=4.1.2、认识JMM></a>4.1.2、认识JMM</h3><p><strong>Java内存模型是根据英文Java Memory Model（JMM）翻译过来。其实JMM并不像JVM内存结构一样真实存在。他只是一个抽象概念。</strong><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了主内存变量的副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间无法直接访问对方工作内存中的变量，线程间的通信需要通过主内存来实现。<p><strong>JMM作用于工作内存和主存之间的数据同步过程。它规定了如何做数据同步以及什么时候做数据同步。</strong><p><img alt=image-20210424211138529 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210424211138529.png?token=AIGEF3JZVGM2SSRA5JMZNGDEZZXWK><p>Java内存模型的相关知识在<code>JSR-133: Java Memory Model and Thread Specification</code>中有描述。JMM是和多线程相关，它描述了一组规则或规范，这个规范规定了一个线程对共享变量的写入对另一个线程是可见的。<p><strong>Java内存模型（Java Memory Model，JMM）就是一种符合内存模型规范，屏蔽了各种硬件和操作系统访问差异，保证了Java程序在各种平台下对内存的访问都能得到一致效果的机制及规范。目的是解决多线程环境中基于共享内存进行通信时，存在的原子性、可见性（缓存一致性）以及有序性问题。</strong><h2 id=4-2、重要概念><a class=headerlink href=#4-2、重要概念 title=4.2、重要概念></a>4.2、重要概念</h2><h3 id=4-2-1、原子性问题><a class=headerlink href=#4-2-1、原子性问题 title=4.2.1、原子性问题></a>4.2.1、原子性问题</h3><p><strong>线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。</strong>所以在多线程场景下，就会发生原子性问题。<p>例如：线程要完成一个读、改、写操作，但在执行完读、改之后，时间片耗完了，此时就要放弃CPU，并等待重新调度。这种情况下，读改写就不是一个原子操作。即存在原子性问题。<h3 id=4-2-2、一致性问题><a class=headerlink href=#4-2-2、一致性问题 title=4.2.2、一致性问题></a>4.2.2、一致性问题</h3><p><strong>多核CPU 和 多线程场景中，每个核都至少有一个L1 缓存。</strong>多个线程访问进程中的某个共享内存，且多个线程分别在不同的核心上执行，则每个核心都会在各自的cache中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自缓存的情况，而各自cache之间的数据就有可能不同。<p>在CPU和主存之间增加缓存可能导致在多线程场景下出现缓存一致性问题，多核CPU的每个核的缓存中，对于同一数据可能有不同的副本。<h3 id=4-2-3、有序性问题><a class=headerlink href=#4-2-3、有序性问题 title=4.2.3、有序性问题></a>4.2.3、有序性问题</h3><p><strong>现代的处理器使用 写缓冲区 临时保存向内存写入的数据。</strong>写缓冲区可以保证指令流水线持续运行，可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。它可以通过 批处理 刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写来减少对内存总线的占用。<p>但要注意，<strong>每个处理器上的写缓冲区，仅仅对它所在的处理器可见。</strong>这个特性会对内存操作的执行顺序产生重要影响：<strong>处理器对内存读/写操作的执行顺序不一定与内存实际发生的读/写操作顺序一致。</strong><p>由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的 顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此 现代的处理器都会允许对写-读操作进行重排序。<p>为提高性能，编译器和处理器会对指令做重排序。重排序分3种类型：<ol><li>编译器优化重排序。（编译器重排序）<li>指令级并行重排序。（处理器重排序）<li>内存系统重排序。（处理器重排序）</ol><p>从Java源代码到最终执行的指令序列，会经历下面3种重排序：<p><img alt=Java内存模型-1.1-指令重排序-源码到执行指令间的重排序过程 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-1.1-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F-%E6%BA%90%E7%A0%81%E5%88%B0%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4%E9%97%B4%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B.png?token=AIGEF3PREC67A44L2UZB5ADEZZX4Q><p><strong>重排序可能会导致多线程程序出现内存可见性问题。</strong><h3 id=4-2-4、内存模型><a class=headerlink href=#4-2-4、内存模型 title=4.2.4、内存模型></a>4.2.4、内存模型</h3><p><strong>CPU多级缓存导致的一致性问题、CPU时间片机制导致的原子性问题、以及处理器优化和指令重排导致的有序性问题等，都是由硬件不断升级导致。</strong><p>为了保证并发编程中可以满足原子性、可见性及有序性，内存模型 就出现了。<p>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器、缓存、并发、编译器有关。它解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。<p><strong>Java语言为了屏蔽掉底层差异，定义了一套属于Java语言的内存模型规范，即Java内存模型。</strong><h2 id=4-3、底层实现><a class=headerlink href=#4-3、底层实现 title=4.3、底层实现></a>4.3、底层实现</h2><h3 id=4-3-1、happens-before><a class=headerlink href=#4-3-1、happens-before title=4.3.1、happens-before></a>4.3.1、happens-before</h3><p>happens-before的概念最初由<em><strong>Leslie Lamport</strong></em>在其一篇影响深远的论文（《Time，Clocks and the Ordering of Events in a Distributed System》）中提出。<p>从JDK 5开始，Java使用新的JSR-133内存模型。JSR-133使用happens-before的概念来指定两个操作之间的执行顺序。<p>在JMM中，<strong>如果一 个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。</strong>这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。<p><strong>happens-before规则有8个</strong>，详情如下：<ul><li><strong>程序次序规则</strong>：一个线程中的每个操作，happens-before于该线程中的任意后续操作。（线程中的代码顺序执行）<li><strong>管程锁定规则</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。（先解锁后加锁）<li><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的 读。（先volatile写后volatile读）<li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。<li><strong>对象终结规则</strong>：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize()方法的开始。<li><strong>线程启动规则</strong>：Thread对象的start()方法先行发生于此线程的每一个动作。<li><strong>线程中断规则</strong>：对线程interrupt()方法的调用先行发生于被中断线程 的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生。<li><strong>线程终止规则</strong>：线程中的所有操作都先行发生于对此线程的终止检 测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。</ul><p>JMM把happens-before 要求禁止的重排序分为下面两种：<ul><li><p><strong>会改变程序执行结果的重排序</strong>：对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。</p><li><p><strong>不会改变程序执行结果的重排序</strong>:对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM允许这种重排序）。</p></ul><blockquote><p>两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个 操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一 个操作按顺序排在第二个操作之前。<p>如果前一个操作的结果不需要对后一个操作可见，且前后两个操作按happens-before关系来执行 与 不按照happens-before关系来执行的结果如果完全一致，那么JMM允许这种重排序。</blockquote><h3 id=4-3-2、as-if-serial><a class=headerlink href=#4-3-2、as-if-serial title=4.3.2、as-if-serial></a>4.3.2、as-if-serial</h3><p>as-if-serial语义是：<strong>不管怎么重排序（编译器和处理器为了提高并行度），（单线程） 程序的执行结果不能被改变。</strong>编译器、runtime和处理器都必须遵守as-if-serial语义。<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。<p>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证了正确同步的多线程程序执行结果的正确性。<h3 id=4-3-3、volatile内存语义><a class=headerlink href=#4-3-3、volatile内存语义 title=4.3.3、volatile内存语义></a>4.3.3、volatile内存语义</h3><h4 id=volatile写内存语义><a class=headerlink href=#volatile写内存语义 title=volatile写内存语义></a>volatile写内存语义</h4><p><strong>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</strong><h4 id=volatile读内存语义><a class=headerlink href=#volatile读内存语义 title=volatile读内存语义></a>volatile读内存语义</h4><p><strong>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</strong><h4 id=底层实现><a class=headerlink href=#底层实现 title=底层实现></a>底层实现</h4><p><strong>为了实现volatile内存语义，JMM会限制 编译器重排序 和 处理器重排序。</strong><p>JMM禁止 编译器重排序 的规则如下：<p><img alt=image-20230805235157835 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805235157835.png?token=AIGEF3KZOENBUAHU2SOPZ2DEZZYFW><blockquote><p>在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量重排序。</blockquote><h3 id=4-3-4、锁内存语义><a class=headerlink href=#4-3-4、锁内存语义 title=4.3.4、锁内存语义></a>4.3.4、锁内存语义</h3><h4 id=锁获取内存语义><a class=headerlink href=#锁获取内存语义 title=锁获取内存语义></a>锁获取内存语义</h4><p><strong>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的 临界区代码必须从主内存中读取共享变量。</strong><h4 id=锁释放内存语义><a class=headerlink href=#锁释放内存语义 title=锁释放内存语义></a>锁释放内存语义</h4><p><strong>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。</strong><blockquote><p>对比锁释放-获取的内存语义与volatile写-读的内存语义可以看出：锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。</blockquote><h4 id=公平锁和非公平锁内存语义><a class=headerlink href=#公平锁和非公平锁内存语义 title=公平锁和非公平锁内存语义></a>公平锁和非公平锁内存语义</h4><ul><li>公平锁和非公平锁释放时，最后都要写一个volatile变量state。<li>公平锁获取时，首先会去读volatile变量。<li>非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile 写的内存语义。</ul><h3 id=4-3-4、final域内存语义><a class=headerlink href=#4-3-4、final域内存语义 title=4.3.4、final域内存语义></a>4.3.4、final域内存语义</h3><p>对于final域，编译器和处理器要遵守两个重排序规则：<ol><li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两者不能重排序。<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能 重排序。</ol><h3 id=4-4-1、原子性><a class=headerlink href=#4-4-1、原子性 title=4.4.1、原子性></a>4.4.1、原子性</h3><p><strong>Java为了保证原子性，提供了两个高级字节码指令<code>monitorenter</code>和<code>monitorexit</code>。在Java中对应的关键字就是synchronized。</strong><p>Java中可以使用synchronized来保证方法和代码块内操作的原子性。<h3 id=4-4-2、可见性><a class=headerlink href=#4-4-2、可见性 title=4.4.2、可见性></a>4.4.2、可见性</h3><p>Java中的关键字volatile有一个功能：<strong>被其修饰的变量在被修改后必须立即同步到主内存，被其修饰的变量在每次使用时都必须从主内存获取。</strong>因此，可以使用volatile来保证多线程操作时变量的可见性。<p>除了volatile，Java中的synchronized和final关键字也可以实现可见性。只不过实现方式不同。<h3 id=4-4-3、有序性><a class=headerlink href=#4-4-3、有序性 title=4.4.3、有序性></a>4.4.3、有序性</h3><p><strong>Java在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。</strong>JMM把内存屏障指令分为4类：<p><img alt=内存屏障类型 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-1.2-%E5%8F%AF%E8%A7%81%E6%80%A7-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E7%B1%BB%E5%9E%8B.png?token=AIGEF3LKY332SGI2CDZSVN3EZZYI2><p><strong>StoreLoad Barriers是一个全能型屏障，它同时具有其他3个屏障的效果。</strong>目前 处理器大多支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为 处理器 要把 写缓冲区数据 全部刷新到内存中（Buffer Fully Flush）。<p>Java中的 synchronized 和 volatile 都可以保证多线程之间操作的有序性。区别：<ul><li>volatile关键字 能 禁止指令重排。<li>synchronized关键字 能 保证同一时刻只有一条线程运行。</ul><h1 id=5、JAVA并发><a class=headerlink href=#5、JAVA并发 title=5、JAVA并发></a>5、JAVA并发</h1><h2 id=5-1、Synchronized><a class=headerlink href=#5-1、Synchronized title=5.1、Synchronized></a>5.1、Synchronized</h2><h3 id=5-1-1、简介><a class=headerlink href=#5-1-1、简介 title=5.1.1、简介></a>5.1.1、简介</h3><p>synchronized一直被认为是重量级锁。随着Java SE 1.6对<code>synchronized</code>进行了各种优化之后，它就并不那么重了。<p><strong>Java SE 1.6中，锁共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，这几个状态会随着竞争情况逐渐升级。</strong>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。<h3 id=5-1-2、底层实现><a class=headerlink href=#5-1-2、底层实现 title=5.1.2、底层实现></a>5.1.2、底层实现</h3><ul><li><p>Java源码层级：synchronized(o)。</p><li><p>字节码层级：</p> <ul><li>synchronized修饰方法（包括实例方法和静态方法）：添加访问标志<code>ACC_SYNCHRONIZED</code>。<li>synchronized修饰同步块：一般情况下都是添加 1个monitor enter 和 2个monitor exit，如果在同步方法中显式抛出异常，那么只会有1个monitor enter 和 1个monitor exit。</ul><li><p>JVM层级：基于操作系统提供的同步机制。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">T01_Sync1</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>Object</span> <span class=variable>o</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Object</span>();</span><br><span class=line>        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>com.T01_Sync1$Lock object internals:</span><br><span class=line> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class=line>      <span class=number>0</span>     <span class=number>4</span>   (object header)  <span class=number>05</span> <span class=number>00</span> <span class=number>00</span> <span class=number>00</span> (<span class=number>00000101</span> <span class=number>00000000</span> <span class=number>00000000</span> <span class=number>00000000</span>) (<span class=number>5</span>)</span><br><span class=line>      <span class=number>4</span>     <span class=number>4</span>   (object header)  <span class=number>00</span> <span class=number>00</span> <span class=number>00</span> <span class=number>00</span> (<span class=number>00000000</span> <span class=number>00000000</span> <span class=number>00000000</span> <span class=number>00000000</span>) (<span class=number>0</span>)</span><br><span class=line>      <span class=number>8</span>     <span class=number>4</span>   (object header)  <span class=number>49</span> ce <span class=number>00</span> <span class=number>20</span> (<span class=number>01001001</span> <span class=number>11001110</span> <span class=number>00000000</span> <span class=number>00100000</span>) (<span class=number>536923721</span>)</span><br><span class=line>     <span class=number>12</span>     <span class=number>4</span>        (loss due to the next object alignment)</span><br><span class=line>Instance size: <span class=number>16</span> bytes</span><br><span class=line>Space losses: <span class=number>0</span> bytes internal + <span class=number>4</span> <span class=type>bytes</span> <span class=variable>external</span> <span class=operator>=</span> <span class=number>4</span> bytes total</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>com.T02_Sync2$Lock object internals:</span><br><span class=line> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class=line>      <span class=number>0</span>     <span class=number>4</span>   (object header)  <span class=number>05</span> <span class=number>90</span> 2e 1e (<span class=number>00000101</span> <span class=number>10010000</span> <span class=number>00101110</span> <span class=number>00011110</span>) (<span class=number>506368005</span>)</span><br><span class=line>      <span class=number>4</span>     <span class=number>4</span>   (object header)  1b <span class=number>02</span> <span class=number>00</span> <span class=number>00</span> (<span class=number>00011011</span> <span class=number>00000010</span> <span class=number>00000000</span> <span class=number>00000000</span>) (<span class=number>539</span>)</span><br><span class=line>      <span class=number>8</span>     <span class=number>4</span>   (object header)  <span class=number>49</span> ce <span class=number>00</span> <span class=number>20</span> (<span class=number>01001001</span> <span class=number>11001110</span> <span class=number>00000000</span> <span class=number>00100000</span>) (<span class=number>536923721</span>)</span><br><span class=line>     <span class=number>12</span>     <span class=number>4</span>        (loss due to the next object alignment)</span><br><span class=line>Instance size: <span class=number>16</span> bytes</span><br><span class=line>Space losses: <span class=number>0</span> bytes internal + <span class=number>4</span> <span class=type>bytes</span> <span class=variable>external</span> <span class=operator>=</span> <span class=number>4</span> bytes tota</span><br></pre></table></figure><li><p>OS/硬件层面</p> <ul><li>X86：使用指令 lock cmpxchg xxx 来实现。</ul></ul><h3 id=5-1-3、锁优化><a class=headerlink href=#5-1-3、锁优化 title=5.1.3、锁优化></a>5.1.3、锁优化</h3><h4 id=自旋锁与自适应自旋><a class=headerlink href=#自旋锁与自适应自旋 title=自旋锁与自适应自旋></a>自旋锁与自适应自旋</h4><p><strong>JDK 1.4.2引入了自旋锁，默认关闭，可使用参数<code>-XX:+UseSpinning</code>开启，JDK 6中改为默认开启。</strong><p>自旋等待不能代替阻塞，自旋等待虽然避免了线程切换的开销，但它要占用处理器时间，如果锁被占用的时间很短，自旋等待效果就会非常好，反之如果锁被占用时间很长，那么自旋线程只会白白消耗处理器资源，这会带来性能的浪费。因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍没有获得锁，就应当使用传统方式挂起线程。<strong>自旋次数默认是十次，也可以使用参数<code>-XX:PreBlockSpin</code>来修改。</strong><p><strong>JDK 6对自旋锁做了优化，引入了自适应自旋。</strong>自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待更长时间。另一方面，如果对于某个锁，自旋很少成功获得锁，那么后期再获取这个锁时可能直接省略自旋过程，以避免浪费处理器资源。<p><strong>JDK7之后就不能控制是否开启自旋功能了。</strong><h4 id=锁消除><a class=headerlink href=#锁消除 title=锁消除></a>锁消除</h4><p><strong>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但实际不会发生共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">add</span><span class=params>(String str1,String str2)</span>{</span><br><span class=line>    <span class=type>StringBuffer</span> <span class=variable>sb</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StringBuffer</span>();</span><br><span class=line>    sb.append(str1).append(str2);</span><br><span class=line>}</span><br></pre></table></figure><p>StringBuffer是线程安全的，因为它的关键方法被<code>synchronized</code>修饰。引用sb只会在<code>add</code>方法中使用，不会发生方法逃逸和线程逃逸，故JVM会自动消除掉StringBuffer对象内部的锁。<blockquote><p>在JDK 5之前，字符串加法会转化为StringBuffer 对象的连续append()操作，在JDK 5及以后的版本中，会转化为StringBuilder对象的连续append()操作。</blockquote><h4 id=锁粗化><a class=headerlink href=#锁粗化 title=锁粗化></a>锁粗化</h4><p>原则上，在编写代码时，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了尽可能减少需要同步的操作数量，即使存在锁竞争，等待锁的线程也能尽快地拿到锁。<p>大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作出现在循环体之中，那即使没有线程竞争，频繁进行互斥同步操作也会导致不必要的性能损耗。<p>比如以下代码，没有锁粗化时需要执行100次加锁/解锁操作，执行 锁粗化 优化后只需要加一次锁即可。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> String <span class="title function_">test</span><span class=params>(String str)</span>{</span><br><span class=line>    <span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=type>StringBuffer</span> <span class=variable>sb</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StringBuffer</span>():</span><br><span class=line>    <span class=keyword>while</span>(i < <span class=number>100</span>){</span><br><span class=line>    	sb.append(str);</span><br><span class=line>    	i++;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> sb.toString():</span><br><span class=line>}</span><br></pre></table></figure><h4 id=偏向锁><a class=headerlink href=#偏向锁 title=偏向锁></a>偏向锁</h4><h5 id=简介><a class=headerlink href=#简介 title=简介></a>简介</h5><p><strong>JDK 6引入偏向锁，目的是消除数据在无竞争情况下的同步原语， 进一步提高程序运行性能。</strong><p>偏向锁中的“偏”，就是偏心的“偏”、偏袒的“偏”。它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，没有其它线程来获取这个锁，则持有偏向锁的线程将永远不需要再进行同步。<h5 id=工作过程><a class=headerlink href=#工作过程 title=工作过程></a>工作过程</h5><p><strong>当锁对象第一次被线程获取时，虚拟机会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后再次进入同步块时，就不需要再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作 等）。</strong><p>若有其它线程尝试获取锁，偏向模式会马上结束。根据锁对象目前是否处于被锁定的状态来决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位 为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照轻量级锁工作流程来执行。<h5 id=总结><a class=headerlink href=#总结 title=总结></a>总结</h5><p>当对象进入偏向状态时，Mark Word大部分的空间（23个比特）都用于存储持有锁的线程ID了，这部分空间占用了原有存储对象哈希码的位置，那原来对象的哈希码怎么办呢？<p>一个对象如果计算过哈希码，就应该一直保持该值不变（推荐但不强制，因为用户可以重载hashCode()方法），否则很多依赖对象哈希码的API都可能存在出错风险。而作为绝大多数对象哈希码来源的Object::hashCode()方法，返回的是对象的一致性哈希码（Identity Hash Code），这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一 次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变。因此，<strong>当一个对象已经计算过一 致性哈希码后，它就再也无法进入偏向锁状态了</strong>；而<strong>当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁</strong>。在重量级锁实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码。<blockquote><p><font color=red>注意：如果请求获取的hashcode值来源于对Object::hashCode()或者System::identityHashCode(Object)方法的调用，那么才会撤销偏向锁并升级为重量级锁；反之，如果重写了对象的hashCode()方法，计算哈希码时并不会触发偏向锁的撤销和重量级锁的升级。</font></blockquote><p>偏向锁可以提高带有同步但无竞争的程序性能，但它同样是一个带有效益权衡（Trade Off）性质的优化，也就是说它并非总是对程序运行有利。如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数<code>-XX:-UseBiasedLocking</code>来禁止偏向锁优化反而可以提升性能。<h4 id=轻量级锁><a class=headerlink href=#轻量级锁 title=轻量级锁></a>轻量级锁</h4><h5 id=简介-1><a class=headerlink href=#简介-1 title=简介></a>简介</h5><p><strong>JDK 6引入了轻量级锁。</strong>“轻量级”是相对于使用操作系统互斥量来实现锁而言，因此传统锁机制被称为“重量级”锁。轻量级锁并不能代替重量级锁，它设计的初衷是在没有多线程竞争的前提下，减少重量级锁使用操作系统互斥量产生的性能消耗。<h5 id=工作过程-1><a class=headerlink href=#工作过程-1 title=工作过程></a>工作过程</h5><p><strong>在代码即将进入同步块时，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word）。</strong><p>然后，虚拟机将<strong>使用CAS操作尝试把锁对象的Mark Word更新为指向Lock Record的指针</strong>。<ul><li>如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且锁对象Mark Word的锁标志位（Mark Word的 最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。<li>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志状态值变为“10”，此时锁对象Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。</ul><p>上面描述的是轻量级锁的加锁过程，它的解锁过程也同样是通过CAS操作来进行，如果对象的 Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，且被阻塞挂起，那么获取到锁的线程在释放锁的同时就要唤醒被挂起的线程。<h5 id=总结-1><a class=headerlink href=#总结-1 title=总结></a>总结</h5><p>轻量级锁能提升程序同步性能的依据是”对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下， 轻量级锁反而会比传统的重量级锁更慢。<p>偏向锁、轻量级锁的状态转化及对象Mark Word的关系如下图所示：<p><img alt=偏向锁、轻量级锁与MarkWord的关系 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E4%B8%8EMarkWord%E7%9A%84%E5%85%B3%E7%B3%BB.png?token=AIGEF3IKANGCKSJOPH3WQ2LEZZYK6><h3 id=5-1-4、锁升级><a class=headerlink href=#5-1-4、锁升级 title=5.1.4、锁升级></a>5.1.4、锁升级</h3><h4 id=5-1-4-1、无锁状态><a class=headerlink href=#5-1-4-1、无锁状态 title=5.1.4.1、无锁状态></a>5.1.4.1、无锁状态</h4><p><strong>new一个对象，默认就是无锁状态。</strong><h4 id=5-1-4-2、偏向锁><a class=headerlink href=#5-1-4-2、偏向锁 title=5.1.4.2、偏向锁></a>5.1.4.2、偏向锁</h4><h5 id=偏向锁来历><a class=headerlink href=#偏向锁来历 title=偏向锁来历></a>偏向锁来历</h5><p>HotSpot作者研究发现，通常不存在锁竞争，而是一个线程经常多次获得同一个锁。所以每次都要竞争锁会消耗很多资源，为了降低获取锁的代价就引入了偏向锁。<h5 id=偏向锁获取><a class=headerlink href=#偏向锁获取 title=偏向锁获取></a>偏向锁获取</h5><p><strong>首次访问锁的线程，偏向锁会偏向于该线程。有其它线程争夺锁时会撤销偏向锁，然后升级为轻量级锁。</strong><p>偏向锁 获取和撤销 过程描述如下：<p>当锁对象首次被线程获取时，会将获取到该锁的线程ID记录在锁对象的Mark Word中，以后该线程在进入和退出 同步块时不需要执行CAS操作来加锁和解锁：<ul><li>如果一致（依然是线程1获取锁对象），则无需通过CAS进行加锁、解锁；<li>如果不一致（其他线程（线程2）要竞争锁对象），则需要检查Java对象头中记录的线程1是否存活：<ul><li>如果没有存活，那么锁状态将被重置为无锁状态，其它线程（线程2）可以将其设为偏向锁；<li>如果存活，那么检查该线程（线程1）的栈帧信息，如果线程1依然需要这个锁，则暂停当前线程1并撤销偏向锁，然后升级为轻量级锁。如果线程1 不再使用该锁对象，那么锁状态将被设为无锁状态，然后重新偏向新的线程。</ul></ul><p>获取偏向锁详细步骤 参考如下：<ol><li>验证对象的bias位。如果是0，则表示该对象不可偏向，应该使用轻量级锁算法。<li>验证对象所属InstanceKlass的prototype的bias位是否被设置。如果没有设置，则该类所有对象全部不允许被偏向锁定，且所有对象的bias位都需要被重置，使用轻量级锁来替换。<li>校验epoch位。校验对象头中MarkWord的epoch位是否与该对象所属InstanceKlass的prototype的MarkWord的epoch匹配。如果不匹配，则表明偏向已过期，需要重新偏向。偏向线程可以通过CAS指令重新偏向于这个锁对象。<li>校验owner线程。比较偏向线程ID与当前线程ID。如果匹配，则表明当前线程已经获得了偏向，可以安全返回。如果不匹配，对象锁被假定为匿名偏向状态，当前线程应该尝试使用CAS指令获得偏向。如果失败的话，就尝试撤销(很可能引入安全点)，然后回退到轻量级锁；如果成功，当前线程成功获得偏向，可直接返回。</ol><h5 id=偏向锁关闭><a class=headerlink href=#偏向锁关闭 title=偏向锁关闭></a>偏向锁关闭</h5><p><strong>偏向锁在Java 6和Java 7中默认启用，但它仅在程序启动几秒后才激活，可通过JVM参数<code>-XX:BiasedLockingStartupDelay=0</code>来关闭该延迟。</strong><p><strong>如果程序线程通常处于竞争状态，可以通过JVM参数<code>-XX:-UseBiasedLocking</code>关闭偏向锁，那么程序默认会直接进入轻量级锁状态。</strong><p>HotSpot支持 存储/释放 偏向锁，以及偏向锁的批量重偏向和撤销。这个特性可以通过JVM参数进行切换，且默认支持。Unlock状态下MarkWord的一个比特位用于标识该对象偏向锁是否被使用或者是否被禁止。如果该bit位为0，则该对象未被锁定，并且禁止偏向；如果该bit位为1，则意味着该对象处于以下三种状态：<ol><li><font color=orange>匿名偏向(Anonymously Biased)</font><li><font color=orange>可重偏向(Rebiasable)</font><li><font color=orange>已偏向(Biased)</font></ol><h4 id=5-1-4-3、轻量级锁><a class=headerlink href=#5-1-4-3、轻量级锁 title=5.1.4.3、轻量级锁></a>5.1.4.3、轻量级锁</h4><h5 id=轻量级锁来历><a class=headerlink href=#轻量级锁来历 title=轻量级锁来历></a>轻量级锁来历</h5><p><strong>轻量级锁适用于 并发高但执行时间短的场景。</strong>线程阻塞将导致用户态与内核态的切换，若阻塞时间很短后锁就被释放了，那么代价会更大。为解决该问题，轻量级锁就出现了。<h5 id=轻量级锁加锁><a class=headerlink href=#轻量级锁加锁 title=轻量级锁加锁></a>轻量级锁加锁</h5><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用 CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。<h5 id=轻量级锁解锁><a class=headerlink href=#轻量级锁解锁 title=轻量级锁解锁></a>轻量级锁解锁</h5><p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。<h5 id=轻量级锁升级><a class=headerlink href=#轻量级锁升级 title=轻量级锁升级></a>轻量级锁升级</h5><p>轻量级锁的升级过程描述如下：<ol><li>线程1获取轻量级锁时会先把锁对象对象头的MarkWord拷贝一份放到线程1栈帧中（称为DisplacedMarkWord），然后通过CAS方式把对象头中的内容替换为指向线程1中锁记录（DisplacedMarkWord）的指针。<li>线程1在修改替换对象头时，线程2进来也需要执行相关操作，但线程2在执行CAS时发现线程1已经把对象头换了，此时线程2的CAS会失败，然后线程2会尝试使用自旋锁来等待线程1释放锁。<li>线程2自旋次数达到上限时还没有获取锁，那么线程2就会将轻量级锁升级为重量级锁，然后线程2会进入到重量级锁的等待队列中进行等待，后续来的线程也会进入该队列进行等待，直到线程1执行完毕释放了锁，然后唤醒等待队列中的线程。</ol><blockquote><p>自旋达到上限时会升级到重量级锁，这里的上限分两种情况：<ul><li><p>Java6之前</p> <ol><li>默认启用，自旋次数的默认值是10次，也可以使用参数<code>-XX：PreBlockSpin</code>来修改。<li>或者，自旋线程数量超过CPU核数一半时升级为重量级锁。</ol><li><p>Java6之后，引入自适应自旋，自旋次数不再固定，而是根据：同一把锁上次的自旋时间 和 拥有锁的线程的状态来决定。</p> <ol><li>如果线程自旋成功，那么下次自旋的最大次数就会增加，因为JVM会认为上次都已经成功了，那么这次大概率也会成功。<li>如果自旋很少成功，那么下次会减少自旋次数甚至是不再自旋，避免CPU空转，消费资源。</ol></ul></blockquote><p><font color=red>注意：</font><p>使用CAS自旋去争夺锁，会导致无意义的CPU占用。所以，<strong>轻量级锁适用于 线程少且执行时间短 的场景。</strong><h4 id=5-1-4-4、重量级锁><a class=headerlink href=#5-1-4-4、重量级锁 title=5.1.4.4、重量级锁></a>5.1.4.4、重量级锁</h4><p>重量级锁竞争时，可以使用自旋来优化。如果当前线程自旋成功（其它线程释放了锁，当前线程获取了锁），那么就可以避免当前线程被阻塞。如果自旋次数达到上限时还没有获取锁，那么就会将轻量级锁升级为重量级锁，然后当前线程会进入到重量级锁的等待队列中进行等待，后续来的线程也会进入该队列进行等待，直到拿到锁的线程执行完毕释放了锁，然后才会唤醒等待队列中的线程。<p><strong>重量级锁底层实现是一个Monitor对象，俗称Monitor锁，该对象有WaitSet、EntryList、Owner等重要成员。</strong><p><strong>获取轻量级锁失败的线程会将轻量级锁升级为重量级锁，此时会创建Monitor锁对象，然后会在synchronized修饰的锁对象头的markword中存入Monitor对象的地址并设置锁标识位为10，并设置Monitor锁对象的Owner指向获取锁的线程，获取锁失败的线程会进入到Monitor锁对象的EntryList中进行等待，直到获取锁的线程释放了锁，并将Owner设置为null，然后会唤醒EntryList中等待的线程来重新竞争锁。</strong><h4 id=小结><a class=headerlink href=#小结 title=小结></a>小结</h4><p>锁升级注意事项：<ol><li>为了避免无用自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁；<li>偏向锁升级为轻量级锁也不能再降级为偏向锁；<li>偏向锁状态可以被重置为无锁状态；</ol><p>锁优缺点对比：<p><img alt=Synachonized-1.1-锁的优缺点 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/Synachonized-1.1-%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png?token=AIGEF3NTWUVMKCIFTZIAWITEZZYNA><h3 id=5-1-5、锁降级><a class=headerlink href=#5-1-5、锁降级 title=5.1.5、锁降级></a>5.1.5、锁降级</h3><p><a href=https://zhuanlan.zhihu.com/p/28505703 rel=noopener target=_blank>https://zhuanlan.zhihu.com/p/28505703</a><p><strong>只被<code>VM Thread</code>访问，降级也就没啥意义了。所以可以认为锁降级不存在！</strong><h4 id=降级目的和过程><a class=headerlink href=#降级目的和过程 title=降级目的和过程></a>降级目的和过程</h4><p>因为BasicLocking的实现优先于重量级锁的使用，JVM会尝试在STW的停顿中对处于“空闲(idle)”状态的重量级锁进行降级(deflate)。我们知道在STW时，所有的Java线程都会暂停在“安全点(SafePoint)”，此时VM Thread通过对所有Monitor进行遍历，或者通过对所有依赖于<code>MonitorInUseLists</code>值的当前正在“使用”中的<code>Monitor</code>子序列进行遍历，从而得到那些未被使用的“Monitor”并将之作为降级对象。<h4 id=降级对象><a class=headerlink href=#降级对象 title=降级对象></a>降级对象</h4><p><strong>重量级锁的降级发生于STW阶段，降级对象就是那些仅仅能被 VM Thread 访问而没有被其它 Java Thread 访问的Monitor对象。</strong><h4 id=HotSpot-VM实现><a title="HotSpot VM实现" class=headerlink href=#HotSpot-VM实现></a>HotSpot VM实现</h4><p>HotSpot VM锁降级底层实现，可以参考：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> ObjectSynchronizer::deflate_idle_monitors() {</span><br><span class=line>  <span class=keyword>assert</span>(SafepointSynchronize::is_at_safepoint(), <span class=string>"must be at safepoint"</span>);</span><br><span class=line>  <span class=type>int</span> <span class=variable>nInuse</span> <span class=operator>=</span> <span class=number>0</span> ;              <span class=comment>// currently associated with objects</span></span><br><span class=line>  <span class=type>int</span> <span class=variable>nInCirculation</span> <span class=operator>=</span> <span class=number>0</span> ;      <span class=comment>// extant</span></span><br><span class=line>  <span class=type>int</span> <span class=variable>nScavenged</span> <span class=operator>=</span> <span class=number>0</span> ;          <span class=comment>// reclaimed</span></span><br><span class=line>  <span class=type>bool</span> <span class=variable>deflated</span> <span class=operator>=</span> <span class=literal>false</span>;</span><br><span class=line></span><br><span class=line>  ObjectMonitor * FreeHead = NULL ;  <span class=comment>// Local SLL of scavenged monitors</span></span><br><span class=line>  ObjectMonitor * FreeTail = NULL ;</span><br><span class=line></span><br><span class=line>  TEVENT (deflate_idle_monitors) ;</span><br><span class=line><span class=comment>// Prevent omFlush from changing mids in Thread dtor's during deflation</span></span><br><span class=line><span class=comment>// And in case the vm thread is acquiring a lock during a safepoint</span></span><br><span class=line><span class=comment>// See e.g. 6320749</span></span><br><span class=line>  Thread::muxAcquire (&ListLock, <span class=string>"scavenge - return"</span>) ;</span><br><span class=line></span><br><span class=line>  <span class=keyword>if</span> (MonitorInUseLists) {</span><br><span class=line>    <span class=type>int</span> <span class=variable>inUse</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>for</span> (JavaThread* cur = Threads::first(); cur != NULL; cur = cur->next()) {</span><br><span class=line>      nInCirculation+= cur->omInUseCount;</span><br><span class=line>      <span class=type>int</span> <span class=variable>deflatedcount</span> <span class=operator>=</span> walk_monitor_list(cur->omInUseList_addr(), &FreeHead, &FreeTail);</span><br><span class=line>      cur->omInUseCount-= deflatedcount;</span><br><span class=line><span class=comment>// verifyInUse(cur);</span></span><br><span class=line>      nScavenged += deflatedcount;</span><br><span class=line>      nInuse += cur->omInUseCount;</span><br><span class=line>     }</span><br><span class=line></span><br><span class=line><span class=comment>// For moribund threads, scan gOmInUseList</span></span><br><span class=line>   <span class=keyword>if</span> (gOmInUseList) {</span><br><span class=line>     nInCirculation += gOmInUseCount;</span><br><span class=line>     <span class=type>int</span> <span class=variable>deflatedcount</span> <span class=operator>=</span> walk_monitor_list((ObjectMonitor **)&gOmInUseList, &FreeHead, &FreeTail);</span><br><span class=line>     gOmInUseCount-= deflatedcount;</span><br><span class=line>     nScavenged += deflatedcount;</span><br><span class=line>     nInuse += gOmInUseCount;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>  } <span class=keyword>else</span> <span class=keyword>for</span> (ObjectMonitor* block = gBlockList; block != NULL; block = next(block)) {</span><br><span class=line>	<span class=comment>// Iterate over all extant monitors - Scavenge all idle monitors.</span></span><br><span class=line>    <span class=keyword>assert</span>(block->object() == CHAINMARKER, <span class=string>"must be a block header"</span>);</span><br><span class=line>    nInCirculation += _BLOCKSIZE ;</span><br><span class=line>    <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>1</span> ; i < _BLOCKSIZE; i++) {</span><br><span class=line>      ObjectMonitor* mid = &block[i];</span><br><span class=line>      <span class=type>oop</span> <span class=variable>obj</span> <span class=operator>=</span> (oop) mid->object();</span><br><span class=line></span><br><span class=line>      <span class=keyword>if</span> (obj == NULL) {</span><br><span class=line>          <span class=comment>// The monitor is not associated with an object.</span></span><br><span class=line>          <span class=comment>// The monitor should either be a thread-specific private</span></span><br><span class=line>          <span class=comment>// free list or the global free list.</span></span><br><span class=line>          <span class=comment>// obj == NULL IMPLIES mid->is_busy() == 0</span></span><br><span class=line>        guarantee (!mid->is_busy(), <span class=string>"invariant"</span>) ;</span><br><span class=line>        <span class=keyword>continue</span> ;</span><br><span class=line>      }</span><br><span class=line>      deflated = deflate_monitor(mid, obj, &FreeHead, &FreeTail);</span><br><span class=line></span><br><span class=line>      <span class=keyword>if</span> (deflated) {</span><br><span class=line>        mid->FreeNext = NULL ;</span><br><span class=line>        nScavenged ++ ;</span><br><span class=line>      } <span class=keyword>else</span> {</span><br><span class=line>        nInuse ++;</span><br><span class=line>      }</span><br><span class=line>    }</span><br><span class=line>  }</span><br><span class=line>  MonitorFreeCount += nScavenged;</span><br><span class=line></span><br><span class=line>	<span class=comment>// Consider: audit gFreeList to ensure that MonitorFreeCount and list agree.</span></span><br><span class=line>  <span class=keyword>if</span> (ObjectMonitor::Knob_Verbose) {</span><br><span class=line>    ::printf (<span class=string>"Deflate: InCirc=%d InUse=%d Scavenged=%d ForceMonitorScavenge=%d : pop=%d free=%d\n"</span>,</span><br><span class=line>        nInCirculation, nInuse, nScavenged, ForceMonitorScavenge,</span><br><span class=line>        MonitorPopulation, MonitorFreeCount) ;</span><br><span class=line>    ::fflush(stdout) ;</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  ForceMonitorScavenge = <span class=number>0</span>;    <span class=comment>// Reset</span></span><br><span class=line></span><br><span class=line><span class=comment>// Move the scavenged monitors back to the global free list.</span></span><br><span class=line>  <span class=keyword>if</span> (FreeHead != NULL) {</span><br><span class=line>     guarantee (FreeTail != NULL && nScavenged > <span class=number>0</span>, <span class=string>"invariant"</span>) ;</span><br><span class=line>     <span class=keyword>assert</span> (FreeTail->FreeNext == NULL, <span class=string>"invariant"</span>) ;</span><br><span class=line><span class=comment>// constant-time list splice - prepend scavenged segment to gFreeList</span></span><br><span class=line>     FreeTail->FreeNext = gFreeList ;</span><br><span class=line>     gFreeList = FreeHead ;</span><br><span class=line>  }</span><br><span class=line>  Thread::muxRelease (&ListLock) ;</span><br><span class=line></span><br><span class=line>  <span class=keyword>if</span> (ObjectMonitor::_sync_Deflations != NULL) ObjectMonitor::_sync_Deflations->inc(nScavenged) ;</span><br><span class=line>  <span class=keyword>if</span> (ObjectMonitor::_sync_MonExtant  != NULL) ObjectMonitor::_sync_MonExtant ->set_value(nInCirculation);</span><br><span class=line></span><br><span class=line><span class=comment>// <span class=doctag>TODO:</span> Add objectMonitor leak detection.</span></span><br><span class=line><span class=comment>// Audit/inventory the objectMonitors -- make sure they're all accounted for.</span></span><br><span class=line>  GVars.stwRandom = os::random() ;</span><br><span class=line>  GVars.stwCycle ++ ;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=5-1-6、注意事项><a class=headerlink href=#5-1-6、注意事项 title=5.1.6、注意事项></a>5.1.6、注意事项</h3><ol><li>synchronized(Object)模式下，不能用String常量、Integer、Long等类型来作为锁角色。<li>锁定方法与非锁定方法可同时执行。<li>多个线程必须锁定同一个锁（对象）。（需用final修饰锁对象，防止修改）<li>自旋锁在 JDK1.4.2 中引入，使用 -XX:+UseSpinning 来开启。JDK 6 中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。<li>自适应自旋锁意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁拥有者的状态来决定。如果上一次自旋时间很短的情况下就获取到了锁，那么这次就会认为大概率也会成功，所以会尝试继续自旋。反之，则会直接阻塞挂起，避免无意义的自旋开销。<li>偏向锁由于有锁撤销的过程，会消耗系统资源，所以，在锁争用特别激烈的时候，用偏向锁未必效率高。还不如直接使用轻量级锁。</ol><h2 id=5-2、CAS><a class=headerlink href=#5-2、CAS title=5.2、CAS></a>5.2、CAS</h2><h3 id=5-2-1、简介><a class=headerlink href=#5-2-1、简介 title=5.2.1、简介></a>5.2.1、简介</h3><p><strong>CAS是 Compare And Set/Swap/exchange 的简写，意为比较并交换。</strong><p>cas(V, Expected, NewValue)：V为原值，Expected为期望值。NewValue为新值。在修改原值为新值时，判断原值是否与期望值相同，相同则修改，否则拿到和期望值不同的原值再次进行相同逻辑的修改，一直到修改成功为止，这个过程就称为“自旋”。自旋会无意义消耗CPU，故是否选择使用CAS自旋技术，要根据实际场景来选择：<ul><li>线程数量多且执行时间长，就要避免使用CAS自旋，而要选用重量级锁来代替，因为重量级锁使用的是等待队列，不会消耗CPU。<li>线程数量少且执行时间短，选用CAS自旋会较好。</ul><h3 id=5-2-2、底层实现><a class=headerlink href=#5-2-2、底层实现 title=5.2.2、底层实现></a>5.2.2、底层实现</h3><ol><li>底层指令实现：<ul><li>IA64、X86下：通过<code>lock、cmpxchg</code>指令实现。单纯的<code>cmpxchg</code>不能保证原子性。<li>sparc-TSO下：通过<code>case</code>指令实现。<li>ARM和PowerPC下：通过一对<code>Idrex/strex</code>指令实现。</ul><li>硬件情况下：lock指令在执行后面指令的时候锁定一个北桥信号。<li>拓展知识：处理器 使用总线锁和缓存锁来实现原子操作。</ol><h3 id=5-2-3、CAS缺点><a class=headerlink href=#5-2-3、CAS缺点 title=5.2.3、CAS缺点></a>5.2.3、CAS缺点</h3><ol><li><p>ABA问题。解决方法：加版本号。</p><li><p>自旋时间长。解决方法：如果JVM支持处理器提供的pause指令，那么效率会有一点提升。</p> <ul><li><p>PAUSE指令作用：</p> <ol><li>提升<code>spin-wait loops(自旋锁循环等待)</code>的性能。在执行一个<code>spin-wait loop</code>时，Pentium4 处理器会遇到严重的性能损失，PAUSE 指令会向处理器发起提醒：告诉处理器所执行的代码序列是一个 spin-wait loop。处理器会根据这个提醒而避开内存序列冲突(memory order violation)，也就是说对 spin-wait loop 不做缓存，不做指令重新排序等动作。这样就可以大大的提高了处理器的性能。正是基于此，才建议在 spin-wait loops 中使用 pasuse 指令。<li>减少 Pentium4 处理器在执行 spin-wait loop 时的电源消耗。在等待资源而执行自旋锁等待时，Pentium4 处理器会极速执行从而导致消耗很多电能，而<code>pause</code>指令则可以极大的减少处理器的电能消耗。</ol><li><p>PAUSE指令拓展：</p> <p>PAUSE 指令在 Pentium4 处理器中引入，但它也是向前兼容的。在早先的 IA-32 处理器中，PAUSE 指令实际上就相当于 NOP 指令。</p> <p>Pentium4 处理器以一种 预延迟(pre-defined delay)的技术来实现 PAUSE 指令。这种延迟是有限度的，且在一些处理器上是零延迟。该指令不会改变处理器的处理器状态。</p></ul><li><p>只能保证一个共享变量的原子操作。解决方法：加锁；AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象中执行CAS操作。</p></ol><h3 id=5-2-4、自增操作><a class=headerlink href=#5-2-4、自增操作 title=5.2.4、自增操作></a>5.2.4、自增操作</h3><ul><li><p>Synchronized操作：执行时间长，因为需要用户态与内核态的切换，从而降低了执行效率。</p><li><p>AtomicXXX操作：执行时间较Synch要少，因为使用了CAS自旋/无锁操作。</p><li><p>LongAdder操作：执行时间长，因为使用了分段锁。 适用于并发量大的情况。</p></ul><h2 id=5-3、Volatile><a class=headerlink href=#5-3、Volatile title=5.3、Volatile></a>5.3、Volatile</h2><h3 id=5-3-1、简介><a class=headerlink href=#5-3-1、简介 title=5.3.1、简介></a>5.3.1、简介</h3><p>volatile是轻量级的 synchronized，它在多处理器开发中保证了共享变量的“可见性”。<strong>可见性指的是 当一个线程修改了一个共享变量后，另外一个线程能读到这个共享变量被修改后的值。</strong><p><strong>volatile比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</strong><p>几个重要的CPU术语如下：<p><img alt=CPU术语001 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/CPU%E6%9C%AF%E8%AF%AD001.png?token=AIGEF3NKAFXF6QJXCEDLJ63EZZYPO><p>volatile变量自身具有如下特性。<ul><li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</ul><h3 id=5-3-2、底层实现><a class=headerlink href=#5-3-2、底层实现 title=5.3.2、底层实现></a>5.3.2、底层实现</h3><h4 id=字节码层面><a class=headerlink href=#字节码层面 title=字节码层面></a>字节码层面</h4><p>在volatile修饰的元素前加了一个访问标志：ACC_VOLATILE。<h4 id=JVM层面（规范）><a class=headerlink href=#JVM层面（规范） title=JVM层面（规范）></a>JVM层面（规范）</h4><ol><li><p>StoreStore Barriers - volatile写 - StoreLoad Barriers。</p><li><p>volatile读 - LoadLoad Barriers - LoadStore Barriers。</p></ol><h4 id=hotspot><a class=headerlink href=#hotspot title=hotspot></a>hotspot</h4><p><strong>底层基于大多数CPU都支持的 lock addl 汇编代码指令来实现。</strong><p>Lock前缀的指令在多核处理器下的作用：<ul><li>将当前处理器缓存行的数据写回到系统内存。<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</ul><blockquote><p>对volatile修饰的变量执行写操作时会向处理器发送一条Lock前缀指令，将该变量所在缓存行的数据【写回到系统内存】。但要注意，虽然已经写回内存但其它处理器中关于该变量的缓存依然是旧的，对旧的数据执行操作就会有问题。所以，多处理器下，为了保证各个处理器缓存的一致性，就会实现【缓存一 致性协议】，每个处理器通过嗅探总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作时会重新从系统内存中把数据读到处理器缓存里。<p>volatile有两个实现原则：<ol><li>Lock前缀指令会引起处理器缓存回写到内存。<li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效。</ol></blockquote><h4 id=CPU层面><a class=headerlink href=#CPU层面 title=CPU层面></a>CPU层面</h4><ul><li><p>X86 CPU内存屏障（有序性保证）</p> <ol><li>sfence指令：sfence指令前写 优先于 sfence指令后写。<li>lfence指令：lfence指令前读 优先于 lfence指令后读。<li>mfence指令：mfence指令前读写 优先于 sfence指令后读写。</ol> <p>可惜大多数CPU并不支持这种指令，故hotspor并没有选择这种方案来实现有序性，而是采用大多数CPU都支持的其它指令：lock addl 来实现。</p></ul><h3 id=5-3-3、实现一致性-可见性><a class=headerlink href=#5-3-3、实现一致性-可见性 title=5.3.3、实现一致性/可见性></a>5.3.3、实现一致性/可见性</h3><ol><li>MESI能解决就用MESI。<li>锁总线。</ol><p>为了保证内存可见性，Java编译器会在生成指令序列的适当位置插入 内存屏障指令 来禁止特定类型的处理器重排序。<p><strong>JMM把内存屏障指令分为4类：LoadLoad屏障、StoreStore屏障、LoadStore屏障、StoreLoad屏障。</strong>（详情参考本教程2.4.2节）<h3 id=5-3-4、实现有序性><a class=headerlink href=#5-3-4、实现有序性 title=5.3.4、实现有序性></a>5.3.4、实现有序性</h3><ol><li>内存屏障、sfence mfence lfence等系统原语/指令。sfence mfence lfence为什么不用？因为可移植性差。<li>锁总线。</ol><h3 id=5-3-5、解决指令重排序><a class=headerlink href=#5-3-5、解决指令重排序 title=5.3.5、解决指令重排序></a>5.3.5、解决指令重排序</h3><ol><li><p>代码级别：volatile修饰变量。</p><li><p>字节码级别：加访问修饰符 ACC_VOLATILE。</p><li><p>JVM级别：JVM内存屏障。（屏障两边的指令禁止重排）</p><li><p>Hotspot实现：lock addl指令。</p> <p>为何lock指令可以解决重排序和可见性问题？因为：lock用于在多处理器中执行指令时会对共享内存进行独占使用，其能够将当前处理器对应的缓存的内容刷新到内存中，并使其它处理器相同缓存中的内容失效。此外还提供有序指令无法越过内存屏障的作用。</p><li><p>系统级别：load fence、store fence原语指令。</p></ol><blockquote><p>编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。<p>这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作， 不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。<p>处理器对读/写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守as-if-serial语义，处理器不会对存在数据依赖性的两个内存操作做重排序）。<p>as-if-serial语义：不管怎么重排序（编译器和处理器为了提高并行度），（单线程） 程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。<p><font color=red>注意：在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但允许volatile变量与普通变量重排序。</font></blockquote><p>bytecodeinterpreter.cpp<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=type>int</span> field_offset = cache-><span class=built_in>f2_as_index</span>();</span><br><span class=line><span class=keyword>if</span> (cache-><span class=built_in>is_volatile</span>()) {</span><br><span class=line>    <span class=keyword>if</span> (support_IRIW_for_not_multiple_copy_atomic_cpu) {</span><br><span class=line>        OrderAccess::<span class=built_in>fence</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>orderaccess_linux_x86.inline.hpp<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>inline</span> <span class=type>void</span> <span class=title>OrderAccess::fence</span><span class=params>()</span> </span>{</span><br><span class=line>  <span class=keyword>if</span> (os::<span class=built_in>is_MP</span>()) {</span><br><span class=line>    <span class=comment>// always use locked addl since mfence is sometimes expensive</span></span><br><span class=line>	<span class=meta>#<span class=keyword>ifdef</span> AMD64</span></span><br><span class=line>    	<span class=function>__asm__ <span class=title>volatile</span> <span class=params>(<span class=string>"lock; addl $0,0(%%rsp)"</span> : : : <span class=string>"cc"</span>, <span class=string>"memory"</span>)</span></span>;</span><br><span class=line>	<span class=meta>#<span class=keyword>else</span></span></span><br><span class=line>    	<span class=function>__asm__ <span class=title>volatile</span> <span class=params>(<span class=string>"lock; addl $0,0(%%esp)"</span> : : : <span class=string>"cc"</span>, <span class=string>"memory"</span>)</span></span>;</span><br><span class=line>	<span class=meta>#<span class=keyword>endif</span></span></span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=5-3-6、volatile优化><a class=headerlink href=#5-3-6、volatile优化 title=5.3.6、volatile优化></a>5.3.6、volatile优化</h3><h4 id=追加到64字节><a class=headerlink href=#追加到64字节 title=追加到64字节></a>追加到64字节</h4><p><strong>著名的Java并发编程大师Doug lea在JDK 7的并发包里新增一个队列集合类LinkedTransferQueue，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能。</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=comment>/** 队列中的头部节点 */</span> </span><br><span class=line><span class=keyword>private</span> <span class=keyword>transient</span> <span class=keyword>final</span> PaddedAtomicReference&LTQNode> head; </span><br><span class=line><span class=comment>/** 队列中的尾部节点 */</span> </span><br><span class=line><span class=keyword>private</span> <span class=keyword>transient</span> <span class=keyword>final</span> PaddedAtomicReference&LTQNode> tail; </span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AtomicReference</span>&LTV> <span class=keyword>implements</span> <span class="title class_">java</span>.io.Serializable { </span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>volatile</span> V value; </span><br><span class=line>    <span class=comment>// 省略其他代码 </span></span><br><span class=line>｝</span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=keyword>class</span> <span class="title class_">PaddedAtomicReference</span>&LTT> <span class=keyword>extends</span> <span class="title class_">AtomicReference</span>&LTT> { </span><br><span class=line>    <span class=comment>// 使用很多4个字节的引用追加到64个字节 </span></span><br><span class=line>    Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe; </span><br><span class=line>    PaddedAtomicReference(T r) {</span><br><span class=line>        <span class=built_in>super</span>(r); </span><br><span class=line>    } </span><br><span class=line>}</span><br></pre></table></figure><h4 id=为何追加到64字节？><a class=headerlink href=#为何追加到64字节？ title=为何追加到64字节？></a>为何追加到64字节？</h4><p>因为对于英特尔酷睿i7、酷睿、Atom和 NetBurst，以及Core Solo和Pentium M处理器的L1、L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行。这意味着，如果队列的头节点和尾节点都不足64字节，则处理器会将它们都读到同一个高速缓存行中，多处理器环境下的每个处理器都会缓存同样的头、尾节点，当一 个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致 其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作则需要不断修改头节点，这样一来效率就会大大降低。<p>为解决这种问题，就可以把不足64字节的数据后面追加到64字节，也就是说让队列的头节点和尾节点各占一个缓存行，这样就避免了阻塞节点操作，大大提高效率。<h4 id=注意事项-1><a class=headerlink href=#注意事项-1 title=注意事项></a>注意事项</h4><p>使用volatile变量时一定要追加至64字节的说法并非一定成立。在以下两种场景中不适合：<ol><li><strong>缓存行非64字节宽的处理器</strong>。如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个 字节宽。<li><strong>共享变量不会被频繁地写</strong>。因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。</ol><blockquote><p><font color=red>注意：追加字节的方式在Java 7下可能不生效，因为Java 7更加智慧，它会淘汰或重新排列无用字段，所以，需要使用其它追加字节的方式。除了volatile，Java并发编程中应用较多的是synchronized。</font></blockquote><h3 id=5-3-7、volatile使用指南><a class=headerlink href=#5-3-7、volatile使用指南 title=5.3.7、volatile使用指南></a>5.3.7、volatile使用指南</h3><p>使用volatile时可参考如下两条规则：<ul><li>写后加写屏障，阻止写屏障前代码跑到后面。（写屏障箭头朝上）<li>读前加读屏障，防止读屏障后面代码跑到前面。（读屏障箭头朝下）</ul><p>代码示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line> <span class=keyword>volatile</span> <span class=type>int</span> a;</span><br><span class=line><span class=type>int</span> b;</span><br><span class=line><span class=type>int</span> c;</span><br><span class=line></span><br><span class=line>a = <span class=number>1</span>;	</span><br><span class=line><span class=comment>// 写屏障^^^^^^</span></span><br><span class=line>b = <span class=number>2</span>;</span><br><span class=line><span class=comment>// 读屏障vvvvvv</span></span><br><span class=line>c = a;</span><br></pre></table></figure><h2 id=5-4、Lock（锁）><a class=headerlink href=#5-4、Lock（锁） title=5.4、Lock（锁）></a>5.4、Lock（锁）</h2><h3 id=5-4-1、简介><a class=headerlink href=#5-4-1、简介 title=5.4.1、简介></a>5.4.1、简介</h3><h4 id=锁类架构图><a class=headerlink href=#锁类架构图 title=锁类架构图></a>锁类架构图</h4><p><img alt=Java中的锁和AQS类结构图01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%92%8CAQS%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE01.png?token=AIGEF3KXLEK2VZACCYGNWBDEZZYRQ><h4 id=Lock接口特性><a class=headerlink href=#Lock接口特性 title=Lock接口特性></a>Lock接口特性</h4><p>Lock接口提供了synchronized不具备的特性，详情如下：<p><img alt=锁-1.1-Lock接口提供了synchronized不具备的特性 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E9%94%81-1.1-Lock%E6%8E%A5%E5%8F%A3%E6%8F%90%E4%BE%9B%E4%BA%86synchronized%E4%B8%8D%E5%85%B7%E5%A4%87%E7%9A%84%E7%89%B9%E6%80%A7.png?token=AIGEF3PVCAV2TJT2GI66CC3EZZYTA><h3 id=5-4-2、乐观锁><a class=headerlink href=#5-4-2、乐观锁 title=5.4.2、乐观锁></a>5.4.2、乐观锁</h3><h4 id=5-4-2-1、简介><a class=headerlink href=#5-4-2-1、简介 title=5.4.2.1、简介></a>5.4.2.1、简介</h4><p><strong>乐观锁代表是 AtomicInteger，使用 CAS 保证原子性。</strong><p>乐观锁 核心思想：无需加锁，每次只有一个线程能 成功修改 共享变量，其它线程会不断重试直到成功。<blockquote><p>乐观锁常见实现就是CAS算法，java java.util.concurrent包下原子类(例如<code>AtomicBoolean</code>，<code>AtomicInteger</code>，<code>AtomicLong</code>)中的递增操作就是通过CAS自旋来实现。</blockquote><h4 id=5-4-2-2、特点><a class=headerlink href=#5-4-2-2、特点 title=5.4.2.2、特点></a>5.4.2.2、特点</h4><ul><li>线程一直运行，不会阻塞，故不存在线程上下文切换。<li>需要多核CPU支持，线程数不应该超过 CPU核心数量。</ul><h4 id=5-4-2-3、适用场景><a class=headerlink href=#5-4-2-3、适用场景 title=5.4.2.3、适用场景></a>5.4.2.3、适用场景</h4><p><strong>乐观锁适用于多读场景，不加锁可以提高读操作性能。</strong><h3 id=5-4-3、悲观锁><a class=headerlink href=#5-4-3、悲观锁 title=5.4.3、悲观锁></a>5.4.3、悲观锁</h3><h4 id=5-4-3-1、简介><a class=headerlink href=#5-4-3-1、简介 title=5.4.3.1、简介></a>5.4.3.1、简介</h4><p><strong>悲观锁代表是 synchronized 和 Lock 锁。</strong><p>悲观锁核心思想：线程占有了锁，才能操作共享变量，每次只能有一个线程占有锁，其它获线程都要等待。<h4 id=5-4-3-2、特点><a class=headerlink href=#5-4-3-2、特点 title=5.4.3.2、特点></a>5.4.3.2、特点</h4><ul><li>线程从运行到阻塞，再从阻塞到唤醒，期间经历 线程上下文切换，若频繁发生，则会严重影响性能。<li>获取 synchronized 和 Lock 锁时，若锁已被占用，那么会默认重试几次，减少阻塞机会。</ul><h4 id=5-4-3-3、适用场景><a class=headerlink href=#5-4-3-3、适用场景 title=5.4.3.3、适用场景></a>5.4.3.3、适用场景</h4><p><strong>悲观锁适用于多写场景，先加锁可以保证写操作时数据的正确性。</strong><h3 id=5-4-4、重入锁><a class=headerlink href=#5-4-4、重入锁 title=5.4.4、重入锁></a>5.4.4、重入锁</h3><h4 id=简介-2><a class=headerlink href=#简介-2 title=简介></a>简介</h4><p>重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对 资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。<p>ReentrantLock虽然没能像synchronized关键字一样支持隐式的重进入，但是在调用lock()方 法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。<h4 id=重入锁特点><a class=headerlink href=#重入锁特点 title=重入锁特点></a>重入锁特点</h4><ol><li>线程A获取锁L后，可以在不释放锁L的同时再次获取锁L，且不会出现死锁现象；<li>线程A释放掉锁L后，其它线程才能获取锁L；</ol><p><strong>可重入锁的使命就是防止自己锁自己，进而提高程序执行性能。</strong><p>Java中可重入锁的常见实现如下：<ol><li>Synchronized<li>ReentrantLock</ol><h3 id=5-4-5、ReentrantLock><a class=headerlink href=#5-4-5、ReentrantLock title=5.4.5、ReentrantLock></a>5.4.5、ReentrantLock</h3><h4 id=5-4-5-1、简介><a class=headerlink href=#5-4-5-1、简介 title=5.4.5.1、简介></a>5.4.5.1、简介</h4><p><strong>ReentrantLock是一个可重入锁、独占式锁，与synchronized关键字相比，它更灵活、更强大，增加了轮询、超时、中断等高级功能。除此外，还提供了对公平锁与非公平锁的选择。</strong><p>ReentrantLock的内部类Sync继承了AQS，分为公平锁FairSync和非公平锁NonfairSync。ReentrantLock使用公平锁还是非公平锁，可以通过它的构造函数来决定。<blockquote><p>公平锁：按照请求的顺序来获取锁；非公平锁：不管请求顺序的先后，谁抢到锁，这把锁就是谁的。</blockquote><p>事实上，公平锁往往没有非公平锁的效率高，但是，并不是任何场景都是以TPS作为唯一指标，公平锁能够减少“饥饿”发生的概率，等待越久的请求越能够得到优先满足。<h4 id=5-4-5-2、原理><a class=headerlink href=#5-4-5-2、原理 title=5.4.5.2、原理></a>5.4.5.2、原理</h4><p><strong>ReentrantLock 主要通过unsafe的 CAS 和 park 两个功能实现锁机制。</strong><p>Sync类是ReentrantLock自定义同步组件，它是ReentrantLock的一个内部类，其继承自AQS，它有两个子类：公平锁FairSync和非公平锁NonfairSync。ReentrantLock的获取与释放锁操作都是委托给该同步组件来实现。<h3 id=5-4-6、读写锁><a class=headerlink href=#5-4-6、读写锁 title=5.4.6、读写锁></a>5.4.6、读写锁</h3><h4 id=5-4-6-1、简介><a class=headerlink href=#5-4-6-1、简介 title=5.4.6.1、简介></a>5.4.6.1、简介</h4><p><strong>读多写少情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。读写锁的实现是 ReentrantReadWriteLock。</strong><p>ReadWriteLock仅定义了获取读锁和写锁的两个方法，其实现ReentrantReadWriteLock，除了接口方法之外，还提供了一些便于外界监控内部工作状态的方法。<h4 id=5-4-6-2、特点><a class=headerlink href=#5-4-6-2、特点 title=5.4.6.2、特点></a>5.4.6.2、特点</h4><p><img alt=锁-1.2-读写锁特性 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E9%94%81-1.2-%E8%AF%BB%E5%86%99%E9%94%81%E7%89%B9%E6%80%A7.png?token=AIGEF3MBYW4434TSKNMP7ULEZZYVI><h4 id=5-4-6-3、底层实现><a class=headerlink href=#5-4-6-3、底层实现 title=5.4.6.3、底层实现></a>5.4.6.3、底层实现</h4><h5 id=读写状态><a class=headerlink href=#读写状态 title=读写状态></a>读写状态</h5><p>读写锁 同样依赖 自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。ReentrantLock中自定义同步器的同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状 态，使得该状态的设计成为读写锁实现的关键。<p><strong>如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将 变量切分成了两个部分，高16位表示读，低16位表示写</strong>，划分方式如下图：<p><img alt=锁-1.3-读写锁状态划分设计图 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E9%94%81-1.3-%E8%AF%BB%E5%86%99%E9%94%81%E7%8A%B6%E6%80%81%E5%88%92%E5%88%86%E8%AE%BE%E8%AE%A1%E5%9B%BE.png?token=AIGEF3KMLEL744A7NPZTJKLEZZYXY><p>读写锁是如何迅速确定读和写各自的状态呢？答案是通过位运算。假设当前同步状态 值为S，写状态等于S&0x0000FFFF（将高16位全部抹去），读状态等于S>>>16（无符号补0右移 16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1<&LT16)，也就是 S+0x00010000。<h5 id=写锁获取与释放><a class=headerlink href=#写锁获取与释放 title=写锁获取与释放></a>写锁获取与释放</h5><p>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程， 则当前线程进入等待状态。<blockquote><p>如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果 允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。</blockquote><p>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0 时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对 后续读写线程可见。<h5 id=读锁获取与释放><a class=headerlink href=#读锁获取与释放 title=读锁获取与释放></a>读锁获取与释放</h5><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问 （或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程 获取，则进入等待状态。<p>读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少值是（1<&LT16）。<h4 id=5-4-6-4、锁升级-降级><a class=headerlink href=#5-4-6-4、锁升级-降级 title=5.4.6.4、锁升级/降级></a>5.4.6.4、锁升级/降级</h4><h5 id=锁降级><a class=headerlink href=#锁降级 title=锁降级></a>锁降级</h5><p><strong>锁降级指的是写锁降级成为读锁。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。</strong><h5 id=锁升级（不存在）><a class=headerlink href=#锁升级（不存在） title=锁升级（不存在）></a>锁升级（不存在）</h5><p><font color=red>RentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。</font>目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。<h3 id=5-4-10、小总结><a class=headerlink href=#5-4-10、小总结 title=5.4.10、小总结></a>5.4.10、小总结</h3><h4 id=5-4-10-1、Synchronized和ReentrantLock区别><a class=headerlink href=#5-4-10-1、Synchronized和ReentrantLock区别 title=5.4.10.1、Synchronized和ReentrantLock区别></a>5.4.10.1、Synchronized和ReentrantLock区别</h4><h5 id=共同点><a class=headerlink href=#共同点 title=共同点></a>共同点</h5><ol><li>都是用来协调多线程对共享对象、变量的访问。<li>都是可重入锁，即同一线程可以多次获得同一个锁。<li>都保证了可见性和互斥性。</ol><h5 id=不同点><a class=headerlink href=#不同点 title=不同点></a>不同点</h5><ol><li><p>API方面</p> <ul><li>Synchronized：可修饰方法、代码块。隐式获取/释放锁。<li>ReentrantLock：显式获取/释放锁。（获取锁：ReentrantLock.lock；释放锁：ReentrantLock.unlock）</ul><li><p>等待可中断</p> <p>有两个线程：T1、T2，假设T1获取了对象object的锁，T2将等待T1释放object的锁。则：</p> <ul><li>Synchronized：T2会一直等待下去，不可被中断。<li>ReentrantLock：T2等待一定时间后，会中断操作，转而去做其它事。</ul><li><p>公平锁</p> <ul><li>Synchronized：是非公平锁。<li>ReenTrantLock：默认是非公平锁，可通过布尔值来控制使用公平锁。</ul><li><p>绑定多个条件</p> <ul><li>Synchronized：锁对象的wait和notify() 或notifyAll()方法可以实现一个隐含的条件。<li>ReenTrantLock：可以同时绑定多个Condition对象，只需多次调用newCondition方法即可。</ul><li><p>性能</p> <p>JDK1.5中的Synchronized有很大优化余地。JDK 1.6 中加入了很多针对锁的优化措施，故synchronized与ReentrantLock在性能方面基本持平。</p><li><p>其它</p> <ul><li>Synchronized是关键字，是内置语言的实现。Lock是一个接口。<li>Synchronized在发生异常时，会自动释放线程占有的锁，不会导致死锁发生。Lock必须通过unlock方法释放锁，否则会造成死锁。<li>Synchronized无法判断是否获取到锁；Lock可以。<li>Synchronized不管读写，都会阻塞线程，读效率低；Lock可以提供读写锁，可提高并发读的效率。</ul></ol><table><thead><tr><th align=center>比较方面<th align=center>synchronized<th align=center>ReenTrantLock<tbody><tr><td align=center>原始构成<td align=center>Java关键字，原生语法层面的互斥，需要JVM支持。<td align=center>JDK1.5之后提供的互斥锁<tr><td align=center>实现<td align=center>通过JVM自动加锁/解锁<td align=center>显式加锁/解锁<tr><td align=center>代码实现<td align=center>隐式自动获取锁/释放锁<td align=center>显式获取锁/释放锁<tr><td align=center>灵活性<td align=center>锁的范围可以随意控制<td align=center>Lock是方法调用，可跨方法，灵活性更大<tr><td align=center>等待可中断<td align=center>不可中断，除非抛出异常。<td align=center>可中断<tr><td align=center>公平<td align=center>非公平锁<td align=center>默认非公平锁，但可通过布尔值控制使用公平锁<tr><td align=center>条件Condition<td align=center><td align=center>通过多次newCondition可以获得多个Condition对象，可以简单的实现比较复杂的线程同步功能。<tr><td align=center>高级功能<td align=center><td align=center>getHoldCount()、getQueueLength()、isFair()、isHeldByCurrentThread()、isLocked()<tr><td align=center>便利性<td align=center>会自动释放获取锁，便利性好。<td align=center>需要手动获取释放锁，便利性差。<tr><td align=center>适用情况<td align=center>适用于并发度低的情况。<td align=center>适用于并发度高的情况。</table><h4 id=5-4-10-2、Lock-VS-Synchronized><a title="5.4.10.2、Lock VS Synchronized" class=headerlink href=#5-4-10-2、Lock-VS-Synchronized></a>5.4.10.2、Lock VS Synchronized</h4><p><strong>Lock可以非阻塞获取锁、被中断地获取锁、超时获取锁。</strong><h2 id=5-5、原子操作><a class=headerlink href=#5-5、原子操作 title=5.5、原子操作></a>5.5、原子操作</h2><h3 id=5-5-1、简介><a class=headerlink href=#5-5-1、简介 title=5.5.1、简介></a>5.5.1、简介</h3><p><strong>原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。</strong><p>原子操作相关术语如下：<p><img alt=原子操作-1.1-相关术语 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-1.1-%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD.png?token=AIGEF3KT2PLCG34WR36C2ZLEZZYZ2><h3 id=5-5-2、处理器原子操作><a class=headerlink href=#5-5-2、处理器原子操作 title=5.5.2、处理器原子操作></a>5.5.2、处理器原子操作</h3><p>首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。<p>为保证复杂内存操作的原子性，处理器提供了两种机制：<p><strong>（1）总线锁</strong><p>所谓总线锁就是使用处理器提供的一个 LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该 处理器可以独占共享内存。<p><strong>（2）缓存锁</strong><p>总线锁定把CPU和内存之间的通信锁住了，开销较大，所以使用缓存锁定代替总线锁定来进行优化。<p>有两种情况下处理器不会使用缓存锁定：<ol><li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，处理器会调用总线锁定。<li>有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的 内存区域在处理器的缓存行中也会调用总线锁定。</ol><h3 id=5-5-3、Java原子操作><a class=headerlink href=#5-5-3、Java原子操作 title=5.5.3、Java原子操作></a>5.5.3、Java原子操作</h3><p><strong>Java中可以通过 锁、循环CAS 方式来实现原子操作。</strong><h4 id=CAS实现原子操作><a class=headerlink href=#CAS实现原子操作 title=CAS实现原子操作></a>CAS实现原子操作</h4><p><strong>JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的</strong>。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。从Java 1.5开始，JDK的并发包里提供了一些原子操作类来支持原子操作。<p>CAS实现原子操作的三大问题：<ol><li>ABA问题。<li>循环时间长开销大。<li>只能保证一个共享变量的原子操作。</ol><h4 id=锁实现原子操作><a class=headerlink href=#锁实现原子操作 title=锁实现原子操作></a>锁实现原子操作</h4><p>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁 机制，有偏向锁、轻量级锁和互斥锁。除了偏向锁，JVM实现锁的方式都用了循环 CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。<h4 id=原子操作类><a class=headerlink href=#原子操作类 title=原子操作类></a>原子操作类</h4><p><strong>JDK 5开始提供了java.util.concurrent.atomic包，Atomic包里一共提供了13个类，属于4种类型的原子更新方式</strong>，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。Atomic包里的类基本都是使用Unsafe实现的包装类。<h5 id=基本类型><a class=headerlink href=#基本类型 title=基本类型></a>基本类型</h5><ul><li>AtomicBoolean：原子更新布尔类型。<li>AtomicInteger：原子更新整型。<li>AtomicLong：原子更新长整型。</ul><p>Java的基本类型里还有char、float和double等，对其这些基本类型，可以将它们转换成整型后，再使用compareAndSwapInt进行CAS更新。<h5 id=数组类型><a class=headerlink href=#数组类型 title=数组类型></a>数组类型</h5><ul><li>AtomicIntegerArray：原子更新整型数组里的元素。<li>AtomicLongArray：原子更新长整型数组里的元素。<li>AtomicReferenceArray：原子更新引用类型数组里的元素。</ul><h5 id=引用类型><a class=headerlink href=#引用类型 title=引用类型></a>引用类型</h5><ul><li>AtomicReference：原子更新引用类型。<li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。<li>AtomicMarkableReference：原子更新带有标记位的引用类型。</ul><h5 id=对象属性><a class=headerlink href=#对象属性 title=对象属性></a>对象属性</h5><ul><li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。<li>AtomicStampedReference：原子更新带有版本号的引用类型。</ul><h2 id=5-6、并发工具类><a class=headerlink href=#5-6、并发工具类 title=5.6、并发工具类></a>5.6、并发工具类</h2><h3 id=5-6-1、CountDownLatch><a class=headerlink href=#5-6-1、CountDownLatch title=5.6.1、CountDownLatch></a>5.6.1、CountDownLatch</h3><p><strong>CountDownLatch允许一个或多个线程等待其他线程完成操作。</strong><p><strong>调用CountDownLatch的countDown方法时，N会减1，CountDownLatch的await方法会阻塞当前线程，直到N变成零。</strong>由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程中时，只需要把这个 CountDownLatch的引用传递到线程里即可。<p><font color=red>注意：计数器必须大于等于0，如果等于0，则调用await方法时不会阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值。一个线程调用countDown方法happen-before另外一个线程调用await方法。</font><h3 id=5-6-2、CyclicBarrier><a class=headerlink href=#5-6-2、CyclicBarrier title=5.6.2、CyclicBarrier></a>5.6.2、CyclicBarrier</h3><p><strong>CyclicBarrier是可循环使用的屏障。它的目的：让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</strong><p>CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。<p>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier（int parties，Runnable barrierAction），用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景。<ul><li>CyclicBarrier VS CountDownLatch</ul><p><strong>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。</strong><h3 id=5-6-3、Semaphore><a class=headerlink href=#5-6-3、Semaphore title=5.6.3、Semaphore></a>5.6.3、Semaphore</h3><p><strong>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</strong><p>Semaphore的构造方法Semaphore(int permits) 接受一个整型的数字，表示可用的许可证数量。Semaphore(10) 表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程<strong>使用 Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证</strong>。还可以用tryAcquire()方法尝试获取许可证。<h3 id=5-6-4、Exchanger><a class=headerlink href=#5-6-4、Exchanger title=5.6.4、Exchanger></a>5.6.4、Exchanger</h3><h4 id=简介-3><a class=headerlink href=#简介-3 title=简介></a>简介</h4><p><strong>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于线程间的数据交换。</strong>它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。<strong>两个线程通过 exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</strong><p><font color=red>注意：如果两个线程有一个没有执行exchange()方法则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用exchange(V x, longtimeout, TimeUnit unit)设置最大等待时长。</font><h4 id=应用场景><a class=headerlink href=#应用场景 title=应用场景></a>应用场景</h4><ol><li>Exchanger可以用于遗传算法，遗传算法中需要选出两个人作为交换对象，这时候会交换两人的数据，并使用交叉规则得出2个结果。<li>Exchanger也可以用于校对工作。</ol><h2 id=5-7、并发容器及框架><a class=headerlink href=#5-7、并发容器及框架 title=5.7、并发容器及框架></a>5.7、并发容器及框架</h2><h3 id=5-7-1、阻塞队列><a class=headerlink href=#5-7-1、阻塞队列 title=5.7.1、阻塞队列></a>5.7.1、阻塞队列</h3><h4 id=简介-4><a class=headerlink href=#简介-4 title=简介></a>简介</h4><p>JDK 7提供了7个阻塞队列，如下。<ul><li>ArrayBlockingQueue：一个由<strong>数组结构</strong>组成的<strong>有界阻塞</strong>队列。<li>LinkedBlockingQueue：一个由<strong>链表结构</strong>组成的<strong>有界阻塞</strong>队列。<li>PriorityBlockingQueue：一个<strong>支持优先级排序的无界阻塞</strong>队列。<li>DelayQueue：一个使用<strong>优先级队列</strong>实现的<strong>无界阻塞</strong>队列。<li>SynchronousQueue：一个<strong>不存储元素的阻塞队列</strong>。<li>LinkedTransferQueue：一个由<strong>链表结构</strong>组成的<strong>无界阻塞</strong>队列。<li>LinkedBlockingDeque：一个由<strong>链表结构</strong>组成的<strong>双向阻塞</strong>队列。</ul><h4 id=分析><a class=headerlink href=#分析 title=分析></a>分析</h4><h5 id=ArrayBlockingQueue><a class=headerlink href=#ArrayBlockingQueue title=ArrayBlockingQueue></a>ArrayBlockingQueue</h5><p><strong>此队列按照先进先出（FIFO）的原则对元素进行排序，默认情况下不保证线程访问队列的公平性。</strong><p>为了保证公平性，通常会降低吞吐量。可以使用以下代码创建一个公平的阻塞队列：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>ArrayBlockingQueue</span> <span class=variable>fairQueue</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class=number>1000</span>,<span class=literal>true</span>);</span><br></pre></table></figure><h5 id=LinkedBlockingQueue><a class=headerlink href=#LinkedBlockingQueue title=LinkedBlockingQueue></a>LinkedBlockingQueue</h5><p><strong>此队列的默认和最大长度为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</strong><h5 id=PriorityBlockingQueue><a class=headerlink href=#PriorityBlockingQueue title=PriorityBlockingQueue></a>PriorityBlockingQueue</h5><p><strong>默认情况下元素采取自然顺序 升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则</strong>，或者初始化 PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。<h5 id=DelayQueue><a class=headerlink href=#DelayQueue title=DelayQueue></a>DelayQueue</h5><p>DelayQueue是一个<strong>支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现</strong>。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。 只有在延迟期满时才能从队列中提取元素。<p>应用场景：<ul><li>缓存系统的设计<li>定时任务调度</ul><h5 id=SynchronousQueue><a class=headerlink href=#SynchronousQueue title=SynchronousQueue></a>SynchronousQueue</h5><p><strong>每一个put操作必须等待一个take操作， 否则不能继续添加元素。</strong><p>它支持公平访问队列，默认情况下线程采用非公平性策略访问队列。<p>SynchronousQueue的吞吐量高于 LinkedBlockingQueue和ArrayBlockingQueue。<h5 id=LinkedTransferQueue><a class=headerlink href=#LinkedTransferQueue title=LinkedTransferQueue></a>LinkedTransferQueue</h5><p>相对于其它 阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。<ul><li><p>transfer方法</p> <p>如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法 时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等 待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。</p><li><p>tryTransfer方法</p> <p>tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等 待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法 立即返回，而transfer方法是必须等到消费者消费了才返回。</p></ul><h5 id=LinkedBlockingDeque><a class=headerlink href=#LinkedBlockingDeque title=LinkedBlockingDeque></a>LinkedBlockingDeque</h5><p>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以 从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。<p>初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“工作窃取”模式中<h4 id=底层实现-1><a class=headerlink href=#底层实现-1 title=底层实现></a>底层实现</h4><p><strong>阻塞队列底层主要使用 通知模式 来实现生产者与消费者间的通信。</strong><p>ArrayBlockingQueue使用了Condition来实现，当往队列里插入一个元素时，如果队列不可用，那么阻塞生产者主要通过 LockSupport.park（this）来实现。<p>park这个方法会阻塞当前线程，但以下4种情况中的任何一种发生时，该方法就会返回：<ul><li>与park对应的unpark执行或已经执行过时。<li>线程被中断时。<li>等待完time参数指定的毫秒数时。<li>异常现象发生时，这个异常现象没有任何原因。</ul><h3 id=5-7-2、ForkJoin框架><a class=headerlink href=#5-7-2、ForkJoin框架 title=5.7.2、ForkJoin框架></a>5.7.2、ForkJoin框架</h3><h4 id=简介-5><a class=headerlink href=#简介-5 title=简介></a>简介</h4><p><strong>Fork/Join框架是Java 7提供的一个用于 并行执行任务 的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</strong><h4 id=工作窃取算法><a class=headerlink href=#工作窃取算法 title=工作窃取算法></a>工作窃取算法</h4><p><strong>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。</strong><p>工作窃取算法的优缺点如下：<ul><li><p>优点：充分利用线程进行并行计算，减少了线程间的竞争</p><li><p>缺点：某些情况下还是存在竞争，比如双端队列里只有一个任务时。并 且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p></ul><h4 id=异常处理><a class=headerlink href=#异常处理 title=异常处理></a>异常处理</h4><p>ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消，且可以通过ForkJoinTask的getException方法获取异常。<p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或没有抛出异常则返回null。<h4 id=底层设计><a class=headerlink href=#底层设计 title=底层设计></a>底层设计</h4><ul><li>步骤1，分割任务。<li>步骤2，执行任务并合并结果。</ul><p>Fork/Join使用两个类来完成以上两件事情：<ul><li><p><strong>ForkJoinTask</strong>：使用ForkJoin框架，必须首先创建一个ForkJoin任务。</p> <p>通常情况下，我们不需要直接继承ForkJoinTask类，只需要继 承它的子类：</p> <ul><li>RecursiveAction：用于没有返回结果的任务。<li>RecursiveTask：用于有返回结果的任务。</ul><li><p><strong>ForkJoinPool</strong>：ForkJoinTask需要通过ForkJoinPool来执行。</p></ul><p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责将存放程序提交给ForkJoinPool的任务，而ForkJoinWorkerThread数组负责执行这些任务。<ul><li><p>ForkJoinTask的fork方法</p> <p>调用ForkJoinTask的fork方法时，会异步调用ForkJoinWorkerThread的pushTask方法将任务放到ForkJoinTask数组中，然后调用ForkJoinPool的signalWork方法唤醒或创建一个线程去执行该任务。</p><li><p>ForkJoinTask的join方法</p> <p>调用Join方法会调用doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有4种：已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常 （EXCEPTIONAL）。</p></ul><h2 id=5-8、并发底层原理><a class=headerlink href=#5-8、并发底层原理 title=5.8、并发底层原理></a>5.8、并发底层原理</h2><h3 id=5-8-1、LockSupport工具><a class=headerlink href=#5-8-1、LockSupport工具 title=5.8.1、LockSupport工具></a>5.8.1、LockSupport工具</h3><p><strong>LockSupport是构建同步组件的基础工具。</strong>LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread) 方法来唤醒一个被阻塞的线程。<p>Java 6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos) 和parkUntil(Object blocker,long deadline)3个方法，用于实现阻塞当前线程的功能，其中参数 blocker是用来标识当前线程在等待的对象（以下称为阻塞对象），该对象主要用于问题排查和 系统监控。<h3 id=5-8-2、Condition接口><a class=headerlink href=#5-8-2、Condition接口 title=5.8.2、Condition接口></a>5.8.2、Condition接口</h3><h4 id=简介-6><a class=headerlink href=#简介-6 title=简介></a>简介</h4><p><strong>Java对象（wait/notify）配合Synchronized可以实现等待/通知模式。Condition接口配合Lock同样可以实现等待/通知模式，但是两者的使用方式和功能特性是有差别的。</strong><p>Object监视器 VS Condition接口：<p><img alt=image-20200620151112096 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200620151112096.png?token=AIGEF3LU66ZLAJQGHYYX6EDEZZY4A><p>Condition对象由Lock对象（调用Lock对象的newCondition()方法）创建出来，即通过Lock的newCondition()方法可以获取一个Condition。<p>Condition使用方式比较简单。当前线程调用await()方法后会释放锁并在此等待，其它线程调用Condition对象的signal()方法会导致当前线程获取锁并从await()方法返回。<h4 id=实现分析><a class=headerlink href=#实现分析 title=实现分析></a>实现分析</h4><p>ConditionObject是同步器AbstractQueuedSynchronizer的内部类，每个Condition对象都包含一个等待队列，该队列是Condition对象实现等待/通知功能的关键。<p><strong>Condition的实现主要包括：等待队列、等待和通知，下面提到的Condition，如果不加说明均指的是ConditionObject。</strong><p><strong>（1）等待队列</strong><p>等待队列是一个FIFO单向队列，队列中的每个节点都包含一个线程引用，该线程就是 在Condition对象上等待的线程，<strong>一个线程调用Condition.await()方法后会释放锁并被构造成节点放入到等待队列，然后进入等待状态</strong>。事实上，节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中的节点类型都是同步器的静态内部类 AbstractQueuedSynchronizer.Node。<p><strong>一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点 （lastWaiter）。</strong><p><img alt=image-20210221163426067 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210221163426067.png?token=AIGEF3OTFQWKT5ZQHHM4UODEZZY6G><p><strong>Object监视器模型中，一个对象拥有一个同步队列和等待队列，而并发包中的 Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列。</strong><p>Condition是同步器的内部类，因此每个Condition实例都能够访问 同步器提供的方法，相当于每个Condition都拥有所属同步器的引用。<p><strong>（2）等待</strong><p>调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。<p>如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。<p><strong>（3）通知</strong><p>调用Condition的signal()方法会导致：将等待队列的首节点移至同步队列中，然后唤醒该节点中的线程，被唤醒的线程会通过调用同步器的acquireQueued()方法来尝试获取同步状态。成功获取同步状态（锁）后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功获取了锁。<blockquote><p><font color=red>注意事项：</font><ol><li>当从await()方法返回时，当前线程一定获取了Condition相关联的锁。<li>调用signal()方法的前提是当前线程必须获取了锁；<li>如果节点不是通过Condition.signal()方法被唤醒，而是通过中断被唤醒的话，会抛出异常 InterruptedException。</ol></blockquote><p>Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点中的线程。<h4 id=知识扩展><a class=headerlink href=#知识扩展 title=知识扩展></a>知识扩展</h4><p><strong>为什么wait()、notyfy()、notifyAll()要放在同步块中？</strong><ol><li>调用wait()就是释放锁，释放锁的前提必须要先获得锁，先获得锁才能释放锁。<li>notify()、notifyAll()是将锁交给调用wait()方法的线程，让其继续执行下去，如果自身没有锁，怎么叫把锁交给其他线程呢；</ol><h3 id=5-8-3、AQS（CLH）><a class=headerlink href=#5-8-3、AQS（CLH） title=5.8.3、AQS（CLH）></a>5.8.3、AQS（CLH）</h3><h4 id=简介-7><a class=headerlink href=#简介-7 title=简介></a>简介</h4><p><strong>AQS（Abstract Queued Synchronizer）：简称抽象队列同步器。</strong><p>CLH（Craig Landin and Hagersten locks）：是一种基于链表的可扩展、高性能、公平的自旋锁，能确保无饥饿性、公平性。申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。<h4 id=底层实现-2><a class=headerlink href=#底层实现-2 title=底层实现></a>底层实现</h4><p><strong>基于volatile + CAS + 队列来实现。</strong><h5 id=同步队列><a class=headerlink href=#同步队列 title=同步队列></a>同步队列</h5><p><strong>同步器依赖内部的 同步队列（FIFO双向队列）来完成同步状态管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node），然后基于CAS的方式放入到同步队列尾部，同时会阻塞当前线程，当同步队列首节点释放同步状态时，会唤醒后继节点来获取同步状态，后继节点获取同步状态成功后会将自己设置为首节点。</strong><p>同步队列中的节点（Node）保存的内容：<strong>获取同步状态失败的线程引用、等待状态以及前驱和后继节点。</strong><p>同步队列的基本结构如下图所示：<p><img alt=image-20200721002028762 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200721002028762.png?token=AIGEF3K7UBTFCK3VU76IGCTEZZY7U><p>同步器拥有首节点（head） 和尾节点（tail）。 当一个线程无法获取到同步状态时，会被构造成节点并放入到同步队列末尾。放入队列末尾的操作将通过调用CAS方法：<code>compareAndSetTail(Node expect,Node update)</code>来实现，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。 插入过程如图所示：<p><img alt=image-20200721002419902 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200721002419902.png?token=AIGEF3KHSKMLNT7SRLOKJKTEZZZA2><p>同步队列遵循FIFO规则，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点来获取同步状态，而后继节点在获取同步状态成功时会将自己设置为首节点。<p>注意：<strong>由于只有一个线程能够成功获取到同步状态，因此设置头节点的操作并不需要通过CAS来保证。</strong><h5 id=等待队列><a class=headerlink href=#等待队列 title=等待队列></a>等待队列</h5><p><strong>等待队列是一个FIFO单向队列。线程A调用Condition.await()方法将会导致线程A释放锁并被构造成节点放入到等待队列末尾，同时线程A进入等待状态。</strong><p>等待队列基本结构如下图所示：<p><img alt=image-20200721004540435 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200721004540435.png?token=AIGEF3NQLSRDPSWZXDGZACLEZZZEI><p><strong>Object监视器模型中，一个对象拥有一个同步队列和等待队列，而并发包中的 Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列，</strong>其对应关系如图所示：<p><img alt=image-20200721004716947 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200721004716947.png?token=AIGEF3IGGKYM4Z4T7SDOZYDEZZZFK><h5 id=独占式获取与释放><a class=headerlink href=#独占式获取与释放 title=独占式获取与释放></a>独占式获取与释放</h5><p><strong>调用同步器的acquire(int arg)方法可以获取同步状态，该方法对中断不敏感。</strong><p>当前线程调用<code>acquireQueued(final Node node,int arg)</code>方法会在“死循环”中尝试获取同步状态，而只有前驱节点是头节点才能够尝试获取同步状态，这是为什么？原因有两个：<ol><li>头节点是成功获取到同步状态的节点，头节点中的线程释放同步状态后会唤醒后继节点来获取同步状态，后继节点中的线程被唤醒后还需要检查自己的前驱节点是否是头节点。<li>维护同步队列的FIFO原则。</ol><p><strong>调用同步器的<code>release(int arg)</code>方法会释放同步状态，释放同步状态后会唤醒后继节点来尝试获取同步状态。</strong><h5 id=共享式获取与释放><a class=headerlink href=#共享式获取与释放 title=共享式获取与释放></a>共享式获取与释放</h5><p>共享式获取与独占式获取最主要的区别在于：<strong>同一时刻能否有多个线程同时获取到同步状态。</strong><p><strong>通过调用同步器的acquireShared(int arg)方法可以共享式获取同步状态。</strong>共享式成功获取到同步状态并退出自旋的条件是<code>tryAcquireShared(int arg)</code>方法返回值大于等于0。其具体过程：如果当前节点的前驱节点是头节点，则尝试获取同步状态，返回值大于等于0时标志着获取同步状态成功并从自旋过程中退出。<p>与独占式一样，共享式获取也需要释放同步状态，<strong>通过调用releaseShared(int arg)方法可以释放同步状态。</strong><h3 id=5-8-4、Unsafe><a class=headerlink href=#5-8-4、Unsafe title=5.8.4、Unsafe></a>5.8.4、Unsafe</h3><h4 id=简介-8><a class=headerlink href=#简介-8 title=简介></a>简介</h4><ol><li>主要用来操作JVM中的内存。<li>直接操作内存：allocateMemory、putXX、freeMemory、pageSize<li>直接生成实例：allocateInstance。<li>直接操作类或实例变量：objectFieldOffset、getInt、getObject。<li>CAS相关：weakCompareAndSetObject / int / Long。<li>Unsafe相当于C/C++中的指针。</ol><blockquote><p>注意：<strong>C分配/释放内存使用malloc/free，C++分配/释放内存使用new/delete。</strong></blockquote><h4 id=使用实例><a class=headerlink href=#使用实例 title=使用实例></a>使用实例</h4><p>Atomicinteger：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=type>int</span> <span class="title function_">incrementAndGet</span><span class=params>()</span> {</span><br><span class=line>    <span class=keyword>for</span> (;;) {</span><br><span class=line>    	<span class=type>int</span> <span class=variable>current</span> <span class=operator>=</span> get();</span><br><span class=line>    	<span class=type>int</span> <span class=variable>next</span> <span class=operator>=</span> current + <span class=number>1</span>;</span><br><span class=line>    	<span class=keyword>if</span> (compareAndSet(current, next))</span><br><span class=line>    	<span class=keyword>return</span> next;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=type>boolean</span> <span class="title function_">compareAndSet</span><span class=params>(<span class=type>int</span> expect, <span class=type>int</span> update)</span> {</span><br><span class=line>	<span class=keyword>return</span> unsafe.compareAndSwapInt(<span class=built_in>this</span>, valueOffset, expect, update);</span><br><span class=line>}</span><br></pre></table></figure><p>Unsafe:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>native</span> <span class=type>boolean</span> <span class="title function_">compareAndSwapInt</span><span class=params>(Object var1, <span class=type>long</span> var2, <span class=type>int</span> var4, <span class=type>int</span> var5)</span>;</span><br></pre></table></figure><p>运用：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> sun.misc.Unsafe;</span><br><span class=line><span class=keyword>import</span> java.lang.reflect.Field;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">T02_TestUnsafe</span> {</span><br><span class=line>    <span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>T02_TestUnsafe</span> <span class=variable>t</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">T02_TestUnsafe</span>();</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=comment>//Unsafe unsafe = Unsafe.getUnsafe();</span></span><br><span class=line></span><br><span class=line>        <span class=type>Field</span> <span class=variable>unsafeField</span> <span class=operator>=</span> Unsafe.class.getDeclaredFields()[<span class=number>0</span>];</span><br><span class=line>        unsafeField.setAccessible(<span class=literal>true</span>);</span><br><span class=line>        <span class=type>Unsafe</span> <span class=variable>unsafe</span> <span class=operator>=</span> (Unsafe) unsafeField.get(<span class=literal>null</span>);</span><br><span class=line></span><br><span class=line>        <span class=type>Field</span> <span class=variable>f</span> <span class=operator>=</span> T02_TestUnsafe.class.getDeclaredField(<span class=string>"i"</span>);</span><br><span class=line>        <span class=type>long</span> <span class=variable>offset</span> <span class=operator>=</span> unsafe.objectFieldOffset(f);</span><br><span class=line>        System.out.println(offset);</span><br><span class=line></span><br><span class=line>        <span class=type>boolean</span> <span class=variable>success</span> <span class=operator>=</span> unsafe.compareAndSwapInt(t, offset, <span class=number>0</span>, <span class=number>1</span>);</span><br><span class=line>        System.out.println(success);</span><br><span class=line>        System.out.println(t.i);</span><br><span class=line>        <span class=comment>//unsafe.compareAndSwapInt()</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>jdk8u: unsafe.cpp:<p>cmpxchg = compare and exchange<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=built_in>UNSAFE_ENTRY</span>(jboolean, <span class=built_in>Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class=line>  <span class=built_in>UnsafeWrapper</span>(<span class=string>"Unsafe_CompareAndSwapInt"</span>);</span><br><span class=line>  oop p = JNIHandles::<span class=built_in>resolve</span>(obj);</span><br><span class=line>  jint* addr = (jint *) <span class=built_in>index_oop_from_field_offset_long</span>(p, offset);</span><br><span class=line>  <span class=keyword>return</span> (jint)(Atomic::<span class=built_in>cmpxchg</span>(x, addr, e)) == e;</span><br><span class=line>UNSAFE_END</span><br></pre></table></figure><p>jdk8u: atomic_linux_x86.inline.hpp<p>is_MP = Multi Processor<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>inline</span> jint <span class=title>Atomic::cmpxchg</span><span class=params>(jint exchange_value, <span class=keyword>volatile</span> jint*dest, jint compare_value)</span> </span>{</span><br><span class=line>  <span class=type>int</span> mp = os::<span class=built_in>is_MP</span>();</span><br><span class=line>  <span class=function>__asm__ <span class=title>volatile</span> <span class=params>(LOCK_IF_MP(%<span class=number>4</span>) <span class=string>"cmpxchgl %1,(%3)"</span></span></span></span><br><span class=line><span class=params><span class=function>                    : <span class=string>"=a"</span> (exchange_value)</span></span></span><br><span class=line><span class=params><span class=function>                    : <span class=string>"r"</span> (exchange_value), <span class=string>"a"</span> (compare_value), <span class=string>"r"</span> (dest), <span class=string>"r"</span> (mp)</span></span></span><br><span class=line><span class=params><span class=function>                    : <span class=string>"cc"</span>, <span class=string>"memory"</span>)</span></span>;</span><br><span class=line>  <span class=keyword>return</span> exchange_value;</span><br><span class=line>}</span><br></pre></table></figure><p>jdk8u: os.hpp is_MP()<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=function><span class=type>static</span> <span class=keyword>inline</span> <span class=type>bool</span> <span class=title>is_MP</span><span class=params>()</span> </span>{</span><br><span class=line>  <span class=comment>// During bootstrap if _processor_count is not yet initialized</span></span><br><span class=line>  <span class=comment>// we claim to be MP as that is safest. If any platform has a</span></span><br><span class=line>  <span class=comment>// stub generator that might be triggered in this phase and for</span></span><br><span class=line>  <span class=comment>// which being declared MP when in fact not, is a problem - then</span></span><br><span class=line>  <span class=comment>// the bootstrap routine for the stub generator needs to check</span></span><br><span class=line>  <span class=comment>// the processor count directly and leave the bootstrap routine</span></span><br><span class=line>  <span class=comment>// in place until called after initialization has ocurred.</span></span><br><span class=line>  <span class=keyword>return</span> (_processor_count != <span class=number>1</span>) || AssumeMP;</span><br><span class=line>}</span><br></pre></table></figure><p>jdk8u: atomic_linux_x86.inline.hpp<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=keyword>define</span> LOCK_IF_MP(mp) <span class=string>"cmp $0, "</span> #mp <span class=string>"; je 1f; lock; 1: "</span></span></span><br></pre></table></figure><p>最终实现：cmpxchg = cas修改变量值<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>lock cmpxchg 指令</span><br></pre></table></figure><p>硬件：lock指令在执行后面指令的时候锁定一个北桥信号（不采用锁总线的方式）。<h1 id=6、Java线程池><a class=headerlink href=#6、Java线程池 title=6、Java线程池></a>6、Java线程池</h1><h2 id=6-1、认识线程池><a class=headerlink href=#6-1、认识线程池 title=6.1、认识线程池></a>6.1、认识线程池</h2><h3 id=6-1-1、线程池优点><a class=headerlink href=#6-1-1、线程池优点 title=6.1.1、线程池优点></a>6.1.1、线程池优点</h3><p>合理地使用线程池能够带来3个好处：<ol><li>降低资源消耗。<li>提高响应速度。<li>提高线程的可管理性。</ol><h3 id=6-1-2、提交任务><a class=headerlink href=#6-1-2、提交任务 title=6.1.2、提交任务></a>6.1.2、提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。<p>两者区别如下：<ol><li>execute方法没有返回值，submit方法有返回值；<li>execute方法会抛出异常，submit方法不会抛出异常，但可通过Future.get方法打印异常；<li>execute方法入参为Runnable，submit方法入参可以是Runnable，也可以是Callable；</ol><h3 id=6-1-3、执行任务><a class=headerlink href=#6-1-3、执行任务 title=6.1.3、执行任务></a>6.1.3、执行任务</h3><p>当提交一个新任务到线程池时，线程池的处理流程如下。<ol><li><strong>判断线程池中的核心线程是否都在执行任务</strong>。如果不是，则创建一个新的核心线程来执行任务。如果核心线程都在执行任务，则进入下个流程。<li><strong>判断工作队列是否已经满</strong>。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。<li><strong>判断线程池中的线程数量是否达到最大限制</strong>。如果没有，则创建一个新的非核心线程来执行任务。如果已经达到最大限制，则交给饱和策略来处理这个任务。</ol><h3 id=6-1-4、关闭线程池><a class=headerlink href=#6-1-4、关闭线程池 title=6.1.4、关闭线程池></a>6.1.4、关闭线程池</h3><p>调用线程池的shutdown或shutdownNow方法可以关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务 可能 永远无法终止。<p>shutdown和shutdownNow两者有区别：<ul><li><p><strong>shutdown</strong>：将线程池状态设置成SHUTDOWN状态，然后中断所有空闲线程。</p><li><p><strong>shutdownNow</strong>：先将线程池状态设置成STOP，然后尝试停止所有正在执行任务或暂停的线程，并返回等待执行任务的列表。</p></ul><p>只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后才表示线程池关闭成功，这时调用isTerminaed方法会返回true。<h2 id=6-2、线程池实现><a class=headerlink href=#6-2、线程池实现 title=6.2、线程池实现></a>6.2、线程池实现</h2><h3 id=6-2-1、WorkStealingPool><a class=headerlink href=#6-2-1、WorkStealingPool title=6.2.1、WorkStealingPool></a>6.2.1、WorkStealingPool</h3><h4 id=简介-9><a class=headerlink href=#简介-9 title=简介></a>简介</h4><p><strong>WorkStealingPool是一种特殊线程池，核心很简单，和其它线程池的区别是：每一个线程都有自己单独的队列，任务会不断的插入到每一个线程对应的队列中，某个线程执行完自己队列中的任务后，会尝试从其它线程的队列中取出任务来执行，这个就是WorkStealingPool。</strong><h4 id=实现><a class=headerlink href=#实现 title=实现></a>实现</h4><p>本质上是一个ForkJoinPool。<h4 id=优缺点><a class=headerlink href=#优缺点 title=优缺点></a>优缺点</h4><p>针对通常意义上的线程池来说，如果某一个线程任务量非常庞大，一直占据着CPU，与此同时其它线程就算是闲着也不能去帮忙——无能为力；而WorkStealingPool就灵活了许多，遇到任务量庞大的线程，其它线程如果执行完了自己的任务后，可以帮忙执行这个任务量庞大的线程，提高了执行效率。<h3 id=6-2-2、ForkJoinPool><a class=headerlink href=#6-2-2、ForkJoinPool title=6.2.2、ForkJoinPool></a>6.2.2、ForkJoinPool</h3><h4 id=简介-10><a class=headerlink href=#简介-10 title=简介></a>简介</h4><p><strong>ForkJoinPool适合把大任务切分成一个个小任务去执行，如果觉得小任务还是太大，那就再切，切到满意为止。每一个小任务执行完成后需要进行汇总——小任务汇总到父任务，父任务最终汇总到根任务，最后得到最终期望的结果，这个汇总合并的过程叫join，故该线程池称为ForkJoinPool。</strong><p>Fork/Join默认会创建与CPU核数数量相同的线程池。<h4 id=注意事项-2><a class=headerlink href=#注意事项-2 title=注意事项></a>注意事项</h4><p>一般实现ForkJoinPool的时候需要定义为特定的类型——能进行切分的任务，故出现了该种类型的任务——ForkJoinTask。但ForkJoinTask太过于原始，我们可以使用RecursiveAction，其有两种形式：<ol><li>RecursiveAction递归：大任务可以切分成小任务，小任务还可以再切分成更小的任务，其隐含了一个递归过程，因此叫RecursiveAction递归，不带返回值。<li>从RecursiveTask继承，有返回值。</ol><h2 id=6-3、默认线程池><a class=headerlink href=#6-3、默认线程池 title=6.3、默认线程池></a>6.3、默认线程池</h2><p>Class Executors中提供了默认线程池创建API，不过最终还是会通过ThreadPoolExecutor去实现。<p>Executors常用线程池实现有：<ol><li>SingleThreadExecutor<li>CachedThreadPool<li>FixedThreadPool<li>ScheduledThreadPool</ol><h3 id=6-3-1、SingleThreadExecutor><a class=headerlink href=#6-3-1、SingleThreadExecutor title=6.3.1、SingleThreadExecutor></a>6.3.1、SingleThreadExecutor</h3><ul><li><p>简介：线程池中只有一个线程，一个线程的线程池可以保证扔进去的任务是顺序执行的。</p><li><p>特点（默认）：核心1，最大1，空闲0L，单位毫秒，队列LinkedBlockingQueue，工厂DefaultThreadFactory，拒绝策略AbortPolicy；</p><li><p>实例</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>ExecutorService</span> <span class=variable>service</span> <span class=operator>=</span> Executors.newSingleThreadExecutor();</span><br><span class=line><span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span><span class=number>0</span>; i < <span class=number>5</span>; i++){</span><br><span class=line>    <span class=keyword>final</span> <span class=type>int</span> <span class=variable>j</span> <span class=operator>=</span> i;</span><br><span class=line>    service.execute(() -> {</span><br><span class=line>        System.out.println(j + <span class=string>" "</span> + Thread.currentThread().getName());</span><br><span class=line>    });</span><br><span class=line>}</span><br></pre></table></figure></ul><h3 id=6-3-2、CachedThreadPool><a class=headerlink href=#6-3-2、CachedThreadPool title=6.3.2、CachedThreadPool></a>6.3.2、CachedThreadPool</h3><ul><li><p>简介：提交一个任务时，若线程池中没有线程则创建一个线程来执行该任务，若有则不创建。</p><li><p>特点（默认）：核心0，最大Integer.MAX_VALUE，空闲60，单位秒，队列SynchronousQueue(默认false非公平；fair ? new TransferQueue<e>() : new TransferStack<e>();)，工厂DefaultThreadFactory，拒绝策略AbortPolicy； <li><p>实例</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=type>ExecutorService</span> <span class=variable>service</span> <span class=operator>=</span> Executors.newCachedThreadPool();</span><br><span class=line>System.out.println(<span class=string>"1 service: "</span> + service);</span><br><span class=line><span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < <span class=number>2</span>; i++){</span><br><span class=line>    service.execute(() -> {</span><br><span class=line>        shhSleep(<span class=number>1</span>);</span><br><span class=line>        System.out.println(Thread.currentThread().getName());</span><br><span class=line>    });</span><br><span class=line>}</span><br><span class=line>System.out.println(<span class=string>"2 service: "</span> + service);</span><br><span class=line>shhSleep(<span class=number>3</span>);</span><br><span class=line>System.out.println(<span class=string>"3 service: "</span> + service);</span><br><span class=line></span><br><span class=line>---</span><br><span class=line></span><br><span class=line><span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">shhSleep</span><span class=params>(<span class=type>long</span> t)</span>{</span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        TimeUnit.SECONDS.sleep(t);</span><br><span class=line>    }<span class=keyword>catch</span> (InterruptedException e){</span><br><span class=line>        e.printStackTrace();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure></li> <h3 id=6-3-3、FixedThreadPool><a class=headerlink href=#6-3-3、FixedThreadPool title=6.3.3、FixedThreadPool></a>6.3.3、FixedThreadPool</h3><ul><li><p>简介：固定的线程数，核心线程数和最大线程数都一样，因此没有回收之说，故就指定为0。</p><li><p>特点（默认）：核心、最大显式指定且一样，空闲0，单位毫秒，队列LinkedBlockingQueue，工厂DefaultThreadFactory，拒绝策略AbortPolicy；</p><li><p>实例</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br></pre><td class=code><pre><span class=line><span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">FixedThreadPoolTest</span><span class=params>()</span>{</span><br><span class=line>    <span class=type>long</span> start, end;</span><br><span class=line>    <span class=keyword>final</span> <span class=type>int</span> <span class=variable>cpuCoreNum</span> <span class=operator>=</span> <span class=number>4</span>;</span><br><span class=line>    <span class=type>ExecutorService</span> <span class=variable>service</span> <span class=operator>=</span> Executors.newFixedThreadPool(cpuCoreNum);</span><br><span class=line>    <span class=type>Task</span> <span class=variable>task1</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Task</span>(<span class=number>1</span>, <span class=number>80000</span>);</span><br><span class=line>    <span class=type>Task</span> <span class=variable>task2</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Task</span>(<span class=number>80001</span>, <span class=number>130000</span>);</span><br><span class=line>    <span class=type>Task</span> <span class=variable>task3</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Task</span>(<span class=number>130001</span>, <span class=number>170000</span>);</span><br><span class=line>    <span class=type>Task</span> <span class=variable>task4</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Task</span>(<span class=number>170001</span>, <span class=number>200000</span>);</span><br><span class=line>    Future&LTList&LTInteger>> f1 = service.submit(task1);</span><br><span class=line>    Future&LTList&LTInteger>> f2 = service.submit(task2);</span><br><span class=line>    Future&LTList&LTInteger>> f3 = service.submit(task3);</span><br><span class=line>    Future&LTList&LTInteger>> f4 = service.submit(task4);</span><br><span class=line>    <span class=keyword>try</span>{</span><br><span class=line>        start = System.currentTimeMillis();</span><br><span class=line>        f1.get();</span><br><span class=line>        f2.get();</span><br><span class=line>        f3.get();</span><br><span class=line>        f4.get();</span><br><span class=line>        end = System.currentTimeMillis();</span><br><span class=line>        System.out.println(end - start);</span><br><span class=line>    }<span class=keyword>catch</span> (InterruptedException e){</span><br><span class=line>        e.printStackTrace();</span><br><span class=line>    }<span class=keyword>catch</span> (ExecutionException e){</span><br><span class=line>        e.printStackTrace();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line>---</span><br><span class=line></span><br><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">Task</span> <span class=keyword>implements</span> <span class="title class_">Callable</span>&LTList&LTInteger>>{</span><br><span class=line>    <span class=type>int</span> startPos, endPos;</span><br><span class=line>    Task(<span class=type>int</span> s, <span class=type>int</span> e){</span><br><span class=line>        <span class=built_in>this</span>.startPos = s;</span><br><span class=line>        <span class=built_in>this</span>.endPos = e;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> List&LTInteger> <span class="title function_">call</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        List&LTInteger> r = getPrime(startPos, endPos);</span><br><span class=line>        <span class=keyword>return</span> r;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>static</span> <span class=type>boolean</span> <span class="title function_">isPrime</span><span class=params>(<span class=type>int</span> num)</span>{</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>2</span>; i < num/<span class=number>2</span>; i++){</span><br><span class=line>            <span class=keyword>if</span> (num % i == <span class=number>0</span>)</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>static</span> List&LTInteger> <span class="title function_">getPrime</span><span class=params>(<span class=type>int</span> start, <span class=type>int</span> end)</span>{</span><br><span class=line>        List&LTInteger> results = <span class=keyword>new</span> <span class="title class_">ArrayList</span><>();</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> start; i <= end; i++){</span><br><span class=line>            <span class=keyword>if</span> (isPrime(i))</span><br><span class=line>                results.add(i);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> results;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure></ul> <h3 id=6-3-4、ScheduledThreadPool><a class=headerlink href=#6-3-4、ScheduledThreadPool title=6.3.4、ScheduledThreadPool></a>6.3.4、ScheduledThreadPool</h3><ul><li><p>简介：定时任务池，本质上还是ThreadPoolExecutor。</p><li><p>特点（默认）：核心指定，最大Integer.MAX_VALUE，空闲0，单位纳秒，队列DelayedWorkQueue，工厂DefaultThreadFactory，拒绝策略AbortPolicy；</p><li><p>实例</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">ScheduledThreadPoolTest</span><span class=params>()</span>{</span><br><span class=line>    <span class=type>ScheduledExecutorService</span> <span class=variable>service</span> <span class=operator>=</span> Executors.newScheduledThreadPool(<span class=number>4</span>);</span><br><span class=line>    service.scheduleAtFixedRate(() -> {</span><br><span class=line>        <span class=keyword>try</span>{</span><br><span class=line>            TimeUnit.MILLISECONDS.sleep(<span class=keyword>new</span> <span class="title class_">Random</span>().nextInt(<span class=number>1000</span>));</span><br><span class=line>        }<span class=keyword>catch</span> (InterruptedException e){</span><br><span class=line>            e.printStackTrace();</span><br><span class=line>        }</span><br><span class=line>        System.out.println(Thread.currentThread().getName());</span><br><span class=line>    }, <span class=number>0</span>, <span class=number>500</span>, TimeUnit.MILLISECONDS);</span><br><span class=line>}</span><br></pre></table></figure></ul> <h2 id=6-4、自定义线程池><a class=headerlink href=#6-4、自定义线程池 title=6.4、自定义线程池></a>6.4、自定义线程池</h2><h3 id=6-4-1、简介><a class=headerlink href=#6-4-1、简介 title=6.4.1、简介></a>6.4.1、简介</h3><p>自定义线程池可通过ThreadPoolExecutor来实现，其相关参数如下：</p> <ol><li><p>corePoolSize（核心线程数）</p><li><p>maximumPoolSize（最大线程数）</p><li><p>keepAliveTime（空闲时间）</p><li><p>TimeUnit unit（空闲时间单位）</p><li><p>BlockingQueue workQueue（阻塞队列）</p><li><p>ThreadFactory threadFactory（线程工厂）</p><li><p>RejectedExecutionHandler handler（拒绝策略）：拒绝策略有四种</p> <ol><li>AbortPolicy（默认）：抛异常RejectedExecutionException<li>DiscardPolicy：扔掉，不抛异常。<li>DiscardOldestPolicy：扔掉排队时间最久的。但是线程池如果关闭了，任务就会被丢弃。<li>CallerRunsPolicy：调用者来处理被拒绝的任务，比如主线程调用submit方法任务，但任务被拒绝，则主线程直接执行。但是线程池如果关闭了，任务就会被丢弃。</ol> <p>除此之外还可以自定义拒绝策略，方式为：实现接口<code>RejectedExecutionHandler</code>，并重写其<code>rejectedExecution(Runnable r, ThreadPoolExecutor executor)</code>方法。</p><li><p>boolean allowCoreThreadTimeOut：是否允许核心线程超时销毁，该参数不在构造函数中，但也极其重要。</p> <p>取值定义：如果为false（默认），则表示即使处于空闲状态，核心线程也保持活动状态（不销毁）。如果为true，则核心线程使用keepAliveTime来超时等待工作（时间过后就销毁）。</p></ol> <h3 id=6-4-2、使用示例><a class=headerlink href=#6-4-2、使用示例 title=6.4.2、使用示例></a>6.4.2、使用示例</h3><p>拒绝策略使用示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>ThreadPoolExecutor</span> <span class=variable>executor</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class=number>2</span>, <span class=number>4</span>, <span class=number>60</span>, TimeUnit.SECONDS, <span class=keyword>new</span> <span class="title class_">ArrayBlockingQueue</span><>(<span class=number>4</span>),Executors.defaultThreadFactory(),<span class=keyword>new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></table></figure> <h3 id=6-4-3、最合适的线程数量><a class=headerlink href=#6-4-3、最合适的线程数量 title=6.4.3、最合适的线程数量></a>6.4.3、最合适的线程数量</h3><h4 id=6-4-3-1、CPU密集型运算><a class=headerlink href=#6-4-3-1、CPU密集型运算 title=6.4.3.1、CPU密集型运算></a>6.4.3.1、CPU密集型运算</h4><p><strong>CPU密集型业务通常采用 cpu核数+1 的数量值作为合适的线程数量。</strong>这样可以实现最优的CPU利用率，加1是保证当线程由于页缺失或其它问题导致暂停时，额外的线程就能顶上去，保证CPU时钟周期不浪费。</p> <h4 id=6-4-3-2、IO密集型运算><a class=headerlink href=#6-4-3-2、IO密集型运算 title=6.4.3.2、IO密集型运算></a>6.4.3.2、IO密集型运算</h4><p>CPU不总是处于繁忙状态，例如，当执行业务计算时会使用CPU资源，但当执行IO操作、RPC远程调用、数据库操作时，CPU不会工作会空闲下来，此时可以利用多线程来提高CPU利用率。</p> <p>经验公式如下：<br>$$<br>线程数量 = 核数 * CPU期望利用率 * 总时间(CPU计算时间+等待时间) / CPU计算时间。<br>$$<br>例如：4核CPU计算时间50%，其它等待时间是50%，期望CPU被100%利用，则</p> <p>线程数量 = 4 * 100% * 100% / 50% = 8个。</p> <p>例如：4核 CPU计算时间10%，其它等待时间是90%，期望CPU被100%利用，则</p> <p>线程数量 = 4 * 100% * 100% / 10% = 40个。</p> <h2 id=6-5、线程池监控><a class=headerlink href=#6-5、线程池监控 title=6.5、线程池监控></a>6.5、线程池监控</h2><h3 id=6-5-1、简介><a class=headerlink href=#6-5-1、简介 title=6.5.1、简介></a>6.5.1、简介</h3><p><strong>如果在系统中大量使用线程池，则有必要对线程池进行监控</strong>，方便在出现问题时，可以根据线程池的使用状况快速定位问题。</p> <h3 id=6-5-2、监控方式><a class=headerlink href=#6-5-2、监控方式 title=6.5.2、监控方式></a>6.5.2、监控方式</h3><h4 id=参数监控><a class=headerlink href=#参数监控 title=参数监控></a>参数监控</h4><p><strong>可以通过线程池提供的参数进行监控</strong>，监控线程池时可以使用以下属性。</p> <ul><li>taskCount：线程池需要执行的任务数量。<li>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。<li>largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是 否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。<li>getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。<li>getActiveCount：获取活动的线程数。</ul> <h4 id=扩展监控><a class=headerlink href=#扩展监控 title=扩展监控></a>扩展监控</h4><p>通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的 beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执行一些代码来进行监控。</p> <p>例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。 这几个方法在线程池里是空方法。</p> <h2 id=6-6、Executor框架><a class=headerlink href=#6-6、Executor框架 title=6.6、Executor框架></a>6.6、Executor框架</h2><h3 id=6-6-1、Executor类结构图><a class=headerlink href=#6-6-1、Executor类结构图 title=6.6.1、Executor类结构图></a>6.6.1、Executor类结构图</h3><p><img alt=Executor类结构图01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/Executor%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE01.png?token=AIGEF3NWRCARP7IVE37JHV3EZZZKE></p> <h3 id=6-6-2、ThreadPoolExecutor源码解析（JDK8）><a class=headerlink href=#6-6-2、ThreadPoolExecutor源码解析（JDK8） title=6.6.2、ThreadPoolExecutor源码解析（JDK8）></a>6.6.2、ThreadPoolExecutor源码解析（JDK8）</h3><h4 id=addWorker><a class=headerlink href=#addWorker title=addWorker></a>addWorker</h4><p>addWorker的源码分两部分：</p> <ol><li>上面的嵌套for死循环，目的就是把worker数量加1。<ol><li>外层for循环：遍历检测状态值是否符合条件，如果状态值 >= shutdown，说明不符合条件，执行return false退出。<li>内层for循环：添加线程。先判断当前WC线程数量是否超过上限（数量 > 536870911或者 >= (corePoolSize /maximumPoolSize)），如果超过就不再添加，否则通过CAS方式进行添加。如果添加成功了，则执行break retr跳出双层循环，这说明第一步算是完成了；如果没有添加成功就继续AtomicInteger的get方法，然后跳到最外层循环处进行重新处理；</ol><li>创建一个Worker并执行这个Worker。</ol> <h4 id=execute><a class=headerlink href=#execute title=execute></a>execute</h4><ol><li><p>如果任务为null，则抛出异常。</p><li><p>工作线程数 是否小于 核心线程数，若小于则直接创建核心线程。否则将任务放入队列中。</p><li><p>如果线程池不是运行状态，或者任务进入队列失败了，则创建非核心线程执行任务。</p></ol> <p><font color=red>注意事项：</font></p> <ol><li>线程非运行状态时，addWorker内部会判断线程池状态。<li>addWorker的第二个参数表示是否创建核心线程。<li>addWorker返回false，说明任务执行失败，需要进行reject操作。</ol> <h4 id=runWorker><a class=headerlink href=#runWorker title=runWorker></a>runWorker</h4><p><strong>启动线程后会通过该方法去执行任务，期间需要加锁</strong>。</p> <ol><li><p>先执行Worker.unlock()方法来允许中断操作；变量boolean completedAbruptly 用于表示是否自旋。</p><li><p>自旋过程。如果firstTask不为null 或者 任务队列不为空，则从队列拿任务来执行，否则将 completedAbruptly设为false; 且最终执行processWorkerExit(w, completedAbruptly);</p> <p>从队列拿到任务后，执行任务的过程如下：</p> <ol><li>w.lock()加锁，任务执行的原子性。<li>如果线程池正在停止，则对当前线程进行中断操作。<li>执行任务的前后通过beforeExecute()、afterExecute()来扩展功能。但要注意这两个方法在该类中默认是空实现。<li>执行 completedAbruptly = false; 和 processWorkerExit(w, completedAbruptly);</ol></ol> <h3 id=6-6-3、ScheduledThreadPoolExecutor><a class=headerlink href=#6-6-3、ScheduledThreadPoolExecutor title=6.6.3、ScheduledThreadPoolExecutor></a>6.6.3、ScheduledThreadPoolExecutor</h3><h4 id=简介-11><a class=headerlink href=#简介-11 title=简介></a>简介</h4><p>继承自ThreadPoolExecutor，<strong>可在指定延迟之后运行任务，或者定期执行任务。</strong>其功能与Timer类似，但 ScheduledThreadPoolExecutor功能更强大、更灵活。Timer对应的是单个后台线程，而 ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。</p> <h4 id=运行机制><a class=headerlink href=#运行机制 title=运行机制></a>运行机制</h4><p>ScheduledThreadPoolExecutor的执行主要分为两大部分：</p> <ol><li>当调用ScheduledThreadPoolExecutor的scheduleAtFixedRate()方法或者scheduleWithFixedDelay()方法时，会向ScheduledThreadPoolExecutor的DelayQueue添加一个实现了 RunnableScheduledFutur接口的ScheduledFutureTask。<li>线程池中的线程从DelayQueue中获取ScheduledFutureTask，然后执行任务。</ol> <h4 id=底层实现-3><a class=headerlink href=#底层实现-3 title=底层实现></a>底层实现</h4><p>ScheduledThreadPoolExecutor会把待调度的任务（ScheduledFutureTask） 放到一个DelayQueue中。</p> <p>ScheduledFutureTask主要包含3个成员变量：</p> <ul><li>long型成员变量time，表示这个任务将要被执行的具体时间。<li>long型成员变量sequenceNumber，表示这个任务被添加到ScheduledThreadPoolExecutor中的序号。<li>long型成员变量period，表示任务执行的间隔周期。</ul> <h3 id=6-6-4、FutureTask><a class=headerlink href=#6-6-4、FutureTask title=6.6.4、FutureTask></a>6.6.4、FutureTask</h3><p>Future接口和实现Future接口的FutureTask类，代表异步计算的结果。</p> <h4 id=简介-12><a class=headerlink href=#简介-12 title=简介></a>简介</h4><p>FutureTask除了实现Future接口外，还实现了Runnable接口。因此，<strong>FutureTask可以交给 Executor执行，也可以由调用线程直接执行（FutureTask.run()）。</strong></p> <p>根据FutureTask.run()方法被执行的时机，FutureTask可处于3种状态：</p> <ul><li>未启动<ol><li>FutureTask.get()方法将导致调用线程阻塞；<li>FutureTask.cancel()方法将导致此任务永远不会被执行；</ol><li>已启动<ol><li>FutureTask.get()方法将导致调用线程阻塞；<li>FutureTask.cancel（true）方法将以中断执行此任务线程 的方式来试图停止任务；<li>FutureTask.cancel（false）方法将 不会对正在执行此任务的线程产生影响（让正在执行的任务运行完成）；</ol><li>已完成<ol><li>FutureTask.get()方法将导致调用线程立即返回结果或抛出异常；<li>FutureTask.cancel（…）方法将返回false。</ol></ul> <h4 id=底层实现-4><a class=headerlink href=#底层实现-4 title=底层实现></a>底层实现</h4><p>FutureTask的实现基于AbstractQueuedSynchronizer。</p> <p>AQS被作为“模板方法模式”的基础类提供给FutureTask的内部子类Sync，这个内部子类只需要实现状态检查和状态更新的方法即可，这些方法将控制FutureTask的获取和释放操作。具体来说，Sync实现了AQS的tryAcquireShared(int) 方法和 tryReleaseShared(int) 方法，Sync通过这两个方法来检查和更新同步状态。</p> <h2 id=6-7、总结><a class=headerlink href=#6-7、总结 title=6.7、总结></a>6.7、总结</h2><h3 id=6-7-1、建议使用ThreadPoolExecutor创建线程池><a class=headerlink href=#6-7-1、建议使用ThreadPoolExecutor创建线程池 title=6.7.1、建议使用ThreadPoolExecutor创建线程池></a>6.7.1、建议使用ThreadPoolExecutor创建线程池</h3><ol><li><p>Executors提供的线程池使用场景有限。</p><li><p>Executors底层还是调用ThreadPoolExecutor创建线程池。</p><li><p>OOM问题（阿里手册）</p> <ol><li><p>FixedThreadPool 和 SingleThreadPool</p> <p>两者允许的队列长度为Integer.MAX_VALUE，可能堆积大量请求，进而导致OOM。</p><li><p>CachedThreadPool</p> <p>允许创建的线程数量为Integer.MAX_VALUE，可能创建大量的线程，进而导致OOM。</p></ol></ol> <h3 id=6-7-2、生产中如何选择使用正确的队列？><a class=headerlink href=#6-7-2、生产中如何选择使用正确的队列？ title=6.7.2、生产中如何选择使用正确的队列？></a>6.7.2、生产中如何选择使用正确的队列？</h3><p>根据实际情况来选择：</p> <ol><li>高峰期的任务，建议使用LinkedBlockingQueue，这个是无界队列，不限制任务数量。<li>重要性较低的任务，建议使用ArrayBlockingQueue，这个队列需要指定大小，如果任务超出，会创建非核心线程执行任务。</ol> <h3 id=6-7-3、生产中如何保证线程池队列的可用性？><a class=headerlink href=#6-7-3、生产中如何保证线程池队列的可用性？ title=6.7.3、生产中如何保证线程池队列的可用性？></a>6.7.3、生产中如何保证线程池队列的可用性？</h3><ol><li>设计一个线程管理器，通过一个定时任务 定时检测线程池当前任务队列的状态，设置一个报警阈值（waterThreshold - 水位线），超过该阈值就会报警，然后根据实际情况去应对。<li>线程池压测，如果发生超水位现象，就对线程按线程名做降级，动态调整核心线程数和队列，当然还有限流等保障。</ol> <h3 id=6-7-4、如何拆分线程池、核心任务数、队列大小呢？><a class=headerlink href=#6-7-4、如何拆分线程池、核心任务数、队列大小呢？ title=6.7.4、如何拆分线程池、核心任务数、队列大小呢？></a>6.7.4、如何拆分线程池、核心任务数、队列大小呢？</h3><ol><li><p>按照 任务类型 拆分任务，使用不同的线程池，分别命名。</p><li><p>区分 任务类型。其是CPU密集型，还是IO密集型，CPU密集型 可以设置 核心线程数为CPU核心数，上下文切换少；IO密集型则可以设置核心线程数大一点。</p><li><p>压测并估算，可以参考线程池变量largestPoolSize，它表示线程池达到过的最大线程任务。</p><li><p>设置核心线程数参考公式如下：</p> <p><strong>最佳线程数 = ((线程等待时间 + 线程CPU时间) / 线程CPU时间) * CPU数量;</strong></p></ol> <h1 id=7、高效工具><a class=headerlink href=#7、高效工具 title=7、高效工具></a>7、高效工具</h1><h2 id=7-1、Disruptor><a class=headerlink href=#7-1、Disruptor title=7.1、Disruptor></a>7.1、Disruptor</h2><h3 id=7-1-1、简介><a class=headerlink href=#7-1-1、简介 title=7.1.1、简介></a>7.1.1、简介</h3><p><strong>Disruptor是分裂、瓦解的意思。Disruptor是一个做金融、做股票的公司开发的，开源后受到广泛认可，2011年获得Duke奖。</strong>如果将之用作MQ的话，其是单机最快的MQ。该工具性能非常高，因为内部用了大量的CAS，另外把各种各样的性能开发到了极致。</p> <p><strong>Disruptor存储在内存中，简单理解就是内存中用于存储元素的一个高效队列。</strong></p> <p>Disruptor称为无锁的、高并发的、环形Buffer，直接覆盖旧数据，降低GC频率，用于生产者消费者模式。</p> <h3 id=7-1-2、核心及特点><a class=headerlink href=#7-1-2、核心及特点 title=7.1.2、核心及特点></a>7.1.2、核心及特点</h3><p><strong>Disruptor是一个环形队列、环形Buffer。</strong>Disruptor是用数组实现的一个队列，你也可以认为Disruptor就是用数组实现的ConcurrentArrayQueue，另外这个Queue是首尾相连。</p> <h3 id=7-1-3、实现原理><a class=headerlink href=#7-1-3、实现原理 title=7.1.3、实现原理></a>7.1.3、实现原理</h3><h4 id=Disruptor为啥快？><a class=headerlink href=#Disruptor为啥快？ title=Disruptor为啥快？></a>Disruptor为啥快？</h4><p>环形结构 只需维护 一个位置，就是sequence序列，该序列表示下一个元素在哪里，相当于只有一个指针在移动定位。位置可以通过数值与环形队列容量取模获得。</p> <p>由于采用覆盖方式，所以没有必要记录头指针和尾指针。我只需要一个指针就够用了，就这一点来说依然比ConcurrentLinkedQueue要快。</p> <h4 id=生产者装满数据后继续装会覆盖吗？><a class=headerlink href=#生产者装满数据后继续装会覆盖吗？ title=生产者装满数据后继续装会覆盖吗？></a>生产者装满数据后继续装会覆盖吗？</h4><p>不会覆盖的，因为有等待策略——生产者生产满了就要停止生产并进入等待状态。等待策略共有8种，详情见总结部分。</p> <h3 id=7-1-4、开发步骤><a class=headerlink href=#7-1-4、开发步骤 title=7.1.4、开发步骤></a>7.1.4、开发步骤</h3><p>开发步骤是比较固定的。</p> <ol><li>定义Event：队列中需要处理的元素。<li>定义Event工厂：用于填充队列。<li>定义EventHandle（消费者）：处理容器中的元素。</ol> <h3 id=7-1-5、入门案例><a class=headerlink href=#7-1-5、入门案例 title=7.1.5、入门案例></a>7.1.5、入门案例</h3><h4 id=OrderEvent-java><a class=headerlink href=#OrderEvent-java title=OrderEvent.java></a>OrderEvent.java</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">OrderEvent</span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=type>long</span> value;</span><br><span class=line>    <span class=keyword>public</span> <span class=type>long</span> <span class="title function_">getValue</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> value;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setValue</span><span class=params>(<span class=type>long</span> value)</span> {</span><br><span class=line>        <span class=built_in>this</span>.value = value;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=OrderEventFactory-java><a class=headerlink href=#OrderEventFactory-java title=OrderEventFactory.java></a>OrderEventFactory.java</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">OrderEventFactory</span> <span class=keyword>implements</span> <span class="title class_">EventFactory</span>&LTOrderEvent> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> OrderEvent <span class="title function_">newInstance</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">OrderEvent</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=OrderEventHandler-java><a class=headerlink href=#OrderEventHandler-java title=OrderEventHandler.java></a>OrderEventHandler.java</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">OrderEventHandler</span> <span class=keyword>implements</span> <span class="title class_">EventHandler</span>&LTOrderEvent> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">onEvent</span><span class=params>(OrderEvent event, <span class=type>long</span> sequence, <span class=type>boolean</span> endOfBatch)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        System.out.println(<span class=string>"消费者："</span> + event.getValue());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=OrderEventProducer-java><a class=headerlink href=#OrderEventProducer-java title=OrderEventProducer.java></a>OrderEventProducer.java</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">OrderEventProducer</span> {</span><br><span class=line>    <span class=keyword>private</span> RingBuffer&LTOrderEvent> ringBuffer;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">OrderEventProducer</span><span class=params>(RingBuffer&LTOrderEvent> ringBuffer)</span> {</span><br><span class=line>        <span class=built_in>this</span>.ringBuffer = ringBuffer;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">sendData</span><span class=params>(ByteBuffer data)</span>{</span><br><span class=line>        <span class=type>long</span> <span class=variable>sequence</span> <span class=operator>=</span> ringBuffer.next();</span><br><span class=line>        <span class=keyword>try</span>{</span><br><span class=line>            <span class=comment>//1. 在生产者发送消息的时候，首先需要从ringBuffer里面获取一个可用的序号</span></span><br><span class=line>            <span class=comment>//2. 根据这个序号 找到具体的“orderEvent”元素 此时获取的OrderEvent是一个空的对象</span></span><br><span class=line>            <span class=type>OrderEvent</span> <span class=variable>event</span> <span class=operator>=</span> ringBuffer.get(sequence);</span><br><span class=line>            <span class=comment>//3 进行实际的赋值操作</span></span><br><span class=line>            event.setValue(data.getLong(<span class=number>0</span>));</span><br><span class=line>        }<span class=keyword>finally</span> {</span><br><span class=line>            <span class=comment>// 4 提交操作</span></span><br><span class=line>            ringBuffer.publish(sequence);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=App-java><a class=headerlink href=#App-java title=App.java></a>App.java</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">App</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>OrderEventFactory</span> <span class=variable>orderEventFactory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">OrderEventFactory</span>();</span><br><span class=line>        <span class=type>ExecutorService</span> <span class=variable>executor</span> <span class=operator>=</span> Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class=line>        <span class=type>int</span> <span class=variable>ringBufferSize</span> <span class=operator>=</span> <span class=number>1024</span> * <span class=number>1024</span>;</span><br><span class=line></span><br><span class=line>        <span class=comment>/**</span></span><br><span class=line><span class=comment>         *  1 eventFacotry 消息工厂对象</span></span><br><span class=line><span class=comment>         *  2 ringBufferSize 容器的长度</span></span><br><span class=line><span class=comment>         *  3 executor 线程池</span></span><br><span class=line><span class=comment>         *  4 ProducerType 生产者类型</span></span><br><span class=line><span class=comment>         *  5 waitStartegy 等待策略</span></span><br><span class=line><span class=comment>         */</span></span><br><span class=line>        <span class=comment>// 1 实例化一个disruptor的对象</span></span><br><span class=line>        Disruptor&LTOrderEvent> disruptor = <span class=keyword>new</span> <span class="title class_">Disruptor</span><>(orderEventFactory, ringBufferSize, executor, ProducerType.SINGLE, <span class=keyword>new</span> <span class="title class_">BlockingWaitStrategy</span>());</span><br><span class=line>        <span class=comment>// 2 添加消费者的监听(Disruptor 与消费者的一个关联关系)</span></span><br><span class=line>        disruptor.handleEventsWith(<span class=keyword>new</span> <span class="title class_">OrderEventHandler</span>());</span><br><span class=line>        <span class=comment>// 3 启动disruptor</span></span><br><span class=line>        disruptor.start();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 4 获取实际存储数据的容器 RingBuffer</span></span><br><span class=line>        RingBuffer&LTOrderEvent> ringBuffer = disruptor.getRingBuffer();</span><br><span class=line>        <span class=type>OrderEventProducer</span> <span class=variable>producer</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">OrderEventProducer</span>(ringBuffer);</span><br><span class=line>        <span class=comment>// 生成一百个数 然后丢给producer</span></span><br><span class=line>        <span class=type>ByteBuffer</span> <span class=variable>bb</span> <span class=operator>=</span> ByteBuffer.allocate(<span class=number>8</span>);</span><br><span class=line>        <span class=keyword>for</span>(<span class=type>long</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < <span class=number>100</span>; i++){</span><br><span class=line>            bb.putLong(<span class=number>0</span>, i);</span><br><span class=line>            producer.sendData(bb);</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=comment>// 关闭disruptor和线程池</span></span><br><span class=line>        disruptor.shutdown();</span><br><span class=line>        executor.shutdown();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h3 id=7-1-6、总结><a class=headerlink href=#7-1-6、总结 title=7.1.6、总结></a>7.1.6、总结</h3><h4 id=ProducerType（生产者线程模式）><a class=headerlink href=#ProducerType（生产者线程模式） title=ProducerType（生产者线程模式）></a>ProducerType（生产者线程模式）</h4><p><strong>ProducerType有两种模式：Producer.MULTI 和 Producer.SINGLE。默认为MULTI，表示在多线程模式下产生sequence。如果确定是单线程生产者，可以指定SINGLE，效率会有提升。</strong></p> <h4 id=等待策略（8种）><a class=headerlink href=#等待策略（8种） title=等待策略（8种）></a>等待策略（8种）</h4><ol><li>BlockingWaitStrategy（常用）：通过线程阻塞的方式，等待生产者被唤醒，唤醒后再次检查依赖的sequence是否已经消费。<li>BusySpinWaitStrategy：线程一直自旋等待，可能比较消耗CPU。<li>LiteBlockingWaitStrategy：线程阻塞等待生产者被唤醒。与第1个的区别是——如果两个线程一个访问waitfor，一个访问signalAll时，可以减少lock加锁次数。<li>LiteTimeoutBlockingWaitStrategy：与第3个相比，该策略设置了阻塞时间，超过时间后抛出异常。<li>PhasedBackoffWaitStrategy：根据时间参数和等待的策略来决定使用哪种等待策略。<li>TimeoutBlockingWaitStrategy：相对于第1个来说，该策略设置了等待时间，超过后抛出异常。<li>YieldingWatitStrategy（常用）：尝试100次，然后Thread.yield()让出CPU。<li>SleepingWaitStrategy（常用）：sleep。</ol> <h4 id=消费者异常处理><a class=headerlink href=#消费者异常处理 title=消费者异常处理></a>消费者异常处理</h4><ol><li>默认：disruptor.setDefaultExceptionHandler()；<li>覆盖：disruptor.handleExceptionFor().wait()；</ol> <h2 id=7-1、JMH><a class=headerlink href=#7-1、JMH title=7.1、JMH></a>7.1、JMH</h2><h3 id=7-1-1、简介-1><a class=headerlink href=#7-1-1、简介-1 title=7.1.1、简介></a>7.1.1、简介</h3><p><strong>JMH全程为 java Microbenchmark Harness，意为Java微基准测试。它测试的是一个方法的性能，换了一种实现后再次观察其性能好坏。</strong></p> <p><font color=red>注意：该测试框架于2013年由JLT人员开发而成，后来归到了OpenJDK下面。</font></p> <h3 id=7-1-2、JMH相关概念><a class=headerlink href=#7-1-2、JMH相关概念 title=7.1.2、JMH相关概念></a>7.1.2、JMH相关概念</h3><ol><li>Benchmark mode：基准测试的模式。<li>Warmup：预热，由于JVM会对特定代码进行优化，预热对于测试很重要。<li>Measurement：共执行多少次测试。<li>Timeout：超时时间。<li>Threads：线程数，由fork指定。<li>Benchmark：测试哪一段代码。</ol> <h3 id=7-1-3、使用示例><a class=headerlink href=#7-1-3、使用示例 title=7.1.3、使用示例></a>7.1.3、使用示例</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.Benchmark;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.BenchmarkMode;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.Mode;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.OutputTimeUnit;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.State;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.Scope;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.Setup;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.TearDown;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.runner.Runner;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.util.ArrayList;</span><br><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line><span class=keyword>import</span> java.util.Random;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.TimeUnit;</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * JMH工具测试</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=meta>@State(Scope.Thread)</span></span><br><span class=line><span class=meta>@BenchmarkMode(Mode.AverageTime)</span>    <span class=comment>// 测试模式</span></span><br><span class=line><span class=meta>@OutputTimeUnit(TimeUnit.MILLISECONDS)</span>  <span class=comment>// 时间单位</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">JMHUseTest</span> {</span><br><span class=line>    <span class=keyword>private</span> List&LTInteger> list;</span><br><span class=line>    <span class=keyword>private</span> Random random;</span><br><span class=line></span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 测试前的初始化</span></span><br><span class=line><span class=comment>     *</span></span><br><span class=line><span class=comment>     * 初始化了一个由1000个随机整数组成的List</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=meta>@Setup</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setup</span><span class=params>()</span> {</span><br><span class=line>        list = <span class=keyword>new</span> <span class="title class_">ArrayList</span><>();</span><br><span class=line>        random = <span class=keyword>new</span> <span class="title class_">Random</span>();</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < <span class=number>1000</span>; i++) {</span><br><span class=line>            list.add(random.nextInt());</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 测试后的清理动作</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=meta>@TearDown</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">teardown</span><span class=params>()</span> {</span><br><span class=line>        list = <span class=literal>null</span>;</span><br><span class=line>        random = <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 排序</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=meta>@Benchmark</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testSort</span><span class=params>()</span> {</span><br><span class=line>        list.sort(Integer::compare);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 并行排序</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=meta>@Benchmark</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testParallelSort</span><span class=params>()</span> {</span><br><span class=line>        list.parallelStream().sorted(Integer::compare).toArray();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 常用方法解析：</span></span><br><span class=line><span class=comment>     * - `include(String classNameRegex)`：指定要测试的类，可以使用正则表达式来匹配多个类。</span></span><br><span class=line><span class=comment>     * - `forks(int count)`：指定测试时进行的fork数量，即测试时重复运行基准测试的次数。</span></span><br><span class=line><span class=comment>     * - `warmupIterations(int count)`：指定预热迭代次数，即在测量迭代次数前进行的预热迭代次数。</span></span><br><span class=line><span class=comment>     * - `measurementIterations(int count)`：指定测量迭代次数，即每个基准测试运行的迭代次数。</span></span><br><span class=line><span class=comment>     * - `mode(Mode mode)`：指定测试模式，包括平均时间（AverageTime）、平均吞吐量（Througput）、平均延迟（SampleTime）等。</span></span><br><span class=line><span class=comment>     * - `timeUnit(TimeUnit unit)`：指定测试结果的时间单位，包括纳秒（NANOSECONDS）、微秒（MICROSECONDS）、毫秒（MILLISECONDS）等。</span></span><br><span class=line><span class=comment>     * - `threads(int count)`：指定测试时使用的线程数。</span></span><br><span class=line><span class=comment>     * - `verbosity(VerboseMode mode)`：指定测试结果的详细程度，包括默认（NORMAL）、详细（EXTRA）、极度详细（DEBUG）等。</span></span><br><span class=line><span class=comment>     * - `jvmArgs(String... args)`：指定测试时使用的Java虚拟机参数。</span></span><br><span class=line><span class=comment>     * - `addProfiler(Class&LT? extends Profiler> profilerClass)`：指定测试时使用的分析器.</span></span><br><span class=line><span class=comment>     * - `resultFormat(ResultFormatType type)`：指定测试结果的输出格式，包括文本（TEXT）、CSV、JSON等。</span></span><br><span class=line><span class=comment>     *</span></span><br><span class=line><span class=comment>     * 创建`Options`对象后，可以使用`Runner`类来运行基准测试。`Runner`类提供了多个方法来运行基准测试，如：</span></span><br><span class=line><span class=comment>     * - `run()`：运行基准测试并输出测试结果。</span></span><br><span class=line><span class=comment>     * - `runAsync()`：异步运行基准测试。</span></span><br><span class=line><span class=comment>     * - `runTo(TimeValue time)`：运行基准测试并在指定时间后停止。</span></span><br><span class=line><span class=comment>     * - `runTo(TimeValue time, TimeUnit timeUnit)`：运行基准测试并在指定时间后停止。</span></span><br><span class=line><span class=comment>     *</span></span><br><span class=line><span class=comment>     * <span class=doctag>@param</span> args</span></span><br><span class=line><span class=comment>     * <span class=doctag>@throws</span> RunnerException</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> RunnerException {</span><br><span class=line>        <span class=type>Options</span> <span class=variable>options</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class=line>                .include(JMHUseTest.class.getSimpleName())</span><br><span class=line>                .forks(<span class=number>1</span>)   <span class=comment>// 运行基准测试的次数</span></span><br><span class=line>                .warmupIterations(<span class=number>1</span>)    <span class=comment>// 预热次数</span></span><br><span class=line>                .measurementIterations(<span class=number>3</span>)   <span class=comment>// 基准测试执行的次数</span></span><br><span class=line>                .build();</span><br><span class=line>        <span class=keyword>new</span> <span class="title class_">Runner</span>(options).run();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <footer class=post-footer><div class=post-eof></div></footer> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/10/12/Java%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9F%A5%E8%AF%86%E7%AF%87/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/10/12/Java%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9F%A5%E8%AF%86%E7%AF%87/ itemprop=url>Java系列-设计模式</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-10-12 11:23:46" datetime=2024-10-12T11:23:46+08:00>2024-10-12</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2024-10-10 20:57:19" datetime=2024-10-10T20:57:19+08:00 itemprop=dateModified>2024-10-10</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=0、概述><a class=headerlink href=#0、概述 title=0、概述></a>0、概述</h1><h2 id=0-1、软件设计基本原则><a class=headerlink href=#0-1、软件设计基本原则 title=0.1、软件设计基本原则></a>0.1、软件设计基本原则</h2><ol><li>高内聚，低耦合；<li>面向抽象编程；<li>多用组合少用继承；<li>遵循开闭原则；</ol><h2 id=0-2、设计模式简介><a class=headerlink href=#0-2、设计模式简介 title=0.2、设计模式简介></a>0.2、设计模式简介</h2><p>设计模式是计算机软件领域较抽象的东西，设计模式的作用：使软件系统变得更加稳定、更易扩展、更易维护。<p><strong>设计模式不分语言，共23种，分3种类型：创建型、行为型、结构型</strong>。<h1 id=1、设计模式分类><a class=headerlink href=#1、设计模式分类 title=1、设计模式分类></a>1、设计模式分类</h1><h2 id=1-1、创建型（5种）><a class=headerlink href=#1-1、创建型（5种） title=1.1、创建型（5种）></a>1.1、创建型（5种）</h2><h3 id=1-1-1、Singleton（单例模式）><a class=headerlink href=#1-1-1、Singleton（单例模式） title=1.1.1、Singleton（单例模式）></a>1.1.1、Singleton（单例模式）</h3><h4 id=简介><a class=headerlink href=#简介 title=简介></a>简介</h4><p><strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。常见单例模式实现有：饿汉式、懒汉式、枚举式等</strong>。<h4 id=实现><a class=headerlink href=#实现 title=实现></a>实现</h4><ol><li>构造方法设为私有，禁止它人创建对象。</ol><h4 id=何时使用><a class=headerlink href=#何时使用 title=何时使用></a>何时使用</h4><p>当您想控制实例数目，节省系统资源的时候。<h4 id=优缺点><a class=headerlink href=#优缺点 title=优缺点></a>优缺点</h4><ul><li><p>优点：</p> <ol><li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。<li>避免对资源的多重占用（比如写文件操作）。</ol><li><p>缺点：</p> <p>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p></ul><h4 id=应用实例><a class=headerlink href=#应用实例 title=应用实例></a>应用实例</h4><ol><li>一个班级只有一个班主任。<li>Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。<li>一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</ol><h4 id=使用场景><a class=headerlink href=#使用场景 title=使用场景></a>使用场景</h4><ol><li>要求生产唯一序列号。<li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。<li>创建一个对象消耗资源过多时可通过单例降低多次创建带来的消耗，比如 I/O 与数据库的连接等。</ol><h4 id=注意事项><a class=headerlink href=#注意事项 title=注意事项></a>注意事项</h4><ol><li><font color=red>注意序列化对单例的破坏；</font><li><font color=red>注意反射对单例的破坏；</font></ol><h4 id=代码实例><a class=headerlink href=#代码实例 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br><span class=line>105</span><br><span class=line>106</span><br><span class=line>107</span><br><span class=line>108</span><br><span class=line>109</span><br><span class=line>110</span><br><span class=line>111</span><br><span class=line>112</span><br><span class=line>113</span><br><span class=line>114</span><br><span class=line>115</span><br></pre><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 实例一：基于双重校验锁方式实现单例</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * - 优点：懒加载，效率较好。</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * - 缺点：反序列化会对单例造成破坏</span></span><br><span class=line><span class=comment> *   应对方案：要想防止序列化对单例的破坏，只要添加readResolve方法就可避免。</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Singleton</span> <span class=keyword>implements</span> <span class="title class_">Serializable</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>volatile</span> <span class=keyword>static</span> Singleton singleton;</span><br><span class=line>    <span class=keyword>private</span> <span class="title function_">Singleton</span> <span class=params>()</span>{}</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> Singleton <span class="title function_">getSingleton</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>if</span> (singleton == <span class=literal>null</span>) {</span><br><span class=line>            <span class=keyword>synchronized</span> (Singleton.class) {</span><br><span class=line>                <span class=keyword>if</span> (singleton == <span class=literal>null</span>) {</span><br><span class=line>                    singleton = <span class=keyword>new</span> <span class="title class_">Singleton</span>();</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> singleton;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>private</span> Object <span class="title function_">readResolve</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> singleton;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 实例二：基于 CAS 实现单例</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * - 优点：</span></span><br><span class=line><span class=comment> *   - 不需要使用传统的锁机制来保证线程安全；</span></span><br><span class=line><span class=comment> *   - 相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度；</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * - 缺点：</span></span><br><span class=line><span class=comment> *   - 如果等待一直执行不成功(一直在死循环中)，会对CPU造成较大的执行开销；</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SingletonByCAS</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>final</span> AtomicReference&LTSingletonByCAS> INSTANCE = <span class=keyword>new</span> <span class="title class_">AtomicReference</span>&LTSingletonByCAS>();</span><br><span class=line>    <span class=keyword>private</span> <span class="title function_">SingletonByCAS</span><span class=params>()</span>{}</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> SingletonByCAS <span class="title function_">getInstance</span><span class=params>()</span>{</span><br><span class=line>        <span class=keyword>for</span> (;;){</span><br><span class=line>            <span class=type>SingletonByCAS</span> <span class=variable>single</span> <span class=operator>=</span> INSTANCE.get();</span><br><span class=line>            <span class=keyword>if</span> (<span class=literal>null</span> != single){</span><br><span class=line>                <span class=keyword>return</span> single;</span><br><span class=line>            }</span><br><span class=line>            single = <span class=keyword>new</span> <span class="title class_">SingletonByCAS</span>();</span><br><span class=line>            <span class=keyword>if</span> (INSTANCE.compareAndSet(<span class=literal>null</span>, single)){</span><br><span class=line>                <span class=keyword>return</span> single;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 实例三：基于 枚举 实现单例</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>enum</span> <span class="title class_">SingletonByEnum</span> {</span><br><span class=line>    INSTANCE;</span><br><span class=line>    <span class=comment>// 其它方法</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 实例四：基于双重校验锁方式实现单例（优化版）</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * - 优点：懒加载，利用局部变量提高效率；</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * - 缺点：反序列化会对单例造成破坏</span></span><br><span class=line><span class=comment> *   应对方案：要想防止序列化对单例的破坏，只要添加readResolve方法就可避免。</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SingletonByLocalVariable</span> <span class=keyword>implements</span> <span class="title class_">Serializable</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>volatile</span> <span class=keyword>static</span> SingletonByLocalVariable singleton;</span><br><span class=line>    <span class=keyword>private</span> <span class="title function_">SingletonByLocalVariable</span><span class=params>()</span>{}</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> SingletonByLocalVariable <span class="title function_">getSingleton</span><span class=params>()</span> {</span><br><span class=line>        <span class=type>SingletonByLocalVariable</span> <span class=variable>tmp</span> <span class=operator>=</span> singleton;</span><br><span class=line>        <span class=keyword>if</span> (tmp == <span class=literal>null</span>) {</span><br><span class=line>            <span class=keyword>synchronized</span> (SingletonByLocalVariable.class) {</span><br><span class=line>                tmp = singleton;</span><br><span class=line>                <span class=keyword>if</span> (tmp == <span class=literal>null</span>) {</span><br><span class=line>                    tmp = <span class=keyword>new</span> <span class="title class_">SingletonByLocalVariable</span>();</span><br><span class=line>                    singleton = tmp;</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> singleton;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>private</span> Object <span class="title function_">readResolve</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> singleton;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 实例五：基于静态内部类实现单例</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * - 原理：利用了classloder的机制来保证初始化instance时只有一个线程。</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * - 优点：这是一种懒加载，也即Singleton类被装载了，但instance不一定被初始化。</span></span><br><span class=line><span class=comment> *        因为SingletonHolder类没有被主动使用，只有显式调用getInstance方法时，</span></span><br><span class=line><span class=comment> *        才会装载SingletonHolder类，进而实例化instance。</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SingletonByStaticInnerClass</span> {</span><br><span class=line>    <span class=comment>// 私有构造，禁止通过new创建对象。</span></span><br><span class=line>    <span class=keyword>private</span> <span class="title function_">SingletonByStaticInnerClass</span><span class=params>()</span>{</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">SingletonHholder</span>{</span><br><span class=line>        <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>final</span> <span class=type>SingletonByStaticInnerClass</span> <span class=variable>INSTANCE</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SingletonByStaticInnerClass</span>();</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>final</span> SingletonByStaticInnerClass <span class="title function_">getInstance</span><span class=params>()</span>{</span><br><span class=line>        <span class=keyword>return</span> SingletonHholder.INSTANCE;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-1-2、FactoryMethod（工厂方法）><a class=headerlink href=#1-1-2、FactoryMethod（工厂方法） title=1.1.2、FactoryMethod（工厂方法）></a>1.1.2、FactoryMethod（工厂方法）</h3><h4 id=简介-1><a class=headerlink href=#简介-1 title=简介></a>简介</h4><p><strong>定义一个用于创建对象的接口，让子类决定实例化哪一个类。该模式将对象的创建延迟到了子类中</strong>。<h4 id=结构><a class=headerlink href=#结构 title=结构></a>结构</h4><ul><li>抽象工厂：声明了工厂方法，但没有实现。<li>具体工厂：实现工厂方法，返回一个具体产品。<li>抽象产品：产品接口。<li>具体产品：实现具体的产品。</ul><h4 id=何时使用-1><a class=headerlink href=#何时使用-1 title=何时使用></a>何时使用</h4><p>需要在不同的条件下创建不同实例，以满足不同的需求。<h4 id=优缺点-1><a class=headerlink href=#优缺点-1 title=优缺点></a>优缺点</h4><ul><li><p>优点</p> <ol><li>将具体产品和创建者解耦。<li>符合单一职责原则。<li>符合开闭原则。</ol><li><p>缺点</p> <p>每增加一个产品时，需要增加一个具体产品类和产品对应的工厂，使得系统中类的个数成倍增加，一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</p></ul><h4 id=使用场景-1><a class=headerlink href=#使用场景-1 title=使用场景></a>使用场景</h4><ol><li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。<li>数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。<li>设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</ol><h4 id=应用实例-1><a class=headerlink href=#应用实例-1 title=应用实例></a>应用实例</h4><ol><li>您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是如何生产出来的。<li>Hibernate 换数据库只需换驱动就可以。</ol><h4 id=源码应用><a class=headerlink href=#源码应用 title=源码应用></a>源码应用</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>Calendar.getInstance();</span><br><span class=line>java.text.NumberFormat.getInstance();</span><br><span class=line>java.util.ResourceBundle.getBundle();</span><br><span class=line></span><br><span class=line>java.net.URLStreamHandlerFactory</span><br><span class=line>java.xml.bind.JAXBContext.createMarshaller</span><br></pre></table></figure><h4 id=注意事项-1><a class=headerlink href=#注意事项-1 title=注意事项></a>注意事项</h4><p><font color=red>在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意：复杂对象适合使用工厂模式，而简单对象不适合。</font><h4 id=代码实例-1><a class=headerlink href=#代码实例-1 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br></pre><td class=code><pre><span class=line><span class=comment>// 抽象产品类</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">Chair</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">sitOn</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体产品类 1</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">ModernChair</span> <span class=keyword>implements</span> <span class="title class_">Chair</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">sitOn</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Sitting on a modern chair."</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体产品类 2</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">VictorianChair</span> <span class=keyword>implements</span> <span class="title class_">Chair</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">sitOn</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Sitting on a victorian chair."</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 抽象工厂类</span></span><br><span class=line><span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">ChairFactory</span> {</span><br><span class=line>    <span class=comment>// 工厂方法</span></span><br><span class=line>    <span class=keyword>abstract</span> Chair <span class="title function_">createChair</span><span class=params>()</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">sit</span><span class=params>()</span> {</span><br><span class=line>        <span class=type>Chair</span> <span class=variable>chair</span> <span class=operator>=</span> createChair();</span><br><span class=line>        chair.sitOn();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体工厂类 1</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">ModernChairFactory</span> <span class=keyword>extends</span> <span class="title class_">ChairFactory</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Chair <span class="title function_">createChair</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">ModernChair</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体工厂类 2</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">VictorianChairFactory</span> <span class=keyword>extends</span> <span class="title class_">ChairFactory</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Chair <span class="title function_">createChair</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">VictorianChair</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=comment>// 创建现代风格椅子的工厂</span></span><br><span class=line>        <span class=type>ChairFactory</span> <span class=variable>modernFactory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ModernChairFactory</span>();</span><br><span class=line>        modernFactory.sit();  <span class=comment>// 输出: Sitting on a modern chair.</span></span><br><span class=line></span><br><span class=line>        <span class=comment>// 创建维多利亚风格椅子的工厂</span></span><br><span class=line>        <span class=type>ChairFactory</span> <span class=variable>victorianFactory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">VictorianChairFactory</span>();</span><br><span class=line>        victorianFactory.sit();  <span class=comment>// 输出: Sitting on a victorian chair.</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-1-3、AbstractFactory（抽象工厂）><a class=headerlink href=#1-1-3、AbstractFactory（抽象工厂） title=1.1.3、AbstractFactory（抽象工厂）></a>1.1.3、AbstractFactory（抽象工厂）</h3><h4 id=定义><a class=headerlink href=#定义 title=定义></a>定义</h4><p>抽象工厂模式提供了一种创建一系列相关或相互依赖对象的接口，而不需要指定它们的具体类。换句话说，它就像是工厂的工厂，用于创建一系列产品（对象）。<h4 id=结构-1><a class=headerlink href=#结构-1 title=结构></a>结构</h4><ul><li>抽象工厂：声明用于创建一组对象的接口。<li>具体工厂：实现接口，返回一组相关的具体产品。<li>抽象产品：每个产品族中的产品都有一个抽象接口。<li>具体产品：实现具体的产品。</ul><h4 id=何时使用-2><a class=headerlink href=#何时使用-2 title=何时使用></a>何时使用</h4><p>系统产品有多于一个的产品族，而系统只消费其中某一族的产品。<h4 id=优缺点-2><a class=headerlink href=#优缺点-2 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>可以实现从工厂得到的产品彼此兼容。<li>可以避免具体产品和客户端代码之间的紧密耦合。<li>符合单一职责原则。<li>符合开闭原则。</ol><li>缺点<ol><li>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体实现中加代码。</ol></ul><h4 id=使用场景-2><a class=headerlink href=#使用场景-2 title=使用场景></a>使用场景</h4><ol><li>QQ 换皮肤，一整套一起换。<li>生成不同操作系统对应的程序。</ol><h4 id=注意事项-2><a class=headerlink href=#注意事项-2 title=注意事项></a>注意事项</h4><p>产品族难扩展，产品等级易扩展。<h4 id=QA><a class=headerlink href=#QA title=QA></a>QA</h4><ol><li><p>为何还需要工厂?</p> <ol><li>灵活控制生产过程。<li>权限、修饰、日志等。</ol></ol><h4 id=代码实例-2><a class=headerlink href=#代码实例-2 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br></pre><td class=code><pre><span class=line><span class=comment>// 抽象产品类 1</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">Chair</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">sitOn</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 抽象产品类 2</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">Table</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">use</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体产品类 1 - 现代风格的椅子</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">ModernChair</span> <span class=keyword>implements</span> <span class="title class_">Chair</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">sitOn</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Sitting on a modern chair."</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体产品类 2 - 现代风格的桌子</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">ModernTable</span> <span class=keyword>implements</span> <span class="title class_">Table</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">use</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Using a modern table."</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体产品类 3 - 维多利亚风格的椅子</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">VictorianChair</span> <span class=keyword>implements</span> <span class="title class_">Chair</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">sitOn</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Sitting on a victorian chair."</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体产品类 4 - 维多利亚风格的桌子</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">VictorianTable</span> <span class=keyword>implements</span> <span class="title class_">Table</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">use</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Using a victorian table."</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 抽象工厂类</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">FurnitureFactory</span> {</span><br><span class=line>    Chair <span class="title function_">createChair</span><span class=params>()</span>;</span><br><span class=line>    Table <span class="title function_">createTable</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体工厂类 1 - 现代风格家具工厂</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">ModernFurnitureFactory</span> <span class=keyword>implements</span> <span class="title class_">FurnitureFactory</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Chair <span class="title function_">createChair</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">ModernChair</span>();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Table <span class="title function_">createTable</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">ModernTable</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体工厂类 2 - 维多利亚风格家具工厂</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">VictorianFurnitureFactory</span> <span class=keyword>implements</span> <span class="title class_">FurnitureFactory</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Chair <span class="title function_">createChair</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">VictorianChair</span>();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Table <span class="title function_">createTable</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">VictorianTable</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=comment>// 创建现代风格的家具工厂</span></span><br><span class=line>        <span class=type>FurnitureFactory</span> <span class=variable>modernFactory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ModernFurnitureFactory</span>();</span><br><span class=line>        <span class=type>Chair</span> <span class=variable>modernChair</span> <span class=operator>=</span> modernFactory.createChair();</span><br><span class=line>        <span class=type>Table</span> <span class=variable>modernTable</span> <span class=operator>=</span> modernFactory.createTable();</span><br><span class=line></span><br><span class=line>        modernChair.sitOn();  <span class=comment>// 输出: Sitting on a modern chair.</span></span><br><span class=line>        modernTable.use();    <span class=comment>// 输出: Using a modern table.</span></span><br><span class=line></span><br><span class=line>        <span class=comment>// 创建维多利亚风格的家具工厂</span></span><br><span class=line>        <span class=type>FurnitureFactory</span> <span class=variable>victorianFactory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">VictorianFurnitureFactory</span>();</span><br><span class=line>        <span class=type>Chair</span> <span class=variable>victorianChair</span> <span class=operator>=</span> victorianFactory.createChair();</span><br><span class=line>        <span class=type>Table</span> <span class=variable>victorianTable</span> <span class=operator>=</span> victorianFactory.createTable();</span><br><span class=line></span><br><span class=line>        victorianChair.sitOn();  <span class=comment>// 输出: Sitting on a victorian chair.</span></span><br><span class=line>        victorianTable.use();    <span class=comment>// 输出: Using a victorian table.</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-1-4、Builder（建造者模式）><a class=headerlink href=#1-1-4、Builder（建造者模式） title=1.1.4、Builder（建造者模式）></a>1.1.4、Builder（建造者模式）</h3><h4 id=简介-2><a class=headerlink href=#简介-2 title=简介></a>简介</h4><p>建造者模式是一种对象创建模式，主要用于构建复杂对象。该模式将复杂对象的创建过程分为多个步骤，并通过使用同一个构建过程，可以创建不同的表示。<h4 id=结构-2><a class=headerlink href=#结构-2 title=结构></a>结构</h4><ul><li>产品类<li>抽象建造者<li>具体建造者<li>指挥者<li>客户端</ul><h4 id=何时使用-3><a class=headerlink href=#何时使用-3 title=何时使用></a>何时使用</h4><p>一些基本部件不会变，而其组合经常变化的时候。<h4 id=优缺点-3><a class=headerlink href=#优缺点-3 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>清晰的创建过程。将复杂对象的创建过程进行分离，使得客户端需要关心具体的创建过程，只需通过接口来构建对象。<li>灵活的产品构建。可以通过不同的具体建造者，来实现相同的构建步骤可以有不同的产品表示。<li>遵循单一职责原则。产品构造和表示是分开的，不同的建造者可以建造不多的产品。<li>代码复用。可以复用建造的步骤，减少重复的代码。</ol><li>缺点<ol><li>产品必须有共同点，范围有限制。<li>内部变化复杂，有很多建造类。</ol></ul><h4 id=使用场景-3><a class=headerlink href=#使用场景-3 title=使用场景></a>使用场景</h4><ol><li>需要构建的对象十分复杂，有许多步骤或部件需要组装。<li>不同的构建方式可能产生不同的对象表示，但构建的步骤或顺序是固定的。<li>希望隐藏对象的构建过程，只暴漏简单的接口。</ol><h4 id=应用实例-2><a class=headerlink href=#应用实例-2 title=应用实例></a>应用实例</h4><ol><li>去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的 “套餐”。<li>JAVA 中的 StringBuilder。</ol><h4 id=源码应用-1><a class=headerlink href=#源码应用-1 title=源码应用></a>源码应用</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>org.springframework.web.service.mvc.method.RequestMappingInfo</span><br><span class=line>org.springframework.benas.factory.support.BeanDefinitionBuilder</span><br></pre></table></figure><h4 id=注意事项-3><a class=headerlink href=#注意事项-3 title=注意事项></a>注意事项</h4><p><font color=red>与工厂模式的区别：建造者模式更加关注零件装配的顺序。</font><h4 id=代码实例-3><a class=headerlink href=#代码实例-3 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br><span class=line>105</span><br><span class=line>106</span><br><span class=line>107</span><br><span class=line>108</span><br><span class=line>109</span><br><span class=line>110</span><br><span class=line>111</span><br><span class=line>112</span><br><span class=line>113</span><br><span class=line>114</span><br><span class=line>115</span><br><span class=line>116</span><br><span class=line>117</span><br><span class=line>118</span><br><span class=line>119</span><br></pre><td class=code><pre><span class=line><span class=comment>// 产品类：汽车</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Car</span> {</span><br><span class=line>    <span class=keyword>private</span> String engine;</span><br><span class=line>    <span class=keyword>private</span> String seats;</span><br><span class=line>    <span class=keyword>private</span> String GPS;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setEngine</span><span class=params>(String engine)</span> {</span><br><span class=line>        <span class=built_in>this</span>.engine = engine;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setSeats</span><span class=params>(String seats)</span> {</span><br><span class=line>        <span class=built_in>this</span>.seats = seats;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setGPS</span><span class=params>(String GPS)</span> {</span><br><span class=line>        <span class=built_in>this</span>.GPS = GPS;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">show</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Car with engine: "</span> + engine + <span class=string>", seats: "</span> + seats + <span class=string>", GPS: "</span> + GPS);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 建造者接口，定义建造产品的步骤</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">CarBuilder</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">buildEngine</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">buildSeats</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">buildGPS</span><span class=params>()</span>;</span><br><span class=line>    Car <span class="title function_">getCar</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体建造者：负责建造一辆具体的汽车</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">SportsCarBuilder</span> <span class=keyword>implements</span> <span class="title class_">CarBuilder</span> {</span><br><span class=line>    <span class=keyword>private</span> Car car;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">SportsCarBuilder</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>this</span>.car = <span class=keyword>new</span> <span class="title class_">Car</span>();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">buildEngine</span><span class=params>()</span> {</span><br><span class=line>        car.setEngine(<span class=string>"V8 Engine"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">buildSeats</span><span class=params>()</span> {</span><br><span class=line>        car.setSeats(<span class=string>"Sports Seats"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">buildGPS</span><span class=params>()</span> {</span><br><span class=line>        car.setGPS(<span class=string>"Advanced GPS"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Car <span class="title function_">getCar</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.car;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=keyword>class</span> <span class="title class_">FamilyCarBuilder</span> <span class=keyword>implements</span> <span class="title class_">CarBuilder</span> {</span><br><span class=line>    <span class=keyword>private</span> Car car;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">FamilyCarBuilder</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>this</span>.car = <span class=keyword>new</span> <span class="title class_">Car</span>();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">buildEngine</span><span class=params>()</span> {</span><br><span class=line>        car.setEngine(<span class=string>"V6 Engine"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">buildSeats</span><span class=params>()</span> {</span><br><span class=line>        car.setSeats(<span class=string>"Comfort Seats"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">buildGPS</span><span class=params>()</span> {</span><br><span class=line>        car.setGPS(<span class=string>"Basic GPS"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Car <span class="title function_">getCar</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.car;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 指挥者类：负责安排建造的顺序</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Director</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">constructSportsCar</span><span class=params>(CarBuilder builder)</span> {</span><br><span class=line>        builder.buildEngine();</span><br><span class=line>        builder.buildSeats();</span><br><span class=line>        builder.buildGPS();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">constructFamilyCar</span><span class=params>(CarBuilder builder)</span> {</span><br><span class=line>        builder.buildEngine();</span><br><span class=line>        builder.buildSeats();</span><br><span class=line>        builder.buildGPS();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>Director</span> <span class=variable>director</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Director</span>();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 构建运动型汽车</span></span><br><span class=line>        <span class=type>CarBuilder</span> <span class=variable>sportsCarBuilder</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SportsCarBuilder</span>();</span><br><span class=line>        director.constructSportsCar(sportsCarBuilder);</span><br><span class=line>        <span class=type>Car</span> <span class=variable>sportsCar</span> <span class=operator>=</span> sportsCarBuilder.getCar();</span><br><span class=line>        sportsCar.show();  <span class=comment>// 输出: Car with engine: V8 Engine, seats: Sports Seats, GPS: Advanced GPS</span></span><br><span class=line></span><br><span class=line>        <span class=comment>// 构建家庭型汽车</span></span><br><span class=line>        <span class=type>CarBuilder</span> <span class=variable>familyCarBuilder</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">FamilyCarBuilder</span>();</span><br><span class=line>        director.constructFamilyCar(familyCarBuilder);</span><br><span class=line>        <span class=type>Car</span> <span class=variable>familyCar</span> <span class=operator>=</span> familyCarBuilder.getCar();</span><br><span class=line>        familyCar.show();  <span class=comment>// 输出: Car with engine: V6 Engine, seats: Comfort Seats, GPS: Basic GPS</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-1-5、Prototype（原型模式）><a class=headerlink href=#1-1-5、Prototype（原型模式） title=1.1.5、Prototype（原型模式）></a>1.1.5、Prototype（原型模式）</h3><h4 id=定义-1><a class=headerlink href=#定义-1 title=定义></a>定义</h4><p>原型模式通过克隆已有对象来获取新对象，而不是通过类的构造器创建对象。该模式提供了一种复制对象的机制，同时可以避免直接使用new关键字来创建实例。<p>相关知识点：Cloneable接口/Object.clone方法；浅拷贝/深拷贝；序列化实现深拷贝。<h4 id=结构-3><a class=headerlink href=#结构-3 title=结构></a>结构</h4><ul><li>Prototype（原型接口）：定义一个接口，用于实现对象的克隆。<li>ConcretePrototype（具体原型类）：实现原型接口的具体类，提供克隆自己的方法。</ul><h4 id=何时使用-4><a class=headerlink href=#何时使用-4 title=何时使用></a>何时使用</h4><ol><li>当一个系统应该独立于它的产品创建，构成和表示时。<li>当要实例化的类是在运行时刻指定时，例如，通过动态装载。<li>为了避免创建一个与产品类层次平行的工厂类层次时。<li>当一个类的实例只能由几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</ol><h4 id=优缺点-4><a class=headerlink href=#优缺点-4 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>性能提高。<li>逃避构造函数的约束。<li>可以不耦合具体类的情况下克隆对象。<li>避免重复的初始化代码。<li>更方便的构建复杂对象。</ol><li>缺点<ol><li>设计克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构时。<li>必须实现 Cloneable 接口。</ol></ul><h4 id=使用场景-4><a class=headerlink href=#使用场景-4 title=使用场景></a>使用场景</h4><ol><li>资源优化场景；<li>类初始化需要消化非常多的资源；<li>性能和安全要求的场景；<li>通过 new 创建对象需要繁杂步骤时；<li>一个对象有多个修改；<li>当多个对象需要对同一对象执行操作时，可以将共享对象拷贝多个来应付每一个调用者对象；<li>实际开发中，原型模式一般和工厂方法一起使用。工厂方法可以将 原型模式拷贝生成的对象提供给调用者；</ol><h4 id=应用实例-3><a class=headerlink href=#应用实例-3 title=应用实例></a>应用实例</h4><ol><li>细胞分裂。<li>JAVA 中的 Object clone() 方法。</ol><h4 id=源码中的应用><a class=headerlink href=#源码中的应用 title=源码中的应用></a>源码中的应用</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>org.springframework.beans.factory.support.AbstracBeanDefinition</span><br><span class=line>java.util.Arrays</span><br></pre></table></figure><h4 id=注意事项-4><a class=headerlink href=#注意事项-4 title=注意事项></a>注意事项</h4><p><font color=red>原型模式是通过拷贝现有对象来生成新对象。浅拷贝实现 Cloneable，重写，深拷贝通过实现 Serializable 读取二进制流。</font><h4 id=代码实例-4><a class=headerlink href=#代码实例-4 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br></pre><td class=code><pre><span class=line><span class=comment>// 原型接口，Java内置的Cloneable接口用于表示对象可克隆</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">Prototype</span> <span class=keyword>extends</span> <span class="title class_">Cloneable</span> {</span><br><span class=line>    Prototype <span class="title function_">clone</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体的原型类，实现克隆方法</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">ConcretePrototype</span> <span class=keyword>implements</span> <span class="title class_">Prototype</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ConcretePrototype</span><span class=params>(String name)</span> {</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 实现克隆方法</span></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Prototype <span class="title function_">clone</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            <span class=keyword>return</span> (Prototype) <span class=built_in>super</span>.clone();  <span class=comment>// 调用Object类的浅拷贝</span></span><br><span class=line>        } <span class=keyword>catch</span> (CloneNotSupportedException e) {</span><br><span class=line>            e.printStackTrace();</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getName</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> name;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setName</span><span class=params>(String name)</span> {</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">toString</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"ConcretePrototype{"</span> +</span><br><span class=line>                <span class=string>"name='"</span> + name + <span class=string>'\''</span> +</span><br><span class=line>                <span class=string>'}'</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=comment>// 创建一个具体原型对象</span></span><br><span class=line>        <span class=type>ConcretePrototype</span> <span class=variable>prototype1</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ConcretePrototype</span>(<span class=string>"Original"</span>);</span><br><span class=line>        System.out.println(<span class=string>"Original: "</span> + prototype1);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 克隆该原型对象</span></span><br><span class=line>        <span class=type>ConcretePrototype</span> <span class=variable>clonedPrototype</span> <span class=operator>=</span> (ConcretePrototype) prototype1.clone();</span><br><span class=line>        clonedPrototype.setName(<span class=string>"Cloned"</span>);</span><br><span class=line>        System.out.println(<span class=string>"Cloned: "</span> + clonedPrototype);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 验证原型对象没有受到影响</span></span><br><span class=line>        System.out.println(<span class=string>"After cloning, Original: "</span> + prototype1);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=1-2、行为型（11种）><a class=headerlink href=#1-2、行为型（11种） title=1.2、行为型（11种）></a>1.2、行为型（11种）</h2><h3 id=1-2-1、Iterator（迭代器模式）><a class=headerlink href=#1-2-1、Iterator（迭代器模式） title=1.2.1、Iterator（迭代器模式）></a>1.2.1、Iterator（迭代器模式）</h3><h4 id=定义-2><a class=headerlink href=#定义-2 title=定义></a>定义</h4><p>迭代器模式用于提供一种顺序访问聚合对象（比如集合、列表、数组）内部元素的方法，而无需暴漏该对象的内部表示。通过迭代器模式，客户端可以遍历容器中的元素，而不需要了解容器的底层实现细节。<h4 id=结构-4><a class=headerlink href=#结构-4 title=结构></a>结构</h4><ul><li>迭代器接口<li>具体迭代器类<li>聚合接口<li>具体聚合类</ul><h4 id=何时使用-5><a class=headerlink href=#何时使用-5 title=何时使用></a>何时使用</h4><p>需要对容器/集合遍历时，可以使用迭代器模式。<h4 id=实现-1><a class=headerlink href=#实现-1 title=实现></a>实现</h4><ul><li>数组实现<li>链表实现</ul><h4 id=优缺点-5><a class=headerlink href=#优缺点-5 title=优缺点></a>优缺点</h4><ul><li><p>优点</p> <ol><li>它支持以不同方式遍历一个聚合对象；<li>迭代器简化了聚合类；<li>在同一聚合上可以有多个遍历；<li>迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码；</ol><li><p>缺点</p> <p>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p></ul><h4 id=使用场景-5><a class=headerlink href=#使用场景-5 title=使用场景></a>使用场景</h4><ol><li>访问一个聚合对象的内部元素而无须暴露其内部表示。<li>需要为聚合对象提供多种遍历方式。<li>为遍历不同的聚合结构提供一个统一的接口。</ol><h4 id=应用实例-4><a class=headerlink href=#应用实例-4 title=应用实例></a>应用实例</h4><p>JAVA 中的 iterator。<h4 id=注意事项-5><a class=headerlink href=#注意事项-5 title=注意事项></a>注意事项</h4><p><font color=red>迭代器模式分离了集合对象的遍历行为，抽象出一个迭代器类，可实现不爆露对象内部就可访问其内部元素；</font><h4 id=代码实例-5><a class=headerlink href=#代码实例-5 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br></pre><td class=code><pre><span class=line><span class=comment>// 迭代器接口</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">Iterator</span>&LTT> {</span><br><span class=line>    <span class=type>boolean</span> <span class="title function_">hasNext</span><span class=params>()</span>;</span><br><span class=line>    T <span class="title function_">next</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 聚合接口</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">Aggregate</span>&LTT> {</span><br><span class=line>    Iterator&LTT> <span class="title function_">createIterator</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体聚合类：自定义集合</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">MyCollection</span>&LTT> <span class=keyword>implements</span> <span class="title class_">Aggregate</span>&LTT> {</span><br><span class=line>    <span class=keyword>private</span> T[] items;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>size</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MyCollection</span><span class=params>(<span class=type>int</span> capacity)</span> {</span><br><span class=line>        items = (T[]) <span class=keyword>new</span> <span class="title class_">Object</span>[capacity];</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">add</span><span class=params>(T item)</span> {</span><br><span class=line>        <span class=keyword>if</span> (size < items.length) {</span><br><span class=line>            items[size++] = item;</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            System.out.println(<span class=string>"集合已满，无法添加更多元素"</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">size</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> size;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> T <span class="title function_">get</span><span class=params>(<span class=type>int</span> index)</span> {</span><br><span class=line>        <span class=keyword>if</span> (index >= <span class=number>0</span> && index < size) {</span><br><span class=line>            <span class=keyword>return</span> items[index];</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Iterator&LTT> <span class="title function_">createIterator</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">MyIterator</span>(<span class=built_in>this</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体迭代器类</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">MyIterator</span>&LTT> <span class=keyword>implements</span> <span class="title class_">Iterator</span>&LTT> {</span><br><span class=line>    <span class=keyword>private</span> MyCollection&LTT> collection;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>index</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MyIterator</span><span class=params>(MyCollection&LTT> collection)</span> {</span><br><span class=line>        <span class=built_in>this</span>.collection = collection;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">hasNext</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> index < collection.size();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> T <span class="title function_">next</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>if</span> (hasNext()) {</span><br><span class=line>            <span class=keyword>return</span> collection.get(index++);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 客户端代码</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">IteratorPatternDemo</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=comment>// 创建自定义集合并添加元素</span></span><br><span class=line>        MyCollection&LTString> myCollection = <span class=keyword>new</span> <span class="title class_">MyCollection</span><>(<span class=number>5</span>);</span><br><span class=line>        myCollection.add(<span class=string>"元素1"</span>);</span><br><span class=line>        myCollection.add(<span class=string>"元素2"</span>);</span><br><span class=line>        myCollection.add(<span class=string>"元素3"</span>);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 获取迭代器</span></span><br><span class=line>        Iterator&LTString> iterator = myCollection.createIterator();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 使用迭代器遍历集合</span></span><br><span class=line>        <span class=keyword>while</span> (iterator.hasNext()) {</span><br><span class=line>            <span class=type>String</span> <span class=variable>item</span> <span class=operator>=</span> iterator.next();</span><br><span class=line>            System.out.println(<span class=string>"访问元素: "</span> + item);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-2、Observer（观察者模式）><a class=headerlink href=#1-2-2、Observer（观察者模式） title=1.2.2、Observer（观察者模式）></a>1.2.2、Observer（观察者模式）</h3><h4 id=定义-3><a class=headerlink href=#定义-3 title=定义></a>定义</h4><p>观察者模式定义了对象间一对多的依赖关系，使得当一个对象的状态发生变化时，其所有依赖于它的对象都会收到通知并自动更新。<h4 id=结构-5><a class=headerlink href=#结构-5 title=结构></a>结构</h4><ul><li>Subject（抽象主题）<li>ConcreteSubject（具体主题）<li>Observer（抽象观察者）<li>ConcreteObserver（具体观察者）</ul><h4 id=何时使用-6><a class=headerlink href=#何时使用-6 title=何时使用></a>何时使用</h4><p>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。<h4 id=优缺点-6><a class=headerlink href=#优缺点-6 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>观察者和被观察者是抽象耦合的。<li>建立一套触发机制。</ol><li>缺点<ol><li>参与者太多 导致 参照者发送通知会消耗很多资源；<li>参与者和参照者中间发生 循坏依赖可能导致系统崩溃。<li>参与者只知道参照者发生了变化，而如何变化却不知道；</ol></ul><h4 id=使用场景-6><a class=headerlink href=#使用场景-6 title=使用场景></a>使用场景</h4><ol><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。<li>一个对象必须通知其他对象，而并不知道这些对象是谁。<li>需要在系统中创建一个触发链，A 对象的行为将影响 B 对象，B 对象的行为将影响 C 对象……，可以使用观察者模式创建一种链式触发机制。</ol><h4 id=应用实例-5><a class=headerlink href=#应用实例-5 title=应用实例></a>应用实例</h4><ol><li>拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。<li>西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</ol><h4 id=源码应用-2><a class=headerlink href=#源码应用-2 title=源码应用></a>源码应用</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>java.util.Observable</span><br><span class=line>org.springframework.context.ApplicationListener</span><br></pre></table></figure><h4 id=注意事项-6><a class=headerlink href=#注意事项-6 title=注意事项></a>注意事项</h4><ol><li><font color=red>JAVA 中存在相关支持类；</font><li><font color=red>应该避免循环引用；</font><li><font color=red>顺序执行将导致某一观察者错误进而导致系统卡壳，故一般采用异步方式；</font></ol><h4 id=代码实例-6><a class=headerlink href=#代码实例-6 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br></pre><td class=code><pre><span class=line><span class=comment>// 抽象主题</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">Subject</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">registerObserver</span><span class=params>(Observer o)</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">removeObserver</span><span class=params>(Observer o)</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">notifyObservers</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体主题</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">WeatherData</span> <span class=keyword>implements</span> <span class="title class_">Subject</span> {</span><br><span class=line>    <span class=keyword>private</span> List&LTObserver> observers;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>float</span> temperature;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">WeatherData</span><span class=params>()</span> {</span><br><span class=line>        observers = <span class=keyword>new</span> <span class="title class_">ArrayList</span><>();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">registerObserver</span><span class=params>(Observer o)</span> {</span><br><span class=line>        observers.add(o);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">removeObserver</span><span class=params>(Observer o)</span> {</span><br><span class=line>        observers.remove(o);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">notifyObservers</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>for</span> (Observer observer : observers) {</span><br><span class=line>            observer.update(temperature);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setTemperature</span><span class=params>(<span class=type>float</span> temperature)</span> {</span><br><span class=line>        <span class=built_in>this</span>.temperature = temperature;</span><br><span class=line>        notifyObservers();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 抽象观察者</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">Observer</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">update</span><span class=params>(<span class=type>float</span> temperature)</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体观察者</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">CurrentConditionsDisplay</span> <span class=keyword>implements</span> <span class="title class_">Observer</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>float</span> temperature;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">update</span><span class=params>(<span class=type>float</span> temperature)</span> {</span><br><span class=line>        <span class=built_in>this</span>.temperature = temperature;</span><br><span class=line>        display();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">display</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Current temperature: "</span> + temperature);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 使用</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">WeatherStation</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>WeatherData</span> <span class=variable>weatherData</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">WeatherData</span>();</span><br><span class=line>        <span class=type>CurrentConditionsDisplay</span> <span class=variable>currentDisplay</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">CurrentConditionsDisplay</span>();</span><br><span class=line></span><br><span class=line>        weatherData.registerObserver(currentDisplay);</span><br><span class=line>        weatherData.setTemperature(<span class=number>25.3f</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-3、TemplateMethod（模板方法）><a class=headerlink href=#1-2-3、TemplateMethod（模板方法） title=1.2.3、TemplateMethod（模板方法）></a>1.2.3、TemplateMethod（模板方法）</h3><h4 id=定义-4><a class=headerlink href=#定义-4 title=定义></a>定义</h4><p>模板方法模式定义了一个算法的骨架，将算法中的某些步骤推迟到子类中去实现。通过模板方法模式，子类可以在不改变算法结构的前提下重新定义算法的某些特定步骤。<h4 id=结构-6><a class=headerlink href=#结构-6 title=结构></a>结构</h4><ul><li>抽象类<li>具体类</ul><h4 id=何时使用-7><a class=headerlink href=#何时使用-7 title=何时使用></a>何时使用</h4><p>系统中存在一部分通用方法。<h4 id=优缺点-7><a class=headerlink href=#优缺点-7 title=优缺点></a>优缺点</h4><ul><li><p>优点</p> <ol><li>封装不变部分，扩展可变部分。<li>提取公共代码，便于维护。<li>行为由父类控制，子类实现。</ol><li><p>缺点</p> <p>每一个不同的实现都需要一个子类来实现，类的数量增加导致系统愈加庞大。</p></ul><h4 id=使用场景-7><a class=headerlink href=#使用场景-7 title=使用场景></a>使用场景</h4><ol><li>有多个子类共有的方法，且逻辑相同。<li>重要的、复杂的方法，可以考虑作为模板方法。</ol><h4 id=应用实例-6><a class=headerlink href=#应用实例-6 title=应用实例></a>应用实例</h4><ol><li>在造房子的时候，地基、走线、水管都一样，只有后期加壁橱加栅栏等差异。<li>西游记中的 81 难，就是一个顶层逻辑骨架。<li>spring 对 Hibernate 的支持，将一些规定好的方法封装起来，编程人员直接使用即可。</ol><h4 id=注意事项-7><a class=headerlink href=#注意事项-7 title=注意事项></a>注意事项</h4><p><font color=red>为防止恶意操作，模板方法一般会使用 final 修饰。</font><h4 id=代码实例-7><a class=headerlink href=#代码实例-7 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br></pre><td class=code><pre><span class=line><span class=comment>// 抽象类，定义算法骨架</span></span><br><span class=line><span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">Game</span> {</span><br><span class=line>    <span class=comment>// 模板方法，定义了游戏的流程</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>void</span> <span class="title function_">play</span><span class=params>()</span> {</span><br><span class=line>        initialize();</span><br><span class=line>        startPlay();</span><br><span class=line>        endPlay();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 具体步骤，子类可能不需要重写</span></span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">initialize</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Game initialized."</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 抽象方法，子类必须实现</span></span><br><span class=line>    <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">startPlay</span><span class=params>()</span>;</span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 抽象方法，子类必须实现</span></span><br><span class=line>    <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">endPlay</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体类，继承抽象类并实现抽象方法</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Football</span> <span class=keyword>extends</span> <span class="title class_">Game</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">startPlay</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Football Game Started. Enjoy the game!"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">endPlay</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Football Game Finished."</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Basketball</span> <span class=keyword>extends</span> <span class="title class_">Game</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">startPlay</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Basketball Game Started. Enjoy the game!"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">endPlay</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Basketball Game Finished."</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 客户端代码</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">TemplateMethodPatternDemo</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>Game</span> <span class=variable>game</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Football</span>();</span><br><span class=line>        game.play(); <span class=comment>// 执行的是模板方法</span></span><br><span class=line>        </span><br><span class=line>        System.out.println();</span><br><span class=line>        </span><br><span class=line>        game = <span class=keyword>new</span> <span class="title class_">Basketball</span>();</span><br><span class=line>        game.play();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-4、Strategy（策略模式）><a class=headerlink href=#1-2-4、Strategy（策略模式） title=1.2.4、Strategy（策略模式）></a>1.2.4、Strategy（策略模式）</h3><h4 id=定义-5><a class=headerlink href=#定义-5 title=定义></a>定义</h4><p>策略模式定义了一系列算法，并将每个算法封装起来，使得它们可以互相替换。策略模式使得算法可以独立于使用它的客户端而变化。<h4 id=结构-7><a class=headerlink href=#结构-7 title=结构></a>结构</h4><ul><li>策略接口<li>具体策略类<li>上下文类</ul><h4 id=何时使用-8><a class=headerlink href=#何时使用-8 title=何时使用></a>何时使用</h4><p>一个系统有许多类，而区分它们的只是他们直接的行为。<h4 id=优缺点-8><a class=headerlink href=#优缺点-8 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>算法可以自由切换。<li>避免使用多重条件判断。<li>扩展性良好。</ol><li>缺点<ol><li>策略类会增多。<li>所有策略类都需要对外暴露。</ol></ul><h4 id=使用场景-8><a class=headerlink href=#使用场景-8 title=使用场景></a>使用场景</h4><ol><li>一个系统中的许多类只存在行为上的区别时，该模式可以动态让一个对象在许多行为中选择一种行为。<li>一个系统需要动态地在几种算法中选择一种。<li>如果一个对象有很多行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</ol><h4 id=应用实例-7><a class=headerlink href=#应用实例-7 title=应用实例></a>应用实例</h4><ol><li>诸葛亮的锦囊妙计，每一个锦囊就是一个策略。<li>旅行的交通方式可以选择骑自行车、开汽车等，每一种旅行方式都是一个策略。<li>JAVA AWT 中的 LayoutManager。</ol><h4 id=注意事项-8><a class=headerlink href=#注意事项-8 title=注意事项></a>注意事项</h4><p><font color=red>如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</font>、<h4 id=代码实例-8><a class=headerlink href=#代码实例-8 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br></pre><td class=code><pre><span class=line><span class=comment>// 策略接口，定义算法的公共方法</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">Strategy</span> {</span><br><span class=line>    <span class=type>int</span> <span class="title function_">doOperation</span><span class=params>(<span class=type>int</span> num1, <span class=type>int</span> num2)</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体策略类1：加法策略</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">OperationAdd</span> <span class=keyword>implements</span> <span class="title class_">Strategy</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">doOperation</span><span class=params>(<span class=type>int</span> num1, <span class=type>int</span> num2)</span> {</span><br><span class=line>        <span class=keyword>return</span> num1 + num2;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体策略类2：减法策略</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">OperationSubtract</span> <span class=keyword>implements</span> <span class="title class_">Strategy</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">doOperation</span><span class=params>(<span class=type>int</span> num1, <span class=type>int</span> num2)</span> {</span><br><span class=line>        <span class=keyword>return</span> num1 - num2;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体策略类3：乘法策略</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">OperationMultiply</span> <span class=keyword>implements</span> <span class="title class_">Strategy</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">doOperation</span><span class=params>(<span class=type>int</span> num1, <span class=type>int</span> num2)</span> {</span><br><span class=line>        <span class=keyword>return</span> num1 * num2;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 上下文类，持有策略的引用</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Context</span> {</span><br><span class=line>    <span class=keyword>private</span> Strategy strategy;</span><br><span class=line></span><br><span class=line>    <span class=comment>// 可以通过构造函数或setter方法设置具体策略</span></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Context</span><span class=params>(Strategy strategy)</span> {</span><br><span class=line>        <span class=built_in>this</span>.strategy = strategy;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setStrategy</span><span class=params>(Strategy strategy)</span> {</span><br><span class=line>        <span class=built_in>this</span>.strategy = strategy;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 调用策略的方法</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">executeStrategy</span><span class=params>(<span class=type>int</span> num1, <span class=type>int</span> num2)</span> {</span><br><span class=line>        <span class=keyword>return</span> strategy.doOperation(num1, num2);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 客户端代码</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">StrategyPatternDemo</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=comment>// 使用加法策略</span></span><br><span class=line>        <span class=type>Context</span> <span class=variable>context</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Context</span>(<span class=keyword>new</span> <span class="title class_">OperationAdd</span>());</span><br><span class=line>        System.out.println(<span class=string>"10 + 5 = "</span> + context.executeStrategy(<span class=number>10</span>, <span class=number>5</span>));</span><br><span class=line></span><br><span class=line>        <span class=comment>// 动态切换为减法策略</span></span><br><span class=line>        context.setStrategy(<span class=keyword>new</span> <span class="title class_">OperationSubtract</span>());</span><br><span class=line>        System.out.println(<span class=string>"10 - 5 = "</span> + context.executeStrategy(<span class=number>10</span>, <span class=number>5</span>));</span><br><span class=line></span><br><span class=line>        <span class=comment>// 动态切换为乘法策略</span></span><br><span class=line>        context.setStrategy(<span class=keyword>new</span> <span class="title class_">OperationMultiply</span>());</span><br><span class=line>        System.out.println(<span class=string>"10 * 5 = "</span> + context.executeStrategy(<span class=number>10</span>, <span class=number>5</span>));</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-5、ChainOfResponsibility（职责链模式）><a class=headerlink href=#1-2-5、ChainOfResponsibility（职责链模式） title=1.2.5、ChainOfResponsibility（职责链模式）></a>1.2.5、ChainOfResponsibility（职责链模式）</h3><h4 id=定义-6><a class=headerlink href=#定义-6 title=定义></a>定义</h4><p>职责链模式通过将请求沿着一个“职责链”传递，链上的每个对象都可以对请求进行处理或将其传递给下一个对象。职责链模式的目的是将请求的发送者与接收者解耦，让多个对象都有机会处理这个请求，而不是明确指定具体的处理对象。<h4 id=结构-8><a class=headerlink href=#结构-8 title=结构></a>结构</h4><ul><li>抽象处理者<li>具体处理者<li>客户端</ul><h4 id=何时使用-9><a class=headerlink href=#何时使用-9 title=何时使用></a>何时使用</h4><p>过滤消息中各种不雅内容；<h4 id=优缺点-9><a class=headerlink href=#优缺点-9 title=优缺点></a>优缺点</h4><ol><li>请求的发送者和接收者解耦。<li>可以执行控制顺序。<li>符合开闭原则和单一职责原则。</ol><h4 id=使用场景-9><a class=headerlink href=#使用场景-9 title=使用场景></a>使用场景</h4><ol><li>多个对象都能处理同一个请求，具体由哪个对象处理该请求则在运行时自动确定。<li>在不明确指定接收者的情况下，向多个对象中的某个对象发送一个请求。<li>动态指定一组对象处理请求的场景。</ol><h4 id=应用实例-8><a class=headerlink href=#应用实例-8 title=应用实例></a>应用实例</h4><ol><li>红楼梦中的 “击鼓传花”。<li>JS 中的事件冒泡。<li>JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</ol><h4 id=源码应用-3><a class=headerlink href=#源码应用-3 title=源码应用></a>源码应用</h4><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>javax.servlet.Filter</span><br><span class=line>javax.servlet.FilterChain</span><br></pre></table></figure><h4 id=注意事项-9><a class=headerlink href=#注意事项-9 title=注意事项></a>注意事项</h4><p><font color=red>JAVA WEB 中有很多应用。</font><h4 id=代码实例-9><a class=headerlink href=#代码实例-9 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br></pre><td class=code><pre><span class=line><span class=comment>// 抽象处理者，定义处理请求的接口</span></span><br><span class=line><span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">Handler</span> {</span><br><span class=line>    <span class=keyword>protected</span> Handler nextHandler; <span class=comment>// 下一个处理者</span></span><br><span class=line></span><br><span class=line>    <span class=comment>// 设置下一个处理者</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setNextHandler</span><span class=params>(Handler nextHandler)</span> {</span><br><span class=line>        <span class=built_in>this</span>.nextHandler = nextHandler;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 处理请求的抽象方法</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">handleRequest</span><span class=params>(<span class=type>int</span> request)</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体处理者1：处理小于10的请求</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">ConcreteHandler1</span> <span class=keyword>extends</span> <span class="title class_">Handler</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">handleRequest</span><span class=params>(<span class=type>int</span> request)</span> {</span><br><span class=line>        <span class=keyword>if</span> (request < <span class=number>10</span>) {</span><br><span class=line>            System.out.println(<span class=string>"Handler1处理请求："</span> + request);</span><br><span class=line>        } <span class=keyword>else</span> <span class=keyword>if</span> (nextHandler != <span class=literal>null</span>) {</span><br><span class=line>            nextHandler.handleRequest(request); <span class=comment>// 转交给下一个处理者</span></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体处理者2：处理10到20之间的请求</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">ConcreteHandler2</span> <span class=keyword>extends</span> <span class="title class_">Handler</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">handleRequest</span><span class=params>(<span class=type>int</span> request)</span> {</span><br><span class=line>        <span class=keyword>if</span> (request >= <span class=number>10</span> && request < <span class=number>20</span>) {</span><br><span class=line>            System.out.println(<span class=string>"Handler2处理请求："</span> + request);</span><br><span class=line>        } <span class=keyword>else</span> <span class=keyword>if</span> (nextHandler != <span class=literal>null</span>) {</span><br><span class=line>            nextHandler.handleRequest(request); <span class=comment>// 转交给下一个处理者</span></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体处理者3：处理大于等于20的请求</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">ConcreteHandler3</span> <span class=keyword>extends</span> <span class="title class_">Handler</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">handleRequest</span><span class=params>(<span class=type>int</span> request)</span> {</span><br><span class=line>        <span class=keyword>if</span> (request >= <span class=number>20</span>) {</span><br><span class=line>            System.out.println(<span class=string>"Handler3处理请求："</span> + request);</span><br><span class=line>        } <span class=keyword>else</span> <span class=keyword>if</span> (nextHandler != <span class=literal>null</span>) {</span><br><span class=line>            nextHandler.handleRequest(request); <span class=comment>// 转交给下一个处理者</span></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 客户端代码</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ChainOfResponsibilityPatternDemo</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=comment>// 创建处理者</span></span><br><span class=line>        <span class=type>Handler</span> <span class=variable>handler1</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ConcreteHandler1</span>();</span><br><span class=line>        <span class=type>Handler</span> <span class=variable>handler2</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ConcreteHandler2</span>();</span><br><span class=line>        <span class=type>Handler</span> <span class=variable>handler3</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ConcreteHandler3</span>();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 设置处理链</span></span><br><span class=line>        handler1.setNextHandler(handler2);</span><br><span class=line>        handler2.setNextHandler(handler3);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 向链中的第一个处理者发出请求</span></span><br><span class=line>        <span class=type>int</span>[] requests = {<span class=number>5</span>, <span class=number>12</span>, <span class=number>25</span>, <span class=number>18</span>};</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> request : requests) {</span><br><span class=line>            handler1.handleRequest(request); <span class=comment>// 始终从第一个处理者开始</span></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-6、Mediator（中介者模式）><a class=headerlink href=#1-2-6、Mediator（中介者模式） title=1.2.6、Mediator（中介者模式）></a>1.2.6、Mediator（中介者模式）</h3><h4 id=定义-7><a class=headerlink href=#定义-7 title=定义></a>定义</h4><p>中介者模式通过一个 中介者对象 来封装对象之间的交互，使得对象不再需要显式地相互引用，减少对象之间的耦合，便于系统的扩展和维护。中介者模式的核心是引入一个中介者来协调多个对象之间的通信，而不是让对象直接交互。<h4 id=结构-9><a class=headerlink href=#结构-9 title=结构></a>结构</h4><ul><li>抽象中介者<li>具体中介者<li>抽象同事类<li>具体同事类</ul><h4 id=何时使用-10><a class=headerlink href=#何时使用-10 title=何时使用></a>何时使用</h4><p>多个类相互耦合，形成了网状结构。<h4 id=优缺点-10><a class=headerlink href=#优缺点-10 title=优缺点></a>优缺点</h4><ul><li><p>优点</p> <ol><li>降低了类的复杂度，将一对多转化成了一对一。<li>实现了类之间的解耦。<li>符合迪米特原则。</ol><li><p>缺点</p> <p>中介者会庞大，变得复杂难以维护。</p></ul><h4 id=使用场景-10><a class=headerlink href=#使用场景-10 title=使用场景></a>使用场景</h4><ol><li>对象间存在复杂引用关系，内部结构复杂难以使用；<li>通过一个中间类来封装多个类中的行为，而又不想生成太多的子类；</ol><h4 id=应用实例-9><a class=headerlink href=#应用实例-9 title=应用实例></a>应用实例</h4><ol><li>中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。<li>机场调度系统。<li>MVC 框架中 C（控制器）就是 M（模型）和 V（视图）的中介者。</ol><h4 id=注意事项-10><a class=headerlink href=#注意事项-10 title=注意事项></a>注意事项</h4><p><font color=red>不应当在职责混乱时使用。</font><h4 id=代码实例-10><a class=headerlink href=#代码实例-10 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br></pre><td class=code><pre><span class=line><span class=comment>// 抽象中介者</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">Mediator</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">sendMessage</span><span class=params>(String message, Colleague colleague)</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 抽象同事类</span></span><br><span class=line><span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">Colleague</span> {</span><br><span class=line>    <span class=keyword>protected</span> Mediator mediator;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Colleague</span><span class=params>(Mediator mediator)</span> {</span><br><span class=line>        <span class=built_in>this</span>.mediator = mediator;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 向中介者发送消息</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">send</span><span class=params>(String message)</span>;</span><br><span class=line></span><br><span class=line>    <span class=comment>// 接收消息</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">receive</span><span class=params>(String message)</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体同事类1</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">ConcreteColleague1</span> <span class=keyword>extends</span> <span class="title class_">Colleague</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ConcreteColleague1</span><span class=params>(Mediator mediator)</span> {</span><br><span class=line>        <span class=built_in>super</span>(mediator);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">send</span><span class=params>(String message)</span> {</span><br><span class=line>        System.out.println(<span class=string>"同事1发送消息："</span> + message);</span><br><span class=line>        mediator.sendMessage(message, <span class=built_in>this</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">receive</span><span class=params>(String message)</span> {</span><br><span class=line>        System.out.println(<span class=string>"同事1接收到消息："</span> + message);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体同事类2</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">ConcreteColleague2</span> <span class=keyword>extends</span> <span class="title class_">Colleague</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ConcreteColleague2</span><span class=params>(Mediator mediator)</span> {</span><br><span class=line>        <span class=built_in>super</span>(mediator);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">send</span><span class=params>(String message)</span> {</span><br><span class=line>        System.out.println(<span class=string>"同事2发送消息："</span> + message);</span><br><span class=line>        mediator.sendMessage(message, <span class=built_in>this</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">receive</span><span class=params>(String message)</span> {</span><br><span class=line>        System.out.println(<span class=string>"同事2接收到消息："</span> + message);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体中介者</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">ConcreteMediator</span> <span class=keyword>implements</span> <span class="title class_">Mediator</span> {</span><br><span class=line>    <span class=keyword>private</span> ConcreteColleague1 colleague1;</span><br><span class=line>    <span class=keyword>private</span> ConcreteColleague2 colleague2;</span><br><span class=line></span><br><span class=line>    <span class=comment>// 注册同事对象</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setColleague1</span><span class=params>(ConcreteColleague1 colleague1)</span> {</span><br><span class=line>        <span class=built_in>this</span>.colleague1 = colleague1;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setColleague2</span><span class=params>(ConcreteColleague2 colleague2)</span> {</span><br><span class=line>        <span class=built_in>this</span>.colleague2 = colleague2;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">sendMessage</span><span class=params>(String message, Colleague colleague)</span> {</span><br><span class=line>        <span class=keyword>if</span> (colleague == colleague1) {</span><br><span class=line>            colleague2.receive(message);</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            colleague1.receive(message);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 客户端代码</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MediatorPatternDemo</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>ConcreteMediator</span> <span class=variable>mediator</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ConcreteMediator</span>();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 创建同事对象并注册到中介者</span></span><br><span class=line>        <span class=type>ConcreteColleague1</span> <span class=variable>colleague1</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ConcreteColleague1</span>(mediator);</span><br><span class=line>        <span class=type>ConcreteColleague2</span> <span class=variable>colleague2</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ConcreteColleague2</span>(mediator);</span><br><span class=line></span><br><span class=line>        mediator.setColleague1(colleague1);</span><br><span class=line>        mediator.setColleague2(colleague2);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 同事1发送消息，通过中介者传递给同事2</span></span><br><span class=line>        colleague1.send(<span class=string>"你好，2号！"</span>);</span><br><span class=line>        <span class=comment>// 同事2发送消息，通过中介者传递给同事1</span></span><br><span class=line>        colleague2.send(<span class=string>"你好，1号！"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-7、Interpreter（解释器模式）><a class=headerlink href=#1-2-7、Interpreter（解释器模式） title=1.2.7、Interpreter（解释器模式）></a>1.2.7、Interpreter（解释器模式）</h3><h4 id=定义-8><a class=headerlink href=#定义-8 title=定义></a>定义</h4><p>解释器模式提供了解析和执行语言的语法或表达式的方式。解释器模式用于定义一个语言的文法，并建立一个解释器来解释该语言中的句子或表达式。<h4 id=结构-10><a class=headerlink href=#结构-10 title=结构></a>结构</h4><ul><li>抽象表达式<li>终结符表达式<li>非终结符表达式<li>上下文<li>客户端</ul><h4 id=何时使用-11><a class=headerlink href=#何时使用-11 title=何时使用></a>何时使用</h4><p>某一个类型的问题发送频率特高，可以将该类型问题的各实例封装成一个简单描述，然后通过解释器来解释处理该描述。<h4 id=优缺点-11><a class=headerlink href=#优缺点-11 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>可扩展性比较好，灵活。<li>增加了新的解释表达式的方式。<li>易于实现简单文法。</ol><li>缺点<ol><li>可利用场景比较少。<li>对于复杂的文法比较难维护。<li>解释器模式会引起类膨胀。<li>解释器模式采用递归调用方法。</ol></ul><h4 id=使用场景-11><a class=headerlink href=#使用场景-11 title=使用场景></a>使用场景</h4><ol><li>将一个解释执行语言中的句子表示为一个抽象语法树。<li>重复出现的问题可以用一种简单的语言来进行表达。<li>简单语法需要解释的场景。</ol><h4 id=应用实例-10><a class=headerlink href=#应用实例-10 title=应用实例></a>应用实例</h4><p>编译器、运算表达式计算。<h4 id=注意事项-11><a class=headerlink href=#注意事项-11 title=注意事项></a>注意事项</h4><p><font color=red>可利用场景比较少，JAVA 中可以用 expression4J 代替。</font><h4 id=代码实例-11><a class=headerlink href=#代码实例-11 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br></pre><td class=code><pre><span class=line><span class=comment>// 抽象表达式接口</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">Expression</span> {</span><br><span class=line>    <span class=type>int</span> <span class="title function_">interpret</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 终结符表达式：常量表达式</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">NumberExpression</span> <span class=keyword>implements</span> <span class="title class_">Expression</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> number;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">NumberExpression</span><span class=params>(<span class=type>int</span> number)</span> {</span><br><span class=line>        <span class=built_in>this</span>.number = number;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">interpret</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.number;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 非终结符表达式：加法表达式</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">AddExpression</span> <span class=keyword>implements</span> <span class="title class_">Expression</span> {</span><br><span class=line>    <span class=keyword>private</span> Expression leftExpression;</span><br><span class=line>    <span class=keyword>private</span> Expression rightExpression;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AddExpression</span><span class=params>(Expression leftExpression, Expression rightExpression)</span> {</span><br><span class=line>        <span class=built_in>this</span>.leftExpression = leftExpression;</span><br><span class=line>        <span class=built_in>this</span>.rightExpression = rightExpression;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">interpret</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> leftExpression.interpret() + rightExpression.interpret();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 非终结符表达式：减法表达式</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">SubtractExpression</span> <span class=keyword>implements</span> <span class="title class_">Expression</span> {</span><br><span class=line>    <span class=keyword>private</span> Expression leftExpression;</span><br><span class=line>    <span class=keyword>private</span> Expression rightExpression;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">SubtractExpression</span><span class=params>(Expression leftExpression, Expression rightExpression)</span> {</span><br><span class=line>        <span class=built_in>this</span>.leftExpression = leftExpression;</span><br><span class=line>        <span class=built_in>this</span>.rightExpression = rightExpression;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">interpret</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> leftExpression.interpret() - rightExpression.interpret();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 客户端代码</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">InterpreterPatternDemo</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=comment>// 构造一个加法表达式： (10 + (5 - 2))</span></span><br><span class=line>        <span class=type>Expression</span> <span class=variable>expression</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AddExpression</span>(</span><br><span class=line>            <span class=keyword>new</span> <span class="title class_">NumberExpression</span>(<span class=number>10</span>), </span><br><span class=line>            <span class=keyword>new</span> <span class="title class_">SubtractExpression</span>(<span class=keyword>new</span> <span class="title class_">NumberExpression</span>(<span class=number>5</span>), <span class=keyword>new</span> <span class="title class_">NumberExpression</span>(<span class=number>2</span>))</span><br><span class=line>        );</span><br><span class=line></span><br><span class=line>        <span class=comment>// 解释并求值</span></span><br><span class=line>        System.out.println(<span class=string>"结果："</span> + expression.interpret());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-8、Command（命令模式）><a class=headerlink href=#1-2-8、Command（命令模式） title=1.2.8、Command（命令模式）></a>1.2.8、Command（命令模式）</h3><h4 id=定义-9><a class=headerlink href=#定义-9 title=定义></a>定义</h4><p>命令模式会将请求封装为一个对象，以实现可以用不同的请求对客户进行参数化、请求排队、记录日志以及支持可撤销操作。命令模式的核心思想是将请求和接收者进行解耦，形成一种调用者和执行者之间的松耦合结构。<h4 id=结构-11><a class=headerlink href=#结构-11 title=结构></a>结构</h4><ul><li>命令接口<li>具体命令类<li>接收者<li>调用者<li>客户端</ul><h4 id=何时使用-12><a class=headerlink href=#何时使用-12 title=何时使用></a>何时使用</h4><p>在某些场合，比如要对行为进行 “记录、撤销 / 重做、事务” 等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将 “行为请求者” 与 “行为实现者” 解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。<h4 id=优缺点-12><a class=headerlink href=#优缺点-12 title=优缺点></a>优缺点</h4><ul><li><p>优点</p> <ol><li>降低了系统耦合度。<li>新命令可以很容易添加到系统中去。</ol><li><p>缺点</p> <p>可能会导致某些系统有过多的具体命令类。</p></ul><h4 id=使用场景-12><a class=headerlink href=#使用场景-12 title=使用场景></a>使用场景</h4><ol><li>GUI 中每一个按钮都是一条命令。<li>模拟 CMD。</ol><h4 id=应用实例-11><a class=headerlink href=#应用实例-11 title=应用实例></a>应用实例</h4><p>struts 1 中 action 的核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层也会有对应不同的模型类，相当于具体的 Command。<h4 id=注意事项-12><a class=headerlink href=#注意事项-12 title=注意事项></a>注意事项</h4><p><font color=red>需要支持命令的撤销 (Undo) 操作和恢复 (Redo) 操作。</font><h4 id=代码实例-12><a class=headerlink href=#代码实例-12 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br></pre><td class=code><pre><span class=line><span class=comment>// 命令接口</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">Command</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">execute</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 接收者：灯</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Light</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">turnOn</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"灯打开了"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">turnOff</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"灯关闭了"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体命令：打开灯命令</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">TurnOnLightCommand</span> <span class=keyword>implements</span> <span class="title class_">Command</span> {</span><br><span class=line>    <span class=keyword>private</span> Light light;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">TurnOnLightCommand</span><span class=params>(Light light)</span> {</span><br><span class=line>        <span class=built_in>this</span>.light = light;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">execute</span><span class=params>()</span> {</span><br><span class=line>        light.turnOn();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体命令：关闭灯命令</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">TurnOffLightCommand</span> <span class=keyword>implements</span> <span class="title class_">Command</span> {</span><br><span class=line>    <span class=keyword>private</span> Light light;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">TurnOffLightCommand</span><span class=params>(Light light)</span> {</span><br><span class=line>        <span class=built_in>this</span>.light = light;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">execute</span><span class=params>()</span> {</span><br><span class=line>        light.turnOff();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 调用者：遥控器</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">RemoteControl</span> {</span><br><span class=line>    <span class=keyword>private</span> Command command;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setCommand</span><span class=params>(Command command)</span> {</span><br><span class=line>        <span class=built_in>this</span>.command = command;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">pressButton</span><span class=params>()</span> {</span><br><span class=line>        command.execute();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 客户端代码</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CommandPatternDemo</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=comment>// 创建接收者对象</span></span><br><span class=line>        <span class=type>Light</span> <span class=variable>livingRoomLight</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Light</span>();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 创建具体命令</span></span><br><span class=line>        <span class=type>Command</span> <span class=variable>turnOnCommand</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TurnOnLightCommand</span>(livingRoomLight);</span><br><span class=line>        <span class=type>Command</span> <span class=variable>turnOffCommand</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TurnOffLightCommand</span>(livingRoomLight);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 创建调用者（遥控器）</span></span><br><span class=line>        <span class=type>RemoteControl</span> <span class=variable>remote</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">RemoteControl</span>();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 打开灯</span></span><br><span class=line>        remote.setCommand(turnOnCommand);</span><br><span class=line>        remote.pressButton();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 关闭灯</span></span><br><span class=line>        remote.setCommand(turnOffCommand);</span><br><span class=line>        remote.pressButton();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-9、State（状态模式）><a class=headerlink href=#1-2-9、State（状态模式） title=1.2.9、State（状态模式）></a>1.2.9、State（状态模式）</h3><h4 id=定义-10><a class=headerlink href=#定义-10 title=定义></a>定义</h4><p>状态模式允许一个对象在内部状态发生改变时，改变它的行为。通过将状态封装为独立的类，状态模式使得对象的行为和状态之间的依赖关系得到解耦，从而使得状态转换更为灵活和清晰。<h4 id=结构-12><a class=headerlink href=#结构-12 title=结构></a>结构</h4><ul><li>上下文<li>状态接口<li>具体状态类</ul><h4 id=何时使用-13><a class=headerlink href=#何时使用-13 title=何时使用></a>何时使用</h4><p>代码中包含大量与对象状态有关的条件语句。<h4 id=优缺点-13><a class=headerlink href=#优缺点-13 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>封装了转换规则。<li>枚举可能的状态，在枚举状态之前需要确定状态种类。<li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。<li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。<li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</ol><li>缺点<ol><li>状态模式的使用必然会增加系统类和对象的个数。<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。<li>状态模式对 “开闭原则” 的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</ol></ul><h4 id=使用场景-13><a class=headerlink href=#使用场景-13 title=使用场景></a>使用场景</h4><ol><li>行为随状态改变而改变的场景。<li>条件、分支语句的代替者。</ol><h4 id=应用实例-12><a class=headerlink href=#应用实例-12 title=应用实例></a>应用实例</h4><ol><li>打篮球的时候运动员可以有正常状态. 不正常状态和超常状态。<li>‘曾侯乙编钟’是具体环境(Context)，钟是抽象接口，钟 A是具体状态。</ol><h4 id=注意事项-13><a class=headerlink href=#注意事项-13 title=注意事项></a>注意事项</h4><p><font color=red>行为受状态约束时使用状态模式，而且状态不超过 5 个。</font><h4 id=代码实例-13><a class=headerlink href=#代码实例-13 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br><span class=line>105</span><br><span class=line>106</span><br><span class=line>107</span><br><span class=line>108</span><br><span class=line>109</span><br><span class=line>110</span><br><span class=line>111</span><br><span class=line>112</span><br><span class=line>113</span><br><span class=line>114</span><br><span class=line>115</span><br><span class=line>116</span><br><span class=line>117</span><br><span class=line>118</span><br><span class=line>119</span><br><span class=line>120</span><br><span class=line>121</span><br><span class=line>122</span><br><span class=line>123</span><br><span class=line>124</span><br><span class=line>125</span><br><span class=line>126</span><br><span class=line>127</span><br><span class=line>128</span><br><span class=line>129</span><br><span class=line>130</span><br><span class=line>131</span><br><span class=line>132</span><br><span class=line>133</span><br><span class=line>134</span><br><span class=line>135</span><br><span class=line>136</span><br><span class=line>137</span><br><span class=line>138</span><br><span class=line>139</span><br><span class=line>140</span><br><span class=line>141</span><br><span class=line>142</span><br><span class=line>143</span><br><span class=line>144</span><br><span class=line>145</span><br><span class=line>146</span><br><span class=line>147</span><br><span class=line>148</span><br><span class=line>149</span><br><span class=line>150</span><br><span class=line>151</span><br><span class=line>152</span><br><span class=line>153</span><br><span class=line>154</span><br><span class=line>155</span><br><span class=line>156</span><br><span class=line>157</span><br><span class=line>158</span><br><span class=line>159</span><br><span class=line>160</span><br><span class=line>161</span><br></pre><td class=code><pre><span class=line><span class=comment>// 状态接口</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">State</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">pressOpenButton</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">pressCloseButton</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">pressMoveButton</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">pressStopButton</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体状态类：停止状态</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">StoppedState</span> <span class=keyword>implements</span> <span class="title class_">State</span> {</span><br><span class=line>    <span class=keyword>private</span> ElevatorContext context;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">StoppedState</span><span class=params>(ElevatorContext context)</span> {</span><br><span class=line>        <span class=built_in>this</span>.context = context;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">pressOpenButton</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"门打开了。"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">pressCloseButton</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"门关闭了。"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">pressMoveButton</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"电梯开始运行。"</span>);</span><br><span class=line>        context.setState(context.getMovingState());  <span class=comment>// 切换到运行状态</span></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">pressStopButton</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"电梯已经停止。"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体状态类：运行状态</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">MovingState</span> <span class=keyword>implements</span> <span class="title class_">State</span> {</span><br><span class=line>    <span class=keyword>private</span> ElevatorContext context;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MovingState</span><span class=params>(ElevatorContext context)</span> {</span><br><span class=line>        <span class=built_in>this</span>.context = context;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">pressOpenButton</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"电梯运行中，不能开门！"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">pressCloseButton</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"门已经是关闭状态。"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">pressMoveButton</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"电梯已经在运行中。"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">pressStopButton</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"电梯停止运行。"</span>);</span><br><span class=line>        context.setState(context.getStoppedState());  <span class=comment>// 切换到停止状态</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体状态类：维护状态</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">MaintenanceState</span> <span class=keyword>implements</span> <span class="title class_">State</span> {</span><br><span class=line>    <span class=keyword>private</span> ElevatorContext context;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MaintenanceState</span><span class=params>(ElevatorContext context)</span> {</span><br><span class=line>        <span class=built_in>this</span>.context = context;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">pressOpenButton</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"电梯维护中，不能开门！"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">pressCloseButton</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"电梯维护中，门不能关闭！"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">pressMoveButton</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"电梯维护中，不能运行！"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">pressStopButton</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"电梯已经停止维护。"</span>);</span><br><span class=line>        context.setState(context.getStoppedState());  <span class=comment>// 切换到停止状态</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 上下文类：电梯</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">ElevatorContext</span> {</span><br><span class=line>    <span class=keyword>private</span> State stoppedState;</span><br><span class=line>    <span class=keyword>private</span> State movingState;</span><br><span class=line>    <span class=keyword>private</span> State maintenanceState;</span><br><span class=line>    <span class=keyword>private</span> State currentState;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ElevatorContext</span><span class=params>()</span> {</span><br><span class=line>        stoppedState = <span class=keyword>new</span> <span class="title class_">StoppedState</span>(<span class=built_in>this</span>);</span><br><span class=line>        movingState = <span class=keyword>new</span> <span class="title class_">MovingState</span>(<span class=built_in>this</span>);</span><br><span class=line>        maintenanceState = <span class=keyword>new</span> <span class="title class_">MaintenanceState</span>(<span class=built_in>this</span>);</span><br><span class=line>        currentState = stoppedState;  <span class=comment>// 初始状态为停止状态</span></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setState</span><span class=params>(State state)</span> {</span><br><span class=line>        currentState = state;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">pressOpenButton</span><span class=params>()</span> {</span><br><span class=line>        currentState.pressOpenButton();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">pressCloseButton</span><span class=params>()</span> {</span><br><span class=line>        currentState.pressCloseButton();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">pressMoveButton</span><span class=params>()</span> {</span><br><span class=line>        currentState.pressMoveButton();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">pressStopButton</span><span class=params>()</span> {</span><br><span class=line>        currentState.pressStopButton();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 获取不同状态的对象</span></span><br><span class=line>    <span class=keyword>public</span> State <span class="title function_">getStoppedState</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> stoppedState;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> State <span class="title function_">getMovingState</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> movingState;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> State <span class="title function_">getMaintenanceState</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> maintenanceState;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 客户端代码</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">StatePatternDemo</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>ElevatorContext</span> <span class=variable>elevator</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ElevatorContext</span>();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 电梯处于停止状态</span></span><br><span class=line>        elevator.pressOpenButton();   <span class=comment>// 门打开了</span></span><br><span class=line>        elevator.pressMoveButton();   <span class=comment>// 电梯开始运行</span></span><br><span class=line>        elevator.pressOpenButton();   <span class=comment>// 电梯运行中，不能开门！</span></span><br><span class=line></span><br><span class=line>        <span class=comment>// 切换到停止状态</span></span><br><span class=line>        elevator.pressStopButton();   <span class=comment>// 电梯停止运行</span></span><br><span class=line>        elevator.pressOpenButton();   <span class=comment>// 门打开了</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-10、Visitor（访问者模式）><a class=headerlink href=#1-2-10、Visitor（访问者模式） title=1.2.10、Visitor（访问者模式）></a>1.2.10、Visitor（访问者模式）</h3><h4 id=定义-11><a class=headerlink href=#定义-11 title=定义></a>定义</h4><p>访问者模式允许你在不修改对象结构的前提下，增加新的操作。访问者模式将数据结构与作用于数据结构的操作进行分离，使得新的操作可以很容易地扩展而不需要修改现有类的代码，符合开闭原则。<h4 id=结构-13><a class=headerlink href=#结构-13 title=结构></a>结构</h4><ul><li>访问者接口<li>具体访问者<li>元素接口<li>具体元素类<li>对象结构</ul><h4 id=何时使用-14><a class=headerlink href=#何时使用-14 title=何时使用></a>何时使用</h4><p>对一个对象执行多种不同操作，且要避免这些操作影响对象关联的类，可以使用该模式将这些操作封装到类中。<h4 id=优缺点-14><a class=headerlink href=#优缺点-14 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>符合单一职责原则。<li>优秀的扩展性。<li>灵活性。</ol><li>缺点<ol><li>具体元素对访问者公布细节，违反了迪米特原则。<li>具体元素变更比较困难。<li>违反了依赖倒置原则，依赖具体类，没有依赖抽象。</ol></ul><h4 id=使用场景-14><a class=headerlink href=#使用场景-14 title=使用场景></a>使用场景</h4><ol><li>对象对应的类很少改变，但需要在对象上添加新操作。<li>需要对一个对象执行多种不同操作，且要避免这些操作影响对象对应的类，且在添加新操作时也不想修改该类的场景；</ol><h4 id=应用实例-13><a class=headerlink href=#应用实例-13 title=应用实例></a>应用实例</h4><p>你去朋友家做客，您是访问者，朋友接受您的访问，然后对朋友的描述做出一个判断，这就是访问者模式。<h4 id=注意事项-14><a class=headerlink href=#注意事项-14 title=注意事项></a>注意事项</h4><p><font color=red>访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。</font><h4 id=代码实例-14><a class=headerlink href=#代码实例-14 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br><span class=line>105</span><br><span class=line>106</span><br><span class=line>107</span><br><span class=line>108</span><br><span class=line>109</span><br><span class=line>110</span><br><span class=line>111</span><br><span class=line>112</span><br><span class=line>113</span><br><span class=line>114</span><br><span class=line>115</span><br><span class=line>116</span><br><span class=line>117</span><br><span class=line>118</span><br><span class=line>119</span><br><span class=line>120</span><br><span class=line>121</span><br><span class=line>122</span><br><span class=line>123</span><br><span class=line>124</span><br><span class=line>125</span><br><span class=line>126</span><br><span class=line>127</span><br></pre><td class=code><pre><span class=line><span class=comment>// 访问者接口</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">Visitor</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(Employee employee)</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(Manager manager)</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体访问者类：工资计算</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">SalaryVisitor</span> <span class=keyword>implements</span> <span class="title class_">Visitor</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(Employee employee)</span> {</span><br><span class=line>        System.out.println(<span class=string>"普通员工 "</span> + employee.getName() + <span class=string>" 的工资为: "</span> + (employee.getSalary() * <span class=number>1.0</span>));</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(Manager manager)</span> {</span><br><span class=line>        System.out.println(<span class=string>"经理 "</span> + manager.getName() + <span class=string>" 的工资为: "</span> + (manager.getSalary() * <span class=number>1.2</span>));</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体访问者类：打印信息</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">PrintInfoVisitor</span> <span class=keyword>implements</span> <span class="title class_">Visitor</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(Employee employee)</span> {</span><br><span class=line>        System.out.println(<span class=string>"普通员工: "</span> + employee.getName());</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(Manager manager)</span> {</span><br><span class=line>        System.out.println(<span class=string>"经理: "</span> + manager.getName());</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 元素接口</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">Element</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">accept</span><span class=params>(Visitor visitor)</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体元素类：普通员工</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Employee</span> <span class=keyword>implements</span> <span class="title class_">Element</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>double</span> salary;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Employee</span><span class=params>(String name, <span class=type>double</span> salary)</span> {</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>        <span class=built_in>this</span>.salary = salary;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getName</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> name;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=type>double</span> <span class="title function_">getSalary</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> salary;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">accept</span><span class=params>(Visitor visitor)</span> {</span><br><span class=line>        visitor.visit(<span class=built_in>this</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体元素类：经理</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Manager</span> <span class=keyword>implements</span> <span class="title class_">Element</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>double</span> salary;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Manager</span><span class=params>(String name, <span class=type>double</span> salary)</span> {</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>        <span class=built_in>this</span>.salary = salary;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getName</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> name;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=type>double</span> <span class="title function_">getSalary</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> salary;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">accept</span><span class=params>(Visitor visitor)</span> {</span><br><span class=line>        visitor.visit(<span class=built_in>this</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 对象结构：公司</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Company</span> {</span><br><span class=line>    <span class=keyword>private</span> List&LTElement> employees = <span class=keyword>new</span> <span class="title class_">ArrayList</span><>();</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">addEmployee</span><span class=params>(Element employee)</span> {</span><br><span class=line>        employees.add(employee);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">accept</span><span class=params>(Visitor visitor)</span> {</span><br><span class=line>        <span class=keyword>for</span> (Element employee : employees) {</span><br><span class=line>            employee.accept(visitor);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 客户端代码</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">VisitorPatternDemo</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=comment>// 创建员工</span></span><br><span class=line>        <span class=type>Employee</span> <span class=variable>emp1</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Employee</span>(<span class=string>"张三"</span>, <span class=number>5000</span>);</span><br><span class=line>        <span class=type>Employee</span> <span class=variable>emp2</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Employee</span>(<span class=string>"李四"</span>, <span class=number>4000</span>);</span><br><span class=line>        <span class=type>Manager</span> <span class=variable>mgr1</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Manager</span>(<span class=string>"王经理"</span>, <span class=number>8000</span>);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 创建公司</span></span><br><span class=line>        <span class=type>Company</span> <span class=variable>company</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Company</span>();</span><br><span class=line>        company.addEmployee(emp1);</span><br><span class=line>        company.addEmployee(emp2);</span><br><span class=line>        company.addEmployee(mgr1);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 创建访问者</span></span><br><span class=line>        <span class=type>SalaryVisitor</span> <span class=variable>salaryVisitor</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SalaryVisitor</span>();</span><br><span class=line>        <span class=type>PrintInfoVisitor</span> <span class=variable>printInfoVisitor</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">PrintInfoVisitor</span>();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 访问员工，计算工资</span></span><br><span class=line>        System.out.println(<span class=string>"工资计算："</span>);</span><br><span class=line>        company.accept(salaryVisitor);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 访问员工，打印信息</span></span><br><span class=line>        System.out.println(<span class=string>"\n打印信息："</span>);</span><br><span class=line>        company.accept(printInfoVisitor);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-11、Memento（备忘录模式）><a class=headerlink href=#1-2-11、Memento（备忘录模式） title=1.2.11、Memento（备忘录模式）></a>1.2.11、Memento（备忘录模式）</h3><h4 id=定义-12><a class=headerlink href=#定义-12 title=定义></a>定义</h4><p>备忘录模式用于在不破坏封装性的前提下，捕获和恢复对象的内部状态。备忘录模式允许对象保存其历史状态，以便在需要时恢复到之前的状态，常用于实现撤销、重做功能。<h4 id=结构-14><a class=headerlink href=#结构-14 title=结构></a>结构</h4><ul><li>发起人<li>备忘录<li>负责人</ul><h4 id=何时使用-15><a class=headerlink href=#何时使用-15 title=何时使用></a>何时使用</h4><p>用户需要取消不确定或者错误的操作时，能够恢复到他原先的状态，使得他有 “后悔药” 可吃。<h4 id=优缺点-15><a class=headerlink href=#优缺点-15 title=优缺点></a>优缺点</h4><ul><li><p>优点</p> <ol><li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。<li>实现了信息的封装，使得用户不需要关心状态的保存细节。</ol><li><p>缺点</p> <p>消耗资源。类成员数量多导致占用大量资源，且保存时会占用内存。</p></ul><h4 id=使用场景-15><a class=headerlink href=#使用场景-15 title=使用场景></a>使用场景</h4><ol><li>需要保存 / 恢复数据的相关状态场景。<li>提供一个可回滚的操作。</ol><h4 id=应用实例-14><a class=headerlink href=#应用实例-14 title=应用实例></a>应用实例</h4><ol><li>后悔药。<li>打游戏时的存档。<li>Windows 里的 ctri + z。<li>IE 中的后退。<li>数据库的事务管理。</ol><h4 id=注意事项-15><a class=headerlink href=#注意事项-15 title=注意事项></a>注意事项</h4><ol><li><font color=red>为了符合迪米特原则，还要增加一个管理备忘录的类。</font><li><font color=red>为了节约内存，可使用原型模式 + 备忘录模式。</font></ol><h4 id=代码实例-15><a class=headerlink href=#代码实例-15 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br></pre><td class=code><pre><span class=line><span class=comment>// 备忘录类：保存编辑器的状态</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">TextEditorMemento</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> String text;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">TextEditorMemento</span><span class=params>(String text)</span> {</span><br><span class=line>        <span class=built_in>this</span>.text = text;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getText</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> text;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 发起人类：文本编辑器</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">TextEditor</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>StringBuilder</span> <span class=variable>text</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StringBuilder</span>();</span><br><span class=line></span><br><span class=line>    <span class=comment>// 编辑文本</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">write</span><span class=params>(String newText)</span> {</span><br><span class=line>        text.append(newText);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 获取当前文本</span></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getText</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> text.toString();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 创建备忘录，保存当前状态</span></span><br><span class=line>    <span class=keyword>public</span> TextEditorMemento <span class="title function_">save</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">TextEditorMemento</span>(text.toString());</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 恢复备忘录中的状态</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">restore</span><span class=params>(TextEditorMemento memento)</span> {</span><br><span class=line>        text = <span class=keyword>new</span> <span class="title class_">StringBuilder</span>(memento.getText());</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 负责人类：保存备忘录</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Caretaker</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> List&LTTextEditorMemento> mementos = <span class=keyword>new</span> <span class="title class_">ArrayList</span><>();</span><br><span class=line></span><br><span class=line>    <span class=comment>// 保存备忘录</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">addMemento</span><span class=params>(TextEditorMemento memento)</span> {</span><br><span class=line>        mementos.add(memento);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 获取最后一个备忘录（撤销功能）</span></span><br><span class=line>    <span class=keyword>public</span> TextEditorMemento <span class="title function_">getLastMemento</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>if</span> (mementos.size() == <span class=number>0</span>) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> mementos.remove(mementos.size() - <span class=number>1</span>);  <span class=comment>// 删除并返回最后一个备忘录</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 客户端代码</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MementoPatternDemo</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>TextEditor</span> <span class=variable>editor</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TextEditor</span>();</span><br><span class=line>        <span class=type>Caretaker</span> <span class=variable>caretaker</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Caretaker</span>();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 用户输入文本</span></span><br><span class=line>        editor.write(<span class=string>"Hello "</span>);</span><br><span class=line>        caretaker.addMemento(editor.save());  <span class=comment>// 保存当前状态</span></span><br><span class=line></span><br><span class=line>        editor.write(<span class=string>"World!"</span>);</span><br><span class=line>        caretaker.addMemento(editor.save());  <span class=comment>// 保存当前状态</span></span><br><span class=line></span><br><span class=line>        System.out.println(<span class=string>"当前文本: "</span> + editor.getText());  <span class=comment>// 当前文本: Hello World!</span></span><br><span class=line></span><br><span class=line>        <span class=comment>// 撤销操作</span></span><br><span class=line>        editor.restore(caretaker.getLastMemento());</span><br><span class=line>        System.out.println(<span class=string>"撤销一次: "</span> + editor.getText());  <span class=comment>// 撤销一次: Hello </span></span><br><span class=line></span><br><span class=line>        <span class=comment>// 再次撤销</span></span><br><span class=line>        editor.restore(caretaker.getLastMemento());</span><br><span class=line>        System.out.println(<span class=string>"再次撤销: "</span> + editor.getText());  <span class=comment>// 再次撤销: (空)</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=1-3、结构型（7种）><a class=headerlink href=#1-3、结构型（7种） title=1.3、结构型（7种）></a>1.3、结构型（7种）</h2><h3 id=1-3-1、Composite（组合模式）><a class=headerlink href=#1-3-1、Composite（组合模式） title=1.3.1、Composite（组合模式）></a>1.3.1、Composite（组合模式）</h3><h4 id=定义-13><a class=headerlink href=#定义-13 title=定义></a>定义</h4><p>组合模式通过将对象组合成树形结构来表示部分、整体的层次结构，使得客户端可以以相同的方式处理单个对象和组合对象。它允许你通过递归方式来组合对象，从而以统一的方式来处理这些对象。<h4 id=结构-15><a class=headerlink href=#结构-15 title=结构></a>结构</h4><ul><li>Component（抽象组件）：定义所有组合对象的公共接口，它既可以是叶子节点，也可以是组合对象。<li>Leaf（叶子节点）：表示组合的叶子对象，不能包含子节点，是组合中的基本构件。<li>Composite（组合对象）：包含子对象的组合对象。它实现了Component接口，且可以包含其它Component对象（包括Leaf和Composite对象）。</ul><h4 id=何时使用-16><a class=headerlink href=#何时使用-16 title=何时使用></a>何时使用</h4><ol><li>想表示对象部分 - 整体的层次结构（树形结构）。<li>忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</ol><h4 id=优缺点-16><a class=headerlink href=#优缺点-16 title=优缺点></a>优缺点</h4><ul><li><p>优点</p> <ol><li>高层模块调用简单。<li>节点自由增加。</ol><li><p>缺点</p> <p>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p></ul><h4 id=使用场景-16><a class=headerlink href=#使用场景-16 title=使用场景></a>使用场景</h4><ol><li>树形结构。组合模式非常适合处理文件系统、组织结构、UI组件树等树形结构的数据。<li>一致性操作。希望客户端以统一的方式处理单个对象和组合对象。</ol><h4 id=应用实例-15><a class=headerlink href=#应用实例-15 title=应用实例></a>应用实例</h4><ol><li>算术表达式包括操作数. 操作符和另一个操作数，其中，另一个操作符也可以是操作数. 操作符和另一个操作数。<li>在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</ol><h4 id=注意事项-16><a class=headerlink href=#注意事项-16 title=注意事项></a>注意事项</h4><p><font color=red>定义时 为 具体类。</font><h4 id=代码实例-16><a class=headerlink href=#代码实例-16 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br></pre><td class=code><pre><span class=line><span class=comment>// 抽象组件类，定义叶子和组合对象的共同接口</span></span><br><span class=line><span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">FileSystemComponent</span> {</span><br><span class=line>    <span class=keyword>protected</span> String name;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">FileSystemComponent</span><span class=params>(String name)</span> {</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 打印组件的名称</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">show</span><span class=params>()</span>;</span><br><span class=line></span><br><span class=line>    <span class=comment>// 叶子节点不支持添加和移除子节点，组合对象需要重写这些方法</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">add</span><span class=params>(FileSystemComponent component)</span> {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">UnsupportedOperationException</span>(<span class=string>"Operation not supported."</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">remove</span><span class=params>(FileSystemComponent component)</span> {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">UnsupportedOperationException</span>(<span class=string>"Operation not supported."</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 叶子节点：文件</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">File</span> <span class=keyword>extends</span> <span class="title class_">FileSystemComponent</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">File</span><span class=params>(String name)</span> {</span><br><span class=line>        <span class=built_in>super</span>(name);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">show</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"File: "</span> + name);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 组合对象：文件夹</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Directory</span> <span class=keyword>extends</span> <span class="title class_">FileSystemComponent</span> {</span><br><span class=line>    <span class=keyword>private</span> List&LTFileSystemComponent> children = <span class=keyword>new</span> <span class="title class_">ArrayList</span><>();</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Directory</span><span class=params>(String name)</span> {</span><br><span class=line>        <span class=built_in>super</span>(name);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">show</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Directory: "</span> + name);</span><br><span class=line>        <span class=keyword>for</span> (FileSystemComponent component : children) {</span><br><span class=line>            component.show();  <span class=comment>// 递归调用子节点的show方法</span></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">add</span><span class=params>(FileSystemComponent component)</span> {</span><br><span class=line>        children.add(component);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">remove</span><span class=params>(FileSystemComponent component)</span> {</span><br><span class=line>        children.remove(component);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=comment>// 创建文件和文件夹</span></span><br><span class=line>        <span class=type>FileSystemComponent</span> <span class=variable>file1</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">File</span>(<span class=string>"File1.txt"</span>);</span><br><span class=line>        <span class=type>FileSystemComponent</span> <span class=variable>file2</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">File</span>(<span class=string>"File2.txt"</span>);</span><br><span class=line>        <span class=type>FileSystemComponent</span> <span class=variable>file3</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">File</span>(<span class=string>"File3.txt"</span>);</span><br><span class=line></span><br><span class=line>        <span class=type>Directory</span> <span class=variable>dir1</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Directory</span>(<span class=string>"Folder1"</span>);</span><br><span class=line>        <span class=type>Directory</span> <span class=variable>dir2</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Directory</span>(<span class=string>"Folder2"</span>);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 将文件添加到文件夹中</span></span><br><span class=line>        dir1.add(file1);</span><br><span class=line>        dir1.add(file2);</span><br><span class=line>        dir2.add(file3);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 创建根目录，并将文件夹添加到根目录中</span></span><br><span class=line>        <span class=type>Directory</span> <span class=variable>root</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Directory</span>(<span class=string>"Root"</span>);</span><br><span class=line>        root.add(dir1);</span><br><span class=line>        root.add(dir2);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 显示文件系统的结构</span></span><br><span class=line>        root.show();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-3-2、Facade（外观模式）><a class=headerlink href=#1-3-2、Facade（外观模式） title=1.3.2、Facade（外观模式）></a>1.3.2、Facade（外观模式）</h3><h4 id=定义-14><a class=headerlink href=#定义-14 title=定义></a>定义</h4><p>外观模式的目的是为复杂的子系统提供一个简化接口，使客户端可以通过一个统一接口来访问子系统的功能，而无需了解子系统的内部细节。外观模式不会改变子系统本身，而是通过创建一个外观类来简化接口。<h4 id=结构-16><a class=headerlink href=#结构-16 title=结构></a>结构</h4><ul><li>facade（外观类）：提供简化的接口，调用子系统的功能。<li>Subsystem Classes（子系统类）：子系统中的各个模块，外观类负责与这些模块进行交互。子系统并不知道外观类的存在，它们只负责执行自己的功能。<li>客户端：通过外观类与子系统进行交互，而不需要直接接触子系统。</ul><h4 id=何时使用-17><a class=headerlink href=#何时使用-17 title=何时使用></a>何时使用</h4><ol><li>无需知道系统内部，只需提供一个系统 “接待员” 即可。<li>定义系统的入口。</ol><h4 id=优缺点-17><a class=headerlink href=#优缺点-17 title=优缺点></a>优缺点</h4><ul><li><p>优点</p> <ol><li>减少系统相互依赖。<li>提高灵活性。<li>提高了安全性。</ol><li><p>缺点</p> <p>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p></ul><h4 id=使用场景-17><a class=headerlink href=#使用场景-17 title=使用场景></a>使用场景</h4><ol><li>为复杂的模块或子系统提供外界访问的模块。<li>子系统相对独立。<li>预防低水平人员带来的风险。</ol><h4 id=应用实例-16><a class=headerlink href=#应用实例-16 title=应用实例></a>应用实例</h4><ol><li>去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。<li>JAVA 的三层开发模式。</ol><h4 id=注意事项-17><a class=headerlink href=#注意事项-17 title=注意事项></a>注意事项</h4><p><font color=red>在层次化结构中，可以使用外观模式定义系统每一层的入口。</font><h4 id=代码实例-17><a class=headerlink href=#代码实例-17 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br></pre><td class=code><pre><span class=line><span class=comment>// 子系统类1：DVD播放器</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">DVDPlayer</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">on</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"DVD Player is ON."</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">play</span><span class=params>(String movie)</span> {</span><br><span class=line>        System.out.println(<span class=string>"Playing movie: "</span> + movie);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">off</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"DVD Player is OFF."</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 子系统类2：投影仪</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Projector</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">on</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Projector is ON."</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">off</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Projector is OFF."</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 子系统类3：音响系统</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">SoundSystem</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">on</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Sound System is ON."</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setVolume</span><span class=params>(<span class=type>int</span> level)</span> {</span><br><span class=line>        System.out.println(<span class=string>"Setting volume to: "</span> + level);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">off</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Sound System is OFF."</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 子系统类4：灯光控制</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Lights</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">dim</span><span class=params>(<span class=type>int</span> level)</span> {</span><br><span class=line>        System.out.println(<span class=string>"Dimming lights to: "</span> + level + <span class=string>"%"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">on</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Lights are ON."</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 外观类：家庭影院外观</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">HomeTheaterFacade</span> {</span><br><span class=line>    <span class=keyword>private</span> DVDPlayer dvdPlayer;</span><br><span class=line>    <span class=keyword>private</span> Projector projector;</span><br><span class=line>    <span class=keyword>private</span> SoundSystem soundSystem;</span><br><span class=line>    <span class=keyword>private</span> Lights lights;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">HomeTheaterFacade</span><span class=params>(DVDPlayer dvdPlayer, Projector projector, SoundSystem soundSystem, Lights lights)</span> {</span><br><span class=line>        <span class=built_in>this</span>.dvdPlayer = dvdPlayer;</span><br><span class=line>        <span class=built_in>this</span>.projector = projector;</span><br><span class=line>        <span class=built_in>this</span>.soundSystem = soundSystem;</span><br><span class=line>        <span class=built_in>this</span>.lights = lights;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 统一的接口：开启家庭影院观看电影</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">watchMovie</span><span class=params>(String movie)</span> {</span><br><span class=line>        System.out.println(<span class=string>"Setting up movie night..."</span>);</span><br><span class=line>        lights.dim(<span class=number>20</span>);  <span class=comment>// 调暗灯光</span></span><br><span class=line>        projector.on();  <span class=comment>// 开启投影仪</span></span><br><span class=line>        soundSystem.on();  <span class=comment>// 开启音响系统</span></span><br><span class=line>        soundSystem.setVolume(<span class=number>5</span>);  <span class=comment>// 设置音量</span></span><br><span class=line>        dvdPlayer.on();  <span class=comment>// 开启DVD播放器</span></span><br><span class=line>        dvdPlayer.play(movie);  <span class=comment>// 播放电影</span></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 统一的接口：关闭家庭影院</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">endMovie</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Shutting down home theater..."</span>);</span><br><span class=line>        dvdPlayer.off();</span><br><span class=line>        soundSystem.off();</span><br><span class=line>        projector.off();</span><br><span class=line>        lights.on();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=comment>// 创建各个子系统对象</span></span><br><span class=line>        <span class=type>DVDPlayer</span> <span class=variable>dvdPlayer</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">DVDPlayer</span>();</span><br><span class=line>        <span class=type>Projector</span> <span class=variable>projector</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Projector</span>();</span><br><span class=line>        <span class=type>SoundSystem</span> <span class=variable>soundSystem</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SoundSystem</span>();</span><br><span class=line>        <span class=type>Lights</span> <span class=variable>lights</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Lights</span>();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 创建外观对象，提供简化接口</span></span><br><span class=line>        <span class=type>HomeTheaterFacade</span> <span class=variable>homeTheater</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">HomeTheaterFacade</span>(dvdPlayer, projector, soundSystem, lights);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 客户端通过外观类控制家庭影院</span></span><br><span class=line>        homeTheater.watchMovie(<span class=string>"Inception"</span>);</span><br><span class=line>        System.out.println();</span><br><span class=line>        homeTheater.endMovie();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-3-3、Proxy（代理模式）><a class=headerlink href=#1-3-3、Proxy（代理模式） title=1.3.3、Proxy（代理模式）></a>1.3.3、Proxy（代理模式）</h3><h4 id=定义-15><a class=headerlink href=#定义-15 title=定义></a>定义</h4><p><strong>为某个动作生成一个代理，用来控制对目标对象的访问。</strong><h4 id=实现-2><a class=headerlink href=#实现-2 title=实现></a>实现</h4><ul><li>静态代理<li>动态代理</ul><h4 id=何时使用-18><a class=headerlink href=#何时使用-18 title=何时使用></a>何时使用</h4><p>想在访问一个类时做一些控制。<h4 id=优缺点-18><a class=headerlink href=#优缺点-18 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>职责清晰。<li>高扩展性。<li>智能化。</ol><li>缺点<ol><li>由于增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。<li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</ol></ul><h4 id=使用场景-18><a class=headerlink href=#使用场景-18 title=使用场景></a>使用场景</h4><ol><li>远程代理。<li>虚拟代理。<li>Copy-on-Write 代理。<li>保护（Protect or Access）代理。<li>Cache 代理。<li>防火墙（Firewall）代理。<li>同步化（Synchronization）代理。<li>智能引用（Smart Reference）代理。</ol><h4 id=应用实例-17><a class=headerlink href=#应用实例-17 title=应用实例></a>应用实例</h4><ol><li>Windows 中的快捷方式。<li>猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。<li>买火车票不一定在火车站买，也可以去代售点。<li>一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。<li>spring aop。</ol><h4 id=注意事项-18><a class=headerlink href=#注意事项-18 title=注意事项></a>注意事项</h4><ol><li><font color=red>与适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</font><li><font color=red>与装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</font></ol><h4 id=代码实例-18><a class=headerlink href=#代码实例-18 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br></pre><td class=code><pre><span class=line><span class=comment>// 抽象主题接口，定义图像的行为</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">Image</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">display</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 真实的图像类，实际处理图像的加载和显示</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">RealImage</span> <span class=keyword>implements</span> <span class="title class_">Image</span> {</span><br><span class=line>    <span class=keyword>private</span> String fileName;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RealImage</span><span class=params>(String fileName)</span> {</span><br><span class=line>        <span class=built_in>this</span>.fileName = fileName;</span><br><span class=line>        loadFromDisk();  <span class=comment>// 加载图像，模拟耗时操作</span></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">loadFromDisk</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Loading "</span> + fileName);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">display</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Displaying "</span> + fileName);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 代理类，控制对 RealImage 的访问，并实现延迟加载</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">ImageProxy</span> <span class=keyword>implements</span> <span class="title class_">Image</span> {</span><br><span class=line>    <span class=keyword>private</span> RealImage realImage;</span><br><span class=line>    <span class=keyword>private</span> String fileName;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ImageProxy</span><span class=params>(String fileName)</span> {</span><br><span class=line>        <span class=built_in>this</span>.fileName = fileName;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">display</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// 只有在需要显示图像时，才去创建和加载真实的图像</span></span><br><span class=line>        <span class=keyword>if</span> (realImage == <span class=literal>null</span>) {</span><br><span class=line>            realImage = <span class=keyword>new</span> <span class="title class_">RealImage</span>(fileName);</span><br><span class=line>        }</span><br><span class=line>        realImage.display();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>Image</span> <span class=variable>image1</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ImageProxy</span>(<span class=string>"image1.jpg"</span>);</span><br><span class=line>        <span class=type>Image</span> <span class=variable>image2</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ImageProxy</span>(<span class=string>"image2.jpg"</span>);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 图像尚未加载，只有在调用 display 时才会加载</span></span><br><span class=line>        System.out.println(<span class=string>"Before calling display..."</span>);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 图像被加载并显示</span></span><br><span class=line>        image1.display();</span><br><span class=line>        image2.display();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 再次调用 display，图像已经加载，不需要再次加载</span></span><br><span class=line>        System.out.println(<span class=string>"After calling display..."</span>);</span><br><span class=line>        image1.display();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-3-4、Adpter（适配器模式）><a class=headerlink href=#1-3-4、Adpter（适配器模式） title=1.3.4、Adpter（适配器模式）></a>1.3.4、Adpter（适配器模式）</h3><h4 id=定义-16><a class=headerlink href=#定义-16 title=定义></a>定义</h4><p>适配器模式用于解决 接口不兼容 的问题，让原本不兼容的类能通过适配器来协同工作。它提供了一种包装器，将一个接口转化为另一个接口，使得不兼容的对象之间可以协作。<h4 id=结构-17><a class=headerlink href=#结构-17 title=结构></a>结构</h4><ul><li>target（目标接口）<li>adaptee（适配者）<li>adapter（适配器）<li>client（客户端）</ul><h4 id=实现-3><a class=headerlink href=#实现-3 title=实现></a>实现</h4><ul><li>Object Adapter<li>Class Adapter</ul><h4 id=何时使用-19><a class=headerlink href=#何时使用-19 title=何时使用></a>何时使用</h4><ol><li>系统需要使用现有的类，而此类的接口不符合系统需要。<li>想要建立一个可以重复使用的类，可以使得不兼容的类变得兼容起来。<li>通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</ol><h4 id=优缺点-19><a class=headerlink href=#优缺点-19 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>可以让任何两个没有关联的类一起运行。<li>提高了类的复用。<li>增加了类的透明度。<li>灵活性好。</ol><li>缺点<ol><li>过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。<li>由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</ol></ul><h4 id=使用场景-19><a class=headerlink href=#使用场景-19 title=使用场景></a>使用场景</h4><ol><li>希望使用某些现有类，但接口与代码不兼容时，可以使用适配器模式。<li>希望重用几个现有子类，这些子类缺少一些不能添加到超类中的公共功能时，可以使用适配器模式。</ol><h4 id=应用实例-18><a class=headerlink href=#应用实例-18 title=应用实例></a>应用实例</h4><ol><li>美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。<li>JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。<li>在 LINUX 上运行 WINDOWS 程序。 4. JAVA 中的 jdbc。</ol><h4 id=源码应用-4><a class=headerlink href=#源码应用-4 title=源码应用></a>源码应用</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>java.util.Arrays#asList();</span><br><span class=line>java.util.Collections#list();</span><br><span class=line>org.springframework.context.event.GenericApplicationListenerAdapter</span><br></pre></table></figure><h4 id=注意事项-19><a class=headerlink href=#注意事项-19 title=注意事项></a>注意事项</h4><p><font color=red>适配器不是在详细设计时添加的，而是解决正在服役的项目问题。</font><h4 id=代码实例-19><a class=headerlink href=#代码实例-19 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br></pre><td class=code><pre><span class=line><span class=comment>// 定义目标接口，要求能播放MP4文件</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">MediaPlayer</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">play</span><span class=params>(String audioType, String fileName)</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 老的音频播放器，只支持MP3格式</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">MP3Player</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">playMP3</span><span class=params>(String fileName)</span> {</span><br><span class=line>        System.out.println(<span class=string>"Playing MP3 file. Name: "</span> + fileName);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 适配器类，适配MP3Player来支持MP4播放功能</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">MediaAdapter</span> <span class=keyword>implements</span> <span class="title class_">MediaPlayer</span> {</span><br><span class=line>    <span class=keyword>private</span> MP3Player mp3Player;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MediaAdapter</span><span class=params>(String audioType)</span> {</span><br><span class=line>        <span class=keyword>if</span> (audioType.equalsIgnoreCase(<span class=string>"mp3"</span>)) {</span><br><span class=line>            mp3Player = <span class=keyword>new</span> <span class="title class_">MP3Player</span>();  <span class=comment>// 使用适配者对象</span></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">play</span><span class=params>(String audioType, String fileName)</span> {</span><br><span class=line>        <span class=keyword>if</span> (audioType.equalsIgnoreCase(<span class=string>"mp3"</span>)) {</span><br><span class=line>            mp3Player.playMP3(fileName);  <span class=comment>// 调用适配者的功能</span></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 高层客户端类，可以播放多种格式，包括MP3和MP4</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">AudioPlayer</span> <span class=keyword>implements</span> <span class="title class_">MediaPlayer</span> {</span><br><span class=line>    MediaAdapter mediaAdapter;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">play</span><span class=params>(String audioType, String fileName)</span> {</span><br><span class=line>        <span class=comment>// 支持播放MP3文件的直接播放</span></span><br><span class=line>        <span class=keyword>if</span> (audioType.equalsIgnoreCase(<span class=string>"mp3"</span>)) {</span><br><span class=line>            System.out.println(<span class=string>"Playing MP3 file. Name: "</span> + fileName);</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 使用适配器播放其他格式，如MP4</span></span><br><span class=line>        <span class=keyword>else</span> <span class=keyword>if</span> (audioType.equalsIgnoreCase(<span class=string>"mp4"</span>)) {</span><br><span class=line>            mediaAdapter = <span class=keyword>new</span> <span class="title class_">MediaAdapter</span>(<span class=string>"mp3"</span>);</span><br><span class=line>            System.out.println(<span class=string>"Using adapter to play MP4 file as MP3."</span>);</span><br><span class=line>            mediaAdapter.play(<span class=string>"mp3"</span>, fileName);  <span class=comment>// 转换格式播放</span></span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            System.out.println(<span class=string>"Invalid media format: "</span> + audioType);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>AudioPlayer</span> <span class=variable>audioPlayer</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AudioPlayer</span>();</span><br><span class=line></span><br><span class=line>        audioPlayer.play(<span class=string>"mp3"</span>, <span class=string>"song.mp3"</span>);</span><br><span class=line>        audioPlayer.play(<span class=string>"mp4"</span>, <span class=string>"movie.mp4"</span>);</span><br><span class=line>        audioPlayer.play(<span class=string>"avi"</span>, <span class=string>"example.avi"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-3-5、Decorator（装饰模式）><a class=headerlink href=#1-3-5、Decorator（装饰模式） title=1.3.5、Decorator（装饰模式）></a>1.3.5、Decorator（装饰模式）</h3><h4 id=定义-17><a class=headerlink href=#定义-17 title=定义></a>定义</h4><p>装饰器模式通过创建一个装饰器对象来包裹原始对象，以增加新的功能。这个模式的核心思想：不改变原始类的基础上，通过装饰器类给原始对象增加行为，装饰器类和原始类实现相同的接口，因此装饰器可以在运行时灵活的组合对象行为。<h4 id=结构-18><a class=headerlink href=#结构-18 title=结构></a>结构</h4><ul><li>组件<li>目标组件<li>装饰器<li>具体装饰器</ul><h4 id=何时使用-20><a class=headerlink href=#何时使用-20 title=何时使用></a>何时使用</h4><p>既想扩展类，又不想通过子类的方式实现。<h4 id=优缺点-20><a class=headerlink href=#优缺点-20 title=优缺点></a>优缺点</h4><ul><li><p>优点</p> <ol><li>不改变原有对象的情况下给一个对象扩展功能。<li>使用不同的组合可以实现不同的效果。<li>符合开闭原则。</ol><li><p>缺点</p> <p>多层装饰比较复杂。</p></ul><h4 id=使用场景-20><a class=headerlink href=#使用场景-20 title=使用场景></a>使用场景</h4><ol><li>扩展一个类的功能。<li>动态增加功能，动态撤销。</ol><h4 id=应用实例-19><a class=headerlink href=#应用实例-19 title=应用实例></a>应用实例</h4><ol><li>孙悟空有 72 变，当他变成 “庙宇” 后，他的根本还是一只猴子，但是他又有了庙宇的功能。<li>不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</ol><h4 id=源码中的应用-1><a class=headerlink href=#源码中的应用-1 title=源码中的应用></a>源码中的应用</h4><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>Servlet API</span><br><span class=line>javax.servlet.http.HttpServletRequestWrapper</span><br><span class=line>javax.servlet.http.HttpServletResponseWrapper</span><br></pre></table></figure><h4 id=注意事项-20><a class=headerlink href=#注意事项-20 title=注意事项></a>注意事项</h4><p><font color=red>可代替继承。</font><h4 id=代码实例-20><a class=headerlink href=#代码实例-20 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br></pre><td class=code><pre><span class=line><span class=comment>// 组件接口，定义基础功能</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">Coffee</span> {</span><br><span class=line>    String <span class="title function_">getDescription</span><span class=params>()</span>;</span><br><span class=line>    <span class=type>double</span> <span class="title function_">getCost</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体组件类，实现基本的咖啡功能</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">BasicCoffee</span> <span class=keyword>implements</span> <span class="title class_">Coffee</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getDescription</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"Basic Coffee"</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>double</span> <span class="title function_">getCost</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=number>2.0</span>;  <span class=comment>// 基本咖啡价格</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 装饰器类，持有一个Coffee对象</span></span><br><span class=line><span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">CoffeeDecorator</span> <span class=keyword>implements</span> <span class="title class_">Coffee</span> {</span><br><span class=line>    <span class=keyword>protected</span> Coffee decoratedCoffee;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">CoffeeDecorator</span><span class=params>(Coffee coffee)</span> {</span><br><span class=line>        <span class=built_in>this</span>.decoratedCoffee = coffee;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getDescription</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> decoratedCoffee.getDescription();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>double</span> <span class="title function_">getCost</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> decoratedCoffee.getCost();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体装饰器类，添加牛奶</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">MilkDecorator</span> <span class=keyword>extends</span> <span class="title class_">CoffeeDecorator</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MilkDecorator</span><span class=params>(Coffee coffee)</span> {</span><br><span class=line>        <span class=built_in>super</span>(coffee);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getDescription</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> decoratedCoffee.getDescription() + <span class=string>", Milk"</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>double</span> <span class="title function_">getCost</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> decoratedCoffee.getCost() + <span class=number>0.5</span>;  <span class=comment>// 牛奶的额外费用</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体装饰器类，添加糖</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">SugarDecorator</span> <span class=keyword>extends</span> <span class="title class_">CoffeeDecorator</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">SugarDecorator</span><span class=params>(Coffee coffee)</span> {</span><br><span class=line>        <span class=built_in>super</span>(coffee);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getDescription</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> decoratedCoffee.getDescription() + <span class=string>", Sugar"</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>double</span> <span class="title function_">getCost</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> decoratedCoffee.getCost() + <span class=number>0.2</span>;  <span class=comment>// 糖的额外费用</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=comment>// 基本咖啡</span></span><br><span class=line>        <span class=type>Coffee</span> <span class=variable>coffee</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">BasicCoffee</span>();</span><br><span class=line>        System.out.println(coffee.getDescription() + <span class=string>" $"</span> + coffee.getCost());</span><br><span class=line></span><br><span class=line>        <span class=comment>// 添加牛奶的咖啡</span></span><br><span class=line>        coffee = <span class=keyword>new</span> <span class="title class_">MilkDecorator</span>(coffee);</span><br><span class=line>        System.out.println(coffee.getDescription() + <span class=string>" $"</span> + coffee.getCost());</span><br><span class=line></span><br><span class=line>        <span class=comment>// 添加糖和牛奶的咖啡</span></span><br><span class=line>        coffee = <span class=keyword>new</span> <span class="title class_">SugarDecorator</span>(coffee);</span><br><span class=line>        System.out.println(coffee.getDescription() + <span class=string>" $"</span> + coffee.getCost());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-3-6、Bridge（桥接模式）><a class=headerlink href=#1-3-6、Bridge（桥接模式） title=1.3.6、Bridge（桥接模式）></a>1.3.6、Bridge（桥接模式）</h3><h4 id=定义-18><a class=headerlink href=#定义-18 title=定义></a>定义</h4><p>桥接模式核心思想是将抽象与实现解耦，使它们可以独立扩展。它通过引入一个中间的“桥”（桥接接口），将不同的抽象部分与不同的实现部分连接起来，避免直接耦合，抽象部分与实现部分可以独立变化，互不影响。<h4 id=结构-19><a class=headerlink href=#结构-19 title=结构></a>结构</h4><ul><li>抽象部分<li>扩展抽象部分<li>实现部分<li>具体实现部分</ul><h4 id=何时使用-21><a class=headerlink href=#何时使用-21 title=何时使用></a>何时使用</h4><p>系统的实现有多个方案，每一种都可能变化。<h4 id=优缺点-21><a class=headerlink href=#优缺点-21 title=优缺点></a>优缺点</h4><ul><li><p>优点</p> <ol><li>抽象和实现的分离。<li>优秀的扩展能力。<li>实现细节对客户透明。</ol><li><p>缺点</p> <p>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p></ul><h4 id=使用场景-21><a class=headerlink href=#使用场景-21 title=使用场景></a>使用场景</h4><ol><li>不希望在抽象类和它的实现之间有一个固定的绑定关系；<li>类的抽象和实现都应该可以通过生成子类的方法加以扩充；<li>对一个抽象的实现部分的修改应对客户不产生影响，即客户代码无需重新编译；</ol><h4 id=应用实例-20><a class=headerlink href=#应用实例-20 title=应用实例></a>应用实例</h4><ol><li>猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。<li>墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。</ol><h4 id=注意事项-21><a class=headerlink href=#注意事项-21 title=注意事项></a>注意事项</h4><p><font color=red>对于两个独立变化的维度，使用桥接模式非常合适。</font><h4 id=代码实例-21><a class=headerlink href=#代码实例-21 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br></pre><td class=code><pre><span class=line><span class=comment>// 实现部分的接口，定义设备的操作</span></span><br><span class=line><span class=keyword>interface</span> <span class="title class_">Device</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">turnOn</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">turnOff</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">setVolume</span><span class=params>(<span class=type>int</span> volume)</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体实现类，电视设备</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">TV</span> <span class=keyword>implements</span> <span class="title class_">Device</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> volume;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">turnOn</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"TV is turned on."</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">turnOff</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"TV is turned off."</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setVolume</span><span class=params>(<span class=type>int</span> volume)</span> {</span><br><span class=line>        <span class=built_in>this</span>.volume = volume;</span><br><span class=line>        System.out.println(<span class=string>"TV volume set to "</span> + <span class=built_in>this</span>.volume);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 具体实现类，收音机设备</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Radio</span> <span class=keyword>implements</span> <span class="title class_">Device</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> volume;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">turnOn</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Radio is turned on."</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">turnOff</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Radio is turned off."</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setVolume</span><span class=params>(<span class=type>int</span> volume)</span> {</span><br><span class=line>        <span class=built_in>this</span>.volume = volume;</span><br><span class=line>        System.out.println(<span class=string>"Radio volume set to "</span> + <span class=built_in>this</span>.volume);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 抽象类，定义远程控制器</span></span><br><span class=line><span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">RemoteControl</span> {</span><br><span class=line>    <span class=keyword>protected</span> Device device;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RemoteControl</span><span class=params>(Device device)</span> {</span><br><span class=line>        <span class=built_in>this</span>.device = device;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">turnOn</span><span class=params>()</span> {</span><br><span class=line>        device.turnOn();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">turnOff</span><span class=params>()</span> {</span><br><span class=line>        device.turnOff();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setVolume</span><span class=params>(<span class=type>int</span> volume)</span> {</span><br><span class=line>        device.setVolume(volume);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 扩展的抽象类，增加更多控制功能</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">AdvancedRemoteControl</span> <span class=keyword>extends</span> <span class="title class_">RemoteControl</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AdvancedRemoteControl</span><span class=params>(Device device)</span> {</span><br><span class=line>        <span class=built_in>super</span>(device);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">mute</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Muting the device."</span>);</span><br><span class=line>        device.setVolume(<span class=number>0</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>Device</span> <span class=variable>tv</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TV</span>();</span><br><span class=line>        <span class=type>RemoteControl</span> <span class=variable>tvRemote</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">RemoteControl</span>(tv);</span><br><span class=line></span><br><span class=line>        tvRemote.turnOn();</span><br><span class=line>        tvRemote.setVolume(<span class=number>10</span>);</span><br><span class=line>        tvRemote.turnOff();</span><br><span class=line></span><br><span class=line>        System.out.println(<span class=string>"---"</span>);</span><br><span class=line></span><br><span class=line>        <span class=type>Device</span> <span class=variable>radio</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Radio</span>();</span><br><span class=line>        <span class=type>AdvancedRemoteControl</span> <span class=variable>radioRemote</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AdvancedRemoteControl</span>(radio);</span><br><span class=line></span><br><span class=line>        radioRemote.turnOn();</span><br><span class=line>        radioRemote.setVolume(<span class=number>5</span>);</span><br><span class=line>        radioRemote.mute();</span><br><span class=line>        radioRemote.turnOff();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-3-7、Flyweight（享元模式）><a class=headerlink href=#1-3-7、Flyweight（享元模式） title=1.3.7、Flyweight（享元模式）></a>1.3.7、Flyweight（享元模式）</h3><h4 id=定义-19><a class=headerlink href=#定义-19 title=定义></a>定义</h4><p>享元模式的核心思想是 共享相似对象，通过共享相同的对象来减少对象的创建。当多个对象本质上相同时，可以使用一个对象来共享，而并非每次都创建一个新对象。<h4 id=结构-20><a class=headerlink href=#结构-20 title=结构></a>结构</h4><ul><li>享元接口<li>具体享元类<li>非共享享元类<li>享元工厂</ul><h4 id=何时使用-22><a class=headerlink href=#何时使用-22 title=何时使用></a>何时使用</h4><ol><li>系统中有大量对象。<li>这些对象消耗大量内存。<li>这些对象的状态大部分可以外部化。<li>这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中拿出来时，每组对象都可用一个对象来代替。<li>系统不依赖于对象身份，因对象不可分辨。</ol><h4 id=优缺点-22><a class=headerlink href=#优缺点-22 title=优缺点></a>优缺点</h4><ul><li>优点：减少对象创建，降低内存消耗，效率提高。<li>缺点：提高了系统复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统混乱。</ul><h4 id=使用场景-22><a class=headerlink href=#使用场景-22 title=使用场景></a>使用场景</h4><ol><li>系统有大量相似对象。<li>需要缓冲池的场景。</ol><h4 id=应用实例-21><a class=headerlink href=#应用实例-21 title=应用实例></a>应用实例</h4><ol><li>JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。<li>数据库的数据池。</ol><h4 id=源码应用-5><a class=headerlink href=#源码应用-5 title=源码应用></a>源码应用</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>String / Integer / Long....</span><br><span class=line>com.sun.org.apache.bcel.internal.generic.InstructionConstants</span><br></pre></table></figure><h4 id=注意事项-22><a class=headerlink href=#注意事项-22 title=注意事项></a>注意事项</h4><ol><li><font color=red>注意划分外部状态和内部状态，否则可能会引起线程安全问题。</font><li><font color=red>这些类必须有一个工厂对象加以控制。</font></ol><h4 id=代码实例-22><a class=headerlink href=#代码实例-22 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br></pre><td class=code><pre><span class=line><span class=comment>// 享元类，表示树的共享部分（类型和颜色）</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">TreeType</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> String color;</span><br><span class=line>    <span class=keyword>private</span> String texture;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">TreeType</span><span class=params>(String name, String color, String texture)</span> {</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>        <span class=built_in>this</span>.color = color;</span><br><span class=line>        <span class=built_in>this</span>.texture = texture;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">draw</span><span class=params>(<span class=type>int</span> x, <span class=type>int</span> y)</span> {</span><br><span class=line>        System.out.println(<span class=string>"Drawing tree of type: "</span> + name + <span class=string>" at ("</span> + x + <span class=string>", "</span> + y + <span class=string>")"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 享元工厂类，负责管理和创建享元类对象</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">TreeFactory</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> Map&LTString, TreeType> treeTypes = <span class=keyword>new</span> <span class="title class_">HashMap</span><>();</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> TreeType <span class="title function_">getTreeType</span><span class=params>(String name, String color, String texture)</span> {</span><br><span class=line>        <span class=type>TreeType</span> <span class=variable>result</span> <span class=operator>=</span> treeTypes.get(name);</span><br><span class=line>        <span class=keyword>if</span> (result == <span class=literal>null</span>) {</span><br><span class=line>            result = <span class=keyword>new</span> <span class="title class_">TreeType</span>(name, color, texture);</span><br><span class=line>            treeTypes.put(name, result);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> result;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 非共享的树类，包含位置等外部状态</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">Tree</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> x;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> y;</span><br><span class=line>    <span class=keyword>private</span> TreeType type;  <span class=comment>// 共享的内部状态</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Tree</span><span class=params>(<span class=type>int</span> x, <span class=type>int</span> y, TreeType type)</span> {</span><br><span class=line>        <span class=built_in>this</span>.x = x;</span><br><span class=line>        <span class=built_in>this</span>.y = y;</span><br><span class=line>        <span class=built_in>this</span>.type = type;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">draw</span><span class=params>()</span> {</span><br><span class=line>        type.draw(x, y);  <span class=comment>// 使用共享的TreeType对象来绘制树</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        List&LTTree> forest = <span class=keyword>new</span> <span class="title class_">ArrayList</span><>();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 创建大量的树，并共享相同的TreeType对象</span></span><br><span class=line>        <span class=type>TreeType</span> <span class=variable>oakType</span> <span class=operator>=</span> TreeFactory.getTreeType(<span class=string>"Oak"</span>, <span class=string>"Green"</span>, <span class=string>"Rough"</span>);</span><br><span class=line>        <span class=type>TreeType</span> <span class=variable>pineType</span> <span class=operator>=</span> TreeFactory.getTreeType(<span class=string>"Pine"</span>, <span class=string>"Dark Green"</span>, <span class=string>"Smooth"</span>);</span><br><span class=line></span><br><span class=line>        forest.add(<span class=keyword>new</span> <span class="title class_">Tree</span>(<span class=number>10</span>, <span class=number>20</span>, oakType));</span><br><span class=line>        forest.add(<span class=keyword>new</span> <span class="title class_">Tree</span>(<span class=number>30</span>, <span class=number>40</span>, oakType));</span><br><span class=line>        forest.add(<span class=keyword>new</span> <span class="title class_">Tree</span>(<span class=number>50</span>, <span class=number>60</span>, pineType));</span><br><span class=line>        forest.add(<span class=keyword>new</span> <span class="title class_">Tree</span>(<span class=number>70</span>, <span class=number>80</span>, pineType));</span><br><span class=line></span><br><span class=line>        <span class=comment>// 绘制森林中的树</span></span><br><span class=line>        <span class=keyword>for</span> (Tree tree : forest) {</span><br><span class=line>            tree.draw();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=1-4、设计模式间的关系><a class=headerlink href=#1-4、设计模式间的关系 title=1.4、设计模式间的关系></a>1.4、设计模式间的关系</h2><p><img alt=设计模式间的关系 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210420203056818.png?token=AIGEF3L6P4ZSWPM3RWVOD3LEZZZVE><h1 id=2、设计模式原则><a class=headerlink href=#2、设计模式原则 title=2、设计模式原则></a>2、设计模式原则</h1><h2 id=2-1、开闭原则（OCP）><a class=headerlink href=#2-1、开闭原则（OCP） title=2.1、开闭原则（OCP）></a>2.1、开闭原则（OCP）</h2><h3 id=2-1-1、简介><a class=headerlink href=#2-1-1、简介 title=2.1.1、简介></a>2.1.1、简介</h3><p><strong>开闭原则规定：软件中的对象（类，模块，函数等）对于扩展应该开放，对于修改应该封闭。</strong>也就是说，应该在不修改类源代码前提下来更改类的行为。<h3 id=2-1-2、分类><a class=headerlink href=#2-1-2、分类 title=2.1.2、分类></a>2.1.2、分类</h3><ul><li><p><strong>梅耶开闭原则</strong>：梅耶原则 提倡继承实现。具体实现可以通过继承来重用，但是接口规格不必如此。已存在的实现对于修改是封闭的，但是新的实现不必实现原有接口。</p><li><p><strong>多态开闭原则</strong>：多态开闭原则 倡导继承抽象类。接口规约可以通过继承来重用，但是实现不必如此。已存在的接口对于修改是封闭的，并且新的实现必须至少实现那个接口。</p></ul><h2 id=2-2、单一职责原则（SRP）><a class=headerlink href=#2-2、单一职责原则（SRP） title=2.2、单一职责原则（SRP）></a>2.2、单一职责原则（SRP）</h2><h3 id=2-2-1、简介><a class=headerlink href=#2-2-1、简介 title=2.2.1、简介></a>2.2.1、简介</h3><p>面向对象五个基本原则（SOLID）之一。<p><strong>单一职责原则（SRP：Single responsibility principle）又称单一功能原则。该原则规定：一个类或者模块只负责完成一个职责。</strong><p>单一职责原则由罗伯特·C·马丁（Robert C. Martin）于《敏捷软件开发：原则、模式和实践》一书中给出。马丁表示此原则是基于汤姆·狄马克(Tom DeMarco)和Meilir Page-Jones的=著作中的 内聚性原则 来实现。<h3 id=2-2-2、问题由来><a class=headerlink href=#2-2-2、问题由来 title=2.2.2、问题由来></a>2.2.2、问题由来</h3><p>之所以会出现单一职责原则就是因为在软件设计时会出现以下类似场景：<p>T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。也就是说职责P1和P2耦合在了一起。<h3 id=2-2-3、产生原因><a class=headerlink href=#2-2-3、产生原因 title=2.2.3、产生原因></a>2.2.3、产生原因</h3><p>很多耦合常常发生在不经意之间，原因就是 职责扩散：因为某种原因，某一职责被分化为颗粒度更细多个职责。<h3 id=2-2-4、解决方法><a class=headerlink href=#2-2-4、解决方法 title=2.2.4、解决方法></a>2.2.4、解决方法</h3><p>遵守单一职责原则，将不同的职责封装到不同的类或模块中。<h2 id=2-3、依赖倒置原则（DIP）><a class=headerlink href=#2-3、依赖倒置原则（DIP） title=2.3、依赖倒置原则（DIP）></a>2.3、依赖倒置原则（DIP）</h2><h3 id=2-3-1、简介><a class=headerlink href=#2-3-1、简介 title=2.3.1、简介></a>2.3.1、简介</h3><p><strong>开闭原则的基础。依赖倒置原则（Dependence Inversion Principle）是指：程序要依赖于抽象接口，不要依赖于具体实现。</strong>简单说就是一定要面向抽象编程，而不要面向实现编程，这样就降低了客户与实现模块间的耦合。<h3 id=2-3-2、意图><a class=headerlink href=#2-3-2、意图 title=2.3.2、意图></a>2.3.2、意图</h3><p><strong>面向过程开发，上层调用下层，上层依赖于下层，当下层剧烈变动时上层也要跟着变动，这就会降低模块的复用性且大大提高了开发成本</strong><p>面向对象开发解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。<h3 id=2-3-3、注意事项><a class=headerlink href=#2-3-3、注意事项 title=2.3.3、注意事项></a>2.3.3、注意事项</h3><ol><li>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。<li>抽象不应该依赖于具体，而是具体应该依赖于抽象。</ol><h2 id=2-4、接口隔离原则（ISP）><a class=headerlink href=#2-4、接口隔离原则（ISP） title=2.4、接口隔离原则（ISP）></a>2.4、接口隔离原则（ISP）</h2><h3 id=2-4-1、简介><a class=headerlink href=#2-4-1、简介 title=2.4.1、简介></a>2.4.1、简介</h3><p>接口隔离原则（Interface Segregation Principle，ISP）是面向对象设计中的一个原则，它强调的是 <strong>客户端不应该依赖它不需要的接口，将臃肿的接口拆分为更小、更具体的接口，避免接口的冗余</strong>。<p>接口隔离原则的核心思想是 <strong>定义接口时要精简、单一，不应该包含不需要的方法，这样可以减少类与接口之间的耦合，提高代码可读性、可维护性、可扩展性</strong>。<p>接口隔离原则可以参考如下几点来实现：<ul><li>将庞大的接口拆分为多个小接口。<li>根据需要只使用特定的接口。<li>接口的职责要单一。</ul><h3 id=2-4-2、优点><a class=headerlink href=#2-4-2、优点 title=2.4.2、优点></a>2.4.2、优点</h3><p>接口隔离原则可以使得系统的接口设计更加灵活、可扩展和易于维护。能降低类与接口之间的耦合度，减少不必要的依赖关系，使得系统的各个模块能够独立地发展与演化。<h2 id=2-5、里氏替换原则（LSP）><a class=headerlink href=#2-5、里氏替换原则（LSP） title=2.5、里氏替换原则（LSP）></a>2.5、里氏替换原则（LSP）</h2><h3 id=2-5-1、简介><a class=headerlink href=#2-5-1、简介 title=2.5.1、简介></a>2.5.1、简介</h3><p>里氏代换原则（Liskov Substitution Principle LSP）是指：<strong>基类可以出现的地方，子类也可以出现</strong>。<p>LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。<em><strong>里氏代换原则是对“开闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化</strong></em>。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。<h3 id=2-5-2、注意事项><a class=headerlink href=#2-5-2、注意事项 title=2.5.2、注意事项></a>2.5.2、注意事项</h3><p><strong>设计时，尽量继承抽象类，而不要继承具体类。</strong>如果从继承等级树来看，所有叶子节点应当是具体类，而所有的树枝节点应当是抽象类或者接口。当然这只是一般性的指导原则，使用时还需具体情况具体分析。<p>简单的理解为一个软件实体如果使用的是一个父类，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，软件里面，把父类都替换成它的子类，程序的行为没有变化。<h2 id=2-6、迪米特原则（LOD）><a class=headerlink href=#2-6、迪米特原则（LOD） title=2.6、迪米特原则（LOD）></a>2.6、迪米特原则（LOD）</h2><h3 id=2-6-1、简介><a class=headerlink href=#2-6-1、简介 title=2.6.1、简介></a>2.6.1、简介</h3><p>迪米特原则（Law Of Demeter）也被称为最少知道原则，是面向对象设计中的一个原则。迪米特原则的核心思想是 <strong>降低对象之间的耦合，使得对象之间的通信变得简单和直接</strong>。<p><strong>迪米特原则的目标是实现高内聚、低耦合</strong>。具体包括如下几点：<ul><li>减少对象之间的耦合<li>保护对象的隐私<li>提高代码可维护性</ul><p>迪米特原则可以参考如下几个方面来实现：<ul><li>在类中尽量减少对其它类的引用，不应该直接引用与本类关系较远的类。<li>通过封装和信息隐藏，将对象的内部细节隐藏起来，只暴漏必要的接口。<li>使用中介者模式或外观模式来降低对象之间的直接依赖关系。</ul><h2 id=2-7、合成复用原则（CRP）><a class=headerlink href=#2-7、合成复用原则（CRP） title=2.7、合成复用原则（CRP）></a>2.7、合成复用原则（CRP）</h2><h3 id=2-7-1、简介><a class=headerlink href=#2-7-1、简介 title=2.7.1、简介></a>2.7.1、简介</h3><p>合成复用原则是设计模式中的一个原则，也称之为CRP原则。它指的是在软件设计中，<strong>优先使用对象组合而不是继承来实现代码的复用</strong>。<p>合成复用原则的核心思想是：<strong>通过将现有的对象组合成新的对象，实现代码复用和灵活性</strong>。相对于通过继承实现复用，使用对象组合可以更好的控制类之间的关系，且可以动态改变对象的行为。<h3 id=2-7-2、优点><a class=headerlink href=#2-7-2、优点 title=2.7.2、优点></a>2.7.2、优点</h3><p>合成复用有如下几个优点：<ul><li>减少类之间的耦合：继承会导致子类和父类之间的紧耦合，而对象组合可以在对象之间建立松散的关系，减少类之间的依赖。<li>提高系统灵活性：对象组合可以动态改变对象的行为，通过替换组合中的对象，可以灵活扩展和修改系统的功能。<li>更好地复用代码：组合现有对象，可以构建出具有不同功能的新对象，实现代码复用。<li>更好的维护：对象组合关系松散，需要修改系统行为时，可以更容易的定位和修改相关的对象。</ul></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/10/12/Java%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/10/12/Java%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/ itemprop=url>Java系列-Java基础</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-10-12 11:23:46" datetime=2024-10-12T11:23:46+08:00>2024-10-12</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2024-10-10 15:34:51" datetime=2024-10-10T15:34:51+08:00 itemprop=dateModified>2024-10-10</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Java%E5%9F%BA%E7%A1%80/ itemprop=url rel=index><span itemprop=name>Java基础</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=数据存储><a class=headerlink href=#数据存储 title=数据存储></a>数据存储</h1><h2 id=概述><a class=headerlink href=#概述 title=概述></a>概述</h2><p><strong>数据在计算机中是以二进制的形式来存储，计算、赋值等操作是二进制间的操作</strong>。<h2 id=进制><a class=headerlink href=#进制 title=进制></a>进制</h2><h3 id=简介><a class=headerlink href=#简介 title=简介></a>简介</h3><p>进制指的是数字满多少进1。比如，二进制表示满2进1，八进制表示满8进1，十进制表示满10进1，十六进制表示满16进1。<p>不同类型的进制数据在Java中的定义公式也不同，它们的区别如下：<ul><li>二进制：由数字0和1组成，以0b开头。<li>八进制：由数字0~7组成，以0开头。<li>十进制：由数字0~9组成，不加任何前缀。<li>十六进制：由数字0<del>9和字母a</del>f组成，以0X开头。</ul><blockquote><p>Java7开始支持上面这种格式的写法。</blockquote><h3 id=进制转换><a class=headerlink href=#进制转换 title=进制转换></a>进制转换</h3><p><strong>任意进制转为十进制的规则为：计算每个<code>系数*基数的权次幂</code>，相加结果就是十进制。</strong>这里的系数就是每个位置上的数字。这里的基数就是进制类型，二进制就是2，八进制就是8。这里的权表示原始进制类型的数字列表从右到左，权从0开始依次加1。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment>// 二进制转十进制</span></span><br><span class=line><span class=number>1010</span> -> <span class=number>0</span>*<span class=number>2</span>^<span class=number>0</span> + <span class=number>1</span>*<span class=number>2</span>^<span class=number>1</span> + <span class=number>0</span>*<span class=number>2</span>^<span class=number>2</span> + <span class=number>1</span>*<span class=number>2</span>^<span class=number>3</span> = <span class=number>0</span> + <span class=number>2</span> + <span class=number>0</span> + <span class=number>8</span> = <span class=number>10</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// 八进制转十进制</span></span><br><span class=line><span class=number>1010</span> -> <span class=number>0</span>*<span class=number>8</span>^<span class=number>0</span> + <span class=number>1</span>*<span class=number>8</span>^<span class=number>1</span> + <span class=number>0</span>*<span class=number>8</span>^<span class=number>2</span> + <span class=number>1</span>*<span class=number>8</span>^<span class=number>3</span> = <span class=number>0</span> + <span class=number>8</span> + <span class=number>0</span> + <span class=number>512</span> = <span class=number>520</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// 十六进制转十进制</span></span><br><span class=line>abc -> <span class=number>12</span>*<span class=number>16</span>^<span class=number>0</span> + <span class=number>11</span>*<span class=number>16</span>^<span class=number>1</span> + <span class=number>10</span>*<span class=number>16</span>^<span class=number>2</span> = <span class=number>2748</span>;</span><br></pre></table></figure><p><strong>十进制转其它进制类型的方法为除基取余法</strong>，规则为：不断除以基数（基数表示进制类型，几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼接起来即可得到对应的进制数。<h1 id=数据类型><a class=headerlink href=#数据类型 title=数据类型></a>数据类型</h1><h2 id=概述-1><a class=headerlink href=#概述-1 title=概述></a>概述</h2><p>Java中提供了基本数据类型和引用数据类型两个类别。<p><strong>基本数据类型共有8个：boolean、byte、short、char、float、int、long、double</strong>。它们的包装类分别为：Boolean、Byte、Short、Character、Float、Integer、Long、Double。按类别又分为4种：整数型（byte/short/int/long）、浮点型（float/double）、字符（char）、布尔（boolean）。<p><strong>引用数据类型共有3个：数组、类、接口</strong>。<table><thead><tr><th align=center>数据类型<th align=center>大小（字节）<th align=center>默认值<th align=center>最小值<th align=center>最大值<tbody><tr><td align=center>boolean<td align=center>1个字节<td align=center>false<td align=center><td align=center><tr><td align=center>byte<td align=center>1个字节<td align=center>0<td align=center>-128<td align=center>127<tr><td align=center>short<td align=center>2个字节<td align=center>0<td align=center>-32768<td align=center>32767<tr><td align=center>char<td align=center>2个字节<td align=center>‘\u0000’（0）<td align=center>‘\u0000’（0）<td align=center>‘\uFFFF’（65535）<tr><td align=center>float<td align=center>4个字节<td align=center>0.0F<td align=center>1.4E-45<td align=center>3.4028235E38<tr><td align=center>int<td align=center>4个字节<td align=center>0<td align=center>-2147483648<td align=center>2147483647<tr><td align=center>long<td align=center>8个字节<td align=center>0.0<td align=center>-2^63<td align=center>2^63-1<tr><td align=center>double<td align=center>8个字节<td align=center>0.0D<td align=center>4.9E-324<td align=center>1.7976931348623157E308</table><p>基本类型和引用类型在存储数据时有区别：<ul><li>基本类型：数据值存储在自己的空间中，赋值给其它基本类型变量时也是赋值的真实数据值。<li>引用类型：数据值存储在其它空间中，自己空间中存储的是该数据在空间中的地址。赋值给其它引用类型变量时也是赋值的地址。</ul><h2 id=类型转换><a class=headerlink href=#类型转换 title=类型转换></a>类型转换</h2><h3 id=简介-1><a class=headerlink href=#简介-1 title=简介></a>简介</h3><p><strong>Java中的各种类型的数据在进行计算和赋值时会进行类型的转换，这种转换分为两种：隐式自动转换 和 强制显式转换</strong>。<p><font color=red>注意：不能对boolean类型进行类型转换。</font><h3 id=隐式转换><a class=headerlink href=#隐式转换 title=隐式转换></a>隐式转换</h3><p><strong>隐式转换指的是把一个取值范围小的数值类型转成取值范围大的数值类型</strong>。<p>隐式转换有如下一些规则：<ul><li>取值范围小的和取值范围大的数值进行运算前，会先将取值小的数值类型提升为大的，然后再进行计算。<li>byte、short、char三种类型的值在运算时，会先将它们都转为int类型，然后再进行计算。</ul><blockquote><p>char类型字符在与数字进行计算时，会先得到字符在ASCII码表中对应的十进制数字，然后基于该数字来与其它数值进行计算，计算规则符合前面说的。</blockquote><p>代码示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=comment>// 示例1</span></span><br><span class=line><span class=type>int</span> <span class=variable>a</span> <span class=operator>=</span> <span class=number>1</span>;</span><br><span class=line><span class=type>double</span> <span class=variable>d</span> <span class=operator>=</span> a; <span class=comment>// 将int类型自动隐式转换为double类型。</span></span><br><span class=line></span><br><span class=line><span class=comment>// 示例2</span></span><br><span class=line><span class=type>int</span> <span class=variable>a</span> <span class=operator>=</span> <span class=number>10</span>;</span><br><span class=line><span class=type>double</span> <span class=variable>d</span> <span class=operator>=</span> <span class=number>20</span>;</span><br><span class=line><span class=type>double</span> <span class=variable>result</span> <span class=operator>=</span> a + d; <span class=comment>// 先将a转为double类型，然后与d计算，结果值为double类型。</span></span><br><span class=line></span><br><span class=line><span class=comment>// 示例3</span></span><br><span class=line><span class=type>byte</span> <span class=variable>b1</span> <span class=operator>=</span> <span class=number>10</span>;</span><br><span class=line><span class=type>byte</span> <span class=variable>b2</span> <span class=operator>=</span> <span class=number>30</span>;</span><br><span class=line><span class=type>int</span> <span class=variable>result</span> <span class=operator>=</span> b1 + b2; <span class=comment>// 先将b1和b2都转为int类型，然后再计算，结果值为int类型。</span></span><br></pre></table></figure><h3 id=强制转换><a class=headerlink href=#强制转换 title=强制转换></a>强制转换</h3><p><strong>强制转换指的是将取值范围大的数值类型转为取值范围小的数值类型</strong>，强制转换的格式为：<code>目标数据类型 变量名 = (目标数据类型)被强转的数据;</code>。<blockquote><p>将取值范围大的数值类型转为取值范围小的数值类型，这种情况理论上不允许，但可以通过强制转换来实现。但要注意的是，<strong>对于浮点类型，强制转换后，数据的精度会丢失</strong>。<p><strong>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入。</strong></blockquote><p>代码示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>double</span> <span class=variable>d</span> <span class=operator>=</span> <span class=number>12.3</span>;</span><br><span class=line><span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> (<span class=type>int</span>)d;	<span class=comment>// 12</span></span><br></pre></table></figure><h2 id=原码、反码、补码><a class=headerlink href=#原码、反码、补码 title=原码、反码、补码></a>原码、反码、补码</h2><h3 id=原码><a class=headerlink href=#原码 title=原码></a>原码</h3><p><strong>原码指的是十进制数据的二进制表现形式，最左边的一位是符号位，0表示正数，1表示负数</strong>。<p>利用原码进行计算时，如果参与计算的数为正数，那么没有问题，如果参与计算的数为负数，那么结果就会出错，实际运算的方向与正确的方向相反。<p>为了解决这种问题，提出了反码。<h3 id=反码><a class=headerlink href=#反码 title=反码></a>反码</h3><p>正数的反码不变，负数的反码是在原码基础上，符号位不变，其它位取反，即0变1，1变0。<p>反码在参与计算时，如果计算结果不跨0，则没有问题，如果结果跨0，则与正确的结果会有1的偏差。<p>为了解决这种问题，提出了补码。<h3 id=补码><a class=headerlink href=#补码 title=补码></a>补码</h3><p>正数的补码不变，负数的补码是在反码基础上+1。补码可以多记录一个特殊值-128，该数据在1个字节下，没有原码和反码。<h2 id=String><a class=headerlink href=#String title=String></a>String</h2><h3 id=简介-2><a class=headerlink href=#简介-2 title=简介></a>简介</h3><p>String是Java定义好的java.lang包中的一个String字符串类。该字符串类是不可变的，每次修改内容都会创建一个新的String对象。<h3 id=创建String对象><a class=headerlink href=#创建String对象 title=创建String对象></a>创建String对象</h3><p>创建String对象的方式有两种：直接赋值 和 使用new关键字。<ul><li>直接赋值：String str = “abc”;<li>new创建：String str = new String(空参/字符串/char数组/byte数组);</ul><h3 id=StringJoiner><a class=headerlink href=#StringJoiner title=StringJoiner></a>StringJoiner</h3><p><strong>JDK8开始提供了一个类StringJoiner。</strong>它与StringBuilder一样，可看作是一个容器，创建StringJoiner对象后，里面的内容是可变的。StringJoiner的作用是提高字符串的操作效率。<p>通过构造方法并指定形参可创建一个符合需求的StringJoiner对象，通过add方法即可添加数据，最终结果就是想要的效果。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// 创建对象</span></span><br><span class=line><span class=type>StringJoiner</span> <span class=variable>sj</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StringJoiner</span>(间隔符号);</span><br><span class=line><span class=type>StringJoiner</span> <span class=variable>sj2</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StringJoiner</span>(间隔符号，开始符号，结束符号);</span><br><span class=line><span class=type>StringJoiner</span> <span class=variable>sj3</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StringJoiner</span>(<span class=string>","</span>，<span class=string>"["</span>，<span class=string>"]"</span>);</span><br><span class=line>sj3.add(<span class=string>"a"</span>).add(<span class=string>"b"</span>).add(<span class=string>"c"</span>);</span><br><span class=line>System.out.println(sj3); <span class=comment>// [a, b, c]</span></span><br></pre></table></figure><h3 id=底层原理><a class=headerlink href=#底层原理 title=底层原理></a>底层原理</h3><p>字符串存储的底层原理：直接赋值会复用字符串常量池中的内容，而new出来的会在堆中开辟一个空间来存储。<p>双等号比较的底层原理：基本类型比较的是值，引用类型比较的是地址。<p>字符串拼接的底层原理：<ul><li><strong>拼接成员全是字符串字面量</strong>：会触发字符串优化机制，编译期就可以得到拼接结果，最终会把结果放进字符串常量池中。<li><strong>拼接成员中存在对象引用</strong>：JDK8之前会使用StringBuilder来拼接。JDK8开始做了优化，会先预估字符串拼接结果的长度，然后基于该长度创建一个数组，然后将各个参与成员字符串放进数组中，最终根据该数组再创建一个代表拼接结果的字符串。不论如何，最终会在堆中创建一个对象，拼接结果会保存在堆中。</ul><p>上面第二种情况中，尽管JDK8做了优化，但底层依然会创建多个对象，效率并没有大的提升。所以，<strong>对于字符串拼接的需求，推荐使用StringBuilder来实现</strong>。<p><strong>StringBuilder为何高效？</strong><p>当创建一个StringBuilder对象后，底层会创建一个容量为16的字节数组，然后将要添加的字符在ASCII码表中对应的十进制数字按顺序放入字节数组中，当空间满时会进行扩容，新容量的计算公式为：<code>旧容量*2+2;</code>。当要添加的元素数量超过扩容后的容量时以要添加元素的数量为大小来扩容。<h2 id=BigInteger><a class=headerlink href=#BigInteger title=BigInteger></a>BigInteger</h2><h3 id=注意事项><a class=headerlink href=#注意事项 title=注意事项></a>注意事项</h3><ul><li>如果BigInteger表示的数字<strong>没有超出long的范围</strong>，可以<strong>使用静态方法</strong>获取；<li>如果BigInteger表示的数字<strong>超出long的范围</strong>，可以<strong>使用构造方法</strong>获取，推荐直接使用该种方式；<li>BigInteger对象创建后，内部的值不能发生改变；<li>BigInteger对象经过计算后会得到一个新的对象；</ul><h3 id=常用操作><a class=headerlink href=#常用操作 title=常用操作></a>常用操作</h3><ul><li>加/减/乘/除：add/subtract/multiply/divide；<li>比较：equals/max/min；<li>次幂：pow；<li>转为基本类型：intValue/doubleValue/…；</ul><h3 id=底层原理-1><a class=headerlink href=#底层原理-1 title=底层原理></a>底层原理</h3><p>如何存储一个超出long范围的数字呢？<p>解决方法是：<strong>先将源数字转为二进制，然后以32位的长度分组，然后再将每一组的二进制位转为10进制数字，多个组就得到了多个10进制数字，最后再将这些十进制数字放入一个int数组中保存</strong>。<h2 id=BigDecimal><a class=headerlink href=#BigDecimal title=BigDecimal></a>BigDecimal</h2><h3 id=前言><a class=headerlink href=#前言 title=前言></a>前言</h3><p>小数在计算机中是通过二进制进行存储，它的二进制位数量可能非常多，在与其它小数进行计算时，无法得出准确结果。<p>为了解决小数计算无法得出准确结果的问题，BigDecimal就出现了，它可以解决这种问题。<h3 id=注意事项-1><a class=headerlink href=#注意事项-1 title=注意事项></a>注意事项</h3><ul><li>如果BigDecimal表示的数字<strong>没有超出double的范围</strong>，可以<strong>使用静态方法</strong>获取对象；<li>如果BigDecimal表示的数字<strong>超出double的范围</strong>，可以<strong>使用构造方法</strong>获取对象；<li>BigDecimal默认已经缓存好整数0<del>10的对象，如果获取整数0</del>10的BigDecimal对象，那么会直接返回已经创建好的对象。</ul><h3 id=常用操作-1><a class=headerlink href=#常用操作-1 title=常用操作></a>常用操作</h3><ul><li>加/减/乘/除：add/subtract/multiply/divide；<li>除：divide(x)/divide(x, 精确位，进制算法)；</ul><h3 id=底层原理-2><a class=headerlink href=#底层原理-2 title=底层原理></a>底层原理</h3><p>如何存储一个超出double范围的小数呢？<p>解决方法是：<strong>先将小数转为字符串，然后将字符串转为字符数组，拿到每个字符在ASSCI码表中对应的数值，然后将这些数值放入一个int数组中存储</strong>。<h1 id=条件结构><a class=headerlink href=#条件结构 title=条件结构></a>条件结构</h1><h2 id=判断><a class=headerlink href=#判断 title=判断></a>判断</h2><h3 id=概述-2><a class=headerlink href=#概述-2 title=概述></a>概述</h3><p>判断结构有多种，它们为：if、switch等。<h3 id=switch><a class=headerlink href=#switch title=switch></a>switch</h3><p><strong>JDK5开始switch支持枚举类型，JDK7开始支持字符串类型。</strong><p>switch使用格式与示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=type>int</span> <span class=variable>number</span> <span class=operator>=</span> <span class=number>10</span>;</span><br><span class=line><span class=keyword>switch</span>(number){</span><br><span class=line>  <span class=keyword>case</span> <span class=number>1</span>:</span><br><span class=line>        <span class=comment>// 操作1</span></span><br><span class=line>        <span class=keyword>break</span>;</span><br><span class=line>  <span class=keyword>case</span> <span class=number>2</span>:</span><br><span class=line>        <span class=comment>// 操作2</span></span><br><span class=line>        <span class=keyword>break</span>;</span><br><span class=line>  <span class=keyword>default</span>:</span><br><span class=line>        <span class=comment>// 默认操作</span></span><br><span class=line>}</span><br></pre></table></figure><p>switch使用注意事项如下：<ul><li>case穿透问题：每个分支中没有写break语句造成。</ul><p><strong>JDK12开始对switch语法结构进行了优化，可以直接使用小箭头+大括号即可，大括号中编写分支逻辑。</strong>详情示例可参考如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment>// 如果括号{}中代码只有一行，那么括号也可以省略。</span></span><br><span class=line><span class=type>int</span> <span class=variable>number</span> <span class=operator>=</span> <span class=number>10</span>;</span><br><span class=line><span class=keyword>switch</span>(number){</span><br><span class=line>  <span class=keyword>case</span> <span class=number>1</span>, <span class=number>2</span>, <span class=number>3</span>, <span class=number>4</span>, <span class=number>5</span> -> {}</span><br><span class=line>  <span class=keyword>case</span> <span class=number>6</span>, <span class=number>7</span> -> {}</span><br><span class=line>  <span class=keyword>case</span> <span class=number>8</span> -> {}</span><br><span class=line>  <span class=keyword>default</span> -> {}</span><br><span class=line>}</span><br></pre></table></figure><h2 id=循环><a class=headerlink href=#循环 title=循环></a>循环</h2><h3 id=概述-3><a class=headerlink href=#概述-3 title=概述></a>概述</h3><p>循环有多种，它们为：for、while、do…while。<h1 id=包><a class=headerlink href=#包 title=包></a>包</h1><h2 id=何为包><a class=headerlink href=#何为包 title=何为包></a>何为包</h2><p>包就是文件夹。它用来管理分类各种不同功能的Java类，方便维护。<p>包名的规则通常为：公司域名反写 + 模块或作用名。比如：com.google.util。<p><strong>包名+类名</strong>表示一个类的<strong>全类名或全限定名</strong>。<h1 id=修饰符><a class=headerlink href=#修饰符 title=修饰符></a>修饰符</h1><h2 id=final><a class=headerlink href=#final title=final></a>final</h2><h3 id=定义><a class=headerlink href=#定义 title=定义></a>定义</h3><p>final表示最终，不可改变。<h3 id=作用><a class=headerlink href=#作用 title=作用></a>作用</h3><p>final可以修饰类、变量、方法，当修饰它们时会对它们添加如下几个规则：<ul><li>变量：final修饰后通常称其为<strong>常量</strong>，该常量只能在被定义时显式赋值一次；<li>方法：final修饰后，该方法不能被重写；<li>类：final修饰后，该类不能被继承；</ul><h3 id=常量><a class=headerlink href=#常量 title=常量></a>常量</h3><p>常量一般作为系统配置信息，方便维护，提高可读性。<p>常量的命名规则：单词全部大写，多个单词时，单词间用下划线隔开。<h2 id=权限修饰符><a class=headerlink href=#权限修饰符 title=权限修饰符></a>权限修饰符</h2><h3 id=定义-1><a class=headerlink href=#定义-1 title=定义></a>定义</h3><p>权限修饰符用来控制一个成员是否可以被访问。它可以修饰内部类、变量、构造方法、方法。<h3 id=分类及作用范围><a class=headerlink href=#分类及作用范围 title=分类及作用范围></a>分类及作用范围</h3><table><thead><tr><th align=center>修饰符/分类<th align=center>同一个类<th align=center>同一个包<th align=center>其它包的子类<th align=center>其它包的无关类<tbody><tr><td align=center>private<td align=center>可以✔<td align=center><td align=center><td align=center><tr><td align=center>空着不写<td align=center>可以✔<td align=center>可以✔<td align=center><td align=center><tr><td align=center>protected<td align=center>可以✔<td align=center>可以✔<td align=center>可以✔<td align=center><tr><td align=center>public<td align=center>可以✔<td align=center>可以✔<td align=center>可以✔<td align=center>可以✔</table><h1 id=代码块><a class=headerlink href=#代码块 title=代码块></a>代码块</h1><h2 id=局部代码块><a class=headerlink href=#局部代码块 title=局部代码块></a>局部代码块</h2><h3 id=定义-2><a class=headerlink href=#定义-2 title=定义></a>定义</h3><p>局部代码块指的是写在方法中的代码块。<p>局部代码块主要用来提前结束变量的生命周期。<h2 id=构造代码块><a class=headerlink href=#构造代码块 title=构造代码块></a>构造代码块</h2><h3 id=定义-3><a class=headerlink href=#定义-3 title=定义></a>定义</h3><p>构造代码块指的是写在类成员位置的代码块。<p><strong>构造代码块先于构造器执行，且每当构造器执行时它都会执行一次</strong>。<h2 id=静态代码块><a class=headerlink href=#静态代码块 title=静态代码块></a>静态代码块</h2><h3 id=定义-4><a class=headerlink href=#定义-4 title=定义></a>定义</h3><p>静态代码块指的是写在类成员位置的被static关键字修饰的代码块。<p><strong>静态代码块会随着类的加载而加载，自动触发且仅执行一次</strong>。<h1 id=面向对象><a class=headerlink href=#面向对象 title=面向对象></a>面向对象</h1><h2 id=概述-4><a class=headerlink href=#概述-4 title=概述></a>概述</h2><p>面向对象中的面向指的是查找寻找，对象指的是具备属性和功能的个体。面向对象编程就是通过这个个体来实现某些功能和需求。<h2 id=类和对象><a class=headerlink href=#类和对象 title=类和对象></a>类和对象</h2><h3 id=简介-3><a class=headerlink href=#简介-3 title=简介></a>简介</h3><p>类是对象共同特征的描述，对象是通过类创建出来的具体物体。Java中必须先有类，才会有对象。<h3 id=定义类><a class=headerlink href=#定义类 title=定义类></a>定义类</h3><p>通过关键字<code>public class</code>可定义一个类，类中可以包括：成员变量、代码块、构造器、成员方法、内部类等。<p>一个Java类的示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Animal</span> {</span><br><span class=line>    <span class=comment>//成员变量</span></span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> Integer age;</span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 代码块</span></span><br><span class=line>    {</span><br><span class=line>        <span class=comment>//...</span></span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>static</span> {</span><br><span class=line>        <span class=comment>//...</span></span><br><span class=line>    }</span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 构造方法</span></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Animal</span><span class=params>()</span>{}</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Animal</span><span class=params>(String name)</span>{</span><br><span class=line>        <span class=comment>//...</span></span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Animal</span><span class=params>(Strng name, Integer age)</span>{</span><br><span class=line>        <span class=comment>//...</span></span><br><span class=line>    }</span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 成员方法</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">show</span><span class=params>(String name)</span>{</span><br><span class=line>        <span class=comment>//...</span></span><br><span class=line>        <span class=comment>// 布局代码块</span></span><br><span class=line>        {</span><br><span class=line>            <span class=comment>//...</span></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    </span><br><span class=line>    <span class=keyword>class</span> <span class="title class_">InnerClass</span> {</span><br><span class=line>        <span class=comment>// 内部类中存储内容的规则与外部类一样。</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=封装><a class=headerlink href=#封装 title=封装></a>封装</h2><h3 id=简介-4><a class=headerlink href=#简介-4 title=简介></a>简介</h3><p><strong>封装指的是将共同的行为或属性进行抽象汇总并定义在一个类中</strong>。<p>对象代表什么，就要封装对应的数据，并提供数据对应的行为。比如人关门行为中的关门动作应该定义在门类中，而并非定义在人类中。<p>封装好的类，内部成员变量通常会被私有访问修饰符<code>private</code>修饰，表示外界不可直接访问，若需访问需要调用类中定义的相关setXXX和getXXX方法来实现，<h3 id=this><a class=headerlink href=#this title=this></a>this</h3><p><strong>this表示当前类的地址，this在方法中使用时表示方法调用者的地址值</strong>。<p>通过关键字this可以调用类的成员变量和成员方法。不通过this直接获取变量时满足就近原则，优先检查局部变量，再检查类成员变量。<h3 id=构造方法><a class=headerlink href=#构造方法 title=构造方法></a>构造方法</h3><p>构造方法也称为构造器、构造函数，有无参构造和有参构造之分。其作用就是在创建对象时给成员变量进行赋值。<p>构造方法有如下一些特点：<ul><li>方法名与类名完全一样。<li>没有返回值类型，void也不能写。<li>没有返回值。<li>构造方法可以重载。</ul><p>注意：<strong>如果没有显式在类中定义构造方法，那么虚拟机会自动为类添加一个默认无参构造方法，且方法体中只有一个调用父类无参构造的代码。</strong><h2 id=继承><a class=headerlink href=#继承 title=继承></a>继承</h2><h3 id=何为继承><a class=headerlink href=#何为继承 title=何为继承></a>何为继承</h3><p>当同类型（Animal）的多个类（Dog、Cat等）中存在相同的成员变量、成员方法时，我们可以将这些相同的变量和方法抽取出来封装到一个类中，其它类需要这些变量和方法时直接继承该类即可默认拥有这些变量和方法，而无需在自己的类中重复编写，提高了代码的复用性。<p>Java中通过关键字<code>extends</code>可以让一个类与另一个类建立继承关系。被继承的类称为基类/超类/父类，继承的类称为派生类/子类。<p>继承的代码示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Dog</span> <span class=keyword>extends</span> <span class="title class_">Animal</span> { <span class=comment>//... }</span></span><br></pre></table></figure><p><strong>注意事项：当类与类之间存在相同的内容，且满足子类是父类的一种，此时可以考虑使用继承来优化代码，提高代码复用</strong>。<h3 id=继承特点><a class=headerlink href=#继承特点 title=继承特点></a>继承特点</h3><p>继承有如下特点：<ul><li>Java只能单继承，不能多继承，但可以多层继承。<li>Java中所有的类都直接或间接继承于Object类。<li>子类只能访问父类中非私有的成员。</ul><h3 id=可以继承的内容><a class=headerlink href=#可以继承的内容 title=可以继承的内容></a>可以继承的内容</h3><ol><li>父类的非私有成员变量；<li>父类的虚方法；（虚方法指的是非private、static、final修改的方法。）</ol><h3 id=this与super使用><a class=headerlink href=#this与super使用 title=this与super使用></a>this与super使用</h3><p>this表示当前方法调用者的地址，super表示当前类的父类。<h3 id=变量与方法的访问特点><a class=headerlink href=#变量与方法的访问特点 title=变量与方法的访问特点></a>变量与方法的访问特点</h3><ul><li>成员变量的使用：就近原则，谁近用谁；<li>构造方法：<ol><li>子类不会继承父类的构造方法；<li><strong>子类构造方法中默认先调用父类构造方法，然后再执行自己的代码</strong>；（子类构造方法中第一行代码必须是<code>super();</code>，不写默认也存在，然后再编写子类构造方法的内容。这里要注意的是如果父类中只有有参构造器，那么就必须手动显式的在子类构造器中第一行调用父类的有参构造<code>super(p1, p2, ...);</code>）</ol><li>成员方法：this调用和直接调用满足就近原则，super调用时直接访问父类；</ul><h3 id=重写><a class=headerlink href=#重写 title=重写></a>重写</h3><p>当父类中的方法无法满足子类的需求时，我们就需要在子类中重写父类的方法。子类中重写的方法上面推荐使用注解<code>@Override</code>来标注，该注解可自动检查重写语法是否正确并给出提示。<p><strong>重写的本质是使用子类中的重写方法覆盖从父类中继承过来的虚方法表中的方法</strong>。也就是说只有被添加到虚方法表中的方法才能被重写。<blockquote><p>虚方法指的是非private、static、final修饰的方法。</blockquote><p>重写注意事项<ol><li>重写方法的名称、形参必须与父类中的<strong>一致</strong>；<li>重写方法的<strong>访问权限</strong>必须<strong>大于等于</strong>父类；<li>重写方法的<strong>返回值类型</strong>必须<strong>小于等于</strong>父类；<li>只有虚方法表中的方法才能被重写；</ol><h2 id=多态><a class=headerlink href=#多态 title=多态></a>多态</h2><h3 id=何为多态><a class=headerlink href=#何为多态 title=何为多态></a>何为多态</h3><p>多态指的是同类型的对象，表现出的不同形态。<p>多态的前提：有继承关系、父类引用指向子类对象、有方法重写。<h3 id=访问成员特点><a class=headerlink href=#访问成员特点 title=访问成员特点></a>访问成员特点</h3><ul><li>调用变量：编译看左边，运行也看左边；<li>调用方法：编译看左边，运行看右边；</ul><h3 id=多态优缺点><a class=headerlink href=#多态优缺点 title=多态优缺点></a>多态优缺点</h3><ul><li>优点：方法中使用父类类型或接口作为参数，可以接收所有子类对象。<li>缺点：不能调用子类的特有方法。</ul><p><strong>多态的缺点是不能调用子类特有的方法，但可以通过强制转换将父类转为子类类型来打破这种限制</strong>。在转换类型前推荐先通过<code>instanceof</code>关键字来判断是否可以转换，可以转换时再转换，否则会抛出转换异常。<p><strong>JDK14开始对instanceof的使用语法进行了优化</strong>。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=type>Animal</span> <span class=variable>a</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Animal</span>();</span><br><span class=line></span><br><span class=line><span class=comment>// 优化前</span></span><br><span class=line><span class=keyword>if</span>(a <span class=keyword>instanceof</span> Dog){</span><br><span class=line>    <span class=type>Dog</span> <span class=variable>d2</span> <span class=operator>=</span> (Dog)a;</span><br><span class=line>    d2.eat();</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// JDK14优化后的写法</span></span><br><span class=line><span class=keyword>if</span>(a <span class=keyword>instanceof</span> Dog d2){</span><br><span class=line>    d2.eat();</span><br><span class=line>}</span><br></pre></table></figure><h1 id=抽象类><a class=headerlink href=#抽象类 title=抽象类></a>抽象类</h1><h2 id=概述-5><a class=headerlink href=#概述-5 title=概述></a>概述</h2><p>子类方法要执行的内容可能与父类不同，所以在父类中就不能确定具体的方法体，不能确定方法体的方法就可以设计为抽象方法，抽象方法没有方法体。<p><strong>存在抽象方法的类必须声明为抽象类</strong>。<p>抽象类和抽象方法的定义格式如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment>// 抽象类</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> class 类名{</span><br><span class=line>    <span class=comment>// 抽象方法（没有方法体）</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> 返回值类型 方法名(参数列表);</span><br><span class=line>}</span><br></pre></table></figure><h2 id=注意事项-2><a class=headerlink href=#注意事项-2 title=注意事项></a>注意事项</h2><ul><li>抽象类不能被实例化；<li>抽象类中不一定有抽象方法，但有抽象方法的类一定是抽象类；<li>抽象类可以有成员变量、构造方法（被子类构造器间接调用做相关初始化）、非抽象方法；<li>抽象类的子类，要么重写其抽象方法，要么定义自己也为抽象类；</ul><h2 id=抽象类意义><a class=headerlink href=#抽象类意义 title=抽象类意义></a>抽象类意义</h2><p>强制子类必须按照方法固定格式来重写，统一代码，方便阅读与管理。<h1 id=接口><a class=headerlink href=#接口 title=接口></a>接口</h1><h2 id=定义-5><a class=headerlink href=#定义-5 title=定义></a>定义</h2><p>接口是一个规则，对行为的抽象。<strong>接口表示有没有某种行为，而抽象类表示是不是某种东西</strong>。<p>使用关键字<code>interface</code>代替关键字<code>class</code>来修饰的模块就称为接口，如：<code>public interface Eat{...}</code>。<blockquote><p>接口和类的关系可以是单实现，也可以是多实现。实现类可以在继承一个类的同时实现多个接口</blockquote><h2 id=成员特点><a class=headerlink href=#成员特点 title=成员特点></a>成员特点</h2><ul><li>成员变量：只能是常量，默认修饰符为<code>public static final</code>。<li>构造方法：不能编写构造方法。<li>成员方法：只能编写抽象方法，默认修饰符为<code>public abstract</code>。但是，jdk8中可以定义有方法体的默认方法、静态方法，jdk9中可以定义私有方法。</ul><h2 id=类与接口的关系><a class=headerlink href=#类与接口的关系 title=类与接口的关系></a>类与接口的关系</h2><ul><li>类和类：继承关系，只能单继承，不能多继承，但可以多层继承；<li>类和接口：可以单实现，也可以多实现，还可以继承一个类的同时实现多个接口；<li>接口和接口：继承关系，可以单继承，也可以多继承；</ul><h2 id=接口新变化><a class=headerlink href=#接口新变化 title=接口新变化></a>接口新变化</h2><p>从jdk8开始，接口规则有了新的变化。这个变化为：<strong>jdk8中可以定义有方法体的默认方法、静态方法，jdk9中可以定义私有方法</strong>。<h3 id=JDK8新变化><a class=headerlink href=#JDK8新变化 title=JDK8新变化></a>JDK8新变化</h3><p>jdk8中关于接口规则的新变化如下：<ul><li>允许在接口中定义被关键字<code>default</code>修饰的带方法体的方法，称为默认方法。默认方法的定义格式为：<code>public default 返回值类型/void 方法名(参数列表/无参)</code>;<li>允许在接口中定义被关键字<code>static</code>修饰的带方法体的方法，称为静态方法。静态方法的定义格式为：<code>public static 返回值类型/void 方法名(参数列表/无参)</code>;</ul><p>注意事项：<ul><li>默认方法<ul><li>默认方法不是抽象方法，不强制要求重写。但如果要重写，重写时要去掉<code>default</code>关键字；<li>默认方法中的public可以省略，但default不能省略；<li>一个类实现了多个接口，且多个接口中存在相同名字的默认方法，则该类就必须重写该方法；</ul><li>静态方法<ul><li>静态方法只能通过接口名调用，不能通过实现类名或对象名来调用；<li>静态方法中的public可以省略，但static不能省略；</ul></ul><h3 id=JDK9新变化><a class=headerlink href=#JDK9新变化 title=JDK9新变化></a>JDK9新变化</h3><p>jdk9中关于接口规则的新变化为：接口中可以定义带有方法体的私有非静态方法和私有静态方法。定义格式为：<code>private [static] 返回值类型/void 方法名(参数列表/无参){}</code>。<blockquote><p>接口中私有方法主要为接口中的默认方法服务。</blockquote><h1 id=内部类><a class=headerlink href=#内部类 title=内部类></a>内部类</h1><h2 id=概述-6><a class=headerlink href=#概述-6 title=概述></a>概述</h2><p>类的五大成员：属性、代码块、构造方法、方法、内部类。<p>内部类指的是在类里面定义的类。<h2 id=内部类分类><a class=headerlink href=#内部类分类 title=内部类分类></a>内部类分类</h2><p>内部类分为如下几种类型：<ul><li>成员内部类：定义在一个类中成员位置的类；<li>静态内部类：与成员内部类相似，被static修饰而已；<li>局部内部类：定义在方法中的类；<li>匿名内部类：“没有名字”的类；</ul><h2 id=成员内部类><a class=headerlink href=#成员内部类 title=成员内部类></a>成员内部类</h2><h3 id=简介-5><a class=headerlink href=#简介-5 title=简介></a>简介</h3><p>定义在类成员位置的类就称为成员内部类。<p>在成员内部类中，JDK16之前不能定义静态变量，JDK16开始可以定义。<h3 id=使用内部类><a class=headerlink href=#使用内部类 title=使用内部类></a>使用内部类</h3><p>获取内部类的对象有两种方式：<ul><li>在外部类中编写一个提供内部类对象的方法；<li>直接创建；格式为：<code>外部类.内部类 对象名 = new 外部类().new 内部类();</code></ul><h3 id=代码示例><a class=headerlink href=#代码示例 title=代码示例></a>代码示例</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">A</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> Integer age;</span><br><span class=line>    <span class=comment>// class B就是一个成员内部类</span></span><br><span class=line>    <span class=keyword>class</span> <span class="title class_">B</span> { }</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>class</span> <span class="title class_">C</span> { }</span><br><span class=line>    <span class=keyword>public</span> C <span class="title function_">getC</span><span class=params>()</span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">C</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 方式一：创建成员内部类对象</span></span><br><span class=line>A.<span class=type>B</span> <span class=variable>b</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">A</span>().<span class=keyword>new</span> <span class="title class_">B</span>();</span><br><span class=line><span class=comment>// 方式二：获取成员内部类对象</span></span><br><span class=line><span class=type>C</span> <span class=variable>c</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">A</span>().getC();</span><br></pre></table></figure><h2 id=静态内部类><a class=headerlink href=#静态内部类 title=静态内部类></a>静态内部类</h2><h3 id=简介-6><a class=headerlink href=#简介-6 title=简介></a>简介</h3><p>写在外部类成员位置的静态类称为静态内部类。静态内部类只能访问外部类中的静态变量和静态方法，若需要访问非静态的成员，需要创建对象后通过对象来访问。<h3 id=使用内部类-1><a class=headerlink href=#使用内部类-1 title=使用内部类></a>使用内部类</h3><p>获取静态内部类对象的方式为：<code>外部类.内部类 对象名 = new 外部类.内部类();</code><p>调用静态内部类中静态方法的方式为：<code>外部类.内部类.方法名();</code><p>调用静态内部类中非静态方法的方式为：先创建静态内部类对象，再通过对象来访问。<h3 id=代码示例-1><a class=headerlink href=#代码示例-1 title=代码示例></a>代码示例</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">A</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> Integer age;</span><br><span class=line>    <span class=comment>// class B就是一个静态内部类</span></span><br><span class=line>    <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">B</span> {</span><br><span class=line>        <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">m1</span><span class=params>()</span>{}</span><br><span class=line>        <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">m2</span><span class=params>()</span>{}</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 创建静态内部类的对象</span></span><br><span class=line>A.<span class=type>B</span> <span class=variable>b</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">A</span>.B();</span><br><span class=line><span class=comment>// 调用静态内部类的非静态方法</span></span><br><span class=line>b.m2();</span><br><span class=line><span class=comment>// 调用静态内部类的静态方法</span></span><br><span class=line>A.B.m1();</span><br></pre></table></figure><h2 id=局部内部类><a class=headerlink href=#局部内部类 title=局部内部类></a>局部内部类</h2><h3 id=简介-7><a class=headerlink href=#简介-7 title=简介></a>简介</h3><p>定义在方法里面的类就称为局部内部类，类似于方法里面的局部变量，生命周期也与方法的生命周期相同。<h3 id=代码示例-2><a class=headerlink href=#代码示例-2 title=代码示例></a>代码示例</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">A</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> Integer age;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">show</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// class B就是一个局部内部类</span></span><br><span class=line>        <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">B</span> {</span><br><span class=line>            <span class=comment>//...</span></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=匿名内部类><a class=headerlink href=#匿名内部类 title=匿名内部类></a>匿名内部类</h2><h3 id=简介-8><a class=headerlink href=#简介-8 title=简介></a>简介</h3><p>匿名内部类指的是隐藏了名字的内部类，可以写在成员位置，称为成员匿名内部类，也可以写在局部位置，称为局部匿名内部类。<blockquote><p>匿名内部类只是隐藏了名字，而并非没有名字。他的名字为<code>外部类名+$+序号</code>，比如名为Person$1。</blockquote><h3 id=代码示例-3><a class=headerlink href=#代码示例-3 title=代码示例></a>代码示例</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">A</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>final</span> <span class=type>String</span> <span class=variable>NAME</span> <span class=operator>=</span> <span class=string>"zhangsan"</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>final</span> <span class=type>Integer</span> <span class=variable>AGE</span> <span class=operator>=</span> <span class=number>18</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">show</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=comment>// 这里new出来的就是一个隐藏名字的匿名内部类。</span></span><br><span class=line>    <span class=keyword>new</span> <span class="title class_">A</span>() {</span><br><span class=line>        <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">show</span><span class=params>()</span>{</span><br><span class=line>            <span class=comment>//...</span></span><br><span class=line>        }</span><br><span class=line>    };</span><br><span class=line>}</span><br></pre></table></figure><h1 id=克隆><a class=headerlink href=#克隆 title=克隆></a>克隆</h1><h2 id=概述-7><a class=headerlink href=#概述-7 title=概述></a>概述</h2><p><strong>基于一个类得到另一个与之相同的类的行为称之为克隆</strong>。<p>克隆分为浅克隆和深克隆两种。<ul><li>浅克隆：无论对象中的属性是基本类型还是引用类型，会将之全部拷贝；<li>深拷贝：基本类型会直接拷贝，字符串会复用串池中的内容，其它引用类型会创建一个新的来使用；</ul><blockquote><p>Object中的克隆属于浅克隆，要使用深克隆，需要重写clone方法。</blockquote><h2 id=使用克隆><a class=headerlink href=#使用克隆 title=使用克隆></a>使用克隆</h2><p>要使用克隆功能，需要满足一些条件：<ol><li>要被克隆的类需要实现Clonable接口；<li>要被克隆的类中需要重写Object的clone()方法；<li>直接调用重写后的clone方法就可以实现克隆；</ol><h1 id=正则表达式><a class=headerlink href=#正则表达式 title=正则表达式></a>正则表达式</h1><h2 id=概述-8><a class=headerlink href=#概述-8 title=概述></a>概述</h2><p><strong>正则表达式主要由字符类、预定义字符、数量词等内容组成</strong>。<p>正则表达式可以校验字符串是否满足一定的规则，并用来校验数据格式的合法性。通过调用Strng类的matches(正则表达式)方法就可以使用正则来匹配判断内容是否有效。<p>正则表达式的作用：校验字符串是否满足规则；在一段文本中查找满足要求的内容。<h2 id=规则><a class=headerlink href=#规则 title=规则></a>规则</h2><p>正则表达式规则如下<p>预定义字符（匹配1个）：<ul><li>点.：任何字符，除了\n回车符号。<li>\d：一个数字。<li>\D：非数字。<li>\s：一个空白字符。<li>\S：非空白字符。<li>\w：[a-zA-Z_0-9]，表示英文、数字、下划线。<li>\W：<code>[^\w]</code>一个非单词字符。<li>[]：里面的内容出现一次。<li>()：分组。<li>&&：交集<li>|：写在方括号外面，表示并集。<li>\：斜杠表示转义字符。<li><code>(?i)</code>：忽略大小写。只会忽略该标识后面的字母大小写。<li><code>?=</code>：?表示前面的字符，=表示前面的字符后面可以拼接那些字符。比如Java(?=7|8|11)就会匹配Java7、Java8、Java11，但要注意的是，最终只保留Java，不会保留后面的数字。换句话说就是，我只想获取Java7、Java8、Java11中的字符Java，而不希望获取Java17、Java20等中的字符Java。<li><code>?:</code>与?=的效果类似，只是最终获取结果会包含所有字符。比如Java(?:7|8|11)就会匹配Java7、Java8、Java11，最终要保留的也是全部字符，不需要去掉后面的数字。<li><code>?!</code>：取反</ul><p>数量词：<ul><li>X？：X出现零次或一次。<li>X*：X出现零次或多次。<li>X+：X出现一次或多次。<li>X{n}：X出现n次。<li>X{n, }：X出现至少n次。<li>X{n, m}：X出现至少n次，但不超过m次。</ul><p>字符类示例（匹配1个）：<ul><li>[abc]：只能是a、b、c。<li>[^abc]：除了abc之外的任何字符。<li>[a-zA-Z]：a-z和A-Z中的任何字符。<li>[a-d[m-p]]：a-d或m-p之间的任何字符。<li>[a-z&&[def]]：a-z和def的交集，结果为d、e、f。<li><code>[a-z&&[^BC]]</code>：a-z和非bc的交集，等同于[ad-z]。<li><code>[a-z&&[^m-p]]</code>：a-z和非m-p的交集。</ul><h2 id=分组><a class=headerlink href=#分组 title=分组></a>分组</h2><h3 id=简介-9><a class=headerlink href=#简介-9 title=简介></a>简介</h3><p>在正则表达式中使用小括号()将内容包括起来可以对要匹配的字符串内容进行分组。<h3 id=分类><a class=headerlink href=#分类 title=分类></a>分类</h3><p>正则表达式中分组有两种：<ul><li><strong>捕获分组（默认）</strong>：可以通过<code>\\+组号 和 $+组号</code>获取每组中的内容反复使用；<li><strong>非捕获分组</strong>：分组后不需要再用本组数据，仅仅把数据括起来，不占组号；(?:)、(?=)、(?!)都是非捕获分组。</ul><h3 id=组号><a class=headerlink href=#组号 title=组号></a>组号</h3><p>捕获分组后每组会有一个组号，也就是序号。该组号存在以下规则：<ul><li>规则1：组号从1开始，连续不间断。<li>规则2：以左括号为基准，最左边的是第一组，其次为二组，以此类推。</ul><p>当在正则表达式中使用小括号进行捕获分组后，可以在正则表达式中继续使用<code>\\+组号</code>来复用该组，也可以在正则表达式外通过<code>$+组号</code>来复用该组匹配到的内容。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>// 我要学学学编编编编程程 -> 我要学编程</span></span><br><span class=line><span class=type>String</span> <span class=variable>str</span> <span class=operator>=</span> <span class=string>"我要学学学编编编编程程"</span>;</span><br><span class=line><span class=type>String</span> <span class=variable>regular</span> <span class=operator>=</span> <span class=string>"*(.)\\1+"</span>; <span class=comment>// 正则表达式</span></span><br><span class=line><span class=type>String</span> <span class=variable>result</span> <span class=operator>=</span> str.replaceAll(regular, <span class=string>"$1"</span>); <span class=comment>// 我要学编程</span></span><br></pre></table></figure><p><strong>注意事项</strong>：通过组号拿到分组内容来使用只适用于捕获分组场景，若是非捕获分组，那么无法使用直接报错。<h1 id=泛型><a class=headerlink href=#泛型 title=泛型></a>泛型</h1><h2 id=概述-9><a class=headerlink href=#概述-9 title=概述></a>概述</h2><p>为了统一数据类型，方便管理，提出了泛型。泛型的定义格式为<code><引用数据类型></code>。<p><strong>泛型中不能写基本数据类型。如果不写泛型，默认为Object。</strong>指定泛型后，在传递数据时只能传递该类型或子类型。<p>泛型可以编写在类、接口、方法上，编写后分别称为泛型类、泛型接口、泛型方法。<ul><li>泛型类：泛型要编写在类名后面；<li>泛型接口：泛型要编写在接口名后面，使用时既可以在实现类中给出类型，也可以实现类延续泛型，然后在创建实现类对象时指定类型。<li>泛型方法：泛型要编写在方法修饰符后面；</ul><h2 id=继承与通配符><a class=headerlink href=#继承与通配符 title=继承与通配符></a>继承与通配符</h2><h3 id=继承-1><a class=headerlink href=#继承-1 title=继承></a>继承</h3><p>泛型不具备继承性，但数据具备继承性。<h3 id=通配符><a class=headerlink href=#通配符 title=通配符></a>通配符</h3><p>通配符为<code>?</code>，与通配符搭配使用的方式有两种：<ul><li>? extends E：表示可以传递E或E的子类型；<li>? super E：表示可以传递E或E的父类型；</ul><h1 id=集合><a class=headerlink href=#集合 title=集合></a>集合</h1><h2 id=概述-10><a class=headerlink href=#概述-10 title=概述></a>概述</h2><p>集合主要分两大部分组成：接口Collection和接口Map。<p>接口Collection的主要实现类有：List、Set、Queue；接口Map的主要实现有：HashMap、Hashtable；<h2 id=数据结构><a class=headerlink href=#数据结构 title=数据结构></a>数据结构</h2><h3 id=树><a class=headerlink href=#树 title=树></a>树</h3><h4 id=概述-11><a class=headerlink href=#概述-11 title=概述></a>概述</h4><p>树有多种分类：普通二叉树、查找二叉树、平衡二叉树、多叉树、红黑树等。<blockquote><p>普通二叉树中的数据没有规则，使用有限。查找二叉树中的数据有规则，但容易变成链表，使用有限。平衡二叉树可避免前两者的问题，但过于追求平衡，编辑性能低下，不合适。</blockquote><p>关于数据结构树的术语如下：<ul><li>度：每一个节点的子节点数量；<li>树高：树的总层数；<li>根节点：最顶层的一个节点；<li>左节点：节点左边的一个节点；<li>右节点：节点右边的一个节点；</ul><h4 id=二叉树遍历><a class=headerlink href=#二叉树遍历 title=二叉树遍历></a>二叉树遍历</h4><p>二叉树的遍历方式有如下几种：<ul><li>前序遍历：从根节点开始，按照<strong>当前节点</strong>，<strong>左子节点</strong>，<strong>右子节点</strong>的顺序遍历；<li>中序遍历：从左子节点开始，按照<strong>左子节点</strong>，<strong>当前节点</strong>，<strong>右子节点</strong>的顺序遍历；<li>后序遍历：从左子节点开始，按照<strong>左子节点</strong>，<strong>右子节点</strong>，<strong>当前节点</strong>的顺序遍历；<li>层序遍历：从根节点开始，从上到下，从左到右一层一层的遍历；</ul><h4 id=平衡二叉树旋转><a class=headerlink href=#平衡二叉树旋转 title=平衡二叉树旋转></a>平衡二叉树旋转</h4><p>平衡二叉树需要旋转的四种情况：<ul><li>左左：一次右旋；<li>左右：先局部左旋，再整体右旋；<li>右右：一次左旋；<li>右左：先局部右旋，再整体左旋；</ul><h4 id=红黑树><a class=headerlink href=#红黑树 title=红黑树></a>红黑树</h4><p>红黑树规则如下：<ul><li>红黑树根节点是黑色；<li>红黑树叶子节点是黑色，但为Nil（空，没有值）;<li>红色节点的两个子节点为黑色，不能存在连续的两个红色节点；<li>根节点到任何一个叶子节点的路径上必须有相同数量的黑色节点；</ul><p>注意：<strong>红黑树在添加节点时，添加的节点默认为红色，因为添加红色节点效率较高。</strong><h2 id=Set><a class=headerlink href=#Set title=Set></a>Set</h2><h3 id=HashSet><a class=headerlink href=#HashSet title=HashSet></a>HashSet</h3><p><strong>集合HashSet中的元素特点为：无序、不重复、无索引</strong>。<p>HashSet集合中元素是否重复是通过比较元素具体的值来判断的，值相同就表示元素相同，元素相同就不能存储。<strong>当向集合Set中添加自定义对象时，必须重写对象的equals和hashcode方法，否则就不满足Set集合中重复元素的判断规则</strong>。<h3 id=LinkedHashSet><a class=headerlink href=#LinkedHashSet title=LinkedHashSet></a>LinkedHashSet</h3><p>集合LinkedHashSet底层基于哈希表，并使用双向链表来记录添加顺序，故该集合中的元素特点为：<strong>有序、不重复、无索引</strong>。<h3 id=TreeSet><a class=headerlink href=#TreeSet title=TreeSet></a>TreeSet</h3><p><strong>集合TreeSet中的元素特点为：可排序、不重复、无索引</strong>。<p>TreeSet底层基于红黑树数据结构实现排序，增删改查性能都比较好。<p>TreeSet排序规则：<ul><li>数值类型：默认按照从小到大的顺序进行排序；<li>字符、字符串类型：按照字符在ASCII码表中的数字升序进行排序；<li>引用类型：实现Comparable接口或Comparator接口，重写比较方法来实现排序；TreeSet默认是根据元素实现的Comporable接口来实现排序，这种方式称之为默认排序或自然排序。除了自然排序还可以通过比较器Comparator自定义比较规则来实现排序，这种排序称之为比较器排序。</ul><blockquote><p>TreeSet默认使用自然排序来实现排序，如果自然排序无法满足需求再选择使用比较器来实现排序。</blockquote><h3 id=使用场景><a class=headerlink href=#使用场景 title=使用场景></a>使用场景</h3><ul><li>如果需要集合中的<strong>元素有序</strong>：使用ArrayList，基于数组，使用偏多；<li>如果需要集合中的<strong>元素去重</strong>：使用HashSet，基于哈希表和红黑树，使用偏多；<li>如果需要集合中的<strong>元素去重且保证存取顺序</strong>：使用LinkedHashSet，基于哈希表和双链表，性能低于HashSet；<li>如果需要集合中的<strong>元素去重且有序</strong>：使用TreeSet，基于红黑树，增删改查效率较高；</ul><h2 id=Map><a class=headerlink href=#Map title=Map></a>Map</h2><h3 id=HashMap><a class=headerlink href=#HashMap title=HashMap></a>HashMap</h3><p>HashMap键值对数据编辑的特点：<ul><li>put（添加）：集合中不存在当前要添加的键值对时，直接存储并返回null；如果存在那就替换已存在的键值对，并返回被覆盖的键值对中的值；<li>remove（删除）：根据键删除键值对并返回被删除键值对的值；</ul><blockquote><p><strong>如果需要向HashMap中存储自定义对象，那么需要重写equals和hashCode方法。</strong></blockquote><h3 id=LinkedHashMap><a class=headerlink href=#LinkedHashMap title=LinkedHashMap></a>LinkedHashMap</h3><p>LinkedHashMap底层数据结构是哈希表，通过双向链表将待插入的元素按照插入顺序链接起来。故，LinkedHashMap中元素的特点为：<strong>有序、不重复、无索引</strong>。<h3 id=TreeMap><a class=headerlink href=#TreeMap title=TreeMap></a>TreeMap</h3><p><strong>TreeMap底层数据结构是红黑树，增删改查性能较好</strong>。<p>TreeMap中元素特点是可排序、不重复、无索引。<p>TreeMap可以根据元素实现的Comparable接口或指定比较器Comparator来实现自定义排序。<blockquote><p>TreeMap中添加自定义引用类型时，无需重写equals和hashcode方法；</blockquote><h2 id=Collections><a class=headerlink href=#Collections title=Collections></a>Collections</h2><h3 id=简介-10><a class=headerlink href=#简介-10 title=简介></a>简介</h3><p><strong>Collections是java.util包下的一个集合工具类，提供了一些常用的操作集合的方法</strong>。<h3 id=常用API><a class=headerlink href=#常用API title=常用API></a>常用API</h3><ul><li>addAll：批量添加元素；<li>shuffle：打乱List集合中元素的顺序；<li>sort：默认排序或根据指定规则排序；<li>binarySearch：以二分查找法查找集合中的元素；<li>copy：拷贝一个集合中的元素到另一个集合中；<li>fill：使用指定的元素填充集合；<li>max/min：根据默认自然排序获得的最大值/最小值；<li>swap：交换集合中指定的两个位置上的元素；</ul><h2 id=不可变集合><a class=headerlink href=#不可变集合 title=不可变集合></a>不可变集合</h2><h3 id=简介-11><a class=headerlink href=#简介-11 title=简介></a>简介</h3><p>不可变集合指的是集合创建完成后，集合不可以执行添加、修改、删除等操作。<h3 id=创建不可变集合><a class=headerlink href=#创建不可变集合 title=创建不可变集合></a>创建不可变集合</h3><p>通过List、Set、Map的的of方法可以创建不可变集合。<ul><li>List：直接调用of方法即可；<li>Set：调用of方法时，集合中不能存在重复元素；<li>Map：调用of方法时，集合中的元素不能重复，且键值对数量不能超过10个。<strong>如果超过10个，需要使用ofEntries方法来创建</strong>。</ul><h2 id=总结><a class=headerlink href=#总结 title=总结></a>总结</h2><p><strong>HashMap中的键不需要实现Compareable接口或传递比较器对象来比较。</strong><p><strong>HashMap与TreeMap对比，谁的效率更高？</strong>当HashMap中的节点形成一个数量为8的链表时，TreeMap效率更高，但形成数量为8的链表的这种情况很少，故，通常情况下还是HashMap的效率更高。<p><strong>HashMap、LinkedHashMap、TreeMap三者在实际应用中该如何选择？</strong>默认使用HashMap，如果需要保证存取有序使用LinkedHashMap，如果需要元素排序使用TreeMap。<h1 id=Stream><a class=headerlink href=#Stream title=Stream></a>Stream</h1><h2 id=概述-12><a class=headerlink href=#概述-12 title=概述></a>概述</h2><p>Stream流类似于工厂中的流水线。通过Stream流，结合Lambda表达式可简化对集合、数组的操作。<h2 id=获取Stream><a class=headerlink href=#获取Stream title=获取Stream></a>获取Stream</h2><p>获取Stream流对象的方式有如下几种：<ul><li>单列集合：直接调用集合的stream方法；<li>双列集合：不能直接获取，先获取单例数据再转为Stream对象，然后再操作；<li>数组：使用Arrays工具类中的静态方法stream；<li>零散数据：使用Stream流的静态方法<code>of</code>将数据进行整合；</ul><h2 id=常用方法><a class=headerlink href=#常用方法 title=常用方法></a>常用方法</h2><ul><li>中间方法：filter、limit、skip、distinct、concat、map等；<li>结束方法：forEach、count、collect等；</ul><h1 id=方法引用><a class=headerlink href=#方法引用 title=方法引用></a>方法引用</h1><h2 id=概述-13><a class=headerlink href=#概述-13 title=概述></a>概述</h2><p>方法引用指的是将已经存在的方法拿过来用，当做函数式接口中抽象方法的方法体。<p><strong>方法引用通过符号<code>::</code>来连接调用方法，该符号就是方法引用符</strong>。<h2 id=使用条件><a class=headerlink href=#使用条件 title=使用条件></a>使用条件</h2><p>想要使用方法引用，需要满足一些条件：<ul><li>存在函数式接口；<li>被引用的方法已经存在；<li>被引用方法的形参和返回值需要与抽象方法的形参和返回值一样；<li>被引用方法的功能可以满足当前的需求；</ul><h2 id=使用分类><a class=headerlink href=#使用分类 title=使用分类></a>使用分类</h2><p>通过方法引用符调用不同类成员的编写方式不同，具体分类如下：<ul><li>引用静态方法：类::静态方法，例如 System.out::print();<li>引用成员方法：<ul><li>其它类的方法：对象::方法，例如 new Student()::getAge；<li>本类：this::方法名;<li>父类：super::方法名；</ul><li>引用构造方法：类名::new，例如 Student::new；<li>引用数组的构造方法：数据类型[]::new，例如 int[]::new；</ul><h1 id=异常><a class=headerlink href=#异常 title=异常></a>异常</h1><h2 id=概述-14><a class=headerlink href=#概述-14 title=概述></a>概述</h2><p>异常的根类为<code>java.lang.Throwable</code>，该根类由Error和Exception两者组成。<strong>Error表示严重的错误，不可处理。Exception表示可被处理的错误</strong>。<p>Exception分为两大类：RuntimeException和其它异常。前者称为运行时异常，也就是程序运行期间可能出现的异常。后者其它异常称为编译时异常，程序编译阶段就能检测到的异常。<p>异常的作用有两个：用来查询bug的关键参考信息 和 作为一种返回值，通知调用者程序执行情况。<h2 id=处理异常><a class=headerlink href=#处理异常 title=处理异常></a>处理异常</h2><h3 id=处理分类><a class=headerlink href=#处理分类 title=处理分类></a>处理分类</h3><p>处理异常的方式如下：<ul><li>JVM默认处理：抛出异常，停止程序的执行；<li>自己处理：主动捕获处理，程序可以继续执行；<li>抛出异常：主动抛出异常，停止程序的执行；</ul><h3 id=抛出异常><a class=headerlink href=#抛出异常 title=抛出异常></a>抛出异常</h3><p>抛出异常分两种：<ul><li>throws：写在定义的方法小括号后面，后面跟写异常类名即可。例如<code>method() throws Exception1, Exception2, ...{//方法体}</code><li>thorw：写在方法中，用于主动抛出指定异常。例如 <code>method() {throw new CustomeException();}</code></ul><h1 id=File><a class=headerlink href=#File title=File></a>File</h1><h2 id=获取和遍历><a class=headerlink href=#获取和遍历 title=获取和遍历></a>获取和遍历</h2><p>注意事项：<ul><li>当File表示的路径不存在时，返回null；<li>当File表示的路径是文件时，返回null；<li>当File表示的是一个空文件夹时，返回长度为0的数组；<li>当FIle表示的是一个有内容的文件夹时，返回存放内容对应路径的数组；<li>当File表示的是一个有隐藏文件的文件夹时，与上一个相同；<li>当FIle表示的是一个有权限的文件夹时，返回null；</ul><h1 id=IO流><a class=headerlink href=#IO流 title=IO流></a>IO流</h1><h2 id=概述-15><a class=headerlink href=#概述-15 title=概述></a>概述</h2><p><strong>IO流就是存储或读取数据的解决方案。I全称为Input，表示输入。O全称为Output，表示输出</strong>。<p>IO流按照流向和可操作文件类型来说，分为两种：<ul><li>按照流向可分：输入流、输出流。<li>按照可操作文件类型可分：字节流、字符流。</ul><p>输入流指的是数据从文件到程序的流向，输出流指的是数据从程序到文件的流向。<p><strong>字节流指的是可以读取任何类型文件的IO流，字符流指的是只能读取纯文本文件的IO流</strong>。<blockquote><p>纯文本文件指的是使用电脑记事本工具打开就可以阅读其中内容的文件。</blockquote><h2 id=自动关流><a class=headerlink href=#自动关流 title=自动关流></a>自动关流</h2><p><strong>JDK7提供了AutoCloseable接口，可实现自动关流</strong>。具体使用方式为try后面使用小括号将使用的流对象包括起来，多个流用分割号<code>;</code>隔开即可。<p><strong>JDK9时再次对之进行了优化，可在外面定义流对象，然后在try后面小括号中只写流对象名即可</strong>。<h2 id=字符集><a class=headerlink href=#字符集 title=字符集></a>字符集</h2><h3 id=计算机存储规则><a class=headerlink href=#计算机存储规则 title=计算机存储规则></a>计算机存储规则</h3><p>计算机存储字符数据的规则为：通过查询字符集得到要存储字符对应的二进制数据，然后再将该二进制数据编码为磁盘存储需要的格式进行存储。当读取磁盘中的数据时，再通过解码和检查字符集得到具体要展示的字符数据。<h3 id=字符集演变><a class=headerlink href=#字符集演变 title=字符集演变></a>字符集演变</h3><h4 id=GB2312字符集><a class=headerlink href=#GB2312字符集 title=GB2312字符集></a>GB2312字符集</h4><p><strong>1980年发布，1981年5月1日实施简体中文汉字编码国家标准</strong>。<h4 id=BIG5字符集><a class=headerlink href=#BIG5字符集 title=BIG5字符集></a>BIG5字符集</h4><p>台湾地区繁体中文标准字符集，共收录13053个中文汉字。1984年实施。<h4 id=GBK字符集><a class=headerlink href=#GBK字符集 title=GBK字符集></a>GBK字符集</h4><p><strong>K表示扩展，GBK表示在GB2312的基础上进行了扩展</strong>，GBK包含GB13000-1中的全部中日韩文字，及BIG5中的所有文字，共收录21003个文字。<strong>GBK字符集兼容ASCII字符集</strong>。<p>windows系统中默认使用的就是GBK，但实际显示的名字为ANSI，因为不同国家版本的windows系统使用的字符集名字不同，但其本质相同，故将它们统一命名为ANSI，<strong>ANSI就代表GBK字符集</strong>。<p>GBK字符集的字符占用规则：<ul><li>英文：<strong>一个英文字符占用1个字节</strong>，一个字节可表示256个不同的英文字符。英文的1个字节的二进制是0开头，转为十进制是一个正数。<li>汉字：<strong>一个汉字字符占用2个字节</strong>，两个字节可表示2^16次方个不同的汉字。2个字节分为高位字节和低位字节，高位字节的二进制是1开头，转为十进制后是一个负数。</ul><p>GBK编码规则如下：<ul><li>英文：查询GBK字符集得到英文对应的7个二进制位，然后<strong>前面补0编码为8位</strong>，最后存储。<li>汉字：查询GBK字符集得到汉字对应的16位二进制位，<strong>无需进行GBK编码</strong>，直接存储。</ul><h4 id=Unicode字符集><a class=headerlink href=#Unicode字符集 title=Unicode字符集></a>Unicode字符集</h4><p><strong>Unicode字符集是国际标准字符集</strong>，它将世界各种语言的每个字符都定义一个唯一的编码，以满足跨语言、跨平台的文本信息转换。<p>基于Unicode字符集进行编码时有多种编码规则，这些规则如下：<ul><li>UTF-16：单个字符使用2个字节存储。<li>UTF-32：所有字符的单个字符都使用4个字节存储字符<li>UTF-8：<strong>单个字符使用1~4个字节存储</strong>。<ul><li>ASCII表英文字符使用1个字节存储，二进制第一位为0，十进制为正数。<li>简体中文使用3个字节存储，二进制第一位为1，第一个字节十进制为负数。<li>其它语言使用4个字节存储。</ul></ul><p>UTF-8编码方式如下，通过字符集得到字符对应的二进制位，将字符对应的二进制位填充在下面的<code>x</code>位置上后可得到该字符实际存储时的二进制位数据格式。<figure class="highlight text"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line># 二进制，从上到下分别为1个字节、2个字节、3个字节、4个字节</span><br><span class=line>0xxxxxxx</span><br><span class=line>110xxxxx 10xxxxxx</span><br><span class=line>1110xxxx 10xxxxxx 10xxxxxx</span><br><span class=line>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></table></figure><h3 id=字符存读规则><a class=headerlink href=#字符存读规则 title=字符存读规则></a>字符存读规则</h3><p>不同种类的字符在存储和读取时，因为使用的字符集和编码解码方式不同而存在不同的规则。<h4 id=英文><a class=headerlink href=#英文 title=英文></a>英文</h4><p>当存储一个英文字母时很简单，底层逻辑为：<strong>先将英文字母根据字符集得到对应的十进制数字，然后将数字转为二进制，再对该二进制进行编码得到实际存储需要的二进制格式，然后进行存储</strong>。<p>从磁盘读取一个英文字符时的逻辑为：<strong>先通过解码得到对应的十进制数字，再查询字符集得到对应的实际展示格式</strong>。<h4 id=汉字><a class=headerlink href=#汉字 title=汉字></a>汉字</h4><p>存储一个汉字时的逻辑为：<strong>先将汉字根据字符集得到对应的十进制数字，然后将数字转为二进制，再对该二进制进行编码（比如UTF-8编码）得到实际存储需要的二进制格式，然后存储</strong>。<p>读取一个汉字时的逻辑为：<strong>先通过解码得到字符集中对应的十进制数字，再查询字符集得到对应的实际展示格式</strong>。<h4 id=注意事项-3><a class=headerlink href=#注意事项-3 title=注意事项></a>注意事项</h4><p>在存储读取字符数据时需要遵循一定的规则，这些规则如下：<ul><li>字符在编码和解码时要使用相同的字符集和编码方式，否则会出现乱码问题。<li>不要使用字节流读取文本文件，因为可能出现乱码问题。</ul><h2 id=字节流><a class=headerlink href=#字节流 title=字节流></a>字节流</h2><h3 id=概述-16><a class=headerlink href=#概述-16 title=概述></a>概述</h3><p><strong>字节流是可以存储读取任何类型文件的IO流。</strong>字节流按照字节来读取内容，如果要正确读取文本文件中的字符，那么读取时就要考虑到每个字符占用的字节大小，否则会出现乱码现象。<h2 id=字符流><a class=headerlink href=#字符流 title=字符流></a>字符流</h2><h3 id=概述-17><a class=headerlink href=#概述-17 title=概述></a>概述</h3><p><strong>字符流是只能存储读取文本文件中字符的IO流</strong>。字符流可以自动判断字符类型（中文、英文、或其它字符类型）来进行相关操作，并达到应有的效果。<h3 id=底层原理-3><a class=headerlink href=#底层原理-3 title=底层原理></a>底层原理</h3><h4 id=字符输入流><a class=headerlink href=#字符输入流 title=字符输入流></a>字符输入流</h4><p><strong>创建字符输入流对象后，底层会关联一个文件，并创建一个大小为8192的字节数组，也就是缓冲区</strong>。<p>读取数据时先判断缓冲区中是否有数据：<ul><li>缓冲区中没有数据：从文件中获取数据装入缓冲区中，且每次尽可能装满缓冲区。<li>缓冲区有数据：先从缓冲区中读取数据，读取完了再从文件读取数据装入缓冲区。空参read方法对于英文会一次读取一个字节，对于中文会一次读取多个字节，并将字节解码为字符集中对应的十进制数字，若需要得到字符还需要进行强转。有参read方法把读取数据、解码、强转进行了合并，并将最终要展示的字符放进了数组中。</ul><blockquote><p>当要读取的文件内容大小超过8192字节大小，第二次填充缓冲区前不会清空缓冲区，而会将文件中超过8192字节大小的后续数据按照缓冲区从小到大的顺序去覆盖，没有覆盖到的内容仍然是第一次填充缓冲区时留下的内容，这一点要知道。</blockquote><h4 id=字符输出流><a class=headerlink href=#字符输出流 title=字符输出流></a>字符输出流</h4><p><strong>创建字符输出流对象后，底层也会关联一个文件，并创建一个大小为8192的字节数组，也就是缓冲区</strong>。<p>默认情况下，当缓冲区中被装满时会自动存入磁盘文件中。当缓冲区没有满且想写出到文件中时，需要调用flush方法来实现。<p>通过调用close方法也会将缓冲区内容写出到文件中，但要注意的是，close方法执行完后会关闭通道，后续无法继续将内容写入文件。<h2 id=缓冲流><a class=headerlink href=#缓冲流 title=缓冲流></a>缓冲流</h2><h3 id=概述-18><a class=headerlink href=#概述-18 title=概述></a>概述</h3><p>缓冲流分为两种：字节缓冲流 和 字符缓冲流。<h3 id=字节缓冲流><a class=headerlink href=#字节缓冲流 title=字节缓冲流></a>字节缓冲流</h3><p>字节缓冲流指的是BufferedInputStream和BufferOutputStream，主要针对字节流的读写进行优化，提升其性能。<p><strong>字节缓冲流底层会有一个大小为8192的字节（byte）数组作为缓冲区来提升读写性能，大小为8192的字节数组占有8KB的空间</strong>。<h3 id=字符缓冲流><a class=headerlink href=#字符缓冲流 title=字符缓冲流></a>字符缓冲流</h3><p>字符缓冲流指的是BufferedReader 和 BufferWriter，主要针对字符流的读写进行优化，提升其性能。<p><strong>字符缓冲流底层会有一个大小为8192的字符（char）数组作为缓冲区来提升读写性能，大小为8192的字符数组占有16KB的空间</strong>。<p>字符缓冲流对象中有两个特有方法：<ul><li>字符缓冲输入流中的readLine()方法：可读取一行字符，遇到换行结束。<li>字符缓冲输出流中的newLine()方法：可跨平台创建并实现一个换行。</ul><h2 id=转换流><a class=headerlink href=#转换流 title=转换流></a>转换流</h2><h3 id=概述-19><a class=headerlink href=#概述-19 title=概述></a>概述</h3><p><strong>转换流是字节流与字符流之间的桥梁，通过转换流可以对字节流与字符流进行相互转换</strong>。<p>转换流分为字符输入转换流和字符输出转换流：<ul><li>字符输入转换流：InputStreamReader<li>字符输出转换流：OutputStreamWriter</ul><h3 id=字符输入转换流><a class=headerlink href=#字符输入转换流 title=字符输入转换流></a>字符输入转换流</h3><p>字符输入转换流可以将字节输入流转为字符输入流。参考示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>FileInputStream</span> <span class=variable>fis</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">FileInputStream</span>(<span class=string>"a.txt"</span>);</span><br><span class=line><span class=type>InputStreamReader</span> <span class=variable>isr</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">InputStreamReader</span>(fis, <span class=string>"UTF-8"</span>)</span><br></pre></table></figure><h3 id=字符输出转换流><a class=headerlink href=#字符输出转换流 title=字符输出转换流></a>字符输出转换流</h3><p>字符输出转换流可以将字节输出流转为字符输出流。参考示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>FileOutputStream</span> <span class=variable>fos</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">FileOutputStream</span>(<span class=string>"a.txt"</span>);</span><br><span class=line><span class=type>OutputStreamWriter</span> <span class=variable>osw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">OutputStreamWriter</span>(fos, <span class=string>"UTF-8"</span>);</span><br></pre></table></figure><h2 id=序列化流><a class=headerlink href=#序列化流 title=序列化流></a>序列化流</h2><h3 id=概述-20><a class=headerlink href=#概述-20 title=概述></a>概述</h3><p><strong>序列化流指的是可以将对象写入到文件，也可以从文件中读取对象的一种字节流</strong>。<p>序列化流分为正序列化流和反序列化流。<ul><li>正序列化流：ObjectOutputStream<li>反序列化流：ObjectInputStream</ul><p><strong>如果不希望将对象中的某个字段进行序列化，可以使用修饰符<code>transient</code>来修饰该字段。</strong><p>对象在序列化后，如果改变了对象中的内容，再次进行反序列化时会报错，其原因与类的版本有关系。每当类中内容被修改，类的版本号就会发生改变，此时进行反序列化必然报错，要想避免该种错误，只需固定类的版本号。<p>可以通过在类中定义一个long型私有常量字段<code>serialVersionUID</code>，对应的值为long型数字来固定类的版本号。<h3 id=正序列化流><a class=headerlink href=#正序列化流 title=正序列化流></a>正序列化流</h3><p>正序列化流可以将对象写入到文件中。参考示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=type>User</span> <span class=variable>user</span> <span class=operator>=</span> User.builder().userId(<span class=number>1</span>).userName(<span class=string>"zhangsan"</span>).build();</span><br><span class=line><span class=type>User</span> <span class=variable>user2</span> <span class=operator>=</span> User.builder().userId(<span class=number>2</span>).userName(<span class=string>"lisi"</span>).build();</span><br><span class=line>List&LTUser> userList = <span class=keyword>new</span> <span class="title class_">ArrayList</span><>();</span><br><span class=line>userList.add(user);</span><br><span class=line>userList.add(user2);</span><br><span class=line></span><br><span class=line><span class=keyword>try</span>(</span><br><span class=line>    <span class=type>FileOutputStream</span> <span class=variable>fos</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">FileOutputStream</span>(<span class=string>"users.txt"</span>);</span><br><span class=line>    <span class=type>ObjectOutpuStream</span> <span class=variable>oos</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class=line>){</span><br><span class=line>    oos.writeObject(userList);</span><br><span class=line>}</span><br></pre></table></figure><h3 id=反序列化流><a class=headerlink href=#反序列化流 title=反序列化流></a>反序列化流</h3><p>反序列化流可以从文件中读取对象。参考示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>try</span>(</span><br><span class=line>    <span class=type>FileInputStream</span> <span class=variable>fis</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">FileInputStream</span>(<span class=string>"users.txt"</span>);</span><br><span class=line>    <span class=type>ObjectInputStream</span> <span class=variable>ois</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class=line>){</span><br><span class=line>    List&LTUser> userList = (List&LTUser>) ois.readObject();</span><br><span class=line>    <span class=keyword>for</span>(User user : userList){</span><br><span class=line>        System.out.println(user);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=打印流><a class=headerlink href=#打印流 title=打印流></a>打印流</h2><h3 id=概述-21><a class=headerlink href=#概述-21 title=概述></a>概述</h3><p>打印流指的是打印、输出的流。<p>打印流有如下几个特点：<ul><li>打印流只有输出流，没有输入流。<li>特有方法可实现数据原样写出。<li>特有方法可实现自动刷新、自动换行。</ul><p>打印流分为两种：字节打印流 和 字符打印流。<ul><li>字节打印流：PrintStream。<li>字符打印流：PrintWriter。</ul><h3 id=字节打印流><a class=headerlink href=#字节打印流 title=字节打印流></a>字节打印流</h3><p>字节打印流底层没有缓冲区，但可以实现自动刷新。<h3 id=字符打印流><a class=headerlink href=#字符打印流 title=字符打印流></a>字符打印流</h3><p>字符打印流底层有缓冲区，想要实现自动刷新需要开启。<h1 id=线程编程><a class=headerlink href=#线程编程 title=线程编程></a>线程编程</h1><h2 id=线程><a class=headerlink href=#线程 title=线程></a>线程</h2><h3 id=概述-22><a class=headerlink href=#概述-22 title=概述></a>概述</h3><p><strong>线程是CPU调度的基本单位</strong>。<p>一个进程中可以存在多个线程，多个线程可以共享进程的资源，每个线程也有自己独立的空间和资源且仅供当前线程使用。<p>线程在运行时有并发和并行两个分类：<ul><li>并发：一个线程在多个任务之间快速切换并执行，同一时间只能执行一个任务，但因切换速度较快，感觉是在同时执行。<li>并行：多个线程对应多个任务同时执行，线程无需切换。可实现真正的同一时间多任务同时执行。</ul><h3 id=实现方式><a class=headerlink href=#实现方式 title=实现方式></a>实现方式</h3><p>创建线程的方式有多种，详情如下：<ul><li>继承Thread类。<li>实现Runable接口。<li>利用Callable接口和Future接口实现。<li>基于线程池创建</ul><h2 id=同步><a class=headerlink href=#同步 title=同步></a>同步</h2><h3 id=概述-23><a class=headerlink href=#概述-23 title=概述></a>概述</h3><p><strong>计算机科学中，同步指的是两个不同但有联系的概念：进程同步与数据同步</strong>。进程同步指多个进程在特定点会合或握手达成协议或使得操作序列有序。数据同步指一个数据集的多份拷贝一致以维护完整性。常用进程同步原语来实现数据同步。<p>多个线程或进程要执行同一个特定的不可重入的程序代码块（临界区），这就需要适当的并发控制同步技术。否则，可能会发生竟态条件。<blockquote><p>竟态条件描述的是一个系统或进程的输出依赖于不受控制的事件出现的顺序或时机。此词语源于两个信号彼此竞争，来影响谁先输出。</blockquote><h3 id=同步代码块><a class=headerlink href=#同步代码块 title=同步代码块></a>同步代码块</h3><p>同步代码块的格式示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>synchronized</span>(<span class=built_in>this</span>/Student.class){</span><br><span class=line>    <span class=comment>//....</span></span><br><span class=line>}</span><br></pre></table></figure><p>可作为同步代码块中锁的元素如下：<ul><li>this：表示同步代码块调用者本身，无法实现多个线程间的同步。<li>字节码：字节码文件，全局唯一，可以实现多个线程间的同步。<li>类对象引用：对象引用本身，全局唯一，可以实现多个线程间的同步。</ul><h3 id=同步方法><a class=headerlink href=#同步方法 title=同步方法></a>同步方法</h3><p>同步方法的格式示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>修饰符 <span class=keyword>synchronized</span> 返回值类型 方法名(方法参数){</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>同步方法有静态与非静态之分，区别如下：<ul><li>静态同步方法：锁为当前类的字节码文件对象（类名.class）。<li>非静态方法：锁为方法调用者本身（this）。</ul><h2 id=线程池><a class=headerlink href=#线程池 title=线程池></a>线程池</h2><h3 id=概述-24><a class=headerlink href=#概述-24 title=概述></a>概述</h3><p>线程池是一种线程使用模式。线程过多会带来调度开销，影响缓存局部性和整体性能，而线程池维护着多个线程，等待被分配任务，避免了频繁创建与销毁线程的代价。<h3 id=创建线程池><a class=headerlink href=#创建线程池 title=创建线程池></a>创建线程池</h3><p>创建一个线程池有多种方式，常用方式为：<ul><li>方式一：调用Executors的静态方法来创建。要注意的是，这些静态方法创建的线程池的等待队列理论无上限，易造成内存溢出。<li>方式二（推荐）：自定义参数创建ThreadPoolExecutor对象来创建一个线程池。</ul><p>线程池重要参数：<ul><li>核心线程数量<li>最大线程数量<li>空闲时间<li>空间时间的单位<li>等待队列<li>线程工厂<li>拒绝策略</ul><p>创建线程池时，设定合适数量的线程会带来良好的效果。线程池中线程数量的设定通常遵循以下规则：<ul><li>计算密集型任务：<code>处理器最大核心数量+1</code>。<li>IO密集型任务：<code>处理器最大核心数量*期望CPU利用率*((CPU计算时间+等待时间)/CPU计算时间)</code>。</ul><h1 id=网络编程><a class=headerlink href=#网络编程 title=网络编程></a>网络编程</h1><h2 id=概述-25><a class=headerlink href=#概述-25 title=概述></a>概述</h2><p>网络编程指的是计算机与计算机之间通过网络进行数据传输和通信。<h2 id=软件架构><a class=headerlink href=#软件架构 title=软件架构></a>软件架构</h2><p>软件架构通常有两类：CS架构和BS架构。CS表示客户端和服务端，需要两套系统。BS表示浏览器和服务端，只需要开发服务端系统即可。两者优缺点，显而易见。<h2 id=三要素><a class=headerlink href=#三要素 title=三要素></a>三要素</h2><p><strong>网络编程三要素为：IP、端口、协议</strong>。<p>IP表示设备在网络中的地址，是唯一标识。端口表示应用程序在设备中的唯一标识。协议表示数据在网络中传输的规则，常见的协议有UDP、TCP、HTTP、HTTPS、FTP等。<h3 id=IP><a class=headerlink href=#IP title=IP></a>IP</h3><p><strong>IP全称为Internet Protocol，是互联网协议地址，也称IP地址，是分配给上网设备的数字标签</strong>。<p>IP地址常见的分类有：IPV4、IPV6。<h4 id=IPV4><a class=headerlink href=#IPV4 title=IPV4></a>IPV4</h4><p><strong>IPV4表示互联网通信协议第四版，采用32位地址长度，每8位一组，共分4组，现实中通常用点分十进制来表示</strong>。<blockquote><p>IP地址协议第一次发布就是第四版，前三版没有对外发布。</blockquote><p>IPV4共有2^32次方个IP地址，<strong>2019年11月26日，IPV4地址分配使用完毕</strong>。<h4 id=IPV6><a class=headerlink href=#IPV6 title=IPV6></a>IPV6</h4><p><strong>IPV6表示互联网通信协议第六版，采用128位地址长度，每16位一组，分8组，现实中通常用冒号分十六进制来表示</strong>。<p>IPV6共有2^128次方个IP地址，足够应付目前使用。<h3 id=端口号><a class=headerlink href=#端口号 title=端口号></a>端口号</h3><p><strong>端口号是程序在设备中的唯一标识</strong>。<p>端口号是由两个字节的整数来表示，取值范围为0<del>65535。其中0</del>1023之间的端口号用于一些知名的网络服务或应用，个人使用1024~65535之间的端口号即可。<blockquote><p>一个端口号同时只能被一个应用使用。</blockquote><h3 id=协议><a class=headerlink href=#协议 title=协议></a>协议</h3><h4 id=概述-26><a class=headerlink href=#概述-26 title=概述></a>概述</h4><p><strong>协议指的是网络间通信的规则</strong>。<p>网络间通信协议的标准有：<ul><li>OSI参考模型：世界互联协议标准，因过于理想化，未能全面推广。<li>TCP/IP参考模型：国际标准协议，目前广泛使用的参考模型标准。</ul><p>这两种参考模型的区别如下表：<table><thead><tr><th align=center>OSI参考模型<th align=center>TCP/IP参考模型<th align=center>协议<th align=center>描述<tbody><tr><td align=center>应用层、表示层、会话层<td align=center>应用层<td align=center>http、ftp、telnet<td align=center>应用程序开发<tr><td align=center>传输层<td align=center>传输层<td align=center>tcp、udp<td align=center>选择数据传输的协议<tr><td align=center>网络层<td align=center>网络层<td align=center>ip、icmp、arp<td align=center>封装自己的ip、对方的ip信息等<tr><td align=center>数据链路层、物理层<td align=center>物理+链路层<td align=center>硬件设备<td align=center>转为二进制通过物理设备传输</table><h4 id=UDP协议><a class=headerlink href=#UDP协议 title=UDP协议></a>UDP协议</h4><p><strong>UDP协议，全称User Datagram Protocol，表示用户数据报协议</strong>。<p>UDP协议特定如下：<ul><li>面向无连接的协议。无论对方是否能收到信息，我只管发送。<li>速度快。<li>有大小限制，每次最多发送64K数据。<li>数据不安全，易丢失。</ul><p>UDP通信方式有三种：<ul><li>单播：只对单个设备发送信息。<li>组播：对某一组中的所有设备发送信息。<li>广播：给所有设备发送信息。</ul><h4 id=TCP协议><a class=headerlink href=#TCP协议 title=TCP协议></a>TCP协议</h4><h5 id=简介-12><a class=headerlink href=#简介-12 title=简介></a>简介</h5><p><strong>TCP协议，全称Transmission Control Protocol，表示传输控制协议</strong>。<p>TCP协议特点如下：<ul><li>面向连接的协议。双方连接成功了才会发送信息。<li>发送的数据没有大小限制。<li>数据安全。<li>速度慢。</ul><h5 id=三次握手><a class=headerlink href=#三次握手 title=三次握手></a>三次握手</h5><p><strong>三次握手主要目的是确保成功建立连接，然后才进行通信</strong>。<p>三次握手的过程如下：<ol><li>客户端向服务器发送连接请求，等待服务器确认。<li>服务器收到连接请求，然后发送可连接的响应。<li>客户端收到可连接响应，然后向服务器发送连接请求，建立连接并通信。</ol><h5 id=四次挥手><a class=headerlink href=#四次挥手 title=四次挥手></a>四次挥手</h5><p><strong>四次挥手主要目的是确保通信完毕，没有其他请求和响应</strong>。<p>四次挥手的过程如下：<ol><li>客户端向服务器发送断开连接的请求。<li>服务器收到断开连接的请求，然后响应客户端称已收到你的请求，但请再稍等片刻，我有数据还没有发送完毕。<li>服务器再次向客户端发送可以断开连接的响应信息。<li>客户端收到可以断开连接的信息，客户端再次发送断开连接的请求，断开连接成功。</ol><h1 id=反射><a class=headerlink href=#反射 title=反射></a>反射</h1><h2 id=概述-27><a class=headerlink href=#概述-27 title=概述></a>概述</h2><p><strong>计算机学中，反射指的是程序运行时可以访问、检测和修改它本身状态或行为的一种能力</strong>。比喻来说，反射就是程序运行的时候能够观察并修改自己的行为。<p>Java中的反射描述的是程序运行过程中，可以访问类的成员变量、成员方法、构造方法等信息，并可以通过这些信息来对类做进一步的管理。<p>J<strong>ava中的反射实际执行中是通过Class对象来获取类的信息并做进一步管理</strong>。<h2 id=管理类成员><a class=headerlink href=#管理类成员 title=管理类成员></a>管理类成员</h2><h3 id=获取Class对象><a class=headerlink href=#获取Class对象 title=获取Class对象></a>获取Class对象</h3><p>获取Class对象的方式如下：<ul><li>方式一：<code>Class.forName("全类名");</code><li>方式二：<code>类名.class;</code><li>方式三：<code>对象.getClass();</code></ul><h3 id=管理字段><a class=headerlink href=#管理字段 title=管理字段></a>管理字段</h3><p>获取类成员字段的方式如下：<ul><li>获取所有公共字段：getFields();<li>获取所有字段：getDeclaredFields();<li>获取单个公共字段：getField(String name);<li>获取单个字段：getDeclaredField(String name);</ul><p>基于字段可执行的操作：<ul><li>赋值：set(Object obj, Object val);<li>获取值：get(Object obj);</ul><h3 id=管理构造器><a class=headerlink href=#管理构造器 title=管理构造器></a>管理构造器</h3><p>获取构造器的方式如下：<ul><li>获取所有公共构造器：getConstructors();<li>获取所有构造器：getDeclaredConstructors();<li>获取单个公共构造器：getConstructor(Class…type);<li>获取单个构造器：getDeclaredConstructor(Class…type)</ul><p>基于构造器反射创建对象的方式如下：<ul><li>newInstance(Object…args);<li>setAccessible(boolean flag)</ul><h3 id=管理方法><a class=headerlink href=#管理方法 title=管理方法></a>管理方法</h3><p>获取类成员方法的方式如下：<ul><li>获取所有公共方法：getMethods();<li>获取所有方法：getDeclaredMethods();<li>获取单个公共方法：getMethod(String name, Class…type);<li>获取单个方法：getDeclaredMethod(String name, Class…type);</ul><p>基于方法可执行的操作：<ul><li>执行方法：invoke(Object obj, Object…args);</ul><h1 id=动态代理><a class=headerlink href=#动态代理 title=动态代理></a>动态代理</h1><h2 id=概述-28><a class=headerlink href=#概述-28 title=概述></a>概述</h2><p>代理可以无侵入式的为对象增加功能。<p>代理对象和被代理对象通过实现同一接口来实现代理功能，接口中是要被代理的方法。<h2 id=创建代理><a class=headerlink href=#创建代理 title=创建代理></a>创建代理</h2><p>Java中创建代理对象可以通过java.lang.Proxy类来实现。Proxy类提供了一个创建代理对象的方法<code>newProxyInstance(...)</code>，该方法有三个参数：<ul><li>ClassLoader：设置要加载代理类的类加载器。<li>Interface：设定要代理哪个接口中的方法。<li>InvocationHandler：代理要执行的具体逻辑。</ul><p>代码示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">ProxyFactory</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> Object <span class="title function_">getProxy</span><span class=params>(Object obj)</span>{</span><br><span class=line>        <span class=keyword>return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), </span><br><span class=line>                                     <span class=keyword>new</span> <span class="title class_">MyInvocationHandler</span>(obj));</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=comment>// 自定义执行器</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">MyInvocationHandler</span>{</span><br><span class=line>    <span class=keyword>private</span> Object target;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MyInvocationHandler</span><span class=params>(Object obj)</span>{</span><br><span class=line>        <span class=built_in>this</span>.target = obj;</span><br><span class=line>    }	</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">invoke</span><span class=params>(Object proxy, Method m, Object[] args)</span> <span class=keyword>throws</span> throwable {</span><br><span class=line>        <span class=keyword>return</span> m.invoke(target, args);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/10/12/Java%E4%B9%8BWeb%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/10/12/Java%E4%B9%8BWeb%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/ itemprop=url>未命名</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-10-12 11:23:46 / 修改时间：11:12:41" datetime=2024-10-12T11:23:46+08:00>2024-10-12</time> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=网络协议><a class=headerlink href=#网络协议 title=网络协议></a>网络协议</h1><h2 id=HTTP协议><a class=headerlink href=#HTTP协议 title=HTTP协议></a>HTTP协议</h2><h3 id=概述><a class=headerlink href=#概述 title=概述></a>概述</h3><p><strong>http协议全称为超文本传输协议</strong>。<p>http协议的特点如下：<ul><li>基于TCP协议，面向连接，安全可靠。<li>基于请求、响应模型，一次请求对应一次响应。<li>http协议是无状态协议。</ul><h3 id=HTTP请求><a class=headerlink href=#HTTP请求 title=HTTP请求></a>HTTP请求</h3><h4 id=请求组成><a class=headerlink href=#请求组成 title=请求组成></a>请求组成</h4><p>HTTP请求包含四部分内容：<ul><li>请求头：请求方式+请求连接+http协议版本。例如：<code>GET /hello?a=1&b=2 HTTP/1.1</code>。<li>请求行：请求与响应相关的键值对信息。例如：<code>Host: localhost:8080</code>、<code>Accept: application/json, text/plain, */*</code>等信息。<li>空行：用于分割请求头和请求体，不可缺少。<li>请求体：请求携带的数据。通常为json格式。</ul><blockquote><p>GET请求也存在请求体，但据规范来讲GET请求不该有请求体，所以大家一致认为GET请求没有请求体，这一点要知道。</blockquote><h4 id=请求方式><a class=headerlink href=#请求方式 title=请求方式></a>请求方式</h4><table><thead><tr><th align=center>对比项<th align=center>用途<th align=center>传参<th align=center>幂等性<tbody><tr><td align=center>GET请求<td align=center>从服务获取资源<td align=center>通过请求URL后面拼接参数来传递。参数大小受浏览器和服务器限制。<td align=center>满足幂等<tr><td align=center>POST请求<td align=center>向服务器提交数据<td align=center>通过请求体传送。参数大小受服务器配置和网络环境等因素限制。<td align=center>非幂等<tr><td align=center>PUT请求<td align=center>向指定资源上传递新的表示<td align=center>通过请求体传送。参数大小受服务器配置和网络环境等因素限制。<td align=center>满足幂等<tr><td align=center>DELETE请求<td align=center>请求服务器删除资源<td align=center>通过请求URL或请求体传送。参数大小受服务器配置和网络环境等因素限制。<td align=center>满足幂等<tr><td align=center>PATCH请求<td align=center>对资源进行局部更新<td align=center>通过请求体传送。参数大小受服务器配置和网络环境等因素限制。<td align=center>非幂等<tr><td align=center>HEAD请求<td align=center>类似于GET，服务器只返回头信息<td align=center>通过URL查询字符串传送。因不包含实体主体，不考虑参数大小限制。<td align=center>满足幂等<tr><td align=center>OPTIONS请求<td align=center>获取目标资源支持的通信选项<td align=center>通过URL查询字符串传送。因不包含实体主体，不考虑参数大小限制。<td align=center>满足幂等<tr><td align=center>TRACE请求<td align=center>在目标资源路径上执行一个消息环回测试<td align=center>通过URL查询字符串传送。因主要用于测试，故不考虑参数大小限制。<td align=center>满足幂等</table><h3 id=HTTP响应><a class=headerlink href=#HTTP响应 title=HTTP响应></a>HTTP响应</h3><h4 id=响应组成><a class=headerlink href=#响应组成 title=响应组成></a>响应组成</h4><p>HTTP响应包含四部分内容：<ul><li>响应头：http协议版本+状态码+描述。例如：<code>HTTP/1.1 200 OK</code>。<li>响应行：表示请求与响应相关的键值对信息。例如：<code>Content-Type: application/json</code>、<code>Keep-Alive: timeout=50</code>等等信息。<li>空行：用于分割响应头和响应体，是必须的。<li>响应体：响应携带的数据。通常为json格式。</ul><h4 id=响应状态码><a class=headerlink href=#响应状态码 title=响应状态码></a>响应状态码</h4><p>响应状态码分为以下几种：<ul><li>1xx：响应中，临时状态码。<li>2xx：处理成功。表示请求已被接收，成功处理完成。<li>3xx：重定向。服务器告诉客户端重定向到另一个地址去获取数据。<li>4xx：客户端错误。错误的原因出在客户端身上，比如客户端没有权限访问等。<li>5xx：服务器错误。错误的原因出在服务器身上，比如执行程序时抛出了异常。</ul><h1 id=Maven><a class=headerlink href=#Maven title=Maven></a>Maven</h1><h2 id=Maven属性><a class=headerlink href=#Maven属性 title=Maven属性></a>Maven属性</h2><p>属性分类如下表所示：<table><thead><tr><th align=center>属性分类<th align=center>引用格式<th align=center>使用示例<tbody><tr><td align=center>自定义属性<td align=center>${自定义属性名}<td align=center>${spring.version}<tr><td align=center>内置属性<td align=center>${内置属性名}<td align=center>${basedir}、${version}<tr><td align=center>Setting属性<td align=center>${settings.属性名}<td align=center>${settings.localRepository}<tr><td align=center>Java系统属性<td align=center>${系统属性分类.系统属性名}<td align=center>${user.home}<tr><td align=center>环境变量属性<td align=center>${env.环境变量属性名}<td align=center>${env.JAVA_HOME}</table><h2 id=多环境开发><a class=headerlink href=#多环境开发 title=多环境开发></a>多环境开发</h2><p><strong>（1）配置多个环境</strong><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>profiles</span>></span></span><br><span class=line>	<span class=tag><<span class=name>profile</span>></span></span><br><span class=line>    	<span class=tag><<span class=name>id</span>></span>env_dev<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>        <span class=tag><<span class=name>properties</span>></span></span><br><span class=line>        	<span class=tag><<span class=name>jdbc.url</span>></span>jdbc:mysql://127.0.0.1:3306/test_ssm<span class=tag>&LT/<span class=name>jdbc.url</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>properties</span>></span></span><br><span class=line>        <span class=tag><<span class=name>activation</span>></span></span><br><span class=line>        	<span class=tag><<span class=name>activeByDefault</span>></span>true<span class=tag>&LT/<span class=name>activeByDefault</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>activation</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>profile</span>></span></span><br><span class=line>    <span class=tag><<span class=name>profile</span>></span></span><br><span class=line>    	<span class=tag><<span class=name>id</span>></span>env_test<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>        <span class=tag><<span class=name>properties</span>></span></span><br><span class=line>        	<span class=tag><<span class=name>jdbc.url</span>></span>jdbc:mysql://127.0.0.1:3306/test_ssm<span class=tag>&LT/<span class=name>jdbc.url</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>properties</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>profile</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>profiles</span>></span></span><br></pre></table></figure><p><strong>（2）使用指定环境</strong><p>使用指定环境有两种方式：<ul><li>通过标签<code>activation</code>来激活当前环境为默认环境。<li>通过命令<code>mvn install -P 环境ID</code>来指定使用当前环境。</ul><h2 id=依赖管理><a class=headerlink href=#依赖管理 title=依赖管理></a>依赖管理</h2><h3 id=依赖传递><a class=headerlink href=#依赖传递 title=依赖传递></a>依赖传递</h3><p><strong>依赖与依赖之间存在传递性</strong>。例如：A依赖B，B依赖C，那么A也会依赖C，这种情况就称为依赖传递。<p><strong>依赖之间的关系有直接依赖与间接依赖之分</strong>。例如：对于依赖A来说，依赖B是直接依赖，依赖C是间接依赖。对于依赖B来说，依赖C是直接依赖。<p>依赖传递过程中存在优先级高低之分，优先级高的会被最终使用，优先级低的不会被使用。优先级高低的判断标准如下：<ul><li>两个不同版本的同一种直接依赖，后写的会覆盖先写的，也就是后写的优先级高。<li>间接依赖中，距离当前项目最近的间接依赖优先级最高。</ul><h3 id=可选依赖><a class=headerlink href=#可选依赖 title=可选依赖></a>可选依赖</h3><p><strong>如果在添加一个依赖的同时不希望该依赖传递给其它项目，那么可以配置该依赖为可选依赖</strong>。<p>通过配置标签<code>&LToptional>true&LT/optional></code>可将一个依赖配置为可选依赖。示例代码如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>com.xxx<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>xxx<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>1.x<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>    <span class=tag><<span class=name>optional</span>></span>true<span class=tag>&LT/<span class=name>optional</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><h3 id=排除依赖><a class=headerlink href=#排除依赖 title=排除依赖></a>排除依赖</h3><p><strong>在引入一个依赖时，如果不希望因为依赖的传递性而引入该依赖中引入的其它依赖（间接依赖），那么可以在引入该依赖时对不希望引入的间接依赖进行排除</strong>。<p>通过配置标签<code>&LTexclusions>&LT/exclusions></code>可实现在引入一个依赖时排除间接依赖。代码示例如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>com.xxx<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>xxx<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>1.x<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>    <span class=tag><<span class=name>exclusions</span>></span></span><br><span class=line>    	<span class=tag><<span class=name>exclusion</span>></span></span><br><span class=line>        	<span class=tag><<span class=name>groupId</span>></span>com.xxx.xxx<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>            <span class=tag><<span class=name>artifactId</span>></span>xxx.xxx<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>exclusion</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>exclusions</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><h2 id=Maven继承><a class=headerlink href=#Maven继承 title=Maven继承></a>Maven继承</h2><h3 id=概述-1><a class=headerlink href=#概述-1 title=概述></a>概述</h3><p>创建一个没有业务逻辑的项目作为父项目，该父项目<strong>只负责管理多个子项目的共同依赖及其依赖的版本</strong>，子项目在需要某个依赖时只需通过配置标签<code>&LTparent>...&LT/parent></code>继承父项目就会默认拥有该依赖。继承简化了依赖配置，统一进行管理，方便高效。<h3 id=实现继承><a class=headerlink href=#实现继承 title=实现继承></a>实现继承</h3><p>创建一个没有业务逻辑的maven项目作为父项目，配置其打包方式为pom。在子项目的pom.xml文件中通过配置标签<code>&LTparent>...&LT/parent></code>来继承父项目。参考示例如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- 父项目 --></span></span><br><span class=line><span class=tag><<span class=name>groupId</span>></span>cn.shh<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line><span class=tag><<span class=name>artifactId</span>></span>mall-parent<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line><span class=tag><<span class=name>version</span>></span>1.0-SNAPSHOT<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag><<span class=name>packaging</span>></span>pom<span class=tag>&LT/<span class=name>packaging</span>></span></span><br><span class=line></span><br><span class=line><span class=comment>&LT!-- 子项目 --></span></span><br><span class=line><span class=tag><<span class=name>parent</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>cn.shh<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>mall-parent<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>1.0-SNAPSHOT<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>    <span class=tag><<span class=name>relativePath</span>/></span> <span class=comment>&LT!--父项目pom文件的相对位置--></span></span><br><span class=line><span class=tag>&LT/<span class=name>parent</span>></span></span><br></pre></table></figure><p><strong>子项目在继承父项目后，也会继承父项目的groupId，故子项目的groupId可以省略</strong>。<p><strong>注意事项</strong>：父子项目配置了同一个依赖的不同版本时，以子工程为准。<h3 id=版本锁定><a class=headerlink href=#版本锁定 title=版本锁定></a>版本锁定</h3><p>版本锁定说的是在父项目中通过标签<code>&LTdependencyManagement></code>来管理所有子项目需要用到的依赖及版本信息，要注意的是，该标签下配置的依赖不会自动传递给子项目，子项目需要某个依赖时必须手动添加该依赖，但无需指定版本信息，这样一来就使用到了父项目中管理的指定版本的依赖。<p><strong>注意事项</strong>：父项目中标签<code>&LTdependencyManagement></code>下配置的依赖不会自动传递给子项目，子项目需要某个依赖时必须手动添加，但无需配置版本信息，因版本在父项目中已经配置。<p>为了更便利的管理依赖的版本，可以将依赖版本信息通过自定义标签来配置管理，标签<code>version</code>中通过使用符号<code>${自定义标签名}</code>来使用配置的依赖版本信息。<p>配置参考示例如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- 父项目 --></span></span><br><span class=line><span class=tag><<span class=name>properties</span>></span></span><br><span class=line>	<span class=tag><<span class=name>xxx.version</span>></span>1.1.1<span class=tag>&LT/<span class=name>xxx.version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>properties</span>></span></span><br><span class=line><span class=tag><<span class=name>dependencyManagement</span>></span></span><br><span class=line>	<span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>    	<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>        	<span class=tag><<span class=name>groupId</span>></span>xxx.xxx<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>            <span class=tag><<span class=name>artifactId</span>></span>xxx<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>            <span class=comment>&LT!--引用自定义的版本信息--></span></span><br><span class=line>            <span class=tag><<span class=name>version</span>></span>${xxx.version}<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>dependencies</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencyManagement</span>></span></span><br><span class=line></span><br><span class=line><span class=comment>&LT!-- 子项目 --></span></span><br><span class=line><span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>    <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>        <span class=tag><<span class=name>groupId</span>></span>xxx.xxx<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>artifactId</span>></span>xxx<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencies</span>></span></span><br></pre></table></figure><h2 id=Maven聚合><a class=headerlink href=#Maven聚合 title=Maven聚合></a>Maven聚合</h2><h3 id=概述-2><a class=headerlink href=#概述-2 title=概述></a>概述</h3><p>对多个maven项目进行编译、打包等操作时需要按照项目依赖的先后顺序来执行，否则无法完成编译、打包等操作。当项目数量非常多时，工作也会变得更加繁重。<p>为了解决繁重的重复工作，maven聚合功能出现了。<strong>通过maven聚合可以实现一键编译、打包等工作，无需再担心项目间的依赖问题</strong>。<h3 id=实现聚合><a class=headerlink href=#实现聚合 title=实现聚合></a>实现聚合</h3><p>聚合是在继承的基础上进行的，实现聚合需要满足两个条件：<ol><li>聚合项目打包方式必须为<code>pom</code>。<li>聚合项目中使用标签<code>&LTmodules>&LT/modules></code>来配置需要聚合的子项目。</ol><p>代码示例如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>modules</span>></span></span><br><span class=line>	<span class=tag><<span class=name>module</span>></span>mall-order<span class=tag>&LT/<span class=name>module</span>></span><span class=comment>&LT!--这里配置的是子项目的相对位置--></span></span><br><span class=line>    <span class=tag><<span class=name>module</span>></span>mall-product<span class=tag>&LT/<span class=name>module</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>modules</span>></span></span><br></pre></table></figure><h2 id=Maven私服><a class=headerlink href=#Maven私服 title=Maven私服></a>Maven私服</h2><h3 id=概述-3><a class=headerlink href=#概述-3 title=概述></a>概述</h3><p><strong>私服是一种特殊的远程仓库，它是架设在局域网内的仓库，用来代理外部的中央仓库，用于解决团队的资源共享与资源同步问题</strong>。<p>私服搭建实现方案有多种，比如 Archiva、Artifactory、Nexus等。推荐使用Nexus来搭建，该工具免费、稳定，且功能强大。<p>项目依赖的查找顺序为：<ol><li>本地仓库<li>私服<li>中央仓库</ol><h3 id=上传与下载><a class=headerlink href=#上传与下载 title=上传与下载></a>上传与下载</h3><p>想要将依赖或jar包上传至私服或从私服下载资源，需要私服的地址和访问权限。<p>上传资源到私服或从私服下载依赖、资源需要进行一些配置。配置步骤参考如下：<p><strong>（1）配置访问私服的用户</strong><p>在maven的settings.xml文件的servers标签中配置server信息。详情参考如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>servers</span>></span></span><br><span class=line>	<span class=tag><<span class=name>server</span>></span></span><br><span class=line>    	<span class=tag><<span class=name>id</span>></span>maven-releases<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>        <span class=tag><<span class=name>username</span>></span>admin<span class=tag>&LT/<span class=name>username</span>></span></span><br><span class=line>        <span class=tag><<span class=name>password</span>></span>admin<span class=tag>&LT/<span class=name>password</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>server</span>></span></span><br><span class=line>    <span class=tag><<span class=name>server</span>></span></span><br><span class=line>    	<span class=tag><<span class=name>id</span>></span>maven-snapshots<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>        <span class=tag><<span class=name>username</span>></span>admin<span class=tag>&LT/<span class=name>username</span>></span></span><br><span class=line>        <span class=tag><<span class=name>password</span>></span>admin<span class=tag>&LT/<span class=name>password</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>server</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servers</span>></span></span><br></pre></table></figure><p><strong>（2）配置私服仓库组地址</strong><p>在maven的settings.xml文件中的标签mirrors、profiles中配置仓库组地址。<strong>如果配置过阿里云等的地址，请覆盖或注释掉</strong>。详情参考如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>mirrors</span>></span></span><br><span class=line>	<span class=tag><<span class=name>mirror</span>></span></span><br><span class=line>    	<span class=tag><<span class=name>id</span>></span>maven-public<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>        <span class=tag><<span class=name>mirrorOf</span>></span>*<span class=tag>&LT/<span class=name>mirrorOf</span>></span></span><br><span class=line>        <span class=tag><<span class=name>url</span>></span>http://192.168.1.100:8081/repository/maven-public/<span class=tag>&LT/<span class=name>url</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>mirror</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>mirrors</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>profiles</span>></span></span><br><span class=line>	<span class=tag><<span class=name>profile</span>></span></span><br><span class=line>    	<span class=tag><<span class=name>id</span>></span>allow-snapshots<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>        <span class=tag><<span class=name>activation</span>></span></span><br><span class=line>        	<span class=tag><<span class=name>activeByDefault</span>></span>true<span class=tag>&LT/<span class=name>activeByDefault</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>activation</span>></span></span><br><span class=line>        <span class=tag><<span class=name>repositories</span>></span></span><br><span class=line>        	<span class=tag><<span class=name>repository</span>></span></span><br><span class=line>            	<span class=tag><<span class=name>id</span>></span>maven-public<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>                <span class=tag><<span class=name>url</span>></span>http://192.168.1.100:8081/repository/maven-public/<span class=tag>&LT/<span class=name>url</span>></span></span><br><span class=line>                <span class=tag><<span class=name>releases</span>></span></span><br><span class=line>                	<span class=tag><<span class=name>enabled</span>></span>true<span class=tag>&LT/<span class=name>enabled</span>></span></span><br><span class=line>                <span class=tag>&LT/<span class=name>releases</span>></span></span><br><span class=line>                <span class=tag><<span class=name>snapshots</span>></span></span><br><span class=line>                	<span class=tag><<span class=name>enabled</span>></span>true<span class=tag>&LT/<span class=name>enabled</span>></span></span><br><span class=line>                <span class=tag>&LT/<span class=name>snapshots</span>></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>repository</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>repositories</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>profile</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>profiles</span>></span></span><br></pre></table></figure><p><strong>（3）配置私服的访问地址</strong><p>在maven工程项目的pom.xml文件中配置访问地址信息。详情参考如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>distributionManagement</span>></span></span><br><span class=line>	<span class=tag><<span class=name>repository</span>></span></span><br><span class=line>    	<span class=tag><<span class=name>id</span>></span>maven-releases<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>        <span class=tag><<span class=name>url</span>></span>http://192.168.1.100:8081/repository/maven-releases/<span class=tag>&LT/<span class=name>url</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>repository</span>></span></span><br><span class=line>	<span class=tag><<span class=name>snapshotRepository</span>></span></span><br><span class=line>    	<span class=tag><<span class=name>id</span>></span>maven-snapshots<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>        <span class=tag><<span class=name>url</span>></span>http://192.168.1.100:8081/repository/maven-snapshots/<span class=tag>&LT/<span class=name>url</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>snapshotRepository</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>distributionManagement</span>></span></span><br></pre></table></figure><p><strong>注意事项</strong>：标签repository中的id属性值要与maven的settings.xml文件中的标签server中的id属性值一样。</div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/10/12/Java%E4%B9%8BJVM%E7%9F%A5%E8%AF%86%E7%AF%87/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/10/12/Java%E4%B9%8BJVM%E7%9F%A5%E8%AF%86%E7%AF%87/ itemprop=url>Java系列-JVM</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-10-12 11:23:46" datetime=2024-10-12T11:23:46+08:00>2024-10-12</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2024-10-11 22:50:38" datetime=2024-10-11T22:50:38+08:00 itemprop=dateModified>2024-10-11</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/JVM/ itemprop=url rel=index><span itemprop=name>JVM</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=0、必知必会><a class=headerlink href=#0、必知必会 title=0、必知必会></a>0、必知必会</h1><h2 id=0-1、Java类加载><a class=headerlink href=#0-1、Java类加载 title=0.1、Java类加载></a>0.1、Java类加载</h2><h3 id=0-1-1、Class文件><a class=headerlink href=#0-1-1、Class文件 title=0.1.1、Class文件></a>0.1.1、Class文件</h3><h4 id=0-1-1-1、简介><a class=headerlink href=#0-1-1-1、简介 title=0.1.1.1、简介></a>0.1.1.1、简介</h4><p><strong>Class文件是一组以8位为单位的 二进制流，超过8位以上的会被按照 高位在前 分割成多个8位进行存储。</strong><p>Class文件格式采用一种类似C语言结构体的伪结构进行数据存储，其中包含两种数据类型，即 无符号数和表 。<ul><li><p><strong>无符号数</strong>：无符号数属于基本数据类型，以u1、u2、u4、u8分别代表1字节、2字节、4字节、8字节的无符号数。它可以描述数字、索引引用、数量值、utf8编码后的字符串值。</p><li><p><strong>表</strong>：<strong>表是由多个无符号数和其它表组成的复合数据类型</strong>。所有表都以<code>_info</code>结尾，用来描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。</p></ul><h4 id=0-1-1-2、class文件结构><a class=headerlink href=#0-1-1-2、class文件结构 title=0.1.1.2、class文件结构></a>0.1.1.2、class文件结构</h4><h5 id=简介><a class=headerlink href=#简介 title=简介></a>简介</h5><p><img alt=image-20210428110838690 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210428110838690.png><p>classFile结构中，各项含义如下：<ol><li>magic：魔数，4个字节。<li>minor_version/major_version：class文件次版本号/主版本号。<li>constant_pool_count：常量池计数器，2个字节（FFFF=65535）。<li>constant_pool[constant_pool_count-1]：常量池。<li>access_flags：访问标志。<li>this_class：类索引。<li>super_class：父类索引。<li>interfaces_count：接口计数器，2个字节（FFFF=65535）。<li>interfaces[interfaces_count]：接口表。<li>fields_count：字段计数器，2个字节（FFFF=65535）。<li>fields[fields_count]：字段表。<li>methods_count：方法计数器，2个字节（FFFF=65535）。<li>methods[methods_count]：方法表。<li>attributes_count：属性计数器，2个字节（FFFF=65535）。<li>attributes[attributes_count]：属性表。</ol><h5 id=魔数><a class=headerlink href=#魔数 title=魔数></a>魔数</h5><p><strong>无法通过文件扩展名来确定文件类型</strong>，文件扩展名可以随意修改，不影响其中的内容。一些软件或工具通常是根据文件的头几个字节（文件头）来检验文件类型，如果类型不支持，就会给出错误提示。<p>**Java字节码文件的文件头，也就是魔数的具体内容为<code>CAFEBABE</code>**，虚拟机进行加载时会对之进行检测判断，不满足时会直接报错。<p>除了Java文件外，其它常见的文件及对应文件头内容如下：<ul><li>XML：文件头大小5个字节，内容<code>3C3F786D6C</code>。<li>AVI：文件头大小4个字节，内容<code>41564920</code>。<li>PNG：文件头大小4个字节，内容为<code>89504E47</code>，且文件尾部也有要求。<li>JPEG：文件头大小3个字节，内容为<code>FFD8FF</code>。<li>BMP：文件头大小2个字节，内容<code>424D</code>。</ul><h5 id=主次版本号><a class=headerlink href=#主次版本号 title=主次版本号></a>主次版本号</h5><p>主次版本号指的是编译字节码文件的JDK版本号，主版本号用来标识大版本号，JDK1.0-1.1使用了45.0-45.3，JDK1.2是46，之后每升级一个大版本就加1。次版本号是当主版本相同时用来区分不同的版本，一般只需关注主版本号。<blockquote><p>JDK1.2之后JDK大版本号的计算方法为<code>主版本号-44</code>。比如主版本号为52，则表示的是JDK8</blockquote><p><strong>版本号的作用主要是判断当前字节码的版本和运行时的JDK是否兼容</strong>。<h5 id=常量池><a class=headerlink href=#常量池 title=常量池></a>常量池</h5><p><strong>常量池的作用为：避免相同的内容重复定义，节省空间</strong>。<p>常量池中的数据都有一个编号，编号从1开始。在字段或字节码指令中通过编号可以快速找到对应的数据。字节码指令中，通过编号引用到常量池的过程称之为符号引用。<h5 id=方法><a class=headerlink href=#方法 title=方法></a>方法</h5><p>字节码中的方法区域是存放字节码指令的核心位置，字节码指令的内容存放在方法的Code属性中。<h3 id=0-1-2、类加载过程><a class=headerlink href=#0-1-2、类加载过程 title=0.1.2、类加载过程></a>0.1.2、类加载过程</h3><h4 id=0-1-2-1、概述><a class=headerlink href=#0-1-2-1、概述 title=0.1.2.1、概述></a>0.1.2.1、概述</h4><p>虚拟机 把 描述类的数据 从Class文件加载到内存，并对数据进行校验、转化解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<p>整个生命周期包括：<strong>加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸载(Unloading)7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）</strong>。<p>加载分为两类：<ul><li><strong>显式加载</strong>：通过类加载器加载一个类。<li><strong>隐式加载</strong>：不直接使用类加载器加载类，而是虚拟机自动加载完成。</ul><blockquote><p>加载后，类的一些信息可通过工具HSDB来查看。<p>HSDB启动命令：<code>java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB</code></blockquote><h4 id=0-1-2-2、加载阶段><a class=headerlink href=#0-1-2-2、加载阶段 title=0.1.2.2、加载阶段></a>0.1.2.2、加载阶段</h4><p>此阶段虚拟机会做三件事：<ol><li>通过一个<strong>类的全限定名</strong>来<strong>获取</strong>定义此<strong>类的二进制字节流</strong>；<li>将这个字节流所代表的<strong>静态存储结构</strong>转为方法区的<strong>运行时数据结构</strong>；<li>在内存中<strong>生成</strong>一个代表该类的 <strong>java.lang.Class对象</strong>，<strong>作为</strong>方法区中<strong>该类各种数据的访问入口</strong>；</ol><p>获取二进制字节流可以通过Class文件、ZIP包、网络、运行时（动态代理）、JSP生成、数据库等途径获取。<p>那些二进制字节流加载完后，按指定格式存放于方法区内（Java7及以前方法区实现为永久代，Java8实现为Metaspace（元空间））。然后在方法区生成一个比较特殊的<code>java.lang.Class</code>对象，用来作为 访问方法区中这些类型数据的 外部接口。<p><font color=red>注意：数组类不通过类加载器加载，而是由Java虚拟机直接创建，但数组类的元素还是要依靠类加载器进行加载。</font><h4 id=0-1-2-3、链接阶段><a class=headerlink href=#0-1-2-3、链接阶段 title=0.1.2.3、链接阶段></a>0.1.2.3、链接阶段</h4><h5 id=验证阶段><a class=headerlink href=#验证阶段 title=验证阶段></a>验证阶段</h5><p>验证的目的是确保Class文件字节流中的<strong>信息符合当前虚拟机的要求</strong>，且<strong>不会危害虚拟机</strong>自身的安全。<p>验证内容如下：<ol><li>文件格式验证<li>元数据验证<li>字节码验证<li>符号引用验证</ol><h5 id=准备阶段><a class=headerlink href=#准备阶段 title=准备阶段></a>准备阶段</h5><p>准备阶段主要工作：在方法区中<strong>为类变量分配内存、设置默认值</strong>。<p>类变量指的是被static修饰的变量，不包含实例变量，实例变量在对象实例化阶段分配在堆中。并且，变量的初始化值并非是类中定义的值，而是该变量所属类型的默认值。<p><font color=red>注意：变量被final修饰时，该字段属性为ConstantValue，它会在 准备阶段 初始化为指定的值。</font><h5 id=解析阶段><a class=headerlink href=#解析阶段 title=解析阶段></a>解析阶段</h5><p>解析阶段主要工作：虚拟机将常量池内的 <strong>符号引用替换为直接引用</strong>。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用 进行解析。<h4 id=0-1-2-4、初始化阶段><a class=headerlink href=#0-1-2-4、初始化阶段 title=0.1.2.4、初始化阶段></a>0.1.2.4、初始化阶段</h4><p>初始化阶段主要工作：<strong>执行类构造器的<code>clinit()</code>方法</strong>。<p><code>&LTclinit>()</code>方法是由编译器自动<strong>收集类中所有类变量的赋值动作和静态语句块中的语句</strong>合并而成。编译器收集的顺序由语句在源文件中出现的顺序决定，静态语句块中只能访问其之前的变量，之后的变量只能赋值但不能访问。<p><font color=red>注意：<code>&LTclinit>()</code>方法 与 实例构造器() 不同，其不需要 显式调用 父类构造器，虚拟机会保证在子类的clinit()方法执行之前，父类的clinit()方法已经执行完毕。虚拟机会保证一个类的clinit()方法在多线程下被同步加锁。</font><p>会导致类初始化的几种情况如下：<ul><li>调用一个类的静态变量或静态方法，<strong>但若变量被final修饰且值是常量时则不会触发初始化</strong>。<li>调用Class.forName(String className);<li>new一个类的对象。<li>执行main方法触发当前类的初始化。</ul><p>不会执行初始化指令的情况如下：<ul><li>无静态代码块，且无静态变量赋值语句。<li>存在没有赋值的静态变量。<li>静态变量被final修饰。<li>创建一个类数组对象时，类也不会初始化。</ul><p><strong>对于存在父类的情况，直接访问父类的静态变量，不会触发子类的初始化。但子类初始化clinit调用前，会先调用父类的clinit初始化方法</strong>。<h4 id=0-1-2-5、使用和卸载阶段><a class=headerlink href=#0-1-2-5、使用和卸载阶段 title=0.1.2.5、使用和卸载阶段></a>0.1.2.5、使用和卸载阶段</h4><p>类被加载并初始化后就是一个可以被使用的完整类。当类不再被使用时，或虚拟机关闭时会类进行卸载。<h3 id=0-1-3、类加载器><a class=headerlink href=#0-1-3、类加载器 title=0.1.3、类加载器></a>0.1.3、类加载器</h3><h4 id=0-1-3-1、简介><a class=headerlink href=#0-1-3-1、简介 title=0.1.3.1、简介></a>0.1.3.1、简介</h4><p><strong>通过 类的全限定名 获取该类二进制字节流的代码块叫 类加载器</strong>。<h4 id=0-1-3-2、类加载器分类><a class=headerlink href=#0-1-3-2、类加载器分类 title=0.1.3.2、类加载器分类></a>0.1.3.2、类加载器分类</h4><p><strong>JVM规范中规定，将派生于抽象类<code>ClassLoader</code>的类加载器都称为 自定义类加载器</strong>。<p>实际开发中，通常会将类加载器分为如下几种：<p><strong>（1）启动类加载器（Bootstrap ClassLoader）</strong><p>使用C/C++语言实现，并不继承java.lang.ClassLoader。为安全起见，主要负责加载Java核心类库，比如：<code>%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar</code>和class等。<p><strong>（2）扩展类加载器（Extensions ClassLoader）</strong><p>使用Java语言实现，派生于抽象类ClassLoader，父类是启动类加载器。<p>主要负责加载<code>%JRE_HOME%\lib\ext</code>目录下的jar包和class文件。<p>使用参数<code>-Djava.ext.dirs=jar包路径</code>可为扩展类加载器添加额外的jar包加载路径。多个路径使用分号<code>;</code>进行分割，若是mac或linux系统则使用冒号<code>:</code>进行分割。<p><strong>（3）应用程序/系统类加载器（App ClassLoader）</strong><p>使用Java语言实现，派生于抽象类ClassLoader，父类是扩展类加载器。<p>加载 CLASSPATH 或 java.class.path 指定路径下的类库。<p><strong>（4）自定义类加载器（Custom ClassLoader）</strong><p>自定义类加载器<strong>可以扩展加载源、修改类加载方式，隔离加载类、防止源码泄露等</strong>。JDK1.2之前，实现自定义类加载需要继承抽象类ClassLoader并重写loadClass方法，而<strong>JDK1.2之后建议重写findClass方法来代替重写loadClass方法</strong>。<p>若无特别需求，则建议直接继承URLClassLoader类，可避免编写findClass方法及获取字节流的方式。<p><font color=red>注意：这些类加载器之间是包含（复合）关系，而并非是继承关系。</font><h4 id=0-1-3-3、常用命令><a class=headerlink href=#0-1-3-3、常用命令 title=0.1.3.3、常用命令></a>0.1.3.3、常用命令</h4><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -Xbootclasspath/a:. cn.shh.xxx.Test bootstrap F init</span><br></pre></table></figure><ul><li><code>Xbootclasspath</code>：表示设置bootclasspath。<li><code>/a</code>：表示将当前目录追加至bootclass之后。</ul><p>常用命令：<ul><li><code>java -Xbootclasspath:&LTnew bootclasspath></code><li><code>java -Xbootclasspath/a:<追加路径></code><li><code>java -Xbootclasspath/p:<追加路径></code></ul><h4 id=0-1-3-4、JDK9新变化><a class=headerlink href=#0-1-3-4、JDK9新变化 title=0.1.3.4、JDK9新变化></a>0.1.3.4、JDK9新变化</h4><p><strong>JDK9引入了模块化概念</strong>。<p>启动类加载器使用Java编写，位于jdk.internal.loader.ClassLoaders类中，且依然无法获取到。BootClassLoader继承自BuiltinClassLoader，实现从模块中找到需要加载的字节码文件。<p><strong>扩展类加载器被替换成了平台类加载器</strong>。平台类加载器遵循模块化方式加载字节码文件，平台类加载的出现主要为了兼容老版本设计方案，自身没有特殊的逻辑。<h3 id=0-1-4、双亲委派模型><a class=headerlink href=#0-1-4、双亲委派模型 title=0.1.4、双亲委派模型></a>0.1.4、双亲委派模型</h3><h4 id=0-1-4-1、简介><a class=headerlink href=#0-1-4-1、简介 title=0.1.4.1、简介></a>0.1.4.1、简介</h4><p><img alt=image-20201224173439957 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20201224173439957.png><p>上图所示，<strong>类加载器间的关系就称为 类加载器的双亲委派模型（Parents Delegation Mode）。</strong><p><strong>类加载器的双亲委派模型在 JDK 1.2 期间被引入。</strong>它并不是一个强制性约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。<p><strong>双亲委派是指：一个类加载器收到了类加载请求时会先请求自己的父加载器去加载，如果父加载器无法加载该类，那么才会交给当前类加载器来加载。</strong><p>双亲委派机制有如下几个特点：<ol><li>Java类随它的类加载器一起具备了一种带有优先级的层次关系。<li>保证Java程序的稳定运行。<li>避免类被重复加载。<li>保证了安全。</ol><h4 id=0-1-4-2、重要方法><a class=headerlink href=#0-1-4-2、重要方法 title=0.1.4.2、重要方法></a>0.1.4.2、重要方法</h4><ul><li>loadClass()：类加载的主要方法。双亲委派机制的体现就是该方法。<li>findClass()：根据名称或位置加载.class字节码。<li>definclass()：把字节码转化为Class。</ul><p><font color=red>注意：自定义类加载器需要破坏双亲委派原则时就重写loadClass方法。如果只想自定义类加载器不想破坏双亲委派模型，那就继承ClassLoader并重写findClass方法。</font><p><code>findClass()</code>方法是JDK1.2之后 ClassLoader 新添加的一个方法。<blockquote><p>JDK1.2 后不提倡覆盖loadClass()方法，而建议把自己的逻辑写到<code>findClass()</code>方法中。因为<code>loadClass()</code>方法无法完成类加载逻辑时最终还是会调用<code>findClass()</code>方法来完成加载。</blockquote><h4 id=0-1-4-3、实现原理><a class=headerlink href=#0-1-4-3、实现原理 title=0.1.4.3、实现原理></a>0.1.4.3、实现原理</h4><p><strong>双亲委派模型的实现代码体现在抽象类<code>java.lang.ClassLoader</code>的<code>loadClass()</code>方法中。</strong>逻辑如下：<ol><li>先检查一个类是否被加载过，若没有被加载，则调用父加载器的 loadClass() 方法进行加载。<li>若父加载器为空，则默认使用启动类加载器作为父加载器。<li>如果父加载器加载失败，抛出 ClassNotFoundException 异常后，再调用自己的 findClass() 方法进行加载。</ol><h4 id=0-1-4-4、破坏双亲模型><a class=headerlink href=#0-1-4-4、破坏双亲模型 title=0.1.4.4、破坏双亲模型></a>0.1.4.4、破坏双亲模型</h4><p>打破双亲委派的方法如下：<ul><li>自定义类加载器，重写loadClass方法。<li>使用线程上下文类加载器。<li>使用Osgi框架类加载器。</ul><p>到目前为止，双亲委派模型出现过几次较大规模的破坏情况：<ol><li>由于 JDK 1.2 才发布双亲委派模型，类加载器和抽象类 ClassLoader 则在 JDK 1.0 时代就已经存在，为了兼容已经存在的自定义类加载器实现，JDK 1.2之后添加了一个新的 protected方法 findClass() 。JDK 1.2之后已不在提倡覆盖 loadClass() 方法，而应当把自己的类加载逻辑写入 findClass() 方法中，在 loadClass() 中如果父类加载失败，则会调用自己的 findClass() 方法来完成加载。<li><strong>基础类之所以称为“基础类”，是因为它们会作为API来被用户代码调用，但是，如果基础类反过来需要调用用户代码时，该怎么办？于是线程上下文类加载器就出现了。</strong>有了线程上下文类加载器，JNDI服务可以去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为打破了双亲委派模型的层次结构来逆向使用类加载器，这实际上违背了双亲委派模型的一般性原则。<li>第三次破坏是由于 <strong>用户对程序动态性的追求而导致，动态性是指：代码热替换、模块热部署等</strong>。比如 OSGI 中的类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更复杂的网状结构。<li>Tomcat等web容器的出现。<li>OSGI、Jigsaw等模块化技术的应用。</ol><h4 id=0-1-4-5、JNDI-JDBC破坏双亲委派><a class=headerlink href=#0-1-4-5、JNDI-JDBC破坏双亲委派 title=0.1.4.5、JNDI/JDBC破坏双亲委派></a>0.1.4.5、JNDI/JDBC破坏双亲委派</h4><p><strong>Java的基础类会被Bootstrap加载，且会通过API方式调用这些基础类。但是，除了API方式调用，还有一种SPI方式调用，如JDBC服务。</strong><p>创建数据库连接的方式如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>Connection</span> <span class=variable>conn</span> <span class=operator>=</span> DriverManager.getConnection(<span class=string>"jdbc:mysql://localhost:3306/mysql"</span>, <span class=string>"root"</span>, <span class=string>"1234"</span>);</span><br></pre></table></figure><p><code>java.sql.DriverManager</code>类位于rt.jar中 ，故会被根加载器加载。类加载时，会执行该类的静态方法。其中有一段关键代码是：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>ServiceLoader&LTDriver> loadedDrivers = ServiceLoader.load(Driver.class);</span><br></pre></table></figure><p>这段代码，会尝试加载classpath下实现了Driver接口的所有实现类。<p>那么，问题就来了。<p><strong>DriverManager会被根加载器加载，但在加载时遇到以上代码，会尝试加载Driver的所有实现类，但这些实现类基本都是第三方提供，根据双亲委派原则，第三方的类不能被根加载器加载。</strong><p>那么，怎么解决这个问题呢？<p><strong>在JDBC中引入ThreadContextClassLoader（线程上下文加载器，默认情况下是AppClassLoader）来破坏双亲委派原则。</strong><p>我们深入到<code>ServiceLoader.load</code>方法就可以看到：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> &LTS> ServiceLoader&LTS> <span class="title function_">load</span><span class=params>(Class&LTS> service)</span> {</span><br><span class=line>    <span class=type>ClassLoader</span> <span class=variable>cl</span> <span class=operator>=</span> Thread.currentThread().getContextClassLoader();</span><br><span class=line>    <span class=keyword>return</span> ServiceLoader.load(service, cl);</span><br><span class=line>}</span><br></pre></table></figure><p>第一行，获取当前线程的线程上下⽂类加载器 AppClassLoader，⽤于加载 classpath 下的具体实现类。<h4 id=0-1-4-6、Tomcat破坏双亲委派><a class=headerlink href=#0-1-4-6、Tomcat破坏双亲委派 title=0.1.4.6、Tomcat破坏双亲委派></a>0.1.4.6、Tomcat破坏双亲委派</h4><h5 id=简介-1><a class=headerlink href=#简介-1 title=简介></a>简介</h5><p>Tomcat中可能会部署多个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，如果采用默认的双亲委派类加载机制，那么无法加载多个相同类。所以，Tomcat破坏双亲委派原则，提供隔离的机制，为web容器中每一个应用单独提供一个WebAppClassLoader加载器。<p><strong>Tomcat类加载机制：为了实现隔离性，优先加载 Web 应用自己定义的类，所以没有遵照双亲委派约定，每一个WebAppClassLoader负责加载自己目录下的class文件，加载不到时再交给CommonClassLoader加载，这和双亲委派刚好相反。</strong><h5 id=tomcat中的类加载器><a class=headerlink href=#tomcat中的类加载器 title=tomcat中的类加载器></a>tomcat中的类加载器</h5><p><strong>Tomcat实现了一套自己的类加载器。顶层类加载为Common类加载器，其有两个子类加载器Catalina类加载器和Shared类加载器</strong>。Shared类加载器下有多个ParallelWebappClassLoader类加载器，因为每个Web应用会单独使用一个。ParallelWebappClassLoader类加载器下会有多个JasperLoader类加载器，因为每次加载jsp文件都会使用一个，这样一来，也就实现了热部署。<h4 id=0-1-4-7、总结><a class=headerlink href=#0-1-4-7、总结 title=0.1.4.7、总结></a>0.1.4.7、总结</h4><h5 id=父子加载器之间是继承关系吗？><a class=headerlink href=#父子加载器之间是继承关系吗？ title=父子加载器之间是继承关系吗？></a>父子加载器之间是继承关系吗？</h5><p><strong>双亲委派模型中，类加载器之间的关系一般不会以继承（Inheritance）的关系来实现，而是使用组合（Composition）关系来复用父加载器代码。</strong><p>如下为ClassLoader中父加载器的定义：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">ClassLoader</span> {</span><br><span class=line>    <span class=comment>// The parent class loader for delegation</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> ClassLoader parent;</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>Java中继承和组合的区别是什么？<ol><li>组合(has-a)关系可以<strong>显式获得被包含类（继承中称为父类）对象</strong>，而继承(is-a)则是<strong>隐式获得父类对象</strong>，被包含类和父类对应，而组合外部类和子类对应。<li>组合关系在<strong>运行期决定</strong>，而继承关系在<strong>编译期决定</strong>。<li>组合是组合类和被包含类之间的一种<strong>松耦合关系</strong>，而继承则是父类和子类之间的一种<strong>紧耦合关系</strong>。<li>组合类中包含了外部类的对象，组合类<strong>可以选择性调用外部类方法</strong>；而使用继承关系时，父类的所有方法和变量都被子类<strong>无条件继承，子类不能选择</strong>。<li>继承可以实现类型回溯，即用父类变量引用子类对象，这样便可以实现多态，而组合没有这个特性。<li>如果你确定复用另外一个类的方法永远不需要改变时，应该使用组合，因为组合只是<strong>简单复用被包含类的接口</strong>，而继承除了复用父类接口外，它还可以<strong>覆盖这些接口</strong>，修改父类接口的默认实现，这个特性是组合没有的。<li>组合体现的是整体和部分的思想，例如电脑类是由内存类，CPU类，硬盘类等组成，而继承则体现的是一种可回溯的父子关系，子类也是父类的一个对象。<li><strong>两者区别主要体现在类的抽象阶段</strong>，在分析类之间的关系时就应该确定是采用组合还是采用继承。</ol></blockquote><h2 id=0-2、JVM运行时数据区><a class=headerlink href=#0-2、JVM运行时数据区 title=0.2、JVM运行时数据区></a>0.2、JVM运行时数据区</h2><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/2.1.1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%89%8D%E8%A8%80-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86.png><h3 id=0-1-1、程序计数器（私有）><a class=headerlink href=#0-1-1、程序计数器（私有） title=0.1.1、程序计数器（私有）></a>0.1.1、程序计数器（私有）</h3><h4 id=0-1-1-1、简介-1><a class=headerlink href=#0-1-1-1、简介-1 title=0.1.1.1、简介></a>0.1.1.1、简介</h4><p>JVM的程序计数寄存器，是物理PC寄存器的一种抽象模拟。<p>程序计数器主要<strong>存储要执行的程序指令的地址信息</strong>，确保程序正确执行。<h4 id=0-1-1-2、作用><a class=headerlink href=#0-1-1-2、作用 title=0.1.1.2、作用></a>0.1.1.2、作用</h4><p>PC寄存器用来<strong>存储指向下一条指令的地址</strong>，也即将要执行的指令代码的地址。由执行引擎读取下一条指令。<h3 id=0-1-2、方法区（公有）><a class=headerlink href=#0-1-2、方法区（公有） title=0.1.2、方法区（公有）></a>0.1.2、方法区（公有）</h3><h4 id=0-1-2-1、简介><a class=headerlink href=#0-1-2-1、简介 title=0.1.2.1、简介></a>0.1.2.1、简介</h4><p>方法区主要存储：<strong>类型信息、运行时常量池、静态变量、JIT代码缓存、域信息、方法信息</strong>等。<p>类型信息包括：类class、接口interface、枚举enum、注解annotation。<p>域信息包括：域名称、域类型、域修饰符。即：public、private、protected、static、final、volatile、transient的某个子集。<p>方法信息包括：方法修饰符、方法返回类型、方法名称、方法参数的数量和类型、方法字节码、操作数栈、局部变量表及大小（abstract和native方法除外）、异常表（abstract和native方法除外）。<p><font color=red>注意事项：方法区内存不足时会导致内存溢出错误。</font><p>方法区内存溢出的场景：Spring、MyBatis。<h4 id=0-1-2-2、实现><a class=headerlink href=#0-1-2-2、实现 title=0.1.2.2、实现></a>0.1.2.2、实现</h4><p><strong>永久代PermSpace（JDK7）</strong><ol><li>JDK7及以前，方法区实现是永久代。<li>JDK7以前，静态变量存放在永久代上。JDK7开始，<strong>字符串常量池、静态变量保存在堆中</strong>。<li>FGC不会清理永久代。<li>-XX:PermSize默认值为20.75M，<code>-XX:MaxPermSize</code>默认值在32位下是64M，64位下是82M。</ol><p><strong>元空间MetaSpace（JDK8）</strong><ol><li>JDK8中方法区实现是元空间，使用物理内存。<li>类型信息、字段、方法、常量保存在元空间中，<strong>字符串常量池、静态变量仍保存在堆中</strong>。<li>FGC会清理元空间。<li>windows下，<code>-XX:MetaspaceSize</code>是21M，<code>-XX:MaxMetaspaceSize</code>的值是-1，表示没有限制。</ol><p><strong>注意事项</strong>：虽然元空间大小的最大上限默认为系统内存的大小，但仍然建议手动设定一个满足需求的固定值大小。<h4 id=0-1-2-3、方法区演变><a class=headerlink href=#0-1-2-3、方法区演变 title=0.1.2.3、方法区演变></a>0.1.2.3、方法区演变</h4><p><strong>首先明确：只有HotSpot才有永久代一说。</strong>bea jrockit、ibm j9等是不存在永久代的概念。原则上如何实现方法区属于虚拟机实现细节，不受jvm规范管束，并不要求统一。<p>Hotspot中方法区的变化如下：<ol><li><strong>JDK1.6及之前</strong>：有永久代，静态变量保存在永久代中。<li><strong>JDK1.7</strong>：有永久代，但已经逐步“去永久代”，字符串常量池、静态变量保存在堆中。<li><strong>JDK1.8及之后</strong>：无永久代，类型信息、字段、方法、常量保存在元空间中，但字符串常量池、静态变量仍然保存在堆中。</ol><h4 id=0-1-2-4、运行时常量池><a class=headerlink href=#0-1-2-4、运行时常量池 title=0.1.2.4、运行时常量池></a>0.1.2.4、运行时常量池</h4><h5 id=常量池-1><a class=headerlink href=#常量池-1 title=常量池></a>常量池</h5><p>常量池是Class文件的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将会在类被加载后放到方法区的运行时常量池中。<h5 id=运行时常量池><a class=headerlink href=#运行时常量池 title=运行时常量池></a>运行时常量池</h5><p><strong>加载 类或接口 到虚拟机后就会创建对应的运行时常量池</strong>。<p>运行时常量池是方法区的一部分。运行时常量池 是 常量池表的运行时表示形式，它包含多种常量，从编译期可知的<strong>数字字面量</strong>到必须运行且解析后才能获得的<strong>方法或字段引用</strong>。（类似于符号表，但比符号表要更广泛。）<h3 id=0-1-3、虚拟机栈（私有）><a class=headerlink href=#0-1-3、虚拟机栈（私有） title=0.1.3、虚拟机栈（私有）></a>0.1.3、虚拟机栈（私有）</h3><h4 id=0-1-3-1、简介-1><a class=headerlink href=#0-1-3-1、简介-1 title=0.1.3.1、简介></a>0.1.3.1、简介</h4><p><strong>每个线程都有自己的栈，栈中的数据都是以 栈帧 的格式存在。</strong>每个线程在执行一个方法时会在栈中建立一个栈帧。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种信息。<p>虚拟机栈的默认大小在不同的系统中也不同，详情如下：<p>JDK8环境下：<ul><li>Linux/ARM (32-bit): 320 KB<li>Linux/i386 (32-bit): 320 KB<li>Linux/x64 (64-bit): 1024 KB<li>macOS (64-bit): 1024 KB<li>Oracle Solaris/i386 (32-bit): 320 KB<li>Oracle Solaris/x64 (64-bit): 1024 KB<li>Windows: 默认值取决于虚拟内存。</ul><p>JDK21环境下：<ul><li>Linux/x64: 1024 KB<li>Linux/Aarch64: 2048 KB<li>macOS/x64: 1024 KB<li>macOS/Aarch64: 2048 KB<li>Windows: 默认值取决于虚拟内存。</ul><p><strong>若默认大小不满足需求，可以通过参数<code>-Xss大小</code>来自定义设置大小。单位可以为字节、K、MB、G</strong>。但要注意的是，设置的大小也需要满足JVM规范要求。<strong>windows 64位系统环境下，JDK8要求最小值为180K，最大值为1024M</strong>。<p><font color=red>注意事项：虚拟机栈内存不足时会导致内存溢出错误。</font><h4 id=0-1-3-2、内部结构><a class=headerlink href=#0-1-3-2、内部结构 title=0.1.3.2、内部结构></a>0.1.3.2、内部结构</h4><p>Java虚拟机中主要存储的是栈帧，而栈帧由以下几部分组成：<ul><li><strong>局部变量表</strong><li><strong>操作数栈</strong><li><strong>动态链接</strong><li><strong>方法出口</strong><li><strong>一些附加信息</strong></ul><h4 id=0-1-3-3、其它><a class=headerlink href=#0-1-3-3、其它 title=0.1.3.3、其它></a>0.1.3.3、其它</h4><p>问题分析：<ul><li>栈内存越大越好吗？非也。<li>垃圾回收是否涉及栈内存？不会涉及。<li>方法中的局部变量是否是线程安全的？若没有发生逃逸，则是线程安全的。</ul><h3 id=0-1-4、本地方法栈（私有）><a class=headerlink href=#0-1-4、本地方法栈（私有） title=0.1.4、本地方法栈（私有）></a>0.1.4、本地方法栈（私有）</h3><h4 id=0-1-4-1、简介-1><a class=headerlink href=#0-1-4-1、简介-1 title=0.1.4.1、简介></a>0.1.4.1、简介</h4><p><strong>本地方法栈使用C语言实现，线程私有，主要服务于本地方法的调用。</strong><p><strong>Hotspot虚拟机中，本地方法栈和Java虚拟机栈实现上使用了同一个空间</strong>。本地方法栈会在栈内存中生成一个栈帧，临时保存方法参数的同时方便出现异常时把本地方法栈信息打印出来。<p>本地方法栈中存储本地方法，执行引擎工作时会加载本地方法库。<p><font color=red>注意事项：本地方法栈内存不足时会导致内存溢出错误。</font><h4 id=0-1-4-2、注意事项><a class=headerlink href=#0-1-4-2、注意事项 title=0.1.4.2、注意事项></a>0.1.4.2、注意事项</h4><ul><li>可以通过本地方法接口来访问虚拟机内部的运行时数据区。<li>直接使用本地处理器中的寄存器。<li>直接从本地内存的堆中分配任意内存。<li>并非所有JVM都支持本地方法，JVM规范并没有要求本地方法栈使用的语言、具体实现方式、数据结构等，也可以选择不实现本地方法栈。<li>Hotspot中直接将本地方法栈和虚拟机栈合二为一。</ul><h3 id=0-1-5、堆（公有）><a class=headerlink href=#0-1-5、堆（公有） title=0.1.5、堆（公有）></a>0.1.5、堆（公有）</h3><h4 id=0-1-5-1、简介><a class=headerlink href=#0-1-5-1、简介 title=0.1.5.1、简介></a>0.1.5.1、简介</h4><p><strong>堆是各个线程共有的区域，该区域主要存储加载创建对象过程中生成的对象数据。</strong><p><font color=red>注意事项：堆空间不足时会导致内存溢出错误。</font><h4 id=0-1-5-2、分代模型><a class=headerlink href=#0-1-5-2、分代模型 title=0.1.5.2、分代模型></a>0.1.5.2、分代模型</h4><p>逻辑上将堆分为以下几个部分：<ul><li>年轻代<ul><li>Eden区<li>Surivor from区<li>Surivor to区</ul><li>老年代<li>永久代/元空间（JDK7及之前是永久代，之后是元空间）</ul><h4 id=0-1-5-3、空间大小><a class=headerlink href=#0-1-5-3、空间大小 title=0.1.5.3、空间大小></a>0.1.5.3、空间大小</h4><h5 id=堆大小><a class=headerlink href=#堆大小 title=堆大小></a>堆大小</h5><p>可以通过Xms、Xmx来设置堆内存初始内存和最大内存，堆大小在JVM启动时已经设定好了。<p>默认情况下：初始内存大小为物理内存/64，最大内存为物理内存的1/4。<p><font color=red>注意事项：堆内存大小超过最大内存限制时会抛出OOM异常。</font><h5 id=新生代老年代><a class=headerlink href=#新生代老年代 title=新生代老年代></a>新生代老年代</h5><p>使用参数<code>-Xmn</code>可以设置新生代的空间大小。<p>默认参数<code>-XX:NewRatio=2</code>表示新生代占比1，老年代占比2，也即，新生代占整个堆内存的1/3。同理<code>-XX:NewRatio=4</code>表示新生代占比1，老年代占比4，新生代占整个堆内存的1/5。<p><font color=red>注意事项：参数<code>-XX:NewRatio=2</code>的实际效果会受参数<code>-XX:+/-UseAdaptiveSizePolicy</code>的影响，后者参数表示 开启或关闭自适应内存分配策略。</font>如果想要达到指定的具体效果，需要使用参数<code>-XX:SurvivorRatio</code>来设置，该参数表示新生代中Eden区与Survivor区的比例。<h3 id=0-1-6、直接内存><a class=headerlink href=#0-1-6、直接内存 title=0.1.6、直接内存></a>0.1.6、直接内存</h3><p><strong>直接内存在堆外，不会受限于-Xmx设置的最大堆大小。</strong>但系统内存也是有限的，Java堆和直接内存的总和依然受限于操作系统能提供的最大内存。<p>直接内存有如下缺点：<ul><li>分配回收成本较高。<li>不受JVM内存回收管理。</ul><p><strong>直接内存大小可以通过参数<code>-XX:MaxDirectMemorySize=size</code>来设置，如果不指定，则默认与堆的最大值-Xmx参数值一致。</strong>默认情况下，大小设置为 0，这意味着 JVM 会自动选择 NIO 直接缓冲区分配的大小。<h3 id=0-1-7、字符串常量池><a class=headerlink href=#0-1-7、字符串常量池 title=0.1.7、字符串常量池></a>0.1.7、字符串常量池</h3><h4 id=0-1-7-1、简介><a class=headerlink href=#0-1-7-1、简介 title=0.1.7.1、简介></a>0.1.7.1、简介</h4><p><strong>String Pool是一个固定大小的Hashtable，默认大小为1009。</strong>如果String Pool中字符串太多，会造成链表过长，进而导致在调用String的intern方法时性能会大幅下降。<p><strong>JDK6及以前版本，字符串常量池在方法区中，JDK7及之后版本，字符串常量池转移到堆中。</strong><h4 id=0-1-7-2、参数设置><a class=headerlink href=#0-1-7-2、参数设置 title=0.1.7.2、参数设置></a>0.1.7.2、参数设置</h4><p>使用参数<code>-XX:StringTableSize</code>可设置StringTable的长度。<blockquote><p>JDK6中StringTable大小固定为1009。JDK7中StringTable大小默认为60013。JDK8中最小有效值为1009。</blockquote><h2 id=0-3、执行引擎><a class=headerlink href=#0-3、执行引擎 title=0.3、执行引擎></a>0.3、执行引擎</h2><h3 id=0-3-1、即时编译器><a class=headerlink href=#0-3-1、即时编译器 title=0.3.1、即时编译器></a>0.3.1、即时编译器</h3><h5 id=解释器与编译器><a class=headerlink href=#解释器与编译器 title=解释器与编译器></a>解释器与编译器</h5><p><strong>当程序需要迅速启动和执行时，解释器先运行，然后编译器逐渐发挥作用。如果编译器优化后类发生了变化，那么可以立即通过解释器来运行。所以说解释器和编译器是互相配合执行代码。</strong><p>HotSpot虚拟机内置了三个即时编译器：<strong>客户端编译器（C1编译器）、服务端编译器（C2编译器）、Graal编译器（JDK10引入）。Graal编译器的目标是替换C2编译器</strong>。<p>JVM执行代码时可采用多种模式，分为三种：<ul><li><p><strong>混合模式（默认方式）</strong>：使用参数<code>-Xmixed</code>可以设置JVM运行于混合模式，该模式下解释器和编译器互相配合执行代码。</p><li><p><strong>解释器（Intepreter）模式</strong>：使用参数<code>-Xint</code>可以设置JVM运行于“解释模式”，该模式下只有解释器来解释执行代码。</p><li><p><strong>JIT（Just In-Time，即时编译）模式</strong>：使用参数<code>-Xcomp</code>可以设置JVM运行于“编译模式”，但要注意，当编译器无法继续工作时解释器依然会介入执行。</p></ul><p><strong>分层编译在JDK 6中初步实现，在JDK 7服务端模式中被作为默认编译策略</strong>。分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其包括：<ul><li>第0层：程序纯解释执行，并且解释器不开启性能监控功能（Profiling）。<li>第1层：使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启 性能监控功能。<li>第2层：使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能。<li>第3层：使用客户端编译器执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。<li>第4层：使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。</ul><p>分层编译后，解释器、客户端编译器、服务端编译器可同时工作，在服务端编译器采用高复杂度优化算法时，客户端编译器可先采用简单优化来为之争取更多编译时间。<blockquote><p>疑问：既然编译到本地效率更高，为啥不全部编译到本地呢？<ol><li>现在的Java解释器执行效率已经很高，几乎可以和编译器相媲美。<li>类库或class很多时，编译到本地会很耗时进而影响启动速度。</ol></blockquote><h5 id=热点代码><a class=headerlink href=#热点代码 title=热点代码></a>热点代码</h5><p>被即时编译器编译的目标是“热点代码”，热点代码主要有两类：<ul><li><strong>被多次调用的方法</strong>。<li><strong>被多次执行的循环体</strong>。</ul><p>某段代码是不是热点代码，是否触发即时编译需要执行“热点探测”（Hot Spot Code Detection），热点探测并不一定要知道方法具体被调用多少次，目前主流的热点探测判定方式有两种，分别是：<ul><li><p><strong>基于采样的热点探测</strong></p> <p>采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。这种探测方式的好处是实现简单高效，可以很容易获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而 扰乱热点探测。</p><li><p><strong>基于计数器的热点探测</strong></p> <p>采用这种方法的虚拟机会为 每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为 它是“热点方法”。这种统计方法实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。</p></ul><h5 id=调用计数器><a class=headerlink href=#调用计数器 title=调用计数器></a>调用计数器</h5><p>方法被调用时会先查看是否存在该方法编译后的代码，存在则先执行编译后的代码，不存在则会将方法调用计时器值加1，然后判断方法调用计数器值与回边计数器值之和是否超过调用计数器的阈值，超过阈值会向即时编译器发送方法代码编译请求，在代码被即时编译器编译完成前会暂时先使用解释器来解释执行，当编译完成后，该方法的调用入口地址就会被自动修改为新值，后期调用该方法时就可以执行编译后的代码了。<blockquote><p>方法调用计数器的默认阈值在客户端模式下是1500次，在服务端模式下是10000次，这个阈值可以通过虚拟机参数<code>-XX:CompileThreshold</code>来人为设定。</blockquote><p>默认设置下，方法调用计数器统计的是一段时间内方法被调用的次数，该时间段内，如果方法的调用次数不足以触发即时编译器来编译，那方法调用计数器数值会减少一半，该过程被称为<em><strong>方法调用计数器热度衰减（Counter Decay）</strong></em>，而这段时间称为此方法统计的<em><strong>半衰周期（Counter Half Life Time）</strong></em>。<blockquote><p><strong>热度衰减操作在垃圾收集时进行</strong>，可使用参数<code>-XX:-UseCounterDecay</code>来关闭热度衰减，让方法调用计数器统计方法调用的绝对次数。可使用参数<code>-XX:CounterHalfLifeTime</code>设置半衰周期的时间，单位秒。</blockquote><h5 id=回边计数器><a class=headerlink href=#回边计数器 title=回边计数器></a>回边计数器</h5><p><strong>回边计数器会统计一个方法中循环体代码的执行次数，在字节码中遇到控制流向后跳转的指令就称为“回边（Back Edge）”，回边计数器统计的目的是为了触发栈上替换编译。</strong><p>回边计数器阈值计算分以下两种情况：<ul><li>客户端模式下回边计数器阈值计算公式为：方法调用计数器阈值（-XX:CompileThreshold）乘以OSR比率（-XX:OnStackReplacePercentage）除以100。其中<code>-XX:OnStackReplacePercentage</code>默认值为933，<strong>如果都取默认值，那客户端模式下的回边计数器的阈值为 13995</strong>。<li>服务端模式下回边计数器阈值的计算公式为：方法调用计数器阈值（-XX:CompileThreshold）乘以（OSR比率（-XX:OnStackReplacePercentage）减去解释器监控比率（-XX:InterpreterProfilePercentage）的差值）除以100。其中-XX：OnStack ReplacePercentage默认值为140，- XX:InterpreterProfilePercentage默认值为33，<strong>如果都取默认值，那服务端模式的回边计数器的阈值为10700</strong>。</ul><p>当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有的话，先执行编译好的代码，否则就把回边计数器的值加一，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。超过阈值时会提交一个栈上替换编译请求， 并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。<p><strong>与方法计数器不同，回边计数器没有计算热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出时会把方法计数器的值也调整到溢出状态，这样下次再进入该方法时就会执行标准编译过程</strong>。<blockquote><p><font color=red>注意：回边次数 不等于 循环次数，因为并不是所有的循环都是回边，如空循环并不算控制流向后跳转，也不会被回边计数器统计。</font></blockquote><h3 id=0-3-2、提前编译器><a class=headerlink href=#0-3-2、提前编译器 title=0.3.2、提前编译器></a>0.3.2、提前编译器</h3><p><strong>JDK 9引入了Jaotc，可实现提前编译Class文件及模块</strong>，它可以减少程序的启动时间和到达全速性能的预热时间。该功能需要特定的物理机器和虚拟机参数，限制太多。<h3 id=0-3-3、编译器优化><a class=headerlink href=#0-3-3、编译器优化 title=0.3.3、编译器优化></a>0.3.3、编译器优化</h3><h4 id=分层编译><a class=headerlink href=#分层编译 title=分层编译></a>分层编译</h4><p>JDK7及之后采用了分层编译方式，JVM中的C1和C2编译器会协同发挥作用，分层编译将整个优化级别分为5个等级。<table><thead><tr><th align=center>等级<th align=center>组件<th align=center>描述<th align=center>内容<th align=center>打分<tbody><tr><td align=center>0<td align=center>解释器<td align=center>解释执行，记录方法调用次数和循环次数<td align=center>无<td align=center>1<tr><td align=center>1<td align=center>C1即时编译器<td align=center>C1完整优化<td align=center>优化后的机器码<td align=center>4<tr><td align=center>2<td align=center>C1即时编译器<td align=center>C1完整优化，记录方法调用次数和循环次数<td align=center>优化后的机器码，及方法调用次数和循环次数<td align=center>3<tr><td align=center>3<td align=center>C1即时编译器<td align=center>C1完整优化，记录额外完整信息<td align=center>优化后的机器码，分支跳转次数，类型转换等。<td align=center>2<tr><td align=center>4<td align=center>C2即时编译器<td align=center>C2完整优化<td align=center>优化后的机器码<td align=center>5</table><h4 id=方法内联><a class=headerlink href=#方法内联 title=方法内联></a>方法内联</h4><h5 id=简介-2><a class=headerlink href=#简介-2 title=简介></a>简介</h5><p><strong>内联被称为优化之母，消除方法调用成本外，也为其它优化手段提供了良好基础。</strong><p><strong>方法内联就是把目标方法代码“复制”到发起调用的方法之中，避免发生真实方法调用。该功能得益于即时编译器的付出</strong>。<blockquote><p>Java中默认的实例方法是虚方法。只有使用 invokespecial指令调用的私有方法、实例构造器、父类方法和使用invokestatic指令调用的静态方法才会在编译期进行解析。被final修饰的方法会使用invokevirtual指令调用，它是非虚方法，《Java语言规范》中明确说明了这点。</blockquote><p>内联与虚方法之间会产生“矛盾”，C和C++是通过使用final关键字来修饰方法解决的，但Java在虚拟机中解决这个问题。<p>Java虚拟机首先引入了一种名为类型<em><strong>继承关系分析（Class Hierarchy Analysis，CHA）</strong></em>技术，用于确定目前已加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法 等信息。<p>编译器进行内联时会根据不同情况采取不同处理：非虚方法直接进行内联就可以；对于虚方法，会向CHA查询此方法下是否有多个目标版本可供选择，如果只有一个版本，那可以内联，这种内联称为<em><strong>守护内联（Guarded Inlining）</strong></em>。由于Java程序是动态连接的，说不准什么时候就会加载到新的类型从而改变CHA结论，因此这种内联属于<em><strong>激进预测性优化</strong></em>。假如在程序的后续执行过程中，虚拟机一直没有加载到会导致方法接收者继承关系发生变化的类，那这个内联优化的代码就可以一直使用。如果加载了导致继承关系发生变化的新类，那么就必须抛弃已编译的代码，退回到解释状态执行，或重新进行编译。<p>如果被调用的方法确实有多个版本可供选择，那即时编译器还将进行最后一次努力，<strong>使用内联缓存（Inline Cache）的方式来缩减方法调用的开销。这种状态下方法调用真正发生，比起直接查虚方法表还要快一些</strong>。<h5 id=内联的限制><a class=headerlink href=#内联的限制 title=内联的限制></a>内联的限制</h5><p>并不是所有方法都可以内联，内联有如下一些限制：<ul><li>方法编译后的字节码指令总大小必须小于35字节才可以内联。可通过参数<code>-XX:MaxInlineSize=值</code>，来控制。<li>方法编译后的字节码指令总大小必须小于325字节，且是一个热方法才可以内联。可通过参数<code>-XX:FreqInlineSize=值</code>来控制。<li>方法编译生成的机器码不能大于1000字节。可通过参数<code>-XX:InlineSmallCode=值</code>来控制。<li>一个接口的实现必须小于3个，如果大于3个就不会发生内联。</ul><h4 id=逃逸分析><a class=headerlink href=#逃逸分析 title=逃逸分析></a>逃逸分析</h4><h6 id=简介-3><a class=headerlink href=#简介-3 title=简介></a>简介</h6><p>逃逸分析（Escape Analysis）与类型继承关系分析一 样，并不是直接优化代码的手段，而是<strong>为其他优化措施提供依据的分析技术</strong>。<p>逃逸分析基本原理：<strong>分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，这种称为方法逃逸；甚至还有可能被外部线程访问，这种称为线程逃逸；不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。</strong><p><font color=red>注意：JDK 6u23版本之后，Hotspot默认开启了逃逸分析。</font><h6 id=优化><a class=headerlink href=#优化 title=优化></a>优化</h6><p>如果能证明一个对象不会逃逸到方法或线程之外（换句话说是别的方法或线程无法通过任何途径 访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实例采取不同程度的优化。比如：<p><strong>（1）栈上分配</strong><p>如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。栈上分配支持方法逃逸，但不支持线程逃逸。<p><strong>（2）标量替换</strong><p><strong>若一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解了，那么这些数据就可以被称为标量。相对的，如果一个数据可以继续分解，那它就被称为聚合量（Aggregate），Java 中的对象就是典型的聚合量</strong>。如果把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量 恢复为原始类型来访问，这个过程就称为标量替换。<p>标量替换可以视作栈上分配的一种特例，实现更简单（不用考虑整个对象完整结构的分配），但对逃逸程度的要求更高，它不允许对象逃逸出方法范围内。<p><strong>（3）同步消除</strong><p>线程同步本身是一个相对耗时的过程，如果逃逸分析 能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争， 对这个变量实施的同步措施也就可以安全地消除掉。<h6 id=功能开启><a class=headerlink href=#功能开启 title=功能开启></a>功能开启</h6><ul><li>-XX:+DoEscapeAnalysis：开启逃逸分析。<li>-XX:+PrintEscapeAnalysis：查看逃逸分析筛选结果。</ul><h4 id=公共子表达式消除><a class=headerlink href=#公共子表达式消除 title=公共子表达式消除></a>公共子表达式消除</h4><p>公共子表达式消除的含义是：<strong>如果一 个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E 的这次出现就称为公共子表达式。对于这种表达式，没有必要花时间再对它重新进行计算，可直接使用计算过的表达式结果代替E。</strong>如果这种优化仅限于程序基本块内，便可称为局部公共子表达式消除（Local Common Subexpression Elimination），如果这种优化的范围涵盖了多个基本块，那就称为全局公共子表达式消除（Global Common Subexpression Elimination）。<h4 id=数组边界检查消除><a class=headerlink href=#数组边界检查消除 title=数组边界检查消除></a>数组边界检查消除</h4><p>数组边界检查消除（Array Bounds Checking Elimination）是即时编译器中的一项语言相关的经典优化技术。如果有一个数组foo[]，在Java语言中访问数组元素foo[i]的时候系统将会自动进行上下界 的范围检查，即i必须满足“i>=0&&i<=foo.length”的访问条件，否则将抛出一个运行时异常： java.lang.ArrayIndexOutOfBoundsException。对于虚拟机执行子系统来说，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这必定是一种性能负担。<p>无论如何，为了安全，数组边界检查肯定是要做的，但数组边界检查是不是必须在运行期间一次 不漏地进行则是可以“商量”的事情。<strong>如果对于数组的访问在编译期根据数据流分析就能确定没有越界，执行时就无须判断了。</strong>更常见的是数组访问发生在循环中，且使用循环变量来访问数组。那么在循环中就可以把整个数组的上下界检查消除掉，这可以减少很多次的条件判断操作。<h3 id=0-3-4、Graal编译器><a class=headerlink href=#0-3-4、Graal编译器 title=0.3.4、Graal编译器></a>0.3.4、Graal编译器</h3><p><strong>从JDK 10起，Graal 编译器可以替换服务端编译器成为HotSpot分层编译中最顶层的即时编译器。</strong><p>Java虚拟机编译器接口（Java-Level JVM Compiler Interface，JVMCI）（JDK 9时发布的JEP 243）使得Graal可以从HotSpot的代码中分离出来。<p>通过Java虚拟机编译器接口就可以把一个在HotSpot虚拟机外部的、用Java语言实现的即时编译器（不局限于Graal）集成到HotSpot中，响应HotSpot发出的最顶层的编译请求，并将编译后的二进制代码 部署到 HotSpot代码缓存中。此外，又可以绕开HotSpot的即时编译系统，让该编译器直接为应用的类库编译出二进制机器码，将该编译器当作一个提前编译器去使用 （如Jaotc）。<h3 id=0-3-5、总结><a class=headerlink href=#0-3-5、总结 title=0.3.5、总结></a>0.3.5、总结</h3><p><strong>HotSpot VM采用解释器与即时编译器并存的架构。</strong>Java虚拟机运行时会采用解释器和即时编译器协调工作的方式来达到相对较好的工作状态。<p>栈空间大于堆空间，数据在堆空间和栈空间之间相互转存时需要满足一定的规则。<ul><li>堆转栈：直接处理。要注意的是：<ul><li>boolean、char无符号，低位复制，高位补0。<li>byte、short有符号，正数补0，负数补1。</ul><li>栈转堆：去掉多出的高位，只留剩下的低位。要注意的是，只有boolean只取最后一位保存即可。</ul><h2 id=0-4、本地方法接口><a class=headerlink href=#0-4、本地方法接口 title=0.4、本地方法接口></a>0.4、本地方法接口</h2><h3 id=0-4-1、本地方法><a class=headerlink href=#0-4-1、本地方法 title=0.4.1、本地方法></a>0.4.1、本地方法</h3><h4 id=0-4-1-1、定义><a class=headerlink href=#0-4-1-1、定义 title=0.4.1.1、定义></a>0.4.1.1、定义</h4><p><strong>被关键字native修饰的没有方法体的方法就是一个本地方法，本地方法是java调用非java代码的接口。</strong><h2 id=0-5、对象管理><a class=headerlink href=#0-5、对象管理 title=0.5、对象管理></a>0.5、对象管理</h2><h3 id=0-5-1、对象创建><a class=headerlink href=#0-5-1、对象创建 title=0.5.1、对象创建></a>0.5.1、对象创建</h3><p>创建对象一般遵循以下6大步骤：<ol><li>判断对象对应的类是否已经被加载、连接、初始化。<li>为对象分配内存。<ul><li>如果内存规整，通过 指针碰撞 方式来分配内存。<li>如果内存不规整，通过 空闲列表 方式来分配内存。</ul><li>处理并发安全问题。<ul><li>采用CAS失败重试，区域加锁保证更新原子性。<li>每个线程预先分配一个TLAB。</ul><li>初始化分配到的空间。<li>设置对象的对象头。<li>执行init方法进行初始化。</ol><h3 id=0-5-2、对象定位><a class=headerlink href=#0-5-2、对象定位 title=0.5.2、对象定位></a>0.5.2、对象定位</h3><h4 id=0-5-2-1、简介><a class=headerlink href=#0-5-2-1、简介 title=0.5.2.1、简介></a>0.5.2.1、简介</h4><p>对象访问有两种方式：句柄访问和直接指针。<strong>Java中使用的是直接指针</strong>。<h4 id=0-5-2-2、句柄访问><a class=headerlink href=#0-5-2-2、句柄访问 title=0.5.2.2、句柄访问></a>0.5.2.2、句柄访问</h4><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86-1.1-%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%BD%8D-%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%9B%BE%E7%A4%BA.png><h4 id=0-5-2-3、直接指针><a class=headerlink href=#0-5-2-3、直接指针 title=0.5.2.3、直接指针></a>0.5.2.3、直接指针</h4><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86-1.2-%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E5%9B%BE%E7%A4%BA.png><h1 id=1、JVM基础><a class=headerlink href=#1、JVM基础 title=1、JVM基础></a>1、JVM基础</h1><h2 id=1-1、概述><a class=headerlink href=#1-1、概述 title=1.1、概述></a>1.1、概述</h2><h3 id=1-1-1、简介><a class=headerlink href=#1-1-1、简介 title=1.1.1、简介></a>1.1.1、简介</h3><p><strong>JVM全称为Java Virtual Machine，意为Java虚拟机。</strong>Java虚拟机拥有解释运行、内存管理、即时编译等功能。<p><strong>JVM、JRE、JDK、JAVASE、JAVAEE等的关系：JVM < JRE < JDK < JAVASE < JAVAEE。它们之间是包含与被包含的关系。</strong>详情介绍如下：<ul><li><strong>JVM</strong>：Java Virtual Machine，表示Java虚拟机。<li><strong>JRE</strong>：Java Runtime Environment，表示Java运行时环境。<li><strong>JDK</strong>：Java Development Kit，表示Java开发工具集。<li><strong>JAVAME</strong>：Java Micro Edition，表示Micro版，之前称J2ME。是一个技术和规范的集合，它为移动设备（包括消费类产品、嵌入式设备、高级移动设备等）提供了基于Java环境的开发与应用平台。Java ME分为两类配置，一类是面向小型移动设备的<em>CLDC</em>（Connected Limited Device Profile），一类是面向功能更强大的移动设备如智能手机和机顶盒，称为<em>CDC</em>（Connected Device Profile CDC）。Java ME有自己的类库，其中<em>CLDC</em>使用的是专用的Java虚拟机叫做J<em>VM</em>。<li><strong>JAVASE</strong>：Java Standard Edition，表示Java标准版，之前称为J2SE。JAVASE是Java技术的核心和基础，是Java ME和Java EE编程的基础。<li><strong>JAVAEE</strong>：Java Enterprise Edition，表示Java企业版，之前也称为J2EE。Java EE 是在 Java SE 的基础上构建的，它提供Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 3.0应用程序。</ul><p>JVM在垃圾回收层面与C++的区别：<ul><li>JAVA：系统自动处理，开发效率高，执行效率低。<li>C++：手工处理，开发效率低，执行效率高。容易出现忘记回收、内存泄漏、回收多次、非法访问等问题。</ul><h3 id=1-1-2、优点><a class=headerlink href=#1-1-2、优点 title=1.1.2、优点></a>1.1.2、优点</h3><p>JVM优点如下：<ul><li>一次编译，到处运行。<li>自动垃圾回收。<li>多态特性。<li>数组下标越界检查。</ul><h3 id=1-1-3、常见虚拟机><a class=headerlink href=#1-1-3、常见虚拟机 title=1.1.3、常见虚拟机></a>1.1.3、常见虚拟机</h3><ul><li><p>Hotspot</p><li><p>JRockit（BEA）：专注于服务端应用，据行业基准测试显示，其是世界上最快的JVM。2008年BEA被Oracle收购，Oracle计划将整合两大优秀的虚拟机，整合方式是在Hotspot基础上加入JRockit的新特性。</p><li><p>J9（IBM）：市场定位与HotSpot相似，适用于服务器端、桌面应用、嵌入式应用等场景。2017年左右，IBM开源了J9 VM，命名为OpenJ9，交给Eclipse基金会管理。</p><li><p>KVM</p><li><p>Azul VM</p><li><p>Liquid VM（BEA）</p><li><p>Graal VM：2018年Oracle公开Graal VM，号称“Run Programs Faster Anywhere”，其与1995年宣称的“Write Once, Run Anywhere”遥相呼应。Graal VM是在HotSpot VM基础上增强而成的跨语言全栈虚拟机，适用于多种语言。</p></ul><h3 id=1-1-4、虚拟机退出><a class=headerlink href=#1-1-4、虚拟机退出 title=1.1.4、虚拟机退出></a>1.1.4、虚拟机退出</h3><p>导致虚拟机退出的情况分以下几种：<ul><li>程序正常结束。<li>程序执行过程中遇到了异常或错误，进而导致虚拟机退出。<li>因操作系统出现错误导致虚拟机退出。<li>调用了Runtime类或System类的exit方法，或Runtime类的halt方法，且Java安全管理器也允许这种操作。</ul><h2 id=1-2、垃圾><a class=headerlink href=#1-2、垃圾 title=1.2、垃圾></a>1.2、垃圾</h2><h3 id=1-2-1、概述><a class=headerlink href=#1-2-1、概述 title=1.2.1、概述></a>1.2.1、概述</h3><p><strong>没有引用指向的任何对象和不再使用的类都是垃圾，应该被回收。</strong><p><strong>方法区中可以回收的内容主要就是不再使用的类</strong>。一个类是否被回收，需要满足一定的条件。当符合以下全部情况时，类将会被回收。<ul><li>此类所有实例对象都已经被回收，在堆中不存在该类的实例对象及子类对象。<li>加载该类的类加载器已经被回收。<li>该类对应的java.lang.Class对象没有在任何地方被引用。</ul><p>堆区域是垃圾回收的主要区域。堆中主要回收的内容就是没有引用指向的对象。<h3 id=1-2-2、识别垃圾><a class=headerlink href=#1-2-2、识别垃圾 title=1.2.2、识别垃圾></a>1.2.2、识别垃圾</h3><h4 id=1-2-2-1、简介><a class=headerlink href=#1-2-2-1、简介 title=1.2.2.1、简介></a>1.2.2.1、简介</h4><p>对于JVM来说，需要通过一些方法来识别并找到垃圾，找到垃圾后才可以执行回收清理工作，进而保持JVM的正常高效运作。<p><strong>识别垃圾的方法，目前只要有两种：引用计数算法、根可达性算法</strong>。两种算法各有优缺点，找到最适合的方法才是最好的。<h4 id=1-2-2-2、引用计数算法><a class=headerlink href=#1-2-2-2、引用计数算法 title=1.2.2.2、引用计数算法></a>1.2.2.2、引用计数算法</h4><h5 id=简介-4><a class=headerlink href=#简介-4 title=简介></a>简介</h5><p><strong>当一个对象被引用时，该对象的引用计数器数值就会加1，这就是引用计数算法。</strong><h5 id=特点><a class=headerlink href=#特点 title=特点></a>特点</h5><p>引用计数算法有以下特点<ol><li><font color=red>需要一个单独字段来存储计数器计算结果，增加了存储开销。</font><li><font color=red>每次赋值都需要更新计数器，增加了时间开销。</font></ol><h5 id=缺点><a class=headerlink href=#缺点 title=缺点></a>缺点</h5><p>引用计数算法不能解决“循环引用”问题。<blockquote><p>循环引用问题指：有对象A和对象B，对象A中含有对象B的引用，对象B中含有对象A的引用。此时，对象A和对象B的引用计数器都不为0，但是在系统中却不存在任何第3个对象引用了A或B。也就是说A和B是应该被回收的垃圾对象，但由于垃圾对象间相互引用，从而使垃圾回收器无法识别，引起内存泄漏。</blockquote><h4 id=1-2-2-3、根可达性算法><a class=headerlink href=#1-2-2-3、根可达性算法 title=1.2.2.3、根可达性算法></a>1.2.2.3、根可达性算法</h4><h5 id=简介-5><a class=headerlink href=#简介-5 title=简介></a>简介</h5><p><strong>根搜索算法有实现简单、执行高效等特点，可有效解决循环引用问题，防止内存泄漏发生。</strong><p>根搜索算法是以 根对象集合 为起始点，按照从上至下的方式 搜索 被根对象集合所连接的目标对象是否可达，如果目标对象不可达就表明该对象己死亡，便可以在 instanceOopDesc Mark World 中将其标记为垃圾对象。在根搜索算法中，只有被根对象集合直接或间接连接的对象才是存活对象。<h5 id=根对象><a class=headerlink href=#根对象 title=根对象></a>根对象</h5><p>根对象通常分为4类：详情如下：<ul><li>线程Thread对象，引用线程栈帧中的方法参数、局部变量等。<li>系统类加载器加载的java.lang.Class对象，引用类中的静态变量。<li>监视器对象，用来保存同步锁synchronized关键字持有的对象。<li>本地方法调用时使用的全局对象。</ul><p>在Hotspot中，根对象集合包含5个元素：<ol><li>Java 对象引用。<li>本地方法内的对象引用。<li>运行时常量池中的对象引用。<li>方法区中类静态属性的对象引用。<li>与一个类对应的唯一数据类型的 Class 对象。</ol><h5 id=注意事项><a class=headerlink href=#注意事项 title=注意事项></a>注意事项</h5><p><strong>根搜索算法中的不可达对象最初处于缓刑阶段，真正死亡要经历两次标记</strong>：<ol><li>如果一个对象没有与GCRoot相连，那么该对象会被第一次标记并判断是否执行该对象的finaliz()方法。如果该对象没有覆盖finalize()方法或finalize()方法已经执行过了，那么无需操作，否则会将该对象放入F-Queue中，然后通过一个低优先级的finalizer线程来执行该对象的finalize()方法。<li>稍后 GC 将对 F- Queue 中的对象进行第二次标记，第二次标记之前，如果该对象与其它对象建立了引用关系，那么第二次标记时会将该对象移出即将回收的集合。如果第二次标记之前，该对象没有与其它对象建立引用关系，那么它会被真正回收。</ol><h2 id=1-3、对象生命周期><a class=headerlink href=#1-3、对象生命周期 title=1.3、对象生命周期></a>1.3、对象生命周期</h2><h3 id=1-3-1、概述><a class=headerlink href=#1-3-1、概述 title=1.3.1、概述></a>1.3.1、概述</h3><p><strong>创建对象后会优先栈上分配；如果不能分配，先判断其大小，如果太大直接放进老年代，如果不大，就尝试先在TLAB中分配；如果还是分配不下，就直接在eden区分配。</strong><p>eden区经过一次垃圾回收之后，存活对象会进入surivor from区，eden区和surivor from区再经过一次回收后，存活对象会被移动到survivor to区（注意：移动完成后from区和to区交换角色，即 from变to，to变from，为的是下次再回收alive对象），以此反复执行，直到年龄达到阈值时就进入老年代。<p><font color=red>注意：from <—> to区中对象间的移动超过阈值就会进入老年代，这个阈值可通过参数<code>-XX:MaxTenuringThreshold=threshold</code>进行设置。</font><p>栈上分配前提条件：<ul><li>线程私有小对象。<li>热点代码。<li>无逃逸：在某一段代码中使用，代码外无法使用。<li>支持标量替换：用普通的类型代替对象（若仅仅使用一个对象中的1至2个属性，那么就无需先拿到对象再获取对应属性，而是直接使用这两个属性代替这个对象）。<li>无需调整。</ul><h3 id=1-3-2、新生代><a class=headerlink href=#1-3-2、新生代 title=1.3.2、新生代></a>1.3.2、新生代</h3><h4 id=1-3-2-1、简介><a class=headerlink href=#1-3-2-1、简介 title=1.3.2.1、简介></a>1.3.2.1、简介</h4><p>新生代也称为年轻代，新生代分为Edon区和Survivor区，Survivor区又分为Survivor0区和Survivor1区，或者说From区和To区。<p>Edon区、Survivor区特点如下：<ul><li>eden（伊甸）：默认占年轻代的比例为8/10，存放刚new出来的对象。<li>survivor from：默认比例为1，回收一次后要存储对象的区域。<li>survivor to：默认比例为1，回收一次后要存储对象的区域。</ul><h4 id=1-3-2-2、新生代GC><a class=headerlink href=#1-3-2-2、新生代GC title=1.3.2.2、新生代GC></a>1.3.2.2、新生代GC</h4><p>对象被创建后通常会先放在Edon区中，当执行一次Minor GC（YGC、年轻代GC）时，会标记Edon区和Survivor From区中的存活对象，并将这些存活对象统一转移至Survivor To区，然后清除Edon区和Survivor From区中没有被标记的死亡对象（垃圾对象）。<p>经过一次YGC后，会交换From区和To区的名字，即原为From区，现为To区，原为To区，现为From区。且会将被转移的存活对象的年龄加1。当对象年龄达到参数<code>-XX:MaxTenuringThreshold=threshold</code>设定的值时会在GC执行的过程中被转移至老年代。<p>Minor GC的注意事项如下：<ul><li>年轻代空间不足时会触发Minor GC，Survivor区满并不会触发Minor GC。<li>Minor GC会引发STW，暂停其它用户线程，当垃圾线程执行完后用户线程才会恢复。</ul><h3 id=1-3-3、老年代><a class=headerlink href=#1-3-3、老年代 title=1.3.3、老年代></a>1.3.3、老年代</h3><h4 id=1-3-3-1、简介><a class=headerlink href=#1-3-3-1、简介 title=1.3.3.1、简介></a>1.3.3.1、简介</h4><p>当对象满足一定的规则时，会被转移至老年代空间中。<p>触发对象被转移至老年代的规则有两个：<p><strong>（1）设置参数<code>-XX:MaxTenuringThreshold=threshold</code>来限定何时将对象转移至老年代</strong><p>参数值表示触发对象被转移至老年代时的对象年龄，如果没有指定该参数，则默认参考为：Parallel Scavenge垃圾回收器中的对象年龄为15，CMS垃圾回收器中的对象年龄为6，G1垃圾回收器中的对象年龄为15。<p><strong>(2）动态年龄</strong><p>from -> to后超过to内存总量50%。eden区+from区的存活对象全部移到to区且这些存活对象占用to区容量的一半，则将to区中大于等于这些存活对象中最大年龄的那些对象直接放入老年代。所以说也不一定非得到了15岁/6岁才行。相关参数为<code>-XX:TargetSurvivorRatio</code>。<p>除此之外，如果一个对象比较大，那么会直接被转移至老年代。<h4 id=1-3-3-2、老年代GC><a class=headerlink href=#1-3-3-2、老年代GC title=1.3.3.2、老年代GC></a>1.3.3.2、老年代GC</h4><p>老年代特点如下：<ul><li>tenured（终身）：默认与新生代的比例为2:1，存放大对象和生命力较强的对象。</ul><p>老年代GC注意事项如下：<ul><li>出现了Major GC前通常会先执行一次Minor GC（非绝对，Parallel Scavenge收集器可以直接执行Major GC。）。<li>Major GC 速度一般比Minor GC慢10倍以上。<li>Major GC后内存依然不足就会报OOM异常。</ul><h3 id=1-3-4、Full-GC><a title="1.3.4、Full GC" class=headerlink href=#1-3-4、Full-GC></a>1.3.4、Full GC</h3><p>触发FGC的情况有如下几种：<ul><li>老年代空间不足。<li>方法区空间不足。<li>通过Minor GC后进入老年代的对象的平均大小大于老年代可用空间。<li>由Eden区、Survivor from区向Survivor to区复制对象时，对象大小大于to区可用内存，则把这些对象放进老年代，且老年代可用内存小于这些对象大小。<li>调用System.gc()方法时，通知系统执行Full GC，但不保证一定执行。</ul><h2 id=1-4、垃圾回收算法><a class=headerlink href=#1-4、垃圾回收算法 title=1.4、垃圾回收算法></a>1.4、垃圾回收算法</h2><h3 id=1-4-1、标记清除（Mark-Sweep）><a class=headerlink href=#1-4-1、标记清除（Mark-Sweep） title=1.4.1、标记清除（Mark-Sweep）></a>1.4.1、标记清除（Mark-Sweep）</h3><h5 id=定义><a class=headerlink href=#定义 title=定义></a>定义</h5><p><strong>标记存活对象，然后清除未被标记的垃圾对象的算法称为标记清除算法。</strong>该算法将垃圾回收分两个阶段，标记阶段和清除阶段。<ol><li><p>标记阶段：Collector从引用根节点开始遍历，标记可以被根对象关联到的对象，这些对象都是可达对象。</p><li><p>清除阶段：Collector对堆内存从头到尾进行线性遍历，如果发现某个对象在其Header中没有被标记为可达对象，则将其回收。这里的清除并非是真的清除，而是将待清除对象的地址保存到空闲地址列表中，为新对象分配内存时直接覆盖使用。</p></ol><p>标记-清除算法不需要运行环境监测每一次内存分配和指针操作，而只要在“标记”阶段中跟踪每个指针变量的指向，用类似思路实现的垃圾收集器常被称为 跟踪收集器。<h5 id=优缺点><a class=headerlink href=#优缺点 title=优缺点></a>优缺点</h5><ul><li>优点：效率较高、成本较低。<li>缺点：会产生内存碎片。</ul><h3 id=1-4-2、复制（Copying）><a class=headerlink href=#1-4-2、复制（Copying） title=1.4.2、复制（Copying）></a>1.4.2、复制（Copying）</h3><h5 id=定义-1><a class=headerlink href=#定义-1 title=定义></a>定义</h5><p><strong>将内存空间分为两块，每次只使用其中一块。垃圾回收时会将当前使用内存（假如为区域A）中的存活对象拷贝至另一空闲内存中（假如为区域B），然后清掉区域A中剩下的死亡对象并交换两个内存区域的角色，最后完成垃圾回收，这种算法称之为 复制算法。</strong><h5 id=优缺点-1><a class=headerlink href=#优缺点-1 title=优缺点></a>优缺点</h5><ul><li>优点：只扫描一次，效率高且没有碎片；<li>缺点：<font color=red>每次需要使用一半内存，造成空间浪费；移动复制对象需要调整对象引用；</font></ul><h5 id=适用场景><a class=headerlink href=#适用场景 title=适用场景></a>适用场景</h5><p>适用于存活对象较少的情况。<h3 id=1-4-3、标记压缩（Mark-Compact）><a class=headerlink href=#1-4-3、标记压缩（Mark-Compact） title=1.4.3、标记压缩（Mark-Compact）></a>1.4.3、标记压缩（Mark-Compact）</h3><h5 id=定义-2><a class=headerlink href=#定义-2 title=定义></a>定义</h5><p>标记压缩算法思想：<strong>从根节点开始标记所有被引用对象，然后将存活对象压缩到内存一端并按顺序排放，之后清理边界外所有的空间。</strong><p>空间压缩后，内存较为规整，此种情况下可以通过 指针碰撞 算法为新对象分配空间。<h5 id=优缺点-2><a class=headerlink href=#优缺点-2 title=优缺点></a>优缺点</h5><ul><li>优点：不会产生碎片；<li>缺点：<font color=red>两遍扫描，第一遍先找出有用的，第二遍才进行移动，如果是多线程还需要进行同步，效率低。</font></ul><h3 id=1-4-4、增量算法-（Incremental-Collecting><a title="1.4.4、增量算法 （Incremental Collecting )" class=headerlink href=#1-4-4、增量算法-（Incremental-Collecting></a>1.4.4、增量算法 （Incremental Collecting )</h3><p>增量算法思想：<strong>垃圾收集线程和应用程序线程交替执行，每次垃圾收集线程只收集小片内存空间，然后切换到应用程序线程执行。依次反复，直到垃圾收集完成。</strong><p><strong>垃圾回收线程和应用程序线程同时执行可减少停顿时间，但因线程切换、上下文转换等会降低吞吐量。</strong><h3 id=1-4-5、其它><a class=headerlink href=#1-4-5、其它 title=1.4.5、其它></a>1.4.5、其它</h3><h4 id=1-4-5-1、屏障><a class=headerlink href=#1-4-5-1、屏障 title=1.4.5.1、屏障></a>1.4.5.1、屏障</h4><h5 id=简介-6><a class=headerlink href=#简介-6 title=简介></a>简介</h5><p>屏障指的是一段逻辑代码，通常会被插入到原生代码中，并在原生代码执行前，或执行时，或执行后来做一些额外的操作。<h5 id=写屏障><a class=headerlink href=#写屏障 title=写屏障></a>写屏障</h5><p>对于G1垃圾回收器来说，屏障代码会被插入到原生代码中引用赋值语句的前和后，分别称为写前屏障和写后屏障。<ul><li>写前屏障：当执行原生代码中的引用赋值代码时，等式左侧的引用会被修改引用另一个对象。而等式左侧引用之前指向的那个对象将失去一个引用。写前屏障的作用就是在引用赋值生效前，记录失去引用的那个对象。JVM不会立即同步更新RSet，而会基于队列实现异步更新。<li>写后屏障：当执行原生代码中的引用赋值代码后，等式右边的对象就会被等式左边的引用来指向，同时需要更新等式右边对象所在分区的RSet，不过同样是基于队列实现异步更新。</ul><h4 id=1-4-5-2、Card-Table（卡表）><a title="1.4.5.2、Card Table（卡表）" class=headerlink href=#1-4-5-2、Card-Table（卡表）></a>1.4.5.2、Card Table（卡表）</h4><h5 id=简介-7><a class=headerlink href=#简介-7 title=简介></a>简介</h5><blockquote><p>官方描述： A <em>card table</em> is a particular type of remembered set. Java HotSpot VM uses an array of bytes as a card table. Each byte is referred to as a <em>card</em>. A card corresponds to a range of addresses in the heap. <em>Dirtying a card</em> means changing the value of the byte to a <em>dirty value</em>; a dirty value might contain a new pointer from the old generation to the young generation in the address range covered by the card.<p>卡表是一种特殊类型的记忆集。Java HotSpot VM 使用字节数组作为卡片表。每个字节称为一张卡。卡片对应于堆中的地址范围。弄脏卡意味着将字节的值更改为脏值，脏值可能包含从老一代到卡所涵盖的地址范围内的年轻一代的新指针。</blockquote><p>Card是一个特殊类型的RSet。Card Table底层是一个字节数组，每个字节称为一个Card，每个字节对应堆中老年代的某个范围的内存地址，也即，每个字节代表老年代中的一小片内存，该字节对应的字节数组中的索引会被拿来表示这一小片内存的地址。默认情况下，每个Card对应老年代中512字节大小的内存，JDK18开始，可以通过参数<code>-XX:GCCardSizeInBytes</code>来设置每个Card可以表示的内存大小。<h5 id=底层原理><a class=headerlink href=#底层原理 title=底层原理></a>底层原理</h5><p>卡表作用：<strong>当老年代中的对象引用了年轻代中的对象时，写屏障逻辑就会将老年代中引用了年轻代对象的对象所占内存对应的Card Table中的Card标记为Dirty（脏），即将该Card对应的字节值标记为1（JDK8源码中1表示被引用了，称为脏卡），这样GC扫描收集垃圾时只需要扫描Dirty Card即可。</strong><p>卡表占堆内存的总大小计算公式为：<code>堆大小/512</code>，这里的512表示的是每个字节可表示的内存大小。<h4 id=1-4-5-3、RSet><a class=headerlink href=#1-4-5-3、RSet title=1.4.5.3、RSet></a>1.4.5.3、RSet</h4><h5 id=简介-8><a class=headerlink href=#简介-8 title=简介></a>简介</h5><p><strong>RSet是Remembered Set的缩写，意为记录集合</strong>。G1中的每个Region都有一个RSet，它是一个hash表，Key是其它Region的起始地址，Value是一个存储Card Table索引的集合。RSet会和Card Table协同来工作。<p>比如，RegionB引用了RegionA中的对象，那么RegionA关联的RSet就会记录RegionB。当GC扫描RegionA并标记其中的存活对象时，就需要知道哪些Region引用了RegionA中的对象，查询RegionA的RSet后发现RegionB中的对象引用了RegionA中的对象，此时GC就需要扫描整个RegionB来找到具体那个对象引用了RegionA。<p>扫描整个RegionB来寻找哪些对象引用了RegionA中的对象这个过程通常耗时会很长，且效率低下。为了解决这个问题，Card Table就出现了，在Card Table的辅助下，在扫描RegionB时，只需扫描Card Table中的Dirty Card即可得到哪些对象引用了RegionA中的对象，如次一来，效率就大大提升了。<p>**RSet大小和Region数量有直接关系，一般来说 RSet 的大小占整个 Java 堆空间的1%~20%**。<blockquote><p>当Region被引用较多时，RSe占用空间会上升，因此为RSet存储划分了三种粒度：<ul><li>稀疏表（Sparse）：直接通过哈希表来存储，key 是 region index，value 是 card 数组（记录 card index）。<li>细粒度（Fine）：当一个 region 的 card 数量超过阈值时，退化为一个 bitmap，每一位对应一个card（index）。如果bit为0表示该bit对应的内存分段中没有引用，为1表示有引用。<li>粗粒度（Coarse）：当引用 region 数量超过阈值时，退化为使用bitmap只记录 regin 引用，每一位对应一个 region（index）。</ul><p>因为某些Region中的对象可能会被其它许多对象引用，为避免保存太多数据，故会以更大粒度保存引用，这种方式会减少RS数据，但会增加扫描和标记开销，因为需要扫描所有bit为1的内存分段中的对象以确定具体是来自哪个对象的引用。</blockquote><h5 id=底层原理-1><a class=headerlink href=#底层原理-1 title=底层原理></a>底层原理</h5><p>RSet的作用为：<strong>当引用发生改变时，写屏障会先检查引用和被引用的对象是否在同一个Region中，如果不在一个Region，那么需要将引用对象关联的Card Table中的Card索引信息记录到被引用对象关联的RSet中</strong>。<p>当引用发生变化时，会把引用关系更新到RS中。RS更新并非实时性，RS处理需要线程同步，开销会很大，所以为了性能需要，G1维护了一个Dirty Card Queue。对于引用赋值语句，JVM会在之前和之后执行特殊操作以在dirty card queue中加入一个保存了对象引用信息的card。YGC时G1会对Dirty Card Queue中所有的card进行处理并更新RS，以保证RS实时准确的反映引用关系。<h5 id=point-in机制><a class=headerlink href=#point-in机制 title=point-in机制></a>point-in机制</h5><p><strong>G1中RSet使用point-in机制，而CMS使用point-out机制</strong>。<p>point-in是指：哪些分区中的对象引用了当前分区中的对象，就在当前分区的RSet中记录哪些分区。<h4 id=1-4-5-4、CSet><a class=headerlink href=#1-4-5-4、CSet title=1.4.5.4、CSet></a>1.4.5.4、CSet</h4><h5 id=简介-9><a class=headerlink href=#简介-9 title=简介></a>简介</h5><p><strong>CSet是Collection Set的缩写，意为回收集合，即，需要回收的内存区域的集合。</strong><p>根据垃圾回收的类型，回收集合中的内存由不同的区域组成：<ul><li>Minor GC（YGC）：回收集合包含年轻代的区域和可能被回收的大对象区域。<li>回收阶段：回收集合包含年轻代的区域、大对象区域，及回收集候选区域中的一些老年代区域组成。</ul><h5 id=底层原理-2><a class=headerlink href=#底层原理-2 title=底层原理></a>底层原理</h5><p>一个回收集合中能有多少Regopm，与以下两个方面有关：<ul><li>有多少Region可以被释放、<li>G1目标停顿时间。</ul><p>G1会在并发周期内回收集合候选区域。在重新标记期间，G1会选择内存使用率较低的Region区域。在备注和清理暂停之间同时准备这些区域，以供后续收集。G1会对这些待回收的区域进行优先级排序，某个区域回收后得到的可用空间大，那么这个待回收区域的优先级就高。后续会根据目标暂停时间，及其它相关需求，并按照待回收区域优先级来有选择性的回收或多或少的区域。<h4 id=1-4-5-5、TLAB><a class=headerlink href=#1-4-5-5、TLAB title=1.4.5.5、TLAB></a>1.4.5.5、TLAB</h4><h5 id=简介-10><a class=headerlink href=#简介-10 title=简介></a>简介</h5><p>堆内存线程共享，多个线程创建对象来分配内存时，为了避免在同一块内存中分配起冲突，所以内存分配的动作需要同步。因为创建对象分配内存是非常频繁的动作，若多个线程的内存分配操作都同步执行，那这就与单个线程在执行差不多，性能极差，成为了提升应用性能的巨大瓶颈。<p>为了避免这种问题的存在，<strong>JVM提出Thread Local Allocation Buffer，可简称为TLAB，意为线程本地分配缓冲</strong>。JVM会为每一个线程分配一个独占私有的内存空间，这个内存空间就称为TLAB，每个线程创建对象分配内存时，会在自己独占的TLAB空间中分配，这样一来就避免了内存分配冲突需要同步分配的问题。<blockquote><p>对于G1垃圾回收器，当对象是Humongous对象，且TLAB也能装下时，同样会被优先分配在线程的TLAB中。</blockquote><p><font color=red>注意：TLAB的独占只限于“内存分配”这个动作，而对于TLAB的读取、内存回收等操作依然属于线程共享。</font><h5 id=参数><a class=headerlink href=#参数 title=参数></a>参数</h5><p>与TLAB相关的参数如下：<ul><li>手动指定tlab大小：-XX：TLABSize<li>tlab功能开启/关闭：XX:+/-UseTLAB<li>tlab占eden空间百分比：-XX:TLABWasteTargetPercent<li>禁用tlab运行时动态自动调整大小功能：-XX:-ResizeTLAB<li>tlab的refill_waste值：-XX：TLABRefillWasteFraction（默认大小64，表示使用约为1/64空间大小作为refill_waste）<li>观察tlab使用情况：-XX+PringTLAB</ul><h5 id=TLAB空间不足><a class=headerlink href=#TLAB空间不足 title=TLAB空间不足></a>TLAB空间不足</h5><p>TLAB空间大小有限制，当空间被用完时会发生什么？<p>当线程创建对象并从TLAB中分配内存时，如果TLAB空闲内存不足，那么会有如下四种可选项：<ul><li>为当前线程分配一个新的TLAB空间，然后在新的TLAB空间中分配内存。<li>在TLAB空间外的堆中分配内存。<li>尝试使用垃圾回收器释放一些内存。<li>无法分配内存，抛出错误。</ul><p>JVM使用复杂的启发式方法来确定具体使用哪些选项，但这些启发式方法可能在不同JVM和不同版本间发生变化。然而，影响这一变化的重要细节包括：<ul><li>一段时间内可能的分配数量。如果要分配大量对象的内存，那么增加TLAB空间将是更有效的选择。如果要分配内存的对象数量很少，那么增加TLAB空间反而效率会很低。<li>正在请求的内存量。请求的内存越多，在TLAB空间外分配内存的成本就越高。<li>可用内存量。如果JVM还有大量可用内存，那么增加TLAB空间相对容易。如果剩余空闲空闲很少，那么增加TLAB空间的成本就会相对较高。<li>内存争用量。如果JVM中有很多线程，每个线程都需要分配内存，那么增加TLAB空间可能比线程少时的情况花费的成本要高。</ul><p>假如一个线程的TLAB空间大小为100KB，已经使用80KB，当再分配一个30KB的对象时，就无法在TLAB中分配，遇到此种情况，有两种处理方案：<ol><li>直接在堆内存中分配对象。<li>废弃当前TLAB，重新申请TLAB并在其中为对象分配内存。</ol><p>为解决这两个问题，虚拟机设定了一个参数<code>refill_waste</code>，称为最大浪费空间。当请求分配的内存大于该参数值，则在堆内存中分配对象，当小于该值时则废弃当前TLAB并重新申请TLAB，然后在其中进行对象分配。<h4 id=1-4-5-6、PLAB><a class=headerlink href=#1-4-5-6、PLAB title=1.4.5.6、PLAB></a>1.4.5.6、PLAB</h4><h5 id=简介-11><a class=headerlink href=#简介-11 title=简介></a>简介</h5><p>垃圾回收器工作期间会有多个线程参与执行，当多个线程需要将存活对象转移至其它空闲内存中时，可能会发生向同一块内存中拷贝的现象，这显然是不正确的，但这种情况也确实可能存在。为了避免多个线程把存活对象向同一块内存中拷贝，<strong>JVM提出了Promotion Local Allocation Buffer，简称PLAB，意为晋升本地分配缓冲</strong>。<p>JVM会为每个线程创建一个独占私有的内存空间，这个内存空间就称为PLAB。当多个线程需要转移存活对象时，会将这些对象转移至自己独占的PLAB空间中，如此一来，就避免了转移冲突问题。<h5 id=参数-1><a class=headerlink href=#参数-1 title=参数></a>参数</h5><ul><li><code>-XX:-ResizePLAB</code>：表示关闭PLAB大小的自动调整。多线程环境下，关闭该功能可一定程度上提升性能。</ul><h4 id=1-4-5-7、SATB><a class=headerlink href=#1-4-5-7、SATB title=1.4.5.7、SATB></a>1.4.5.7、SATB</h4><h5 id=简介-12><a class=headerlink href=#简介-12 title=简介></a>简介</h5><p><strong>SATB是Snapshot At The Beginning的的缩写，意为开始时快照。SATB是由Taiichi Tuasa提出的增量式完全并发标记算法，主要用于使用标记清除算法的垃圾回收器的并发标记阶段</strong>。<p>每个线程都有一个独占的SATB缓冲区，初始大小为256条记录，当空间用完时会分配新的缓冲区继续使用，而旧的缓冲区会被加入全局列表。<p>SATB针对G1的Region分区来设计，又解决了CMS重新标记过程暂停时间长的问题。<h5 id=底层原理-3><a class=headerlink href=#底层原理-3 title=底层原理></a>底层原理</h5><p>SATB的核心思想是创建一个对象图，类似于堆的逻辑快照，确保在并发标记阶段能快速定位所有垃圾对象。<strong>当引用发生改变时，写前屏障会在引用变更前，将值记录在SATB的日志或缓冲区中</strong>。<p><strong>并发标记阶段，标记线程会定期检查和处理全局缓冲区列表中的记录。根据标记位图的标记位来扫描引用字段并更新RSet，这个过程称为并发标记或SATB写前屏障</strong>。<h2 id=1-5、垃圾收集器><a class=headerlink href=#1-5、垃圾收集器 title=1.5、垃圾收集器></a>1.5、垃圾收集器</h2><h3 id=1-5-1、Serial（JDK1-3）><a class=headerlink href=#1-5-1、Serial（JDK1-3） title=1.5.1、Serial（JDK1.3）></a>1.5.1、Serial（JDK1.3）</h3><h4 id=简介-13><a class=headerlink href=#简介-13 title=简介></a>简介</h4><p><strong>JDK1.3.1引入Serial GC，适用于存储器小，CPU少的环境。</strong><p>Serial 收集器工作于<strong>年轻代</strong>，采用<strong>复制算法</strong>、串行回收和“ Stop-the-World ”机制的方式执行内存回收。<p><strong>注意事项：JDK8及之前版本，Seril和CMS可以搭配使用，JDK9开始废除了这种搭配</strong>。<h4 id=参数-2><a class=headerlink href=#参数-2 title=参数></a>参数</h4><ul><li>-XX:+UseSerialGC：表示使用Serial垃圾回收器。年轻代会被Serial回收、老年代会被Serial Old回收。</ul><h3 id=1-5-2、Serial-Old><a title="1.5.2、Serial Old" class=headerlink href=#1-5-2、Serial-Old></a>1.5.2、Serial Old</h3><h4 id=简介-14><a class=headerlink href=#简介-14 title=简介></a>简介</h4><p>Serial Old收集器工作于<strong>老年代</strong>，采用单线程<strong>标记压缩算法</strong>。<blockquote><p>Serial Old是运行在Client模式下默认的老年代垃圾回收器。Serial Old在Server模式下主要有两个用途：与新生代的Parallel Scavenge配合使用；作为老年代CMS收集器的后备方案。</blockquote><h4 id=参数-3><a class=headerlink href=#参数-3 title=参数></a>参数</h4><ul><li>-XX:+UseSerialGC：表示使用Serial垃圾回收器。年轻代会被Serial回收、老年代会被Serial Old回收。</ul><h3 id=1-5-3、Parallel-Scavenge（JDK1-4）><a title="1.5.3、Parallel Scavenge（JDK1.4）" class=headerlink href=#1-5-3、Parallel-Scavenge（JDK1-4）></a>1.5.3、Parallel Scavenge（JDK1.4）</h3><h4 id=简介-15><a class=headerlink href=#简介-15 title=简介></a>简介</h4><p><strong>JDK1.4.2引入Parallel GC，JDK6中成为默认垃圾回收器。</strong><p>Parallel Scavenge收集器工作在<strong>年轻代</strong>，采用<strong>复制算法</strong>，关注吞吐量。与并行收集器一样都是多线程、独占式的收集器。<p>自适应调节策略是Parallel Scavenge与ParNew的一个重要区别。<blockquote><p>如果没有优化，JDK8默认使用Parallel Scavenge和Parallel Old，简称PS+PO。</blockquote><p><strong>注意事项：JDK14之前，Parallel Scavenge和Serial Old可以搭配使用。但JDK14开始废除了这种搭配</strong>。<h4 id=参数-4><a class=headerlink href=#参数-4 title=参数></a>参数</h4><ul><li>-XX:+UseParallelGC：年轻代使用并行回收收集器，老年代使用串行收集器。<li>-XX:+UseParallelOldGC：年轻代和老年代都使用井行垃圾回收器。<li>-XX:ParallelGCThreads：年轻代并行收集器的线程数量。默认当CPU数量小于8时线程数量等于CPU数量。当CPU数量大于8时线程数量值为<code>3 + [5 * cpu数量 / 8]</code>。<li>-XX MaxGCPauseMills：最大垃圾收集停顿时间（单位毫秒），它的值是一个大于0的整数。<li>-XX:+GCTimeRatio：垃圾收集时间占总时间的比例。取值范围为0~100，默认值为99，也就是垃圾回收时间占用不超过1%。与参数<code>-XX MaxGCPauseMills</code>有一定矛盾性。<li>-XX:+UseAdaptiveSizePolicy：开启自适应调节策略。在这种模式下，年轻代的大小、 Eden的比例、晋升老年代的对象年龄等参数会被自动调整，己达到在堆大小、吞吐量和停顿时间之间的平衡点。仅指定虚拟机的最大堆、目标的吞吐量（ GCTimeRatio ）和停顿时间（ MaxGCPauseMills) , 让虚拟机自己完成调优工作。</ul><h3 id=1-5-4、Parallel-Old><a title="1.5.4、Parallel Old" class=headerlink href=#1-5-4、Parallel-Old></a>1.5.4、Parallel Old</h3><h4 id=简介-16><a class=headerlink href=#简介-16 title=简介></a>简介</h4><p><strong>JDK6开始启用Parallel Old垃圾回收器，工作于老年代。它是一种采用标记压缩算法且基于并行回收和“Stop-the-World”机制的关注吞吐量的多线程并发收集器，。</strong><h4 id=如何开启？><a class=headerlink href=#如何开启？ title=如何开启？></a>如何开启？</h4><ul><li>-XX:+UseParallelOldGC：年轻代和老年代中都使用并行回收收集器；<li>-XX :ParallelGCThreads：垃圾回收时的线程数量；</ul><h3 id=1-5-5、ParNew><a class=headerlink href=#1-5-5、ParNew title=1.5.5、ParNew></a>1.5.5、ParNew</h3><h4 id=简介-17><a class=headerlink href=#简介-17 title=简介></a>简介</h4><p><strong>ParNew收集器是Serial收集器的多线程版本。</strong><p>ParNew收集器工作于<strong>年轻代</strong>，采用<strong>复制算法</strong>和<strong>Stop-the-World机制</strong>，并采用井行回收的方式执行内存回收。<p>ParNew是大多数JVM运行在Server模式下新生代的默认垃圾回收器。<p><strong>注意事项：JDK8及之前版本，ParNew和Serial Old可以搭配使用，JDK9开始废除了这种搭配。</strong><h4 id=优缺点-3><a class=headerlink href=#优缺点-3 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>单CPU环境下， ParNew 收集器不见得比 Serial 收集器更高效；<li>ParNew收集器可充分利用多核心CPU的优势，可更快速地完成垃圾收集，提升程序吞吐量；</ol><li>缺点</ul><h4 id=参数-5><a class=headerlink href=#参数-5 title=参数></a>参数</h4><ul><li>-XX:+UseParNewGC：使用 ParNew 收集器；<li>-XX:ParallelGCThreads：并发线程数量，默认与CPU数量相同。</ul><h4 id=ParNew-vs-Paraller-Scavenge><a title="ParNew vs Paraller Scavenge" class=headerlink href=#ParNew-vs-Paraller-Scavenge></a>ParNew vs Paraller Scavenge</h4><ol><li>PN响应时间优先，可配合CMS。<li>PS吞吐量优先。</ol><h3 id=1-5-6、CMS（JDK1-4）><a class=headerlink href=#1-5-6、CMS（JDK1-4） title=1.5.6、CMS（JDK1.4）></a>1.5.6、CMS（JDK1.4）</h3><h4 id=1-5-6-1、简介><a class=headerlink href=#1-5-6-1、简介 title=1.5.6.1、简介></a>1.5.6.1、简介</h4><p>CMS（Concurrent Mark Sweep）采用<strong>标记清除算法和STW机制</strong>，它可以确保工作线程和垃圾回收线程同时工作，拥有低延迟等特点。<p><font color=red>注意：HotSpot 中， 除了 CMS收集器外的任何老年代垃圾收集器都会执行Full GC，只有G1收集器较为特殊。</font><p><strong>注意事项：JDK 1.4.2引入CMS，JDK 14中删除了CMS</strong>。<h4 id=1-5-6-2、回收过程><a class=headerlink href=#1-5-6-2、回收过程 title=1.5.6.2、回收过程></a>1.5.6.2、回收过程</h4><p>CMS垃圾回收器的工作过程如下：<p><img alt=image-20240219151141264 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2024/02/19/image-20240219151141264.png><ol><li><strong>初始标记</strong>：<strong>STW</strong>暂停应用线程，<strong>单线程</strong>标记GC Roots能直接关联到的对象，标记完成后，恢复应用程序线程的运行。因直接关联对象比较小，故该阶段<strong>速度很快</strong>。<li><strong>并发标记</strong>：应用线程和垃圾回收线程<strong>同时工作</strong>，垃圾回收线程从GC Roots直接关联的对象开始遍历整个对象图。并发标记过程是应用线程和垃圾回收线程同时工作，故会出现垃圾对象漏标的情况（前一秒还不是垃圾，后一秒就变成了垃圾，反之亦然），此时就需要通过重新标记阶段来尽可能的标记这些漏标的垃圾对象。<li><strong>重新标记</strong>：<strong>STW</strong>停止应用线程，使用<strong>多线程</strong>对起死回生对象、漏标对象 进行重新标记。<li><strong>并发清理</strong>：应用线程和垃圾回收线程<strong>多线程同时工作</strong>，垃圾回收线程清理标记阶段已找出来的垃圾对象。因与应用线程一起执行，故该阶段会产生浮动垃圾。</ol><h4 id=1-5-6-3、优缺点><a class=headerlink href=#1-5-6-3、优缺点 title=1.5.6.3、优缺点></a>1.5.6.3、优缺点</h4><p>CMS优点：<strong>并发收集、低延迟</strong>。<p>CMS存在如下缺点：<ul><li><p><strong>会产生内存碎片</strong>：并发清理后存在内存碎片，可用空间不足会导致提前触发FULL GC。</p><li><p><strong>对CPU资源较敏感</strong>：并发执行占用了一部分的资源导致程序一定程度上变慢，总吞吐量会降低。</p><li><p><strong>无法处理浮动垃圾</strong>：应用线程与垃圾回收线程同时运行，期间可能出现前一秒不是垃圾对象，后一秒成了垃圾对象的现象，这种现象产生的垃圾称为浮动垃圾。并发标记阶段出现的浮动垃圾，可能不会在本次GC过程中被回收。</p></ul><p><font color=red>注意：CMS无法处理时会采用 单线程Serial Old收集器 进行标记压缩，速度会非常慢。</font><h4 id=1-5-6-4、参数><a class=headerlink href=#1-5-6-4、参数 title=1.5.6.4、参数></a>1.5.6.4、参数</h4><ul><li><strong>-XX:+UseConcMarkSweepGC</strong>：使用 CMS 收集器。开启该参数时会自动开启参数-XX:+UserParNewGC，最终的组合就是年轻代使用ParNew，老年代使用CMS和Serial Old。<li><strong>-XX:CMSInitiatingOccupanyFraction</strong>：堆内存使用率达到该阈值会触发垃圾回收。JDK5及之前版本默认值为68，即堆内存使用率达到68%时触发一次垃圾回收。JDK6及之后版本默认值为92。<li><strong>-XX:+UseCMSInitiatingOccupancyOnly</strong>： 只使用设定的回收阈值(-XX:CMSInitiatingOccupanyFraction值)。如果不开启该功能，则JVM仅在第一次使用设定值，后续会自动调整；<li><strong>-XX:+UseCMSCompactAtFullCollection</strong>：执行完Full GC后是否对内存进行压缩，压缩可避免内存碎片但停顿时间会更长。<li><strong>-XX:CMSFullGCsBeforeCompaction</strong>：执行多少次Full GC后对内存进行压缩。<li><strong>-XX:ParallelCMSThreads</strong>：CMS线程数量。默认线程数量为**(ParallelGCThreads + 3) / 4**，</ul><h4 id=1-5-6-5、卡表的使用><a class=headerlink href=#1-5-6-5、卡表的使用 title=1.5.6.5、卡表的使用></a>1.5.6.5、卡表的使用</h4><p>Card Table 在 CMS GC 中有使用，使用一块区域用来记录老年代中的每个 Card 指向新生代的引用（<code>points-out</code> 结构），YGC执行时会将该区域的对象作为 GC roots，而不需要扫描整个老年代。<p>并发标记时，如果某个对象的引用发生了变化，那么标记该对象所在的 Card 为 Dirty Card（通过 write-barrier）。在重新标记时，只需要重新扫描 Dirty Cards 即可，同时清除 Dirty 标记。<h3 id=1-5-7、G1（JDK7）><a class=headerlink href=#1-5-7、G1（JDK7） title=1.5.7、G1（JDK7）></a>1.5.7、G1（JDK7）</h3><h4 id=1-5-7-1、简介><a class=headerlink href=#1-5-7-1、简介 title=1.5.7.1、简介></a>1.5.7.1、简介</h4><p><strong>G1是一款服务器式垃圾回收器，适用于大内存多处理器的服务器。尽可能满足设定的垃圾回收目标，同时提高吞吐量。</strong><p>如果你的应用程序符合以下几点，那么使用G1将变得非常合适：<ul><li>超过50%的堆内存被实时数据占用。<li>对象分配率和晋升率有很大差异。</ul><p>G1有如下特点：<ol><li><strong>并发收集；</strong><li><strong>压缩空闲空间不会延长GC暂停时间</strong>；<li><strong>更易预测的GC暂停时间</strong>；<li><strong>适用于 低吞吐量 场景</strong>；</ol><blockquote><p>JDK 1.7u4中引入G1。<p>JDK9（JEP248）开始，G1成为默认垃圾收集器。<p>JDK12中增强了G1。</blockquote><h4 id=1-8-7-2、Region><a class=headerlink href=#1-8-7-2、Region title=1.8.7.2、Region></a>1.8.7.2、Region</h4><p><strong>G1 会把整个 Java 堆划分为不超过2048个大小独立的Region，每个 Region 大小要满足2的N次幂，范围在1MB-32MB 之间</strong>。Region的大小在 JVM 生命周期内不会被改变。<p>每一个Region在逻辑上属于某一个分代，该分代分为四种：<ol><li><strong>Eden区存放新对象</strong>；<li><strong>Survivor区放存活对象</strong>；<li><strong>old区存放老对象</strong>；<li><strong>Humongoous区存放大对象</strong>；（G1中通常会将H区作为老年代的一部分来看待。）</ol><blockquote><p>G1内存区域不是固定的E或O。G1新老年代比例动态变化无需显式指定，因为G1有预测停顿时间的基准。G1会跟踪每一次STW，据此动态设置各个Region的大小。<p><strong>超过Region一半大小的对象称为大对象</strong>。如果一个H区无法容纳一个大对象，那么会使用连续的H区来存储这个大对象。为了能找到连续的H区，有时不得不执行Full GC。G1不会复制巨型对象，巨型对象没有被引用时会在YGC阶段被回收。</blockquote><h4 id=1-5-7-4、GC回收过程><a class=headerlink href=#1-5-7-4、GC回收过程 title=1.5.7.4、GC回收过程></a>1.5.7.4、GC回收过程</h4><p>G1垃圾回收过程图示如下：<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-1.1-G1-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.png><h5 id=YGC阶段（标记复制-STW）><a title="YGC阶段（标记复制 / STW）" class=headerlink href=#YGC阶段（标记复制-STW）></a>YGC阶段（标记复制 / STW）</h5><p>创建好的对象先放到Eden区，<strong>当所有Eden区都满了，G1会启动一次年轻代垃圾回收</strong>：先停止应用线程（Stop-The-World），然后创建回收集（Collection Set），再将要被回收的内存放到回收集中，最终执行回收操作。<p><font color=red>注意</font>：YGC只会回收Eden区和Survivor区。回收集是指需要被回收的内存分段的集合，年轻代回收集包含年轻代Eden区和Survivor区所有的内存分段。<p>年轻代回收过程如下：<ol><li>根扫描：扫描根对象。根指的是静态变量指向的对象，正在执行的方法链条上的局部变量等。根引用和RSet记录的外部引用将作为扫描存活对象的入口。<li>更新RS：处理Dirty Card队列，更新RS。（RS可以反映老年代中的对象对年轻代对象的引用情况）<li>处理RS：识别老年代对象对Eden区中对象的引用，被指向的Eden区对象都被认为是存活对象。<li>对象拷贝：将Eden中的存活对象复制到Survivor中，Survivor中存活对象复制到其它空闲的Survivor中，且年龄未达阈值则将年龄加1，达到阈值则复制到老年代中。<strong>如果Survivor空间不足，Eden中部分数据会直接晋升至老年代</strong>。<li>处理引用：处理软引用，弱引用，虚引用、Final等引用。最终Eden中空间为空，GC停止，目标内存中对象连续，没有内存碎片，所以复制过程可以达到整理内存的效果。</ol><h5 id=并发标记><a class=headerlink href=#并发标记 title=并发标记></a>并发标记</h5><p><strong>年轻代回收后或 houmongous对象 分配后会检测当前堆内存使用情况，当堆内存（包括老年代和新生代）使用率达到参数<code>-XX:InitiatingHeapOccupancyPercent</code>（默认是45%）设置的百分比时会触发老年代回收。</strong><p><strong>老年代回收过程：垃圾回收线程与应用线程并发执行，垃圾回收线程会标记老年代的存活对象，因与应用程序线程并发执行，故会存在指针引用错误的情况。</strong>G1处理对象丢失的方法是使用 开始时快照技术（SATB，Snapshot At The Begging），这种技术会造成某些垃圾对象也被当做是存活对象，所以G1占用的内存比实际需要的内存要大。<p>并发标记过程如下：<ol><li><p>初始标记（STW）：<strong>STW</strong>停止应用线程，垃圾回收线程标记根节点直接可达的对象。该阶段会触发一次YGC。</p><li><p>根区域扫描：扫描Survivor区直接可达的老年代对象，并标记被引用的对象。<strong>该过程必须在YGC之前完成</strong>。</p><li><p>并发标记：<strong>应用线程与垃圾回收线程并发执行</strong>，垃圾回收线程标记可关联到的对象。<strong>并发标记阶段，若区域中的对象都是垃圾，那么该区域会被立即回收</strong>。同时会计算每个区域对象的活性（区域中存活对象的比例）。要注意的是，<strong>该过程可能被YGC中断</strong>。</p><li><p>再次标记（STW）：<strong>STW</strong>停止应用线程，垃圾回收线程再次标记可能遗漏的垃圾对象。因并发标记阶段中，应用线程和垃圾回收线程并发执行，故会存在漏标的垃圾对象，再次标记阶段就是为了尽可能找出这些漏标的垃圾对象。G1采用SATB（开始时快照技术）算法来尽快尽可能的找到这些漏标的垃圾对象。</p><li><p>独占清除（STW）：<strong>STW</strong>停止应用线程，计算各个区域存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。该阶段不会执行垃圾收集。</p><li><p>并发清理：识别并清理完全空闲的区域。</p></ol><h5 id=混合回收（Mixed-GC）><a title="混合回收（Mixed GC）" class=headerlink href=#混合回收（Mixed-GC）></a>混合回收（Mixed GC）</h5><p><strong>对象晋升到老年代Region后，为避免堆内存被耗尽，会触发一次混合回收（Mixed GC）。</strong>混合回收逻辑：<strong>回收整个年轻代和一部分老年代，至于回收多少老年代region，与设定的垃圾回收时间参数有关</strong>。<p>为满足设定的垃圾回收时间，虚拟机会自动选择或多或少的的老年代进行回收。可以被回收的老年代region，其实在并发标记阶段中的独占清理阶段已经按优先级排序过了，垃圾回收器在回收这些老年代region时，只需根据设定的垃圾回收时间和回收耗时来自动选择回收多少优先级较高的老年代region合适，以至于不超过设定的垃圾回收耗时。<p><strong>并发标记结束以后，老年代中百分百为垃圾的内存被回收了，部分为垃圾的内存也计算了出来。</strong><ul><li>-XX:G1MixedGCCountTarget：该参数表示 老年代内存分段会分多少次来回收，默认8次。<li>-XX:G1MixedGCLiveThresholdPercent：表示垃圾占内存分段比例要达到该参数值设定的百分比时才会被回收，默认为65%。垃圾占内存分段比例越高的，越优先被回收。<strong>老年代、Eden、Survivor from区中要被回收的内存分段合起来称为Collection Set，也即 回收集合</strong>。混合回收集（Collection Set）包括八分之一的老年代内存分段、Eden区内存分段、Survivor区内存分段，下次mixed GC 的evacuation阶段会把他们都一并清理。混合回收的算法和年轻代完全一样，只是回收集多了老年代的内存分段。混合回收并不一定要进行8次。具体执行逻辑与参数<code>-XX:G1HeapWastePercent</code>有关，详情如下。<li>-XX:G1HeapWastePercent：默认为10%，表示允许浪费整个堆内存10%的空间。也就是说 若垃圾占堆内存的比例低于10%，就不再执行混合回收，因为性价比很低。</ul><p><font color=red>注意：Mixed GC 并不是 Full GC。G1 GC回收足够数量的老年代区域 (通过多次混合回收) 后，G1将恢复到年轻代回收、全局并发标记、混合回收，以此逻辑循环执行。</font><h5 id=FGC><a class=headerlink href=#FGC title=FGC></a>FGC</h5><p>G1初衷是避免Full GC出现，但如果G1工作过程中出现问题，不能正常工作时会停止应用程序，使用单线程Serial收集器来完成垃圾清理工作，性能会非常差。<p>导致Full GC的原因有两个：<ul><li><em><strong>Evacuation时没有足够的to-space来存放晋升对象</strong></em>。<li><em><strong>并发处理过程完成之前空间耗尽</strong></em>。</ul><h4 id=1-5-7-5、三色标记算法><a class=headerlink href=#1-5-7-5、三色标记算法 title=1.5.7.5、三色标记算法></a>1.5.7.5、三色标记算法</h4><p>并发标记使用的是三色标记算法。它是描述追踪式回收器的一种有效方法，利用它可以推演回收器的正确性。 三色标记会将对象分成三种类型：<ul><li><strong>黑色</strong>：根对象，或者该对象与它的子对象都被扫描过。<li><strong>灰色</strong>：对象本身已被扫描过，但该对象的子对象还没有扫描。<li><strong>白色</strong>：未扫描过的对象，扫描完所有对象之后，最终为白色的就是不可达对象，即为垃圾对象。</ul><h4 id=1-5-7-8、G1优化><a class=headerlink href=#1-5-7-8、G1优化 title=1.5.7.8、G1优化></a>1.5.7.8、G1优化</h4><p>优化和注意事项分析如下：<ul><li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小。固定年轻代大小会覆盖暂停时间目标。<li>评估G1 GC吞吐量时，暂停时间目标不需要太严格，否则会直接影响吞吐量。</ul><h4 id=1-5-7-9、参数><a class=headerlink href=#1-5-7-9、参数 title=1.5.7.9、参数></a>1.5.7.9、参数</h4><ul><li>-XX:+UseG1GC：使用G1垃圾回收器。<li>-XX:G1HeapRegionSize：每个Region的大小。值是2的幂，范围1m~32m之间。目标是根据最小Java堆大小划分出约2048个区域，默认是堆内存的1/2000。<li>-XX:MaxGCPauseMillis：最大GC停顿时间指标。默认200ms。<li>-XX:ParallelGCThread：STW工作线程的数量，最多8个。<li>-XX:ConcGCThreads：并发标记的线程数量。建议该值为并行垃圾回收线程数量(ParallelGCThreads)的1/4左右。<li>-XX:InitiatingHeapOccupancyPercent：触发并发GC周期的堆占用率阈值。默认是45。</ul><h4 id=1-5-7-10、G1特有功能><a class=headerlink href=#1-5-7-10、G1特有功能 title=1.5.7.10、G1特有功能></a>1.5.7.10、G1特有功能</h4><h5 id=字符串去重><a class=headerlink href=#字符串去重 title=字符串去重></a>字符串去重</h5><p><strong>JDK8u20版本中，G1除了回收垃圾外，对字符串去重做了优化</strong>。G1会把所有新分配的字符串放入一个队列，当G1在回收年轻代时，会检查队列中是否存在重复字符串，如果存在重复的字符串，那么会让它们引用同一个char[]。<p>G1的这种优化与String.intern()不一样。String的intern关注的是字符串对象，而G1字符串去重关注的是char[]，在JVM内部使用了不同的字符串表。<h5 id=类卸载><a class=headerlink href=#类卸载 title=类卸载></a>类卸载</h5><p>并发标记工作执行完后，就可以确定哪些类不再使用。当一个类加载器加载的所有类不再使用时，就会卸载这些类。<p>通过参数<code>-XX:+ClassUnloadingWithConcurrentMark</code>可以开启自动检测类卸载功能。该功能默认开启。<h5 id=回收巨型对象><a class=headerlink href=#回收巨型对象 title=回收巨型对象></a>回收巨型对象</h5><p>对于G1中的巨型对象，G1不会对之进行拷贝，但回收时会被优先考虑。G1会跟踪老年代中对象对巨型对象的引用，当老年代中没有对象引用巨型对象时，<strong>G1会在新生代垃圾回收时处理掉关联的巨型对象</strong>。<h5 id=动态并发标记><a class=headerlink href=#动态并发标记 title=动态并发标记></a>动态并发标记</h5><p><strong>G1中的并发标记过程必须在堆空间被使用完前完成，否则会退化为FGC</strong>。<p>JDK9之前，可以通过参数<code>-XX:InitiatingHeapOccupancyPercent</code>来固定触发并发标记的阈值。该参数表示当所有老年代区占整个堆内存空间的比例达到该参数设置的百分比时就会触发执行并发标记工作。<p>JDK9开始可以实现自动调整这个触发阈值。要注意的是，仍然可以使用该参数设置初始触发阈值，但后期会通过数据采样来动态调整触发阈值。<h3 id=1-5-8、ZGC-（JDK11）><a title="1.5.8、ZGC （JDK11）" class=headerlink href=#1-5-8、ZGC-（JDK11）></a>1.5.8、ZGC （JDK11）</h3><h4 id=1-5-8-1、简介><a class=headerlink href=#1-5-8-1、简介 title=1.5.8.1、简介></a>1.5.8.1、简介</h4><h5 id=概述><a class=headerlink href=#概述 title=概述></a>概述</h5><p><strong>JDK11开始，加入了一款实验性质的可扩展低延迟垃圾收集器，即ZGC。目前仅支持Linux/x86-64。ZGC收集器是一款基于Region内存布局，（暂时）不设分代，使用读屏障、染色指针和内存多重映射等技术来实现可并发的标记整理算法，首要目标是实现低延迟。</strong><p>ZGC旨在实现以下几个目标：<ul><li>暂停时间不超过10毫秒。<li>暂停时间不会随着堆的增大或存活集的变多而增加。<li>可处理几百兆到几TB大小的堆。<li>与使用 G1 相比，应用程序吞吐量降低不超过 15%。<li>利用彩色指针和负载屏障为未来的GC功能和优化奠定基础。</ul><blockquote><p>JDK11环境下，使用ZGC需要两个参数：<code>-XX:+UnlockExperimentalVMOptions</code>和<code>-XX:+UseZGC</code>结合使用。该版本的ZGC存在如下一些限制：<ul><li>仅在linux/x64上可用。<li>不支持使用压缩的 oops 和/或压缩的类点。默认情况下， <code>-XX:+UseCompressedOops</code> 和 <code>-XX:+UseCompressedClassPointers</code> 选项处于禁用状态。启用它们将不起作用。<li>不支持类卸载。默认情况下， <code>-XX:+ClassUnloading</code> 和 <code>-XX:+ClassUnloadingWithConcurrentMark</code> 选项处于禁用状态。启用它们将不起作用。<li>不支持将 ZGC 与 Graal 结合使用。</ul><p>JDK11（JEP333）中引入ZGC。JDK13中增强ZGC。<p>JDK14（JEP364）提供了支持macOS系统的实验版ZGC，JDK14（JEP365）提供了支持Windows系统的实验版ZGC。<p>JDK15（JEP377）开始，ZGC可用于生产环境，直接使用一个参数<code>XX:+UseZGC</code>就可以使用ZGC。此JEP不建议更改默认GC，它仍然是G1。<p>JDK21（JEP439）提出了分代ZGC，且计划后期会作为默认配置。</blockquote><h5 id=分代ZGC><a class=headerlink href=#分代ZGC title=分代ZGC></a>分代ZGC</h5><p><strong>JDK21（JEP439）提出了分代ZGC，且计划后期会作为默认配置</strong>。分代ZGC可降低分配停滞的风险、降低堆内存开销、降低垃圾回收CPU开销。除此外，不需要手动配置分代大小、垃圾回收线程数量、对象在年轻代的存活时长。要使用分代ZGC，需要使用两个参数<code>-XX:+UseZGC</code>和<code>-XX:+ZGenerational</code>。<p>分代 ZGC 将堆分为两个逻辑代：年轻一代用于最近分配的对象，而老一代用于长期存在的对象。每一代都是独立收集的，因此ZGC可以专注于收集有利可图的年轻对象。<p>非分代 ZGC 同时使用彩色指针和负载屏障。分代 ZGC 还使用存储屏障来有效地跟踪从一代对象到另一代对象的引用。<h4 id=1-5-8-2、内存布局><a class=headerlink href=#1-5-8-2、内存布局 title=1.5.8.2、内存布局></a>1.5.8.2、内存布局</h4><p><strong>ZGC采用了与G1类似的Region堆内存布局，但ZGC中的称为ZPage，ZPage具有动态性（动态的创建和销毁，以及动态的区域容量大小）</strong>。<p>ZGC的Region可以分为三类：<ul><li>小型Region：容量固定为2MB，用于放置小于256KB的小对象。<li>中型Region：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。<li>大型Region：容量不固定，可以动态变化，但必须为2MB的整数倍，用于存放4MB或以上的大对象。并且<strong>每个大型Region只会存放一个对象</strong>。</ul><h4 id=1-5-8-3、染色指针><a class=headerlink href=#1-5-8-3、染色指针 title=1.5.8.3、染色指针></a>1.5.8.3、染色指针</h4><h5 id=简介-18><a class=headerlink href=#简介-18 title=简介></a>简介</h5><p>HotSpot的垃圾收集器，有几种不同的标记实现方案。<ul><li>把标记直接记录在对象头上（Serial 收集器）。<li>把标记记录在与对象相互独立的数据结构上（G1、Shenandoah使用了一种相当于堆内存的1/64大小的BitMap结构来记录标记信息）。<li><strong>ZGC染色指针直接把标记信息记录到引用对象的指针上</strong>。</ul><p>染色指针是一种直接<strong>将少量额外信息存储在指针上的技术</strong>。目前Linux下64位指针的高18位暂不使用，低42位用来寻址4T空间，43、44、45、46位用来标记对象的不同状态。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/ZGC%E9%A2%9C%E8%89%B2%E6%8C%87%E9%92%8801.png><p>ZGC将使用剩下46位的高4位来存储四个标志信息：<ol><li>Marked0：对象被标记为存活对象，并涂抹一种颜色。<li>Marked1：对象被标记为存活对象，涂抹另一种颜色，用于区分不同的垃圾回收周期。<li>Remapped：是否进入了重分配集。<li>Finalizable：是否只能通过finalize()方法才能被访问到。</ol><p><font color=red>注意：标志位占用4位，剩余42位可寻址4TB内存空间，所以ZGC能够管理的内存不能超过4TB。</font><h5 id=特点-1><a class=headerlink href=#特点-1 title=特点></a>特点</h5><ul><li><strong>染色指针可以确保某个Region的存活对象被移走之后，该Region会立即被释放和重用掉</strong>，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。<li><strong>染色指针可以减少在垃圾收集过程中内存屏障的使用数量</strong>。因为读、写内存屏障的主要目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。<li>染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</ul><h4 id=1-5-8-4、读屏障><a class=headerlink href=#1-5-8-4、读屏障 title=1.5.8.4、读屏障></a>1.5.8.4、读屏障</h4><p><strong>当从堆中加载对象时，就会使用读屏障（Load Barrier）</strong>。读屏障的主要作用就是<strong>检查指针上的三色标记位，根据标记位判断出对象是否被移动过，如果没有则可以直接访问，如果移动过就需要进行“自愈”</strong>。自愈会使对象访问变慢，但“自愈”完成后访问就会变快。<blockquote><p>当读取处于重分配集的对象时，会被读屏障拦截，通过 转发表记录 将访问转发到新复制对象上，并同时修正更新该引用的值，使其直接指向新对象。ZGC将这种行为叫做指针的“自愈能力”。</blockquote><h4 id=1-5-8-5、内存多重映射><a class=headerlink href=#1-5-8-5、内存多重映射 title=1.5.8.5、内存多重映射></a>1.5.8.5、内存多重映射</h4><h5 id=简介-19><a class=headerlink href=#简介-19 title=简介></a>简介</h5><p><strong>Linux/x86-64平台上ZGC使用了多重映射（Multi-Mapping），将多个不同的虚拟内存地址映射到同一物理内存地址上，这是一种多对一映射，意味着ZGC在虚拟内存中看到的地址空间要比实际的堆内存容量更大</strong>。把染色指针中的标志位看作是地址的分段符，那只要将这些不同的地址段都映射到同一物理内存空间，经过多重映射转换后，就可以使用染色指针进行正常寻址。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/ZGC%E5%86%85%E5%AD%98%E5%A4%9A%E9%87%8D%E6%98%A0%E5%B0%8401.png><h4 id=1-5-8-6、ZGC工作过程><a class=headerlink href=#1-5-8-6、ZGC工作过程 title=1.5.8.6、ZGC工作过程></a>1.5.8.6、ZGC工作过程</h4><p>ZGC工作过程大致可划分为以下四个阶段。四个阶段都可以并发执行，只不过两个阶段中间会存在短暂的小阶段停顿。<p><img alt=ZGC运行过程 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/ZGC%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B01><ol><li>并发标记（Concurrent Mark）：与G1、Shenandoah一样，<strong>并发标记是遍历对象图做可达性分析的阶段</strong>，前后也要经过类似于G1、Shenandoah的初始标记、最终标记的短暂停顿，而且这些停顿阶段所做的事情在目标上也是类似的。<li>并发预备重分配（ Concurrent Prepare for Relocate）：根据特定查询条件统计<strong>得到本次收集过程要清理的Region，并将这些Region组成重分配集（Relocation Set）</strong>。<li>并发重分配（Concurrent Relocate）：重分配是核心阶段，这个过程<strong>会把重分配集中的存活对象复制到新Region上，并为重分配集中的每个Region维护一个转发表（Forward Table）,记录从旧对象到新对象的转向关系</strong>。<li>并发重映射（Concurrent Remap）：<strong>重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用</strong>，并发映射并不是一个必须要“迫切”去完成的任务。ZGC会巧妙地把该阶段要做的工作合并到下一次垃圾收集循环中的并发标记阶段中去完成，反正都要遍历所有对象，这样合并后反而节省了一次遍历开销。</ol><h4 id=1-5-8-7、ZGC优缺点><a class=headerlink href=#1-5-8-7、ZGC优缺点 title=1.5.8.7、ZGC优缺点></a>1.5.8.7、ZGC优缺点</h4><h5 id=优点（高吞吐量、低延迟）><a class=headerlink href=#优点（高吞吐量、低延迟） title=优点（高吞吐量、低延迟）></a>优点（高吞吐量、低延迟）</h5><p><strong>ZGC支持<code>NUMA-Aware</code>内存分配</strong>。NUMA（Non-Uniform Memory Access，非统一内存访问架构）是一种多处理器或多核处理器计算机所设计的内存架构。<p>现在多CPU插槽的服务器都是Numa架构，比如两颗CPU插槽(24核)，64G内存的服务器，那一颗CPU 12个核，访问从属于它的32G本地内存，要比访问另外32G远端内存要快得多。<p>ZGC默认支持NUMA架构，在创建对象时，根据当前线程在哪个CPU执行，优先在靠近这个CPU的内存进行分配，这样可以显著的提高性能，在SPEC JBB 2005 基准测试里获得40%的提升。<h5 id=缺点（浮动垃圾）><a class=headerlink href=#缺点（浮动垃圾） title=缺点（浮动垃圾）></a>缺点（浮动垃圾）</h5><p>当ZGC准备要对一个很大的堆做一次完整的并发收集，则全过程要持续十分钟以上，由于应用的对象分配速率很高，将创造大量的新对象，这些新对象很难进入当次收集的标记范围，通常就只能全部作为存活对象来看待（尽管其中绝大部分对象都是朝生夕灭），这就<strong>产生了大量的浮动垃圾</strong>。<p>目前唯一的办法就是尽可能地去增加堆容量大小，获取更多喘息的时间。但若要从根本上解决，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后针对这个区域进行更频繁、更快的收集。<strong>庆幸的是，JDK21中提出了ZGC的分代垃圾收集</strong>。<h3 id=1-5-9、Epsilon（JDK11）><a class=headerlink href=#1-5-9、Epsilon（JDK11） title=1.5.9、Epsilon（JDK11）></a>1.5.9、Epsilon（JDK11）</h3><h4 id=1-5-9-1、简介><a class=headerlink href=#1-5-9-1、简介 title=1.5.9.1、简介></a>1.5.9.1、简介</h4><p>JDK 11中的JEP 318添加了一个名为Epsilon的垃圾回收器。<strong>Epsilon（A No-Op Garbage Collector）只负责分配内存不做任何垃圾回收操作</strong>。当堆内存空闲空间不足时会自动触发与<code>OutOfMemoryError</code>相关的处理。<h4 id=1-5-9-2、目标><a class=headerlink href=#1-5-9-2、目标 title=1.5.9.2、目标></a>1.5.9.2、目标</h4><p>Epsilon回收器设计目的或初衷：<ol><li>性能测试：测试应用在没有GC干预情况下的性能。<li>短生命周期应用：对于生命周期较短的应用，没有垃圾回收也是可以接受的。<li>内存管理：自己来管理内存。</ol><h4 id=1-5-9-3、使用场景><a class=headerlink href=#1-5-9-3、使用场景 title=1.5.9.3、使用场景></a>1.5.9.3、使用场景</h4><ul><li>Performance testing：什么都不执行的GC非常适合用于差异性分析。no-op GC可以用于过滤掉GC诱发的新能损耗，比如GC线程的调度，GC屏障的消耗，GC周期的不合适触发，内存位置变化等。此外有些延迟者不是由于GC引起的，比如scheduling hiccups, compiler transition hiccups，所以去除GC引发的延迟有助于统计这些延迟。<li>Memory pressure testing：在测试java代码时，确定分配内存的阈值有助于设置内存压力常量值。这时no-op就很有用，它可以简单地接受一个分配的内存分配上限，当内存超限时就失败。例如：测试需要分配小于1G的内存，就使用-Xmx1g参数来配置no-op GC，然后当内存耗尽的时候就直接crash。<li>VM interface testing：以VM开发视角，有一个简单的GC实现，有助于理解VM-GC的最小接口实现。它也用于证明VM-GC接口的健全性。<li>Extremely short lived jobs： 一个短声明周期的工作可能会依赖快速退出来释放资源，这个时候接收GC周期来清理heap其实是在浪费时间，因为heap会在退出时清理。并且GC周期可能会占用一会时间，因为它依赖heap上的数据量。<li>Last-drop latency improvements：对那些极端延迟敏感的应用，开发者十分清楚内存占用，或者是几乎没有垃圾回收的应用，此时耗时较长的GC周期将会是一件坏事。<li>Last-drop throughput improvements：即便对那些无需内存分配的工作，选择一个GC意味着选择了一系列的GC屏障，所有的OpenJDK GC都是分代的，所以他们至少会有一个写屏障。避免这些屏障可以带来一点点的吞吐量提升。</ul><h4 id=1-5-9-4、相关描述><a class=headerlink href=#1-5-9-4、相关描述 title=1.5.9.4、相关描述></a>1.5.9.4、相关描述</h4><p>通过参数<code>-XX:+UseEpsilonGC</code>可以开启Epsilon GC。<p>Epsilon GC通过在分配内存的单个连续块中实现线性分配来工作。这样就可以在GC中轻松实现无锁TLAB（线程本地分配缓冲区）发行代码，然后可以重用现有VM代码处理的无锁TLAB内部分配。发出TLAB还有助于使驻留内存占用的进程受实际分配的内存限制。大量/超出TLAB的分配由同一代码处理，因为在此方案中分配TLAB与分配大对象之间几乎没有区别。<p>Epsilon使用的障碍集完全为空/无操作，因为GC不执行任何GC循环，因此不关心对象图，对象标记，对象复制等。引入一种新的障碍集实现是可能是此实现中最具破坏性的JVM更改。<p>由于Epsilon的运行时接口的唯一重要部分是发布TLAB的时间，因此其延迟很大程度上取决于所发布的TLAB的大小。对于任意大的TLAB和任意大的堆，延迟开销可以由任意低的正值（因此称为名称）来描述。（替代起源故事：“ epsilon”通常表示“空符号”，与该GC的禁止操作性保持一致）。<p>Java堆耗尽就不可能进行分配，也不能进行内存回收。此时有几种选择：<ul><li>抛出一条带有描述性信息的<code>OutOfMemoryError</code>异常消息。<li>执行堆转储（启用<code>-XX:+HeapDumpOnOutOfMemoryError</code>）<li>关闭JVM，并有选择地执行外部操作（通常操作<code>-XX:OnOutOfMemoryError=...</code>），例如，启动调试器或向外部监视系统通知该失败。</ul><h3 id=1-5-10、Shenandoah><a class=headerlink href=#1-5-10、Shenandoah title=1.5.10、Shenandoah></a>1.5.10、Shenandoah</h3><p>待补充。<h3 id=1-5-11、总结><a class=headerlink href=#1-5-11、总结 title=1.5.11、总结></a>1.5.11、总结</h3><h4 id=1-5-11-1、垃圾收集器对比><a class=headerlink href=#1-5-11-1、垃圾收集器对比 title=1.5.11.1、垃圾收集器对比></a>1.5.11.1、垃圾收集器对比</h4><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-1.2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93.png><p><img alt=image-20210315120311771 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210315120311771.png><h4 id=1-5-11-2、注意事项><a class=headerlink href=#1-5-11-2、注意事项 title=1.5.11.2、注意事项></a>1.5.11.2、注意事项</h4><p>JEP173（JDK8）开始，不推荐使用的垃圾回收器组合：DefNew+CMS、ParNew+Serial Old、Incremental CMS。<p>JEP214（JDK9）中删除了JEP173中就已经不推荐的垃圾回收器组合，推荐使用ParallelScavenge+Serial Old组合。<p>JEP248（JDK9）中，将G1设为32位和64位服务器环境下的默认垃圾回收器。<p>JEP291（JDK9）中宣布弃用CMS垃圾回收器。JEP363（JDK14）中删除了CMS垃圾回收器。<p>JEP318（JDK11）中提出了<strong>实验性质</strong>的无操作垃圾回收器<strong>Epsilon</strong>。<p>JEP333（JDK11）中提出了<strong>实现性质</strong>的可扩展低延迟垃圾回收器<strong>ZGC</strong>。JDK14（JEP364）提供了支持macOS系统的实验版ZGC，JDK14（JEP365）提供了支持Windows系统的实验版ZGC。<h2 id=1-6、漏标问题><a class=headerlink href=#1-6、漏标问题 title=1.6、漏标问题></a>1.6、漏标问题</h2><h3 id=1-9-1、认识漏标><a class=headerlink href=#1-9-1、认识漏标 title=1.9.1、认识漏标></a>1.9.1、认识漏标</h3><p>CMS和G1的核心就是垃圾回收线程和应用线程同时执行，而该阶段会产生“漏标”问题。<p>问题：<strong>GC标记阶段中如果删除了所有灰色到白色的引用，且黑色指向了白色，则此时不对黑色对象的子对象进行重新扫描，就会出现漏标现象，会把白色对象当作垃圾被回收</strong>。<h3 id=1-9-2、解决漏标><a class=headerlink href=#1-9-2、解决漏标 title=1.9.2、解决漏标></a>1.9.2、解决漏标</h3><p><strong>（1）增量更新（Increment Update）</strong><p><img alt=image-20210314213906184 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210314213906184.png><p>如上图所示，若A指向D时，跟踪这个引用，并把A标记为灰色，下次扫描时就会重新扫描A的子对象D，这就叫做增量更新。<p>特点：<strong>当产生新标记后，关注引用的增加，CMS采用 增量更新+写屏障 解决了漏标问题</strong>。<p><strong>（2）SATB（snapshot at the beginning）</strong><p><img alt=image-20210314214048813 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210314214048813.png><p>如上图所示，刚开始做一个快照，当B和D之间的引用消失时要把这个引用推到GC的堆栈，保证D能够被扫描到。如果某一个引用消失了，会把白色对象放到GC堆栈中，下次扫描时直接扫描白色对象即可，这样白色就不会漏标了。<p>SATB有三个工作步骤：<ol><li>在开始标记时生成一个快照图，用来标记存活对象。<li>在并发标记时所有被改变的对象将会被加入到队列（在write barrier里把所有旧的引用所指向的对象都变成非白的）。<li>可能存在游离垃圾，将在下次被收集。</ol><p>特点：<strong>当引用被删除后，关注引用的删除，G1用 SATB+写屏障 解决了漏标问题</strong>。<blockquote><p>SATB 算法通过创建一个对象图的方式完成堆内存逻辑上的快照，即将堆内存里所有需要回收的对象全部呈现在它的这张对象图上，这个标记过程在并行标记阶段完成 。<p>SATB 算法维护的标记内容在数据结构上也分为两块， 一块是已经完成的标记，另一块是即将进行的标记。</blockquote><h3 id=1-9-3、总结><a class=headerlink href=#1-9-3、总结 title=1.9.3、总结></a>1.9.3、总结</h3><p>灰色指向白色的引用消失时，如果没有黑色指向白色，则该引用会直接被push到堆栈，下次扫描时，由于RSet的存在，不需要扫描整个堆去查找指向白色的引用，效率比较高。<blockquote><p>G1为什么使用SATB而不使用incremental update？因为如果使用增量更新，那么变成灰色后还要重新扫描，效率太低。</blockquote><h1 id=2、JVM参数><a class=headerlink href=#2、JVM参数 title=2、JVM参数></a>2、JVM参数</h1><h2 id=2-1、简介><a class=headerlink href=#2-1、简介 title=2.1、简介></a>2.1、简介</h2><h3 id=2-1-1、参数分类><a class=headerlink href=#2-1-1、参数分类 title=2.1.1、参数分类></a>2.1.1、参数分类</h3><ul><li><strong>-开头</strong>：标准类型，所有HotSpot都支持。<li><strong>-X开头</strong>：非标准类型，特定版本才支持。<li><strong>-XX开头</strong>：运行时选项，控制虚拟机的运行时行为。下个版本可能取消。<ol><li><strong>Boolean类型参数</strong>：-XX:+/- 某个属性值（+表示开启，-表示关闭）。<li><strong>K-V类型参数</strong>：-XX: key（属性）= value（属性值）</ol></ul><p>通过命令<code>jinfo -flag 配置项 进程号</code>可查看当前运行环境的配置项。<blockquote><p>如何解释-Xms和-Xmx参数属于-XX参数？<p>-Xms = -XX:InitialHeapSize=size / -Xmx = -XX:MaxHeapSize=size</blockquote><h3 id=2-1-2、查看参数值><a class=headerlink href=#2-1-2、查看参数值 title=2.1.2、查看参数值></a>2.1.2、查看参数值</h3><p><strong>（1）查看java进程相关参数</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>jinfo -flag 参数项 进程号</span><br><span class=line>jinfo -flags 进程号</span><br></pre></table></figure><p><strong>（2）查看默认值和最终值</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>java -XX:+PrintFlagsInitial   <span class=comment># 查看jvm未更改的默认参数</span></span><br><span class=line>java -XX:+PrintFlagsFinal     <span class=comment># 查看jvm已经更改过的参数</span></span><br></pre></table></figure><p>也可以在运行java命令的同时加入jvm参数，如：<code>java -XX:+PrintFlagsFinal UpdateJVMParamDemo</code><p><font color=red>注意：<code>:=</code>表示jvm启动时修改过的参数。<code>=</code>表示jvm没有更改过的默认参数。</font><p><strong>（3）打印命令行参数</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -XX:+PrintCommandLineFlags</span><br></pre></table></figure><p><strong>（4）查看可以被修改的参数</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -XX:+PrintFlagsFinal -version | grep manageable</span><br></pre></table></figure><h2 id=2-2、系统优化参数><a class=headerlink href=#2-2、系统优化参数 title=2.2、系统优化参数></a>2.2、系统优化参数</h2><ul><li><strong>-XX:-UseCompressedOops</strong>：禁用压缩指针。默认启用，当 Java 堆内存小于 32 GB 时将使用压缩指针。启用此选项后，对象引用表示为 32 位偏移量而不是 64 位指针。此选项仅适用于 64 位 JVM。当 Java 堆内存大于 32GB 时，也可以使用压缩指针。查看<code>-XX:ObjectAlignmentInBytes</code>选项。<li><strong>-XX:+Inline</strong>：启用方法内联。默认开启。要禁用方法内联，请指定<code>-XX:-Inline</code>。<li><strong>-XX:InlineSmallCode=大小</strong>：设置触发内联功能的已编译方法的代码大小（以字节为单位）。只有已编译代码小于指定大小时才会被内联。默认最大代码大小设置为 1000 字节：-XX:InlineSmallCode=1000。<li><strong>-XX:MaxInlineSize=大小</strong>：设置要内联的方法的最大字节码大小（以字节为单位）。默认最大字节码大小为 35 个字节：<code>-XX:MaxInlineSize=35</code>。<li><strong>-XX:MaxTrivialSize=大小</strong>：设置要内联的普通方法的最大字节码大小（以字节为单位）。默认普通方法的最大字节码大小为 6 个字节：<code>-XX:MaxTrivialSize=6</code>。<li><strong>-XX:+PrintInlining</strong>：启用内联决策打印，可以查看哪些方法正在被内联。默认禁用且不打印内联信息。参数<code>-XX:+PrintInlining</code>必须与参数<code>-XX:+UnlockDiagnosticVMOptions</code>一起使用。<li><strong>-XX:+OptimizeStringConcat</strong>：启用<code>String</code>连接优化。默认启用。要禁用<code>String</code>串联优化，请指定<code>-XX:-OptimizeStringConcat</code>。只有 Java HotSpot Server VM 支持此选项。<li><strong>-XX:+UseStringDeduplication</strong>：启用字符串重复数据删除。默认禁用。要想启用该功能就必须启用G1 垃圾收集器。</ul><h2 id=2-3、类加载参数><a class=headerlink href=#2-3、类加载参数 title=2.3、类加载参数></a>2.3、类加载参数</h2><ul><li><p><strong>-XX:+TraceClassLoading</strong>：启用类加载跟踪。</p><li><p><strong>-XX:+TraceClassLoadingPreorder</strong>：启用按引用顺序跟踪所有加载类。默认禁用且不跟踪。</p><li><p><strong>-XX:+TraceClassUnloading</strong>：启用类卸载跟踪。默认禁用且不跟踪。</p><li><p><strong>-XX:CICompilerCount=线程</strong>：设置用于编译的编译器线程数。默认线程数为 2，客户端线程数为 1，如果使用分层编译，它会扩展到内核数。</p><li><p><strong>-XX:CodeCacheMinimumFreeSpace=大小</strong>：编译所需最小空间（以字节为单位）。当剩余空间小于最小可用空间时将停止编译。默认空间大小为 500 KB。</p><li><p><strong>-XX:CompileOnly=方法</strong>：设置限制编译的方法列表（以逗号分隔）。</p> <figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-XX:CompileOnly=java/lang/String.length,java/util/List.size</span><br></pre></table></figure><li><p><strong>-XX:CompileThreshold=调用</strong>：设置 编译前解释方法次数。默认情况下，在服务器 JVM 中，JIT 编译器执行 10,000 次解释方法调用来收集信息以进行高效编译。对于客户端 JVM，默认为 1,500 次调用。启用分层编译时将忽略此选项；见选项<code>-XX:+TieredCompilation</code>。</p><li><p><strong>-XX:+BackgroundCompilation</strong>：启用后台编译。默认启用。要禁用后台编译，请指定<code>-XX:-BackgroundCompilation</code>（这等效于指定<code>-Xbatch</code>）。</p><li><p><strong>-XX:MaxNodeLimit=节点</strong>：设置单个方法编译期间要使用的最大节点数。默认情况下，最大节点数设置为 65,000：<code>-XX:MaxNodeLimit=65000</code>。</p><li><p><strong>-XX:+PrintCompilation</strong>：通过在每次编译方法时将消息打印到控制台来启用来自 JVM 的详细诊断输出。这可以查看实际编译了哪些方法。默认禁用该功能且不打印诊断输出。同时可以通过指定参数<code>-XX:+LogCompilation</code>将编译活动记录到文件中。</p><li><p><strong>-XX:ReservedCodeCacheSize=大小</strong>：设置 JIT 编译代码的最大代码缓存大小（以字节为单位）。默认最大代码缓存为 240 MB；如果指定参数<code>-XX:-TieredCompilation</code>禁用了分层编译，则默认大小为 48 MB。该参数最大限制为 2 GB，否则报错。最大代码缓存不应小于初始代码缓存；见选项<code>-XX:InitialCodeCacheSize</code>。此选项等效于<code>-Xmaxjitcodesize</code>。</p><li><p><strong>-XX:-TieredCompilation</strong>：禁用分层编译。默认启用。只有 Java HotSpot Server VM 支持此选项。</p></ul><h2 id=2-4、运行时数据区参数><a class=headerlink href=#2-4、运行时数据区参数 title=2.4、运行时数据区参数></a>2.4、运行时数据区参数</h2><h3 id=2-4-1、堆（Heap）><a class=headerlink href=#2-4-1、堆（Heap） title=2.4.1、堆（Heap）></a>2.4.1、堆（Heap）</h3><h4 id=基本参数><a class=headerlink href=#基本参数 title=基本参数></a>基本参数</h4><ul><li><strong>-Xms / -XX:InitialHeapSize=大小</strong>：堆内存最小值和初始大小。此值必须是 1024 的倍数且大于 1 MB。<li><strong>-Xmx / -XX:MaxHeapSize=大小</strong>：堆内存最大值（以字节为单位）。此值必须是 1024 的倍数且大于 2 MB。通常将<code>-Xms</code>并<code>-Xmx</code>设为相同值。<li><strong>-XX:+AggressiveHeap</strong>：启用 Java 堆优化。根据计算机配置（RAM 和 CPU）自动设置合适的参数值。默认禁用。<li><strong>-XX:NewRatio=比率</strong>：设置年轻代和年老代大小比例。默认为 2。<li><strong>-XX:+UseAdaptiveSizePolicy</strong>：启用自适应大小调整。默认启用。要禁用请指定参数<code>-XX:-UseAdaptiveSizePolicy</code>和 设置内存分配池的大小（请参阅<code>-XX:SurvivorRatio</code>选项）。<li><strong>-XX:InitialRAMPercentage=percent</strong>：将用于 Java 堆的初始内存量设置为 -XX:MaxRAM 选项中所述确定的最大内存量的百分比。默认值为 1.5625%。<li><strong>-XX:MaxRAMPercentage=百分比</strong>：Java 堆的最大内存量，设置为 -XX:MaxRAM 选项中所述确定的最大内存量的百分比。默认值为 25%。</ul><h4 id=年轻代><a class=headerlink href=#年轻代 title=年轻代></a>年轻代</h4><ul><li><strong>-XX:NewSize</strong>：年轻代初始大小。<li><strong>-XX:MaxNewSize</strong>：年轻代最大内存大小。<li><strong>-Xmn</strong>：年轻代 初始大小 和 最大大小。官方建议 年轻代大小 应在 整堆大小的四分之一到二分之一之间。<li><strong>-XX:SurvivorRatio</strong>：新生代中 Eden区 与 Survivor区 的占用比例，默认为8，意为eden区大小占年轻代的8/10，而survivor from区和to区各占1/10；<li><strong>-XX:+UseTLAB</strong>：在年轻代中使用TLAB。默认启用。要禁用 TLAB，请指定<code>-XX:-UseTLAB</code>。<li><strong>-XX:TLABSize=大小</strong>：TLAB 初始大小（以字节为单位）。参数值为 0 时表示自动选择初始大小。<li><strong>-XX:TargetSurvivorRatio=百分比</strong>：YGC后的幸存区（Surivivor区）使用占比。默认为 50%。</ul><h4 id=老年代><a class=headerlink href=#老年代 title=老年代></a>老年代</h4><h3 id=2-4-2、方法区（MethodArea）><a class=headerlink href=#2-4-2、方法区（MethodArea） title=2.4.2、方法区（MethodArea）></a>2.4.2、方法区（MethodArea）</h3><h4 id=永久代（JDK7及以前版本）><a class=headerlink href=#永久代（JDK7及以前版本） title=永久代（JDK7及以前版本）></a>永久代（JDK7及以前版本）</h4><ul><li><strong>-XX:PermSize=size</strong>：设置永久代初始大小（字节单位）,超过该大小，则触发垃圾回收。<li><strong>-XX:MaxPermSize=size</strong>：设置永久代最大容量。</ul><h4 id=元空间（JDK8及以后版本）><a class=headerlink href=#元空间（JDK8及以后版本） title=元空间（JDK8及以后版本）></a>元空间（JDK8及以后版本）</h4><ul><li><strong>-XX:MetaspaceSize=size</strong>：设置类元数据空间大小，该空间将在第一次超出时触发垃圾回收。根据使用的元数据量增加或减少垃圾收集的阈值。默认大小取决于平台。<li><strong>-XX:MaxMetaspaceSize=size</strong>：设置 类元数据 最大本机内存量。默认大小不受限制。<li><strong>-XX:+/-UseCompressedOops</strong>：开启或关闭对象指针压缩功能，默认开启。当 Java 堆大小小于 32 GB 时，将使用压缩指针。启用此选项后，对象引用将表示为 32 位偏移量，而不是 64 位指针。该参数选项只适用于64位的JVM。<li>-XX:+UseCompressedClassPointers：压缩类型指针。<li>-XX:CompressedClassSpaceSize：设置Klass Metaspace的大小，默认1G。</ul><h3 id=2-4-3、操作数栈（OperandStack）><a class=headerlink href=#2-4-3、操作数栈（OperandStack） title=2.4.3、操作数栈（OperandStack）></a>2.4.3、操作数栈（OperandStack）</h3><ul><li><strong>-Xss</strong>：设置线程栈大小（以字节为单位）等价于<code>-XX:ThreadStackSize=大小</code>。默认值取决于平台。<li><strong>-XX:+DoEscapeAnalysis</strong>：启用逃逸分析。默认启用。要禁用请指定<code>-XX:-DoEscapeAnalysis</code>。只有 Java HotSpot Server VM 支持此选项。</ul><h3 id=2-4-4、本地方法栈（LocalMethodStack）><a class=headerlink href=#2-4-4、本地方法栈（LocalMethodStack） title=2.4.4、本地方法栈（LocalMethodStack）></a>2.4.4、本地方法栈（LocalMethodStack）</h3><h3 id=2-4-5、程序计数器（ProgramRegister）><a class=headerlink href=#2-4-5、程序计数器（ProgramRegister） title=2.4.5、程序计数器（ProgramRegister）></a>2.4.5、程序计数器（ProgramRegister）</h3><h3 id=2-4-6、直接内存（DirectMemory）><a class=headerlink href=#2-4-6、直接内存（DirectMemory） title=2.4.6、直接内存（DirectMemory）></a>2.4.6、直接内存（DirectMemory）</h3><ul><li><strong>-XX:MaxDirectMemorySize=size</strong>：设置新 I/O（<code>java.nio</code>包）直接缓冲区分配的最大值（以字节为单位）。默认为 0，表示 JVM 会自动选择 NIO 直接缓冲区大小。</ul><h3 id=2-4-7、其它><a class=headerlink href=#2-4-7、其它 title=2.4.7、其它></a>2.4.7、其它</h3><ul><li><strong>-XX:ObjectAlignmentInBytes=对齐</strong>：设置 Java 对象的内存对齐（以字节为单位）。默认为 8 个字节。指定的值应该是 2 的幂，且必须在 8 到 256（含）范围内。堆大小限制（以字节为单位）的计算公式为：<code>4GB * ObjectAlignmentInBytes</code>。<li><strong>-XX:+PrintCommandLineFlags</strong>：启用打印当前JVM参数选项信息的功能。默认禁用。<li><strong>-XX:InitialCodeCacheSize=大小</strong>：设置 初始代码缓存大小（以字节为单位）。JDK17以前默认为 500 KB，JDK17及以后其默认值取决于平台。初始代码缓存大小应不小于系统的最小内存页大小。</ul><h2 id=2-5、垃圾回收参数><a class=headerlink href=#2-5、垃圾回收参数 title=2.5、垃圾回收参数></a>2.5、垃圾回收参数</h2><h3 id=2-5-1、基本参数><a class=headerlink href=#2-5-1、基本参数 title=2.5.1、基本参数></a>2.5.1、基本参数</h3><ul><li><p><strong>-Xnoclassgc</strong>：禁用类的垃圾回收 (GC)。</p><li><p><strong>-XX:ErrorFile=filename</strong>：发生错误时 将 错误数据 写入指定文件。文件默认在当前目录且命名为 hs_err_pid pid.log，其中 pid 是导致错误的进程标识符。</p><li><p><strong>-XX:+HeapDumpOnOutOfMemoryError</strong>：出现OOM异常时将错误信息导出到指定文件。可使用参数<code>-XX:HeapDumpPath</code>设置文件路径和名称。默认情况下，此选项处于禁用状态，并且在引发 <code>OutOfMemoryError</code> 异常时不会转储堆。</p><li><p><strong>-XX:HeapDumpPath=路径</strong>：设置该<code>-XX:+HeapDumpOnOutOfMemoryError</code>选项时，设置用于写入堆分析器 (HPROF) 提供的堆转储的路径和文件名。默认情况下，该文件在当前工作目录中创建，并命名为<code>java_pid</code><em>pid</em><code>.hprof</code>，其中 pid 是导致错误的进程标识符。以下示例设置默认文件（<code>%p</code>代表当前进程标识符）：</p> <figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>-XX:HeapDumpPath=./java_pid%p.hprof</span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>例如，将堆转储文件保存在/var/log/java/java_heapdump.hprof</span></span><br><span class=line>-XX:HeapDumpPath=/var/log/java/java_heapdump.hprof</span><br></pre></table></figure><li><p><strong>-XX:ActiveProcessorCount= x</strong>：覆盖 VM 用于计算其用于各种操作（例如垃圾收集和 ForkJoinPool）的线程池大小的 CPU 数量。</p><li><p><strong>-XX:MaxHeapFreeRatio=百分比</strong>：设置 GC后堆最大空闲空间占比（0 到 100）。如果GC后空闲空间占比大于该参数值，则将堆缩小。默认为 70%。</p><li><p><strong>-XX:MinHeapFreeRatio=百分比</strong>：设置 GC后堆最小空闲空间占比（0 到 100）。如果GC后空闲空间占比小于该参数值，则将堆扩大。默认为 40%。</p><li><p><strong>-XX:MaxTenuringThreshold=阈值</strong>：对象晋升至老年代的最大年龄阈值为 15。并行（吞吐量）收集器默认为 15，CMS 收集器默认为 6。</p><li><p><strong>-XX:MinRAMPercentage=百分比</strong>：将 JVM 可用于 Java 堆的最大内存量设置为如<code>-XX:MaxRAM</code>小堆选项中所述确定的最大内存量的百分比。小堆大约 125 MB。默认值为 50%。</p><li><p><strong>-XX:+ScavengeBeforeFullGC</strong>：FGC前先执行一次YGC，默认启用。Oracle 建议您不要禁用它。</p><li><p><strong>-XX:StringDeduplicationAgeThreshold=阈值</strong>：<code>String</code>达到指定年龄的对象被视为重复数据删除的候选对象。一个对象的年龄是衡量它在垃圾收集中幸存下来的次数。这有时被称为任期；</p><li><p><strong>-XX:+UseGCOverheadLimit</strong>：允许使用限制 JVM 在<code>OutOfMemoryError</code>抛出异常之前花费在 GC 上的时间比例的策略。默认情况下启用此选项，<code>OutOfMemoryError</code>如果总时间的 98% 以上用于垃圾收集并且堆的回收少于 2%，则并行 GC 将抛出异常。当堆很小时，此功能可用于防止应用程序长时间运行而几乎没有或没有进展。要禁用此选项请指定<code>-XX:-UseGCOverheadLimit</code>。</p><li><p><strong>-XX:+UseNUMA</strong>：通过增加应用程序对低延迟内存的使用，在具有非统一内存架构 (NUMA) 的机器上实现应用程序的性能优化。默认情况下，此选项处于禁用状态，并且不会对 NUMA 进行优化。该选项仅在使用并行垃圾收集器 ( <code>-XX:+UseParallelGC</code>)时可用。</p><li><p>-XX:PreTenureSizeThreshold：设置大对象大小；</p><li><p>-XX:MaxTenuringThreshold：表示对象晋升到老年代的年龄阈值；（默认值15，CMS为6，G1为15。）</p> <p><font color=red>注意，年龄小于该阈值时也可能会晋升，但晋升时对象的年龄永远不会超过该阈值。因为还有对象动态晋升机制的存在，动态晋升是指：当survivor区中所有相同大小对象的大小总和超过survivor区一半时，就需要将这些相同大小的对象和大于该大小的对象全部晋升到老年代中，使得survivor区中有空闲空间来供程序正常运行来用，否则没有空闲空间，程序将会出现问题。</font></p></ul><h3 id=2-5-2、垃圾收集器参数><a class=headerlink href=#2-5-2、垃圾收集器参数 title=2.5.2、垃圾收集器参数></a>2.5.2、垃圾收集器参数</h3><h4 id=基本参数-1><a class=headerlink href=#基本参数-1 title=基本参数></a>基本参数</h4><ul><li><strong>-XX:ConcGCThreads=线程</strong>：设置并发GC 线程数。默认值取决于 JVM 可用的 CPU 数量。<li><strong>-XX:+DisableExplicitGC</strong>：禁用代码块 System.gc()。<li><strong>-XX:InitiatingHeapOccupancyPercent=百分比</strong>：设置启动并发 GC 周期的堆占用百分比（0 到 100）。它被垃圾收集器使用，它们根据整个堆的占用率触发并发 GC 周期，而不仅仅是其中一代（例如，G1 垃圾收集器）。默认初始值为 45%。值 0 表示不间断 GC 循环。<li><strong>-XX:MaxGCPauseMillis=时间</strong>：设置 GC 最大暂停时间（以毫秒为单位）。默认 没有最大暂停时间值。</ul><h4 id=Serial-Old常用参数><a title="Serial Old常用参数" class=headerlink href=#Serial-Old常用参数></a>Serial Old常用参数</h4><ul><li><strong>-XX:+UseSerialGC</strong>：启用串行垃圾收集器。适用于小型的简单的应用程序。默认禁用，并根据机器配置和 JVM 类型自动选择收集器。</ul><h4 id=Parallel常用参数><a class=headerlink href=#Parallel常用参数 title=Parallel常用参数></a>Parallel常用参数</h4><ul><li><p><strong>-XX:+UseParallelGC</strong>：使用并行清理垃圾收集器（也称为吞吐量收集器）。默认禁用，并根据机器配置和 JVM 类型自动选择收集器。如果启用该选项，则默认同时启用<code>-XX:+UseParallelOldGC</code>，除非明确禁用它。</p><li><p><strong>-XX:+UseParallelOldGC</strong>：启用并行垃圾收集器。默认禁用。启用它会自动启用参数<code>-XX:+UseParallelGC</code>。</p><li><p><strong>-XX:+ParallelGCThreads=n</strong>：设置用于年轻代和年老代并行垃圾回收的线程数。默认值取决于 JVM 可用的 CPU 数量。同样适用于CMS。*</p> <p>按照逻辑处理器的数量来设置n值。n 的值应该与逻辑处理器的数量相同，最多为 8。如果逻辑处理器不止八个，则将 n 的值设置为逻辑处理器数量的 5/8 左右。这适用于大多数情况，除非是较大的 SPARC 系统，其中 n 值可以是逻辑处理器数的 5/16 左右。</p><li><p><strong>-XX:+UseAdaptiveSizePolicy</strong>：表示自动选择各区大小比例。</p><li><p><strong>-XX:InitialSurvivorRatio=比率</strong>：设置吞吐量垃圾收集器使用的初始幸存者空间比率（由<code>-XX:+UseParallelGC</code>和/或 -<code>XX:+UseParallelOldGC</code>选项启用）。默认吞吐量垃圾收集器使用<code>-XX:+UseParallelGC</code>和<code>-XX:+UseParallelOldGC</code>选项启用自适应大小调整，并根据应用程序行为调整幸存者空间大小，从初始值开始。如果禁用了自适应大小调整（使用该<code>-XX:-UseAdaptiveSizePolicy</code>选项），<code>-XX:SurvivorRatio</code>则应使用该选项为整个应用程序执行设置幸存者空间的大小。</p> <p>根据年轻代的大小（Y）和初始幸存者空间比率（R），可以使用以下公式计算幸存者空间的初始大小（S）：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>S=Y/(R+2)</span><br></pre></table></figure><li><p><strong>-XX:+ParallelRefProcEnabled</strong>：启用并行引用处理。默认禁用状态。</p><li><p><code>-XX:MaxGCPauseMillis</code>：设置垃圾收集器最大停顿时间。</p><li><p><code>-XX:GCTimeRatio</code>：垃圾收集时间占总时间的比例。</p></ul><h4 id=ParNew参数><a class=headerlink href=#ParNew参数 title=ParNew参数></a>ParNew参数</h4><ul><li>-XX:+UseParNewGC：年轻代中使用 并行线程 进行收集。默认禁用。设置参数<code>-XX:+UseConcMarkSweepGC</code>会自动启用。使用<code>-XX:+UseParNewGC</code>不带选项<code>-XX:+UseConcMarkSweepGC</code>的选择是在JDK 8弃用。</ul><h4 id=CMS常用参数><a class=headerlink href=#CMS常用参数 title=CMS常用参数></a>CMS常用参数</h4><ul><li><p>-XX:+UseConcMarkSweepGC：为老年代启用 CMS 垃圾收集器。Oracle 建议您在吞吐量 ( <code>-XX:+UseParallelGC</code>) 垃圾收集器无法满足应用程序延迟要求时使用 CMS 垃圾收集器。G1 垃圾收集器 ( <code>-XX:+UseG1GC</code>) 是另一种选择。</p> <p>默认情况下，此选项处于禁用状态，并根据机器的配置和 JVM 的类型自动选择收集器。当启用该选项时，<code>-XX:+UseParNewGC</code>选项将自动设置，你不应该禁用它，因为下面的选项组合已经在JDK 8被弃用：<code>-XX:+UseConcMarkSweepGC -XX:-UseParNewGC</code>。</p><li><p>-XX:ParallelCMSThreads：CMS线程数量。</p><li><p>-XX:CMSInitiatingOccupancyFraction：老年代内存使用率达到多少时执行CMS收集（低版本的 JDK 默认值为 68%, JDK6 及以上版本默认值为 92%），这里的内存回收范围仅限于老年代，而非整个堆空间，因此通过该选项便可以有效降低 Full GC 执行次数。如果频繁发生SerialOld卡顿，应该调小，（频繁CMS回收）。默认值设置为 -1。任何负值（包括默认值）都意味着<code>-XX:CMSTriggerRatio</code>用于定义初始占用率的值。</p><li><p>-XX:+UseCMSCompactAtFullCollection：执行FGC后是否进行压缩整理。</p><li><p>-XX:CMSFullGCsBeforeCompaction：执行FGC多少次后进行压缩整理。</p><li><p>-XX:+CMSClassUnloadingEnabled：表示对永久代进行垃圾回收；</p> <p>CMS收集器默认不会对永久代进行垃圾回收，如需回收设置该参数即可。在早期JVM版本中，要求设置额外的标志-XX:+CMSPermGenSweepingEnabled。注意，即使没有设置这个标志，一旦永久代耗尽空间也会尝试进行垃圾回收，但是收集不会是并行的，而再一次进行Full GC。</p><li><p>-XX:CMSInitiatingPermOccupancyFraction：达到什么比例时进行Perm回收。</p><li><p>GCTimeRatio：设置GC时间占用程序运行时间的百分比。</p><li><p>-XX:MaxGCPauseMillis：停顿时间，是一个建议时间，GC会尝试用各种手段达到这个时间，比如减小年轻代。</p><li><p>-XX:+CMSClassUnloadingEnabled：在使用并发标记清除 (CMS) 垃圾收集器时启用类卸载。默认启用。要禁用 CMS 垃圾收集器的类卸载，请指定<code>-XX:-CMSClassUnloadingEnabled</code>。</p><li><p>-XX:+CMSScavengeBeforeRemark：在 CMS 重新标记前启用清理。默认禁用。</p><li><p>-XX:CMSTriggerRatio=百分比：设置在<code>-XX:MinHeapFreeRatio</code>CMS 收集周期开始之前分配的指定值的百分比（0 到 100）。默认值设置为 80%。</p><li><p>-XX:+ExplicitGCInvokesConcurrent：通过使用<code>System.gc()</code>请求启用并发 GC 的调用。默认禁用，只能与<code>-XX:+UseConcMarkSweepGC</code>选项一起启用。</p><li><p>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses：通过在并发 GC 周期中使用 System.gc() 请求和卸载类来启用并发 GC 的调用。默认禁用，只能与 -XX:+UseConcMarkSweepGC 选项一起启用。</p><li><p>-XX:+UseCMSInitiatingOccupancyOnly：允许使用占用值作为启动 CMS 收集器的唯一标准。默认禁用，可以使用其他条件。</p></ul><h4 id=G1常用参数><a class=headerlink href=#G1常用参数 title=G1常用参数></a>G1常用参数</h4><ul><li><p>-XX:+UseG1GC：表示 使用G1收集器；</p><li><p>-XX:MaxGCPauseMillis：每次GC的停顿目标时间，默认值 200ms。G1会尝试调整Young区的个数来达到该值；</p><li><p>-XX:GCPauseIntervalMillis：GC间隔时间；</p><li><p>-XX:G1HeapRegionSize=n：分区大小，建议逐渐增大该值1、2、4、8、16、32。随着size增加，垃圾存活时间会更长，GC间隔会更长，但每次GC时间也会更长，ZGC做了改进（动态区块大小）；</p><li><p>-XX:G1HeapWastePercent：默认值5%，表示在全局并发标记结束后能够统计出所有可被回收的垃圾占Heap的比例值，如果超过5%，就会触发之后的多轮Mixed GC，mixed gc会同时回收年轻代+老年代，而这个参数可以指定mixed gc触发的时机；</p> <p>注意：该参数与 <code>InitiatingHeapOccupancyPercent</code> 结合使用可以实现提前回收老年代，让老年代提前释放空间。</p><li><p>-XX:InitiatingHeapOccupancyPercent=45：默认45%，表示在堆使用率达到该参数设定值时，就会触发 混合回收；</p><li><p>-XX:G1NewSizePercent：新生代最小比例，默认为5%。</p><li><p>-XX:G1MaxNewSizePercent：新生代最大比例，默认为60%；</p><li><p>-XX:G1MixedGCCountTarget：默认值8，表示最后的混合回收阶段会执行8次，一次只回收掉一部分Region，然后系统继续运行，过了一小段时间后，会再次进行混合回收，就这样重复8次；</p><li><p>-XX:G1MixedGCLiveThresholdPercent：默认值85%，表示 一个Region中的存活对象若大于Region大小的85%，那就无需回收这个Region，否则得不偿失；</p><li><p>-XX:GCTimeRatio：圾回收时间占程序运行时间的百分比；</p><li><p>-XX:ConcGCThreads=n：设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1/4 左右；</p><li><p><strong>-XX:G1HeapRegionSize=大小</strong>：使用G1收集器时 Java 堆细分的区域大小。该值介于 1 MB 和 32 MB 之间。默认区域大小是根据堆大小来定。</p><li><p><strong>-XX:+G1PrintHeapRegions</strong>：启用打印有关哪些区域已分配以及哪些由 G1 收集器回收的信息。默认情况下，此选项处于禁用状态。</p><li><p><strong>-XX:G1ReservePercent=百分比</strong>：设置保留为虚假上限的堆的百分比（0 到 50），以减少 G1 收集器升级失败的可能性。默认情况下，此选项设置为 10%。</p><li><p><strong>-XX:+UseStringDeduplication</strong>：启用字符串重复数据删除。默认禁用。要使用此选项，您必须启用G1垃圾收集器。</p></ul><h4 id=常见垃圾回收器参数><a class=headerlink href=#常见垃圾回收器参数 title=常见垃圾回收器参数></a>常见垃圾回收器参数</h4><p>设置串行收集器：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-XX:+UseSerialGC = Serial New(DefNew) + Serial Old</span><br></pre></table></figure><p>设置并行收集器：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>-XX:+UseParallelGC</span><br><span class=line>-XX:ParallelGCThreads=n     <span class=comment># 设置并行收集器工作时使用的CPU数量。</span></span><br><span class=line>-XX:MaxGCPauseMillis=n      <span class=comment># 设置并行收集器最大停顿时间。</span></span><br><span class=line>-XX:GCTimeRatio=n           <span class=comment># 设置垃圾回收时间占程序运行时间的百分比。</span></span><br></pre></table></figure><p>设置老年代并行收集器：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-XX:+UseParallelOldGC</span><br></pre></table></figure><p>设置并发收集器：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>-XX:+UseConcMarkSweepGC</span><br><span class=line>-XX:+CMSIncrementalMode <span class=comment># 设置为增量模式，适用于单CPU情况。</span></span><br><span class=line>-XX:ParallelGCThreads=n <span class=comment># 设置年轻代收集为并行收集时，并行GC线程的数量，一般最好和CPU核心数量一样。</span></span><br></pre></table></figure><p>其它参数如下：<ul><li><p>-XX:+UseParNewGC = ParNew + SerialOld</p><li><p>-XX:+UseConc(current)MarkSweepGC = ParNew + CMS + SerialOld</p><li><p>-XX:+UseParallelGC = Parallel Scavenge + Parallel Old</p><li><p>-XX:+UseG1GC = G1</p><li><p>查看Linux下默认GC的方法，而Windows中会打印UseParallelGC。</p> <ol><li>java -XX:+PrintCommandLineFlags - version<li>通过GC日志分辨。</ol><li><p>Linux下JDK8默认垃圾收集器？</p> <ol><li>1.8.0_181 默认看不出，Copy MarkCompact<li>1.8.0_222 默认PS + PO</ol></ul><h3 id=2-5-3、GC日志参数><a class=headerlink href=#2-5-3、GC日志参数 title=2.5.3、GC日志参数></a>2.5.3、GC日志参数</h3><h4 id=基本参数-2><a class=headerlink href=#基本参数-2 title=基本参数></a>基本参数</h4><ul><li><strong>-XX:LogFile=路径</strong>：设置写入日志数据的路径和文件名。默认该文件创建在当前工作目录中，并命名为<code>hotspot.log</code>.</ul><h4 id=日志打印参数><a class=headerlink href=#日志打印参数 title=日志打印参数></a>日志打印参数</h4><ul><li><strong>-XX:+PrintGC</strong>：每次 GC 时打印消息。默认禁用。<li><strong>-XX:+PrintGCDetails</strong>：每次 GC 时打印详细消息。默认禁用。<li><strong>-XX:+PrintGCTimeStamps</strong>：每次 GC 时打印时间戳。默认禁用。<li><strong>-XX:+PrintGCTaskTimeStamps</strong>：为每个单独的 GC 工作线程任务启用时间戳打印。默认禁用。<li><strong>-XX:+PrintGCCauses</strong><li><strong>-XX:+PrintGCApplicationConcurrentTime</strong>：启用打印自上次暂停（例如，GC 暂停）以来经过的时间。默认禁用。<li><strong>-XX:+PrintGCApplicationStoppedTime</strong>：启用打印暂停（例如，GC 暂停）持续的时间。默认禁用。<li><strong>-XX:+PrintGCDateStamps</strong>：每次 GC 时打印日期戳。默认禁用。<li><strong>-XX:+PrintStringDeduplicationStatistics</strong>：打印详细重复数据，删除统计信息。默认禁用。查看<code>-XX:+UseStringDeduplication</code>选项。<li><strong>-XX:+PrintTenuringDistribution</strong>：启用任期年龄信息的打印。<li><strong>-XX:SoftRefLRUPolicyMSPerMB=时间</strong>：软引用对象在上次被引用后在堆上保持活动的时间量（以毫秒为单位）。默认值是堆中每空闲兆字节的生命周期一秒。<li><strong>-XX:PrintHeapAtGC</strong>：GC执行前后打印出堆的信息；<li><strong>-Xloggc:filename</strong>：日志文件保存路径；</ul><p><font color=red>注意：total = eden区 + 1个survivor区。</font><h4 id=注意事项-1><a class=headerlink href=#注意事项-1 title=注意事项></a>注意事项</h4><p>JDK8及之前推荐配置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:文件路径</span><br></pre></table></figure><p>JDK9及之后推荐配置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-Xlog:gc*:file=文件路径</span><br></pre></table></figure><h2 id=2-6、Java锁参数><a class=headerlink href=#2-6、Java锁参数 title=2.6、Java锁参数></a>2.6、Java锁参数</h2><ul><li><strong>-XX:-UseBiasedLocking</strong>：禁用偏向锁。</ul><h2 id=2-7、JVM参数总结><a class=headerlink href=#2-7、JVM参数总结 title=2.7、JVM参数总结></a>2.7、JVM参数总结</h2><h3 id=2-7-1、GC常用参数><a class=headerlink href=#2-7-1、GC常用参数 title=2.7.1、GC常用参数></a>2.7.1、GC常用参数</h3><ul><li>-Xms / -Xmx / -Xmn / -Xss：最小堆 / 最大堆 / 年轻代 / 栈空间。<li>-XX:NewSize：JVM启动时分配的新生代内存大小。<li>-XX:OldSize：JVM启动时分配的老年代内存大小。<li>-XX:PermSize 和 -XX:MaxPermSize：JVM 永久代（方法区，JDK7之前）大小。<li>-XX SurvivorRatio：Eden空间和另外两个Survivor空间的比例，默认比例是<code>8:1</code>。<li>-XX:+UseTLAB：使用TLAB，默认打开。<li>-XX:+PrintTLAB：打印TLAB使用情况。<li>-XX:TLABSize：设置TLAB大小。<li>-XX:+DisableExplictGC：禁用System.gc()功能，FGC。<li>-XX:+PrintGC：打印GC日志信息。<li>-XX:+PrintGCDetails：打印GC详细的日志信息。<li>-XX:+PrintHeapAtGC：发生GC时打印堆信息。<li>-XX:+PrintGCTimeStamps：打印GC执行时间信息。<li>-XX:+PrintGCApplicationConcurrentTime (低)：打印应用程序时间。<li>-XX:+PrintGCApplicationStoppedTime（低）：打印暂停时长。<li>-XX:+PrintReferenceGC（重要性低）：记录回收了多少种不同引用类型的引用。<li>-verbose:class：类加载详细过程。<li>-XX:+PrintVMOptions：打印虚拟机的选项信息。<li>-XX:+PrintFlagsFinal -XX:+PrintFlagsInitial：必须会用。<li>-Xloggc:opt/log/gc.log：将生成的gc日志保存于指定的文件中。<li>-XX:MaxTenuringThreshold：升代年龄，最大值15。<li>-XX:PreBlockSpin：锁自旋次数参数（默认即可，不建议设置）。<li>-XX:CompileThreshold：热点代码检测参数、逃逸分析、标量替换（默认即可，不建议设置）。</ul><h3 id=2-7-2、堆内存常用配置><a class=headerlink href=#2-7-2、堆内存常用配置 title=2.7.2、堆内存常用配置></a>2.7.2、堆内存常用配置</h3><h4 id=参考1><a class=headerlink href=#参考1 title=参考1></a>参考1</h4><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -Xms3550m -Xmx3550m -Xmn2g -Xss128k</span><br></pre></table></figure><ul><li><p>-Xmx3550m：设置JVM最大可用内存为3550M。</p><li><p>-Xms3550m：设置JVM内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</p><li><p>-Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻代大小+老年代大小+持久代大小。持久代大小一般固定为64m，所以增大年轻代后，将会减小老年代大小。</p> <p><font color=red>注意：此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</font></p><li><p>-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p></ul><h4 id=参考2><a class=headerlink href=#参考2 title=参考2></a>参考2</h4><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -Xms3550m -Xmx3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0</span><br></pre></table></figure><ul><li>-XX:NewRatio=4：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4表示年轻代与年老代的比为<code>1:4</code>，年轻代占整个堆栈的1/5。<li>-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为<code>2:4</code>，一个Survivor区占整个年轻代的1/6。<li>-XX:MaxPermSize=16m：设置持久代大小为16m。JDK8中弃用，若使用JDK8及更新版本，则该参数被<code>-XX:MaxMetaspaceSize</code>替代。<li>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代即被回收的机会。</ul><h4 id=参考3><a class=headerlink href=#参考3 title=参考3></a>参考3</h4><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>-Xms1G -Xmx1G -Xss256K -XX:MaxMetaspaceSize=512M -XX:+DisableExplicitGC</span><br><span class=line>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/opt/dumps/my-service.hprof</span><br><span class=line>-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:文件路径</span><br></pre></table></figure><p>参数解析：<ul><li>-XX:MaxMetaspaceSize=512M：最大元空间大小为512M。<li>-XX:+DisableExplicitGC：禁用System.gc()功能。<li>-XX:+HeapDumpOnOutOfMemoryError：出现OutOfMemory错误时自动生成堆内存快照。<li>-XX:HeapDumpPath=/opt/dumps/my-service.hprof：堆内存快照的生成位置。与上一个参数一起用。<li>-XX:+PrintGCDetails：打印详细的垃圾回收日志。<li>-XX:+PrintGCDateStamps：打印垃圾回收使用。<li>-Xloggc:文件路径：日志文件输出位置。</ul><p>注意事项：JDK9及之后，gc日志输出参数可修改为：<code>-Xlog:gc*:file=文件名</code>。<h3 id=2-8-3、回收器常用配置><a class=headerlink href=#2-8-3、回收器常用配置 title=2.8.3、回收器常用配置></a>2.8.3、回收器常用配置</h3><h4 id=吞吐量优先><a class=headerlink href=#吞吐量优先 title=吞吐量优先></a>吞吐量优先</h4><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment># 方案1</span></span><br><span class=line>java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20</span><br><span class=line><span class=comment># 方案2</span></span><br><span class=line>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC</span><br><span class=line><span class=comment># 方案3</span></span><br><span class=line>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100</span><br><span class=line><span class=comment># 方案4</span></span><br><span class=line>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy</span><br></pre></table></figure><h4 id=响应时间优先><a class=headerlink href=#响应时间优先 title=响应时间优先></a>响应时间优先</h4><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># 方案1</span></span><br><span class=line>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</span><br><span class=line><span class=comment># 方案2</span></span><br><span class=line>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</span><br></pre></table></figure><h1 id=3、JVM调优><a class=headerlink href=#3、JVM调优 title=3、JVM调优></a>3、JVM调优</h1><h2 id=3-1、调优须知><a class=headerlink href=#3-1、调优须知 title=3.1、调优须知></a>3.1、调优须知</h2><h3 id=3-1-1、重要概念><a class=headerlink href=#3-1-1、重要概念 title=3.1.1、重要概念></a>3.1.1、重要概念</h3><h4 id=3-1-1-1、内存泄漏><a class=headerlink href=#3-1-1-1、内存泄漏 title=3.1.1.1、内存泄漏></a>3.1.1.1、内存泄漏</h4><p>内存泄漏（Memory Leak）：<strong>程序申请内存后无法释放已申请的内存空间。</strong>一次内存泄露可以忽略，但内存泄露堆积，后果很严重。<h4 id=3-1-1-2、内存溢出><a class=headerlink href=#3-1-1-2、内存溢出 title=3.1.1.2、内存溢出></a>3.1.1.2、内存溢出</h4><p>内存溢出（Out Of Memory）：<strong>程序申请内存时没有足够的内存空间供其使用会出现Out Of Memory。</strong><h4 id=3-1-1-3、QPS><a class=headerlink href=#3-1-1-3、QPS title=3.1.1.3、QPS></a>3.1.1.3、QPS</h4><p><strong>QPS</strong>：全称——Queries Per Second，意思是<em><strong>每秒查询率</strong></em>，是一台服务器每秒能够响应的查询次数（数据库中的每秒执行查询sql的次数），显然，这个不够全面，不能描述增删改，所以，不建议用qps来作为系统性能指标。<h4 id=3-1-1-4、TPS><a class=headerlink href=#3-1-1-4、TPS title=3.1.1.4、TPS></a>3.1.1.4、TPS</h4><p><strong>TPS</strong>：全称——Transactions Per Second，意思是<em><strong>每秒事务数</strong></em>，具体事务的定义，都是人为的，可以一个接口、多个接口、一个业务流程等等。一个事务是指事务内第一个请求发送到接收到最后一个请求的响应的过程，以此来计算使用的时间和完成的事务个数。<p>以单接口定义的事务为例，每个事务包括了如下3个过程：<ol><li>向服务器发请求。<li>服务器自己的内部处理（包含应用服务器、数据库服务器等）。<li>服务器返回结果给客户端。</ol><p>如果每秒能够完成N次这三个过程，那么TPS就是N；<p>如果多个接口定义为一个事务，且1、2、3过程执行一轮为一次，那么1秒能执行多少次，TPS就是多少。<h4 id=3-1-1-5、吞吐量><a class=headerlink href=#3-1-1-5、吞吐量 title=3.1.1.5、吞吐量></a>3.1.1.5、吞吐量</h4><p><strong>吞吐量</strong>：用户代码时间 / (用户代码执行时间 + 垃圾回收时间)。<p>科学计算、数据挖掘等场景会注重吞吐量。<h4 id=3-1-1-6、响应时间><a class=headerlink href=#3-1-1-6、响应时间 title=3.1.1.6、响应时间></a>3.1.1.6、响应时间</h4><p><strong>响应时间</strong>：服务器接收到请求到返回结果给客户端这么一个过程所耗费的时间。STW时间越短，响应时间越好。<h3 id=3-1-1、调优目标><a class=headerlink href=#3-1-1、调优目标 title=3.1.1、调优目标></a>3.1.1、调优目标</h3><p>GC调优包含：内存调优、锁竞争调优、CPU占用调优、IO调优等众多领域。<p>GC调优前，要先确定调优的目标是什么？比如，目标是追求响应时间、吞吐量等。<h3 id=3-1-2、调优思路><a class=headerlink href=#3-1-2、调优思路 title=3.1.2、调优思路></a>3.1.2、调优思路</h3><h4 id=3-1-2-1、思路分析><a class=headerlink href=#3-1-2-1、思路分析 title=3.1.2.1、思路分析></a>3.1.2.1、思路分析</h4><p>调优，从业务场景开始，同时要遵循无监控，不调优的规则。<p>常见的调优思路如下：<ol><li><p>熟悉业务场景（选择垃圾收集器，垃圾收集器只有合适的，没有最好的）。</p> <ul><li>响应时间：停顿时间，（推荐：CMS / G1 / ZGC）<li>吞吐量：代码时间 / (代码时间 + GC时间)，（推荐：PS）</ul><li><p>选择回收器组合。</p><li><p>计算内存需求。</p><li><p>选定CPU（越高越好，按预算来）。</p><li><p>设置各种内存区域的大小，及相关参数。</p><li><p>开启日志。</p></ol><h4 id=3-1-2-2、常用参数><a class=headerlink href=#3-1-2-2、常用参数 title=3.1.2.2、常用参数></a>3.1.2.2、常用参数</h4><h5 id=日志参数><a class=headerlink href=#日志参数 title=日志参数></a>日志参数</h5><p>与日志相关的常用参数如下：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>// JDK8及之前</span><br><span class=line>-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:文件路径</span><br><span class=line></span><br><span class=line>// JDK9开始</span><br><span class=line>-Xlog:gc*:file=文件路径</span><br></pre></table></figure><h5 id=其它命令><a class=headerlink href=#其它命令 title=其它命令></a>其它命令</h5><ol><li>java -XX:+PrintFlagsInitial：打印默认参数值；<li>java -XX:+PrintFlagsFinal：打印最终参数值；<li>java -XX:+PrintFlagsFinal | grep xxx：找到对应的参数；<li>java -XX:+PrintFlagsFinal -version | grep GC；</ol><h2 id=3-2、GC日志><a class=headerlink href=#3-2、GC日志 title=3.2、GC日志></a>3.2、GC日志</h2><h3 id=3-7-1、准备><a class=headerlink href=#3-7-1、准备 title=3.7.1、准备></a>3.7.1、准备</h3><p>测试代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">HelloGC</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        System.out.println(<span class=string>"HellGC."</span>);</span><br><span class=line>        <span class=type>List</span> <span class=variable>list</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">LinkedList</span>();</span><br><span class=line>        <span class=keyword>for</span> (;;){</span><br><span class=line>            <span class=type>byte</span>[] b = <span class=keyword>new</span> <span class="title class_">byte</span>[<span class=number>1024</span> * <span class=number>1024</span>];</span><br><span class=line>            list.add(b);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>测试一：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令</span></span><br><span class=line>java -XX:+PrintCommandLineFlags HelloGC</span><br><span class=line></span><br><span class=line><span class=comment># 输出</span></span><br><span class=line>-XX:InitialHeapSize=29592512 -XX:MaxHeapSize=473480192 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops </span><br><span class=line>HelloGC</span><br><span class=line>Exception <span class=keyword>in</span> thread <span class=string>"main"</span> java.lang.OutOfMemoryError: Java heap space at HelloGC.main(HelloGC.java:9)</span><br></pre></table></figure><p>测试二：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令</span></span><br><span class=line>java -Xmn10M -Xms40M -Xmx60M -XX:+PrintCommandLineFlags -XX:+PrintGC HelloGC PrintGCDetails PrintGCTimeStamps PrintGCCauses</span><br><span class=line></span><br><span class=line><span class=comment># 输出</span></span><br><span class=line>-XX:InitialHeapSize=41943040 -XX:MaxHeapSize=62914560 -XX:MaxNewSize=10485760 -XX:NewSize=10485760 -XX:+PrintCommandLineFlags -XX:+PrintGC -XX:+UseCompressedClassPointers -XX:+UseCompressedOops </span><br><span class=line>HelloGC</span><br><span class=line>[GC (Allocation Failure)  7675K->7426K(39936K), 0.0065081 secs]</span><br><span class=line>[GC (Allocation Failure)  14756K->14594K(39936K), 0.0066781 secs]</span><br><span class=line>[GC (Allocation Failure)  21916K->21762K(39936K), 0.0082077 secs]</span><br><span class=line>[GC (Allocation Failure)  29086K->28931K(39936K), 0.0062089 secs]</span><br><span class=line>[GC (Allocation Failure)  36256K->36099K(45076K), 0.0077737 secs]</span><br><span class=line>[Full GC (Allocation Failure)  36099K->36098K(45076K), 0.0023287 secs]</span><br><span class=line>[GC (Allocation Failure)  43424K->43266K(60416K), 0.0068826 secs]</span><br><span class=line>[GC (Allocation Failure)  50592K->50434K(60416K), 0.0075865 secs]</span><br><span class=line>[Full GC (Allocation Failure)  57761K->57603K(60416K), 0.0027358 secs]</span><br><span class=line>[Full GC (Allocation Failure)  57603K->57591K(60416K), 0.0022941 secs]</span><br><span class=line>Exception <span class=keyword>in</span> thread <span class=string>"main"</span> java.lang.OutOfMemoryError: Java heap space at HelloGC.main(HelloGC.java:9)</span><br></pre></table></figure><p>测试三：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令</span></span><br><span class=line>java -XX:+UseConcMarkSweepGC -XX:+PrintCommandLineFlags HelloGC</span><br><span class=line></span><br><span class=line> <span class=comment># 输出</span></span><br><span class=line>-XX:InitialHeapSize=29592512 -XX:MaxHeapSize=473480192 -XX:MaxNewSize=87244800 -XX:MaxTenuringThreshold=6 -XX:OldPLABSize=16 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC </span><br><span class=line>HelloGC</span><br><span class=line>Exception <span class=keyword>in</span> thread <span class=string>"main"</span> java.lang.OutOfMemoryError: Java heap space at HelloGC.main(HelloGC.java:9)</span><br></pre></table></figure><h3 id=3-7-2、示例日志1><a class=headerlink href=#3-7-2、示例日志1 title=3.7.2、示例日志1></a>3.7.2、示例日志1</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>[GC (Allocation Failure) [DefNew (promotion failed) : 123228K->138592K(138816K), <span class=number>0.0698705</span> secs][Tenured: 308488K->308488K(308608K), <span class=number>0.0097199</span> secs] 360036K->359693K(447424K), </span><br><span class=line>[Metaspace: 2500K->2500K(1056768K)], <span class=number>0.0796660</span> secs] </span><br><span class=line>[Times: user=<span class=number>0.02</span> sys=<span class=number>0.06</span>, real=<span class=number>0.07</span> secs]</span><br></pre></table></figure><ul><li>GC：指YGC。<li>(Allocation Failure)：GC原因。<li>DefNew：产生的年代，这里是年轻代；后面的：123228K->138592K(138816K), 0.0698705 secs，其从左到右分别代表：回收前年轻代大小->回收后年轻代大小(整个年轻代的大小)，回收所消耗的时间；<li>[Tenured: 308488K->308488K(308608K), 0.0097199 secs]：从左到右分别代表：回收前堆大小->回收后堆大小(整个堆的大小)，回收消耗的时间。<li>[Metaspace: 2500K->2500K(1056768K)], 0.0796660 secs]：从左到右分别代表：回收前元空间大小->回收后大小(整个元空间的大小)，回收消耗的时间。<li>[Times: user=0.02 sys=0.06, real=0.07 secs]：从左到右分别代表：用户态消耗的时间、内核态消耗的时间，整个过程实际消耗多长时间。</ul><h3 id=3-7-3、示例日志2><a class=headerlink href=#3-7-3、示例日志2 title=3.7.3、示例日志2></a>3.7.3、示例日志2</h3><p>一旦内存溢出，就会把整个堆 heap dump出来：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>Heap</span><br><span class=line> def <span class=keyword>new</span> <span class="title class_">generation</span>   total 138816K, used 138753K [<span class=number>0x00000000e3c00000</span>, <span class=number>0x00000000ed2a0000</span>, <span class=number>0x00000000ed2a0000</span>)</span><br><span class=line>  eden space 123392K, <span class=number>100</span>% used [<span class=number>0x00000000e3c00000</span>, <span class=number>0x00000000eb480000</span>, <span class=number>0x00000000eb480000</span>)</span><br><span class=line>  from space 15424K,  <span class=number>99</span>% used [<span class=number>0x00000000ec390000</span>, <span class=number>0x00000000ed290478</span>, <span class=number>0x00000000ed2a0000</span>)</span><br><span class=line>  to   space 15424K,   <span class=number>0</span>% used [<span class=number>0x00000000eb480000</span>, <span class=number>0x00000000eb480000</span>, <span class=number>0x00000000ec390000</span>)</span><br><span class=line> tenured generation   total 308608K, used 308477K [<span class=number>0x00000000ed2a0000</span>, <span class=number>0x0000000100000000</span>, <span class=number>0x0000000100000000</span>)</span><br><span class=line>   the space 308608K,  <span class=number>99</span>% used [<span class=number>0x00000000ed2a0000</span>, <span class=number>0x00000000fffdf618</span>, <span class=number>0x00000000fffdf800</span>, <span class=number>0x0000000100000000</span>)</span><br><span class=line> Metaspace       used 2531K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class=line>  <span class=keyword>class</span> <span class="title class_">space</span>    used 272K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></table></figure><ul><li><p>Metaspace used 2531K, capacity 4486K, committed 4864K, reserved 1056768K：2531K表示已使用；4486K表示总容量；4864K表示虚拟内存占用；1056768K表示虚拟内存保留容量。</p><li><p>total = eden + 一个survivor</p><li><p>年轻代大小加起来不相等？因为除了new的对象和年轻代外还有其他信息。观察日志主要看的是变化。</p></ul><h2 id=3-3、调优工具><a class=headerlink href=#3-3、调优工具 title=3.3、调优工具></a>3.3、调优工具</h2><h3 id=3-5-1、Arthas><a class=headerlink href=#3-5-1、Arthas title=3.5.1、Arthas></a>3.5.1、Arthas</h3><h4 id=常用命令><a class=headerlink href=#常用命令 title=常用命令></a>常用命令</h4><p>1、dump到指定文件（使用jhat进行分析）<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>heapdump</span> <span class=string>/tmp/dump.hprof</span></span><br></pre></table></figure><p>2、仅dump live对象<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>heapdump</span> <span class=string>--live /tmp/dump.hprof</span></span><br></pre></table></figure><p>3、展示当前进程信息<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>dashboard</span></span><br></pre></table></figure><p>4、打印线程ID的栈信息<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>thread</span> <span class=string>id </span></span><br></pre></table></figure><p>5、可以方便查看死锁<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>thread</span> <span class=string>-b id</span></span><br></pre></table></figure><p>6、反编译<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>jad</span> <span class=string>*.class    如：jad HelloGC</span></span><br></pre></table></figure><p>反编译需要注意以下问题：<ol><li><font color=red>动态代理生成类问题；</font><li><font color=red>第三方类；（观察代码）</font><li><font color=red>版本问题；（确定自己最新提交的版本是不是被使用）</font></ol><p><font color=red>注意：配合热替换使用，但要注意热替换的限制问题。</font><p>7、热替换<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>redefine /opt/XXX.class</span><br></pre></table></figure><p>实现步骤：<ol><li>运行测试类A；（A中有方法m，m中打印数字1。）<li>现需要修改类A中方法m的逻辑，让其打印数字2；<li>在不停掉1步骤中类A的情况下，直接修改类A中方法m的逻辑（打印2），然后重新编译（javac A.java）；<li>执行arthas命令：<code>redefine /opt/A.class</code>，即可实现热替换；（命令中的A.class是修改后的最新版本）</ol><p>限制条件有：<ol><li>只能修改方法实现；（方法已经运行）<li>不能改方法名；<li>不能改属性；</ol><h3 id=3-5-2、VisualVM><a class=headerlink href=#3-5-2、VisualVM title=3.5.2、VisualVM></a>3.5.2、VisualVM</h3><h3 id=3-5-3、Profiler><a class=headerlink href=#3-5-3、Profiler title=3.5.3、Profiler></a>3.5.3、Profiler</h3><h3 id=3-5-4、GCEasy><a class=headerlink href=#3-5-4、GCEasy title=3.5.4、GCEasy></a>3.5.4、GCEasy</h3><h3 id=3-5-5、GCViewer><a class=headerlink href=#3-5-5、GCViewer title=3.5.5、GCViewer></a>3.5.5、GCViewer</h3><p>GCViewer是一个将GC日志转为可视化图表的工具。<p>通过命令<code>java -jar gcviewer_1.3.4.jar 日志文件.log</code>即可查看转换结果。<h2 id=3-4、调优建议><a class=headerlink href=#3-4、调优建议 title=3.4、调优建议></a>3.4、调优建议</h2><h3 id=3-4-1、选择垃圾回收器><a class=headerlink href=#3-4-1、选择垃圾回收器 title=3.4.1、选择垃圾回收器></a>3.4.1、选择垃圾回收器</h3><p>没有最好的垃圾回收器，只有最合适的垃圾回收器。要想程序运行表现符合自己的期望，就要选择适合当前程序的垃圾回收器。<p>对于一个程序或项目来说，<strong>如果追求更快的响应时间，希望提升用户的整体体验，那么可以选择响应时间优先的垃圾回收器，即CMS、G1、ZGC。如果追求的是吞吐量，对响应时间并无苛刻要求，那么可以选择使用吞吐量优先的垃圾回收器，即ParallelGC</strong>。<h3 id=3-4-2、新生代调优><a class=headerlink href=#3-4-2、新生代调优 title=3.4.2、新生代调优></a>3.4.2、新生代调优</h3><h4 id=3-4-2-1、概述><a class=headerlink href=#3-4-2-1、概述 title=3.4.2.1、概述></a>3.4.2.1、概述</h4><p>当线程创建一个对象时，需要在Eden区中当前线程私有的TLAB中为该对象分配内存。当多个线程多次创建对象并在Eden区中分配内存时，Eden区的空间将会被逐渐消耗完。当Eden区中没有空闲空间用来分配新创建的对象时，就会触发垃圾回收器的YGC操作，垃圾回收器会通过YGC操作将Eden区和Survivor From区中的存活对象转移至Survivor To区中，然后对Eden区和Survivor From区中剩余的垃圾对象进行清除回收，回收后的空间就可以再次被用于新对象的内存分配。注意的是，每当执行一次年轻代垃圾回收，Survivor区的From和To会交换角色，如此一来，每次都可以将存活对象转移到To区中。<p>新生代调优要考虑的方面为：<strong>为新生代分配合适的可以满足（单次请求响应*并发量）需要的内存大小，尽量避免YGC的频繁执行</strong>。<p>参数<code>-XX:NewSize</code>可设置新生代初始大小，参数<code>-XX:MaxNewSize</code>可设置新生代最大空间。除了这两个参数外，可以使用参数<code>-Xmn大小</code>来设置新生代的初始和最大内存，该参数可替代前面两个参数。参数值的单位可以是M、K、字节。<p><strong>oracle官方建议：年轻代的大小应该保持在堆总大小的1/4~1/2之间</strong>。<h4 id=3-4-2-2、Survivor区><a class=headerlink href=#3-4-2-2、Survivor区 title=3.4.2.2、Survivor区></a>3.4.2.2、Survivor区</h4><p>Survivor区也成为幸存区，分为From和To两个部分。Survivor To区中主要存储Eden区和Survivor From区中转移过来的存活对象，这种转移在底层通过<strong>复制算法</strong>完成，转移完成后这些存活对象的年龄会加1。这些存活对象经过多次复制转移，年龄会依次递增，当年龄达到晋升阈值时，会将这些年龄到达阈值的存活对象复制到老年代中。<p>复制算法复制转移对象的成本相对较高，因此，对于Survivor区优化来说，可以考虑的方面为：<strong>适当降低对象晋升至老年代时的年龄阈值，避免多次无意义的复制操作，一定程度上减少了性能的损耗</strong>。<p>参数<code>-XX:MaxTenuringThreshold=threshold</code>可设置触发对象晋升至老年代的年龄阈值。参数<code>-XX:+PrintTenuringDistribution</code>可实现打印对象晋升时相关日志。<h3 id=3-4-3、老年代调优><a class=headerlink href=#3-4-3、老年代调优 title=3.4.3、老年代调优></a>3.4.3、老年代调优</h3><h4 id=3-4-3-1、CMS垃圾回收器><a class=headerlink href=#3-4-3-1、CMS垃圾回收器 title=3.4.3.1、CMS垃圾回收器></a>3.4.3.1、CMS垃圾回收器</h4><p>对于基于CMS垃圾回收器的程序或应用来调优时，可参考如下几点：<ul><li>老年代空间尽可能大一点。<li>当发生FGC时，先尝试调优新生代。<li>如果FGC并非因新生代的问题触发，则先观察FGC触发时老年代内存的占用情况。如果老年代内存偏小，则需根据实际情况通过扩容或降低触发GC的阈值来尝试解决。</ul><p>FGC的触发，可能是硬件原因，也可能是年轻代、老年代本身的原因。硬件原因说的是当前的硬件资源环境不能满足程序的良好运行，因此导致了问题的出现。年轻代、老年代原因说的是没有根据实际情况对堆内存做出合适的配置和优化，进而导致问题的出现。<p><strong>如果FGC是由硬件资源不足导致，可通过增加硬件资源来改善和避免。如果FGC是因年轻代、老年代等的不合理配置导致，则可以通过实验得出较合理的配置</strong>。比如，若老年代空间不足，则可以尝试为其扩容1/4~1/3来解决，也可以通过参数<code>-XX:CMSInitiatingOccupancyFraction=percent</code>来设置合适的GC触发阈值，让GC提前执行来尝试解决。<h2 id=3-5、调优案例><a class=headerlink href=#3-5、调优案例 title=3.5、调优案例></a>3.5、调优案例</h2><h3 id=3-5-1、案例一><a class=headerlink href=#3-5-1、案例一 title=3.5.1、案例一></a>3.5.1、案例一</h3><h4 id=案例代码><a class=headerlink href=#案例代码 title=案例代码></a>案例代码</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.math.BigDecimal;</span><br><span class=line><span class=keyword>import</span> java.util.ArrayList;</span><br><span class=line><span class=keyword>import</span> java.util.Date;</span><br><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.TimeUnit;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">FullGC_Problem01</span> {</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">CardInfo</span>{</span><br><span class=line>        <span class=type>BigDecimal</span> <span class=variable>bigDecimal</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">BigDecimal</span>(<span class=number>0.0</span>);</span><br><span class=line>        <span class=type>String</span> <span class=variable>name</span> <span class=operator>=</span> <span class=string>"ZhangSan"</span>;</span><br><span class=line>        <span class=type>int</span> <span class=variable>age</span> <span class=operator>=</span> <span class=number>18</span>;</span><br><span class=line>        <span class=type>Date</span> <span class=variable>birthdate</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Date</span>();</span><br><span class=line></span><br><span class=line>        <span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">m</span><span class=params>()</span>{}</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>ScheduledThreadPoolExecutor</span> <span class=variable>executor</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class=number>50</span>, <span class=keyword>new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy());</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> Exception{</span><br><span class=line>        executor.setMaximumPoolSize(<span class=number>50</span>);</span><br><span class=line>        <span class=keyword>for</span> (;;){</span><br><span class=line>            modelFit();</span><br><span class=line>            Thread.sleep(<span class=number>100</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">modelFit</span><span class=params>()</span>{</span><br><span class=line>        List&LTCardInfo> taskList = getAllCardInfo();</span><br><span class=line>        taskList.forEach(info -> {</span><br><span class=line>            executor.scheduleWithFixedDelay(() -> {</span><br><span class=line>                info.m();</span><br><span class=line>            }, <span class=number>2</span>, <span class=number>3</span>, TimeUnit.SECONDS);</span><br><span class=line>        });</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> List&LTCardInfo> <span class="title function_">getAllCardInfo</span><span class=params>()</span>{</span><br><span class=line>        List&LTCardInfo> taskList = <span class=keyword>new</span> <span class="title class_">ArrayList</span><>();</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < <span class=number>100</span>; i++){</span><br><span class=line>            <span class=type>CardInfo</span> <span class=variable>ci</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">CardInfo</span>();</span><br><span class=line>            taskList.add(ci);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> taskList;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h4 id=排查过程><a class=headerlink href=#排查过程 title=排查过程></a>排查过程</h4><p><strong>1）运行测试程序</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -Xms200m -Xmx200m -XX:+PrintGC -XX:+HeapDumpOnOutOfMemoryError FullGC_Problem01</span><br></pre></table></figure><p><strong>2）查看CPU占用，拿到占比较高的进程ID。</strong><p>通过命令 top 查找耗费CPU最高的进程PID，比如3568。<p><strong>3）找到CPU占用最高的线程ID，查看线程运行情况。</strong><ol><li>通过命令<code>top -Hp 3568</code>查找当前进程中耗费CPU最高的线程PID，比如1374；<li>通过命令<code>printf "%x\n" 1374</code>可以把线程PID转为16进制，比如转换后得到 55e；<li>通过命令<code>jstack 3568 | grep -20 55e</code>查找当前线程阻塞的位置；</ol><p><strong>4）查看线程运行情况</strong>：执行<code>jinfo pid</code>命令。<p><strong>5）观察GC执行情况。</strong><p>通过命令<code>jstat -gc PID</code> 观察gc动态情况，阅读GC日志发现频繁GC，arthas观察，jconsole，jvisualVM，Jprofiler（最好用）。<p>通过命令<code>jstat -gc 4655 500</code>实现每500毫秒打印一次GC情况。<blockquote><p>注意：图形界面监控一般适用于测试阶段，线上系统监控一般使用命令行调式工具——cmdline、Arthas。</blockquote><p><strong>6）查看对象创建的数量。</strong><p>通过命令<code>jmap -histo pid | head -20</code>查看对象创建数量排名前20的对象信息。<p><strong>7）导出dump信息文件。</strong><p>通过命令<code>jmap -dump:format=b,file=D:\test\heap.hprof 6956</code>将当前堆栈信息导出到一个文件中。<blockquote><p>线上系统，内存特别大，jmap执行期间会对进程产生很大影响，甚至卡顿（电商不适合）<ol><li>设定参数HeapDump，OOM的时会自动产生堆转储文件（不是很专业，因为多有监控，内存增长就会报警。<li>多服务器备份（高可用），停掉这台服务器对其他服务器不影响。<li>在线定位(一般小点儿公司用不到)。<li>在测试环境中压测（产生类似内存增长问题，在堆还不是很大的时候进行转储）。</ol></blockquote><p><strong>8）重新运行测试程序。</strong><p><code>java -Xms20M -Xmx20M -XX:+UseParallelGC -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/opt/test_jvm/gc_out/ FullGC_Problem01</code><p><strong>9）分析dump文件。</strong><p>使用<code>MAT、jhat、jvisualvm</code>工具来分析dump文件。<p>执行命令<code>jhat -J-Xmx512M xxx.hprof</code>后会在7000端口开启一个服务，通过浏览器可以访问该服务并对其执行相关操作，比如可以使用OQL查找特定问题对象。<p><strong>10）找出代码问题。</strong><h2 id=3-6、OOM问题案例><a class=headerlink href=#3-6、OOM问题案例 title=3.6、OOM问题案例></a>3.6、OOM问题案例</h2><h3 id=3-6-1、堆内存溢出><a class=headerlink href=#3-6-1、堆内存溢出 title=3.6.1、堆内存溢出></a>3.6.1、堆内存溢出</h3><p><strong>（1）创建了大且多的对象</strong><h3 id=3-6-2、方法区内存溢出><a class=headerlink href=#3-6-2、方法区内存溢出 title=3.6.2、方法区内存溢出></a>3.6.2、方法区内存溢出</h3><p><strong>（1）动态生成类</strong><h3 id=3-6-3、栈溢出><a class=headerlink href=#3-6-3、栈溢出 title=3.6.3、栈溢出></a>3.6.3、栈溢出</h3><p><strong>（1）递归深度多大</strong><h3 id=3-6-4、直接内存溢出><a class=headerlink href=#3-6-4、直接内存溢出 title=3.6.4、直接内存溢出></a>3.6.4、直接内存溢出</h3><p><strong>（1）NIO操作</strong><h3 id=3-6-5、其它><a class=headerlink href=#3-6-5、其它 title=3.6.5、其它></a>3.6.5、其它</h3><p><strong>（1）创建大量线程</strong><p><strong>（2）连接池多且大，且连接没有关闭</strong><p><strong>（3）第三方库问题，或使用不当造成</strong><h2 id=3-7、垃圾回收器调优><a class=headerlink href=#3-7、垃圾回收器调优 title=3.7、垃圾回收器调优></a>3.7、垃圾回收器调优</h2><h3 id=3-7-1、G1调优><a class=headerlink href=#3-7-1、G1调优 title=3.7.1、G1调优></a>3.7.1、G1调优</h3><p>触发FGC的情况如下：<p><strong>（1）并发模式失败</strong><p>G1启动标记周期，但在Mix GC之前，老年代就被填满，此时G1会放弃标记周期。这种情形下，需要增加堆大小，或者调整周期（例如增加线程数-XX:ConcGCThreads等）。<p><strong>（2）晋升失败或疏散失败</strong><p><strong>G1 GC时如果没有足够的内存供存活对象或晋升对象使用时会触发Full GC。可以在日志中看到（to-space exhausted）或者（to-space overflow）。</strong>解决该问题的方式如下：<ol><li>增加参数<code>-XX:G1ReservePercent</code>的值（并相应增加总的堆大小），为“目标空间”增加预留内存。<li>减少参数<code>-XX:InitiatingHeapOccupancyPercent</code>的值，提前启动标记周期。<li>增加参数<code>-XX:ConcGCThreads</code>的值，增加并行标记线程的数目。</ol><p><strong>（3）巨型对象分配失败</strong><p>当巨型对象找不到空闲空间分配时会触发Full GC来释放空间。这种情况下，应该避免分配大量的巨型对象，增加内存或者增大<code>-XX:G1HeapRegionSize</code>，使巨型对象不再是巨型对象。<h2 id=3-8、场景分析优化><a class=headerlink href=#3-8、场景分析优化 title=3.8、场景分析优化></a>3.8、场景分析优化</h2><h3 id=3-8-1、卡慢场景><a class=headerlink href=#3-8-1、卡慢场景 title=3.8.1、卡慢场景></a>3.8.1、卡慢场景</h3><p><strong>场景1</strong>：原服务器32位、1.5G内存堆，用户反馈慢。优化升级为64位、16G内存堆后，反馈更慢，反而不如从前。<p><strong>1）原网站为啥慢？</strong><p>多用户访问数据，故大量数据加载至内存，从而造成内存不足、频繁GC、STW长、响应时间慢等问题。<p><strong>2）为什么会卡顿？</strong><p>内存越大，FGC时间就会越长。<p><strong>3）如何应对？</strong><p>PS 更改为 PN + CMS 或者 G1。<h3 id=3-8-2、CPU消耗高问题><a class=headerlink href=#3-8-2、CPU消耗高问题 title=3.8.2、CPU消耗高问题></a>3.8.2、CPU消耗高问题</h3><p>场景1：系统CPU经常100%，如何调优？<p>解决方案参考如下：<ol><li>找出消耗CPU较高的进程；可使用 top 命令查看。<li>该进程中哪个线程消耗CPU较高；可使用 top -Hp 命令查看。<li>导出该线程的堆栈；可使用 jstack 命令实现。<li>查找哪个方法（栈帧）导致的问题。<li>工作线程占比高 | 垃圾回收线程占比高。</ol><h3 id=3-8-3、内存消耗高问题><a class=headerlink href=#3-8-3、内存消耗高问题 title=3.8.3、内存消耗高问题></a>3.8.3、内存消耗高问题</h3><p>场景1：系统内存飙高，如何定位及应对？<p>参考解决方案如下：<ol><li>堆栈比较多，导出堆信息；可使用 jmap 命令实现。<li>通过工具分析，分析工具有：jhat、jvisualvm、mat、jprofiler等。</ol><h3 id=3-8-4、如何监控JVM><a class=headerlink href=#3-8-4、如何监控JVM title=3.8.4、如何监控JVM></a>3.8.4、如何监控JVM</h3><p>工具：jstat、jvisualvm、jprofiler、arthas、top。</div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/10/12/Java%E4%B9%8BASM%E7%9F%A5%E8%AF%86%E7%AF%87/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/10/12/Java%E4%B9%8BASM%E7%9F%A5%E8%AF%86%E7%AF%87/ itemprop=url>Java系列-ASM</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-10-12 11:23:46" datetime=2024-10-12T11:23:46+08:00>2024-10-12</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-06 10:57:52" datetime=2023-08-06T10:57:52+08:00 itemprop=dateModified>2023-08-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/ASM/ itemprop=url rel=index><span itemprop=name>ASM</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=0、前言><a class=headerlink href=#0、前言 title=0、前言></a>0、前言</h1><p>本文档基于ASM4.0来分析。<h1 id=1、简介><a class=headerlink href=#1、简介 title=1、简介></a>1、简介</h1><h2 id=1-1、简析><a class=headerlink href=#1-1、简析 title=1.1、简析></a>1.1、简析</h2><p>ASM不是生成和转换已编译Java的唯一工具类，但它是最新且有效的类之一。其主要优点如下：<ol><li>它具有易使用、简单、精心设计的模块化API。<li>并且具有关联的Eclipse插件。<li>它支持最新的Java版本Java 7<li>它体积小，速度快且非常稳定。<li>庞大的社区支持。<li>完全开源。</ol><h2 id=1-2、总述><a class=headerlink href=#1-2、总述 title=1.2、总述></a>1.2、总述</h2><h3 id=1-2-1、作用域><a class=headerlink href=#1-2-1、作用域 title=1.2.1、作用域></a>1.2.1、作用域</h3><p>ASM库的目标是生成、转换和分析以字节数组表示的已编译Java类（因为它们存储在磁盘上并已加载到Java虚拟机中）。为此，ASM提供了使用比字节更高的概念来读取，写入和转换此类字节数组的工具，例如数字常量，字符串，Java标识符，Java类型，Java类结构元素等。请注意，ASM的范围图书馆严格限于阅读，写作，转换和分析类。特别是类加载过程超出了范围。<h3 id=1-2-2、模块><a class=headerlink href=#1-2-2、模块 title=1.2.2、模块></a>1.2.2、模块</h3><p>ASM库提供了两个用于生成和转换已编译类的API：核心API提供基于事件的类表示，而树API提供基于对象的表示。<p>这两个API可以与XML文档的简单API（SAX）和XML文档的文档对象模型（DOM）API进行比较：基于事件的API与SAX类似，而基于对象的API与DOM类似。基于对象的API建立在基于事件的API之上，就像可以在SAX之上提供DOM一样。<p>优缺点：<ul><li>与基于对象的API相比，基于事件的API更快，并且所需的内存更少，因为不需要创建并在内存中存储代表该类的对象树（SAX和DOM之间也存在相同的区别）。<li>但是，使用基于事件的API来实现类转换可能会更加困难，因为在任何给定时间只有该类的一个元素（与当前事件相对应的元素）才可用，而整个类可以在基于对象的内存中使用API。</ul><h3 id=1-2-3、结构><a class=headerlink href=#1-2-3、结构 title=1.2.3、结构></a>1.2.3、结构</h3><p>ASM应用程序具有强大的体系结构方面。实际上，基于事件的API是围绕事件生成器（类解析器），事件使用者（类编写器）和各种预定义的事件过滤器组织的，可以向其中添加用户定义的生产者，使用者和过滤器。因此，使用此API分为两个步骤：<ol><li>将事件产生器，过滤器和使用者组件组装成可能复杂的架构。<li>然后启动事件生产者以运行生成或转换过程。</ol><h2 id=1-3、组织><a class=headerlink href=#1-3、组织 title=1.3、组织></a>1.3、组织</h2><p>ASM库组织在几个包中，这些包分布在几个jar文件中：<ol><li>asm.jar<li>asm-util.jar<li>asm-commons.jar<li>asm-tree.jar<li>asm-analysis.jar</ol><h1 id=2、类><a class=headerlink href=#2、类 title=2、类></a>2、类</h1><h2 id=2-1、结构><a class=headerlink href=#2-1、结构 title=2.1、结构></a>2.1、结构</h2><h3 id=2-1-3、类型描述符><a class=headerlink href=#2-1-3、类型描述符 title=2.1.3、类型描述符></a>2.1.3、类型描述符</h3><p>内部名称仅用于约束为类或接口类型的类型。在所有其他情况下，例如字段类型，Java类型都在带有类型描述符的已编译类中表示：<p><img alt=image-20200905140752294 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200905140752294.png?token=AIGEF3IRGWSRIZT72N35LHDEZZZXO><h3 id=2-1-4、方法描述符><a class=headerlink href=#2-1-4、方法描述符 title=2.1.4、方法描述符></a>2.1.4、方法描述符</h3><p>方法描述符是类型描述符的列表，这些类型描述符在单个字符串中描述方法的参数类型和返回类型。方法描述符以左括号开头，然后是每个形式参数的类型描述符，然后是右括号，然后是返回类型的类型描述符，如果该方法返回void，则返回V（方法描述符不包含方法名称或参数名称）。<p><img alt=image-20200905141030231 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200905141030231.png?token=AIGEF3NN3ZCLCO7OIRB5P5TEZZZYO><h2 id=2-2、接口与组件><a class=headerlink href=#2-2、接口与组件 title=2.2、接口与组件></a>2.2、接口与组件</h2><h3 id=2-2-1、简介><a class=headerlink href=#2-2-1、简介 title=2.2.1、简介></a>2.2.1、简介</h3><p>用于生成和转换已编译类的 ASM API 基于 ClassVisitor 抽象类。此类中的每个方法都对应于同名的类文件结构部分。通过单个方法调用可以访问简单部分，该方法的参数描述其内容，并返回void。使用初始方法调用（其返回辅助访问者类）访问其内容可以具有任意长度和复杂度的节。 visitAnnotation，visitField和visitMethod方法就是这种情况，它们分别返回AnnotationVisitor，FieldVisitor和MethodVisitor。<p>这些辅助类递归使用相同的原理。例如，FieldVisitor抽象类中的每个方法（请参见图2.5）对应于具有相同名称的类文件子结构，并且与ClassVisitor中一样，返回一个辅助AnnotationVisitor。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ClassVisitor</span><span class=params>(<span class=type>int</span> api)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ClassVisitor</span><span class=params>(<span class=type>int</span> api, ClassVisitor cv)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(<span class=type>int</span> version, <span class=type>int</span> access, String name,String signature, String superName, String[] interfaces)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitSource</span><span class=params>(String source, String debug)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitOuterClass</span><span class=params>(String owner, String name, String desc)</span>;</span><br><span class=line>    AnnotationVisitor <span class="title function_">visitAnnotation</span><span class=params>(String desc, <span class=type>boolean</span> visible)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitAttribute</span><span class=params>(Attribute attr)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInnerClass</span><span class=params>(String name, String outerName,String innerName, <span class=type>int</span> access)</span>;</span><br><span class=line>    <span class=keyword>public</span> FieldVisitor <span class="title function_">visitField</span><span class=params>(<span class=type>int</span> access, String name, String desc,String signature, Object value)</span>;</span><br><span class=line>    <span class=keyword>public</span> MethodVisitor <span class="title function_">visitMethod</span><span class=params>(<span class=type>int</span> access, String name, String desc,String signature, String[] exceptions)</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">FieldVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">FieldVisitor</span><span class=params>(<span class=type>int</span> api)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">FieldVisitor</span><span class=params>(<span class=type>int</span> api, FieldVisitor fv)</span>;</span><br><span class=line>    <span class=keyword>public</span> AnnotationVisitor <span class="title function_">visitAnnotation</span><span class=params>(String desc, <span class=type>boolean</span> visible)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitAttribute</span><span class=params>(Attribute attr)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><p>ASM提供了三个基于ClassVisitor API的核心组件，用于生成和转换类：<ol><li>ClassReader类解析以字节数组形式给出的已编译类，并在作为参数传递给其accept方法的ClassVisitor实例上调用相应的visitXxx方法。可以将其视为事件产生器。<li>ClassWriter类是ClassVisitor抽象类的子类，该类直接以二进制形式构建编译的类。它产生包含已编译类的字节数组作为输出，可以使用toByteArray方法进行检索。可以将其视为事件消费者。<li>ClassVisitor类将它收到的所有方法调用委托给另一个ClassVisitor实例。可以将其视为事件过滤器。</ol><h3 id=2-2-2、解析类><a class=headerlink href=#2-2-2、解析类 title=2.2.2、解析类></a>2.2.2、解析类</h3><p>解析现有类的唯一必需组件是ClassReader组件。让我们以一个例子来说明这一点。假设我们希望以类似于javap工具的方式打印类的内容。第一步是编写ClassVisitor类的子类，该子类打印有关其访问的类的信息。这是一个可能的，过于简化的实现：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ClassPrinter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ClassPrinter</span><span class=params>()</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(<span class=type>int</span> version, <span class=type>int</span> access, String name,String signature, String superName, String[] interfaces)</span> {</span><br><span class=line>    	System.out.println(name + <span class=string>" extends "</span> + superName + <span class=string>" {"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitSource</span><span class=params>(String source, String debug)</span> {}</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitOuterClass</span><span class=params>(String owner, String name, String desc)</span> {}</span><br><span class=line>    <span class=keyword>public</span> AnnotationVisitor <span class="title function_">visitAnnotation</span><span class=params>(String desc,<span class=type>boolean</span> visible)</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitAttribute</span><span class=params>(Attribute attr)</span> {}</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInnerClass</span><span class=params>(String name, String outerName, String innerName, <span class=type>int</span> access)</span> {}</span><br><span class=line>    <span class=keyword>public</span> FieldVisitor <span class="title function_">visitField</span><span class=params>(<span class=type>int</span> access, String name, String desc,String signature, Object value)</span> {</span><br><span class=line>    	System.out.println(<span class=string>" "</span> + desc + <span class=string>" "</span> + name);</span><br><span class=line>    	<span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> MethodVisitor <span class="title function_">visitMethod</span><span class=params>(<span class=type>int</span> access, String name,String desc, String signature, String[] exceptions)</span> {</span><br><span class=line>    	System.out.println(<span class=string>" "</span> + name + desc);</span><br><span class=line>    	<span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span> {</span><br><span class=line>    	System.out.println(<span class=string>"}"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><p>第二步是将该ClassPrinter与ClassReader组件结合起来，以便ClassReader产生的事件由我们的ClassPrinter消耗：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>ClassPrinter</span> <span class=variable>cp</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPrinter</span>();</span><br><span class=line><span class=type>ClassReader</span> <span class=variable>cr</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassReader</span>(<span class=string>"java.lang.Runnable"</span>);</span><br><span class=line>cr.accept(cp, <span class=number>0</span>);</span><br></pre></table></figure><p>请注意，有几种方法可以构造ClassReader实例。可以通过名称（如上所述）或通过值（字节数组或InputStream）指定必须读取的类。可以使用ClassLoader的getResourceAsStream方法通过以下方式获取用于读取类内容的输入流：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>cl.getResourceAsStream(classname.replace(’.’, ’/’) + <span class=string>".class"</span>);</span><br></pre></table></figure><h3 id=2-2-3、生成类><a class=headerlink href=#2-2-3、生成类 title=2.2.3、生成类></a>2.2.3、生成类</h3><p>生成类的唯一必需组件是ClassWriter组件。让我们以一个例子来说明这一点。考虑以下接口：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Comparable</span> <span class=keyword>extends</span> <span class="title class_">Mesurable</span> {</span><br><span class=line>    <span class=type>int</span> <span class=variable>LESS</span> <span class=operator>=</span> -<span class=number>1</span>;</span><br><span class=line>    <span class=type>int</span> <span class=variable>EQUAL</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=type>int</span> <span class=variable>GREATER</span> <span class=operator>=</span> <span class=number>1</span>;</span><br><span class=line>    <span class=type>int</span> <span class="title function_">compareTo</span><span class=params>(Object o)</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>它可以通过对ClassVisitor的六个方法调用来生成：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line>cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, <span class=string>"pkg/Comparable"</span>, <span class=literal>null</span>, <span class=string>"java/lang/Object"</span>,<span class=keyword>new</span> <span class="title class_">String</span>[] { <span class=string>"pkg/Mesurable"</span> });</span><br><span class=line>cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class=string>"LESS"</span>, <span class=string>"I"</span>, <span class=literal>null</span>, <span class=keyword>new</span> <span class="title class_">Integer</span>(-<span class=number>1</span>)).visitEnd();</span><br><span class=line>cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class=string>"EQUAL"</span>, <span class=string>"I"</span>, <span class=literal>null</span>, <span class=keyword>new</span> <span class="title class_">Integer</span>(<span class=number>0</span>)).visitEnd();</span><br><span class=line>cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class=string>"GREATER"</span>, <span class=string>"I"</span>, <span class=literal>null</span>, <span class=keyword>new</span> <span class="title class_">Integer</span>(<span class=number>1</span>)).visitEnd();</span><br><span class=line>cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, <span class=string>"compareTo"</span>, <span class=string>"(Ljava/lang/Object;)I"</span>, <span class=literal>null</span>, <span class=literal>null</span>).visitEnd();</span><br><span class=line>cw.visitEnd();</span><br><span class=line><span class=type>byte</span>[] b = cw.toByteArray();</span><br></pre></table></figure><h4 id=2-2-3-1、使用生成的类：><a class=headerlink href=#2-2-3-1、使用生成的类： title=2.2.3.1、使用生成的类：></a>2.2.3.1、使用生成的类：</h4><p>先前的字节数组可以存储在Comparable.class文件中，以备将来使用。另外，也可以使用ClassLoader动态加载它。一种方法是定义ClassLoader子类，其defineClass方法是公共的：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">MyClassLoader</span> <span class=keyword>extends</span> <span class="title class_">ClassLoader</span> {</span><br><span class=line>    <span class=keyword>public</span> Class <span class="title function_">defineClass</span><span class=params>(String name, <span class=type>byte</span>[] b)</span> {</span><br><span class=line>    	<span class=keyword>return</span> defineClass(name, b, <span class=number>0</span>, b.length);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><p>然后，可以使用以下命令直接加载生成的类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>Class</span> <span class=variable>c</span> <span class=operator>=</span> myClassLoader.defineClass(<span class=string>"pkg.Comparable"</span>, b);</span><br></pre></table></figure><p>加载生成的类的另一种方法（可能更干净）是定义ClassLoader子类，该类的findClass方法被重写，以便动态生成请求的类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">StubClassLoader</span> <span class=keyword>extends</span> <span class="title class_">ClassLoader</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> Class <span class="title function_">findClass</span><span class=params>(String name)</span> <span class=keyword>throws</span> ClassNotFoundException {</span><br><span class=line>        <span class=keyword>if</span> (name.endsWith(<span class=string>"_Stub"</span>)) {</span><br><span class=line>            <span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line>            <span class=comment>//...</span></span><br><span class=line>            <span class=type>byte</span>[] b = cw.toByteArray();</span><br><span class=line>            <span class=keyword>return</span> defineClass(name, b, <span class=number>0</span>, b.length);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>super</span>.findClass(name);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>实际上，使用生成的类的方式取决于上下文，并且超出了ASM API的范围。如果正在编写编译器，则类生成过程将由表示要编译的程序的抽象语法树驱动，并且生成的类将存储在磁盘上。如果要编写动态代理类生成器或Aspect Weaver，则将以一种或另一种方式使用ClassLoader。<h3 id=2-2-4、转换类><a class=headerlink href=#2-2-4、转换类 title=2.2.4、转换类></a>2.2.4、转换类</h3><p>到目前为止，仅单独使用了ClassReader和ClassWriter组件。这些事件是“手动”产生的，并由ClassWriter直接消耗，或者对称地，它们是由ClassReader产生并“手动”消耗的，即由自定义的ClassVisitor实现。当这些组件一起使用时，事情开始变得非常有趣。第一步是将ClassReader产生的事件定向到ClassWriter。结果是由类编写器重构了由类读取器解析的类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=type>byte</span>[] b1 = ...;</span><br><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line><span class=type>ClassReader</span> <span class=variable>cr</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassReader</span>(b1);</span><br><span class=line>cr.accept(cw, <span class=number>0</span>);</span><br><span class=line><span class=type>byte</span>[] b2 = cw.toByteArray();  <span class=comment>// b2 represents the same class as b1</span></span><br></pre></table></figure><p>下一步是在类读取器和类写入器之间引入ClassVisitor：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>byte</span>[] b1 = ...;</span><br><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line><span class=comment>// cv forwards all events to cw</span></span><br><span class=line><span class=type>ClassVisitor</span> <span class=variable>cv</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassVisitor</span>(ASM4, cw) { };</span><br><span class=line><span class=type>ClassReader</span> <span class=variable>cr</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassReader</span>(b1);</span><br><span class=line>cr.accept(cv, <span class=number>0</span>);</span><br><span class=line><span class=type>byte</span>[] b2 = cw.toByteArray(); <span class=comment>// b2 represents the same class as b1</span></span><br></pre></table></figure><p>但是，结果不会改变，因为ClassVisitor事件过滤器不过滤任何内容。但是，现在可以通过重写某些方法来过滤某些事件，以便能够转换类。例如，考虑以下ClassVisitor子类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ChangeVersionAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ChangeVersionAdapter</span><span class=params>(ClassVisitor cv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(<span class=type>int</span> version, <span class=type>int</span> access, String name, String signature, String superName, String[] interfaces)</span> {</span><br><span class=line>    	cv.visit(V1_5, access, name, signature, superName, interfaces);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>此类仅覆盖ClassVisitor类的一个方法。结果，除了对visit方法的调用之外，所有调用均以不变的方式转发给传递给构造函数的类visitor cv，后者以修改后的类版本号转发。<h4 id=2-2-4-1、优化><a class=headerlink href=#2-2-4-1、优化 title=2.2.4.1、优化></a>2.2.4.1、优化</h4><p>上一个转换仅更改原始类中的四个字节。但是，使用上面的代码，b1被完全解析，并且相应的事件用于从头开始构造b2，这不是很有效。复制不直接转换为b2的b1部分，而无需解析这些部分并且不生成相应的事件，将更加有效。 ASM自动为方法执行此优化：<ol><li>如果ClassReader组件检测到作为参数传递给其accept方法的ClassVisitor返回的MethodVisitor来自ClassWriter，则这意味着该方法的内容将不会被转换，并且实际上甚至不会被应用程序看到。<li>在这种情况下，ClassReader组件不会解析此方法的内容，不会生成相应的事件，而只是复制ClassWriter中此方法的字节数组表示形式</ol><p>如果ClassReader和ClassWriter组件具有相互引用，则可以通过以下方式进行此优化：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=type>byte</span>[] b1 = ...</span><br><span class=line><span class=type>ClassReader</span> <span class=variable>cr</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassReader</span>(b1);</span><br><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(cr, <span class=number>0</span>);</span><br><span class=line><span class=type>ChangeVersionAdapter</span> <span class=variable>ca</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ChangeVersionAdapter</span>(cw);</span><br><span class=line>cr.accept(ca, <span class=number>0</span>);</span><br><span class=line><span class=type>byte</span>[] b2 = cw.toByteArray();</span><br></pre></table></figure><h4 id=2-2-4-2、使用转换类><a class=headerlink href=#2-2-4-2、使用转换类 title=2.2.4.2、使用转换类></a>2.2.4.2、使用转换类</h4><p>可以将转换后的类b2存储在磁盘上或用ClassLoader加载。但是在ClassLoader内部完成的类转换只能转换由此类加载器加载的类。如果要转换所有类，则必须将转换放入ClassFileTransformer内，如java.lang.instrument包中所定义（有关更多详细信息，请参见此包的文档）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">premain</span><span class=params>(String agentArgs, Instrumentation inst)</span> {</span><br><span class=line>    inst.addTransformer(<span class=keyword>new</span> <span class="title class_">ClassFileTransformer</span>() {</span><br><span class=line>    	<span class=keyword>public</span> <span class=type>byte</span>[] transform(ClassLoader l, String name, Class c, ProtectionDomain d, <span class=type>byte</span>[] b)<span class=keyword>throws</span> IllegalClassFormatException {</span><br><span class=line>            <span class=type>ClassReader</span> <span class=variable>cr</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassReader</span>(b);</span><br><span class=line>            <span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(cr, <span class=number>0</span>);</span><br><span class=line>            <span class=type>ClassVisitor</span> <span class=variable>cv</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ChangeVersionAdapter</span>(cw);</span><br><span class=line>            cr.accept(cv, <span class=number>0</span>);</span><br><span class=line>            <span class=keyword>return</span> cw.toByteArray();</span><br><span class=line>    	}</span><br><span class=line>    });</span><br><span class=line>}</span><br></pre></table></figure><h3 id=2-2-5、删除类成员><a class=headerlink href=#2-2-5、删除类成员 title=2.2.5、删除类成员></a>2.2.5、删除类成员</h3><p>例如，以下类适配器删除有关外部类和内部类的信息，以及从中编译该类的源文件的名称（生成的类保持完整的功能，因为这些元素仅用于调试目的）。这是通过不以适当的访问方法转发任何内容来完成的：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoveDebugAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RemoveDebugAdapter</span><span class=params>(ClassVisitor cv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitSource</span><span class=params>(String source, String debug)</span> {}</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitOuterClass</span><span class=params>(String owner, String name, String desc)</span> {}</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInnerClass</span><span class=params>(String name, String outerName, String innerName, <span class=type>int</span> access)</span> {}</span><br><span class=line>}</span><br></pre></table></figure><p>该策略不适用于字段和方法，因为visitField和visitMethod方法必须返回结果。为了删除字段或方法，您必须不要转发方法调用，并且必须将null返回给调用方。例如，以下类适配器删除由其名称和其描述符指定的单个方法（该名称不足以标识一个方法，因为一个类可以包含多个同名但参数不同的方法）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoveMethodAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>private</span> String mName;</span><br><span class=line>    <span class=keyword>private</span> String mDesc;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RemoveMethodAdapter</span><span class=params>(ClassVisitor cv, String mName, String mDesc)</span> {</span><br><span class=line>        <span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>        <span class=built_in>this</span>.mName = mName;</span><br><span class=line>        <span class=built_in>this</span>.mDesc = mDesc;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> MethodVisitor <span class="title function_">visitMethod</span><span class=params>(<span class=type>int</span> access, String name, String desc, String signature, String[] exceptions)</span> {</span><br><span class=line>        <span class=keyword>if</span> (name.equals(mName) && desc.equals(mDesc)) {</span><br><span class=line>            <span class=comment>// do not delegate to next visitor -> this removes the method</span></span><br><span class=line>            <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=2-2-6、添加类成员><a class=headerlink href=#2-2-6、添加类成员 title=2.2.6、添加类成员></a>2.2.6、添加类成员</h3><p>这里是一个类适配器，它将一个字段添加到类中，除非该字段已经存在：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AddFieldAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> fAcc;</span><br><span class=line>    <span class=keyword>private</span> String fName;</span><br><span class=line>    <span class=keyword>private</span> String fDesc;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>boolean</span> isFieldPresent;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AddFieldAdapter</span><span class=params>(ClassVisitor cv, <span class=type>int</span> fAcc, String fName, String fDesc)</span> {</span><br><span class=line>        <span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>        <span class=built_in>this</span>.fAcc = fAcc;</span><br><span class=line>        <span class=built_in>this</span>.fName = fName;</span><br><span class=line>        <span class=built_in>this</span>.fDesc = fDesc;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> FieldVisitor <span class="title function_">visitField</span><span class=params>(<span class=type>int</span> access, String name, String desc, String signature, Object value)</span> {</span><br><span class=line>        <span class=keyword>if</span> (name.equals(fName)) {</span><br><span class=line>            isFieldPresent = <span class=literal>true</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cv.visitField(access, name, desc, signature, value);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>if</span> (!isFieldPresent) {</span><br><span class=line>            <span class=type>FieldVisitor</span> <span class=variable>fv</span> <span class=operator>=</span> cv.visitField(fAcc, fName, fDesc, <span class=literal>null</span>, <span class=literal>null</span>);</span><br><span class=line>            <span class=keyword>if</span> (fv != <span class=literal>null</span>) {</span><br><span class=line>            	fv.visitEnd();</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        cv.visitEnd();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=2-2-7、转型链><a class=headerlink href=#2-2-7、转型链 title=2.2.7、转型链></a>2.2.7、转型链</h3><p>到目前为止，我们已经看到了由ClassReader，类适配器和ClassWriter组成的简单转换链。当然，可以使用更复杂的链，将多个类适配器链在一起。链接多个适配器可让您组成多个独立的类转换，以执行复杂的转换。还要注意，转换链不一定是线性的。您可以编写一个ClassVisitor，将它同时收到的所有方法调用转发到多个ClassVisitor：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MultiClassAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>protected</span> ClassVisitor[] cvs;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MultiClassAdapter</span><span class=params>(ClassVisitor[] cvs)</span> {</span><br><span class=line>        <span class=built_in>super</span>(ASM4);</span><br><span class=line>        <span class=built_in>this</span>.cvs = cvs;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(<span class=type>int</span> version, <span class=type>int</span> access, String name, String signature, String superName, String[] interfaces)</span> {</span><br><span class=line>        <span class=keyword>for</span> (ClassVisitor cv : cvs) {</span><br><span class=line>        	cv.visit(version, access, name, signature, superName, interfaces);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    ...</span><br><span class=line>}</span><br></pre></table></figure><h2 id=2-3、工具><a class=headerlink href=#2-3、工具 title=2.3、工具></a>2.3、工具</h2><h3 id=2-3-1、Type><a class=headerlink href=#2-3-1、Type title=2.3.1、Type></a>2.3.1、Type</h3><p>如前几节所述，ASM API公开了Java类型，因为它们存储在编译的类中，即作为内部名称或类型描述符。可以将它们公开显示在源代码中，以使代码更具可读性。但这需要在ClassReader和ClassWriter中的两种表示形式之间进行系统的转换，这会降低性能。这就是ASM不会将内部名称和类型描述符透明转换为等效的源代码形式的原因。但是，它提供了Type类，以便在必要时手动执行此操作。<p>Type对象表示Java类型，可以从类型描述符或从Class对象构造。 Type类还包含表示原始类型的静态变量。例如，Type.INT_TYPE是表示int类型的Type对象。<h3 id=2-3-2、TraceClassVisitor><a class=headerlink href=#2-3-2、TraceClassVisitor title=2.3.2、TraceClassVisitor></a>2.3.2、TraceClassVisitor</h3><p>为了检查生成的或转换的类是否符合您的期望，ClassWriter返回的字节数组并没有真正的帮助，因为它是人类无法读取的。文本表示将更易于使用。这是TraceClassVisitor类提供的。顾名思义，该类扩展了ClassVisitor类，并构造了所访问类的文本表示形式。因此，可以使用TraceClassVisitor而不是使用ClassWriter来生成类，以便获得对实际生成内容的可读记录。或者，甚至更好的是，您可以同时使用两者。实际上，TraceClassVisitor除了其默认行为外，还可以将对其方法的所有调用委派给另一个访问者，例如ClassWriter：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line><span class=type>TraceClassVisitor</span> <span class=variable>cv</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TraceClassVisitor</span>(cw, printWriter);</span><br><span class=line>cv.visit(...);</span><br><span class=line>...</span><br><span class=line>cv.visitEnd();</span><br><span class=line><span class=type>byte</span> b[] = cw.toByteArray();</span><br><span class=line></span><br></pre></table></figure><p>这段代码创建了一个TraceClassVisitor，它将接收到的所有调用委托给cw，并将这些调用的文本表示输出到printWriter。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=comment>// class version 49.0 (49)</span></span><br><span class=line><span class=comment>// access flags 1537</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>interface</span> <span class="title class_">pkg</span>/Comparable <span class=keyword>implements</span> <span class="title class_">pkg</span>/Mesurable {</span><br><span class=line>    <span class=comment>// access flags 25</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>I</span> <span class=variable>LESS</span> <span class=operator>=</span> -<span class=number>1</span></span><br><span class=line>    <span class=comment>// access flags 25</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>I</span> <span class=variable>EQUAL</span> <span class=operator>=</span> <span class=number>0</span></span><br><span class=line>    <span class=comment>// access flags 25</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>I</span> <span class=variable>GREATER</span> <span class=operator>=</span> <span class=number>1</span></span><br><span class=line>    <span class=comment>// access flags 1025</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> <span class="title function_">compareTo</span><span class=params>(Ljava/lang/Object;)</span>I</span><br><span class=line>}</span><br></pre></table></figure><h3 id=2-3-3、CheckClassAdapter><a class=headerlink href=#2-3-3、CheckClassAdapter title=2.3.3、CheckClassAdapter></a>2.3.3、CheckClassAdapter</h3><p>为了检查一个类，打印该类的文本表示形式，最后创建一个字节数组表示形式，您应该使用类似以下内容的方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line><span class=type>TraceClassVisitor</span> <span class=variable>tcv</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TraceClassVisitor</span>(cw, printWriter);</span><br><span class=line><span class=type>CheckClassAdapter</span> <span class=variable>cv</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">CheckClassAdapter</span>(tcv);</span><br><span class=line>cv.visit(...);</span><br><span class=line>...</span><br><span class=line>cv.visitEnd();</span><br><span class=line><span class=type>byte</span> b[] = cw.toByteArray();</span><br></pre></table></figure><p>请注意，如果以不同的顺序链接这些类访问者，则它们执行的操作也将以不同的顺序进行。例如，使用以下代码，检查将在跟踪之后进行：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line><span class=type>CheckClassAdapter</span> <span class=variable>cca</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">CheckClassAdapter</span>(cw);</span><br><span class=line><span class=type>TraceClassVisitor</span> <span class=variable>cv</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TraceClassVisitor</span>(cca, printWriter);</span><br></pre></table></figure><p>与TraceClassVisitor一样，您可以在生成或转换链中的任何点使用CheckClassAdapter，不仅可以在ClassWriter之前使用，还可以在链中此点检查类。<h3 id=2-3-4、ASMifier><a class=headerlink href=#2-3-4、ASMifier title=2.3.4、ASMifier></a>2.3.4、ASMifier</h3><p>可以从命令行使用ASMifier类。例如使用：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>java -classpath asm.jar:asm-util.jar \</span><br><span class=line>org.objectweb.asm.util.ASMifier \</span><br><span class=line>java.lang.Runnable</span><br></pre></table></figure><p>产生缩进后的代码为：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> asm.java.lang;</span><br><span class=line><span class=keyword>import</span> org.objectweb.asm.*;</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RunnableDump</span> <span class=keyword>implements</span> <span class="title class_">Opcodes</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=type>byte</span>[] dump() <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line>        FieldVisitor fv;</span><br><span class=line>        MethodVisitor mv;</span><br><span class=line>        AnnotationVisitor av0;</span><br><span class=line>        cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, <span class=string>"java/lang/Runnable"</span>, <span class=literal>null</span>, <span class=string>"java/lang/Object"</span>, <span class=literal>null</span>);</span><br><span class=line>    {</span><br><span class=line>        mv = cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, <span class=string>"run"</span>, <span class=string>"()V"</span>, <span class=literal>null</span>, <span class=literal>null</span>);</span><br><span class=line>        mv.visitEnd();</span><br><span class=line>    }</span><br><span class=line>    cw.visitEnd();</span><br><span class=line>    <span class=keyword>return</span> cw.toByteArray();</span><br><span class=line>}</span><br></pre></table></figure><h1 id=3、方法><a class=headerlink href=#3、方法 title=3、方法></a>3、方法</h1><p>本章介绍如何使用核心ASM API生成和转换编译方法。它首先介绍了已编译的方法，然后提供了许多说明性示例，介绍了相应的ASM接口，组件以及生成和转换它们的工具。<h2 id=3-1、结构><a class=headerlink href=#3-1、结构 title=3.1、结构></a>3.1、结构</h2><p>在已编译的类中，方法的代码存储为一系列字节码指令。为了生成和转换类，了解这些指令并理解它们的工作原理至关重要。<h3 id=3-1-1、执行模式><a class=headerlink href=#3-1-1、执行模式 title=3.1.1、执行模式></a>3.1.1、执行模式</h3><p>在呈现字节码指令之前，必须呈现Java虚拟机执行模型。如您所知，Java代码是在线程内部执行的。每个线程都有其自己的执行堆栈，该堆栈由框架组成。每个框架代表一个方法调用：每次调用一个方法时，都会在当前线程的执行堆栈上推送一个新框架。当方法返回时，无论是正常情况还是由于异常而返回，都会从执行堆栈弹出该框架，并在调用方法中继续执行（其框架现在位于堆栈的顶部）。<p>局部变量和操作数堆栈部分的大小取决于方法的代码。它是在编译时计算的，并与字节码指令一起存储在已编译的类中。结果，与给定方法的调用相对应的所有框架都具有相同的大小，但是与不同方法相对应的框架的局部变量和操作数堆栈部分可以具有不同的大小。<h3 id=3-1-2、字节码指令><a class=headerlink href=#3-1-2、字节码指令 title=3.1.2、字节码指令></a>3.1.2、字节码指令</h3><p>字节码指令由标识该指令的操作码和固定数量的参数组成：<ul><li>操作码是一个无符号的字节值（因此为字节码名称），并由助记符标识。例如，操作码值0由助记符NOP设计，并且对应于不执行任何操作的指令。<li>参数是定义精确指令行为的静态值。它们在操作码之后给出。例如，操作码值为167的GOTO标签指令将自变量标签指定为要执行的下一条指令。指令参数不能与指令操作数混淆：参数值是静态已知的，并存储在编译后的代码中，而操作数值来自操作数堆栈，并且仅在运行时才知道。</ul><p>字节码指令可分为两类：一小组指令旨在将值从局部变量传输到操作数堆栈，反之亦然；其他指令仅作用于操作数堆栈：它们从堆栈中弹出一些值，根据这些值计算结果，然后将其推回堆栈。<p>所有其他字节码指令仅在操作数堆栈上工作。它们可以分为以下类别：<ul><li>Stack<li>Constants<li>Arithmetic and logic<li>Casts<li>Objects<li>Fields<li>Methods<li>Arrays<li>Jumps<li>Return</ul><h3 id=3-1-3、实例><a class=headerlink href=#3-1-3、实例 title=3.1.3、实例></a>3.1.3、实例</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> pkg;</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Bean</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> f;</span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">getF</span><span class=params>()</span> {</span><br><span class=line>    	<span class=keyword>return</span> <span class=built_in>this</span>.f;</span><br><span class=line>    }	</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setF</span><span class=params>(<span class=type>int</span> f)</span> {</span><br><span class=line>    	<span class=built_in>this</span>.f = f;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>getter方法的字节码为：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>ALOAD <span class=number>0</span></span><br><span class=line>GETFIELD pkg/Bean f I</span><br><span class=line>IRETURN</span><br></pre></table></figure><p>第一条指令读取局部变量0，该局部变量在创建此方法调用的帧期间已初始化为0，并将此值压入操作数堆栈。第二条指令从堆栈中弹出此值，即this，并压入此对象的f字段，即this.f.最后一条指令从堆栈中弹出该值，并将其返回给调用方。此方法的执行帧的连续状态如下图所示：<p><img alt=image-20200906150115558 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200906150115558.png?token=AIGEF3PER5BJHXJG27CVUGDEZZZ2Q><p>setter方法的字节码为：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>ALOAD <span class=number>0</span></span><br><span class=line>ILOAD <span class=number>1</span></span><br><span class=line>PUTFIELD pkg/Bean f I</span><br><span class=line>RETURN</span><br></pre></table></figure><p>第一条指令将其压入操作数堆栈。第二条指令压入局部变量1，该局部变量在创建用于此方法调用的框架期间使用f参数值初始化。第三条指令弹出这两个值，并将int值存储在所引用对象的f字段中，即在this.f中。最后一条指令在源代码中是隐式的，而在编译后的代码中是强制性的，它会破坏当前执行框架并返回给调用者。此方法的执行帧的连续状态如图3.3所示。<p><img alt=image-20200906150426003 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200906150426003.png?token=AIGEF3MGQCPQK5TETM4YJWDEZZZ32><p>现在让我们考虑一个稍微复杂一些的setter方法<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">checkAndSetF</span><span class=params>(<span class=type>int</span> f)</span> {</span><br><span class=line>    <span class=keyword>if</span> (f >= <span class=number>0</span>) {</span><br><span class=line>    	<span class=built_in>this</span>.f = f;</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>    	<span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>对应字节码如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line>    ILOAD <span class=number>1</span></span><br><span class=line>    IFLT label</span><br><span class=line>    ALOAD <span class=number>0</span></span><br><span class=line>    ILOAD <span class=number>1</span></span><br><span class=line>    PUTFIELD pkg/Bean f I</span><br><span class=line>    GOTO end</span><br><span class=line>label:</span><br><span class=line>    NEW java/lang/IllegalArgumentException</span><br><span class=line>    DUP</span><br><span class=line>    INVOKESPECIAL java/lang/IllegalArgumentException &LTinit> ()V</span><br><span class=line>    ATHROW</span><br><span class=line>end:</span><br><span class=line>	RETURN</span><br></pre></table></figure><h3 id=3-1-4、异常处理><a class=headerlink href=#3-1-4、异常处理 title=3.1.4、异常处理></a>3.1.4、异常处理</h3><p>例如下面的源代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">sleep</span><span class=params>(<span class=type>long</span> d)</span> {</span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>    	Thread.sleep(d);</span><br><span class=line>    } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>    	e.printStackTrace();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>其可以编译成：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>TRYCATCHBLOCK <span class=keyword>try</span> <span class=keyword>catch</span> <span class=keyword>catch</span> java/lang/InterruptedException</span><br><span class=line><span class=keyword>try</span>:</span><br><span class=line>LLOAD <span class=number>0</span></span><br><span class=line>INVOKESTATIC java/lang/Thread <span class="title function_">sleep</span> <span class=params>(J)</span>V</span><br><span class=line>RETURN</span><br><span class=line><span class=keyword>catch</span>:</span><br><span class=line>INVOKEVIRTUAL java/lang/InterruptedException <span class="title function_">printStackTrace</span> <span class=params>()</span>V</span><br><span class=line>RETURN</span><br></pre></table></figure><h3 id=3-1-5、Frames><a class=headerlink href=#3-1-5、Frames title=3.1.5、Frames></a>3.1.5、Frames</h3><p>例如，如果考虑上一节的getF方法，则可以定义三个堆栈映射框架，这些框架映射框架给出了执行框架的状态，这些状态仅在ALOAD之前，在GETFIELD之前和在IRETURN之前。这三个堆栈映射框架对应于图3.2中所示的三种情况，可以描述如下，其中第一个方括号之间的类型对应于局部变量，其他类型对应于操作数堆栈：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>State of the execution frame before 	Instruction</span><br><span class=line>[pkg/Bean] [] 						  ALOAD <span class=number>0</span></span><br><span class=line>[pkg/Bean] [pkg/Bean] 				   GETFIELD</span><br><span class=line>[pkg/Bean] [I] 						  IRETURN</span><br></pre></table></figure><p>我们可以对checkAndSetF方法做同样的事情：<p><img alt=image-20200906151656565 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200906151656565.png?token=AIGEF3NVDVSTEU3H4PJNRM3EZZZ5W><p>为了节省更多空间，通过仅存储与前一帧的差异来压缩每个帧，并且不存储初始帧，因为它可以很容易地从方法参数类型推导出来。在使用checkAndSetF方法的情况下，必须存储的两个帧相等并且等于初始帧，因此将它们存储为F_SAME助记符指定的单字节值。这些帧可以在它们关联的字节码指令之前被表示。这给出了checkAndSetF方法的最终字节码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line>ILOAD <span class=number>1</span></span><br><span class=line>IFLT label</span><br><span class=line>ALOAD <span class=number>0</span></span><br><span class=line>ILOAD <span class=number>1</span></span><br><span class=line>PUTFIELD pkg/Bean f I</span><br><span class=line>GOTO end</span><br><span class=line>label:</span><br><span class=line>F_SAME</span><br><span class=line>NEW java/lang/IllegalArgumentException</span><br><span class=line>DUP</span><br><span class=line>INVOKESPECIAL java/lang/IllegalArgumentException &LTinit> ()V</span><br><span class=line>ATHROW</span><br><span class=line>end:</span><br><span class=line>F_SAME</span><br><span class=line>RETURN</span><br></pre></table></figure><h2 id=3-2、接口与组件><a class=headerlink href=#3-2、接口与组件 title=3.2、接口与组件></a>3.2、接口与组件</h2><h3 id=3-2-2、生成方法><a class=headerlink href=#3-2-2、生成方法 title=3.2.2、生成方法></a>3.2.2、生成方法</h3><p>如果mv是MethodVisitor，则可以使用以下方法调用生成3.1.3节中定义的getF方法的字节码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>mv.visitCode();</span><br><span class=line>mv.visitVarInsn(ALOAD, <span class=number>0</span>);</span><br><span class=line>mv.visitFieldInsn(GETFIELD, <span class=string>"pkg/Bean"</span>, <span class=string>"f"</span>, <span class=string>"I"</span>);</span><br><span class=line>mv.visitInsn(IRETURN);</span><br><span class=line>mv.visitMaxs(<span class=number>1</span>, <span class=number>1</span>);</span><br><span class=line>mv.visitEnd();</span><br></pre></table></figure><p>setF方法和构造函数的字节码可以类似的方式生成。一个更有趣的示例是checkAndSetF方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line>mv.visitCode();</span><br><span class=line>mv.visitVarInsn(ILOAD, <span class=number>1</span>);</span><br><span class=line><span class=type>Label</span> <span class=variable>label</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Label</span>();</span><br><span class=line>mv.visitJumpInsn(IFLT, label);</span><br><span class=line>mv.visitVarInsn(ALOAD, <span class=number>0</span>);</span><br><span class=line>mv.visitVarInsn(ILOAD, <span class=number>1</span>);</span><br><span class=line>mv.visitFieldInsn(PUTFIELD, <span class=string>"pkg/Bean"</span>, <span class=string>"f"</span>, <span class=string>"I"</span>);</span><br><span class=line><span class=type>Label</span> <span class=variable>end</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Label</span>();</span><br><span class=line>mv.visitJumpInsn(GOTO, end);</span><br><span class=line>mv.visitLabel(label);</span><br><span class=line>mv.visitFrame(F_SAME, <span class=number>0</span>, <span class=literal>null</span>, <span class=number>0</span>, <span class=literal>null</span>);</span><br><span class=line>mv.visitTypeInsn(NEW, <span class=string>"java/lang/IllegalArgumentException"</span>);</span><br><span class=line>mv.visitInsn(DUP);</span><br><span class=line>mv.visitMethodInsn(INVOKESPECIAL,</span><br><span class=line><span class=string>"java/lang/IllegalArgumentException"</span>, <span class=string>"&LTinit>"</span>, <span class=string>"()V"</span>);</span><br><span class=line>mv.visitInsn(ATHROW);</span><br><span class=line>mv.visitLabel(end);</span><br><span class=line>mv.visitFrame(F_SAME, <span class=number>0</span>, <span class=literal>null</span>, <span class=number>0</span>, <span class=literal>null</span>);</span><br><span class=line>mv.visitInsn(RETURN);</span><br><span class=line>mv.visitMaxs(<span class=number>2</span>, <span class=number>2</span>);</span><br><span class=line>mv.visitEnd();</span><br></pre></table></figure><blockquote><p>注意：Label对象指定该标签的visitLabel调用之后的指令。例如，end指定RETURN指令，而不是紧随其后访问的帧，因为这不是指令。拥有多个指定同一条指令的标签是完全合法的，但是标签必须精确地指定一条指令。换句话说，可以使用不同的标签连续调用visitLabel，但是指令中使用的标签必须使用visitLabel进行一次精确的访问。最后一个约束是不能共享标签：每个方法必须具有自己的标签。</blockquote><h3 id=3-2-3、转换方法><a class=headerlink href=#3-2-3、转换方法 title=3.2.3、转换方法></a>3.2.3、转换方法</h3><p>为了了解如何使用方法适配器，让我们考虑一个非常简单的适配器，它删除了方法内部的NOP指令（可以删除它们，因为它们什么都不做，因此不会出现问题）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoveNopAdapter</span> <span class=keyword>extends</span> <span class="title class_">MethodVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RemoveNopAdapter</span><span class=params>(MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        <span class=keyword>if</span> (opcode != NOP) {</span><br><span class=line>        	mv.visitInsn(opcode);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>可以在类适配器内部使用此适配器，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoveNopClassAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RemoveNopClassAdapter</span><span class=params>(ClassVisitor cv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> MethodVisitor <span class="title function_">visitMethod</span><span class=params>(<span class=type>int</span> access, String name,</span></span><br><span class=line><span class=params>        String desc, String signature, String[] exceptions)</span> {</span><br><span class=line>        MethodVisitor mv;</span><br><span class=line>        mv = cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class=line>        <span class=keyword>if</span> (mv != <span class=literal>null</span>) {</span><br><span class=line>        	mv = <span class=keyword>new</span> <span class="title class_">RemoveNopAdapter</span>(mv);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> mv;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>但是请注意，这不是强制性的：完全有可能构建与类适配器链不同的方法适配器链。每个方法甚至可以具有不同的方法适配器链。例如，类适配器可以选择仅在方法中而不在构造函数中删除NOP。可以按照以下步骤进行：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>...</span><br><span class=line>mv = cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class=line><span class=keyword>if</span> (mv != <span class=literal>null</span> && !name.equals(<span class=string>"&LTinit>"</span>)) {</span><br><span class=line>mv = <span class=keyword>new</span> <span class="title class_">RemoveNopAdapter</span>(mv);</span><br><span class=line>}</span><br><span class=line>...</span><br></pre></table></figure><p>方法适配器链甚至可以具有与类适配器链不同的拓扑。例如，类适配器链可以是线性的，而方法适配器链具有分支：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> MethodVisitor <span class="title function_">visitMethod</span><span class=params>(<span class=type>int</span> access, String name, String desc, String signature, String[] exceptions)</span> {</span><br><span class=line>    MethodVisitor mv1, mv2;</span><br><span class=line>    mv1 = cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class=line>    mv2 = cv.visitMethod(access, <span class=string>"_"</span> + name, desc, signature, exceptions);</span><br><span class=line>    <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">MultiMethodAdapter</span>(mv1, mv2);</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-2-4、无状态转换><a class=headerlink href=#3-2-4、无状态转换 title=3.2.4、无状态转换></a>3.2.4、无状态转换</h3><p>假设我们要衡量一个程序的每个类所花费的时间。我们需要在每个类中添加一个静态计时器字段，并且需要将该类的每个方法的执行时间添加到此计时器字段中。换句话说，我们要转换一个诸如C的类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">C</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">m</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>    	Thread.sleep(<span class=number>100</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>转为：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">C</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=type>long</span> timer;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">m</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        timer -= System.currentTimeMillis();</span><br><span class=line>        Thread.sleep(<span class=number>100</span>);</span><br><span class=line>        timer += System.currentTimeMillis();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>为了了解如何在ASM中实现这一点，我们可以编译这两个类，并比较这两个版本上的TraceClassVisitor的输出（使用默认的Textifier后端或使用ASMifier后端）。使用默认后端，我们得到以下差异（粗体）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line>GETSTATIC C.timer : J</span><br><span class=line>INVOKESTATIC java/lang/System.currentTimeMillis()J</span><br><span class=line>LSUB</span><br><span class=line>PUTSTATIC C.timer : J</span><br><span class=line>LDC <span class=number>100</span></span><br><span class=line>INVOKESTATIC java/lang/Thread.sleep(J)V</span><br><span class=line>GETSTATIC C.timer : J</span><br><span class=line>INVOKESTATIC java/lang/System.currentTimeMillis()J</span><br><span class=line>LADD</span><br><span class=line>PUTSTATIC C.timer : J</span><br><span class=line><span class=type>RETURN</span></span><br><span class=line><span class=variable>MAXSTACK</span> <span class=operator>=</span> <span class=number>4</span></span><br><span class=line>MAXLOCALS = <span class=number>1</span></span><br></pre></table></figure><p>我们看到必须在方法的开头添加四个指令，在返回指令之前添加四个其他指令。我们还需要更新最大操作数堆栈大小。该方法代码的开头是通过visitCode方法访问的。因此，我们可以通过在方法适配器中重写此方法来添加前四个指令：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitCode</span><span class=params>()</span> {</span><br><span class=line>    mv.visitCode();</span><br><span class=line>    mv.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>    mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>    mv.visitInsn(LSUB);</span><br><span class=line>    mv.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>}</span><br></pre></table></figure><p>必须将owner设置为要转换的类的名称。现在，我们必须在任何RETURN之前，任何xRETURN或ATHROW之前添加其他四条指令，它们都是终止该方法执行的所有指令。这些指令没有任何参数，因此可以在visitInsn方法中进行访问。然后，我们可以覆盖此方法以添加我们的说明：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>    <span class=keyword>if</span> ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {</span><br><span class=line>        mv.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>        mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>        mv.visitInsn(LADD);</span><br><span class=line>        mv.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>    }</span><br><span class=line>    mv.visitInsn(opcode);</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-2-5、有状态转换><a class=headerlink href=#3-2-5、有状态转换 title=3.2.5、有状态转换></a>3.2.5、有状态转换</h3><p>为了实现删除或替换某些指令序列的转换，可以方便地引入MethodVisitor子类，该子类的visitXxx Insn方法调用通用的visitInsn（）方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">PatternMethodAdapter</span> <span class=keyword>extends</span> <span class="title class_">MethodVisitor</span> {</span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>int</span> <span class=variable>SEEN_NOTHING</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>protected</span> <span class=type>int</span> state;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">PatternMethodAdapter</span><span class=params>(<span class=type>int</span> api, MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(api, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Overrid</span> <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        visitInsn();</span><br><span class=line>        mv.visitInsn(opcode);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitIntInsn</span><span class=params>(<span class=type>int</span> opcode, <span class=type>int</span> operand)</span> {</span><br><span class=line>        visitInsn();</span><br><span class=line>        mv.visitIntInsn(opcode, operand);</span><br><span class=line>    }</span><br><span class=line>    ...</span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>然后可以像这样实现上面的转换：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoveAddZeroAdapter</span> <span class=keyword>extends</span> <span class="title class_">PatternMethodAdapter</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>int</span> <span class=variable>SEEN_ICONST_0</span> <span class=operator>=</span> <span class=number>1</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RemoveAddZeroAdapter</span><span class=params>(MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        <span class=keyword>if</span> (state == SEEN_ICONST_0) {</span><br><span class=line>            <span class=keyword>if</span> (opcode == IADD) {</span><br><span class=line>            	state = SEEN_NOTHING;</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        visitInsn();</span><br><span class=line>        <span class=keyword>if</span> (opcode == ICONST_0) {</span><br><span class=line>            state = SEEN_ICONST_0;</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        mv.visitInsn(opcode);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> <span class=keyword>protected</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>if</span> (state == SEEN_ICONST_0) {</span><br><span class=line>        	mv.visitInsn(ICONST_0);</span><br><span class=line>        }</span><br><span class=line>        state = SEEN_NOTHING;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=3-3、工具><a class=headerlink href=#3-3、工具 title=3.3、工具></a>3.3、工具</h2><h3 id=3-3-1、基础工具><a class=headerlink href=#3-3-1、基础工具 title=3.3.1、基础工具></a>3.3.1、基础工具</h3><ul><li>Type<li>TraceClassVisitor<li>CheckClassAdapter<li>ASMifier</ul><h3 id=3-3-2、分析适配器><a class=headerlink href=#3-3-2、分析适配器 title=3.3.2、分析适配器></a>3.3.2、分析适配器</h3><p>在我们的AddTimerAdapter示例中，可以使用此适配器来获取RETURN指令之前的操作数堆栈的大小，从而允许为visitMaxs中的maxStack计算最佳转换值（实际上，不建议使用此方法，因为它比使用COMPUTE_MAXS效率低得多）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">AddTimerMethodAdapter2</span> <span class=keyword>extends</span> <span class="title class_">AnalyzerAdapter</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> maxStack;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AddTimerMethodAdapter2</span><span class=params>(String owner, <span class=type>int</span> access, String name, String desc, MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, owner, access, name, desc, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitCode</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>super</span>.visitCode();</span><br><span class=line>        mv.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>        mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>        mv.visitInsn(LSUB);</span><br><span class=line>        mv.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>        maxStack = <span class=number>4</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        <span class=keyword>if</span> ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {</span><br><span class=line>            mv.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>            mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>            mv.visitInsn(LADD);</span><br><span class=line>            mv.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>            maxStack = Math.max(maxStack, stack.size() + <span class=number>4</span>);</span><br><span class=line>        }</span><br><span class=line>    	<span class=built_in>super</span>.visitInsn(opcode);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitMaxs</span><span class=params>(<span class=type>int</span> maxStack, <span class=type>int</span> maxLocals)</span> {</span><br><span class=line>    	<span class=built_in>super</span>.visitMaxs(Math.max(<span class=built_in>this</span>.maxStack, maxStack), maxLocals);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>或者，可以通过调用超类的方法来插入新指令：结果是这些指令的帧将由AnalyzerAdapter计算。此外，由于此适配器基于其计算的帧来更新visitMaxs的参数，因此我们不需要自己更新它们：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">AddTimerMethodAdapter3</span> <span class=keyword>extends</span> <span class="title class_">AnalyzerAdapter</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AddTimerMethodAdapter3</span><span class=params>(String owner, <span class=type>int</span> access, String name, String desc, MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, owner, access, name, desc, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitCode</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>super</span>.visitCode();</span><br><span class=line>        <span class=built_in>super</span>.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>        <span class=built_in>super</span>.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>        <span class=built_in>super</span>.visitInsn(LSUB);</span><br><span class=line>        <span class=built_in>super</span>.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        <span class=keyword>if</span> ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {</span><br><span class=line>            <span class=built_in>super</span>.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>            <span class=built_in>super</span>.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>            <span class=built_in>super</span>.visitInsn(LADD);</span><br><span class=line>            <span class=built_in>super</span>.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>        }</span><br><span class=line>        <span class=built_in>super</span>.visitInsn(opcode);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-3-3、LocalVariablesSorter><a class=headerlink href=#3-3-3、LocalVariablesSorter title=3.3.3、LocalVariablesSorter></a>3.3.3、LocalVariablesSorter</h3><p>为了展示如何使用此适配器，假设我们要使用局部变量来实现AddTimerAdapter：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">C</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=type>long</span> timer;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">m</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>long</span> <span class=variable>t</span> <span class=operator>=</span> System.currentTimeMillis();</span><br><span class=line>        Thread.sleep(<span class=number>100</span>);</span><br><span class=line>        timer += System.currentTimeMillis() - t;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>通过扩展LocalVariablesSorter并使用此类中定义的newLocal方法，可以轻松完成此操作：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">AddTimerMethodAdapter4</span> <span class=keyword>extends</span> <span class="title class_">LocalVariablesSorter</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> time;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AddTimerMethodAdapter4</span><span class=params>(<span class=type>int</span> access, String desc, MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, access, desc, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitCode</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>super</span>.visitCode();</span><br><span class=line>        mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>        time = newLocal(Type.LONG_TYPE);</span><br><span class=line>        mv.visitVarInsn(LSTORE, time);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        <span class=keyword>if</span> ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {</span><br><span class=line>            mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>            mv.visitVarInsn(LLOAD, time);</span><br><span class=line>            mv.visitInsn(LSUB);</span><br><span class=line>            mv.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>            mv.visitInsn(LADD);</span><br><span class=line>            mv.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>        }</span><br><span class=line>        <span class=built_in>super</span>.visitInsn(opcode);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitMaxs</span><span class=params>(<span class=type>int</span> maxStack, <span class=type>int</span> maxLocals)</span> {</span><br><span class=line>    	<span class=built_in>super</span>.visitMaxs(maxStack + <span class=number>4</span>, maxLocals);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>使用局部变量不能解决我们在此类的原始版本中遇到的问题，该问题涉及maxStack的最坏情况。如果要使用AnalyzerAdapter来解决此问题，除了LocalVariablesSorter之外，还必须通过委派而不是通过继承使用这些适配器（因为无法进行多重继承）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">AddTimerMethodAdapter5</span> <span class=keyword>extends</span> <span class="title class_">MethodVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> LocalVariablesSorter lvs;</span><br><span class=line>    <span class=keyword>public</span> AnalyzerAdapter aa;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> time;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> maxStack;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AddTimerMethodAdapter5</span><span class=params>(MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitCode</span><span class=params>()</span> {</span><br><span class=line>        mv.visitCode();</span><br><span class=line>        mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>        time = lvs.newLocal(Type.LONG_TYPE);</span><br><span class=line>        mv.visitVarInsn(LSTORE, time);</span><br><span class=line>        maxStack = <span class=number>4</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        <span class=keyword>if</span> ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {</span><br><span class=line>            mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>            mv.visitVarInsn(LLOAD, time);</span><br><span class=line>            mv.visitInsn(LSUB);</span><br><span class=line>            mv.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>            mv.visitInsn(LADD);</span><br><span class=line>            mv.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>            maxStack = Math.max(aa.stack.size() + <span class=number>4</span>, maxStack);</span><br><span class=line>        }</span><br><span class=line>        mv.visitInsn(opcode);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitMaxs</span><span class=params>(<span class=type>int</span> maxStack, <span class=type>int</span> maxLocals)</span> {</span><br><span class=line>    	mv.visitMaxs(Math.max(<span class=built_in>this</span>.maxStack, maxStack), maxLocals);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>为了使用此适配器，您必须将LocalVariablesSorter链接到AnalyzerAdapter，后者本身也链接到您的适配器：第一个适配器将对局部变量进行排序并相应地更新帧，分析器适配器将计算中间帧，并考虑到前一个适配器中完成的重新编号，您的适配器将可以访问这些重新编号的中间框架。该链可以在visitMethod中构造如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>mv = cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class=line><span class=keyword>if</span> (!isInterface && mv != <span class=literal>null</span> && !name.equals(<span class=string>"&LTinit>"</span>)) {</span><br><span class=line>    <span class=type>AddTimerMethodAdapter5</span> <span class=variable>at</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AddTimerMethodAdapter5</span>(mv);</span><br><span class=line>    at.aa = <span class=keyword>new</span> <span class="title class_">AnalyzerAdapter</span>(owner, access, name, desc, at);</span><br><span class=line>    at.lvs = <span class=keyword>new</span> <span class="title class_">LocalVariablesSorter</span>(access, desc, at.aa);</span><br><span class=line>    <span class=keyword>return</span> at.lvs;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-3-4、AdviceAdapter><a class=headerlink href=#3-3-4、AdviceAdapter title=3.3.4、AdviceAdapter></a>3.3.4、AdviceAdapter</h3><h1 id=4、元数据><a class=headerlink href=#4、元数据 title=4、元数据></a>4、元数据</h1><p>本章说明如何使用核心API生成和转换已编译的Java类元数据，例如注释。每个部分都以一种类型的元数据开始呈现，然后以一些说明性示例呈现相应的ASM接口，组件和工具以生成和转换这些元数据。<h2 id=4-1、泛型><a class=headerlink href=#4-1、泛型 title=4.1、泛型></a>4.1、泛型</h2><p>诸如List之类的通用类以及使用它们的类包含有关它们声明或使用的通用类型的信息。字节码指令在运行时不使用此信息，但是可以通过反射API进行访问。编译器还使用它进行单独的编译。<h3 id=4-1-2、接口与组件><a class=headerlink href=#4-1-2、接口与组件 title=4.1.2、接口与组件></a>4.1.2、接口与组件</h3><p>与描述符一样，出于相同的效率原因（请参阅第2.3.1节），ASM API公开存储在已编译类中的签名（签名的主要出现位置是ClassVisitor类的visit，visitField和visitMethod方法，作为可选的类，类型或方法签名参数）。希望它还在org.objectweb.asm.signature包中基于SignatureVisitor抽象类提供了一些生成和转换签名的工具。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">SignatureVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>char</span> <span class=variable>EXTENDS</span> <span class=operator>=</span> ’+’;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>char</span> <span class=variable>SUPER</span> <span class=operator>=</span> ’-’;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>char</span> <span class=variable>INSTANCEOF</span> <span class=operator>=</span> ’=’;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">SignatureVisitor</span><span class=params>(<span class=type>int</span> api)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitFormalTypeParameter</span><span class=params>(String name)</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitClassBound</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitInterfaceBound</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitSuperclass</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitInterface</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitParameterType</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitReturnType</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitExceptionType</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitBaseType</span><span class=params>(<span class=type>char</span> descriptor)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitTypeVariable</span><span class=params>(String name)</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitArrayType</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitClassType</span><span class=params>(String name)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInnerClassType</span><span class=params>(String name)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitTypeArgument</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitTypeArgument</span><span class=params>(<span class=type>char</span> wildcard)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>以下代码的结果为“ LA.B;”：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=type>String</span> <span class=variable>s</span> <span class=operator>=</span> <span class=string>"Ljava/util/HashMap&LTTK;TV;>.HashIterator&LTTK;>;"</span>;</span><br><span class=line>Map&LTString, String> renaming = <span class=keyword>new</span> <span class="title class_">HashMap</span>&LTString, String>();</span><br><span class=line>renaming.put(<span class=string>"java/util/HashMap"</span>, <span class=string>"A"</span>);</span><br><span class=line>renaming.put(<span class=string>"java/util/HashMap.HashIterator"</span>, <span class=string>"B"</span>);</span><br><span class=line><span class=type>SignatureWriter</span> <span class=variable>sw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SignatureWriter</span>();</span><br><span class=line><span class=type>SignatureVisitor</span> <span class=variable>sa</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">RenameSignatureAdapter</span>(sw, renaming);</span><br><span class=line><span class=type>SignatureReader</span> <span class=variable>sr</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SignatureReader</span>(s);</span><br><span class=line>sr.acceptType(sa);</span><br><span class=line>sw.toString();</span><br></pre></table></figure><h3 id=4-1-3、工具><a class=headerlink href=#4-1-3、工具 title=4.1.3、工具></a>4.1.3、工具</h3><p>2.3节中介绍的TraceClassVisitor和ASMifier类以内部形式打印类文件中包含的签名。它们可以通过以下方式用于查找与给定泛型类型相对应的签名：编写具有某些泛型类型的Java类，对其进行编译，然后使用这些命令行工具来找到相应的签名。<h2 id=4-2、注解><a class=headerlink href=#4-2、注解 title=4.2、注解></a>4.2、注解</h2><p>如果类，字段，方法和方法参数的注释（例如@Deprecated或@Override）存储在已编译的类中，则其保留策略不是RetentionPolicy.SOURCE。该信息在运行时不会由字节码指令使用，但是如果保留策略为RetentionPolicy.RUNTIME，则可以通过反射API进行访问。编译器也可以使用它。<h3 id=4-2-1、结构><a class=headerlink href=#4-2-1、结构 title=4.2.1、结构></a>4.2.1、结构</h3><p>源代码中的注释可以采用各种形式，例如@ Deprecated，@ Retention（RetentionPolicy.CLASS）或@Task（desc =“ refactor”，id = 1）。但是，在内部，所有注释都具有相同的形式，并由注释类型和一组名称值对指定，其中值限于：<ol><li>基本值，字符串或类值。<li>枚举值。<li>注释值。<li>以上值的数组。</ol><p>请注意，注释可以包含其他注释，甚至可以包含注释数组。因此，注释可能非常复杂。<h3 id=4-2-2、接口与组件><a class=headerlink href=#4-2-2、接口与组件 title=4.2.2、接口与组件></a>4.2.2、接口与组件</h3><p>用于生成和转换注释的ASM API基于AnnotationVisitor抽象类。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">AnnotationVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AnnotationVisitor</span><span class=params>(<span class=type>int</span> api)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AnnotationVisitor</span><span class=params>(<span class=type>int</span> api, AnnotationVisitor av)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(String name, Object value)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnum</span><span class=params>(String name, String desc, String value)</span>;</span><br><span class=line>    <span class=keyword>public</span> AnnotationVisitor <span class="title function_">visitAnnotation</span><span class=params>(String name, String desc)</span>;</span><br><span class=line>    <span class=keyword>public</span> AnnotationVisitor <span class="title function_">visitArray</span><span class=params>(String name)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure><p><strong>添加，删除和检测注释：</strong><p>像字段和方法一样，可以通过在visitAnnotation方法中返回null来删除注释：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoveAnnotationAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>private</span> String annDesc;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RemoveAnnotationAdapter</span><span class=params>(ClassVisitor cv, String annDesc)</span> {</span><br><span class=line>        <span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>        <span class=built_in>this</span>.annDesc = annDesc;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> AnnotationVisitor <span class="title function_">visitAnnotation</span><span class=params>(String desc, <span class=type>boolean</span> vis)</span> {</span><br><span class=line>        <span class=keyword>if</span> (desc.equals(annDesc)) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cv.visitAnnotation(desc, vis);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>由于必须调用ClassVisitor类的方法的限制，添加类注释会更加困难。实际上，必须重写所有在visitAnnotation之后的方法，以检测何时访问了所有注释（由于使用了visitCode方法，方法注释更易于添加）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AddAnnotationAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>private</span> String annotationDesc;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>boolean</span> isAnnotationPresent;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AddAnnotationAdapter</span><span class=params>(ClassVisitor cv, String annotationDesc)</span> {</span><br><span class=line>        <span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>        <span class=built_in>this</span>.annotationDesc = annotationDesc;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(<span class=type>int</span> version, <span class=type>int</span> access, String name, String signature, String superName, String[] interfaces)</span> {</span><br><span class=line>        <span class=type>int</span> <span class=variable>v</span> <span class=operator>=</span> (version & <span class=number>0xFF</span>) < V1_5 ? V1_5 : version;</span><br><span class=line>        cv.visit(v, access, name, signature, superName, interfaces);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> AnnotationVisitor <span class="title function_">visitAnnotation</span><span class=params>(String desc, <span class=type>boolean</span> visible)</span> {</span><br><span class=line>        <span class=keyword>if</span> (visible && desc.equals(annotationDesc)) {</span><br><span class=line>            isAnnotationPresent = <span class=literal>true</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cv.visitAnnotation(desc, visible);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInnerClass</span><span class=params>(String name, String outerName, String innerName, <span class=type>int</span> access)</span> {</span><br><span class=line>        addAnnotation();</span><br><span class=line>        cv.visitInnerClass(name, outerName, innerName, access);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> FieldVisitor <span class="title function_">visitField</span><span class=params>(<span class=type>int</span> access, String name, String desc, String signature, Object value)</span> {</span><br><span class=line>        addAnnotation();</span><br><span class=line>        <span class=keyword>return</span> cv.visitField(access, name, desc, signature, value);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> MethodVisitor <span class="title function_">visitMethod</span><span class=params>(<span class=type>int</span> access, String name, String desc, String signature, String[] exceptions)</span> {</span><br><span class=line>        addAnnotation();</span><br><span class=line>        <span class=keyword>return</span> cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span> {</span><br><span class=line>        addAnnotation();</span><br><span class=line>        cv.visitEnd();</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">addAnnotation</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>if</span> (!isAnnotationPresent) {</span><br><span class=line>            <span class=type>AnnotationVisitor</span> <span class=variable>av</span> <span class=operator>=</span> cv.visitAnnotation(annotationDesc, <span class=literal>true</span>);</span><br><span class=line>            <span class=keyword>if</span> (av != <span class=literal>null</span>) {</span><br><span class=line>            	av.visitEnd();</span><br><span class=line>            }</span><br><span class=line>            isAnnotationPresent = <span class=literal>true</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=4-2-3、工具><a class=headerlink href=#4-2-3、工具 title=4.2.3、工具></a>4.2.3、工具</h3><p>2.3节中介绍的TraceClassVisitor，CheckClassAdapter和ASMifier类也支持注释（与方法一样，也可以使用TraceAnnotationVisitor或CheckAnnotationAdapter在单个注释级别而不是在类级别使用）。它们可以用来查看如何生成一些特定的注释。例如使用：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>java -classpath asm.jar:asm-util.jar \</span><br><span class=line>org.objectweb.asm.util.ASMifier \</span><br><span class=line>java.lang.Deprecated</span><br></pre></table></figure><p>打印经过少量重构后的代码，其内容为：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> asm.java.lang;</span><br><span class=line><span class=keyword>import</span> org.objectweb.asm.*;</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DeprecatedDump</span> <span class=keyword>implements</span> <span class="title class_">Opcodes</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=type>byte</span>[] dump() <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line>        AnnotationVisitor av;</span><br><span class=line>        cw.visit(V1_5, ACC_PUBLIC + ACC_ANNOTATION + ACC_ABSTRACT + ACC_INTERFACE, <span class=string>"java/lang/Deprecated"</span>, <span class=literal>null</span>, <span class=string>"java/lang/Object"</span>, <span class=keyword>new</span> <span class="title class_">String</span>[] {<span class=string>"java/lang/annotation/Annotation"</span> });</span><br><span class=line>        {</span><br><span class=line>            av = cw.visitAnnotation(<span class=string>"Ljava/lang/annotation/Documented;"</span>, <span class=literal>true</span>);</span><br><span class=line>            av.visitEnd();</span><br><span class=line>        }</span><br><span class=line>        {</span><br><span class=line>            av = cw.visitAnnotation(<span class=string>"Ljava/lang/annotation/Retention;"</span>, <span class=literal>true</span>);</span><br><span class=line>            av.visitEnum(<span class=string>"value"</span>, <span class=string>"Ljava/lang/annotation/RetentionPolicy;"</span>,</span><br><span class=line>            <span class=string>"RUNTIME"</span>);</span><br><span class=line>            av.visitEnd();</span><br><span class=line>        }</span><br><span class=line>        cw.visitEnd();</span><br><span class=line>        <span class=keyword>return</span> cw.toByteArray();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=4-3、Debug><a class=headerlink href=#4-3、Debug title=4.3、Debug></a>4.3、Debug</h2><p>用javac -g编译的类包含其源文件的名称，源行号和字节码指令之间的映射以及源代码中的本地变量名称和字节码中的本地变量槽之间的映射。此可选信息在调试器中使用，并且在可用时在异常堆栈跟踪中使用。<h3 id=4-3-2、接口与组件><a class=headerlink href=#4-3-2、接口与组件 title=4.3.2、接口与组件></a>4.3.2、接口与组件</h3><p>使用ClassVisitor和MethodVisitor类的三种方法访问调试信息：<ul><li>使用ClassVisitor类的visitSource方法访问源文件名；<li>使用MethodVisitor类的visitLineNumber方法访问源行号和字节码指令之间的映射，一次一对。<li>使用MethodVisitor类的visitLocalVariable方法访问源代码中的局部变量名称和字节码中的局部变量槽之间的映射，一次访问一个元组。</ul><p>在访问作为参数传递的标签之后，必须调用visitLineNumber方法。实际上，在该标签之后调用它，这使得在方法访问者中很容易知道当前指令的源代码行：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyAdapter</span> <span class=keyword>extends</span> <span class="title class_">MethodVisitor</span> {</span><br><span class=line>    <span class=type>int</span> currentLine;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MyAdapter</span><span class=params>(MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitLineNumber</span><span class=params>(<span class=type>int</span> line, Label start)</span> {</span><br><span class=line>        mv.visitLineNumber(line, start);</span><br><span class=line>        currentLine = line;</span><br><span class=line>    }</span><br><span class=line>    ...</span><br><span class=line>}</span><br></pre></table></figure><p>同样，在访问作为参数传递的标签之后，必须调用visitLocalVariable方法。这是与上一节中介绍的对和元组相对应的示例方法调用：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>visitLineNumber(n1, l1);</span><br><span class=line>visitLineNumber(n2, l2);</span><br><span class=line>visitLineNumber(n3, l3);</span><br><span class=line>visitLocalVariable(<span class=string>"i"</span>, <span class=string>"I"</span>, <span class=literal>null</span>, l1, l2, <span class=number>1</span>);</span><br><span class=line>visitLocalVariable(<span class=string>"j"</span>, <span class=string>"I"</span>, <span class=literal>null</span>, l2, l3, <span class=number>1</span>);</span><br><span class=line>visitLocalVariable(<span class=string>"i"</span>, <span class=string>"I"</span>, <span class=literal>null</span>, l3, end, <span class=number>1</span>);</span><br></pre></table></figure><p><strong>忽略调试信息</strong><p>注意：ClassReader类提供其他选项，例如SKIP_CODE跳过对已编译代码的访问（如果您只需要类结构，这将很有用），SKIP_FRAMES跳过堆栈映射框架，以及EXPAND_FRAMES取消压缩这些框架。<h3 id=4-3-3、工具><a class=headerlink href=#4-3-3、工具 title=4.3.3、工具></a>4.3.3、工具</h3><p>与通用类型和注释一样，您可以使用TraceClassVisitor，CheckClassAdapter和ASMifier类来查找如何使用调试信息。<h1 id=5、向后兼容（Backward-compatibility）><a title="5、向后兼容（Backward compatibility）" class=headerlink href=#5、向后兼容（Backward-compatibility）></a>5、向后兼容（Backward compatibility）</h1><h2 id=5-1、简介><a class=headerlink href=#5-1、简介 title=5.1、简介></a>5.1、简介</h2><p>ASM 4.0中引入的向后兼容机制，需要将ClassVisitor，FieldVisitor，MethodVisitor等从接口更改为抽象类，并使用构造函数以ASM版本作为参数。如果您的代码是针对ASM 3.x实施的，则可以通过在代码分析器和适配器中将扩展替换为工具，并在其构造函数中指定ASM版本，将其升级到ASM 4.0。此外，ClassAdapter和MethodAdapter已合并为ClassVisitor和MethodVisitor。要转换代码，只需要将ClassAdapter替换为ClassVisitor，并将MethodAdapter替换为MethodVisitor。另外，如果定义了自定义FieldAdapter或AnnotationAdapter类，则现在可以将它们替换为FieldVisitor和AnnotationVisitor。<h3 id=5-1-1、Backward-compatibility-contract><a title="5.1.1、Backward compatibility contract" class=headerlink href=#5-1-1、Backward-compatibility-contract></a>5.1.1、Backward compatibility contract</h3><p>实际上，对于类生成器，分析器和适配器，影响是不同的：<ul><li>类生成器不受影响：它们生成具有某些固定类版本的代码，并且这些生成的类将在将来的JVM版本中保持有效，因为JVM确保了向后二进制兼容性。<li>•类分析器可能会受到影响，也可能不会受到影响。例如，尽管引入了注释，但是分析针对Java 4编写的字节码指令的代码可能仍将适用于Java 5类。但是，这些相同的代码可能不再适用于Java 7类，因为它不能忽略新的invokedynamic指令。<li>类适配器可能会受到影响，也可能不会受到影响。无效代码删除工具不受注释的引入甚至新的invokedynamic指令的影响。另一方面，类重命名工具受这两者的影响。类适配器可能会受到影响，也可能不会受到影响。无效代码删除工具不受注释的引入甚至新的invokedynamic指令的影响。另一方面，类重命名工具受这两者的影响。</ul><p>所有这些导致了以下向后兼容协议的定义：<ul><li>ASM版本X是为版本小于或等于x的Java类编写的。它不能生成版本y> x的类，并且在ClassReader.accept中输入大于x的类作为输入时必须失败。<li>为ASM X编写的代码并遵循下面介绍的准则，必须继续使用未经修改的输入类，并且输入类的版本必须为x，且ASM的将来版本为Y> X。<li>为ASM X编写并遵循下面介绍的准则的代码必须继续使用未经声明的输入类，它们的声明版本为y，但仅使用具有ASM Y或更高版本的旧版本或等于x的版本中定义的功能。<li>如果将使用ASM X或任何其他将来版本的，使用类版本y> x中引入的功能的输入作为输入，则为ASM X编写并遵循下面介绍的准则的代码必须失败。</ul><p>请注意，最后三点与类别生成器无关，后者没有类别输入。<h3 id=5-1-2、例子><a class=headerlink href=#5-1-2、例子 title=5.1.2、例子></a>5.1.2、例子</h3><p>为了说明用户指南和确保向后兼容性的内部ASM机制，我们在本章中假设将向Java 8类添加两个新的虚构属性，一个用于存储类作者，另一个用于存储其许可证。 。我们还假设这些新属性将通过ASM 5.0中的ClassVisitor中的两个新方法公开：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> <span class="title function_">visitLicense</span><span class=params>(String license)</span>;</span><br></pre></table></figure><p>来访问许可证，并使用新版本的visitSource来与源文件名和调试信息1一起访问作者：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> <span class="title function_">visitSource</span><span class=params>(String author, String source, String debug)</span>;</span><br></pre></table></figure><p>旧的visitSource方法仍然有效，但是在ASM 5.0中声明为已弃用：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta>@Deprecated</span> </span><br><span class=line><span class=keyword>void</span> <span class="title function_">visitSource</span><span class=params>(String source, String debug)</span>;</span><br></pre></table></figure><p>author和license属性是可选的，即，调用visitLicense不是必需的，在visitSource调用中author可以为null。<h2 id=5-2、指导><a class=headerlink href=#5-2、指导 title=5.2、指导></a>5.2、指导</h2><h3 id=5-2-1、基本规则><a class=headerlink href=#5-2-1、基本规则 title=5.2.1、基本规则></a>5.2.1、基本规则</h3><p>准则1：为ASM版本X编写ClassVisitor子类，以该确切版本作为参数调用ClassVisitor构造函数，并且永远不要覆盖或调用在此版本的ClassVisitor类中不推荐使用的方法（或在更高版本中引入的方法）。<h3 id=5-2-2、继承规则><a class=headerlink href=#5-2-2、继承规则 title=5.2.2、继承规则></a>5.2.2、继承规则</h3><p>准则2：不要使用访问者的继承，而应使用委派（即访问者链）。一种好的做法是，默认情况下将您的访问者班级定为最终班，以确保做到这一点。<p>实际上，该规则有两个例外：<ol><li>如果您自己完全控制继承链，并同时释放层次结构的所有类，则可以使用访问者的继承。然后，您必须确保为同一ASM版本编写层次结构中的所有类。尽管如此，将层次结构的叶类定为最终类。<li>如果除叶子类之外没有其他类重写任何访问方法，则可以使用“访问者”的继承（例如，如果您在ClassVisitor和具体访问者类之间使用中间类只是为了引入便捷方法）。仍然，使层次结构的叶类成为最终类（除非它们也不覆盖任何访问方法；在这种情况下，请提供一个构造器，以ASM版本作为参数，以便子类可以指定为其编写的版本）。</ol></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/04-%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/04-%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/ itemprop=url>微服务问题系列-一致性问题</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:15" datetime=2024-08-21T21:39:15+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-07 16:08:17" datetime=2023-08-07T16:08:17+08:00 itemprop=dateModified>2023-08-07</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/ itemprop=url rel=index><span itemprop=name>微服务</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、Raft协议><a class=headerlink href=#1、Raft协议 title=1、Raft协议></a>1、Raft协议</h1><h2 id=1-1、简介><a class=headerlink href=#1-1、简介 title=1.1、简介></a>1.1、简介</h2><p>分布式系统，3个节点 n1、n2、n3，每个节点有三种状态：跟随者、候选者、leader。<ol><li>最开始，三个节点都是fllower状态。<li>其中一个节点先将自己变为 候选者，然后向其他节点发送拉票请求，让其他节点投票给他，让他做leader。<li>若有超过一半的节点同意该请求，则当前候选者正式升级为leader。<li>leader节点收到 赋值请求X=5，会在leader节点日志中记录X=5，要注意的是仅仅是在日志中记录一下，并没有提交。<li>leader节点记录日志后，会将该赋值命令 发送給其它节点，其它节点同样先记录在日志中，记录成功后会发送响应给leader节点。<li>leader节点收到所有节点响应后，提交 本地日志中的赋值命令，提交成功后 会通知其它节点也提交。</ol><h2 id=1-2、领导选举逻辑><a class=headerlink href=#1-2、领导选举逻辑 title=1.2、领导选举逻辑></a>1.2、领导选举逻辑</h2><p>注意：raft协议有两个超时时间（选举时间、自旋时间）来控制选举过程。<p>选举超时：随从变为候选者的时间（自旋时间），一般150ms-300ms。<ol><li>所有节点都有自旋时间，谁的自旋时间先结束，谁先称为候选者。<li>该候选者先向其它节点发送投票请求，其他节点可以选择是否投票给它，若有超过一半的节点都同意，则该候选者将成功升级为leader。<li>其它节点投完票后会重置自旋时间，也就是从0开始自旋。<li>leader节点会发送心跳检测，其它跟随者收到心跳检测后会重置自旋时间，一收到就重置，一收到就重置。<li>此时，若leader因为某种原因，停止了心跳检测请求的发送，那么其他跟随者的自旋时间到期后，会在所有跟随者中挑选一个做为新的leader（选拔逻辑与之前相同），期间若选举失败，会重新选举，直到成功。</ol></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/03-%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/03-%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7/ itemprop=url>微服务问题系列-接口幂等问题</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:15" datetime=2024-08-21T21:39:15+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-07 16:08:27" datetime=2023-08-07T16:08:27+08:00 itemprop=dateModified>2023-08-07</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/ itemprop=url rel=index><span itemprop=name>微服务</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、幂等性简介><a class=headerlink href=#1、幂等性简介 title=1、幂等性简介></a>1、幂等性简介</h1><h2 id=1-1、幂等性定义><a class=headerlink href=#1-1、幂等性定义 title=1.1、幂等性定义></a>1.1、幂等性定义</h2><p><strong>针对同一个接口，调用多次与调用一次，其效果完全等同。这种情况被称为符合幂等性。</strong><h2 id=1-2、幂等性场景><a class=headerlink href=#1-2、幂等性场景 title=1.2、幂等性场景></a>1.2、幂等性场景</h2><ol><li>订单付款。<li>充值。</ol><h1 id=2、幂等性方案><a class=headerlink href=#2、幂等性方案 title=2、幂等性方案></a>2、幂等性方案</h1><h2 id=2-1、token机制><a class=headerlink href=#2-1、token机制 title=2.1、token机制></a>2.1、token机制</h2><h2 id=2-2、锁机制><a class=headerlink href=#2-2、锁机制 title=2.2、锁机制></a>2.2、锁机制</h2><ul><li>数据库悲观锁<li>数据库乐观锁<li>业务层分布式锁</ul><h2 id=2-3、唯一约束><a class=headerlink href=#2-3、唯一约束 title=2.3、唯一约束></a>2.3、唯一约束</h2><ul><li>数据库唯一约束<li>redis set 防重</ul><h2 id=2-4、防重表><a class=headerlink href=#2-4、防重表 title=2.4、防重表></a>2.4、防重表</h2><h2 id=2-5、请求唯一ID><a class=headerlink href=#2-5、请求唯一ID title=2.5、请求唯一ID></a>2.5、请求唯一ID</h2></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/03-%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/03-%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86/ itemprop=url>微服务业务功能系列-日志处理</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:15" datetime=2024-08-21T21:39:15+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-07 15:30:19" datetime=2023-08-07T15:30:19+08:00 itemprop=dateModified>2023-08-07</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/ itemprop=url rel=index><span itemprop=name>微服务</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、日志简介><a class=headerlink href=#1、日志简介 title=1、日志简介></a>1、日志简介</h1><h2 id=1-1、日志级别><a class=headerlink href=#1-1、日志级别 title=1.1、日志级别></a>1.1、日志级别</h2><p><strong>日志级别从高到底依次为：ALL、DEBUG、INFO、WARN、ERROR、FATAL、OFF。</strong><h2 id=1-2、默认日志><a class=headerlink href=#1-2、默认日志 title=1.2、默认日志></a>1.2、默认日志</h2><p>SpringBoot中默认使用logback日志系统。<h1 id=2、配置><a class=headerlink href=#2、配置 title=2、配置></a>2、配置</h1><p>在项目resources目录下创建<code>logback-spring.xml</code>文件，在文件中添加如下内容，并根据个人实际情况做不同的设置与修改。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br><span class=line>105</span><br><span class=line>106</span><br><span class=line>107</span><br><span class=line>108</span><br><span class=line>109</span><br><span class=line>110</span><br><span class=line>111</span><br><span class=line>112</span><br><span class=line>113</span><br><span class=line>114</span><br><span class=line>115</span><br><span class=line>116</span><br><span class=line>117</span><br><span class=line>118</span><br><span class=line>119</span><br><span class=line>120</span><br><span class=line>121</span><br><span class=line>122</span><br><span class=line>123</span><br><span class=line>124</span><br><span class=line>125</span><br><span class=line>126</span><br><span class=line>127</span><br><span class=line>128</span><br><span class=line>129</span><br><span class=line>130</span><br><span class=line>131</span><br><span class=line>132</span><br><span class=line>133</span><br><span class=line>134</span><br><span class=line>135</span><br><span class=line>136</span><br><span class=line>137</span><br><span class=line>138</span><br><span class=line>139</span><br><span class=line>140</span><br><span class=line>141</span><br><span class=line>142</span><br><span class=line>143</span><br><span class=line>144</span><br><span class=line>145</span><br><span class=line>146</span><br><span class=line>147</span><br><span class=line>148</span><br><span class=line>149</span><br><span class=line>150</span><br><span class=line>151</span><br><span class=line>152</span><br><span class=line>153</span><br><span class=line>154</span><br><span class=line>155</span><br><span class=line>156</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>configuration</span>  <span class=attr>scan</span>=<span class=string>"true"</span> <span class=attr>scanPeriod</span>=<span class=string>"10 seconds"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- 日志级别从低到高分为TRACE < DEBUG < INFO < WARN < ERROR < FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --></span></span><br><span class=line>    <span class=comment>&LT!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true --></span></span><br><span class=line>    <span class=comment>&LT!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --></span></span><br><span class=line>    <span class=comment>&LT!-- de<span class=doctag>bug:</span>当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>contextName</span>></span>logback<span class=tag>&LT/<span class=name>contextName</span>></span></span><br><span class=line>    <span class=comment>&LT!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。 --></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"log.path"</span> <span class=attr>value</span>=<span class=string>"D:/tmp/guliedu/edu"</span> /></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- 彩色日志 --></span></span><br><span class=line>    <span class=comment>&LT!-- 配置格式变量：CONSOLE_LOG_PATTERN 彩色日志格式 --></span></span><br><span class=line>    <span class=comment>&LT!-- magenta:洋红 --></span></span><br><span class=line>    <span class=comment>&LT!-- boldMagenta:粗红--></span></span><br><span class=line>    <span class=comment>&LT!-- cyan:青色 --></span></span><br><span class=line>    <span class=comment>&LT!-- white:白色 --></span></span><br><span class=line>    <span class=comment>&LT!-- magenta:洋红 --></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"CONSOLE_LOG_PATTERN"</span></span></span><br><span class=line><span class=tag>              <span class=attr>value</span>=<span class=string>"%yellow(%date{yyyy-MM-dd HH:mm:ss}) %highlight(%-5level) %blue(%thread) %blue(%file:%line) %green(%logger) %cyan(%msg%n)"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!--输出到控制台--></span></span><br><span class=line>    <span class=tag><<span class=name>appender</span> <span class=attr>name</span>=<span class=string>"CONSOLE"</span> <span class=attr>class</span>=<span class=string>"ch.qos.logback.core.ConsoleAppender"</span>></span></span><br><span class=line>        <span class=comment>&LT!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--></span></span><br><span class=line>        <span class=comment>&LT!-- 例如：如果此处配置了INFO级别，则后面其他位置即使配置了DEBUG级别的日志，也不会被输出 --></span></span><br><span class=line>        <span class=tag><<span class=name>filter</span> <span class=attr>class</span>=<span class=string>"ch.qos.logback.classic.filter.ThresholdFilter"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>level</span>></span>INFO<span class=tag>&LT/<span class=name>level</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>filter</span>></span></span><br><span class=line>        <span class=tag><<span class=name>encoder</span>></span></span><br><span class=line>            <span class=tag><<span class=name>Pattern</span>></span>${CONSOLE_LOG_PATTERN}<span class=tag>&LT/<span class=name>Pattern</span>></span></span><br><span class=line>            <span class=comment>&LT!-- 设置字符集 --></span></span><br><span class=line>            <span class=tag><<span class=name>charset</span>></span>UTF-8<span class=tag>&LT/<span class=name>charset</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>encoder</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>appender</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!--输出到文件--></span></span><br><span class=line>    <span class=comment>&LT!-- 时间滚动输出 level为 INFO 日志 --></span></span><br><span class=line>    <span class=tag><<span class=name>appender</span> <span class=attr>name</span>=<span class=string>"INFO_FILE"</span> <span class=attr>class</span>=<span class=string>"ch.qos.logback.core.rolling.RollingFileAppender"</span>></span></span><br><span class=line>        <span class=comment>&LT!-- 正在记录的日志文件的路径及文件名 --></span></span><br><span class=line>        <span class=tag><<span class=name>file</span>></span>${log.path}/log_info.log<span class=tag>&LT/<span class=name>file</span>></span></span><br><span class=line>        <span class=comment>&LT!--日志文件输出格式--></span></span><br><span class=line>        <span class=tag><<span class=name>encoder</span>></span></span><br><span class=line>            <span class=tag><<span class=name>pattern</span>></span>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n<span class=tag>&LT/<span class=name>pattern</span>></span></span><br><span class=line>            <span class=tag><<span class=name>charset</span>></span>UTF-8<span class=tag>&LT/<span class=name>charset</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>encoder</span>></span></span><br><span class=line>        <span class=comment>&LT!-- 日志记录器的滚动策略，按日期，按大小记录 --></span></span><br><span class=line>        <span class=tag><<span class=name>rollingPolicy</span> <span class=attr>class</span>=<span class=string>"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>></span></span><br><span class=line>            <span class=comment>&LT!-- 每天日志归档路径以及格式 --></span></span><br><span class=line>            <span class=tag><<span class=name>fileNamePattern</span>></span>${log.path}/info/log-info-%d{yyyy-MM-dd}.%i.log<span class=tag>&LT/<span class=name>fileNamePattern</span>></span></span><br><span class=line>            <span class=tag><<span class=name>timeBasedFileNamingAndTriggeringPolicy</span> <span class=attr>class</span>=<span class=string>"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>></span></span><br><span class=line>                <span class=tag><<span class=name>maxFileSize</span>></span>100MB<span class=tag>&LT/<span class=name>maxFileSize</span>></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>timeBasedFileNamingAndTriggeringPolicy</span>></span></span><br><span class=line>            <span class=comment>&LT!--日志文件保留天数--></span></span><br><span class=line>            <span class=tag><<span class=name>maxHistory</span>></span>15<span class=tag>&LT/<span class=name>maxHistory</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>rollingPolicy</span>></span></span><br><span class=line>        <span class=comment>&LT!-- 此日志文件只记录info级别的 --></span></span><br><span class=line>        <span class=tag><<span class=name>filter</span> <span class=attr>class</span>=<span class=string>"ch.qos.logback.classic.filter.LevelFilter"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>level</span>></span>INFO<span class=tag>&LT/<span class=name>level</span>></span></span><br><span class=line>            <span class=tag><<span class=name>onMatch</span>></span>ACCEPT<span class=tag>&LT/<span class=name>onMatch</span>></span></span><br><span class=line>            <span class=tag><<span class=name>onMismatch</span>></span>DENY<span class=tag>&LT/<span class=name>onMismatch</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>filter</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>appender</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- 时间滚动输出 WARN级别 的日志 --></span></span><br><span class=line>    <span class=tag><<span class=name>appender</span> <span class=attr>name</span>=<span class=string>"WARN_FILE"</span> <span class=attr>class</span>=<span class=string>"ch.qos.logback.core.rolling.RollingFileAppender"</span>></span></span><br><span class=line>        <span class=comment>&LT!-- 正在记录的日志文件的路径及文件名 --></span></span><br><span class=line>        <span class=tag><<span class=name>file</span>></span>${log.path}/log_warn.log<span class=tag>&LT/<span class=name>file</span>></span></span><br><span class=line>        <span class=comment>&LT!--日志文件输出格式--></span></span><br><span class=line>        <span class=tag><<span class=name>encoder</span>></span></span><br><span class=line>            <span class=tag><<span class=name>pattern</span>></span>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n<span class=tag>&LT/<span class=name>pattern</span>></span></span><br><span class=line>            <span class=tag><<span class=name>charset</span>></span>UTF-8<span class=tag>&LT/<span class=name>charset</span>></span> <span class=comment>&LT!-- 此处设置字符集 --></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>encoder</span>></span></span><br><span class=line>        <span class=comment>&LT!-- 日志记录器的滚动策略，按日期，按大小记录 --></span></span><br><span class=line>        <span class=tag><<span class=name>rollingPolicy</span> <span class=attr>class</span>=<span class=string>"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>fileNamePattern</span>></span>${log.path}/warn/log-warn-%d{yyyy-MM-dd}.%i.log<span class=tag>&LT/<span class=name>fileNamePattern</span>></span></span><br><span class=line>            <span class=tag><<span class=name>timeBasedFileNamingAndTriggeringPolicy</span> <span class=attr>class</span>=<span class=string>"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>></span></span><br><span class=line>                <span class=tag><<span class=name>maxFileSize</span>></span>100MB<span class=tag>&LT/<span class=name>maxFileSize</span>></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>timeBasedFileNamingAndTriggeringPolicy</span>></span></span><br><span class=line>            <span class=comment>&LT!--日志文件保留天数--></span></span><br><span class=line>            <span class=tag><<span class=name>maxHistory</span>></span>15<span class=tag>&LT/<span class=name>maxHistory</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>rollingPolicy</span>></span></span><br><span class=line>        <span class=comment>&LT!-- 此日志文件只记录warn级别的 --></span></span><br><span class=line>        <span class=tag><<span class=name>filter</span> <span class=attr>class</span>=<span class=string>"ch.qos.logback.classic.filter.LevelFilter"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>level</span>></span>warn<span class=tag>&LT/<span class=name>level</span>></span></span><br><span class=line>            <span class=tag><<span class=name>onMatch</span>></span>ACCEPT<span class=tag>&LT/<span class=name>onMatch</span>></span></span><br><span class=line>            <span class=tag><<span class=name>onMismatch</span>></span>DENY<span class=tag>&LT/<span class=name>onMismatch</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>filter</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>appender</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- 时间滚动输出 ERROR级别 的日志 --></span></span><br><span class=line>    <span class=tag><<span class=name>appender</span> <span class=attr>name</span>=<span class=string>"ERROR_FILE"</span> <span class=attr>class</span>=<span class=string>"ch.qos.logback.core.rolling.RollingFileAppender"</span>></span></span><br><span class=line>        <span class=comment>&LT!-- 正在记录的日志文件的路径及文件名 --></span></span><br><span class=line>        <span class=tag><<span class=name>file</span>></span>${log.path}/log_error.log<span class=tag>&LT/<span class=name>file</span>></span></span><br><span class=line>        <span class=comment>&LT!--日志文件输出格式--></span></span><br><span class=line>        <span class=tag><<span class=name>encoder</span>></span></span><br><span class=line>            <span class=tag><<span class=name>pattern</span>></span>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n<span class=tag>&LT/<span class=name>pattern</span>></span></span><br><span class=line>            <span class=tag><<span class=name>charset</span>></span>UTF-8<span class=tag>&LT/<span class=name>charset</span>></span> <span class=comment>&LT!-- 此处设置字符集 --></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>encoder</span>></span></span><br><span class=line>        <span class=comment>&LT!-- 日志记录器的滚动策略，按日期，按大小记录 --></span></span><br><span class=line>        <span class=tag><<span class=name>rollingPolicy</span> <span class=attr>class</span>=<span class=string>"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>fileNamePattern</span>></span>${log.path}/error/log-error-%d{yyyy-MM-dd}.%i.log<span class=tag>&LT/<span class=name>fileNamePattern</span>></span></span><br><span class=line>            <span class=tag><<span class=name>timeBasedFileNamingAndTriggeringPolicy</span> <span class=attr>class</span>=<span class=string>"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"</span>></span></span><br><span class=line>                <span class=tag><<span class=name>maxFileSize</span>></span>100MB<span class=tag>&LT/<span class=name>maxFileSize</span>></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>timeBasedFileNamingAndTriggeringPolicy</span>></span></span><br><span class=line>            <span class=comment>&LT!--日志文件保留天数--></span></span><br><span class=line>            <span class=tag><<span class=name>maxHistory</span>></span>15<span class=tag>&LT/<span class=name>maxHistory</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>rollingPolicy</span>></span></span><br><span class=line>        <span class=comment>&LT!-- 此日志文件只记录ERROR级别的 --></span></span><br><span class=line>        <span class=tag><<span class=name>filter</span> <span class=attr>class</span>=<span class=string>"ch.qos.logback.classic.filter.LevelFilter"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>level</span>></span>ERROR<span class=tag>&LT/<span class=name>level</span>></span></span><br><span class=line>            <span class=tag><<span class=name>onMatch</span>></span>ACCEPT<span class=tag>&LT/<span class=name>onMatch</span>></span></span><br><span class=line>            <span class=tag><<span class=name>onMismatch</span>></span>DENY<span class=tag>&LT/<span class=name>onMismatch</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>filter</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>appender</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!--</span></span><br><span class=line><span class=comment>        &LTlogger>用来设置某一个包或者具体的某一个类的日志打印级别、以及指定&LTappender>。</span></span><br><span class=line><span class=comment>        &LTlogger>仅有一个name属性，</span></span><br><span class=line><span class=comment>        一个可选的level和一个可选的addtivity属性。</span></span><br><span class=line><span class=comment>        name:用来指定受此logger约束的某一个包或者具体的某一个类。</span></span><br><span class=line><span class=comment>        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，</span></span><br><span class=line><span class=comment>              如果未设置此属性，那么当前logger将会继承上级的级别。</span></span><br><span class=line><span class=comment>    --></span></span><br><span class=line>    <span class=comment>&LT!--</span></span><br><span class=line><span class=comment>        使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：</span></span><br><span class=line><span class=comment>        第一种把&LTroot level="INFO">改成&LTroot level="DEBUG">这样就会打印sql，不过这样日志那边会出现很多其他消息</span></span><br><span class=line><span class=comment>        第二种就是单独给mapper下目录配置DEBUG模式，代码如下，这样配置sql语句会打印，其他还是正常DEBUG级别：</span></span><br><span class=line><span class=comment>     --></span></span><br><span class=line>    <span class=comment>&LT!--开发环境:打印控制台--></span></span><br><span class=line>    <span class=tag><<span class=name>springProfile</span> <span class=attr>name</span>=<span class=string>"dev"</span>></span></span><br><span class=line>        <span class=comment>&LT!--可以输出项目中的debug日志，包括mybatis的sql日志--></span></span><br><span class=line>        <span class=tag><<span class=name>logger</span> <span class=attr>name</span>=<span class=string>"cn.shh.project.guliedu"</span> <span class=attr>level</span>=<span class=string>"INFO"</span> /></span></span><br><span class=line>        <span class=comment>&LT!--</span></span><br><span class=line><span class=comment>            root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性</span></span><br><span class=line><span class=comment>            level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，默认是DEBUG</span></span><br><span class=line><span class=comment>            可以包含零个或多个appender元素。</span></span><br><span class=line><span class=comment>        --></span></span><br><span class=line>        <span class=tag><<span class=name>root</span> <span class=attr>level</span>=<span class=string>"INFO"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>appender-ref</span> <span class=attr>ref</span>=<span class=string>"CONSOLE"</span> /></span></span><br><span class=line>            <span class=tag><<span class=name>appender-ref</span> <span class=attr>ref</span>=<span class=string>"INFO_FILE"</span> /></span></span><br><span class=line>            <span class=tag><<span class=name>appender-ref</span> <span class=attr>ref</span>=<span class=string>"WARN_FILE"</span> /></span></span><br><span class=line>            <span class=tag><<span class=name>appender-ref</span> <span class=attr>ref</span>=<span class=string>"ERROR_FILE"</span> /></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>root</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>springProfile</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!--生产环境:输出到文件--></span></span><br><span class=line>    <span class=tag><<span class=name>springProfile</span> <span class=attr>name</span>=<span class=string>"pro"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>root</span> <span class=attr>level</span>=<span class=string>"INFO"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>appender-ref</span> <span class=attr>ref</span>=<span class=string>"CONSOLE"</span> /></span></span><br><span class=line>            <span class=tag><<span class=name>appender-ref</span> <span class=attr>ref</span>=<span class=string>"DEBUG_FILE"</span> /></span></span><br><span class=line>            <span class=tag><<span class=name>appender-ref</span> <span class=attr>ref</span>=<span class=string>"INFO_FILE"</span> /></span></span><br><span class=line>            <span class=tag><<span class=name>appender-ref</span> <span class=attr>ref</span>=<span class=string>"ERROR_FILE"</span> /></span></span><br><span class=line>            <span class=tag><<span class=name>appender-ref</span> <span class=attr>ref</span>=<span class=string>"WARN_FILE"</span> /></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>root</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>springProfile</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>configuration</span>></span></span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <nav class=pagination><span class="page-number current">1</span><a class=page-number href=/page/2/>2</a><span class=space>…</span><a class=page-number href=/page/12/>12</a><a class="extend next" aria-label=下一页 href=/page/2/ rel=next title=下一页><i class="fa fa-angle-right"></i></a></nav> <footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer> <div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div> <div class=sidebar-dimmer></div> <div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div> <noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript> <script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script> <script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script> <script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script> <script src=/js/third-party/search/local-search.js></script> 