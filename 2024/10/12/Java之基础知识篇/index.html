<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hgprivate.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="数据存储概述数据在计算机中是以二进制的形式来存储，计算、赋值等操作是二进制间的操作。 进制简介进制指的是数字满多少进1。比如，二进制表示满2进1，八进制表示满8进1，十进制表示满10进1，十六进制表示满16进1。 不同类型的进制数据在Java中的定义公式也不同，它们的区别如下：  二进制：由数字0和1组成，以0b开头。 八进制：由数字0~7组成，以0开头。 十进制：由数字0~9组成，不加任何前缀。" name=description><meta content=article property=og:type><meta content=Java系列-Java基础 property=og:title><meta content=https://hgprivate.github.io/2024/10/12/Java%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content="数据存储概述数据在计算机中是以二进制的形式来存储，计算、赋值等操作是二进制间的操作。 进制简介进制指的是数字满多少进1。比如，二进制表示满2进1，八进制表示满8进1，十进制表示满10进1，十六进制表示满16进1。 不同类型的进制数据在Java中的定义公式也不同，它们的区别如下：  二进制：由数字0和1组成，以0b开头。 八进制：由数字0~7组成，以0开头。 十进制：由数字0~9组成，不加任何前缀。" property=og:description><meta content=zh_CN property=og:locale><meta content=2024-10-12T03:23:46.472Z property=article:published_time><meta content=2024-10-10T07:34:51.170Z property=article:modified_time><meta content=豪哥 property=article:author><meta content=Java基础 property=article:tag><meta content=summary name=twitter:card><link href=https://hgprivate.github.io/2024/10/12/Java%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hgprivate.github.io/2024/10/12/Java%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/","path":"2024/10/12/Java之基础知识篇/","title":"Java系列-Java基础"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>Java系列-Java基础 | 豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>豪哥博客</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8><span class=nav-number>1.</span> <span class=nav-text>数据存储</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A6%82%E8%BF%B0><span class=nav-number>1.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%BF%9B%E5%88%B6><span class=nav-number>1.2.</span> <span class=nav-text>进制</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%AE%80%E4%BB%8B><span class=nav-number>1.2.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2><span class=nav-number>1.2.2.</span> <span class=nav-text>进制转换</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B><span class=nav-number>2.</span> <span class=nav-text>数据类型</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-1><span class=nav-number>2.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2><span class=nav-number>2.2.</span> <span class=nav-text>类型转换</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-1><span class=nav-number>2.2.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2><span class=nav-number>2.2.2.</span> <span class=nav-text>隐式转换</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2><span class=nav-number>2.2.3.</span> <span class=nav-text>强制转换</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8E%9F%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81><span class=nav-number>2.3.</span> <span class=nav-text>原码、反码、补码</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8E%9F%E7%A0%81><span class=nav-number>2.3.1.</span> <span class=nav-text>原码</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8F%8D%E7%A0%81><span class=nav-number>2.3.2.</span> <span class=nav-text>反码</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%A1%A5%E7%A0%81><span class=nav-number>2.3.3.</span> <span class=nav-text>补码</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#String><span class=nav-number>2.4.</span> <span class=nav-text>String</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-2><span class=nav-number>2.4.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%88%9B%E5%BB%BAString%E5%AF%B9%E8%B1%A1><span class=nav-number>2.4.2.</span> <span class=nav-text>创建String对象</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#StringJoiner><span class=nav-number>2.4.3.</span> <span class=nav-text>StringJoiner</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86><span class=nav-number>2.4.4.</span> <span class=nav-text>底层原理</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#BigInteger><span class=nav-number>2.5.</span> <span class=nav-text>BigInteger</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9><span class=nav-number>2.5.1.</span> <span class=nav-text>注意事项</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C><span class=nav-number>2.5.2.</span> <span class=nav-text>常用操作</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-1><span class=nav-number>2.5.3.</span> <span class=nav-text>底层原理</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#BigDecimal><span class=nav-number>2.6.</span> <span class=nav-text>BigDecimal</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%89%8D%E8%A8%80><span class=nav-number>2.6.1.</span> <span class=nav-text>前言</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1><span class=nav-number>2.6.2.</span> <span class=nav-text>注意事项</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C-1><span class=nav-number>2.6.3.</span> <span class=nav-text>常用操作</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-2><span class=nav-number>2.6.4.</span> <span class=nav-text>底层原理</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%9D%A1%E4%BB%B6%E7%BB%93%E6%9E%84><span class=nav-number>3.</span> <span class=nav-text>条件结构</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%88%A4%E6%96%AD><span class=nav-number>3.1.</span> <span class=nav-text>判断</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-2><span class=nav-number>3.1.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#switch><span class=nav-number>3.1.2.</span> <span class=nav-text>switch</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%BE%AA%E7%8E%AF><span class=nav-number>3.2.</span> <span class=nav-text>循环</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-3><span class=nav-number>3.2.1.</span> <span class=nav-text>概述</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%8C%85><span class=nav-number>4.</span> <span class=nav-text>包</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BD%95%E4%B8%BA%E5%8C%85><span class=nav-number>4.1.</span> <span class=nav-text>何为包</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E4%BF%AE%E9%A5%B0%E7%AC%A6><span class=nav-number>5.</span> <span class=nav-text>修饰符</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#final><span class=nav-number>5.1.</span> <span class=nav-text>final</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AE%9A%E4%B9%89><span class=nav-number>5.1.1.</span> <span class=nav-text>定义</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BD%9C%E7%94%A8><span class=nav-number>5.1.2.</span> <span class=nav-text>作用</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%B8%B8%E9%87%8F><span class=nav-number>5.1.3.</span> <span class=nav-text>常量</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6><span class=nav-number>5.2.</span> <span class=nav-text>权限修饰符</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AE%9A%E4%B9%89-1><span class=nav-number>5.2.1.</span> <span class=nav-text>定义</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%88%86%E7%B1%BB%E5%8F%8A%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4><span class=nav-number>5.2.2.</span> <span class=nav-text>分类及作用范围</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E4%BB%A3%E7%A0%81%E5%9D%97><span class=nav-number>6.</span> <span class=nav-text>代码块</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%B1%80%E9%83%A8%E4%BB%A3%E7%A0%81%E5%9D%97><span class=nav-number>6.1.</span> <span class=nav-text>局部代码块</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AE%9A%E4%B9%89-2><span class=nav-number>6.1.1.</span> <span class=nav-text>定义</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97><span class=nav-number>6.2.</span> <span class=nav-text>构造代码块</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AE%9A%E4%B9%89-3><span class=nav-number>6.2.1.</span> <span class=nav-text>定义</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97><span class=nav-number>6.3.</span> <span class=nav-text>静态代码块</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AE%9A%E4%B9%89-4><span class=nav-number>6.3.1.</span> <span class=nav-text>定义</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1><span class=nav-number>7.</span> <span class=nav-text>面向对象</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-4><span class=nav-number>7.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1><span class=nav-number>7.2.</span> <span class=nav-text>类和对象</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-3><span class=nav-number>7.2.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AE%9A%E4%B9%89%E7%B1%BB><span class=nav-number>7.2.2.</span> <span class=nav-text>定义类</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%B0%81%E8%A3%85><span class=nav-number>7.3.</span> <span class=nav-text>封装</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-4><span class=nav-number>7.3.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#this><span class=nav-number>7.3.2.</span> <span class=nav-text>this</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95><span class=nav-number>7.3.3.</span> <span class=nav-text>构造方法</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%BB%A7%E6%89%BF><span class=nav-number>7.4.</span> <span class=nav-text>继承</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BD%95%E4%B8%BA%E7%BB%A7%E6%89%BF><span class=nav-number>7.4.1.</span> <span class=nav-text>何为继承</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%BB%A7%E6%89%BF%E7%89%B9%E7%82%B9><span class=nav-number>7.4.2.</span> <span class=nav-text>继承特点</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E7%9A%84%E5%86%85%E5%AE%B9><span class=nav-number>7.4.3.</span> <span class=nav-text>可以继承的内容</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#this%E4%B8%8Esuper%E4%BD%BF%E7%94%A8><span class=nav-number>7.4.4.</span> <span class=nav-text>this与super使用</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8F%98%E9%87%8F%E4%B8%8E%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9><span class=nav-number>7.4.5.</span> <span class=nav-text>变量与方法的访问特点</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%87%8D%E5%86%99><span class=nav-number>7.4.6.</span> <span class=nav-text>重写</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%A4%9A%E6%80%81><span class=nav-number>7.5.</span> <span class=nav-text>多态</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BD%95%E4%B8%BA%E5%A4%9A%E6%80%81><span class=nav-number>7.5.1.</span> <span class=nav-text>何为多态</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E7%89%B9%E7%82%B9><span class=nav-number>7.5.2.</span> <span class=nav-text>访问成员特点</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A4%9A%E6%80%81%E4%BC%98%E7%BC%BA%E7%82%B9><span class=nav-number>7.5.3.</span> <span class=nav-text>多态优缺点</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%8A%BD%E8%B1%A1%E7%B1%BB><span class=nav-number>8.</span> <span class=nav-text>抽象类</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-5><span class=nav-number>8.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2><span class=nav-number>8.2.</span> <span class=nav-text>注意事项</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%84%8F%E4%B9%89><span class=nav-number>8.3.</span> <span class=nav-text>抽象类意义</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%8E%A5%E5%8F%A3><span class=nav-number>9.</span> <span class=nav-text>接口</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%AE%9A%E4%B9%89-5><span class=nav-number>9.1.</span> <span class=nav-text>定义</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%88%90%E5%91%98%E7%89%B9%E7%82%B9><span class=nav-number>9.2.</span> <span class=nav-text>成员特点</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB><span class=nav-number>9.3.</span> <span class=nav-text>类与接口的关系</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%8E%A5%E5%8F%A3%E6%96%B0%E5%8F%98%E5%8C%96><span class=nav-number>9.4.</span> <span class=nav-text>接口新变化</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#JDK8%E6%96%B0%E5%8F%98%E5%8C%96><span class=nav-number>9.4.1.</span> <span class=nav-text>JDK8新变化</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#JDK9%E6%96%B0%E5%8F%98%E5%8C%96><span class=nav-number>9.4.2.</span> <span class=nav-text>JDK9新变化</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%86%85%E9%83%A8%E7%B1%BB><span class=nav-number>10.</span> <span class=nav-text>内部类</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-6><span class=nav-number>10.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%86%85%E9%83%A8%E7%B1%BB%E5%88%86%E7%B1%BB><span class=nav-number>10.2.</span> <span class=nav-text>内部类分类</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB><span class=nav-number>10.3.</span> <span class=nav-text>成员内部类</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-5><span class=nav-number>10.3.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB><span class=nav-number>10.3.2.</span> <span class=nav-text>使用内部类</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B><span class=nav-number>10.3.3.</span> <span class=nav-text>代码示例</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB><span class=nav-number>10.4.</span> <span class=nav-text>静态内部类</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-6><span class=nav-number>10.4.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB-1><span class=nav-number>10.4.2.</span> <span class=nav-text>使用内部类</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1><span class=nav-number>10.4.3.</span> <span class=nav-text>代码示例</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB><span class=nav-number>10.5.</span> <span class=nav-text>局部内部类</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-7><span class=nav-number>10.5.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-2><span class=nav-number>10.5.2.</span> <span class=nav-text>代码示例</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB><span class=nav-number>10.6.</span> <span class=nav-text>匿名内部类</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-8><span class=nav-number>10.6.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-3><span class=nav-number>10.6.2.</span> <span class=nav-text>代码示例</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%85%8B%E9%9A%86><span class=nav-number>11.</span> <span class=nav-text>克隆</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-7><span class=nav-number>11.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BD%BF%E7%94%A8%E5%85%8B%E9%9A%86><span class=nav-number>11.2.</span> <span class=nav-text>使用克隆</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F><span class=nav-number>12.</span> <span class=nav-text>正则表达式</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-8><span class=nav-number>12.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%A7%84%E5%88%99><span class=nav-number>12.2.</span> <span class=nav-text>规则</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%88%86%E7%BB%84><span class=nav-number>12.3.</span> <span class=nav-text>分组</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-9><span class=nav-number>12.3.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%88%86%E7%B1%BB><span class=nav-number>12.3.2.</span> <span class=nav-text>分类</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%BB%84%E5%8F%B7><span class=nav-number>12.3.3.</span> <span class=nav-text>组号</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%B3%9B%E5%9E%8B><span class=nav-number>13.</span> <span class=nav-text>泛型</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-9><span class=nav-number>13.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%80%9A%E9%85%8D%E7%AC%A6><span class=nav-number>13.2.</span> <span class=nav-text>继承与通配符</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%BB%A7%E6%89%BF-1><span class=nav-number>13.2.1.</span> <span class=nav-text>继承</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E9%80%9A%E9%85%8D%E7%AC%A6><span class=nav-number>13.2.2.</span> <span class=nav-text>通配符</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E9%9B%86%E5%90%88><span class=nav-number>14.</span> <span class=nav-text>集合</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-10><span class=nav-number>14.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84><span class=nav-number>14.2.</span> <span class=nav-text>数据结构</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%A0%91><span class=nav-number>14.2.1.</span> <span class=nav-text>树</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-11><span class=nav-number>14.2.1.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86><span class=nav-number>14.2.1.2.</span> <span class=nav-text>二叉树遍历</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%97%8B%E8%BD%AC><span class=nav-number>14.2.1.3.</span> <span class=nav-text>平衡二叉树旋转</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%BA%A2%E9%BB%91%E6%A0%91><span class=nav-number>14.2.1.4.</span> <span class=nav-text>红黑树</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Set><span class=nav-number>14.3.</span> <span class=nav-text>Set</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#HashSet><span class=nav-number>14.3.1.</span> <span class=nav-text>HashSet</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#LinkedHashSet><span class=nav-number>14.3.2.</span> <span class=nav-text>LinkedHashSet</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#TreeSet><span class=nav-number>14.3.3.</span> <span class=nav-text>TreeSet</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF><span class=nav-number>14.3.4.</span> <span class=nav-text>使用场景</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Map><span class=nav-number>14.4.</span> <span class=nav-text>Map</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#HashMap><span class=nav-number>14.4.1.</span> <span class=nav-text>HashMap</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#LinkedHashMap><span class=nav-number>14.4.2.</span> <span class=nav-text>LinkedHashMap</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#TreeMap><span class=nav-number>14.4.3.</span> <span class=nav-text>TreeMap</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#Collections><span class=nav-number>14.5.</span> <span class=nav-text>Collections</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-10><span class=nav-number>14.5.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%B8%B8%E7%94%A8API><span class=nav-number>14.5.2.</span> <span class=nav-text>常用API</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88><span class=nav-number>14.6.</span> <span class=nav-text>不可变集合</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-11><span class=nav-number>14.6.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88><span class=nav-number>14.6.2.</span> <span class=nav-text>创建不可变集合</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%80%BB%E7%BB%93><span class=nav-number>14.7.</span> <span class=nav-text>总结</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#Stream><span class=nav-number>15.</span> <span class=nav-text>Stream</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-12><span class=nav-number>15.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%8E%B7%E5%8F%96Stream><span class=nav-number>15.2.</span> <span class=nav-text>获取Stream</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95><span class=nav-number>15.3.</span> <span class=nav-text>常用方法</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8><span class=nav-number>16.</span> <span class=nav-text>方法引用</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-13><span class=nav-number>16.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6><span class=nav-number>16.2.</span> <span class=nav-text>使用条件</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BD%BF%E7%94%A8%E5%88%86%E7%B1%BB><span class=nav-number>16.3.</span> <span class=nav-text>使用分类</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%BC%82%E5%B8%B8><span class=nav-number>17.</span> <span class=nav-text>异常</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-14><span class=nav-number>17.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8><span class=nav-number>17.2.</span> <span class=nav-text>处理异常</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%A4%84%E7%90%86%E5%88%86%E7%B1%BB><span class=nav-number>17.2.1.</span> <span class=nav-text>处理分类</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8><span class=nav-number>17.2.2.</span> <span class=nav-text>抛出异常</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#File><span class=nav-number>18.</span> <span class=nav-text>File</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%8E%B7%E5%8F%96%E5%92%8C%E9%81%8D%E5%8E%86><span class=nav-number>18.1.</span> <span class=nav-text>获取和遍历</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#IO%E6%B5%81><span class=nav-number>19.</span> <span class=nav-text>IO流</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-15><span class=nav-number>19.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%87%AA%E5%8A%A8%E5%85%B3%E6%B5%81><span class=nav-number>19.2.</span> <span class=nav-text>自动关流</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%AD%97%E7%AC%A6%E9%9B%86><span class=nav-number>19.3.</span> <span class=nav-text>字符集</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E8%A7%84%E5%88%99><span class=nav-number>19.3.1.</span> <span class=nav-text>计算机存储规则</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AD%97%E7%AC%A6%E9%9B%86%E6%BC%94%E5%8F%98><span class=nav-number>19.3.2.</span> <span class=nav-text>字符集演变</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#GB2312%E5%AD%97%E7%AC%A6%E9%9B%86><span class=nav-number>19.3.2.1.</span> <span class=nav-text>GB2312字符集</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#BIG5%E5%AD%97%E7%AC%A6%E9%9B%86><span class=nav-number>19.3.2.2.</span> <span class=nav-text>BIG5字符集</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#GBK%E5%AD%97%E7%AC%A6%E9%9B%86><span class=nav-number>19.3.2.3.</span> <span class=nav-text>GBK字符集</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Unicode%E5%AD%97%E7%AC%A6%E9%9B%86><span class=nav-number>19.3.2.4.</span> <span class=nav-text>Unicode字符集</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AD%97%E7%AC%A6%E5%AD%98%E8%AF%BB%E8%A7%84%E5%88%99><span class=nav-number>19.3.3.</span> <span class=nav-text>字符存读规则</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%8B%B1%E6%96%87><span class=nav-number>19.3.3.1.</span> <span class=nav-text>英文</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%B1%89%E5%AD%97><span class=nav-number>19.3.3.2.</span> <span class=nav-text>汉字</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-3><span class=nav-number>19.3.3.3.</span> <span class=nav-text>注意事项</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%AD%97%E8%8A%82%E6%B5%81><span class=nav-number>19.4.</span> <span class=nav-text>字节流</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-16><span class=nav-number>19.4.1.</span> <span class=nav-text>概述</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%AD%97%E7%AC%A6%E6%B5%81><span class=nav-number>19.5.</span> <span class=nav-text>字符流</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-17><span class=nav-number>19.5.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-3><span class=nav-number>19.5.2.</span> <span class=nav-text>底层原理</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81><span class=nav-number>19.5.2.1.</span> <span class=nav-text>字符输入流</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81><span class=nav-number>19.5.2.2.</span> <span class=nav-text>字符输出流</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%BC%93%E5%86%B2%E6%B5%81><span class=nav-number>19.6.</span> <span class=nav-text>缓冲流</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-18><span class=nav-number>19.6.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81><span class=nav-number>19.6.2.</span> <span class=nav-text>字节缓冲流</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81><span class=nav-number>19.6.3.</span> <span class=nav-text>字符缓冲流</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%BD%AC%E6%8D%A2%E6%B5%81><span class=nav-number>19.7.</span> <span class=nav-text>转换流</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-19><span class=nav-number>19.7.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BD%AC%E6%8D%A2%E6%B5%81><span class=nav-number>19.7.2.</span> <span class=nav-text>字符输入转换流</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E8%BD%AC%E6%8D%A2%E6%B5%81><span class=nav-number>19.7.3.</span> <span class=nav-text>字符输出转换流</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81><span class=nav-number>19.8.</span> <span class=nav-text>序列化流</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-20><span class=nav-number>19.8.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%AD%A3%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81><span class=nav-number>19.8.2.</span> <span class=nav-text>正序列化流</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81><span class=nav-number>19.8.3.</span> <span class=nav-text>反序列化流</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%89%93%E5%8D%B0%E6%B5%81><span class=nav-number>19.9.</span> <span class=nav-text>打印流</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-21><span class=nav-number>19.9.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AD%97%E8%8A%82%E6%89%93%E5%8D%B0%E6%B5%81><span class=nav-number>19.9.2.</span> <span class=nav-text>字节打印流</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AD%97%E7%AC%A6%E6%89%93%E5%8D%B0%E6%B5%81><span class=nav-number>19.9.3.</span> <span class=nav-text>字符打印流</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B><span class=nav-number>20.</span> <span class=nav-text>线程编程</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%BA%BF%E7%A8%8B><span class=nav-number>20.1.</span> <span class=nav-text>线程</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-22><span class=nav-number>20.1.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F><span class=nav-number>20.1.2.</span> <span class=nav-text>实现方式</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%90%8C%E6%AD%A5><span class=nav-number>20.2.</span> <span class=nav-text>同步</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-23><span class=nav-number>20.2.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97><span class=nav-number>20.2.2.</span> <span class=nav-text>同步代码块</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95><span class=nav-number>20.2.3.</span> <span class=nav-text>同步方法</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%BA%BF%E7%A8%8B%E6%B1%A0><span class=nav-number>20.3.</span> <span class=nav-text>线程池</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-24><span class=nav-number>20.3.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0><span class=nav-number>20.3.2.</span> <span class=nav-text>创建线程池</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B><span class=nav-number>21.</span> <span class=nav-text>网络编程</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-25><span class=nav-number>21.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84><span class=nav-number>21.2.</span> <span class=nav-text>软件架构</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%B8%89%E8%A6%81%E7%B4%A0><span class=nav-number>21.3.</span> <span class=nav-text>三要素</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#IP><span class=nav-number>21.3.1.</span> <span class=nav-text>IP</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#IPV4><span class=nav-number>21.3.1.1.</span> <span class=nav-text>IPV4</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#IPV6><span class=nav-number>21.3.1.2.</span> <span class=nav-text>IPV6</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%AB%AF%E5%8F%A3%E5%8F%B7><span class=nav-number>21.3.2.</span> <span class=nav-text>端口号</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%8D%8F%E8%AE%AE><span class=nav-number>21.3.3.</span> <span class=nav-text>协议</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-26><span class=nav-number>21.3.3.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#UDP%E5%8D%8F%E8%AE%AE><span class=nav-number>21.3.3.2.</span> <span class=nav-text>UDP协议</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#TCP%E5%8D%8F%E8%AE%AE><span class=nav-number>21.3.3.3.</span> <span class=nav-text>TCP协议</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-12><span class=nav-number>21.3.3.3.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B><span class=nav-number>21.3.3.3.2.</span> <span class=nav-text>三次握手</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B><span class=nav-number>21.3.3.3.3.</span> <span class=nav-text>四次挥手</span></a></ol></ol></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%8F%8D%E5%B0%84><span class=nav-number>22.</span> <span class=nav-text>反射</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-27><span class=nav-number>22.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E7%AE%A1%E7%90%86%E7%B1%BB%E6%88%90%E5%91%98><span class=nav-number>22.2.</span> <span class=nav-text>管理类成员</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1><span class=nav-number>22.2.1.</span> <span class=nav-text>获取Class对象</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%AE%A1%E7%90%86%E5%AD%97%E6%AE%B5><span class=nav-number>22.2.2.</span> <span class=nav-text>管理字段</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%AE%A1%E7%90%86%E6%9E%84%E9%80%A0%E5%99%A8><span class=nav-number>22.2.3.</span> <span class=nav-text>管理构造器</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95><span class=nav-number>22.2.4.</span> <span class=nav-text>管理方法</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86><span class=nav-number>23.</span> <span class=nav-text>动态代理</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%A6%82%E8%BF%B0-28><span class=nav-number>23.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86><span class=nav-number>23.2.</span> <span class=nav-text>创建代理</span></a></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>116</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>36</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>129</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://hgprivate.github.io/2024/10/12/Java%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="Java系列-Java基础 | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>Java系列-Java基础</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-10-12 11:23:46" datetime=2024-10-12T11:23:46+08:00>2024-10-12</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2024-10-10 15:34:51" datetime=2024-10-10T15:34:51+08:00 itemprop=dateModified>2024-10-10</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Java%E5%9F%BA%E7%A1%80/ itemprop=url rel=index><span itemprop=name>Java基础</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=数据存储><a class=headerlink href=#数据存储 title=数据存储></a>数据存储</h1><h2 id=概述><a class=headerlink href=#概述 title=概述></a>概述</h2><p><strong>数据在计算机中是以二进制的形式来存储，计算、赋值等操作是二进制间的操作</strong>。<h2 id=进制><a class=headerlink href=#进制 title=进制></a>进制</h2><h3 id=简介><a class=headerlink href=#简介 title=简介></a>简介</h3><p>进制指的是数字满多少进1。比如，二进制表示满2进1，八进制表示满8进1，十进制表示满10进1，十六进制表示满16进1。<p>不同类型的进制数据在Java中的定义公式也不同，它们的区别如下：<ul><li>二进制：由数字0和1组成，以0b开头。<li>八进制：由数字0~7组成，以0开头。<li>十进制：由数字0~9组成，不加任何前缀。<li>十六进制：由数字0<del>9和字母a</del>f组成，以0X开头。</ul><blockquote><p>Java7开始支持上面这种格式的写法。</blockquote><h3 id=进制转换><a class=headerlink href=#进制转换 title=进制转换></a>进制转换</h3><p><strong>任意进制转为十进制的规则为：计算每个<code>系数*基数的权次幂</code>，相加结果就是十进制。</strong>这里的系数就是每个位置上的数字。这里的基数就是进制类型，二进制就是2，八进制就是8。这里的权表示原始进制类型的数字列表从右到左，权从0开始依次加1。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment>// 二进制转十进制</span></span><br><span class=line><span class=number>1010</span> -> <span class=number>0</span>*<span class=number>2</span>^<span class=number>0</span> + <span class=number>1</span>*<span class=number>2</span>^<span class=number>1</span> + <span class=number>0</span>*<span class=number>2</span>^<span class=number>2</span> + <span class=number>1</span>*<span class=number>2</span>^<span class=number>3</span> = <span class=number>0</span> + <span class=number>2</span> + <span class=number>0</span> + <span class=number>8</span> = <span class=number>10</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// 八进制转十进制</span></span><br><span class=line><span class=number>1010</span> -> <span class=number>0</span>*<span class=number>8</span>^<span class=number>0</span> + <span class=number>1</span>*<span class=number>8</span>^<span class=number>1</span> + <span class=number>0</span>*<span class=number>8</span>^<span class=number>2</span> + <span class=number>1</span>*<span class=number>8</span>^<span class=number>3</span> = <span class=number>0</span> + <span class=number>8</span> + <span class=number>0</span> + <span class=number>512</span> = <span class=number>520</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// 十六进制转十进制</span></span><br><span class=line>abc -> <span class=number>12</span>*<span class=number>16</span>^<span class=number>0</span> + <span class=number>11</span>*<span class=number>16</span>^<span class=number>1</span> + <span class=number>10</span>*<span class=number>16</span>^<span class=number>2</span> = <span class=number>2748</span>;</span><br></pre></table></figure><p><strong>十进制转其它进制类型的方法为除基取余法</strong>，规则为：不断除以基数（基数表示进制类型，几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼接起来即可得到对应的进制数。<h1 id=数据类型><a class=headerlink href=#数据类型 title=数据类型></a>数据类型</h1><h2 id=概述-1><a class=headerlink href=#概述-1 title=概述></a>概述</h2><p>Java中提供了基本数据类型和引用数据类型两个类别。<p><strong>基本数据类型共有8个：boolean、byte、short、char、float、int、long、double</strong>。它们的包装类分别为：Boolean、Byte、Short、Character、Float、Integer、Long、Double。按类别又分为4种：整数型（byte/short/int/long）、浮点型（float/double）、字符（char）、布尔（boolean）。<p><strong>引用数据类型共有3个：数组、类、接口</strong>。<table><thead><tr><th align=center>数据类型<th align=center>大小（字节）<th align=center>默认值<th align=center>最小值<th align=center>最大值<tbody><tr><td align=center>boolean<td align=center>1个字节<td align=center>false<td align=center><td align=center><tr><td align=center>byte<td align=center>1个字节<td align=center>0<td align=center>-128<td align=center>127<tr><td align=center>short<td align=center>2个字节<td align=center>0<td align=center>-32768<td align=center>32767<tr><td align=center>char<td align=center>2个字节<td align=center>‘\u0000’（0）<td align=center>‘\u0000’（0）<td align=center>‘\uFFFF’（65535）<tr><td align=center>float<td align=center>4个字节<td align=center>0.0F<td align=center>1.4E-45<td align=center>3.4028235E38<tr><td align=center>int<td align=center>4个字节<td align=center>0<td align=center>-2147483648<td align=center>2147483647<tr><td align=center>long<td align=center>8个字节<td align=center>0.0<td align=center>-2^63<td align=center>2^63-1<tr><td align=center>double<td align=center>8个字节<td align=center>0.0D<td align=center>4.9E-324<td align=center>1.7976931348623157E308</table><p>基本类型和引用类型在存储数据时有区别：<ul><li>基本类型：数据值存储在自己的空间中，赋值给其它基本类型变量时也是赋值的真实数据值。<li>引用类型：数据值存储在其它空间中，自己空间中存储的是该数据在空间中的地址。赋值给其它引用类型变量时也是赋值的地址。</ul><h2 id=类型转换><a class=headerlink href=#类型转换 title=类型转换></a>类型转换</h2><h3 id=简介-1><a class=headerlink href=#简介-1 title=简介></a>简介</h3><p><strong>Java中的各种类型的数据在进行计算和赋值时会进行类型的转换，这种转换分为两种：隐式自动转换 和 强制显式转换</strong>。<p><font color=red>注意：不能对boolean类型进行类型转换。</font><h3 id=隐式转换><a class=headerlink href=#隐式转换 title=隐式转换></a>隐式转换</h3><p><strong>隐式转换指的是把一个取值范围小的数值类型转成取值范围大的数值类型</strong>。<p>隐式转换有如下一些规则：<ul><li>取值范围小的和取值范围大的数值进行运算前，会先将取值小的数值类型提升为大的，然后再进行计算。<li>byte、short、char三种类型的值在运算时，会先将它们都转为int类型，然后再进行计算。</ul><blockquote><p>char类型字符在与数字进行计算时，会先得到字符在ASCII码表中对应的十进制数字，然后基于该数字来与其它数值进行计算，计算规则符合前面说的。</blockquote><p>代码示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=comment>// 示例1</span></span><br><span class=line><span class=type>int</span> <span class=variable>a</span> <span class=operator>=</span> <span class=number>1</span>;</span><br><span class=line><span class=type>double</span> <span class=variable>d</span> <span class=operator>=</span> a; <span class=comment>// 将int类型自动隐式转换为double类型。</span></span><br><span class=line></span><br><span class=line><span class=comment>// 示例2</span></span><br><span class=line><span class=type>int</span> <span class=variable>a</span> <span class=operator>=</span> <span class=number>10</span>;</span><br><span class=line><span class=type>double</span> <span class=variable>d</span> <span class=operator>=</span> <span class=number>20</span>;</span><br><span class=line><span class=type>double</span> <span class=variable>result</span> <span class=operator>=</span> a + d; <span class=comment>// 先将a转为double类型，然后与d计算，结果值为double类型。</span></span><br><span class=line></span><br><span class=line><span class=comment>// 示例3</span></span><br><span class=line><span class=type>byte</span> <span class=variable>b1</span> <span class=operator>=</span> <span class=number>10</span>;</span><br><span class=line><span class=type>byte</span> <span class=variable>b2</span> <span class=operator>=</span> <span class=number>30</span>;</span><br><span class=line><span class=type>int</span> <span class=variable>result</span> <span class=operator>=</span> b1 + b2; <span class=comment>// 先将b1和b2都转为int类型，然后再计算，结果值为int类型。</span></span><br></pre></table></figure><h3 id=强制转换><a class=headerlink href=#强制转换 title=强制转换></a>强制转换</h3><p><strong>强制转换指的是将取值范围大的数值类型转为取值范围小的数值类型</strong>，强制转换的格式为：<code>目标数据类型 变量名 = (目标数据类型)被强转的数据;</code>。<blockquote><p>将取值范围大的数值类型转为取值范围小的数值类型，这种情况理论上不允许，但可以通过强制转换来实现。但要注意的是，<strong>对于浮点类型，强制转换后，数据的精度会丢失</strong>。<p><strong>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入。</strong></blockquote><p>代码示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>double</span> <span class=variable>d</span> <span class=operator>=</span> <span class=number>12.3</span>;</span><br><span class=line><span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> (<span class=type>int</span>)d;	<span class=comment>// 12</span></span><br></pre></table></figure><h2 id=原码、反码、补码><a class=headerlink href=#原码、反码、补码 title=原码、反码、补码></a>原码、反码、补码</h2><h3 id=原码><a class=headerlink href=#原码 title=原码></a>原码</h3><p><strong>原码指的是十进制数据的二进制表现形式，最左边的一位是符号位，0表示正数，1表示负数</strong>。<p>利用原码进行计算时，如果参与计算的数为正数，那么没有问题，如果参与计算的数为负数，那么结果就会出错，实际运算的方向与正确的方向相反。<p>为了解决这种问题，提出了反码。<h3 id=反码><a class=headerlink href=#反码 title=反码></a>反码</h3><p>正数的反码不变，负数的反码是在原码基础上，符号位不变，其它位取反，即0变1，1变0。<p>反码在参与计算时，如果计算结果不跨0，则没有问题，如果结果跨0，则与正确的结果会有1的偏差。<p>为了解决这种问题，提出了补码。<h3 id=补码><a class=headerlink href=#补码 title=补码></a>补码</h3><p>正数的补码不变，负数的补码是在反码基础上+1。补码可以多记录一个特殊值-128，该数据在1个字节下，没有原码和反码。<h2 id=String><a class=headerlink href=#String title=String></a>String</h2><h3 id=简介-2><a class=headerlink href=#简介-2 title=简介></a>简介</h3><p>String是Java定义好的java.lang包中的一个String字符串类。该字符串类是不可变的，每次修改内容都会创建一个新的String对象。<h3 id=创建String对象><a class=headerlink href=#创建String对象 title=创建String对象></a>创建String对象</h3><p>创建String对象的方式有两种：直接赋值 和 使用new关键字。<ul><li>直接赋值：String str = “abc”;<li>new创建：String str = new String(空参/字符串/char数组/byte数组);</ul><h3 id=StringJoiner><a class=headerlink href=#StringJoiner title=StringJoiner></a>StringJoiner</h3><p><strong>JDK8开始提供了一个类StringJoiner。</strong>它与StringBuilder一样，可看作是一个容器，创建StringJoiner对象后，里面的内容是可变的。StringJoiner的作用是提高字符串的操作效率。<p>通过构造方法并指定形参可创建一个符合需求的StringJoiner对象，通过add方法即可添加数据，最终结果就是想要的效果。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// 创建对象</span></span><br><span class=line><span class=type>StringJoiner</span> <span class=variable>sj</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StringJoiner</span>(间隔符号);</span><br><span class=line><span class=type>StringJoiner</span> <span class=variable>sj2</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StringJoiner</span>(间隔符号，开始符号，结束符号);</span><br><span class=line><span class=type>StringJoiner</span> <span class=variable>sj3</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StringJoiner</span>(<span class=string>","</span>，<span class=string>"["</span>，<span class=string>"]"</span>);</span><br><span class=line>sj3.add(<span class=string>"a"</span>).add(<span class=string>"b"</span>).add(<span class=string>"c"</span>);</span><br><span class=line>System.out.println(sj3); <span class=comment>// [a, b, c]</span></span><br></pre></table></figure><h3 id=底层原理><a class=headerlink href=#底层原理 title=底层原理></a>底层原理</h3><p>字符串存储的底层原理：直接赋值会复用字符串常量池中的内容，而new出来的会在堆中开辟一个空间来存储。<p>双等号比较的底层原理：基本类型比较的是值，引用类型比较的是地址。<p>字符串拼接的底层原理：<ul><li><strong>拼接成员全是字符串字面量</strong>：会触发字符串优化机制，编译期就可以得到拼接结果，最终会把结果放进字符串常量池中。<li><strong>拼接成员中存在对象引用</strong>：JDK8之前会使用StringBuilder来拼接。JDK8开始做了优化，会先预估字符串拼接结果的长度，然后基于该长度创建一个数组，然后将各个参与成员字符串放进数组中，最终根据该数组再创建一个代表拼接结果的字符串。不论如何，最终会在堆中创建一个对象，拼接结果会保存在堆中。</ul><p>上面第二种情况中，尽管JDK8做了优化，但底层依然会创建多个对象，效率并没有大的提升。所以，<strong>对于字符串拼接的需求，推荐使用StringBuilder来实现</strong>。<p><strong>StringBuilder为何高效？</strong><p>当创建一个StringBuilder对象后，底层会创建一个容量为16的字节数组，然后将要添加的字符在ASCII码表中对应的十进制数字按顺序放入字节数组中，当空间满时会进行扩容，新容量的计算公式为：<code>旧容量*2+2;</code>。当要添加的元素数量超过扩容后的容量时以要添加元素的数量为大小来扩容。<h2 id=BigInteger><a class=headerlink href=#BigInteger title=BigInteger></a>BigInteger</h2><h3 id=注意事项><a class=headerlink href=#注意事项 title=注意事项></a>注意事项</h3><ul><li>如果BigInteger表示的数字<strong>没有超出long的范围</strong>，可以<strong>使用静态方法</strong>获取；<li>如果BigInteger表示的数字<strong>超出long的范围</strong>，可以<strong>使用构造方法</strong>获取，推荐直接使用该种方式；<li>BigInteger对象创建后，内部的值不能发生改变；<li>BigInteger对象经过计算后会得到一个新的对象；</ul><h3 id=常用操作><a class=headerlink href=#常用操作 title=常用操作></a>常用操作</h3><ul><li>加/减/乘/除：add/subtract/multiply/divide；<li>比较：equals/max/min；<li>次幂：pow；<li>转为基本类型：intValue/doubleValue/…；</ul><h3 id=底层原理-1><a class=headerlink href=#底层原理-1 title=底层原理></a>底层原理</h3><p>如何存储一个超出long范围的数字呢？<p>解决方法是：<strong>先将源数字转为二进制，然后以32位的长度分组，然后再将每一组的二进制位转为10进制数字，多个组就得到了多个10进制数字，最后再将这些十进制数字放入一个int数组中保存</strong>。<h2 id=BigDecimal><a class=headerlink href=#BigDecimal title=BigDecimal></a>BigDecimal</h2><h3 id=前言><a class=headerlink href=#前言 title=前言></a>前言</h3><p>小数在计算机中是通过二进制进行存储，它的二进制位数量可能非常多，在与其它小数进行计算时，无法得出准确结果。<p>为了解决小数计算无法得出准确结果的问题，BigDecimal就出现了，它可以解决这种问题。<h3 id=注意事项-1><a class=headerlink href=#注意事项-1 title=注意事项></a>注意事项</h3><ul><li>如果BigDecimal表示的数字<strong>没有超出double的范围</strong>，可以<strong>使用静态方法</strong>获取对象；<li>如果BigDecimal表示的数字<strong>超出double的范围</strong>，可以<strong>使用构造方法</strong>获取对象；<li>BigDecimal默认已经缓存好整数0<del>10的对象，如果获取整数0</del>10的BigDecimal对象，那么会直接返回已经创建好的对象。</ul><h3 id=常用操作-1><a class=headerlink href=#常用操作-1 title=常用操作></a>常用操作</h3><ul><li>加/减/乘/除：add/subtract/multiply/divide；<li>除：divide(x)/divide(x, 精确位，进制算法)；</ul><h3 id=底层原理-2><a class=headerlink href=#底层原理-2 title=底层原理></a>底层原理</h3><p>如何存储一个超出double范围的小数呢？<p>解决方法是：<strong>先将小数转为字符串，然后将字符串转为字符数组，拿到每个字符在ASSCI码表中对应的数值，然后将这些数值放入一个int数组中存储</strong>。<h1 id=条件结构><a class=headerlink href=#条件结构 title=条件结构></a>条件结构</h1><h2 id=判断><a class=headerlink href=#判断 title=判断></a>判断</h2><h3 id=概述-2><a class=headerlink href=#概述-2 title=概述></a>概述</h3><p>判断结构有多种，它们为：if、switch等。<h3 id=switch><a class=headerlink href=#switch title=switch></a>switch</h3><p><strong>JDK5开始switch支持枚举类型，JDK7开始支持字符串类型。</strong><p>switch使用格式与示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=type>int</span> <span class=variable>number</span> <span class=operator>=</span> <span class=number>10</span>;</span><br><span class=line><span class=keyword>switch</span>(number){</span><br><span class=line>  <span class=keyword>case</span> <span class=number>1</span>:</span><br><span class=line>        <span class=comment>// 操作1</span></span><br><span class=line>        <span class=keyword>break</span>;</span><br><span class=line>  <span class=keyword>case</span> <span class=number>2</span>:</span><br><span class=line>        <span class=comment>// 操作2</span></span><br><span class=line>        <span class=keyword>break</span>;</span><br><span class=line>  <span class=keyword>default</span>:</span><br><span class=line>        <span class=comment>// 默认操作</span></span><br><span class=line>}</span><br></pre></table></figure><p>switch使用注意事项如下：<ul><li>case穿透问题：每个分支中没有写break语句造成。</ul><p><strong>JDK12开始对switch语法结构进行了优化，可以直接使用小箭头+大括号即可，大括号中编写分支逻辑。</strong>详情示例可参考如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment>// 如果括号{}中代码只有一行，那么括号也可以省略。</span></span><br><span class=line><span class=type>int</span> <span class=variable>number</span> <span class=operator>=</span> <span class=number>10</span>;</span><br><span class=line><span class=keyword>switch</span>(number){</span><br><span class=line>  <span class=keyword>case</span> <span class=number>1</span>, <span class=number>2</span>, <span class=number>3</span>, <span class=number>4</span>, <span class=number>5</span> -> {}</span><br><span class=line>  <span class=keyword>case</span> <span class=number>6</span>, <span class=number>7</span> -> {}</span><br><span class=line>  <span class=keyword>case</span> <span class=number>8</span> -> {}</span><br><span class=line>  <span class=keyword>default</span> -> {}</span><br><span class=line>}</span><br></pre></table></figure><h2 id=循环><a class=headerlink href=#循环 title=循环></a>循环</h2><h3 id=概述-3><a class=headerlink href=#概述-3 title=概述></a>概述</h3><p>循环有多种，它们为：for、while、do…while。<h1 id=包><a class=headerlink href=#包 title=包></a>包</h1><h2 id=何为包><a class=headerlink href=#何为包 title=何为包></a>何为包</h2><p>包就是文件夹。它用来管理分类各种不同功能的Java类，方便维护。<p>包名的规则通常为：公司域名反写 + 模块或作用名。比如：com.google.util。<p><strong>包名+类名</strong>表示一个类的<strong>全类名或全限定名</strong>。<h1 id=修饰符><a class=headerlink href=#修饰符 title=修饰符></a>修饰符</h1><h2 id=final><a class=headerlink href=#final title=final></a>final</h2><h3 id=定义><a class=headerlink href=#定义 title=定义></a>定义</h3><p>final表示最终，不可改变。<h3 id=作用><a class=headerlink href=#作用 title=作用></a>作用</h3><p>final可以修饰类、变量、方法，当修饰它们时会对它们添加如下几个规则：<ul><li>变量：final修饰后通常称其为<strong>常量</strong>，该常量只能在被定义时显式赋值一次；<li>方法：final修饰后，该方法不能被重写；<li>类：final修饰后，该类不能被继承；</ul><h3 id=常量><a class=headerlink href=#常量 title=常量></a>常量</h3><p>常量一般作为系统配置信息，方便维护，提高可读性。<p>常量的命名规则：单词全部大写，多个单词时，单词间用下划线隔开。<h2 id=权限修饰符><a class=headerlink href=#权限修饰符 title=权限修饰符></a>权限修饰符</h2><h3 id=定义-1><a class=headerlink href=#定义-1 title=定义></a>定义</h3><p>权限修饰符用来控制一个成员是否可以被访问。它可以修饰内部类、变量、构造方法、方法。<h3 id=分类及作用范围><a class=headerlink href=#分类及作用范围 title=分类及作用范围></a>分类及作用范围</h3><table><thead><tr><th align=center>修饰符/分类<th align=center>同一个类<th align=center>同一个包<th align=center>其它包的子类<th align=center>其它包的无关类<tbody><tr><td align=center>private<td align=center>可以✔<td align=center><td align=center><td align=center><tr><td align=center>空着不写<td align=center>可以✔<td align=center>可以✔<td align=center><td align=center><tr><td align=center>protected<td align=center>可以✔<td align=center>可以✔<td align=center>可以✔<td align=center><tr><td align=center>public<td align=center>可以✔<td align=center>可以✔<td align=center>可以✔<td align=center>可以✔</table><h1 id=代码块><a class=headerlink href=#代码块 title=代码块></a>代码块</h1><h2 id=局部代码块><a class=headerlink href=#局部代码块 title=局部代码块></a>局部代码块</h2><h3 id=定义-2><a class=headerlink href=#定义-2 title=定义></a>定义</h3><p>局部代码块指的是写在方法中的代码块。<p>局部代码块主要用来提前结束变量的生命周期。<h2 id=构造代码块><a class=headerlink href=#构造代码块 title=构造代码块></a>构造代码块</h2><h3 id=定义-3><a class=headerlink href=#定义-3 title=定义></a>定义</h3><p>构造代码块指的是写在类成员位置的代码块。<p><strong>构造代码块先于构造器执行，且每当构造器执行时它都会执行一次</strong>。<h2 id=静态代码块><a class=headerlink href=#静态代码块 title=静态代码块></a>静态代码块</h2><h3 id=定义-4><a class=headerlink href=#定义-4 title=定义></a>定义</h3><p>静态代码块指的是写在类成员位置的被static关键字修饰的代码块。<p><strong>静态代码块会随着类的加载而加载，自动触发且仅执行一次</strong>。<h1 id=面向对象><a class=headerlink href=#面向对象 title=面向对象></a>面向对象</h1><h2 id=概述-4><a class=headerlink href=#概述-4 title=概述></a>概述</h2><p>面向对象中的面向指的是查找寻找，对象指的是具备属性和功能的个体。面向对象编程就是通过这个个体来实现某些功能和需求。<h2 id=类和对象><a class=headerlink href=#类和对象 title=类和对象></a>类和对象</h2><h3 id=简介-3><a class=headerlink href=#简介-3 title=简介></a>简介</h3><p>类是对象共同特征的描述，对象是通过类创建出来的具体物体。Java中必须先有类，才会有对象。<h3 id=定义类><a class=headerlink href=#定义类 title=定义类></a>定义类</h3><p>通过关键字<code>public class</code>可定义一个类，类中可以包括：成员变量、代码块、构造器、成员方法、内部类等。<p>一个Java类的示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Animal</span> {</span><br><span class=line>    <span class=comment>//成员变量</span></span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> Integer age;</span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 代码块</span></span><br><span class=line>    {</span><br><span class=line>        <span class=comment>//...</span></span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>static</span> {</span><br><span class=line>        <span class=comment>//...</span></span><br><span class=line>    }</span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 构造方法</span></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Animal</span><span class=params>()</span>{}</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Animal</span><span class=params>(String name)</span>{</span><br><span class=line>        <span class=comment>//...</span></span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Animal</span><span class=params>(Strng name, Integer age)</span>{</span><br><span class=line>        <span class=comment>//...</span></span><br><span class=line>    }</span><br><span class=line>    </span><br><span class=line>    <span class=comment>// 成员方法</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">show</span><span class=params>(String name)</span>{</span><br><span class=line>        <span class=comment>//...</span></span><br><span class=line>        <span class=comment>// 布局代码块</span></span><br><span class=line>        {</span><br><span class=line>            <span class=comment>//...</span></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    </span><br><span class=line>    <span class=keyword>class</span> <span class="title class_">InnerClass</span> {</span><br><span class=line>        <span class=comment>// 内部类中存储内容的规则与外部类一样。</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=封装><a class=headerlink href=#封装 title=封装></a>封装</h2><h3 id=简介-4><a class=headerlink href=#简介-4 title=简介></a>简介</h3><p><strong>封装指的是将共同的行为或属性进行抽象汇总并定义在一个类中</strong>。<p>对象代表什么，就要封装对应的数据，并提供数据对应的行为。比如人关门行为中的关门动作应该定义在门类中，而并非定义在人类中。<p>封装好的类，内部成员变量通常会被私有访问修饰符<code>private</code>修饰，表示外界不可直接访问，若需访问需要调用类中定义的相关setXXX和getXXX方法来实现，<h3 id=this><a class=headerlink href=#this title=this></a>this</h3><p><strong>this表示当前类的地址，this在方法中使用时表示方法调用者的地址值</strong>。<p>通过关键字this可以调用类的成员变量和成员方法。不通过this直接获取变量时满足就近原则，优先检查局部变量，再检查类成员变量。<h3 id=构造方法><a class=headerlink href=#构造方法 title=构造方法></a>构造方法</h3><p>构造方法也称为构造器、构造函数，有无参构造和有参构造之分。其作用就是在创建对象时给成员变量进行赋值。<p>构造方法有如下一些特点：<ul><li>方法名与类名完全一样。<li>没有返回值类型，void也不能写。<li>没有返回值。<li>构造方法可以重载。</ul><p>注意：<strong>如果没有显式在类中定义构造方法，那么虚拟机会自动为类添加一个默认无参构造方法，且方法体中只有一个调用父类无参构造的代码。</strong><h2 id=继承><a class=headerlink href=#继承 title=继承></a>继承</h2><h3 id=何为继承><a class=headerlink href=#何为继承 title=何为继承></a>何为继承</h3><p>当同类型（Animal）的多个类（Dog、Cat等）中存在相同的成员变量、成员方法时，我们可以将这些相同的变量和方法抽取出来封装到一个类中，其它类需要这些变量和方法时直接继承该类即可默认拥有这些变量和方法，而无需在自己的类中重复编写，提高了代码的复用性。<p>Java中通过关键字<code>extends</code>可以让一个类与另一个类建立继承关系。被继承的类称为基类/超类/父类，继承的类称为派生类/子类。<p>继承的代码示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Dog</span> <span class=keyword>extends</span> <span class="title class_">Animal</span> { <span class=comment>//... }</span></span><br></pre></table></figure><p><strong>注意事项：当类与类之间存在相同的内容，且满足子类是父类的一种，此时可以考虑使用继承来优化代码，提高代码复用</strong>。<h3 id=继承特点><a class=headerlink href=#继承特点 title=继承特点></a>继承特点</h3><p>继承有如下特点：<ul><li>Java只能单继承，不能多继承，但可以多层继承。<li>Java中所有的类都直接或间接继承于Object类。<li>子类只能访问父类中非私有的成员。</ul><h3 id=可以继承的内容><a class=headerlink href=#可以继承的内容 title=可以继承的内容></a>可以继承的内容</h3><ol><li>父类的非私有成员变量；<li>父类的虚方法；（虚方法指的是非private、static、final修改的方法。）</ol><h3 id=this与super使用><a class=headerlink href=#this与super使用 title=this与super使用></a>this与super使用</h3><p>this表示当前方法调用者的地址，super表示当前类的父类。<h3 id=变量与方法的访问特点><a class=headerlink href=#变量与方法的访问特点 title=变量与方法的访问特点></a>变量与方法的访问特点</h3><ul><li>成员变量的使用：就近原则，谁近用谁；<li>构造方法：<ol><li>子类不会继承父类的构造方法；<li><strong>子类构造方法中默认先调用父类构造方法，然后再执行自己的代码</strong>；（子类构造方法中第一行代码必须是<code>super();</code>，不写默认也存在，然后再编写子类构造方法的内容。这里要注意的是如果父类中只有有参构造器，那么就必须手动显式的在子类构造器中第一行调用父类的有参构造<code>super(p1, p2, ...);</code>）</ol><li>成员方法：this调用和直接调用满足就近原则，super调用时直接访问父类；</ul><h3 id=重写><a class=headerlink href=#重写 title=重写></a>重写</h3><p>当父类中的方法无法满足子类的需求时，我们就需要在子类中重写父类的方法。子类中重写的方法上面推荐使用注解<code>@Override</code>来标注，该注解可自动检查重写语法是否正确并给出提示。<p><strong>重写的本质是使用子类中的重写方法覆盖从父类中继承过来的虚方法表中的方法</strong>。也就是说只有被添加到虚方法表中的方法才能被重写。<blockquote><p>虚方法指的是非private、static、final修饰的方法。</blockquote><p>重写注意事项<ol><li>重写方法的名称、形参必须与父类中的<strong>一致</strong>；<li>重写方法的<strong>访问权限</strong>必须<strong>大于等于</strong>父类；<li>重写方法的<strong>返回值类型</strong>必须<strong>小于等于</strong>父类；<li>只有虚方法表中的方法才能被重写；</ol><h2 id=多态><a class=headerlink href=#多态 title=多态></a>多态</h2><h3 id=何为多态><a class=headerlink href=#何为多态 title=何为多态></a>何为多态</h3><p>多态指的是同类型的对象，表现出的不同形态。<p>多态的前提：有继承关系、父类引用指向子类对象、有方法重写。<h3 id=访问成员特点><a class=headerlink href=#访问成员特点 title=访问成员特点></a>访问成员特点</h3><ul><li>调用变量：编译看左边，运行也看左边；<li>调用方法：编译看左边，运行看右边；</ul><h3 id=多态优缺点><a class=headerlink href=#多态优缺点 title=多态优缺点></a>多态优缺点</h3><ul><li>优点：方法中使用父类类型或接口作为参数，可以接收所有子类对象。<li>缺点：不能调用子类的特有方法。</ul><p><strong>多态的缺点是不能调用子类特有的方法，但可以通过强制转换将父类转为子类类型来打破这种限制</strong>。在转换类型前推荐先通过<code>instanceof</code>关键字来判断是否可以转换，可以转换时再转换，否则会抛出转换异常。<p><strong>JDK14开始对instanceof的使用语法进行了优化</strong>。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=type>Animal</span> <span class=variable>a</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Animal</span>();</span><br><span class=line></span><br><span class=line><span class=comment>// 优化前</span></span><br><span class=line><span class=keyword>if</span>(a <span class=keyword>instanceof</span> Dog){</span><br><span class=line>    <span class=type>Dog</span> <span class=variable>d2</span> <span class=operator>=</span> (Dog)a;</span><br><span class=line>    d2.eat();</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// JDK14优化后的写法</span></span><br><span class=line><span class=keyword>if</span>(a <span class=keyword>instanceof</span> Dog d2){</span><br><span class=line>    d2.eat();</span><br><span class=line>}</span><br></pre></table></figure><h1 id=抽象类><a class=headerlink href=#抽象类 title=抽象类></a>抽象类</h1><h2 id=概述-5><a class=headerlink href=#概述-5 title=概述></a>概述</h2><p>子类方法要执行的内容可能与父类不同，所以在父类中就不能确定具体的方法体，不能确定方法体的方法就可以设计为抽象方法，抽象方法没有方法体。<p><strong>存在抽象方法的类必须声明为抽象类</strong>。<p>抽象类和抽象方法的定义格式如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment>// 抽象类</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> class 类名{</span><br><span class=line>    <span class=comment>// 抽象方法（没有方法体）</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> 返回值类型 方法名(参数列表);</span><br><span class=line>}</span><br></pre></table></figure><h2 id=注意事项-2><a class=headerlink href=#注意事项-2 title=注意事项></a>注意事项</h2><ul><li>抽象类不能被实例化；<li>抽象类中不一定有抽象方法，但有抽象方法的类一定是抽象类；<li>抽象类可以有成员变量、构造方法（被子类构造器间接调用做相关初始化）、非抽象方法；<li>抽象类的子类，要么重写其抽象方法，要么定义自己也为抽象类；</ul><h2 id=抽象类意义><a class=headerlink href=#抽象类意义 title=抽象类意义></a>抽象类意义</h2><p>强制子类必须按照方法固定格式来重写，统一代码，方便阅读与管理。<h1 id=接口><a class=headerlink href=#接口 title=接口></a>接口</h1><h2 id=定义-5><a class=headerlink href=#定义-5 title=定义></a>定义</h2><p>接口是一个规则，对行为的抽象。<strong>接口表示有没有某种行为，而抽象类表示是不是某种东西</strong>。<p>使用关键字<code>interface</code>代替关键字<code>class</code>来修饰的模块就称为接口，如：<code>public interface Eat{...}</code>。<blockquote><p>接口和类的关系可以是单实现，也可以是多实现。实现类可以在继承一个类的同时实现多个接口</blockquote><h2 id=成员特点><a class=headerlink href=#成员特点 title=成员特点></a>成员特点</h2><ul><li>成员变量：只能是常量，默认修饰符为<code>public static final</code>。<li>构造方法：不能编写构造方法。<li>成员方法：只能编写抽象方法，默认修饰符为<code>public abstract</code>。但是，jdk8中可以定义有方法体的默认方法、静态方法，jdk9中可以定义私有方法。</ul><h2 id=类与接口的关系><a class=headerlink href=#类与接口的关系 title=类与接口的关系></a>类与接口的关系</h2><ul><li>类和类：继承关系，只能单继承，不能多继承，但可以多层继承；<li>类和接口：可以单实现，也可以多实现，还可以继承一个类的同时实现多个接口；<li>接口和接口：继承关系，可以单继承，也可以多继承；</ul><h2 id=接口新变化><a class=headerlink href=#接口新变化 title=接口新变化></a>接口新变化</h2><p>从jdk8开始，接口规则有了新的变化。这个变化为：<strong>jdk8中可以定义有方法体的默认方法、静态方法，jdk9中可以定义私有方法</strong>。<h3 id=JDK8新变化><a class=headerlink href=#JDK8新变化 title=JDK8新变化></a>JDK8新变化</h3><p>jdk8中关于接口规则的新变化如下：<ul><li>允许在接口中定义被关键字<code>default</code>修饰的带方法体的方法，称为默认方法。默认方法的定义格式为：<code>public default 返回值类型/void 方法名(参数列表/无参)</code>;<li>允许在接口中定义被关键字<code>static</code>修饰的带方法体的方法，称为静态方法。静态方法的定义格式为：<code>public static 返回值类型/void 方法名(参数列表/无参)</code>;</ul><p>注意事项：<ul><li>默认方法<ul><li>默认方法不是抽象方法，不强制要求重写。但如果要重写，重写时要去掉<code>default</code>关键字；<li>默认方法中的public可以省略，但default不能省略；<li>一个类实现了多个接口，且多个接口中存在相同名字的默认方法，则该类就必须重写该方法；</ul><li>静态方法<ul><li>静态方法只能通过接口名调用，不能通过实现类名或对象名来调用；<li>静态方法中的public可以省略，但static不能省略；</ul></ul><h3 id=JDK9新变化><a class=headerlink href=#JDK9新变化 title=JDK9新变化></a>JDK9新变化</h3><p>jdk9中关于接口规则的新变化为：接口中可以定义带有方法体的私有非静态方法和私有静态方法。定义格式为：<code>private [static] 返回值类型/void 方法名(参数列表/无参){}</code>。<blockquote><p>接口中私有方法主要为接口中的默认方法服务。</blockquote><h1 id=内部类><a class=headerlink href=#内部类 title=内部类></a>内部类</h1><h2 id=概述-6><a class=headerlink href=#概述-6 title=概述></a>概述</h2><p>类的五大成员：属性、代码块、构造方法、方法、内部类。<p>内部类指的是在类里面定义的类。<h2 id=内部类分类><a class=headerlink href=#内部类分类 title=内部类分类></a>内部类分类</h2><p>内部类分为如下几种类型：<ul><li>成员内部类：定义在一个类中成员位置的类；<li>静态内部类：与成员内部类相似，被static修饰而已；<li>局部内部类：定义在方法中的类；<li>匿名内部类：“没有名字”的类；</ul><h2 id=成员内部类><a class=headerlink href=#成员内部类 title=成员内部类></a>成员内部类</h2><h3 id=简介-5><a class=headerlink href=#简介-5 title=简介></a>简介</h3><p>定义在类成员位置的类就称为成员内部类。<p>在成员内部类中，JDK16之前不能定义静态变量，JDK16开始可以定义。<h3 id=使用内部类><a class=headerlink href=#使用内部类 title=使用内部类></a>使用内部类</h3><p>获取内部类的对象有两种方式：<ul><li>在外部类中编写一个提供内部类对象的方法；<li>直接创建；格式为：<code>外部类.内部类 对象名 = new 外部类().new 内部类();</code></ul><h3 id=代码示例><a class=headerlink href=#代码示例 title=代码示例></a>代码示例</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">A</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> Integer age;</span><br><span class=line>    <span class=comment>// class B就是一个成员内部类</span></span><br><span class=line>    <span class=keyword>class</span> <span class="title class_">B</span> { }</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>class</span> <span class="title class_">C</span> { }</span><br><span class=line>    <span class=keyword>public</span> C <span class="title function_">getC</span><span class=params>()</span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">C</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 方式一：创建成员内部类对象</span></span><br><span class=line>A.<span class=type>B</span> <span class=variable>b</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">A</span>().<span class=keyword>new</span> <span class="title class_">B</span>();</span><br><span class=line><span class=comment>// 方式二：获取成员内部类对象</span></span><br><span class=line><span class=type>C</span> <span class=variable>c</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">A</span>().getC();</span><br></pre></table></figure><h2 id=静态内部类><a class=headerlink href=#静态内部类 title=静态内部类></a>静态内部类</h2><h3 id=简介-6><a class=headerlink href=#简介-6 title=简介></a>简介</h3><p>写在外部类成员位置的静态类称为静态内部类。静态内部类只能访问外部类中的静态变量和静态方法，若需要访问非静态的成员，需要创建对象后通过对象来访问。<h3 id=使用内部类-1><a class=headerlink href=#使用内部类-1 title=使用内部类></a>使用内部类</h3><p>获取静态内部类对象的方式为：<code>外部类.内部类 对象名 = new 外部类.内部类();</code><p>调用静态内部类中静态方法的方式为：<code>外部类.内部类.方法名();</code><p>调用静态内部类中非静态方法的方式为：先创建静态内部类对象，再通过对象来访问。<h3 id=代码示例-1><a class=headerlink href=#代码示例-1 title=代码示例></a>代码示例</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">A</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> Integer age;</span><br><span class=line>    <span class=comment>// class B就是一个静态内部类</span></span><br><span class=line>    <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">B</span> {</span><br><span class=line>        <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">m1</span><span class=params>()</span>{}</span><br><span class=line>        <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">m2</span><span class=params>()</span>{}</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 创建静态内部类的对象</span></span><br><span class=line>A.<span class=type>B</span> <span class=variable>b</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">A</span>.B();</span><br><span class=line><span class=comment>// 调用静态内部类的非静态方法</span></span><br><span class=line>b.m2();</span><br><span class=line><span class=comment>// 调用静态内部类的静态方法</span></span><br><span class=line>A.B.m1();</span><br></pre></table></figure><h2 id=局部内部类><a class=headerlink href=#局部内部类 title=局部内部类></a>局部内部类</h2><h3 id=简介-7><a class=headerlink href=#简介-7 title=简介></a>简介</h3><p>定义在方法里面的类就称为局部内部类，类似于方法里面的局部变量，生命周期也与方法的生命周期相同。<h3 id=代码示例-2><a class=headerlink href=#代码示例-2 title=代码示例></a>代码示例</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">A</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> Integer age;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">show</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// class B就是一个局部内部类</span></span><br><span class=line>        <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">B</span> {</span><br><span class=line>            <span class=comment>//...</span></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=匿名内部类><a class=headerlink href=#匿名内部类 title=匿名内部类></a>匿名内部类</h2><h3 id=简介-8><a class=headerlink href=#简介-8 title=简介></a>简介</h3><p>匿名内部类指的是隐藏了名字的内部类，可以写在成员位置，称为成员匿名内部类，也可以写在局部位置，称为局部匿名内部类。<blockquote><p>匿名内部类只是隐藏了名字，而并非没有名字。他的名字为<code>外部类名+$+序号</code>，比如名为Person$1。</blockquote><h3 id=代码示例-3><a class=headerlink href=#代码示例-3 title=代码示例></a>代码示例</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">A</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>final</span> <span class=type>String</span> <span class=variable>NAME</span> <span class=operator>=</span> <span class=string>"zhangsan"</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>final</span> <span class=type>Integer</span> <span class=variable>AGE</span> <span class=operator>=</span> <span class=number>18</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">show</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=comment>// 这里new出来的就是一个隐藏名字的匿名内部类。</span></span><br><span class=line>    <span class=keyword>new</span> <span class="title class_">A</span>() {</span><br><span class=line>        <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">show</span><span class=params>()</span>{</span><br><span class=line>            <span class=comment>//...</span></span><br><span class=line>        }</span><br><span class=line>    };</span><br><span class=line>}</span><br></pre></table></figure><h1 id=克隆><a class=headerlink href=#克隆 title=克隆></a>克隆</h1><h2 id=概述-7><a class=headerlink href=#概述-7 title=概述></a>概述</h2><p><strong>基于一个类得到另一个与之相同的类的行为称之为克隆</strong>。<p>克隆分为浅克隆和深克隆两种。<ul><li>浅克隆：无论对象中的属性是基本类型还是引用类型，会将之全部拷贝；<li>深拷贝：基本类型会直接拷贝，字符串会复用串池中的内容，其它引用类型会创建一个新的来使用；</ul><blockquote><p>Object中的克隆属于浅克隆，要使用深克隆，需要重写clone方法。</blockquote><h2 id=使用克隆><a class=headerlink href=#使用克隆 title=使用克隆></a>使用克隆</h2><p>要使用克隆功能，需要满足一些条件：<ol><li>要被克隆的类需要实现Clonable接口；<li>要被克隆的类中需要重写Object的clone()方法；<li>直接调用重写后的clone方法就可以实现克隆；</ol><h1 id=正则表达式><a class=headerlink href=#正则表达式 title=正则表达式></a>正则表达式</h1><h2 id=概述-8><a class=headerlink href=#概述-8 title=概述></a>概述</h2><p><strong>正则表达式主要由字符类、预定义字符、数量词等内容组成</strong>。<p>正则表达式可以校验字符串是否满足一定的规则，并用来校验数据格式的合法性。通过调用Strng类的matches(正则表达式)方法就可以使用正则来匹配判断内容是否有效。<p>正则表达式的作用：校验字符串是否满足规则；在一段文本中查找满足要求的内容。<h2 id=规则><a class=headerlink href=#规则 title=规则></a>规则</h2><p>正则表达式规则如下<p>预定义字符（匹配1个）：<ul><li>点.：任何字符，除了\n回车符号。<li>\d：一个数字。<li>\D：非数字。<li>\s：一个空白字符。<li>\S：非空白字符。<li>\w：[a-zA-Z_0-9]，表示英文、数字、下划线。<li>\W：<code>[^\w]</code>一个非单词字符。<li>[]：里面的内容出现一次。<li>()：分组。<li>&&：交集<li>|：写在方括号外面，表示并集。<li>\：斜杠表示转义字符。<li><code>(?i)</code>：忽略大小写。只会忽略该标识后面的字母大小写。<li><code>?=</code>：?表示前面的字符，=表示前面的字符后面可以拼接那些字符。比如Java(?=7|8|11)就会匹配Java7、Java8、Java11，但要注意的是，最终只保留Java，不会保留后面的数字。换句话说就是，我只想获取Java7、Java8、Java11中的字符Java，而不希望获取Java17、Java20等中的字符Java。<li><code>?:</code>与?=的效果类似，只是最终获取结果会包含所有字符。比如Java(?:7|8|11)就会匹配Java7、Java8、Java11，最终要保留的也是全部字符，不需要去掉后面的数字。<li><code>?!</code>：取反</ul><p>数量词：<ul><li>X？：X出现零次或一次。<li>X*：X出现零次或多次。<li>X+：X出现一次或多次。<li>X{n}：X出现n次。<li>X{n, }：X出现至少n次。<li>X{n, m}：X出现至少n次，但不超过m次。</ul><p>字符类示例（匹配1个）：<ul><li>[abc]：只能是a、b、c。<li>[^abc]：除了abc之外的任何字符。<li>[a-zA-Z]：a-z和A-Z中的任何字符。<li>[a-d[m-p]]：a-d或m-p之间的任何字符。<li>[a-z&&[def]]：a-z和def的交集，结果为d、e、f。<li><code>[a-z&&[^BC]]</code>：a-z和非bc的交集，等同于[ad-z]。<li><code>[a-z&&[^m-p]]</code>：a-z和非m-p的交集。</ul><h2 id=分组><a class=headerlink href=#分组 title=分组></a>分组</h2><h3 id=简介-9><a class=headerlink href=#简介-9 title=简介></a>简介</h3><p>在正则表达式中使用小括号()将内容包括起来可以对要匹配的字符串内容进行分组。<h3 id=分类><a class=headerlink href=#分类 title=分类></a>分类</h3><p>正则表达式中分组有两种：<ul><li><strong>捕获分组（默认）</strong>：可以通过<code>\\+组号 和 $+组号</code>获取每组中的内容反复使用；<li><strong>非捕获分组</strong>：分组后不需要再用本组数据，仅仅把数据括起来，不占组号；(?:)、(?=)、(?!)都是非捕获分组。</ul><h3 id=组号><a class=headerlink href=#组号 title=组号></a>组号</h3><p>捕获分组后每组会有一个组号，也就是序号。该组号存在以下规则：<ul><li>规则1：组号从1开始，连续不间断。<li>规则2：以左括号为基准，最左边的是第一组，其次为二组，以此类推。</ul><p>当在正则表达式中使用小括号进行捕获分组后，可以在正则表达式中继续使用<code>\\+组号</code>来复用该组，也可以在正则表达式外通过<code>$+组号</code>来复用该组匹配到的内容。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>// 我要学学学编编编编程程 -> 我要学编程</span></span><br><span class=line><span class=type>String</span> <span class=variable>str</span> <span class=operator>=</span> <span class=string>"我要学学学编编编编程程"</span>;</span><br><span class=line><span class=type>String</span> <span class=variable>regular</span> <span class=operator>=</span> <span class=string>"*(.)\\1+"</span>; <span class=comment>// 正则表达式</span></span><br><span class=line><span class=type>String</span> <span class=variable>result</span> <span class=operator>=</span> str.replaceAll(regular, <span class=string>"$1"</span>); <span class=comment>// 我要学编程</span></span><br></pre></table></figure><p><strong>注意事项</strong>：通过组号拿到分组内容来使用只适用于捕获分组场景，若是非捕获分组，那么无法使用直接报错。<h1 id=泛型><a class=headerlink href=#泛型 title=泛型></a>泛型</h1><h2 id=概述-9><a class=headerlink href=#概述-9 title=概述></a>概述</h2><p>为了统一数据类型，方便管理，提出了泛型。泛型的定义格式为<code><引用数据类型></code>。<p><strong>泛型中不能写基本数据类型。如果不写泛型，默认为Object。</strong>指定泛型后，在传递数据时只能传递该类型或子类型。<p>泛型可以编写在类、接口、方法上，编写后分别称为泛型类、泛型接口、泛型方法。<ul><li>泛型类：泛型要编写在类名后面；<li>泛型接口：泛型要编写在接口名后面，使用时既可以在实现类中给出类型，也可以实现类延续泛型，然后在创建实现类对象时指定类型。<li>泛型方法：泛型要编写在方法修饰符后面；</ul><h2 id=继承与通配符><a class=headerlink href=#继承与通配符 title=继承与通配符></a>继承与通配符</h2><h3 id=继承-1><a class=headerlink href=#继承-1 title=继承></a>继承</h3><p>泛型不具备继承性，但数据具备继承性。<h3 id=通配符><a class=headerlink href=#通配符 title=通配符></a>通配符</h3><p>通配符为<code>?</code>，与通配符搭配使用的方式有两种：<ul><li>? extends E：表示可以传递E或E的子类型；<li>? super E：表示可以传递E或E的父类型；</ul><h1 id=集合><a class=headerlink href=#集合 title=集合></a>集合</h1><h2 id=概述-10><a class=headerlink href=#概述-10 title=概述></a>概述</h2><p>集合主要分两大部分组成：接口Collection和接口Map。<p>接口Collection的主要实现类有：List、Set、Queue；接口Map的主要实现有：HashMap、Hashtable；<h2 id=数据结构><a class=headerlink href=#数据结构 title=数据结构></a>数据结构</h2><h3 id=树><a class=headerlink href=#树 title=树></a>树</h3><h4 id=概述-11><a class=headerlink href=#概述-11 title=概述></a>概述</h4><p>树有多种分类：普通二叉树、查找二叉树、平衡二叉树、多叉树、红黑树等。<blockquote><p>普通二叉树中的数据没有规则，使用有限。查找二叉树中的数据有规则，但容易变成链表，使用有限。平衡二叉树可避免前两者的问题，但过于追求平衡，编辑性能低下，不合适。</blockquote><p>关于数据结构树的术语如下：<ul><li>度：每一个节点的子节点数量；<li>树高：树的总层数；<li>根节点：最顶层的一个节点；<li>左节点：节点左边的一个节点；<li>右节点：节点右边的一个节点；</ul><h4 id=二叉树遍历><a class=headerlink href=#二叉树遍历 title=二叉树遍历></a>二叉树遍历</h4><p>二叉树的遍历方式有如下几种：<ul><li>前序遍历：从根节点开始，按照<strong>当前节点</strong>，<strong>左子节点</strong>，<strong>右子节点</strong>的顺序遍历；<li>中序遍历：从左子节点开始，按照<strong>左子节点</strong>，<strong>当前节点</strong>，<strong>右子节点</strong>的顺序遍历；<li>后序遍历：从左子节点开始，按照<strong>左子节点</strong>，<strong>右子节点</strong>，<strong>当前节点</strong>的顺序遍历；<li>层序遍历：从根节点开始，从上到下，从左到右一层一层的遍历；</ul><h4 id=平衡二叉树旋转><a class=headerlink href=#平衡二叉树旋转 title=平衡二叉树旋转></a>平衡二叉树旋转</h4><p>平衡二叉树需要旋转的四种情况：<ul><li>左左：一次右旋；<li>左右：先局部左旋，再整体右旋；<li>右右：一次左旋；<li>右左：先局部右旋，再整体左旋；</ul><h4 id=红黑树><a class=headerlink href=#红黑树 title=红黑树></a>红黑树</h4><p>红黑树规则如下：<ul><li>红黑树根节点是黑色；<li>红黑树叶子节点是黑色，但为Nil（空，没有值）;<li>红色节点的两个子节点为黑色，不能存在连续的两个红色节点；<li>根节点到任何一个叶子节点的路径上必须有相同数量的黑色节点；</ul><p>注意：<strong>红黑树在添加节点时，添加的节点默认为红色，因为添加红色节点效率较高。</strong><h2 id=Set><a class=headerlink href=#Set title=Set></a>Set</h2><h3 id=HashSet><a class=headerlink href=#HashSet title=HashSet></a>HashSet</h3><p><strong>集合HashSet中的元素特点为：无序、不重复、无索引</strong>。<p>HashSet集合中元素是否重复是通过比较元素具体的值来判断的，值相同就表示元素相同，元素相同就不能存储。<strong>当向集合Set中添加自定义对象时，必须重写对象的equals和hashcode方法，否则就不满足Set集合中重复元素的判断规则</strong>。<h3 id=LinkedHashSet><a class=headerlink href=#LinkedHashSet title=LinkedHashSet></a>LinkedHashSet</h3><p>集合LinkedHashSet底层基于哈希表，并使用双向链表来记录添加顺序，故该集合中的元素特点为：<strong>有序、不重复、无索引</strong>。<h3 id=TreeSet><a class=headerlink href=#TreeSet title=TreeSet></a>TreeSet</h3><p><strong>集合TreeSet中的元素特点为：可排序、不重复、无索引</strong>。<p>TreeSet底层基于红黑树数据结构实现排序，增删改查性能都比较好。<p>TreeSet排序规则：<ul><li>数值类型：默认按照从小到大的顺序进行排序；<li>字符、字符串类型：按照字符在ASCII码表中的数字升序进行排序；<li>引用类型：实现Comparable接口或Comparator接口，重写比较方法来实现排序；TreeSet默认是根据元素实现的Comporable接口来实现排序，这种方式称之为默认排序或自然排序。除了自然排序还可以通过比较器Comparator自定义比较规则来实现排序，这种排序称之为比较器排序。</ul><blockquote><p>TreeSet默认使用自然排序来实现排序，如果自然排序无法满足需求再选择使用比较器来实现排序。</blockquote><h3 id=使用场景><a class=headerlink href=#使用场景 title=使用场景></a>使用场景</h3><ul><li>如果需要集合中的<strong>元素有序</strong>：使用ArrayList，基于数组，使用偏多；<li>如果需要集合中的<strong>元素去重</strong>：使用HashSet，基于哈希表和红黑树，使用偏多；<li>如果需要集合中的<strong>元素去重且保证存取顺序</strong>：使用LinkedHashSet，基于哈希表和双链表，性能低于HashSet；<li>如果需要集合中的<strong>元素去重且有序</strong>：使用TreeSet，基于红黑树，增删改查效率较高；</ul><h2 id=Map><a class=headerlink href=#Map title=Map></a>Map</h2><h3 id=HashMap><a class=headerlink href=#HashMap title=HashMap></a>HashMap</h3><p>HashMap键值对数据编辑的特点：<ul><li>put（添加）：集合中不存在当前要添加的键值对时，直接存储并返回null；如果存在那就替换已存在的键值对，并返回被覆盖的键值对中的值；<li>remove（删除）：根据键删除键值对并返回被删除键值对的值；</ul><blockquote><p><strong>如果需要向HashMap中存储自定义对象，那么需要重写equals和hashCode方法。</strong></blockquote><h3 id=LinkedHashMap><a class=headerlink href=#LinkedHashMap title=LinkedHashMap></a>LinkedHashMap</h3><p>LinkedHashMap底层数据结构是哈希表，通过双向链表将待插入的元素按照插入顺序链接起来。故，LinkedHashMap中元素的特点为：<strong>有序、不重复、无索引</strong>。<h3 id=TreeMap><a class=headerlink href=#TreeMap title=TreeMap></a>TreeMap</h3><p><strong>TreeMap底层数据结构是红黑树，增删改查性能较好</strong>。<p>TreeMap中元素特点是可排序、不重复、无索引。<p>TreeMap可以根据元素实现的Comparable接口或指定比较器Comparator来实现自定义排序。<blockquote><p>TreeMap中添加自定义引用类型时，无需重写equals和hashcode方法；</blockquote><h2 id=Collections><a class=headerlink href=#Collections title=Collections></a>Collections</h2><h3 id=简介-10><a class=headerlink href=#简介-10 title=简介></a>简介</h3><p><strong>Collections是java.util包下的一个集合工具类，提供了一些常用的操作集合的方法</strong>。<h3 id=常用API><a class=headerlink href=#常用API title=常用API></a>常用API</h3><ul><li>addAll：批量添加元素；<li>shuffle：打乱List集合中元素的顺序；<li>sort：默认排序或根据指定规则排序；<li>binarySearch：以二分查找法查找集合中的元素；<li>copy：拷贝一个集合中的元素到另一个集合中；<li>fill：使用指定的元素填充集合；<li>max/min：根据默认自然排序获得的最大值/最小值；<li>swap：交换集合中指定的两个位置上的元素；</ul><h2 id=不可变集合><a class=headerlink href=#不可变集合 title=不可变集合></a>不可变集合</h2><h3 id=简介-11><a class=headerlink href=#简介-11 title=简介></a>简介</h3><p>不可变集合指的是集合创建完成后，集合不可以执行添加、修改、删除等操作。<h3 id=创建不可变集合><a class=headerlink href=#创建不可变集合 title=创建不可变集合></a>创建不可变集合</h3><p>通过List、Set、Map的的of方法可以创建不可变集合。<ul><li>List：直接调用of方法即可；<li>Set：调用of方法时，集合中不能存在重复元素；<li>Map：调用of方法时，集合中的元素不能重复，且键值对数量不能超过10个。<strong>如果超过10个，需要使用ofEntries方法来创建</strong>。</ul><h2 id=总结><a class=headerlink href=#总结 title=总结></a>总结</h2><p><strong>HashMap中的键不需要实现Compareable接口或传递比较器对象来比较。</strong><p><strong>HashMap与TreeMap对比，谁的效率更高？</strong>当HashMap中的节点形成一个数量为8的链表时，TreeMap效率更高，但形成数量为8的链表的这种情况很少，故，通常情况下还是HashMap的效率更高。<p><strong>HashMap、LinkedHashMap、TreeMap三者在实际应用中该如何选择？</strong>默认使用HashMap，如果需要保证存取有序使用LinkedHashMap，如果需要元素排序使用TreeMap。<h1 id=Stream><a class=headerlink href=#Stream title=Stream></a>Stream</h1><h2 id=概述-12><a class=headerlink href=#概述-12 title=概述></a>概述</h2><p>Stream流类似于工厂中的流水线。通过Stream流，结合Lambda表达式可简化对集合、数组的操作。<h2 id=获取Stream><a class=headerlink href=#获取Stream title=获取Stream></a>获取Stream</h2><p>获取Stream流对象的方式有如下几种：<ul><li>单列集合：直接调用集合的stream方法；<li>双列集合：不能直接获取，先获取单例数据再转为Stream对象，然后再操作；<li>数组：使用Arrays工具类中的静态方法stream；<li>零散数据：使用Stream流的静态方法<code>of</code>将数据进行整合；</ul><h2 id=常用方法><a class=headerlink href=#常用方法 title=常用方法></a>常用方法</h2><ul><li>中间方法：filter、limit、skip、distinct、concat、map等；<li>结束方法：forEach、count、collect等；</ul><h1 id=方法引用><a class=headerlink href=#方法引用 title=方法引用></a>方法引用</h1><h2 id=概述-13><a class=headerlink href=#概述-13 title=概述></a>概述</h2><p>方法引用指的是将已经存在的方法拿过来用，当做函数式接口中抽象方法的方法体。<p><strong>方法引用通过符号<code>::</code>来连接调用方法，该符号就是方法引用符</strong>。<h2 id=使用条件><a class=headerlink href=#使用条件 title=使用条件></a>使用条件</h2><p>想要使用方法引用，需要满足一些条件：<ul><li>存在函数式接口；<li>被引用的方法已经存在；<li>被引用方法的形参和返回值需要与抽象方法的形参和返回值一样；<li>被引用方法的功能可以满足当前的需求；</ul><h2 id=使用分类><a class=headerlink href=#使用分类 title=使用分类></a>使用分类</h2><p>通过方法引用符调用不同类成员的编写方式不同，具体分类如下：<ul><li>引用静态方法：类::静态方法，例如 System.out::print();<li>引用成员方法：<ul><li>其它类的方法：对象::方法，例如 new Student()::getAge；<li>本类：this::方法名;<li>父类：super::方法名；</ul><li>引用构造方法：类名::new，例如 Student::new；<li>引用数组的构造方法：数据类型[]::new，例如 int[]::new；</ul><h1 id=异常><a class=headerlink href=#异常 title=异常></a>异常</h1><h2 id=概述-14><a class=headerlink href=#概述-14 title=概述></a>概述</h2><p>异常的根类为<code>java.lang.Throwable</code>，该根类由Error和Exception两者组成。<strong>Error表示严重的错误，不可处理。Exception表示可被处理的错误</strong>。<p>Exception分为两大类：RuntimeException和其它异常。前者称为运行时异常，也就是程序运行期间可能出现的异常。后者其它异常称为编译时异常，程序编译阶段就能检测到的异常。<p>异常的作用有两个：用来查询bug的关键参考信息 和 作为一种返回值，通知调用者程序执行情况。<h2 id=处理异常><a class=headerlink href=#处理异常 title=处理异常></a>处理异常</h2><h3 id=处理分类><a class=headerlink href=#处理分类 title=处理分类></a>处理分类</h3><p>处理异常的方式如下：<ul><li>JVM默认处理：抛出异常，停止程序的执行；<li>自己处理：主动捕获处理，程序可以继续执行；<li>抛出异常：主动抛出异常，停止程序的执行；</ul><h3 id=抛出异常><a class=headerlink href=#抛出异常 title=抛出异常></a>抛出异常</h3><p>抛出异常分两种：<ul><li>throws：写在定义的方法小括号后面，后面跟写异常类名即可。例如<code>method() throws Exception1, Exception2, ...{//方法体}</code><li>thorw：写在方法中，用于主动抛出指定异常。例如 <code>method() {throw new CustomeException();}</code></ul><h1 id=File><a class=headerlink href=#File title=File></a>File</h1><h2 id=获取和遍历><a class=headerlink href=#获取和遍历 title=获取和遍历></a>获取和遍历</h2><p>注意事项：<ul><li>当File表示的路径不存在时，返回null；<li>当File表示的路径是文件时，返回null；<li>当File表示的是一个空文件夹时，返回长度为0的数组；<li>当FIle表示的是一个有内容的文件夹时，返回存放内容对应路径的数组；<li>当File表示的是一个有隐藏文件的文件夹时，与上一个相同；<li>当FIle表示的是一个有权限的文件夹时，返回null；</ul><h1 id=IO流><a class=headerlink href=#IO流 title=IO流></a>IO流</h1><h2 id=概述-15><a class=headerlink href=#概述-15 title=概述></a>概述</h2><p><strong>IO流就是存储或读取数据的解决方案。I全称为Input，表示输入。O全称为Output，表示输出</strong>。<p>IO流按照流向和可操作文件类型来说，分为两种：<ul><li>按照流向可分：输入流、输出流。<li>按照可操作文件类型可分：字节流、字符流。</ul><p>输入流指的是数据从文件到程序的流向，输出流指的是数据从程序到文件的流向。<p><strong>字节流指的是可以读取任何类型文件的IO流，字符流指的是只能读取纯文本文件的IO流</strong>。<blockquote><p>纯文本文件指的是使用电脑记事本工具打开就可以阅读其中内容的文件。</blockquote><h2 id=自动关流><a class=headerlink href=#自动关流 title=自动关流></a>自动关流</h2><p><strong>JDK7提供了AutoCloseable接口，可实现自动关流</strong>。具体使用方式为try后面使用小括号将使用的流对象包括起来，多个流用分割号<code>;</code>隔开即可。<p><strong>JDK9时再次对之进行了优化，可在外面定义流对象，然后在try后面小括号中只写流对象名即可</strong>。<h2 id=字符集><a class=headerlink href=#字符集 title=字符集></a>字符集</h2><h3 id=计算机存储规则><a class=headerlink href=#计算机存储规则 title=计算机存储规则></a>计算机存储规则</h3><p>计算机存储字符数据的规则为：通过查询字符集得到要存储字符对应的二进制数据，然后再将该二进制数据编码为磁盘存储需要的格式进行存储。当读取磁盘中的数据时，再通过解码和检查字符集得到具体要展示的字符数据。<h3 id=字符集演变><a class=headerlink href=#字符集演变 title=字符集演变></a>字符集演变</h3><h4 id=GB2312字符集><a class=headerlink href=#GB2312字符集 title=GB2312字符集></a>GB2312字符集</h4><p><strong>1980年发布，1981年5月1日实施简体中文汉字编码国家标准</strong>。<h4 id=BIG5字符集><a class=headerlink href=#BIG5字符集 title=BIG5字符集></a>BIG5字符集</h4><p>台湾地区繁体中文标准字符集，共收录13053个中文汉字。1984年实施。<h4 id=GBK字符集><a class=headerlink href=#GBK字符集 title=GBK字符集></a>GBK字符集</h4><p><strong>K表示扩展，GBK表示在GB2312的基础上进行了扩展</strong>，GBK包含GB13000-1中的全部中日韩文字，及BIG5中的所有文字，共收录21003个文字。<strong>GBK字符集兼容ASCII字符集</strong>。<p>windows系统中默认使用的就是GBK，但实际显示的名字为ANSI，因为不同国家版本的windows系统使用的字符集名字不同，但其本质相同，故将它们统一命名为ANSI，<strong>ANSI就代表GBK字符集</strong>。<p>GBK字符集的字符占用规则：<ul><li>英文：<strong>一个英文字符占用1个字节</strong>，一个字节可表示256个不同的英文字符。英文的1个字节的二进制是0开头，转为十进制是一个正数。<li>汉字：<strong>一个汉字字符占用2个字节</strong>，两个字节可表示2^16次方个不同的汉字。2个字节分为高位字节和低位字节，高位字节的二进制是1开头，转为十进制后是一个负数。</ul><p>GBK编码规则如下：<ul><li>英文：查询GBK字符集得到英文对应的7个二进制位，然后<strong>前面补0编码为8位</strong>，最后存储。<li>汉字：查询GBK字符集得到汉字对应的16位二进制位，<strong>无需进行GBK编码</strong>，直接存储。</ul><h4 id=Unicode字符集><a class=headerlink href=#Unicode字符集 title=Unicode字符集></a>Unicode字符集</h4><p><strong>Unicode字符集是国际标准字符集</strong>，它将世界各种语言的每个字符都定义一个唯一的编码，以满足跨语言、跨平台的文本信息转换。<p>基于Unicode字符集进行编码时有多种编码规则，这些规则如下：<ul><li>UTF-16：单个字符使用2个字节存储。<li>UTF-32：所有字符的单个字符都使用4个字节存储字符<li>UTF-8：<strong>单个字符使用1~4个字节存储</strong>。<ul><li>ASCII表英文字符使用1个字节存储，二进制第一位为0，十进制为正数。<li>简体中文使用3个字节存储，二进制第一位为1，第一个字节十进制为负数。<li>其它语言使用4个字节存储。</ul></ul><p>UTF-8编码方式如下，通过字符集得到字符对应的二进制位，将字符对应的二进制位填充在下面的<code>x</code>位置上后可得到该字符实际存储时的二进制位数据格式。<figure class="highlight text"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line># 二进制，从上到下分别为1个字节、2个字节、3个字节、4个字节</span><br><span class=line>0xxxxxxx</span><br><span class=line>110xxxxx 10xxxxxx</span><br><span class=line>1110xxxx 10xxxxxx 10xxxxxx</span><br><span class=line>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></table></figure><h3 id=字符存读规则><a class=headerlink href=#字符存读规则 title=字符存读规则></a>字符存读规则</h3><p>不同种类的字符在存储和读取时，因为使用的字符集和编码解码方式不同而存在不同的规则。<h4 id=英文><a class=headerlink href=#英文 title=英文></a>英文</h4><p>当存储一个英文字母时很简单，底层逻辑为：<strong>先将英文字母根据字符集得到对应的十进制数字，然后将数字转为二进制，再对该二进制进行编码得到实际存储需要的二进制格式，然后进行存储</strong>。<p>从磁盘读取一个英文字符时的逻辑为：<strong>先通过解码得到对应的十进制数字，再查询字符集得到对应的实际展示格式</strong>。<h4 id=汉字><a class=headerlink href=#汉字 title=汉字></a>汉字</h4><p>存储一个汉字时的逻辑为：<strong>先将汉字根据字符集得到对应的十进制数字，然后将数字转为二进制，再对该二进制进行编码（比如UTF-8编码）得到实际存储需要的二进制格式，然后存储</strong>。<p>读取一个汉字时的逻辑为：<strong>先通过解码得到字符集中对应的十进制数字，再查询字符集得到对应的实际展示格式</strong>。<h4 id=注意事项-3><a class=headerlink href=#注意事项-3 title=注意事项></a>注意事项</h4><p>在存储读取字符数据时需要遵循一定的规则，这些规则如下：<ul><li>字符在编码和解码时要使用相同的字符集和编码方式，否则会出现乱码问题。<li>不要使用字节流读取文本文件，因为可能出现乱码问题。</ul><h2 id=字节流><a class=headerlink href=#字节流 title=字节流></a>字节流</h2><h3 id=概述-16><a class=headerlink href=#概述-16 title=概述></a>概述</h3><p><strong>字节流是可以存储读取任何类型文件的IO流。</strong>字节流按照字节来读取内容，如果要正确读取文本文件中的字符，那么读取时就要考虑到每个字符占用的字节大小，否则会出现乱码现象。<h2 id=字符流><a class=headerlink href=#字符流 title=字符流></a>字符流</h2><h3 id=概述-17><a class=headerlink href=#概述-17 title=概述></a>概述</h3><p><strong>字符流是只能存储读取文本文件中字符的IO流</strong>。字符流可以自动判断字符类型（中文、英文、或其它字符类型）来进行相关操作，并达到应有的效果。<h3 id=底层原理-3><a class=headerlink href=#底层原理-3 title=底层原理></a>底层原理</h3><h4 id=字符输入流><a class=headerlink href=#字符输入流 title=字符输入流></a>字符输入流</h4><p><strong>创建字符输入流对象后，底层会关联一个文件，并创建一个大小为8192的字节数组，也就是缓冲区</strong>。<p>读取数据时先判断缓冲区中是否有数据：<ul><li>缓冲区中没有数据：从文件中获取数据装入缓冲区中，且每次尽可能装满缓冲区。<li>缓冲区有数据：先从缓冲区中读取数据，读取完了再从文件读取数据装入缓冲区。空参read方法对于英文会一次读取一个字节，对于中文会一次读取多个字节，并将字节解码为字符集中对应的十进制数字，若需要得到字符还需要进行强转。有参read方法把读取数据、解码、强转进行了合并，并将最终要展示的字符放进了数组中。</ul><blockquote><p>当要读取的文件内容大小超过8192字节大小，第二次填充缓冲区前不会清空缓冲区，而会将文件中超过8192字节大小的后续数据按照缓冲区从小到大的顺序去覆盖，没有覆盖到的内容仍然是第一次填充缓冲区时留下的内容，这一点要知道。</blockquote><h4 id=字符输出流><a class=headerlink href=#字符输出流 title=字符输出流></a>字符输出流</h4><p><strong>创建字符输出流对象后，底层也会关联一个文件，并创建一个大小为8192的字节数组，也就是缓冲区</strong>。<p>默认情况下，当缓冲区中被装满时会自动存入磁盘文件中。当缓冲区没有满且想写出到文件中时，需要调用flush方法来实现。<p>通过调用close方法也会将缓冲区内容写出到文件中，但要注意的是，close方法执行完后会关闭通道，后续无法继续将内容写入文件。<h2 id=缓冲流><a class=headerlink href=#缓冲流 title=缓冲流></a>缓冲流</h2><h3 id=概述-18><a class=headerlink href=#概述-18 title=概述></a>概述</h3><p>缓冲流分为两种：字节缓冲流 和 字符缓冲流。<h3 id=字节缓冲流><a class=headerlink href=#字节缓冲流 title=字节缓冲流></a>字节缓冲流</h3><p>字节缓冲流指的是BufferedInputStream和BufferOutputStream，主要针对字节流的读写进行优化，提升其性能。<p><strong>字节缓冲流底层会有一个大小为8192的字节（byte）数组作为缓冲区来提升读写性能，大小为8192的字节数组占有8KB的空间</strong>。<h3 id=字符缓冲流><a class=headerlink href=#字符缓冲流 title=字符缓冲流></a>字符缓冲流</h3><p>字符缓冲流指的是BufferedReader 和 BufferWriter，主要针对字符流的读写进行优化，提升其性能。<p><strong>字符缓冲流底层会有一个大小为8192的字符（char）数组作为缓冲区来提升读写性能，大小为8192的字符数组占有16KB的空间</strong>。<p>字符缓冲流对象中有两个特有方法：<ul><li>字符缓冲输入流中的readLine()方法：可读取一行字符，遇到换行结束。<li>字符缓冲输出流中的newLine()方法：可跨平台创建并实现一个换行。</ul><h2 id=转换流><a class=headerlink href=#转换流 title=转换流></a>转换流</h2><h3 id=概述-19><a class=headerlink href=#概述-19 title=概述></a>概述</h3><p><strong>转换流是字节流与字符流之间的桥梁，通过转换流可以对字节流与字符流进行相互转换</strong>。<p>转换流分为字符输入转换流和字符输出转换流：<ul><li>字符输入转换流：InputStreamReader<li>字符输出转换流：OutputStreamWriter</ul><h3 id=字符输入转换流><a class=headerlink href=#字符输入转换流 title=字符输入转换流></a>字符输入转换流</h3><p>字符输入转换流可以将字节输入流转为字符输入流。参考示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>FileInputStream</span> <span class=variable>fis</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">FileInputStream</span>(<span class=string>"a.txt"</span>);</span><br><span class=line><span class=type>InputStreamReader</span> <span class=variable>isr</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">InputStreamReader</span>(fis, <span class=string>"UTF-8"</span>)</span><br></pre></table></figure><h3 id=字符输出转换流><a class=headerlink href=#字符输出转换流 title=字符输出转换流></a>字符输出转换流</h3><p>字符输出转换流可以将字节输出流转为字符输出流。参考示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>FileOutputStream</span> <span class=variable>fos</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">FileOutputStream</span>(<span class=string>"a.txt"</span>);</span><br><span class=line><span class=type>OutputStreamWriter</span> <span class=variable>osw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">OutputStreamWriter</span>(fos, <span class=string>"UTF-8"</span>);</span><br></pre></table></figure><h2 id=序列化流><a class=headerlink href=#序列化流 title=序列化流></a>序列化流</h2><h3 id=概述-20><a class=headerlink href=#概述-20 title=概述></a>概述</h3><p><strong>序列化流指的是可以将对象写入到文件，也可以从文件中读取对象的一种字节流</strong>。<p>序列化流分为正序列化流和反序列化流。<ul><li>正序列化流：ObjectOutputStream<li>反序列化流：ObjectInputStream</ul><p><strong>如果不希望将对象中的某个字段进行序列化，可以使用修饰符<code>transient</code>来修饰该字段。</strong><p>对象在序列化后，如果改变了对象中的内容，再次进行反序列化时会报错，其原因与类的版本有关系。每当类中内容被修改，类的版本号就会发生改变，此时进行反序列化必然报错，要想避免该种错误，只需固定类的版本号。<p>可以通过在类中定义一个long型私有常量字段<code>serialVersionUID</code>，对应的值为long型数字来固定类的版本号。<h3 id=正序列化流><a class=headerlink href=#正序列化流 title=正序列化流></a>正序列化流</h3><p>正序列化流可以将对象写入到文件中。参考示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=type>User</span> <span class=variable>user</span> <span class=operator>=</span> User.builder().userId(<span class=number>1</span>).userName(<span class=string>"zhangsan"</span>).build();</span><br><span class=line><span class=type>User</span> <span class=variable>user2</span> <span class=operator>=</span> User.builder().userId(<span class=number>2</span>).userName(<span class=string>"lisi"</span>).build();</span><br><span class=line>List&LTUser> userList = <span class=keyword>new</span> <span class="title class_">ArrayList</span><>();</span><br><span class=line>userList.add(user);</span><br><span class=line>userList.add(user2);</span><br><span class=line></span><br><span class=line><span class=keyword>try</span>(</span><br><span class=line>    <span class=type>FileOutputStream</span> <span class=variable>fos</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">FileOutputStream</span>(<span class=string>"users.txt"</span>);</span><br><span class=line>    <span class=type>ObjectOutpuStream</span> <span class=variable>oos</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ObjectOutputStream</span>(fos);</span><br><span class=line>){</span><br><span class=line>    oos.writeObject(userList);</span><br><span class=line>}</span><br></pre></table></figure><h3 id=反序列化流><a class=headerlink href=#反序列化流 title=反序列化流></a>反序列化流</h3><p>反序列化流可以从文件中读取对象。参考示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>try</span>(</span><br><span class=line>    <span class=type>FileInputStream</span> <span class=variable>fis</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">FileInputStream</span>(<span class=string>"users.txt"</span>);</span><br><span class=line>    <span class=type>ObjectInputStream</span> <span class=variable>ois</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ObjectInputStream</span>(fis);</span><br><span class=line>){</span><br><span class=line>    List&LTUser> userList = (List&LTUser>) ois.readObject();</span><br><span class=line>    <span class=keyword>for</span>(User user : userList){</span><br><span class=line>        System.out.println(user);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=打印流><a class=headerlink href=#打印流 title=打印流></a>打印流</h2><h3 id=概述-21><a class=headerlink href=#概述-21 title=概述></a>概述</h3><p>打印流指的是打印、输出的流。<p>打印流有如下几个特点：<ul><li>打印流只有输出流，没有输入流。<li>特有方法可实现数据原样写出。<li>特有方法可实现自动刷新、自动换行。</ul><p>打印流分为两种：字节打印流 和 字符打印流。<ul><li>字节打印流：PrintStream。<li>字符打印流：PrintWriter。</ul><h3 id=字节打印流><a class=headerlink href=#字节打印流 title=字节打印流></a>字节打印流</h3><p>字节打印流底层没有缓冲区，但可以实现自动刷新。<h3 id=字符打印流><a class=headerlink href=#字符打印流 title=字符打印流></a>字符打印流</h3><p>字符打印流底层有缓冲区，想要实现自动刷新需要开启。<h1 id=线程编程><a class=headerlink href=#线程编程 title=线程编程></a>线程编程</h1><h2 id=线程><a class=headerlink href=#线程 title=线程></a>线程</h2><h3 id=概述-22><a class=headerlink href=#概述-22 title=概述></a>概述</h3><p><strong>线程是CPU调度的基本单位</strong>。<p>一个进程中可以存在多个线程，多个线程可以共享进程的资源，每个线程也有自己独立的空间和资源且仅供当前线程使用。<p>线程在运行时有并发和并行两个分类：<ul><li>并发：一个线程在多个任务之间快速切换并执行，同一时间只能执行一个任务，但因切换速度较快，感觉是在同时执行。<li>并行：多个线程对应多个任务同时执行，线程无需切换。可实现真正的同一时间多任务同时执行。</ul><h3 id=实现方式><a class=headerlink href=#实现方式 title=实现方式></a>实现方式</h3><p>创建线程的方式有多种，详情如下：<ul><li>继承Thread类。<li>实现Runable接口。<li>利用Callable接口和Future接口实现。<li>基于线程池创建</ul><h2 id=同步><a class=headerlink href=#同步 title=同步></a>同步</h2><h3 id=概述-23><a class=headerlink href=#概述-23 title=概述></a>概述</h3><p><strong>计算机科学中，同步指的是两个不同但有联系的概念：进程同步与数据同步</strong>。进程同步指多个进程在特定点会合或握手达成协议或使得操作序列有序。数据同步指一个数据集的多份拷贝一致以维护完整性。常用进程同步原语来实现数据同步。<p>多个线程或进程要执行同一个特定的不可重入的程序代码块（临界区），这就需要适当的并发控制同步技术。否则，可能会发生竟态条件。<blockquote><p>竟态条件描述的是一个系统或进程的输出依赖于不受控制的事件出现的顺序或时机。此词语源于两个信号彼此竞争，来影响谁先输出。</blockquote><h3 id=同步代码块><a class=headerlink href=#同步代码块 title=同步代码块></a>同步代码块</h3><p>同步代码块的格式示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>synchronized</span>(<span class=built_in>this</span>/Student.class){</span><br><span class=line>    <span class=comment>//....</span></span><br><span class=line>}</span><br></pre></table></figure><p>可作为同步代码块中锁的元素如下：<ul><li>this：表示同步代码块调用者本身，无法实现多个线程间的同步。<li>字节码：字节码文件，全局唯一，可以实现多个线程间的同步。<li>类对象引用：对象引用本身，全局唯一，可以实现多个线程间的同步。</ul><h3 id=同步方法><a class=headerlink href=#同步方法 title=同步方法></a>同步方法</h3><p>同步方法的格式示例如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>修饰符 <span class=keyword>synchronized</span> 返回值类型 方法名(方法参数){</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>同步方法有静态与非静态之分，区别如下：<ul><li>静态同步方法：锁为当前类的字节码文件对象（类名.class）。<li>非静态方法：锁为方法调用者本身（this）。</ul><h2 id=线程池><a class=headerlink href=#线程池 title=线程池></a>线程池</h2><h3 id=概述-24><a class=headerlink href=#概述-24 title=概述></a>概述</h3><p>线程池是一种线程使用模式。线程过多会带来调度开销，影响缓存局部性和整体性能，而线程池维护着多个线程，等待被分配任务，避免了频繁创建与销毁线程的代价。<h3 id=创建线程池><a class=headerlink href=#创建线程池 title=创建线程池></a>创建线程池</h3><p>创建一个线程池有多种方式，常用方式为：<ul><li>方式一：调用Executors的静态方法来创建。要注意的是，这些静态方法创建的线程池的等待队列理论无上限，易造成内存溢出。<li>方式二（推荐）：自定义参数创建ThreadPoolExecutor对象来创建一个线程池。</ul><p>线程池重要参数：<ul><li>核心线程数量<li>最大线程数量<li>空闲时间<li>空间时间的单位<li>等待队列<li>线程工厂<li>拒绝策略</ul><p>创建线程池时，设定合适数量的线程会带来良好的效果。线程池中线程数量的设定通常遵循以下规则：<ul><li>计算密集型任务：<code>处理器最大核心数量+1</code>。<li>IO密集型任务：<code>处理器最大核心数量*期望CPU利用率*((CPU计算时间+等待时间)/CPU计算时间)</code>。</ul><h1 id=网络编程><a class=headerlink href=#网络编程 title=网络编程></a>网络编程</h1><h2 id=概述-25><a class=headerlink href=#概述-25 title=概述></a>概述</h2><p>网络编程指的是计算机与计算机之间通过网络进行数据传输和通信。<h2 id=软件架构><a class=headerlink href=#软件架构 title=软件架构></a>软件架构</h2><p>软件架构通常有两类：CS架构和BS架构。CS表示客户端和服务端，需要两套系统。BS表示浏览器和服务端，只需要开发服务端系统即可。两者优缺点，显而易见。<h2 id=三要素><a class=headerlink href=#三要素 title=三要素></a>三要素</h2><p><strong>网络编程三要素为：IP、端口、协议</strong>。<p>IP表示设备在网络中的地址，是唯一标识。端口表示应用程序在设备中的唯一标识。协议表示数据在网络中传输的规则，常见的协议有UDP、TCP、HTTP、HTTPS、FTP等。<h3 id=IP><a class=headerlink href=#IP title=IP></a>IP</h3><p><strong>IP全称为Internet Protocol，是互联网协议地址，也称IP地址，是分配给上网设备的数字标签</strong>。<p>IP地址常见的分类有：IPV4、IPV6。<h4 id=IPV4><a class=headerlink href=#IPV4 title=IPV4></a>IPV4</h4><p><strong>IPV4表示互联网通信协议第四版，采用32位地址长度，每8位一组，共分4组，现实中通常用点分十进制来表示</strong>。<blockquote><p>IP地址协议第一次发布就是第四版，前三版没有对外发布。</blockquote><p>IPV4共有2^32次方个IP地址，<strong>2019年11月26日，IPV4地址分配使用完毕</strong>。<h4 id=IPV6><a class=headerlink href=#IPV6 title=IPV6></a>IPV6</h4><p><strong>IPV6表示互联网通信协议第六版，采用128位地址长度，每16位一组，分8组，现实中通常用冒号分十六进制来表示</strong>。<p>IPV6共有2^128次方个IP地址，足够应付目前使用。<h3 id=端口号><a class=headerlink href=#端口号 title=端口号></a>端口号</h3><p><strong>端口号是程序在设备中的唯一标识</strong>。<p>端口号是由两个字节的整数来表示，取值范围为0<del>65535。其中0</del>1023之间的端口号用于一些知名的网络服务或应用，个人使用1024~65535之间的端口号即可。<blockquote><p>一个端口号同时只能被一个应用使用。</blockquote><h3 id=协议><a class=headerlink href=#协议 title=协议></a>协议</h3><h4 id=概述-26><a class=headerlink href=#概述-26 title=概述></a>概述</h4><p><strong>协议指的是网络间通信的规则</strong>。<p>网络间通信协议的标准有：<ul><li>OSI参考模型：世界互联协议标准，因过于理想化，未能全面推广。<li>TCP/IP参考模型：国际标准协议，目前广泛使用的参考模型标准。</ul><p>这两种参考模型的区别如下表：<table><thead><tr><th align=center>OSI参考模型<th align=center>TCP/IP参考模型<th align=center>协议<th align=center>描述<tbody><tr><td align=center>应用层、表示层、会话层<td align=center>应用层<td align=center>http、ftp、telnet<td align=center>应用程序开发<tr><td align=center>传输层<td align=center>传输层<td align=center>tcp、udp<td align=center>选择数据传输的协议<tr><td align=center>网络层<td align=center>网络层<td align=center>ip、icmp、arp<td align=center>封装自己的ip、对方的ip信息等<tr><td align=center>数据链路层、物理层<td align=center>物理+链路层<td align=center>硬件设备<td align=center>转为二进制通过物理设备传输</table><h4 id=UDP协议><a class=headerlink href=#UDP协议 title=UDP协议></a>UDP协议</h4><p><strong>UDP协议，全称User Datagram Protocol，表示用户数据报协议</strong>。<p>UDP协议特定如下：<ul><li>面向无连接的协议。无论对方是否能收到信息，我只管发送。<li>速度快。<li>有大小限制，每次最多发送64K数据。<li>数据不安全，易丢失。</ul><p>UDP通信方式有三种：<ul><li>单播：只对单个设备发送信息。<li>组播：对某一组中的所有设备发送信息。<li>广播：给所有设备发送信息。</ul><h4 id=TCP协议><a class=headerlink href=#TCP协议 title=TCP协议></a>TCP协议</h4><h5 id=简介-12><a class=headerlink href=#简介-12 title=简介></a>简介</h5><p><strong>TCP协议，全称Transmission Control Protocol，表示传输控制协议</strong>。<p>TCP协议特点如下：<ul><li>面向连接的协议。双方连接成功了才会发送信息。<li>发送的数据没有大小限制。<li>数据安全。<li>速度慢。</ul><h5 id=三次握手><a class=headerlink href=#三次握手 title=三次握手></a>三次握手</h5><p><strong>三次握手主要目的是确保成功建立连接，然后才进行通信</strong>。<p>三次握手的过程如下：<ol><li>客户端向服务器发送连接请求，等待服务器确认。<li>服务器收到连接请求，然后发送可连接的响应。<li>客户端收到可连接响应，然后向服务器发送连接请求，建立连接并通信。</ol><h5 id=四次挥手><a class=headerlink href=#四次挥手 title=四次挥手></a>四次挥手</h5><p><strong>四次挥手主要目的是确保通信完毕，没有其他请求和响应</strong>。<p>四次挥手的过程如下：<ol><li>客户端向服务器发送断开连接的请求。<li>服务器收到断开连接的请求，然后响应客户端称已收到你的请求，但请再稍等片刻，我有数据还没有发送完毕。<li>服务器再次向客户端发送可以断开连接的响应信息。<li>客户端收到可以断开连接的信息，客户端再次发送断开连接的请求，断开连接成功。</ol><h1 id=反射><a class=headerlink href=#反射 title=反射></a>反射</h1><h2 id=概述-27><a class=headerlink href=#概述-27 title=概述></a>概述</h2><p><strong>计算机学中，反射指的是程序运行时可以访问、检测和修改它本身状态或行为的一种能力</strong>。比喻来说，反射就是程序运行的时候能够观察并修改自己的行为。<p>Java中的反射描述的是程序运行过程中，可以访问类的成员变量、成员方法、构造方法等信息，并可以通过这些信息来对类做进一步的管理。<p>J<strong>ava中的反射实际执行中是通过Class对象来获取类的信息并做进一步管理</strong>。<h2 id=管理类成员><a class=headerlink href=#管理类成员 title=管理类成员></a>管理类成员</h2><h3 id=获取Class对象><a class=headerlink href=#获取Class对象 title=获取Class对象></a>获取Class对象</h3><p>获取Class对象的方式如下：<ul><li>方式一：<code>Class.forName("全类名");</code><li>方式二：<code>类名.class;</code><li>方式三：<code>对象.getClass();</code></ul><h3 id=管理字段><a class=headerlink href=#管理字段 title=管理字段></a>管理字段</h3><p>获取类成员字段的方式如下：<ul><li>获取所有公共字段：getFields();<li>获取所有字段：getDeclaredFields();<li>获取单个公共字段：getField(String name);<li>获取单个字段：getDeclaredField(String name);</ul><p>基于字段可执行的操作：<ul><li>赋值：set(Object obj, Object val);<li>获取值：get(Object obj);</ul><h3 id=管理构造器><a class=headerlink href=#管理构造器 title=管理构造器></a>管理构造器</h3><p>获取构造器的方式如下：<ul><li>获取所有公共构造器：getConstructors();<li>获取所有构造器：getDeclaredConstructors();<li>获取单个公共构造器：getConstructor(Class…type);<li>获取单个构造器：getDeclaredConstructor(Class…type)</ul><p>基于构造器反射创建对象的方式如下：<ul><li>newInstance(Object…args);<li>setAccessible(boolean flag)</ul><h3 id=管理方法><a class=headerlink href=#管理方法 title=管理方法></a>管理方法</h3><p>获取类成员方法的方式如下：<ul><li>获取所有公共方法：getMethods();<li>获取所有方法：getDeclaredMethods();<li>获取单个公共方法：getMethod(String name, Class…type);<li>获取单个方法：getDeclaredMethod(String name, Class…type);</ul><p>基于方法可执行的操作：<ul><li>执行方法：invoke(Object obj, Object…args);</ul><h1 id=动态代理><a class=headerlink href=#动态代理 title=动态代理></a>动态代理</h1><h2 id=概述-28><a class=headerlink href=#概述-28 title=概述></a>概述</h2><p>代理可以无侵入式的为对象增加功能。<p>代理对象和被代理对象通过实现同一接口来实现代理功能，接口中是要被代理的方法。<h2 id=创建代理><a class=headerlink href=#创建代理 title=创建代理></a>创建代理</h2><p>Java中创建代理对象可以通过java.lang.Proxy类来实现。Proxy类提供了一个创建代理对象的方法<code>newProxyInstance(...)</code>，该方法有三个参数：<ul><li>ClassLoader：设置要加载代理类的类加载器。<li>Interface：设定要代理哪个接口中的方法。<li>InvocationHandler：代理要执行的具体逻辑。</ul><p>代码示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">ProxyFactory</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> Object <span class="title function_">getProxy</span><span class=params>(Object obj)</span>{</span><br><span class=line>        <span class=keyword>return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), </span><br><span class=line>                                     <span class=keyword>new</span> <span class="title class_">MyInvocationHandler</span>(obj));</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=comment>// 自定义执行器</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">MyInvocationHandler</span>{</span><br><span class=line>    <span class=keyword>private</span> Object target;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MyInvocationHandler</span><span class=params>(Object obj)</span>{</span><br><span class=line>        <span class=built_in>this</span>.target = obj;</span><br><span class=line>    }	</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">invoke</span><span class=params>(Object proxy, Method m, Object[] args)</span> <span class=keyword>throws</span> throwable {</span><br><span class=line>        <span class=keyword>return</span> m.invoke(target, args);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure></div><footer class=post-footer><div class=post-tags><a href=/tags/Java%E5%9F%BA%E7%A1%80/ rel=tag># Java基础</a></div><div class=post-nav><div class=post-nav-item><a href=/2024/10/12/Java%E4%B9%8BWeb%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/ rel=prev title=Java系列-Web基础> <i class="fa fa-angle-left"></i> Java系列-Web基础 </a></div><div class=post-nav-item><a href=/2024/10/12/Java%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9F%A5%E8%AF%86%E7%AF%87/ rel=next title=Java系列-设计模式> Java系列-设计模式 <i class="fa fa-angle-right"></i> </a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script>