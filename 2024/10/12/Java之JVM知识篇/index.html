<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hshz21.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="0、必知必会0.1、Java类加载0.1.1、Class文件0.1.1.1、简介Class文件是一组以8位为单位的 二进制流，超过8位以上的会被按照 高位在前 分割成多个8位进行存储。 Class文件格式采用一种类似C语言结构体的伪结构进行数据存储，其中包含两种数据类型，即 无符号数和表 。  无符号数：无符号数属于基本数据类型，以u1、u2、u4、u8分别代表1字节、2字节、4字节、8字节的无符" name=description><meta content=article property=og:type><meta content=Java系列-JVM property=og:title><meta content=https://hshz21.gitee.io/2024/10/12/Java%E4%B9%8BJVM%E7%9F%A5%E8%AF%86%E7%AF%87/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content="0、必知必会0.1、Java类加载0.1.1、Class文件0.1.1.1、简介Class文件是一组以8位为单位的 二进制流，超过8位以上的会被按照 高位在前 分割成多个8位进行存储。 Class文件格式采用一种类似C语言结构体的伪结构进行数据存储，其中包含两种数据类型，即 无符号数和表 。  无符号数：无符号数属于基本数据类型，以u1、u2、u4、u8分别代表1字节、2字节、4字节、8字节的无符" property=og:description><meta content=zh_CN property=og:locale><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210428110838690.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20201224173439957.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/2.1.1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%89%8D%E8%A8%80-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86-1.1-%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%BD%8D-%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%9B%BE%E7%A4%BA.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86-1.2-%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E5%9B%BE%E7%A4%BA.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2024/02/19/image-20240219151141264.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-1.1-G1-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/ZGC%E9%A2%9C%E8%89%B2%E6%8C%87%E9%92%8801.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/ZGC%E5%86%85%E5%AD%98%E5%A4%9A%E9%87%8D%E6%98%A0%E5%B0%8401.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/ZGC%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B01 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-1.2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210315120311771.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210314213906184.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210314214048813.png property=og:image><meta content=2024-10-12T03:23:46.439Z property=article:published_time><meta content=2024-10-11T14:50:38.092Z property=article:modified_time><meta content=豪哥 property=article:author><meta content=JVM property=article:tag><meta content=summary name=twitter:card><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210428110838690.png name=twitter:image><link href=https://hshz21.gitee.io/2024/10/12/Java%E4%B9%8BJVM%E7%9F%A5%E8%AF%86%E7%AF%87/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hshz21.gitee.io/2024/10/12/Java%E4%B9%8BJVM%E7%9F%A5%E8%AF%86%E7%AF%87/","path":"2024/10/12/Java之JVM知识篇/","title":"Java系列-JVM"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>Java系列-JVM | 豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>豪哥博客</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#0%E3%80%81%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A><span class=nav-number>1.</span> <span class=nav-text>0、必知必会</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#0-1%E3%80%81Java%E7%B1%BB%E5%8A%A0%E8%BD%BD><span class=nav-number>1.1.</span> <span class=nav-text>0.1、Java类加载</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#0-1-1%E3%80%81Class%E6%96%87%E4%BB%B6><span class=nav-number>1.1.1.</span> <span class=nav-text>0.1.1、Class文件</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-1-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.1.1.1.</span> <span class=nav-text>0.1.1.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-1-2%E3%80%81class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84><span class=nav-number>1.1.1.2.</span> <span class=nav-text>0.1.1.2、class文件结构</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%AE%80%E4%BB%8B><span class=nav-number>1.1.1.2.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%AD%94%E6%95%B0><span class=nav-number>1.1.1.2.2.</span> <span class=nav-text>魔数</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%B8%BB%E6%AC%A1%E7%89%88%E6%9C%AC%E5%8F%B7><span class=nav-number>1.1.1.2.3.</span> <span class=nav-text>主次版本号</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%B8%B8%E9%87%8F%E6%B1%A0><span class=nav-number>1.1.1.2.4.</span> <span class=nav-text>常量池</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%96%B9%E6%B3%95><span class=nav-number>1.1.1.2.5.</span> <span class=nav-text>方法</span></a></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#0-1-2%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B><span class=nav-number>1.1.2.</span> <span class=nav-text>0.1.2、类加载过程</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-2-1%E3%80%81%E6%A6%82%E8%BF%B0><span class=nav-number>1.1.2.1.</span> <span class=nav-text>0.1.2.1、概述</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-2-2%E3%80%81%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5><span class=nav-number>1.1.2.2.</span> <span class=nav-text>0.1.2.2、加载阶段</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-2-3%E3%80%81%E9%93%BE%E6%8E%A5%E9%98%B6%E6%AE%B5><span class=nav-number>1.1.2.3.</span> <span class=nav-text>0.1.2.3、链接阶段</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%AA%8C%E8%AF%81%E9%98%B6%E6%AE%B5><span class=nav-number>1.1.2.3.1.</span> <span class=nav-text>验证阶段</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5><span class=nav-number>1.1.2.3.2.</span> <span class=nav-text>准备阶段</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E8%A7%A3%E6%9E%90%E9%98%B6%E6%AE%B5><span class=nav-number>1.1.2.3.3.</span> <span class=nav-text>解析阶段</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-2-4%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5><span class=nav-number>1.1.2.4.</span> <span class=nav-text>0.1.2.4、初始化阶段</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-2-5%E3%80%81%E4%BD%BF%E7%94%A8%E5%92%8C%E5%8D%B8%E8%BD%BD%E9%98%B6%E6%AE%B5><span class=nav-number>1.1.2.5.</span> <span class=nav-text>0.1.2.5、使用和卸载阶段</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#0-1-3%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8><span class=nav-number>1.1.3.</span> <span class=nav-text>0.1.3、类加载器</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-3-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.1.3.1.</span> <span class=nav-text>0.1.3.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-3-2%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%88%86%E7%B1%BB><span class=nav-number>1.1.3.2.</span> <span class=nav-text>0.1.3.2、类加载器分类</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-3-3%E3%80%81%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4><span class=nav-number>1.1.3.3.</span> <span class=nav-text>0.1.3.3、常用命令</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-3-4%E3%80%81JDK9%E6%96%B0%E5%8F%98%E5%8C%96><span class=nav-number>1.1.3.4.</span> <span class=nav-text>0.1.3.4、JDK9新变化</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#0-1-4%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B><span class=nav-number>1.1.4.</span> <span class=nav-text>0.1.4、双亲委派模型</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-4-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.1.4.1.</span> <span class=nav-text>0.1.4.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-4-2%E3%80%81%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95><span class=nav-number>1.1.4.2.</span> <span class=nav-text>0.1.4.2、重要方法</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-4-3%E3%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86><span class=nav-number>1.1.4.3.</span> <span class=nav-text>0.1.4.3、实现原理</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-4-4%E3%80%81%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E6%A8%A1%E5%9E%8B><span class=nav-number>1.1.4.4.</span> <span class=nav-text>0.1.4.4、破坏双亲模型</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-4-5%E3%80%81JNDI-JDBC%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE><span class=nav-number>1.1.4.5.</span> <span class=nav-text>0.1.4.5、JNDI/JDBC破坏双亲委派</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-4-6%E3%80%81Tomcat%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE><span class=nav-number>1.1.4.6.</span> <span class=nav-text>0.1.4.6、Tomcat破坏双亲委派</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-1><span class=nav-number>1.1.4.6.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#tomcat%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8><span class=nav-number>1.1.4.6.2.</span> <span class=nav-text>tomcat中的类加载器</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-4-7%E3%80%81%E6%80%BB%E7%BB%93><span class=nav-number>1.1.4.7.</span> <span class=nav-text>0.1.4.7、总结</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%88%B6%E5%AD%90%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B9%8B%E9%97%B4%E6%98%AF%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E5%90%97%EF%BC%9F><span class=nav-number>1.1.4.7.1.</span> <span class=nav-text>父子加载器之间是继承关系吗？</span></a></ol></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#0-2%E3%80%81JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA><span class=nav-number>1.2.</span> <span class=nav-text>0.2、JVM运行时数据区</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#0-1-1%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88%E7%A7%81%E6%9C%89%EF%BC%89><span class=nav-number>1.2.1.</span> <span class=nav-text>0.1.1、程序计数器（私有）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-1-1%E3%80%81%E7%AE%80%E4%BB%8B-1><span class=nav-number>1.2.1.1.</span> <span class=nav-text>0.1.1.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-1-2%E3%80%81%E4%BD%9C%E7%94%A8><span class=nav-number>1.2.1.2.</span> <span class=nav-text>0.1.1.2、作用</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#0-1-2%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88%E5%85%AC%E6%9C%89%EF%BC%89><span class=nav-number>1.2.2.</span> <span class=nav-text>0.1.2、方法区（公有）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-2-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.2.2.1.</span> <span class=nav-text>0.1.2.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-2-2%E3%80%81%E5%AE%9E%E7%8E%B0><span class=nav-number>1.2.2.2.</span> <span class=nav-text>0.1.2.2、实现</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-2-3%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E6%BC%94%E5%8F%98><span class=nav-number>1.2.2.3.</span> <span class=nav-text>0.1.2.3、方法区演变</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-2-4%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0><span class=nav-number>1.2.2.4.</span> <span class=nav-text>0.1.2.4、运行时常量池</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%B8%B8%E9%87%8F%E6%B1%A0-1><span class=nav-number>1.2.2.4.1.</span> <span class=nav-text>常量池</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0><span class=nav-number>1.2.2.4.2.</span> <span class=nav-text>运行时常量池</span></a></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#0-1-3%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%88%E7%A7%81%E6%9C%89%EF%BC%89><span class=nav-number>1.2.3.</span> <span class=nav-text>0.1.3、虚拟机栈（私有）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-3-1%E3%80%81%E7%AE%80%E4%BB%8B-1><span class=nav-number>1.2.3.1.</span> <span class=nav-text>0.1.3.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-3-2%E3%80%81%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84><span class=nav-number>1.2.3.2.</span> <span class=nav-text>0.1.3.2、内部结构</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-3-3%E3%80%81%E5%85%B6%E5%AE%83><span class=nav-number>1.2.3.3.</span> <span class=nav-text>0.1.3.3、其它</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#0-1-4%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%88%E7%A7%81%E6%9C%89%EF%BC%89><span class=nav-number>1.2.4.</span> <span class=nav-text>0.1.4、本地方法栈（私有）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-4-1%E3%80%81%E7%AE%80%E4%BB%8B-1><span class=nav-number>1.2.4.1.</span> <span class=nav-text>0.1.4.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-4-2%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9><span class=nav-number>1.2.4.2.</span> <span class=nav-text>0.1.4.2、注意事项</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#0-1-5%E3%80%81%E5%A0%86%EF%BC%88%E5%85%AC%E6%9C%89%EF%BC%89><span class=nav-number>1.2.5.</span> <span class=nav-text>0.1.5、堆（公有）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-5-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.2.5.1.</span> <span class=nav-text>0.1.5.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-5-2%E3%80%81%E5%88%86%E4%BB%A3%E6%A8%A1%E5%9E%8B><span class=nav-number>1.2.5.2.</span> <span class=nav-text>0.1.5.2、分代模型</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-5-3%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F><span class=nav-number>1.2.5.3.</span> <span class=nav-text>0.1.5.3、空间大小</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%A0%86%E5%A4%A7%E5%B0%8F><span class=nav-number>1.2.5.3.1.</span> <span class=nav-text>堆大小</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%96%B0%E7%94%9F%E4%BB%A3%E8%80%81%E5%B9%B4%E4%BB%A3><span class=nav-number>1.2.5.3.2.</span> <span class=nav-text>新生代老年代</span></a></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#0-1-6%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98><span class=nav-number>1.2.6.</span> <span class=nav-text>0.1.6、直接内存</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#0-1-7%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0><span class=nav-number>1.2.7.</span> <span class=nav-text>0.1.7、字符串常量池</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-7-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.2.7.1.</span> <span class=nav-text>0.1.7.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-1-7-2%E3%80%81%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE><span class=nav-number>1.2.7.2.</span> <span class=nav-text>0.1.7.2、参数设置</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#0-3%E3%80%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E><span class=nav-number>1.3.</span> <span class=nav-text>0.3、执行引擎</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#0-3-1%E3%80%81%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8><span class=nav-number>1.3.1.</span> <span class=nav-text>0.3.1、即时编译器</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E8%A7%A3%E9%87%8A%E5%99%A8%E4%B8%8E%E7%BC%96%E8%AF%91%E5%99%A8><span class=nav-number>1.3.1.0.1.</span> <span class=nav-text>解释器与编译器</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%83%AD%E7%82%B9%E4%BB%A3%E7%A0%81><span class=nav-number>1.3.1.0.2.</span> <span class=nav-text>热点代码</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E8%B0%83%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8><span class=nav-number>1.3.1.0.3.</span> <span class=nav-text>调用计数器</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%9B%9E%E8%BE%B9%E8%AE%A1%E6%95%B0%E5%99%A8><span class=nav-number>1.3.1.0.4.</span> <span class=nav-text>回边计数器</span></a></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#0-3-2%E3%80%81%E6%8F%90%E5%89%8D%E7%BC%96%E8%AF%91%E5%99%A8><span class=nav-number>1.3.2.</span> <span class=nav-text>0.3.2、提前编译器</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#0-3-3%E3%80%81%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96><span class=nav-number>1.3.3.</span> <span class=nav-text>0.3.3、编译器优化</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%88%86%E5%B1%82%E7%BC%96%E8%AF%91><span class=nav-number>1.3.3.1.</span> <span class=nav-text>分层编译</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94><span class=nav-number>1.3.3.2.</span> <span class=nav-text>方法内联</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-2><span class=nav-number>1.3.3.2.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%86%85%E8%81%94%E7%9A%84%E9%99%90%E5%88%B6><span class=nav-number>1.3.3.2.2.</span> <span class=nav-text>内联的限制</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90><span class=nav-number>1.3.3.3.</span> <span class=nav-text>逃逸分析</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-3><span class=nav-number>1.3.3.3.0.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-6"><a class=nav-link href=#%E4%BC%98%E5%8C%96><span class=nav-number>1.3.3.3.0.2.</span> <span class=nav-text>优化</span></a><li class="nav-item nav-level-6"><a class=nav-link href=#%E5%8A%9F%E8%83%BD%E5%BC%80%E5%90%AF><span class=nav-number>1.3.3.3.0.3.</span> <span class=nav-text>功能开启</span></a></ol></ol><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%85%AC%E5%85%B1%E5%AD%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B6%88%E9%99%A4><span class=nav-number>1.3.3.4.</span> <span class=nav-text>公共子表达式消除</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%95%B0%E7%BB%84%E8%BE%B9%E7%95%8C%E6%A3%80%E6%9F%A5%E6%B6%88%E9%99%A4><span class=nav-number>1.3.3.5.</span> <span class=nav-text>数组边界检查消除</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#0-3-4%E3%80%81Graal%E7%BC%96%E8%AF%91%E5%99%A8><span class=nav-number>1.3.4.</span> <span class=nav-text>0.3.4、Graal编译器</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#0-3-5%E3%80%81%E6%80%BB%E7%BB%93><span class=nav-number>1.3.5.</span> <span class=nav-text>0.3.5、总结</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#0-4%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3><span class=nav-number>1.4.</span> <span class=nav-text>0.4、本地方法接口</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#0-4-1%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95><span class=nav-number>1.4.1.</span> <span class=nav-text>0.4.1、本地方法</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#0-4-1-1%E3%80%81%E5%AE%9A%E4%B9%89><span class=nav-number>1.4.1.1.</span> <span class=nav-text>0.4.1.1、定义</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#0-5%E3%80%81%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86><span class=nav-number>1.5.</span> <span class=nav-text>0.5、对象管理</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#0-5-1%E3%80%81%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA><span class=nav-number>1.5.1.</span> <span class=nav-text>0.5.1、对象创建</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#0-5-2%E3%80%81%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%BD%8D><span class=nav-number>1.5.2.</span> <span class=nav-text>0.5.2、对象定位</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#0-5-2-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.5.2.1.</span> <span class=nav-text>0.5.2.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-5-2-2%E3%80%81%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE><span class=nav-number>1.5.2.2.</span> <span class=nav-text>0.5.2.2、句柄访问</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#0-5-2-3%E3%80%81%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88><span class=nav-number>1.5.2.3.</span> <span class=nav-text>0.5.2.3、直接指针</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#1%E3%80%81JVM%E5%9F%BA%E7%A1%80><span class=nav-number>2.</span> <span class=nav-text>1、JVM基础</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81%E6%A6%82%E8%BF%B0><span class=nav-number>2.1.</span> <span class=nav-text>1.1、概述</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>2.1.1.</span> <span class=nav-text>1.1.1、简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-2%E3%80%81%E4%BC%98%E7%82%B9><span class=nav-number>2.1.2.</span> <span class=nav-text>1.1.2、优点</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-3%E3%80%81%E5%B8%B8%E8%A7%81%E8%99%9A%E6%8B%9F%E6%9C%BA><span class=nav-number>2.1.3.</span> <span class=nav-text>1.1.3、常见虚拟机</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-4%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%80%80%E5%87%BA><span class=nav-number>2.1.4.</span> <span class=nav-text>1.1.4、虚拟机退出</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-2%E3%80%81%E5%9E%83%E5%9C%BE><span class=nav-number>2.2.</span> <span class=nav-text>1.2、垃圾</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-1%E3%80%81%E6%A6%82%E8%BF%B0><span class=nav-number>2.2.1.</span> <span class=nav-text>1.2.1、概述</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-2%E3%80%81%E8%AF%86%E5%88%AB%E5%9E%83%E5%9C%BE><span class=nav-number>2.2.2.</span> <span class=nav-text>1.2.2、识别垃圾</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-2-2-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>2.2.2.1.</span> <span class=nav-text>1.2.2.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-2-2-2%E3%80%81%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95><span class=nav-number>2.2.2.2.</span> <span class=nav-text>1.2.2.2、引用计数算法</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-4><span class=nav-number>2.2.2.2.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%89%B9%E7%82%B9><span class=nav-number>2.2.2.2.2.</span> <span class=nav-text>特点</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%BC%BA%E7%82%B9><span class=nav-number>2.2.2.2.3.</span> <span class=nav-text>缺点</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#1-2-2-3%E3%80%81%E6%A0%B9%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95><span class=nav-number>2.2.2.3.</span> <span class=nav-text>1.2.2.3、根可达性算法</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-5><span class=nav-number>2.2.2.3.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%A0%B9%E5%AF%B9%E8%B1%A1><span class=nav-number>2.2.2.3.2.</span> <span class=nav-text>根对象</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9><span class=nav-number>2.2.2.3.3.</span> <span class=nav-text>注意事项</span></a></ol></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-3%E3%80%81%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F><span class=nav-number>2.3.</span> <span class=nav-text>1.3、对象生命周期</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-1%E3%80%81%E6%A6%82%E8%BF%B0><span class=nav-number>2.3.1.</span> <span class=nav-text>1.3.1、概述</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-2%E3%80%81%E6%96%B0%E7%94%9F%E4%BB%A3><span class=nav-number>2.3.2.</span> <span class=nav-text>1.3.2、新生代</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-2-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>2.3.2.1.</span> <span class=nav-text>1.3.2.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-2-2%E3%80%81%E6%96%B0%E7%94%9F%E4%BB%A3GC><span class=nav-number>2.3.2.2.</span> <span class=nav-text>1.3.2.2、新生代GC</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-3%E3%80%81%E8%80%81%E5%B9%B4%E4%BB%A3><span class=nav-number>2.3.3.</span> <span class=nav-text>1.3.3、老年代</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-3-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>2.3.3.1.</span> <span class=nav-text>1.3.3.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-3-2%E3%80%81%E8%80%81%E5%B9%B4%E4%BB%A3GC><span class=nav-number>2.3.3.2.</span> <span class=nav-text>1.3.3.2、老年代GC</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-4%E3%80%81Full-GC><span class=nav-number>2.3.4.</span> <span class=nav-text>1.3.4、Full GC</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-4%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95><span class=nav-number>2.4.</span> <span class=nav-text>1.4、垃圾回收算法</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-1%E3%80%81%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%EF%BC%88Mark-Sweep%EF%BC%89><span class=nav-number>2.4.1.</span> <span class=nav-text>1.4.1、标记清除（Mark-Sweep）</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%AE%9A%E4%B9%89><span class=nav-number>2.4.1.0.1.</span> <span class=nav-text>定义</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BC%98%E7%BC%BA%E7%82%B9><span class=nav-number>2.4.1.0.2.</span> <span class=nav-text>优缺点</span></a></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-2%E3%80%81%E5%A4%8D%E5%88%B6%EF%BC%88Copying%EF%BC%89><span class=nav-number>2.4.2.</span> <span class=nav-text>1.4.2、复制（Copying）</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%AE%9A%E4%B9%89-1><span class=nav-number>2.4.2.0.1.</span> <span class=nav-text>定义</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BC%98%E7%BC%BA%E7%82%B9-1><span class=nav-number>2.4.2.0.2.</span> <span class=nav-text>优缺点</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF><span class=nav-number>2.4.2.0.3.</span> <span class=nav-text>适用场景</span></a></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-3%E3%80%81%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9%EF%BC%88Mark-Compact%EF%BC%89><span class=nav-number>2.4.3.</span> <span class=nav-text>1.4.3、标记压缩（Mark-Compact）</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%AE%9A%E4%B9%89-2><span class=nav-number>2.4.3.0.1.</span> <span class=nav-text>定义</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BC%98%E7%BC%BA%E7%82%B9-2><span class=nav-number>2.4.3.0.2.</span> <span class=nav-text>优缺点</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-4%E3%80%81%E5%A2%9E%E9%87%8F%E7%AE%97%E6%B3%95-%EF%BC%88Incremental-Collecting><span class=nav-number>2.4.4.</span> <span class=nav-text>1.4.4、增量算法 （Incremental Collecting )</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-5%E3%80%81%E5%85%B6%E5%AE%83><span class=nav-number>2.4.5.</span> <span class=nav-text>1.4.5、其它</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-4-5-1%E3%80%81%E5%B1%8F%E9%9A%9C><span class=nav-number>2.4.5.1.</span> <span class=nav-text>1.4.5.1、屏障</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-6><span class=nav-number>2.4.5.1.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%86%99%E5%B1%8F%E9%9A%9C><span class=nav-number>2.4.5.1.2.</span> <span class=nav-text>写屏障</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#1-4-5-2%E3%80%81Card-Table%EF%BC%88%E5%8D%A1%E8%A1%A8%EF%BC%89><span class=nav-number>2.4.5.2.</span> <span class=nav-text>1.4.5.2、Card Table（卡表）</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-7><span class=nav-number>2.4.5.2.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86><span class=nav-number>2.4.5.2.2.</span> <span class=nav-text>底层原理</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#1-4-5-3%E3%80%81RSet><span class=nav-number>2.4.5.3.</span> <span class=nav-text>1.4.5.3、RSet</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-8><span class=nav-number>2.4.5.3.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-1><span class=nav-number>2.4.5.3.2.</span> <span class=nav-text>底层原理</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#point-in%E6%9C%BA%E5%88%B6><span class=nav-number>2.4.5.3.3.</span> <span class=nav-text>point-in机制</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#1-4-5-4%E3%80%81CSet><span class=nav-number>2.4.5.4.</span> <span class=nav-text>1.4.5.4、CSet</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-9><span class=nav-number>2.4.5.4.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-2><span class=nav-number>2.4.5.4.2.</span> <span class=nav-text>底层原理</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#1-4-5-5%E3%80%81TLAB><span class=nav-number>2.4.5.5.</span> <span class=nav-text>1.4.5.5、TLAB</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-10><span class=nav-number>2.4.5.5.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%8F%82%E6%95%B0><span class=nav-number>2.4.5.5.2.</span> <span class=nav-text>参数</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#TLAB%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3><span class=nav-number>2.4.5.5.3.</span> <span class=nav-text>TLAB空间不足</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#1-4-5-6%E3%80%81PLAB><span class=nav-number>2.4.5.6.</span> <span class=nav-text>1.4.5.6、PLAB</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-11><span class=nav-number>2.4.5.6.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%8F%82%E6%95%B0-1><span class=nav-number>2.4.5.6.2.</span> <span class=nav-text>参数</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#1-4-5-7%E3%80%81SATB><span class=nav-number>2.4.5.7.</span> <span class=nav-text>1.4.5.7、SATB</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-12><span class=nav-number>2.4.5.7.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-3><span class=nav-number>2.4.5.7.2.</span> <span class=nav-text>底层原理</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-5%E3%80%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8><span class=nav-number>2.5.</span> <span class=nav-text>1.5、垃圾收集器</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-5-1%E3%80%81Serial%EF%BC%88JDK1-3%EF%BC%89><span class=nav-number>2.5.1.</span> <span class=nav-text>1.5.1、Serial（JDK1.3）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-13><span class=nav-number>2.5.1.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8F%82%E6%95%B0-2><span class=nav-number>2.5.1.2.</span> <span class=nav-text>参数</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-5-2%E3%80%81Serial-Old><span class=nav-number>2.5.2.</span> <span class=nav-text>1.5.2、Serial Old</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-14><span class=nav-number>2.5.2.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8F%82%E6%95%B0-3><span class=nav-number>2.5.2.2.</span> <span class=nav-text>参数</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-5-3%E3%80%81Parallel-Scavenge%EF%BC%88JDK1-4%EF%BC%89><span class=nav-number>2.5.3.</span> <span class=nav-text>1.5.3、Parallel Scavenge（JDK1.4）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-15><span class=nav-number>2.5.3.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8F%82%E6%95%B0-4><span class=nav-number>2.5.3.2.</span> <span class=nav-text>参数</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-5-4%E3%80%81Parallel-Old><span class=nav-number>2.5.4.</span> <span class=nav-text>1.5.4、Parallel Old</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-16><span class=nav-number>2.5.4.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%A6%82%E4%BD%95%E5%BC%80%E5%90%AF%EF%BC%9F><span class=nav-number>2.5.4.2.</span> <span class=nav-text>如何开启？</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-5-5%E3%80%81ParNew><span class=nav-number>2.5.5.</span> <span class=nav-text>1.5.5、ParNew</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-17><span class=nav-number>2.5.5.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BC%98%E7%BC%BA%E7%82%B9-3><span class=nav-number>2.5.5.2.</span> <span class=nav-text>优缺点</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8F%82%E6%95%B0-5><span class=nav-number>2.5.5.3.</span> <span class=nav-text>参数</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#ParNew-vs-Paraller-Scavenge><span class=nav-number>2.5.5.4.</span> <span class=nav-text>ParNew vs Paraller Scavenge</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-5-6%E3%80%81CMS%EF%BC%88JDK1-4%EF%BC%89><span class=nav-number>2.5.6.</span> <span class=nav-text>1.5.6、CMS（JDK1.4）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-6-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>2.5.6.1.</span> <span class=nav-text>1.5.6.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-6-2%E3%80%81%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B><span class=nav-number>2.5.6.2.</span> <span class=nav-text>1.5.6.2、回收过程</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-6-3%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9><span class=nav-number>2.5.6.3.</span> <span class=nav-text>1.5.6.3、优缺点</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-6-4%E3%80%81%E5%8F%82%E6%95%B0><span class=nav-number>2.5.6.4.</span> <span class=nav-text>1.5.6.4、参数</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-6-5%E3%80%81%E5%8D%A1%E8%A1%A8%E7%9A%84%E4%BD%BF%E7%94%A8><span class=nav-number>2.5.6.5.</span> <span class=nav-text>1.5.6.5、卡表的使用</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-5-7%E3%80%81G1%EF%BC%88JDK7%EF%BC%89><span class=nav-number>2.5.7.</span> <span class=nav-text>1.5.7、G1（JDK7）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-7-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>2.5.7.1.</span> <span class=nav-text>1.5.7.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-8-7-2%E3%80%81Region><span class=nav-number>2.5.7.2.</span> <span class=nav-text>1.8.7.2、Region</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-7-4%E3%80%81GC%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B><span class=nav-number>2.5.7.3.</span> <span class=nav-text>1.5.7.4、GC回收过程</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#YGC%E9%98%B6%E6%AE%B5%EF%BC%88%E6%A0%87%E8%AE%B0%E5%A4%8D%E5%88%B6-STW%EF%BC%89><span class=nav-number>2.5.7.3.1.</span> <span class=nav-text>YGC阶段（标记复制 / STW）</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0><span class=nav-number>2.5.7.3.2.</span> <span class=nav-text>并发标记</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%B7%B7%E5%90%88%E5%9B%9E%E6%94%B6%EF%BC%88Mixed-GC%EF%BC%89><span class=nav-number>2.5.7.3.3.</span> <span class=nav-text>混合回收（Mixed GC）</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#FGC><span class=nav-number>2.5.7.3.4.</span> <span class=nav-text>FGC</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-7-5%E3%80%81%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95><span class=nav-number>2.5.7.4.</span> <span class=nav-text>1.5.7.5、三色标记算法</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-7-8%E3%80%81G1%E4%BC%98%E5%8C%96><span class=nav-number>2.5.7.5.</span> <span class=nav-text>1.5.7.8、G1优化</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-7-9%E3%80%81%E5%8F%82%E6%95%B0><span class=nav-number>2.5.7.6.</span> <span class=nav-text>1.5.7.9、参数</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-7-10%E3%80%81G1%E7%89%B9%E6%9C%89%E5%8A%9F%E8%83%BD><span class=nav-number>2.5.7.7.</span> <span class=nav-text>1.5.7.10、G1特有功能</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%BB%E9%87%8D><span class=nav-number>2.5.7.7.1.</span> <span class=nav-text>字符串去重</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%B1%BB%E5%8D%B8%E8%BD%BD><span class=nav-number>2.5.7.7.2.</span> <span class=nav-text>类卸载</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%9B%9E%E6%94%B6%E5%B7%A8%E5%9E%8B%E5%AF%B9%E8%B1%A1><span class=nav-number>2.5.7.7.3.</span> <span class=nav-text>回收巨型对象</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%8A%A8%E6%80%81%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0><span class=nav-number>2.5.7.7.4.</span> <span class=nav-text>动态并发标记</span></a></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-5-8%E3%80%81ZGC-%EF%BC%88JDK11%EF%BC%89><span class=nav-number>2.5.8.</span> <span class=nav-text>1.5.8、ZGC （JDK11）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-8-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>2.5.8.1.</span> <span class=nav-text>1.5.8.1、简介</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%A6%82%E8%BF%B0><span class=nav-number>2.5.8.1.1.</span> <span class=nav-text>概述</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%88%86%E4%BB%A3ZGC><span class=nav-number>2.5.8.1.2.</span> <span class=nav-text>分代ZGC</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-8-2%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80><span class=nav-number>2.5.8.2.</span> <span class=nav-text>1.5.8.2、内存布局</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-8-3%E3%80%81%E6%9F%93%E8%89%B2%E6%8C%87%E9%92%88><span class=nav-number>2.5.8.3.</span> <span class=nav-text>1.5.8.3、染色指针</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-18><span class=nav-number>2.5.8.3.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%89%B9%E7%82%B9-1><span class=nav-number>2.5.8.3.2.</span> <span class=nav-text>特点</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-8-4%E3%80%81%E8%AF%BB%E5%B1%8F%E9%9A%9C><span class=nav-number>2.5.8.4.</span> <span class=nav-text>1.5.8.4、读屏障</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-8-5%E3%80%81%E5%86%85%E5%AD%98%E5%A4%9A%E9%87%8D%E6%98%A0%E5%B0%84><span class=nav-number>2.5.8.5.</span> <span class=nav-text>1.5.8.5、内存多重映射</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-19><span class=nav-number>2.5.8.5.1.</span> <span class=nav-text>简介</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-8-6%E3%80%81ZGC%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B><span class=nav-number>2.5.8.6.</span> <span class=nav-text>1.5.8.6、ZGC工作过程</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-8-7%E3%80%81ZGC%E4%BC%98%E7%BC%BA%E7%82%B9><span class=nav-number>2.5.8.7.</span> <span class=nav-text>1.5.8.7、ZGC优缺点</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BC%98%E7%82%B9%EF%BC%88%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F%E3%80%81%E4%BD%8E%E5%BB%B6%E8%BF%9F%EF%BC%89><span class=nav-number>2.5.8.7.1.</span> <span class=nav-text>优点（高吞吐量、低延迟）</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%BC%BA%E7%82%B9%EF%BC%88%E6%B5%AE%E5%8A%A8%E5%9E%83%E5%9C%BE%EF%BC%89><span class=nav-number>2.5.8.7.2.</span> <span class=nav-text>缺点（浮动垃圾）</span></a></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-5-9%E3%80%81Epsilon%EF%BC%88JDK11%EF%BC%89><span class=nav-number>2.5.9.</span> <span class=nav-text>1.5.9、Epsilon（JDK11）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-9-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>2.5.9.1.</span> <span class=nav-text>1.5.9.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-9-2%E3%80%81%E7%9B%AE%E6%A0%87><span class=nav-number>2.5.9.2.</span> <span class=nav-text>1.5.9.2、目标</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-9-3%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF><span class=nav-number>2.5.9.3.</span> <span class=nav-text>1.5.9.3、使用场景</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-9-4%E3%80%81%E7%9B%B8%E5%85%B3%E6%8F%8F%E8%BF%B0><span class=nav-number>2.5.9.4.</span> <span class=nav-text>1.5.9.4、相关描述</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-5-10%E3%80%81Shenandoah><span class=nav-number>2.5.10.</span> <span class=nav-text>1.5.10、Shenandoah</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-5-11%E3%80%81%E6%80%BB%E7%BB%93><span class=nav-number>2.5.11.</span> <span class=nav-text>1.5.11、总结</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-11-1%E3%80%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%AF%B9%E6%AF%94><span class=nav-number>2.5.11.1.</span> <span class=nav-text>1.5.11.1、垃圾收集器对比</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-5-11-2%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9><span class=nav-number>2.5.11.2.</span> <span class=nav-text>1.5.11.2、注意事项</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-6%E3%80%81%E6%BC%8F%E6%A0%87%E9%97%AE%E9%A2%98><span class=nav-number>2.6.</span> <span class=nav-text>1.6、漏标问题</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-9-1%E3%80%81%E8%AE%A4%E8%AF%86%E6%BC%8F%E6%A0%87><span class=nav-number>2.6.1.</span> <span class=nav-text>1.9.1、认识漏标</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-9-2%E3%80%81%E8%A7%A3%E5%86%B3%E6%BC%8F%E6%A0%87><span class=nav-number>2.6.2.</span> <span class=nav-text>1.9.2、解决漏标</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-9-3%E3%80%81%E6%80%BB%E7%BB%93><span class=nav-number>2.6.3.</span> <span class=nav-text>1.9.3、总结</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#2%E3%80%81JVM%E5%8F%82%E6%95%B0><span class=nav-number>3.</span> <span class=nav-text>2、JVM参数</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#2-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>3.1.</span> <span class=nav-text>2.1、简介</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-1%E3%80%81%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB><span class=nav-number>3.1.1.</span> <span class=nav-text>2.1.1、参数分类</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-2%E3%80%81%E6%9F%A5%E7%9C%8B%E5%8F%82%E6%95%B0%E5%80%BC><span class=nav-number>3.1.2.</span> <span class=nav-text>2.1.2、查看参数值</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-2%E3%80%81%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E5%8F%82%E6%95%B0><span class=nav-number>3.2.</span> <span class=nav-text>2.2、系统优化参数</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-3%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%82%E6%95%B0><span class=nav-number>3.3.</span> <span class=nav-text>2.3、类加载参数</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-4%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%8F%82%E6%95%B0><span class=nav-number>3.4.</span> <span class=nav-text>2.4、运行时数据区参数</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-1%E3%80%81%E5%A0%86%EF%BC%88Heap%EF%BC%89><span class=nav-number>3.4.1.</span> <span class=nav-text>2.4.1、堆（Heap）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%9F%BA%E6%9C%AC%E5%8F%82%E6%95%B0><span class=nav-number>3.4.1.1.</span> <span class=nav-text>基本参数</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%B9%B4%E8%BD%BB%E4%BB%A3><span class=nav-number>3.4.1.2.</span> <span class=nav-text>年轻代</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%80%81%E5%B9%B4%E4%BB%A3><span class=nav-number>3.4.1.3.</span> <span class=nav-text>老年代</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-2%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88MethodArea%EF%BC%89><span class=nav-number>3.4.2.</span> <span class=nav-text>2.4.2、方法区（MethodArea）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%B0%B8%E4%B9%85%E4%BB%A3%EF%BC%88JDK7%E5%8F%8A%E4%BB%A5%E5%89%8D%E7%89%88%E6%9C%AC%EF%BC%89><span class=nav-number>3.4.2.1.</span> <span class=nav-text>永久代（JDK7及以前版本）</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%88JDK8%E5%8F%8A%E4%BB%A5%E5%90%8E%E7%89%88%E6%9C%AC%EF%BC%89><span class=nav-number>3.4.2.2.</span> <span class=nav-text>元空间（JDK8及以后版本）</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-3%E3%80%81%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%88%EF%BC%88OperandStack%EF%BC%89><span class=nav-number>3.4.3.</span> <span class=nav-text>2.4.3、操作数栈（OperandStack）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-4%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%88LocalMethodStack%EF%BC%89><span class=nav-number>3.4.4.</span> <span class=nav-text>2.4.4、本地方法栈（LocalMethodStack）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-5%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88ProgramRegister%EF%BC%89><span class=nav-number>3.4.5.</span> <span class=nav-text>2.4.5、程序计数器（ProgramRegister）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-6%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%EF%BC%88DirectMemory%EF%BC%89><span class=nav-number>3.4.6.</span> <span class=nav-text>2.4.6、直接内存（DirectMemory）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-7%E3%80%81%E5%85%B6%E5%AE%83><span class=nav-number>3.4.7.</span> <span class=nav-text>2.4.7、其它</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-5%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%8F%82%E6%95%B0><span class=nav-number>3.5.</span> <span class=nav-text>2.5、垃圾回收参数</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-5-1%E3%80%81%E5%9F%BA%E6%9C%AC%E5%8F%82%E6%95%B0><span class=nav-number>3.5.1.</span> <span class=nav-text>2.5.1、基本参数</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-5-2%E3%80%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%8F%82%E6%95%B0><span class=nav-number>3.5.2.</span> <span class=nav-text>2.5.2、垃圾收集器参数</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%9F%BA%E6%9C%AC%E5%8F%82%E6%95%B0-1><span class=nav-number>3.5.2.1.</span> <span class=nav-text>基本参数</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Serial-Old%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0><span class=nav-number>3.5.2.2.</span> <span class=nav-text>Serial Old常用参数</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#Parallel%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0><span class=nav-number>3.5.2.3.</span> <span class=nav-text>Parallel常用参数</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#ParNew%E5%8F%82%E6%95%B0><span class=nav-number>3.5.2.4.</span> <span class=nav-text>ParNew参数</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#CMS%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0><span class=nav-number>3.5.2.5.</span> <span class=nav-text>CMS常用参数</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#G1%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0><span class=nav-number>3.5.2.6.</span> <span class=nav-text>G1常用参数</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%B8%B8%E8%A7%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%8F%82%E6%95%B0><span class=nav-number>3.5.2.7.</span> <span class=nav-text>常见垃圾回收器参数</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-5-3%E3%80%81GC%E6%97%A5%E5%BF%97%E5%8F%82%E6%95%B0><span class=nav-number>3.5.3.</span> <span class=nav-text>2.5.3、GC日志参数</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%9F%BA%E6%9C%AC%E5%8F%82%E6%95%B0-2><span class=nav-number>3.5.3.1.</span> <span class=nav-text>基本参数</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E5%8F%82%E6%95%B0><span class=nav-number>3.5.3.2.</span> <span class=nav-text>日志打印参数</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1><span class=nav-number>3.5.3.3.</span> <span class=nav-text>注意事项</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-6%E3%80%81Java%E9%94%81%E5%8F%82%E6%95%B0><span class=nav-number>3.6.</span> <span class=nav-text>2.6、Java锁参数</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-7%E3%80%81JVM%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93><span class=nav-number>3.7.</span> <span class=nav-text>2.7、JVM参数总结</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-7-1%E3%80%81GC%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0><span class=nav-number>3.7.1.</span> <span class=nav-text>2.7.1、GC常用参数</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-7-2%E3%80%81%E5%A0%86%E5%86%85%E5%AD%98%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE><span class=nav-number>3.7.2.</span> <span class=nav-text>2.7.2、堆内存常用配置</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8F%82%E8%80%831><span class=nav-number>3.7.2.1.</span> <span class=nav-text>参考1</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8F%82%E8%80%832><span class=nav-number>3.7.2.2.</span> <span class=nav-text>参考2</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%8F%82%E8%80%833><span class=nav-number>3.7.2.3.</span> <span class=nav-text>参考3</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-8-3%E3%80%81%E5%9B%9E%E6%94%B6%E5%99%A8%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE><span class=nav-number>3.7.3.</span> <span class=nav-text>2.8.3、回收器常用配置</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88><span class=nav-number>3.7.3.1.</span> <span class=nav-text>吞吐量优先</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88><span class=nav-number>3.7.3.2.</span> <span class=nav-text>响应时间优先</span></a></ol></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#3%E3%80%81JVM%E8%B0%83%E4%BC%98><span class=nav-number>4.</span> <span class=nav-text>3、JVM调优</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#3-1%E3%80%81%E8%B0%83%E4%BC%98%E9%A1%BB%E7%9F%A5><span class=nav-number>4.1.</span> <span class=nav-text>3.1、调优须知</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-1%E3%80%81%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5><span class=nav-number>4.1.1.</span> <span class=nav-text>3.1.1、重要概念</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-1-1-1%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F><span class=nav-number>4.1.1.1.</span> <span class=nav-text>3.1.1.1、内存泄漏</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-1-1-2%E3%80%81%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA><span class=nav-number>4.1.1.2.</span> <span class=nav-text>3.1.1.2、内存溢出</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-1-1-3%E3%80%81QPS><span class=nav-number>4.1.1.3.</span> <span class=nav-text>3.1.1.3、QPS</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-1-1-4%E3%80%81TPS><span class=nav-number>4.1.1.4.</span> <span class=nav-text>3.1.1.4、TPS</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-1-1-5%E3%80%81%E5%90%9E%E5%90%90%E9%87%8F><span class=nav-number>4.1.1.5.</span> <span class=nav-text>3.1.1.5、吞吐量</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-1-1-6%E3%80%81%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4><span class=nav-number>4.1.1.6.</span> <span class=nav-text>3.1.1.6、响应时间</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-1%E3%80%81%E8%B0%83%E4%BC%98%E7%9B%AE%E6%A0%87><span class=nav-number>4.1.2.</span> <span class=nav-text>3.1.1、调优目标</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-2%E3%80%81%E8%B0%83%E4%BC%98%E6%80%9D%E8%B7%AF><span class=nav-number>4.1.3.</span> <span class=nav-text>3.1.2、调优思路</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-1-2-1%E3%80%81%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90><span class=nav-number>4.1.3.1.</span> <span class=nav-text>3.1.2.1、思路分析</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-1-2-2%E3%80%81%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0><span class=nav-number>4.1.3.2.</span> <span class=nav-text>3.1.2.2、常用参数</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%97%A5%E5%BF%97%E5%8F%82%E6%95%B0><span class=nav-number>4.1.3.2.1.</span> <span class=nav-text>日志参数</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%85%B6%E5%AE%83%E5%91%BD%E4%BB%A4><span class=nav-number>4.1.3.2.2.</span> <span class=nav-text>其它命令</span></a></ol></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-2%E3%80%81GC%E6%97%A5%E5%BF%97><span class=nav-number>4.2.</span> <span class=nav-text>3.2、GC日志</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-7-1%E3%80%81%E5%87%86%E5%A4%87><span class=nav-number>4.2.1.</span> <span class=nav-text>3.7.1、准备</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-7-2%E3%80%81%E7%A4%BA%E4%BE%8B%E6%97%A5%E5%BF%971><span class=nav-number>4.2.2.</span> <span class=nav-text>3.7.2、示例日志1</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-7-3%E3%80%81%E7%A4%BA%E4%BE%8B%E6%97%A5%E5%BF%972><span class=nav-number>4.2.3.</span> <span class=nav-text>3.7.3、示例日志2</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-3%E3%80%81%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7><span class=nav-number>4.3.</span> <span class=nav-text>3.3、调优工具</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-5-1%E3%80%81Arthas><span class=nav-number>4.3.1.</span> <span class=nav-text>3.5.1、Arthas</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4><span class=nav-number>4.3.1.1.</span> <span class=nav-text>常用命令</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-5-2%E3%80%81VisualVM><span class=nav-number>4.3.2.</span> <span class=nav-text>3.5.2、VisualVM</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-5-3%E3%80%81Profiler><span class=nav-number>4.3.3.</span> <span class=nav-text>3.5.3、Profiler</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-5-4%E3%80%81GCEasy><span class=nav-number>4.3.4.</span> <span class=nav-text>3.5.4、GCEasy</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-5-5%E3%80%81GCViewer><span class=nav-number>4.3.5.</span> <span class=nav-text>3.5.5、GCViewer</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-4%E3%80%81%E8%B0%83%E4%BC%98%E5%BB%BA%E8%AE%AE><span class=nav-number>4.4.</span> <span class=nav-text>3.4、调优建议</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-4-1%E3%80%81%E9%80%89%E6%8B%A9%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8><span class=nav-number>4.4.1.</span> <span class=nav-text>3.4.1、选择垃圾回收器</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-4-2%E3%80%81%E6%96%B0%E7%94%9F%E4%BB%A3%E8%B0%83%E4%BC%98><span class=nav-number>4.4.2.</span> <span class=nav-text>3.4.2、新生代调优</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-4-2-1%E3%80%81%E6%A6%82%E8%BF%B0><span class=nav-number>4.4.2.1.</span> <span class=nav-text>3.4.2.1、概述</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-4-2-2%E3%80%81Survivor%E5%8C%BA><span class=nav-number>4.4.2.2.</span> <span class=nav-text>3.4.2.2、Survivor区</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-4-3%E3%80%81%E8%80%81%E5%B9%B4%E4%BB%A3%E8%B0%83%E4%BC%98><span class=nav-number>4.4.3.</span> <span class=nav-text>3.4.3、老年代调优</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-4-3-1%E3%80%81CMS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8><span class=nav-number>4.4.3.1.</span> <span class=nav-text>3.4.3.1、CMS垃圾回收器</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-5%E3%80%81%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B><span class=nav-number>4.5.</span> <span class=nav-text>3.5、调优案例</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-5-1%E3%80%81%E6%A1%88%E4%BE%8B%E4%B8%80><span class=nav-number>4.5.1.</span> <span class=nav-text>3.5.1、案例一</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81><span class=nav-number>4.5.1.1.</span> <span class=nav-text>案例代码</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%8E%92%E6%9F%A5%E8%BF%87%E7%A8%8B><span class=nav-number>4.5.1.2.</span> <span class=nav-text>排查过程</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-6%E3%80%81OOM%E9%97%AE%E9%A2%98%E6%A1%88%E4%BE%8B><span class=nav-number>4.6.</span> <span class=nav-text>3.6、OOM问题案例</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-6-1%E3%80%81%E5%A0%86%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA><span class=nav-number>4.6.1.</span> <span class=nav-text>3.6.1、堆内存溢出</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-6-2%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA><span class=nav-number>4.6.2.</span> <span class=nav-text>3.6.2、方法区内存溢出</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-6-3%E3%80%81%E6%A0%88%E6%BA%A2%E5%87%BA><span class=nav-number>4.6.3.</span> <span class=nav-text>3.6.3、栈溢出</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-6-4%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA><span class=nav-number>4.6.4.</span> <span class=nav-text>3.6.4、直接内存溢出</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-6-5%E3%80%81%E5%85%B6%E5%AE%83><span class=nav-number>4.6.5.</span> <span class=nav-text>3.6.5、其它</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-7%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E8%B0%83%E4%BC%98><span class=nav-number>4.7.</span> <span class=nav-text>3.7、垃圾回收器调优</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-7-1%E3%80%81G1%E8%B0%83%E4%BC%98><span class=nav-number>4.7.1.</span> <span class=nav-text>3.7.1、G1调优</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-8%E3%80%81%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96><span class=nav-number>4.8.</span> <span class=nav-text>3.8、场景分析优化</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-8-1%E3%80%81%E5%8D%A1%E6%85%A2%E5%9C%BA%E6%99%AF><span class=nav-number>4.8.1.</span> <span class=nav-text>3.8.1、卡慢场景</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-8-2%E3%80%81CPU%E6%B6%88%E8%80%97%E9%AB%98%E9%97%AE%E9%A2%98><span class=nav-number>4.8.2.</span> <span class=nav-text>3.8.2、CPU消耗高问题</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-8-3%E3%80%81%E5%86%85%E5%AD%98%E6%B6%88%E8%80%97%E9%AB%98%E9%97%AE%E9%A2%98><span class=nav-number>4.8.3.</span> <span class=nav-text>3.8.3、内存消耗高问题</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-8-4%E3%80%81%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7JVM><span class=nav-number>4.8.4.</span> <span class=nav-text>3.8.4、如何监控JVM</span></a></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>116</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>35</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>128</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://hshz21.gitee.io/2024/10/12/Java%E4%B9%8BJVM%E7%9F%A5%E8%AF%86%E7%AF%87/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="Java系列-JVM | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>Java系列-JVM</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-10-12 11:23:46" datetime=2024-10-12T11:23:46+08:00>2024-10-12</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2024-10-11 22:50:38" datetime=2024-10-11T22:50:38+08:00 itemprop=dateModified>2024-10-11</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/JVM/ itemprop=url rel=index><span itemprop=name>JVM</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=0、必知必会><a class=headerlink href=#0、必知必会 title=0、必知必会></a>0、必知必会</h1><h2 id=0-1、Java类加载><a class=headerlink href=#0-1、Java类加载 title=0.1、Java类加载></a>0.1、Java类加载</h2><h3 id=0-1-1、Class文件><a class=headerlink href=#0-1-1、Class文件 title=0.1.1、Class文件></a>0.1.1、Class文件</h3><h4 id=0-1-1-1、简介><a class=headerlink href=#0-1-1-1、简介 title=0.1.1.1、简介></a>0.1.1.1、简介</h4><p><strong>Class文件是一组以8位为单位的 二进制流，超过8位以上的会被按照 高位在前 分割成多个8位进行存储。</strong><p>Class文件格式采用一种类似C语言结构体的伪结构进行数据存储，其中包含两种数据类型，即 无符号数和表 。<ul><li><p><strong>无符号数</strong>：无符号数属于基本数据类型，以u1、u2、u4、u8分别代表1字节、2字节、4字节、8字节的无符号数。它可以描述数字、索引引用、数量值、utf8编码后的字符串值。</p><li><p><strong>表</strong>：<strong>表是由多个无符号数和其它表组成的复合数据类型</strong>。所有表都以<code>_info</code>结尾，用来描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。</p></ul><h4 id=0-1-1-2、class文件结构><a class=headerlink href=#0-1-1-2、class文件结构 title=0.1.1.2、class文件结构></a>0.1.1.2、class文件结构</h4><h5 id=简介><a class=headerlink href=#简介 title=简介></a>简介</h5><p><img alt=image-20210428110838690 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210428110838690.png><p>classFile结构中，各项含义如下：<ol><li>magic：魔数，4个字节。<li>minor_version/major_version：class文件次版本号/主版本号。<li>constant_pool_count：常量池计数器，2个字节（FFFF=65535）。<li>constant_pool[constant_pool_count-1]：常量池。<li>access_flags：访问标志。<li>this_class：类索引。<li>super_class：父类索引。<li>interfaces_count：接口计数器，2个字节（FFFF=65535）。<li>interfaces[interfaces_count]：接口表。<li>fields_count：字段计数器，2个字节（FFFF=65535）。<li>fields[fields_count]：字段表。<li>methods_count：方法计数器，2个字节（FFFF=65535）。<li>methods[methods_count]：方法表。<li>attributes_count：属性计数器，2个字节（FFFF=65535）。<li>attributes[attributes_count]：属性表。</ol><h5 id=魔数><a class=headerlink href=#魔数 title=魔数></a>魔数</h5><p><strong>无法通过文件扩展名来确定文件类型</strong>，文件扩展名可以随意修改，不影响其中的内容。一些软件或工具通常是根据文件的头几个字节（文件头）来检验文件类型，如果类型不支持，就会给出错误提示。<p>**Java字节码文件的文件头，也就是魔数的具体内容为<code>CAFEBABE</code>**，虚拟机进行加载时会对之进行检测判断，不满足时会直接报错。<p>除了Java文件外，其它常见的文件及对应文件头内容如下：<ul><li>XML：文件头大小5个字节，内容<code>3C3F786D6C</code>。<li>AVI：文件头大小4个字节，内容<code>41564920</code>。<li>PNG：文件头大小4个字节，内容为<code>89504E47</code>，且文件尾部也有要求。<li>JPEG：文件头大小3个字节，内容为<code>FFD8FF</code>。<li>BMP：文件头大小2个字节，内容<code>424D</code>。</ul><h5 id=主次版本号><a class=headerlink href=#主次版本号 title=主次版本号></a>主次版本号</h5><p>主次版本号指的是编译字节码文件的JDK版本号，主版本号用来标识大版本号，JDK1.0-1.1使用了45.0-45.3，JDK1.2是46，之后每升级一个大版本就加1。次版本号是当主版本相同时用来区分不同的版本，一般只需关注主版本号。<blockquote><p>JDK1.2之后JDK大版本号的计算方法为<code>主版本号-44</code>。比如主版本号为52，则表示的是JDK8</blockquote><p><strong>版本号的作用主要是判断当前字节码的版本和运行时的JDK是否兼容</strong>。<h5 id=常量池><a class=headerlink href=#常量池 title=常量池></a>常量池</h5><p><strong>常量池的作用为：避免相同的内容重复定义，节省空间</strong>。<p>常量池中的数据都有一个编号，编号从1开始。在字段或字节码指令中通过编号可以快速找到对应的数据。字节码指令中，通过编号引用到常量池的过程称之为符号引用。<h5 id=方法><a class=headerlink href=#方法 title=方法></a>方法</h5><p>字节码中的方法区域是存放字节码指令的核心位置，字节码指令的内容存放在方法的Code属性中。<h3 id=0-1-2、类加载过程><a class=headerlink href=#0-1-2、类加载过程 title=0.1.2、类加载过程></a>0.1.2、类加载过程</h3><h4 id=0-1-2-1、概述><a class=headerlink href=#0-1-2-1、概述 title=0.1.2.1、概述></a>0.1.2.1、概述</h4><p>虚拟机 把 描述类的数据 从Class文件加载到内存，并对数据进行校验、转化解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<p>整个生命周期包括：<strong>加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸载(Unloading)7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）</strong>。<p>加载分为两类：<ul><li><strong>显式加载</strong>：通过类加载器加载一个类。<li><strong>隐式加载</strong>：不直接使用类加载器加载类，而是虚拟机自动加载完成。</ul><blockquote><p>加载后，类的一些信息可通过工具HSDB来查看。<p>HSDB启动命令：<code>java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB</code></blockquote><h4 id=0-1-2-2、加载阶段><a class=headerlink href=#0-1-2-2、加载阶段 title=0.1.2.2、加载阶段></a>0.1.2.2、加载阶段</h4><p>此阶段虚拟机会做三件事：<ol><li>通过一个<strong>类的全限定名</strong>来<strong>获取</strong>定义此<strong>类的二进制字节流</strong>；<li>将这个字节流所代表的<strong>静态存储结构</strong>转为方法区的<strong>运行时数据结构</strong>；<li>在内存中<strong>生成</strong>一个代表该类的 <strong>java.lang.Class对象</strong>，<strong>作为</strong>方法区中<strong>该类各种数据的访问入口</strong>；</ol><p>获取二进制字节流可以通过Class文件、ZIP包、网络、运行时（动态代理）、JSP生成、数据库等途径获取。<p>那些二进制字节流加载完后，按指定格式存放于方法区内（Java7及以前方法区实现为永久代，Java8实现为Metaspace（元空间））。然后在方法区生成一个比较特殊的<code>java.lang.Class</code>对象，用来作为 访问方法区中这些类型数据的 外部接口。<p><font color=red>注意：数组类不通过类加载器加载，而是由Java虚拟机直接创建，但数组类的元素还是要依靠类加载器进行加载。</font><h4 id=0-1-2-3、链接阶段><a class=headerlink href=#0-1-2-3、链接阶段 title=0.1.2.3、链接阶段></a>0.1.2.3、链接阶段</h4><h5 id=验证阶段><a class=headerlink href=#验证阶段 title=验证阶段></a>验证阶段</h5><p>验证的目的是确保Class文件字节流中的<strong>信息符合当前虚拟机的要求</strong>，且<strong>不会危害虚拟机</strong>自身的安全。<p>验证内容如下：<ol><li>文件格式验证<li>元数据验证<li>字节码验证<li>符号引用验证</ol><h5 id=准备阶段><a class=headerlink href=#准备阶段 title=准备阶段></a>准备阶段</h5><p>准备阶段主要工作：在方法区中<strong>为类变量分配内存、设置默认值</strong>。<p>类变量指的是被static修饰的变量，不包含实例变量，实例变量在对象实例化阶段分配在堆中。并且，变量的初始化值并非是类中定义的值，而是该变量所属类型的默认值。<p><font color=red>注意：变量被final修饰时，该字段属性为ConstantValue，它会在 准备阶段 初始化为指定的值。</font><h5 id=解析阶段><a class=headerlink href=#解析阶段 title=解析阶段></a>解析阶段</h5><p>解析阶段主要工作：虚拟机将常量池内的 <strong>符号引用替换为直接引用</strong>。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用 进行解析。<h4 id=0-1-2-4、初始化阶段><a class=headerlink href=#0-1-2-4、初始化阶段 title=0.1.2.4、初始化阶段></a>0.1.2.4、初始化阶段</h4><p>初始化阶段主要工作：<strong>执行类构造器的<code>clinit()</code>方法</strong>。<p><code>&LTclinit>()</code>方法是由编译器自动<strong>收集类中所有类变量的赋值动作和静态语句块中的语句</strong>合并而成。编译器收集的顺序由语句在源文件中出现的顺序决定，静态语句块中只能访问其之前的变量，之后的变量只能赋值但不能访问。<p><font color=red>注意：<code>&LTclinit>()</code>方法 与 实例构造器() 不同，其不需要 显式调用 父类构造器，虚拟机会保证在子类的clinit()方法执行之前，父类的clinit()方法已经执行完毕。虚拟机会保证一个类的clinit()方法在多线程下被同步加锁。</font><p>会导致类初始化的几种情况如下：<ul><li>调用一个类的静态变量或静态方法，<strong>但若变量被final修饰且值是常量时则不会触发初始化</strong>。<li>调用Class.forName(String className);<li>new一个类的对象。<li>执行main方法触发当前类的初始化。</ul><p>不会执行初始化指令的情况如下：<ul><li>无静态代码块，且无静态变量赋值语句。<li>存在没有赋值的静态变量。<li>静态变量被final修饰。<li>创建一个类数组对象时，类也不会初始化。</ul><p><strong>对于存在父类的情况，直接访问父类的静态变量，不会触发子类的初始化。但子类初始化clinit调用前，会先调用父类的clinit初始化方法</strong>。<h4 id=0-1-2-5、使用和卸载阶段><a class=headerlink href=#0-1-2-5、使用和卸载阶段 title=0.1.2.5、使用和卸载阶段></a>0.1.2.5、使用和卸载阶段</h4><p>类被加载并初始化后就是一个可以被使用的完整类。当类不再被使用时，或虚拟机关闭时会类进行卸载。<h3 id=0-1-3、类加载器><a class=headerlink href=#0-1-3、类加载器 title=0.1.3、类加载器></a>0.1.3、类加载器</h3><h4 id=0-1-3-1、简介><a class=headerlink href=#0-1-3-1、简介 title=0.1.3.1、简介></a>0.1.3.1、简介</h4><p><strong>通过 类的全限定名 获取该类二进制字节流的代码块叫 类加载器</strong>。<h4 id=0-1-3-2、类加载器分类><a class=headerlink href=#0-1-3-2、类加载器分类 title=0.1.3.2、类加载器分类></a>0.1.3.2、类加载器分类</h4><p><strong>JVM规范中规定，将派生于抽象类<code>ClassLoader</code>的类加载器都称为 自定义类加载器</strong>。<p>实际开发中，通常会将类加载器分为如下几种：<p><strong>（1）启动类加载器（Bootstrap ClassLoader）</strong><p>使用C/C++语言实现，并不继承java.lang.ClassLoader。为安全起见，主要负责加载Java核心类库，比如：<code>%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar</code>和class等。<p><strong>（2）扩展类加载器（Extensions ClassLoader）</strong><p>使用Java语言实现，派生于抽象类ClassLoader，父类是启动类加载器。<p>主要负责加载<code>%JRE_HOME%\lib\ext</code>目录下的jar包和class文件。<p>使用参数<code>-Djava.ext.dirs=jar包路径</code>可为扩展类加载器添加额外的jar包加载路径。多个路径使用分号<code>;</code>进行分割，若是mac或linux系统则使用冒号<code>:</code>进行分割。<p><strong>（3）应用程序/系统类加载器（App ClassLoader）</strong><p>使用Java语言实现，派生于抽象类ClassLoader，父类是扩展类加载器。<p>加载 CLASSPATH 或 java.class.path 指定路径下的类库。<p><strong>（4）自定义类加载器（Custom ClassLoader）</strong><p>自定义类加载器<strong>可以扩展加载源、修改类加载方式，隔离加载类、防止源码泄露等</strong>。JDK1.2之前，实现自定义类加载需要继承抽象类ClassLoader并重写loadClass方法，而<strong>JDK1.2之后建议重写findClass方法来代替重写loadClass方法</strong>。<p>若无特别需求，则建议直接继承URLClassLoader类，可避免编写findClass方法及获取字节流的方式。<p><font color=red>注意：这些类加载器之间是包含（复合）关系，而并非是继承关系。</font><h4 id=0-1-3-3、常用命令><a class=headerlink href=#0-1-3-3、常用命令 title=0.1.3.3、常用命令></a>0.1.3.3、常用命令</h4><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -Xbootclasspath/a:. cn.shh.xxx.Test bootstrap F init</span><br></pre></table></figure><ul><li><code>Xbootclasspath</code>：表示设置bootclasspath。<li><code>/a</code>：表示将当前目录追加至bootclass之后。</ul><p>常用命令：<ul><li><code>java -Xbootclasspath:&LTnew bootclasspath></code><li><code>java -Xbootclasspath/a:<追加路径></code><li><code>java -Xbootclasspath/p:<追加路径></code></ul><h4 id=0-1-3-4、JDK9新变化><a class=headerlink href=#0-1-3-4、JDK9新变化 title=0.1.3.4、JDK9新变化></a>0.1.3.4、JDK9新变化</h4><p><strong>JDK9引入了模块化概念</strong>。<p>启动类加载器使用Java编写，位于jdk.internal.loader.ClassLoaders类中，且依然无法获取到。BootClassLoader继承自BuiltinClassLoader，实现从模块中找到需要加载的字节码文件。<p><strong>扩展类加载器被替换成了平台类加载器</strong>。平台类加载器遵循模块化方式加载字节码文件，平台类加载的出现主要为了兼容老版本设计方案，自身没有特殊的逻辑。<h3 id=0-1-4、双亲委派模型><a class=headerlink href=#0-1-4、双亲委派模型 title=0.1.4、双亲委派模型></a>0.1.4、双亲委派模型</h3><h4 id=0-1-4-1、简介><a class=headerlink href=#0-1-4-1、简介 title=0.1.4.1、简介></a>0.1.4.1、简介</h4><p><img alt=image-20201224173439957 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20201224173439957.png><p>上图所示，<strong>类加载器间的关系就称为 类加载器的双亲委派模型（Parents Delegation Mode）。</strong><p><strong>类加载器的双亲委派模型在 JDK 1.2 期间被引入。</strong>它并不是一个强制性约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。<p><strong>双亲委派是指：一个类加载器收到了类加载请求时会先请求自己的父加载器去加载，如果父加载器无法加载该类，那么才会交给当前类加载器来加载。</strong><p>双亲委派机制有如下几个特点：<ol><li>Java类随它的类加载器一起具备了一种带有优先级的层次关系。<li>保证Java程序的稳定运行。<li>避免类被重复加载。<li>保证了安全。</ol><h4 id=0-1-4-2、重要方法><a class=headerlink href=#0-1-4-2、重要方法 title=0.1.4.2、重要方法></a>0.1.4.2、重要方法</h4><ul><li>loadClass()：类加载的主要方法。双亲委派机制的体现就是该方法。<li>findClass()：根据名称或位置加载.class字节码。<li>definclass()：把字节码转化为Class。</ul><p><font color=red>注意：自定义类加载器需要破坏双亲委派原则时就重写loadClass方法。如果只想自定义类加载器不想破坏双亲委派模型，那就继承ClassLoader并重写findClass方法。</font><p><code>findClass()</code>方法是JDK1.2之后 ClassLoader 新添加的一个方法。<blockquote><p>JDK1.2 后不提倡覆盖loadClass()方法，而建议把自己的逻辑写到<code>findClass()</code>方法中。因为<code>loadClass()</code>方法无法完成类加载逻辑时最终还是会调用<code>findClass()</code>方法来完成加载。</blockquote><h4 id=0-1-4-3、实现原理><a class=headerlink href=#0-1-4-3、实现原理 title=0.1.4.3、实现原理></a>0.1.4.3、实现原理</h4><p><strong>双亲委派模型的实现代码体现在抽象类<code>java.lang.ClassLoader</code>的<code>loadClass()</code>方法中。</strong>逻辑如下：<ol><li>先检查一个类是否被加载过，若没有被加载，则调用父加载器的 loadClass() 方法进行加载。<li>若父加载器为空，则默认使用启动类加载器作为父加载器。<li>如果父加载器加载失败，抛出 ClassNotFoundException 异常后，再调用自己的 findClass() 方法进行加载。</ol><h4 id=0-1-4-4、破坏双亲模型><a class=headerlink href=#0-1-4-4、破坏双亲模型 title=0.1.4.4、破坏双亲模型></a>0.1.4.4、破坏双亲模型</h4><p>打破双亲委派的方法如下：<ul><li>自定义类加载器，重写loadClass方法。<li>使用线程上下文类加载器。<li>使用Osgi框架类加载器。</ul><p>到目前为止，双亲委派模型出现过几次较大规模的破坏情况：<ol><li>由于 JDK 1.2 才发布双亲委派模型，类加载器和抽象类 ClassLoader 则在 JDK 1.0 时代就已经存在，为了兼容已经存在的自定义类加载器实现，JDK 1.2之后添加了一个新的 protected方法 findClass() 。JDK 1.2之后已不在提倡覆盖 loadClass() 方法，而应当把自己的类加载逻辑写入 findClass() 方法中，在 loadClass() 中如果父类加载失败，则会调用自己的 findClass() 方法来完成加载。<li><strong>基础类之所以称为“基础类”，是因为它们会作为API来被用户代码调用，但是，如果基础类反过来需要调用用户代码时，该怎么办？于是线程上下文类加载器就出现了。</strong>有了线程上下文类加载器，JNDI服务可以去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为打破了双亲委派模型的层次结构来逆向使用类加载器，这实际上违背了双亲委派模型的一般性原则。<li>第三次破坏是由于 <strong>用户对程序动态性的追求而导致，动态性是指：代码热替换、模块热部署等</strong>。比如 OSGI 中的类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更复杂的网状结构。<li>Tomcat等web容器的出现。<li>OSGI、Jigsaw等模块化技术的应用。</ol><h4 id=0-1-4-5、JNDI-JDBC破坏双亲委派><a class=headerlink href=#0-1-4-5、JNDI-JDBC破坏双亲委派 title=0.1.4.5、JNDI/JDBC破坏双亲委派></a>0.1.4.5、JNDI/JDBC破坏双亲委派</h4><p><strong>Java的基础类会被Bootstrap加载，且会通过API方式调用这些基础类。但是，除了API方式调用，还有一种SPI方式调用，如JDBC服务。</strong><p>创建数据库连接的方式如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>Connection</span> <span class=variable>conn</span> <span class=operator>=</span> DriverManager.getConnection(<span class=string>"jdbc:mysql://localhost:3306/mysql"</span>, <span class=string>"root"</span>, <span class=string>"1234"</span>);</span><br></pre></table></figure><p><code>java.sql.DriverManager</code>类位于rt.jar中 ，故会被根加载器加载。类加载时，会执行该类的静态方法。其中有一段关键代码是：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>ServiceLoader&LTDriver> loadedDrivers = ServiceLoader.load(Driver.class);</span><br></pre></table></figure><p>这段代码，会尝试加载classpath下实现了Driver接口的所有实现类。<p>那么，问题就来了。<p><strong>DriverManager会被根加载器加载，但在加载时遇到以上代码，会尝试加载Driver的所有实现类，但这些实现类基本都是第三方提供，根据双亲委派原则，第三方的类不能被根加载器加载。</strong><p>那么，怎么解决这个问题呢？<p><strong>在JDBC中引入ThreadContextClassLoader（线程上下文加载器，默认情况下是AppClassLoader）来破坏双亲委派原则。</strong><p>我们深入到<code>ServiceLoader.load</code>方法就可以看到：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> &LTS> ServiceLoader&LTS> <span class="title function_">load</span><span class=params>(Class&LTS> service)</span> {</span><br><span class=line>    <span class=type>ClassLoader</span> <span class=variable>cl</span> <span class=operator>=</span> Thread.currentThread().getContextClassLoader();</span><br><span class=line>    <span class=keyword>return</span> ServiceLoader.load(service, cl);</span><br><span class=line>}</span><br></pre></table></figure><p>第一行，获取当前线程的线程上下⽂类加载器 AppClassLoader，⽤于加载 classpath 下的具体实现类。<h4 id=0-1-4-6、Tomcat破坏双亲委派><a class=headerlink href=#0-1-4-6、Tomcat破坏双亲委派 title=0.1.4.6、Tomcat破坏双亲委派></a>0.1.4.6、Tomcat破坏双亲委派</h4><h5 id=简介-1><a class=headerlink href=#简介-1 title=简介></a>简介</h5><p>Tomcat中可能会部署多个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，如果采用默认的双亲委派类加载机制，那么无法加载多个相同类。所以，Tomcat破坏双亲委派原则，提供隔离的机制，为web容器中每一个应用单独提供一个WebAppClassLoader加载器。<p><strong>Tomcat类加载机制：为了实现隔离性，优先加载 Web 应用自己定义的类，所以没有遵照双亲委派约定，每一个WebAppClassLoader负责加载自己目录下的class文件，加载不到时再交给CommonClassLoader加载，这和双亲委派刚好相反。</strong><h5 id=tomcat中的类加载器><a class=headerlink href=#tomcat中的类加载器 title=tomcat中的类加载器></a>tomcat中的类加载器</h5><p><strong>Tomcat实现了一套自己的类加载器。顶层类加载为Common类加载器，其有两个子类加载器Catalina类加载器和Shared类加载器</strong>。Shared类加载器下有多个ParallelWebappClassLoader类加载器，因为每个Web应用会单独使用一个。ParallelWebappClassLoader类加载器下会有多个JasperLoader类加载器，因为每次加载jsp文件都会使用一个，这样一来，也就实现了热部署。<h4 id=0-1-4-7、总结><a class=headerlink href=#0-1-4-7、总结 title=0.1.4.7、总结></a>0.1.4.7、总结</h4><h5 id=父子加载器之间是继承关系吗？><a class=headerlink href=#父子加载器之间是继承关系吗？ title=父子加载器之间是继承关系吗？></a>父子加载器之间是继承关系吗？</h5><p><strong>双亲委派模型中，类加载器之间的关系一般不会以继承（Inheritance）的关系来实现，而是使用组合（Composition）关系来复用父加载器代码。</strong><p>如下为ClassLoader中父加载器的定义：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">ClassLoader</span> {</span><br><span class=line>    <span class=comment>// The parent class loader for delegation</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> ClassLoader parent;</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>Java中继承和组合的区别是什么？<ol><li>组合(has-a)关系可以<strong>显式获得被包含类（继承中称为父类）对象</strong>，而继承(is-a)则是<strong>隐式获得父类对象</strong>，被包含类和父类对应，而组合外部类和子类对应。<li>组合关系在<strong>运行期决定</strong>，而继承关系在<strong>编译期决定</strong>。<li>组合是组合类和被包含类之间的一种<strong>松耦合关系</strong>，而继承则是父类和子类之间的一种<strong>紧耦合关系</strong>。<li>组合类中包含了外部类的对象，组合类<strong>可以选择性调用外部类方法</strong>；而使用继承关系时，父类的所有方法和变量都被子类<strong>无条件继承，子类不能选择</strong>。<li>继承可以实现类型回溯，即用父类变量引用子类对象，这样便可以实现多态，而组合没有这个特性。<li>如果你确定复用另外一个类的方法永远不需要改变时，应该使用组合，因为组合只是<strong>简单复用被包含类的接口</strong>，而继承除了复用父类接口外，它还可以<strong>覆盖这些接口</strong>，修改父类接口的默认实现，这个特性是组合没有的。<li>组合体现的是整体和部分的思想，例如电脑类是由内存类，CPU类，硬盘类等组成，而继承则体现的是一种可回溯的父子关系，子类也是父类的一个对象。<li><strong>两者区别主要体现在类的抽象阶段</strong>，在分析类之间的关系时就应该确定是采用组合还是采用继承。</ol></blockquote><h2 id=0-2、JVM运行时数据区><a class=headerlink href=#0-2、JVM运行时数据区 title=0.2、JVM运行时数据区></a>0.2、JVM运行时数据区</h2><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/2.1.1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%89%8D%E8%A8%80-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86.png><h3 id=0-1-1、程序计数器（私有）><a class=headerlink href=#0-1-1、程序计数器（私有） title=0.1.1、程序计数器（私有）></a>0.1.1、程序计数器（私有）</h3><h4 id=0-1-1-1、简介-1><a class=headerlink href=#0-1-1-1、简介-1 title=0.1.1.1、简介></a>0.1.1.1、简介</h4><p>JVM的程序计数寄存器，是物理PC寄存器的一种抽象模拟。<p>程序计数器主要<strong>存储要执行的程序指令的地址信息</strong>，确保程序正确执行。<h4 id=0-1-1-2、作用><a class=headerlink href=#0-1-1-2、作用 title=0.1.1.2、作用></a>0.1.1.2、作用</h4><p>PC寄存器用来<strong>存储指向下一条指令的地址</strong>，也即将要执行的指令代码的地址。由执行引擎读取下一条指令。<h3 id=0-1-2、方法区（公有）><a class=headerlink href=#0-1-2、方法区（公有） title=0.1.2、方法区（公有）></a>0.1.2、方法区（公有）</h3><h4 id=0-1-2-1、简介><a class=headerlink href=#0-1-2-1、简介 title=0.1.2.1、简介></a>0.1.2.1、简介</h4><p>方法区主要存储：<strong>类型信息、运行时常量池、静态变量、JIT代码缓存、域信息、方法信息</strong>等。<p>类型信息包括：类class、接口interface、枚举enum、注解annotation。<p>域信息包括：域名称、域类型、域修饰符。即：public、private、protected、static、final、volatile、transient的某个子集。<p>方法信息包括：方法修饰符、方法返回类型、方法名称、方法参数的数量和类型、方法字节码、操作数栈、局部变量表及大小（abstract和native方法除外）、异常表（abstract和native方法除外）。<p><font color=red>注意事项：方法区内存不足时会导致内存溢出错误。</font><p>方法区内存溢出的场景：Spring、MyBatis。<h4 id=0-1-2-2、实现><a class=headerlink href=#0-1-2-2、实现 title=0.1.2.2、实现></a>0.1.2.2、实现</h4><p><strong>永久代PermSpace（JDK7）</strong><ol><li>JDK7及以前，方法区实现是永久代。<li>JDK7以前，静态变量存放在永久代上。JDK7开始，<strong>字符串常量池、静态变量保存在堆中</strong>。<li>FGC不会清理永久代。<li>-XX:PermSize默认值为20.75M，<code>-XX:MaxPermSize</code>默认值在32位下是64M，64位下是82M。</ol><p><strong>元空间MetaSpace（JDK8）</strong><ol><li>JDK8中方法区实现是元空间，使用物理内存。<li>类型信息、字段、方法、常量保存在元空间中，<strong>字符串常量池、静态变量仍保存在堆中</strong>。<li>FGC会清理元空间。<li>windows下，<code>-XX:MetaspaceSize</code>是21M，<code>-XX:MaxMetaspaceSize</code>的值是-1，表示没有限制。</ol><p><strong>注意事项</strong>：虽然元空间大小的最大上限默认为系统内存的大小，但仍然建议手动设定一个满足需求的固定值大小。<h4 id=0-1-2-3、方法区演变><a class=headerlink href=#0-1-2-3、方法区演变 title=0.1.2.3、方法区演变></a>0.1.2.3、方法区演变</h4><p><strong>首先明确：只有HotSpot才有永久代一说。</strong>bea jrockit、ibm j9等是不存在永久代的概念。原则上如何实现方法区属于虚拟机实现细节，不受jvm规范管束，并不要求统一。<p>Hotspot中方法区的变化如下：<ol><li><strong>JDK1.6及之前</strong>：有永久代，静态变量保存在永久代中。<li><strong>JDK1.7</strong>：有永久代，但已经逐步“去永久代”，字符串常量池、静态变量保存在堆中。<li><strong>JDK1.8及之后</strong>：无永久代，类型信息、字段、方法、常量保存在元空间中，但字符串常量池、静态变量仍然保存在堆中。</ol><h4 id=0-1-2-4、运行时常量池><a class=headerlink href=#0-1-2-4、运行时常量池 title=0.1.2.4、运行时常量池></a>0.1.2.4、运行时常量池</h4><h5 id=常量池-1><a class=headerlink href=#常量池-1 title=常量池></a>常量池</h5><p>常量池是Class文件的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将会在类被加载后放到方法区的运行时常量池中。<h5 id=运行时常量池><a class=headerlink href=#运行时常量池 title=运行时常量池></a>运行时常量池</h5><p><strong>加载 类或接口 到虚拟机后就会创建对应的运行时常量池</strong>。<p>运行时常量池是方法区的一部分。运行时常量池 是 常量池表的运行时表示形式，它包含多种常量，从编译期可知的<strong>数字字面量</strong>到必须运行且解析后才能获得的<strong>方法或字段引用</strong>。（类似于符号表，但比符号表要更广泛。）<h3 id=0-1-3、虚拟机栈（私有）><a class=headerlink href=#0-1-3、虚拟机栈（私有） title=0.1.3、虚拟机栈（私有）></a>0.1.3、虚拟机栈（私有）</h3><h4 id=0-1-3-1、简介-1><a class=headerlink href=#0-1-3-1、简介-1 title=0.1.3.1、简介></a>0.1.3.1、简介</h4><p><strong>每个线程都有自己的栈，栈中的数据都是以 栈帧 的格式存在。</strong>每个线程在执行一个方法时会在栈中建立一个栈帧。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种信息。<p>虚拟机栈的默认大小在不同的系统中也不同，详情如下：<p>JDK8环境下：<ul><li>Linux/ARM (32-bit): 320 KB<li>Linux/i386 (32-bit): 320 KB<li>Linux/x64 (64-bit): 1024 KB<li>macOS (64-bit): 1024 KB<li>Oracle Solaris/i386 (32-bit): 320 KB<li>Oracle Solaris/x64 (64-bit): 1024 KB<li>Windows: 默认值取决于虚拟内存。</ul><p>JDK21环境下：<ul><li>Linux/x64: 1024 KB<li>Linux/Aarch64: 2048 KB<li>macOS/x64: 1024 KB<li>macOS/Aarch64: 2048 KB<li>Windows: 默认值取决于虚拟内存。</ul><p><strong>若默认大小不满足需求，可以通过参数<code>-Xss大小</code>来自定义设置大小。单位可以为字节、K、MB、G</strong>。但要注意的是，设置的大小也需要满足JVM规范要求。<strong>windows 64位系统环境下，JDK8要求最小值为180K，最大值为1024M</strong>。<p><font color=red>注意事项：虚拟机栈内存不足时会导致内存溢出错误。</font><h4 id=0-1-3-2、内部结构><a class=headerlink href=#0-1-3-2、内部结构 title=0.1.3.2、内部结构></a>0.1.3.2、内部结构</h4><p>Java虚拟机中主要存储的是栈帧，而栈帧由以下几部分组成：<ul><li><strong>局部变量表</strong><li><strong>操作数栈</strong><li><strong>动态链接</strong><li><strong>方法出口</strong><li><strong>一些附加信息</strong></ul><h4 id=0-1-3-3、其它><a class=headerlink href=#0-1-3-3、其它 title=0.1.3.3、其它></a>0.1.3.3、其它</h4><p>问题分析：<ul><li>栈内存越大越好吗？非也。<li>垃圾回收是否涉及栈内存？不会涉及。<li>方法中的局部变量是否是线程安全的？若没有发生逃逸，则是线程安全的。</ul><h3 id=0-1-4、本地方法栈（私有）><a class=headerlink href=#0-1-4、本地方法栈（私有） title=0.1.4、本地方法栈（私有）></a>0.1.4、本地方法栈（私有）</h3><h4 id=0-1-4-1、简介-1><a class=headerlink href=#0-1-4-1、简介-1 title=0.1.4.1、简介></a>0.1.4.1、简介</h4><p><strong>本地方法栈使用C语言实现，线程私有，主要服务于本地方法的调用。</strong><p><strong>Hotspot虚拟机中，本地方法栈和Java虚拟机栈实现上使用了同一个空间</strong>。本地方法栈会在栈内存中生成一个栈帧，临时保存方法参数的同时方便出现异常时把本地方法栈信息打印出来。<p>本地方法栈中存储本地方法，执行引擎工作时会加载本地方法库。<p><font color=red>注意事项：本地方法栈内存不足时会导致内存溢出错误。</font><h4 id=0-1-4-2、注意事项><a class=headerlink href=#0-1-4-2、注意事项 title=0.1.4.2、注意事项></a>0.1.4.2、注意事项</h4><ul><li>可以通过本地方法接口来访问虚拟机内部的运行时数据区。<li>直接使用本地处理器中的寄存器。<li>直接从本地内存的堆中分配任意内存。<li>并非所有JVM都支持本地方法，JVM规范并没有要求本地方法栈使用的语言、具体实现方式、数据结构等，也可以选择不实现本地方法栈。<li>Hotspot中直接将本地方法栈和虚拟机栈合二为一。</ul><h3 id=0-1-5、堆（公有）><a class=headerlink href=#0-1-5、堆（公有） title=0.1.5、堆（公有）></a>0.1.5、堆（公有）</h3><h4 id=0-1-5-1、简介><a class=headerlink href=#0-1-5-1、简介 title=0.1.5.1、简介></a>0.1.5.1、简介</h4><p><strong>堆是各个线程共有的区域，该区域主要存储加载创建对象过程中生成的对象数据。</strong><p><font color=red>注意事项：堆空间不足时会导致内存溢出错误。</font><h4 id=0-1-5-2、分代模型><a class=headerlink href=#0-1-5-2、分代模型 title=0.1.5.2、分代模型></a>0.1.5.2、分代模型</h4><p>逻辑上将堆分为以下几个部分：<ul><li>年轻代<ul><li>Eden区<li>Surivor from区<li>Surivor to区</ul><li>老年代<li>永久代/元空间（JDK7及之前是永久代，之后是元空间）</ul><h4 id=0-1-5-3、空间大小><a class=headerlink href=#0-1-5-3、空间大小 title=0.1.5.3、空间大小></a>0.1.5.3、空间大小</h4><h5 id=堆大小><a class=headerlink href=#堆大小 title=堆大小></a>堆大小</h5><p>可以通过Xms、Xmx来设置堆内存初始内存和最大内存，堆大小在JVM启动时已经设定好了。<p>默认情况下：初始内存大小为物理内存/64，最大内存为物理内存的1/4。<p><font color=red>注意事项：堆内存大小超过最大内存限制时会抛出OOM异常。</font><h5 id=新生代老年代><a class=headerlink href=#新生代老年代 title=新生代老年代></a>新生代老年代</h5><p>使用参数<code>-Xmn</code>可以设置新生代的空间大小。<p>默认参数<code>-XX:NewRatio=2</code>表示新生代占比1，老年代占比2，也即，新生代占整个堆内存的1/3。同理<code>-XX:NewRatio=4</code>表示新生代占比1，老年代占比4，新生代占整个堆内存的1/5。<p><font color=red>注意事项：参数<code>-XX:NewRatio=2</code>的实际效果会受参数<code>-XX:+/-UseAdaptiveSizePolicy</code>的影响，后者参数表示 开启或关闭自适应内存分配策略。</font>如果想要达到指定的具体效果，需要使用参数<code>-XX:SurvivorRatio</code>来设置，该参数表示新生代中Eden区与Survivor区的比例。<h3 id=0-1-6、直接内存><a class=headerlink href=#0-1-6、直接内存 title=0.1.6、直接内存></a>0.1.6、直接内存</h3><p><strong>直接内存在堆外，不会受限于-Xmx设置的最大堆大小。</strong>但系统内存也是有限的，Java堆和直接内存的总和依然受限于操作系统能提供的最大内存。<p>直接内存有如下缺点：<ul><li>分配回收成本较高。<li>不受JVM内存回收管理。</ul><p><strong>直接内存大小可以通过参数<code>-XX:MaxDirectMemorySize=size</code>来设置，如果不指定，则默认与堆的最大值-Xmx参数值一致。</strong>默认情况下，大小设置为 0，这意味着 JVM 会自动选择 NIO 直接缓冲区分配的大小。<h3 id=0-1-7、字符串常量池><a class=headerlink href=#0-1-7、字符串常量池 title=0.1.7、字符串常量池></a>0.1.7、字符串常量池</h3><h4 id=0-1-7-1、简介><a class=headerlink href=#0-1-7-1、简介 title=0.1.7.1、简介></a>0.1.7.1、简介</h4><p><strong>String Pool是一个固定大小的Hashtable，默认大小为1009。</strong>如果String Pool中字符串太多，会造成链表过长，进而导致在调用String的intern方法时性能会大幅下降。<p><strong>JDK6及以前版本，字符串常量池在方法区中，JDK7及之后版本，字符串常量池转移到堆中。</strong><h4 id=0-1-7-2、参数设置><a class=headerlink href=#0-1-7-2、参数设置 title=0.1.7.2、参数设置></a>0.1.7.2、参数设置</h4><p>使用参数<code>-XX:StringTableSize</code>可设置StringTable的长度。<blockquote><p>JDK6中StringTable大小固定为1009。JDK7中StringTable大小默认为60013。JDK8中最小有效值为1009。</blockquote><h2 id=0-3、执行引擎><a class=headerlink href=#0-3、执行引擎 title=0.3、执行引擎></a>0.3、执行引擎</h2><h3 id=0-3-1、即时编译器><a class=headerlink href=#0-3-1、即时编译器 title=0.3.1、即时编译器></a>0.3.1、即时编译器</h3><h5 id=解释器与编译器><a class=headerlink href=#解释器与编译器 title=解释器与编译器></a>解释器与编译器</h5><p><strong>当程序需要迅速启动和执行时，解释器先运行，然后编译器逐渐发挥作用。如果编译器优化后类发生了变化，那么可以立即通过解释器来运行。所以说解释器和编译器是互相配合执行代码。</strong><p>HotSpot虚拟机内置了三个即时编译器：<strong>客户端编译器（C1编译器）、服务端编译器（C2编译器）、Graal编译器（JDK10引入）。Graal编译器的目标是替换C2编译器</strong>。<p>JVM执行代码时可采用多种模式，分为三种：<ul><li><p><strong>混合模式（默认方式）</strong>：使用参数<code>-Xmixed</code>可以设置JVM运行于混合模式，该模式下解释器和编译器互相配合执行代码。</p><li><p><strong>解释器（Intepreter）模式</strong>：使用参数<code>-Xint</code>可以设置JVM运行于“解释模式”，该模式下只有解释器来解释执行代码。</p><li><p><strong>JIT（Just In-Time，即时编译）模式</strong>：使用参数<code>-Xcomp</code>可以设置JVM运行于“编译模式”，但要注意，当编译器无法继续工作时解释器依然会介入执行。</p></ul><p><strong>分层编译在JDK 6中初步实现，在JDK 7服务端模式中被作为默认编译策略</strong>。分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其包括：<ul><li>第0层：程序纯解释执行，并且解释器不开启性能监控功能（Profiling）。<li>第1层：使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启 性能监控功能。<li>第2层：使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能。<li>第3层：使用客户端编译器执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。<li>第4层：使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。</ul><p>分层编译后，解释器、客户端编译器、服务端编译器可同时工作，在服务端编译器采用高复杂度优化算法时，客户端编译器可先采用简单优化来为之争取更多编译时间。<blockquote><p>疑问：既然编译到本地效率更高，为啥不全部编译到本地呢？<ol><li>现在的Java解释器执行效率已经很高，几乎可以和编译器相媲美。<li>类库或class很多时，编译到本地会很耗时进而影响启动速度。</ol></blockquote><h5 id=热点代码><a class=headerlink href=#热点代码 title=热点代码></a>热点代码</h5><p>被即时编译器编译的目标是“热点代码”，热点代码主要有两类：<ul><li><strong>被多次调用的方法</strong>。<li><strong>被多次执行的循环体</strong>。</ul><p>某段代码是不是热点代码，是否触发即时编译需要执行“热点探测”（Hot Spot Code Detection），热点探测并不一定要知道方法具体被调用多少次，目前主流的热点探测判定方式有两种，分别是：<ul><li><p><strong>基于采样的热点探测</strong></p> <p>采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。这种探测方式的好处是实现简单高效，可以很容易获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而 扰乱热点探测。</p><li><p><strong>基于计数器的热点探测</strong></p> <p>采用这种方法的虚拟机会为 每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为 它是“热点方法”。这种统计方法实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。</p></ul><h5 id=调用计数器><a class=headerlink href=#调用计数器 title=调用计数器></a>调用计数器</h5><p>方法被调用时会先查看是否存在该方法编译后的代码，存在则先执行编译后的代码，不存在则会将方法调用计时器值加1，然后判断方法调用计数器值与回边计数器值之和是否超过调用计数器的阈值，超过阈值会向即时编译器发送方法代码编译请求，在代码被即时编译器编译完成前会暂时先使用解释器来解释执行，当编译完成后，该方法的调用入口地址就会被自动修改为新值，后期调用该方法时就可以执行编译后的代码了。<blockquote><p>方法调用计数器的默认阈值在客户端模式下是1500次，在服务端模式下是10000次，这个阈值可以通过虚拟机参数<code>-XX:CompileThreshold</code>来人为设定。</blockquote><p>默认设置下，方法调用计数器统计的是一段时间内方法被调用的次数，该时间段内，如果方法的调用次数不足以触发即时编译器来编译，那方法调用计数器数值会减少一半，该过程被称为<em><strong>方法调用计数器热度衰减（Counter Decay）</strong></em>，而这段时间称为此方法统计的<em><strong>半衰周期（Counter Half Life Time）</strong></em>。<blockquote><p><strong>热度衰减操作在垃圾收集时进行</strong>，可使用参数<code>-XX:-UseCounterDecay</code>来关闭热度衰减，让方法调用计数器统计方法调用的绝对次数。可使用参数<code>-XX:CounterHalfLifeTime</code>设置半衰周期的时间，单位秒。</blockquote><h5 id=回边计数器><a class=headerlink href=#回边计数器 title=回边计数器></a>回边计数器</h5><p><strong>回边计数器会统计一个方法中循环体代码的执行次数，在字节码中遇到控制流向后跳转的指令就称为“回边（Back Edge）”，回边计数器统计的目的是为了触发栈上替换编译。</strong><p>回边计数器阈值计算分以下两种情况：<ul><li>客户端模式下回边计数器阈值计算公式为：方法调用计数器阈值（-XX:CompileThreshold）乘以OSR比率（-XX:OnStackReplacePercentage）除以100。其中<code>-XX:OnStackReplacePercentage</code>默认值为933，<strong>如果都取默认值，那客户端模式下的回边计数器的阈值为 13995</strong>。<li>服务端模式下回边计数器阈值的计算公式为：方法调用计数器阈值（-XX:CompileThreshold）乘以（OSR比率（-XX:OnStackReplacePercentage）减去解释器监控比率（-XX:InterpreterProfilePercentage）的差值）除以100。其中-XX：OnStack ReplacePercentage默认值为140，- XX:InterpreterProfilePercentage默认值为33，<strong>如果都取默认值，那服务端模式的回边计数器的阈值为10700</strong>。</ul><p>当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有的话，先执行编译好的代码，否则就把回边计数器的值加一，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。超过阈值时会提交一个栈上替换编译请求， 并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。<p><strong>与方法计数器不同，回边计数器没有计算热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出时会把方法计数器的值也调整到溢出状态，这样下次再进入该方法时就会执行标准编译过程</strong>。<blockquote><p><font color=red>注意：回边次数 不等于 循环次数，因为并不是所有的循环都是回边，如空循环并不算控制流向后跳转，也不会被回边计数器统计。</font></blockquote><h3 id=0-3-2、提前编译器><a class=headerlink href=#0-3-2、提前编译器 title=0.3.2、提前编译器></a>0.3.2、提前编译器</h3><p><strong>JDK 9引入了Jaotc，可实现提前编译Class文件及模块</strong>，它可以减少程序的启动时间和到达全速性能的预热时间。该功能需要特定的物理机器和虚拟机参数，限制太多。<h3 id=0-3-3、编译器优化><a class=headerlink href=#0-3-3、编译器优化 title=0.3.3、编译器优化></a>0.3.3、编译器优化</h3><h4 id=分层编译><a class=headerlink href=#分层编译 title=分层编译></a>分层编译</h4><p>JDK7及之后采用了分层编译方式，JVM中的C1和C2编译器会协同发挥作用，分层编译将整个优化级别分为5个等级。<table><thead><tr><th align=center>等级<th align=center>组件<th align=center>描述<th align=center>内容<th align=center>打分<tbody><tr><td align=center>0<td align=center>解释器<td align=center>解释执行，记录方法调用次数和循环次数<td align=center>无<td align=center>1<tr><td align=center>1<td align=center>C1即时编译器<td align=center>C1完整优化<td align=center>优化后的机器码<td align=center>4<tr><td align=center>2<td align=center>C1即时编译器<td align=center>C1完整优化，记录方法调用次数和循环次数<td align=center>优化后的机器码，及方法调用次数和循环次数<td align=center>3<tr><td align=center>3<td align=center>C1即时编译器<td align=center>C1完整优化，记录额外完整信息<td align=center>优化后的机器码，分支跳转次数，类型转换等。<td align=center>2<tr><td align=center>4<td align=center>C2即时编译器<td align=center>C2完整优化<td align=center>优化后的机器码<td align=center>5</table><h4 id=方法内联><a class=headerlink href=#方法内联 title=方法内联></a>方法内联</h4><h5 id=简介-2><a class=headerlink href=#简介-2 title=简介></a>简介</h5><p><strong>内联被称为优化之母，消除方法调用成本外，也为其它优化手段提供了良好基础。</strong><p><strong>方法内联就是把目标方法代码“复制”到发起调用的方法之中，避免发生真实方法调用。该功能得益于即时编译器的付出</strong>。<blockquote><p>Java中默认的实例方法是虚方法。只有使用 invokespecial指令调用的私有方法、实例构造器、父类方法和使用invokestatic指令调用的静态方法才会在编译期进行解析。被final修饰的方法会使用invokevirtual指令调用，它是非虚方法，《Java语言规范》中明确说明了这点。</blockquote><p>内联与虚方法之间会产生“矛盾”，C和C++是通过使用final关键字来修饰方法解决的，但Java在虚拟机中解决这个问题。<p>Java虚拟机首先引入了一种名为类型<em><strong>继承关系分析（Class Hierarchy Analysis，CHA）</strong></em>技术，用于确定目前已加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法 等信息。<p>编译器进行内联时会根据不同情况采取不同处理：非虚方法直接进行内联就可以；对于虚方法，会向CHA查询此方法下是否有多个目标版本可供选择，如果只有一个版本，那可以内联，这种内联称为<em><strong>守护内联（Guarded Inlining）</strong></em>。由于Java程序是动态连接的，说不准什么时候就会加载到新的类型从而改变CHA结论，因此这种内联属于<em><strong>激进预测性优化</strong></em>。假如在程序的后续执行过程中，虚拟机一直没有加载到会导致方法接收者继承关系发生变化的类，那这个内联优化的代码就可以一直使用。如果加载了导致继承关系发生变化的新类，那么就必须抛弃已编译的代码，退回到解释状态执行，或重新进行编译。<p>如果被调用的方法确实有多个版本可供选择，那即时编译器还将进行最后一次努力，<strong>使用内联缓存（Inline Cache）的方式来缩减方法调用的开销。这种状态下方法调用真正发生，比起直接查虚方法表还要快一些</strong>。<h5 id=内联的限制><a class=headerlink href=#内联的限制 title=内联的限制></a>内联的限制</h5><p>并不是所有方法都可以内联，内联有如下一些限制：<ul><li>方法编译后的字节码指令总大小必须小于35字节才可以内联。可通过参数<code>-XX:MaxInlineSize=值</code>，来控制。<li>方法编译后的字节码指令总大小必须小于325字节，且是一个热方法才可以内联。可通过参数<code>-XX:FreqInlineSize=值</code>来控制。<li>方法编译生成的机器码不能大于1000字节。可通过参数<code>-XX:InlineSmallCode=值</code>来控制。<li>一个接口的实现必须小于3个，如果大于3个就不会发生内联。</ul><h4 id=逃逸分析><a class=headerlink href=#逃逸分析 title=逃逸分析></a>逃逸分析</h4><h6 id=简介-3><a class=headerlink href=#简介-3 title=简介></a>简介</h6><p>逃逸分析（Escape Analysis）与类型继承关系分析一 样，并不是直接优化代码的手段，而是<strong>为其他优化措施提供依据的分析技术</strong>。<p>逃逸分析基本原理：<strong>分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，这种称为方法逃逸；甚至还有可能被外部线程访问，这种称为线程逃逸；不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。</strong><p><font color=red>注意：JDK 6u23版本之后，Hotspot默认开启了逃逸分析。</font><h6 id=优化><a class=headerlink href=#优化 title=优化></a>优化</h6><p>如果能证明一个对象不会逃逸到方法或线程之外（换句话说是别的方法或线程无法通过任何途径 访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实例采取不同程度的优化。比如：<p><strong>（1）栈上分配</strong><p>如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。栈上分配支持方法逃逸，但不支持线程逃逸。<p><strong>（2）标量替换</strong><p><strong>若一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解了，那么这些数据就可以被称为标量。相对的，如果一个数据可以继续分解，那它就被称为聚合量（Aggregate），Java 中的对象就是典型的聚合量</strong>。如果把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量 恢复为原始类型来访问，这个过程就称为标量替换。<p>标量替换可以视作栈上分配的一种特例，实现更简单（不用考虑整个对象完整结构的分配），但对逃逸程度的要求更高，它不允许对象逃逸出方法范围内。<p><strong>（3）同步消除</strong><p>线程同步本身是一个相对耗时的过程，如果逃逸分析 能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争， 对这个变量实施的同步措施也就可以安全地消除掉。<h6 id=功能开启><a class=headerlink href=#功能开启 title=功能开启></a>功能开启</h6><ul><li>-XX:+DoEscapeAnalysis：开启逃逸分析。<li>-XX:+PrintEscapeAnalysis：查看逃逸分析筛选结果。</ul><h4 id=公共子表达式消除><a class=headerlink href=#公共子表达式消除 title=公共子表达式消除></a>公共子表达式消除</h4><p>公共子表达式消除的含义是：<strong>如果一 个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E 的这次出现就称为公共子表达式。对于这种表达式，没有必要花时间再对它重新进行计算，可直接使用计算过的表达式结果代替E。</strong>如果这种优化仅限于程序基本块内，便可称为局部公共子表达式消除（Local Common Subexpression Elimination），如果这种优化的范围涵盖了多个基本块，那就称为全局公共子表达式消除（Global Common Subexpression Elimination）。<h4 id=数组边界检查消除><a class=headerlink href=#数组边界检查消除 title=数组边界检查消除></a>数组边界检查消除</h4><p>数组边界检查消除（Array Bounds Checking Elimination）是即时编译器中的一项语言相关的经典优化技术。如果有一个数组foo[]，在Java语言中访问数组元素foo[i]的时候系统将会自动进行上下界 的范围检查，即i必须满足“i>=0&&i<=foo.length”的访问条件，否则将抛出一个运行时异常： java.lang.ArrayIndexOutOfBoundsException。对于虚拟机执行子系统来说，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这必定是一种性能负担。<p>无论如何，为了安全，数组边界检查肯定是要做的，但数组边界检查是不是必须在运行期间一次 不漏地进行则是可以“商量”的事情。<strong>如果对于数组的访问在编译期根据数据流分析就能确定没有越界，执行时就无须判断了。</strong>更常见的是数组访问发生在循环中，且使用循环变量来访问数组。那么在循环中就可以把整个数组的上下界检查消除掉，这可以减少很多次的条件判断操作。<h3 id=0-3-4、Graal编译器><a class=headerlink href=#0-3-4、Graal编译器 title=0.3.4、Graal编译器></a>0.3.4、Graal编译器</h3><p><strong>从JDK 10起，Graal 编译器可以替换服务端编译器成为HotSpot分层编译中最顶层的即时编译器。</strong><p>Java虚拟机编译器接口（Java-Level JVM Compiler Interface，JVMCI）（JDK 9时发布的JEP 243）使得Graal可以从HotSpot的代码中分离出来。<p>通过Java虚拟机编译器接口就可以把一个在HotSpot虚拟机外部的、用Java语言实现的即时编译器（不局限于Graal）集成到HotSpot中，响应HotSpot发出的最顶层的编译请求，并将编译后的二进制代码 部署到 HotSpot代码缓存中。此外，又可以绕开HotSpot的即时编译系统，让该编译器直接为应用的类库编译出二进制机器码，将该编译器当作一个提前编译器去使用 （如Jaotc）。<h3 id=0-3-5、总结><a class=headerlink href=#0-3-5、总结 title=0.3.5、总结></a>0.3.5、总结</h3><p><strong>HotSpot VM采用解释器与即时编译器并存的架构。</strong>Java虚拟机运行时会采用解释器和即时编译器协调工作的方式来达到相对较好的工作状态。<p>栈空间大于堆空间，数据在堆空间和栈空间之间相互转存时需要满足一定的规则。<ul><li>堆转栈：直接处理。要注意的是：<ul><li>boolean、char无符号，低位复制，高位补0。<li>byte、short有符号，正数补0，负数补1。</ul><li>栈转堆：去掉多出的高位，只留剩下的低位。要注意的是，只有boolean只取最后一位保存即可。</ul><h2 id=0-4、本地方法接口><a class=headerlink href=#0-4、本地方法接口 title=0.4、本地方法接口></a>0.4、本地方法接口</h2><h3 id=0-4-1、本地方法><a class=headerlink href=#0-4-1、本地方法 title=0.4.1、本地方法></a>0.4.1、本地方法</h3><h4 id=0-4-1-1、定义><a class=headerlink href=#0-4-1-1、定义 title=0.4.1.1、定义></a>0.4.1.1、定义</h4><p><strong>被关键字native修饰的没有方法体的方法就是一个本地方法，本地方法是java调用非java代码的接口。</strong><h2 id=0-5、对象管理><a class=headerlink href=#0-5、对象管理 title=0.5、对象管理></a>0.5、对象管理</h2><h3 id=0-5-1、对象创建><a class=headerlink href=#0-5-1、对象创建 title=0.5.1、对象创建></a>0.5.1、对象创建</h3><p>创建对象一般遵循以下6大步骤：<ol><li>判断对象对应的类是否已经被加载、连接、初始化。<li>为对象分配内存。<ul><li>如果内存规整，通过 指针碰撞 方式来分配内存。<li>如果内存不规整，通过 空闲列表 方式来分配内存。</ul><li>处理并发安全问题。<ul><li>采用CAS失败重试，区域加锁保证更新原子性。<li>每个线程预先分配一个TLAB。</ul><li>初始化分配到的空间。<li>设置对象的对象头。<li>执行init方法进行初始化。</ol><h3 id=0-5-2、对象定位><a class=headerlink href=#0-5-2、对象定位 title=0.5.2、对象定位></a>0.5.2、对象定位</h3><h4 id=0-5-2-1、简介><a class=headerlink href=#0-5-2-1、简介 title=0.5.2.1、简介></a>0.5.2.1、简介</h4><p>对象访问有两种方式：句柄访问和直接指针。<strong>Java中使用的是直接指针</strong>。<h4 id=0-5-2-2、句柄访问><a class=headerlink href=#0-5-2-2、句柄访问 title=0.5.2.2、句柄访问></a>0.5.2.2、句柄访问</h4><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86-1.1-%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%BD%8D-%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%9B%BE%E7%A4%BA.png><h4 id=0-5-2-3、直接指针><a class=headerlink href=#0-5-2-3、直接指针 title=0.5.2.3、直接指针></a>0.5.2.3、直接指针</h4><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86-1.2-%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E5%9B%BE%E7%A4%BA.png><h1 id=1、JVM基础><a class=headerlink href=#1、JVM基础 title=1、JVM基础></a>1、JVM基础</h1><h2 id=1-1、概述><a class=headerlink href=#1-1、概述 title=1.1、概述></a>1.1、概述</h2><h3 id=1-1-1、简介><a class=headerlink href=#1-1-1、简介 title=1.1.1、简介></a>1.1.1、简介</h3><p><strong>JVM全称为Java Virtual Machine，意为Java虚拟机。</strong>Java虚拟机拥有解释运行、内存管理、即时编译等功能。<p><strong>JVM、JRE、JDK、JAVASE、JAVAEE等的关系：JVM < JRE < JDK < JAVASE < JAVAEE。它们之间是包含与被包含的关系。</strong>详情介绍如下：<ul><li><strong>JVM</strong>：Java Virtual Machine，表示Java虚拟机。<li><strong>JRE</strong>：Java Runtime Environment，表示Java运行时环境。<li><strong>JDK</strong>：Java Development Kit，表示Java开发工具集。<li><strong>JAVAME</strong>：Java Micro Edition，表示Micro版，之前称J2ME。是一个技术和规范的集合，它为移动设备（包括消费类产品、嵌入式设备、高级移动设备等）提供了基于Java环境的开发与应用平台。Java ME分为两类配置，一类是面向小型移动设备的<em>CLDC</em>（Connected Limited Device Profile），一类是面向功能更强大的移动设备如智能手机和机顶盒，称为<em>CDC</em>（Connected Device Profile CDC）。Java ME有自己的类库，其中<em>CLDC</em>使用的是专用的Java虚拟机叫做J<em>VM</em>。<li><strong>JAVASE</strong>：Java Standard Edition，表示Java标准版，之前称为J2SE。JAVASE是Java技术的核心和基础，是Java ME和Java EE编程的基础。<li><strong>JAVAEE</strong>：Java Enterprise Edition，表示Java企业版，之前也称为J2EE。Java EE 是在 Java SE 的基础上构建的，它提供Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 3.0应用程序。</ul><p>JVM在垃圾回收层面与C++的区别：<ul><li>JAVA：系统自动处理，开发效率高，执行效率低。<li>C++：手工处理，开发效率低，执行效率高。容易出现忘记回收、内存泄漏、回收多次、非法访问等问题。</ul><h3 id=1-1-2、优点><a class=headerlink href=#1-1-2、优点 title=1.1.2、优点></a>1.1.2、优点</h3><p>JVM优点如下：<ul><li>一次编译，到处运行。<li>自动垃圾回收。<li>多态特性。<li>数组下标越界检查。</ul><h3 id=1-1-3、常见虚拟机><a class=headerlink href=#1-1-3、常见虚拟机 title=1.1.3、常见虚拟机></a>1.1.3、常见虚拟机</h3><ul><li><p>Hotspot</p><li><p>JRockit（BEA）：专注于服务端应用，据行业基准测试显示，其是世界上最快的JVM。2008年BEA被Oracle收购，Oracle计划将整合两大优秀的虚拟机，整合方式是在Hotspot基础上加入JRockit的新特性。</p><li><p>J9（IBM）：市场定位与HotSpot相似，适用于服务器端、桌面应用、嵌入式应用等场景。2017年左右，IBM开源了J9 VM，命名为OpenJ9，交给Eclipse基金会管理。</p><li><p>KVM</p><li><p>Azul VM</p><li><p>Liquid VM（BEA）</p><li><p>Graal VM：2018年Oracle公开Graal VM，号称“Run Programs Faster Anywhere”，其与1995年宣称的“Write Once, Run Anywhere”遥相呼应。Graal VM是在HotSpot VM基础上增强而成的跨语言全栈虚拟机，适用于多种语言。</p></ul><h3 id=1-1-4、虚拟机退出><a class=headerlink href=#1-1-4、虚拟机退出 title=1.1.4、虚拟机退出></a>1.1.4、虚拟机退出</h3><p>导致虚拟机退出的情况分以下几种：<ul><li>程序正常结束。<li>程序执行过程中遇到了异常或错误，进而导致虚拟机退出。<li>因操作系统出现错误导致虚拟机退出。<li>调用了Runtime类或System类的exit方法，或Runtime类的halt方法，且Java安全管理器也允许这种操作。</ul><h2 id=1-2、垃圾><a class=headerlink href=#1-2、垃圾 title=1.2、垃圾></a>1.2、垃圾</h2><h3 id=1-2-1、概述><a class=headerlink href=#1-2-1、概述 title=1.2.1、概述></a>1.2.1、概述</h3><p><strong>没有引用指向的任何对象和不再使用的类都是垃圾，应该被回收。</strong><p><strong>方法区中可以回收的内容主要就是不再使用的类</strong>。一个类是否被回收，需要满足一定的条件。当符合以下全部情况时，类将会被回收。<ul><li>此类所有实例对象都已经被回收，在堆中不存在该类的实例对象及子类对象。<li>加载该类的类加载器已经被回收。<li>该类对应的java.lang.Class对象没有在任何地方被引用。</ul><p>堆区域是垃圾回收的主要区域。堆中主要回收的内容就是没有引用指向的对象。<h3 id=1-2-2、识别垃圾><a class=headerlink href=#1-2-2、识别垃圾 title=1.2.2、识别垃圾></a>1.2.2、识别垃圾</h3><h4 id=1-2-2-1、简介><a class=headerlink href=#1-2-2-1、简介 title=1.2.2.1、简介></a>1.2.2.1、简介</h4><p>对于JVM来说，需要通过一些方法来识别并找到垃圾，找到垃圾后才可以执行回收清理工作，进而保持JVM的正常高效运作。<p><strong>识别垃圾的方法，目前只要有两种：引用计数算法、根可达性算法</strong>。两种算法各有优缺点，找到最适合的方法才是最好的。<h4 id=1-2-2-2、引用计数算法><a class=headerlink href=#1-2-2-2、引用计数算法 title=1.2.2.2、引用计数算法></a>1.2.2.2、引用计数算法</h4><h5 id=简介-4><a class=headerlink href=#简介-4 title=简介></a>简介</h5><p><strong>当一个对象被引用时，该对象的引用计数器数值就会加1，这就是引用计数算法。</strong><h5 id=特点><a class=headerlink href=#特点 title=特点></a>特点</h5><p>引用计数算法有以下特点<ol><li><font color=red>需要一个单独字段来存储计数器计算结果，增加了存储开销。</font><li><font color=red>每次赋值都需要更新计数器，增加了时间开销。</font></ol><h5 id=缺点><a class=headerlink href=#缺点 title=缺点></a>缺点</h5><p>引用计数算法不能解决“循环引用”问题。<blockquote><p>循环引用问题指：有对象A和对象B，对象A中含有对象B的引用，对象B中含有对象A的引用。此时，对象A和对象B的引用计数器都不为0，但是在系统中却不存在任何第3个对象引用了A或B。也就是说A和B是应该被回收的垃圾对象，但由于垃圾对象间相互引用，从而使垃圾回收器无法识别，引起内存泄漏。</blockquote><h4 id=1-2-2-3、根可达性算法><a class=headerlink href=#1-2-2-3、根可达性算法 title=1.2.2.3、根可达性算法></a>1.2.2.3、根可达性算法</h4><h5 id=简介-5><a class=headerlink href=#简介-5 title=简介></a>简介</h5><p><strong>根搜索算法有实现简单、执行高效等特点，可有效解决循环引用问题，防止内存泄漏发生。</strong><p>根搜索算法是以 根对象集合 为起始点，按照从上至下的方式 搜索 被根对象集合所连接的目标对象是否可达，如果目标对象不可达就表明该对象己死亡，便可以在 instanceOopDesc Mark World 中将其标记为垃圾对象。在根搜索算法中，只有被根对象集合直接或间接连接的对象才是存活对象。<h5 id=根对象><a class=headerlink href=#根对象 title=根对象></a>根对象</h5><p>根对象通常分为4类：详情如下：<ul><li>线程Thread对象，引用线程栈帧中的方法参数、局部变量等。<li>系统类加载器加载的java.lang.Class对象，引用类中的静态变量。<li>监视器对象，用来保存同步锁synchronized关键字持有的对象。<li>本地方法调用时使用的全局对象。</ul><p>在Hotspot中，根对象集合包含5个元素：<ol><li>Java 对象引用。<li>本地方法内的对象引用。<li>运行时常量池中的对象引用。<li>方法区中类静态属性的对象引用。<li>与一个类对应的唯一数据类型的 Class 对象。</ol><h5 id=注意事项><a class=headerlink href=#注意事项 title=注意事项></a>注意事项</h5><p><strong>根搜索算法中的不可达对象最初处于缓刑阶段，真正死亡要经历两次标记</strong>：<ol><li>如果一个对象没有与GCRoot相连，那么该对象会被第一次标记并判断是否执行该对象的finaliz()方法。如果该对象没有覆盖finalize()方法或finalize()方法已经执行过了，那么无需操作，否则会将该对象放入F-Queue中，然后通过一个低优先级的finalizer线程来执行该对象的finalize()方法。<li>稍后 GC 将对 F- Queue 中的对象进行第二次标记，第二次标记之前，如果该对象与其它对象建立了引用关系，那么第二次标记时会将该对象移出即将回收的集合。如果第二次标记之前，该对象没有与其它对象建立引用关系，那么它会被真正回收。</ol><h2 id=1-3、对象生命周期><a class=headerlink href=#1-3、对象生命周期 title=1.3、对象生命周期></a>1.3、对象生命周期</h2><h3 id=1-3-1、概述><a class=headerlink href=#1-3-1、概述 title=1.3.1、概述></a>1.3.1、概述</h3><p><strong>创建对象后会优先栈上分配；如果不能分配，先判断其大小，如果太大直接放进老年代，如果不大，就尝试先在TLAB中分配；如果还是分配不下，就直接在eden区分配。</strong><p>eden区经过一次垃圾回收之后，存活对象会进入surivor from区，eden区和surivor from区再经过一次回收后，存活对象会被移动到survivor to区（注意：移动完成后from区和to区交换角色，即 from变to，to变from，为的是下次再回收alive对象），以此反复执行，直到年龄达到阈值时就进入老年代。<p><font color=red>注意：from <—> to区中对象间的移动超过阈值就会进入老年代，这个阈值可通过参数<code>-XX:MaxTenuringThreshold=threshold</code>进行设置。</font><p>栈上分配前提条件：<ul><li>线程私有小对象。<li>热点代码。<li>无逃逸：在某一段代码中使用，代码外无法使用。<li>支持标量替换：用普通的类型代替对象（若仅仅使用一个对象中的1至2个属性，那么就无需先拿到对象再获取对应属性，而是直接使用这两个属性代替这个对象）。<li>无需调整。</ul><h3 id=1-3-2、新生代><a class=headerlink href=#1-3-2、新生代 title=1.3.2、新生代></a>1.3.2、新生代</h3><h4 id=1-3-2-1、简介><a class=headerlink href=#1-3-2-1、简介 title=1.3.2.1、简介></a>1.3.2.1、简介</h4><p>新生代也称为年轻代，新生代分为Edon区和Survivor区，Survivor区又分为Survivor0区和Survivor1区，或者说From区和To区。<p>Edon区、Survivor区特点如下：<ul><li>eden（伊甸）：默认占年轻代的比例为8/10，存放刚new出来的对象。<li>survivor from：默认比例为1，回收一次后要存储对象的区域。<li>survivor to：默认比例为1，回收一次后要存储对象的区域。</ul><h4 id=1-3-2-2、新生代GC><a class=headerlink href=#1-3-2-2、新生代GC title=1.3.2.2、新生代GC></a>1.3.2.2、新生代GC</h4><p>对象被创建后通常会先放在Edon区中，当执行一次Minor GC（YGC、年轻代GC）时，会标记Edon区和Survivor From区中的存活对象，并将这些存活对象统一转移至Survivor To区，然后清除Edon区和Survivor From区中没有被标记的死亡对象（垃圾对象）。<p>经过一次YGC后，会交换From区和To区的名字，即原为From区，现为To区，原为To区，现为From区。且会将被转移的存活对象的年龄加1。当对象年龄达到参数<code>-XX:MaxTenuringThreshold=threshold</code>设定的值时会在GC执行的过程中被转移至老年代。<p>Minor GC的注意事项如下：<ul><li>年轻代空间不足时会触发Minor GC，Survivor区满并不会触发Minor GC。<li>Minor GC会引发STW，暂停其它用户线程，当垃圾线程执行完后用户线程才会恢复。</ul><h3 id=1-3-3、老年代><a class=headerlink href=#1-3-3、老年代 title=1.3.3、老年代></a>1.3.3、老年代</h3><h4 id=1-3-3-1、简介><a class=headerlink href=#1-3-3-1、简介 title=1.3.3.1、简介></a>1.3.3.1、简介</h4><p>当对象满足一定的规则时，会被转移至老年代空间中。<p>触发对象被转移至老年代的规则有两个：<p><strong>（1）设置参数<code>-XX:MaxTenuringThreshold=threshold</code>来限定何时将对象转移至老年代</strong><p>参数值表示触发对象被转移至老年代时的对象年龄，如果没有指定该参数，则默认参考为：Parallel Scavenge垃圾回收器中的对象年龄为15，CMS垃圾回收器中的对象年龄为6，G1垃圾回收器中的对象年龄为15。<p><strong>(2）动态年龄</strong><p>from -> to后超过to内存总量50%。eden区+from区的存活对象全部移到to区且这些存活对象占用to区容量的一半，则将to区中大于等于这些存活对象中最大年龄的那些对象直接放入老年代。所以说也不一定非得到了15岁/6岁才行。相关参数为<code>-XX:TargetSurvivorRatio</code>。<p>除此之外，如果一个对象比较大，那么会直接被转移至老年代。<h4 id=1-3-3-2、老年代GC><a class=headerlink href=#1-3-3-2、老年代GC title=1.3.3.2、老年代GC></a>1.3.3.2、老年代GC</h4><p>老年代特点如下：<ul><li>tenured（终身）：默认与新生代的比例为2:1，存放大对象和生命力较强的对象。</ul><p>老年代GC注意事项如下：<ul><li>出现了Major GC前通常会先执行一次Minor GC（非绝对，Parallel Scavenge收集器可以直接执行Major GC。）。<li>Major GC 速度一般比Minor GC慢10倍以上。<li>Major GC后内存依然不足就会报OOM异常。</ul><h3 id=1-3-4、Full-GC><a title="1.3.4、Full GC" class=headerlink href=#1-3-4、Full-GC></a>1.3.4、Full GC</h3><p>触发FGC的情况有如下几种：<ul><li>老年代空间不足。<li>方法区空间不足。<li>通过Minor GC后进入老年代的对象的平均大小大于老年代可用空间。<li>由Eden区、Survivor from区向Survivor to区复制对象时，对象大小大于to区可用内存，则把这些对象放进老年代，且老年代可用内存小于这些对象大小。<li>调用System.gc()方法时，通知系统执行Full GC，但不保证一定执行。</ul><h2 id=1-4、垃圾回收算法><a class=headerlink href=#1-4、垃圾回收算法 title=1.4、垃圾回收算法></a>1.4、垃圾回收算法</h2><h3 id=1-4-1、标记清除（Mark-Sweep）><a class=headerlink href=#1-4-1、标记清除（Mark-Sweep） title=1.4.1、标记清除（Mark-Sweep）></a>1.4.1、标记清除（Mark-Sweep）</h3><h5 id=定义><a class=headerlink href=#定义 title=定义></a>定义</h5><p><strong>标记存活对象，然后清除未被标记的垃圾对象的算法称为标记清除算法。</strong>该算法将垃圾回收分两个阶段，标记阶段和清除阶段。<ol><li><p>标记阶段：Collector从引用根节点开始遍历，标记可以被根对象关联到的对象，这些对象都是可达对象。</p><li><p>清除阶段：Collector对堆内存从头到尾进行线性遍历，如果发现某个对象在其Header中没有被标记为可达对象，则将其回收。这里的清除并非是真的清除，而是将待清除对象的地址保存到空闲地址列表中，为新对象分配内存时直接覆盖使用。</p></ol><p>标记-清除算法不需要运行环境监测每一次内存分配和指针操作，而只要在“标记”阶段中跟踪每个指针变量的指向，用类似思路实现的垃圾收集器常被称为 跟踪收集器。<h5 id=优缺点><a class=headerlink href=#优缺点 title=优缺点></a>优缺点</h5><ul><li>优点：效率较高、成本较低。<li>缺点：会产生内存碎片。</ul><h3 id=1-4-2、复制（Copying）><a class=headerlink href=#1-4-2、复制（Copying） title=1.4.2、复制（Copying）></a>1.4.2、复制（Copying）</h3><h5 id=定义-1><a class=headerlink href=#定义-1 title=定义></a>定义</h5><p><strong>将内存空间分为两块，每次只使用其中一块。垃圾回收时会将当前使用内存（假如为区域A）中的存活对象拷贝至另一空闲内存中（假如为区域B），然后清掉区域A中剩下的死亡对象并交换两个内存区域的角色，最后完成垃圾回收，这种算法称之为 复制算法。</strong><h5 id=优缺点-1><a class=headerlink href=#优缺点-1 title=优缺点></a>优缺点</h5><ul><li>优点：只扫描一次，效率高且没有碎片；<li>缺点：<font color=red>每次需要使用一半内存，造成空间浪费；移动复制对象需要调整对象引用；</font></ul><h5 id=适用场景><a class=headerlink href=#适用场景 title=适用场景></a>适用场景</h5><p>适用于存活对象较少的情况。<h3 id=1-4-3、标记压缩（Mark-Compact）><a class=headerlink href=#1-4-3、标记压缩（Mark-Compact） title=1.4.3、标记压缩（Mark-Compact）></a>1.4.3、标记压缩（Mark-Compact）</h3><h5 id=定义-2><a class=headerlink href=#定义-2 title=定义></a>定义</h5><p>标记压缩算法思想：<strong>从根节点开始标记所有被引用对象，然后将存活对象压缩到内存一端并按顺序排放，之后清理边界外所有的空间。</strong><p>空间压缩后，内存较为规整，此种情况下可以通过 指针碰撞 算法为新对象分配空间。<h5 id=优缺点-2><a class=headerlink href=#优缺点-2 title=优缺点></a>优缺点</h5><ul><li>优点：不会产生碎片；<li>缺点：<font color=red>两遍扫描，第一遍先找出有用的，第二遍才进行移动，如果是多线程还需要进行同步，效率低。</font></ul><h3 id=1-4-4、增量算法-（Incremental-Collecting><a title="1.4.4、增量算法 （Incremental Collecting )" class=headerlink href=#1-4-4、增量算法-（Incremental-Collecting></a>1.4.4、增量算法 （Incremental Collecting )</h3><p>增量算法思想：<strong>垃圾收集线程和应用程序线程交替执行，每次垃圾收集线程只收集小片内存空间，然后切换到应用程序线程执行。依次反复，直到垃圾收集完成。</strong><p><strong>垃圾回收线程和应用程序线程同时执行可减少停顿时间，但因线程切换、上下文转换等会降低吞吐量。</strong><h3 id=1-4-5、其它><a class=headerlink href=#1-4-5、其它 title=1.4.5、其它></a>1.4.5、其它</h3><h4 id=1-4-5-1、屏障><a class=headerlink href=#1-4-5-1、屏障 title=1.4.5.1、屏障></a>1.4.5.1、屏障</h4><h5 id=简介-6><a class=headerlink href=#简介-6 title=简介></a>简介</h5><p>屏障指的是一段逻辑代码，通常会被插入到原生代码中，并在原生代码执行前，或执行时，或执行后来做一些额外的操作。<h5 id=写屏障><a class=headerlink href=#写屏障 title=写屏障></a>写屏障</h5><p>对于G1垃圾回收器来说，屏障代码会被插入到原生代码中引用赋值语句的前和后，分别称为写前屏障和写后屏障。<ul><li>写前屏障：当执行原生代码中的引用赋值代码时，等式左侧的引用会被修改引用另一个对象。而等式左侧引用之前指向的那个对象将失去一个引用。写前屏障的作用就是在引用赋值生效前，记录失去引用的那个对象。JVM不会立即同步更新RSet，而会基于队列实现异步更新。<li>写后屏障：当执行原生代码中的引用赋值代码后，等式右边的对象就会被等式左边的引用来指向，同时需要更新等式右边对象所在分区的RSet，不过同样是基于队列实现异步更新。</ul><h4 id=1-4-5-2、Card-Table（卡表）><a title="1.4.5.2、Card Table（卡表）" class=headerlink href=#1-4-5-2、Card-Table（卡表）></a>1.4.5.2、Card Table（卡表）</h4><h5 id=简介-7><a class=headerlink href=#简介-7 title=简介></a>简介</h5><blockquote><p>官方描述： A <em>card table</em> is a particular type of remembered set. Java HotSpot VM uses an array of bytes as a card table. Each byte is referred to as a <em>card</em>. A card corresponds to a range of addresses in the heap. <em>Dirtying a card</em> means changing the value of the byte to a <em>dirty value</em>; a dirty value might contain a new pointer from the old generation to the young generation in the address range covered by the card.<p>卡表是一种特殊类型的记忆集。Java HotSpot VM 使用字节数组作为卡片表。每个字节称为一张卡。卡片对应于堆中的地址范围。弄脏卡意味着将字节的值更改为脏值，脏值可能包含从老一代到卡所涵盖的地址范围内的年轻一代的新指针。</blockquote><p>Card是一个特殊类型的RSet。Card Table底层是一个字节数组，每个字节称为一个Card，每个字节对应堆中老年代的某个范围的内存地址，也即，每个字节代表老年代中的一小片内存，该字节对应的字节数组中的索引会被拿来表示这一小片内存的地址。默认情况下，每个Card对应老年代中512字节大小的内存，JDK18开始，可以通过参数<code>-XX:GCCardSizeInBytes</code>来设置每个Card可以表示的内存大小。<h5 id=底层原理><a class=headerlink href=#底层原理 title=底层原理></a>底层原理</h5><p>卡表作用：<strong>当老年代中的对象引用了年轻代中的对象时，写屏障逻辑就会将老年代中引用了年轻代对象的对象所占内存对应的Card Table中的Card标记为Dirty（脏），即将该Card对应的字节值标记为1（JDK8源码中1表示被引用了，称为脏卡），这样GC扫描收集垃圾时只需要扫描Dirty Card即可。</strong><p>卡表占堆内存的总大小计算公式为：<code>堆大小/512</code>，这里的512表示的是每个字节可表示的内存大小。<h4 id=1-4-5-3、RSet><a class=headerlink href=#1-4-5-3、RSet title=1.4.5.3、RSet></a>1.4.5.3、RSet</h4><h5 id=简介-8><a class=headerlink href=#简介-8 title=简介></a>简介</h5><p><strong>RSet是Remembered Set的缩写，意为记录集合</strong>。G1中的每个Region都有一个RSet，它是一个hash表，Key是其它Region的起始地址，Value是一个存储Card Table索引的集合。RSet会和Card Table协同来工作。<p>比如，RegionB引用了RegionA中的对象，那么RegionA关联的RSet就会记录RegionB。当GC扫描RegionA并标记其中的存活对象时，就需要知道哪些Region引用了RegionA中的对象，查询RegionA的RSet后发现RegionB中的对象引用了RegionA中的对象，此时GC就需要扫描整个RegionB来找到具体那个对象引用了RegionA。<p>扫描整个RegionB来寻找哪些对象引用了RegionA中的对象这个过程通常耗时会很长，且效率低下。为了解决这个问题，Card Table就出现了，在Card Table的辅助下，在扫描RegionB时，只需扫描Card Table中的Dirty Card即可得到哪些对象引用了RegionA中的对象，如次一来，效率就大大提升了。<p>**RSet大小和Region数量有直接关系，一般来说 RSet 的大小占整个 Java 堆空间的1%~20%**。<blockquote><p>当Region被引用较多时，RSe占用空间会上升，因此为RSet存储划分了三种粒度：<ul><li>稀疏表（Sparse）：直接通过哈希表来存储，key 是 region index，value 是 card 数组（记录 card index）。<li>细粒度（Fine）：当一个 region 的 card 数量超过阈值时，退化为一个 bitmap，每一位对应一个card（index）。如果bit为0表示该bit对应的内存分段中没有引用，为1表示有引用。<li>粗粒度（Coarse）：当引用 region 数量超过阈值时，退化为使用bitmap只记录 regin 引用，每一位对应一个 region（index）。</ul><p>因为某些Region中的对象可能会被其它许多对象引用，为避免保存太多数据，故会以更大粒度保存引用，这种方式会减少RS数据，但会增加扫描和标记开销，因为需要扫描所有bit为1的内存分段中的对象以确定具体是来自哪个对象的引用。</blockquote><h5 id=底层原理-1><a class=headerlink href=#底层原理-1 title=底层原理></a>底层原理</h5><p>RSet的作用为：<strong>当引用发生改变时，写屏障会先检查引用和被引用的对象是否在同一个Region中，如果不在一个Region，那么需要将引用对象关联的Card Table中的Card索引信息记录到被引用对象关联的RSet中</strong>。<p>当引用发生变化时，会把引用关系更新到RS中。RS更新并非实时性，RS处理需要线程同步，开销会很大，所以为了性能需要，G1维护了一个Dirty Card Queue。对于引用赋值语句，JVM会在之前和之后执行特殊操作以在dirty card queue中加入一个保存了对象引用信息的card。YGC时G1会对Dirty Card Queue中所有的card进行处理并更新RS，以保证RS实时准确的反映引用关系。<h5 id=point-in机制><a class=headerlink href=#point-in机制 title=point-in机制></a>point-in机制</h5><p><strong>G1中RSet使用point-in机制，而CMS使用point-out机制</strong>。<p>point-in是指：哪些分区中的对象引用了当前分区中的对象，就在当前分区的RSet中记录哪些分区。<h4 id=1-4-5-4、CSet><a class=headerlink href=#1-4-5-4、CSet title=1.4.5.4、CSet></a>1.4.5.4、CSet</h4><h5 id=简介-9><a class=headerlink href=#简介-9 title=简介></a>简介</h5><p><strong>CSet是Collection Set的缩写，意为回收集合，即，需要回收的内存区域的集合。</strong><p>根据垃圾回收的类型，回收集合中的内存由不同的区域组成：<ul><li>Minor GC（YGC）：回收集合包含年轻代的区域和可能被回收的大对象区域。<li>回收阶段：回收集合包含年轻代的区域、大对象区域，及回收集候选区域中的一些老年代区域组成。</ul><h5 id=底层原理-2><a class=headerlink href=#底层原理-2 title=底层原理></a>底层原理</h5><p>一个回收集合中能有多少Regopm，与以下两个方面有关：<ul><li>有多少Region可以被释放、<li>G1目标停顿时间。</ul><p>G1会在并发周期内回收集合候选区域。在重新标记期间，G1会选择内存使用率较低的Region区域。在备注和清理暂停之间同时准备这些区域，以供后续收集。G1会对这些待回收的区域进行优先级排序，某个区域回收后得到的可用空间大，那么这个待回收区域的优先级就高。后续会根据目标暂停时间，及其它相关需求，并按照待回收区域优先级来有选择性的回收或多或少的区域。<h4 id=1-4-5-5、TLAB><a class=headerlink href=#1-4-5-5、TLAB title=1.4.5.5、TLAB></a>1.4.5.5、TLAB</h4><h5 id=简介-10><a class=headerlink href=#简介-10 title=简介></a>简介</h5><p>堆内存线程共享，多个线程创建对象来分配内存时，为了避免在同一块内存中分配起冲突，所以内存分配的动作需要同步。因为创建对象分配内存是非常频繁的动作，若多个线程的内存分配操作都同步执行，那这就与单个线程在执行差不多，性能极差，成为了提升应用性能的巨大瓶颈。<p>为了避免这种问题的存在，<strong>JVM提出Thread Local Allocation Buffer，可简称为TLAB，意为线程本地分配缓冲</strong>。JVM会为每一个线程分配一个独占私有的内存空间，这个内存空间就称为TLAB，每个线程创建对象分配内存时，会在自己独占的TLAB空间中分配，这样一来就避免了内存分配冲突需要同步分配的问题。<blockquote><p>对于G1垃圾回收器，当对象是Humongous对象，且TLAB也能装下时，同样会被优先分配在线程的TLAB中。</blockquote><p><font color=red>注意：TLAB的独占只限于“内存分配”这个动作，而对于TLAB的读取、内存回收等操作依然属于线程共享。</font><h5 id=参数><a class=headerlink href=#参数 title=参数></a>参数</h5><p>与TLAB相关的参数如下：<ul><li>手动指定tlab大小：-XX：TLABSize<li>tlab功能开启/关闭：XX:+/-UseTLAB<li>tlab占eden空间百分比：-XX:TLABWasteTargetPercent<li>禁用tlab运行时动态自动调整大小功能：-XX:-ResizeTLAB<li>tlab的refill_waste值：-XX：TLABRefillWasteFraction（默认大小64，表示使用约为1/64空间大小作为refill_waste）<li>观察tlab使用情况：-XX+PringTLAB</ul><h5 id=TLAB空间不足><a class=headerlink href=#TLAB空间不足 title=TLAB空间不足></a>TLAB空间不足</h5><p>TLAB空间大小有限制，当空间被用完时会发生什么？<p>当线程创建对象并从TLAB中分配内存时，如果TLAB空闲内存不足，那么会有如下四种可选项：<ul><li>为当前线程分配一个新的TLAB空间，然后在新的TLAB空间中分配内存。<li>在TLAB空间外的堆中分配内存。<li>尝试使用垃圾回收器释放一些内存。<li>无法分配内存，抛出错误。</ul><p>JVM使用复杂的启发式方法来确定具体使用哪些选项，但这些启发式方法可能在不同JVM和不同版本间发生变化。然而，影响这一变化的重要细节包括：<ul><li>一段时间内可能的分配数量。如果要分配大量对象的内存，那么增加TLAB空间将是更有效的选择。如果要分配内存的对象数量很少，那么增加TLAB空间反而效率会很低。<li>正在请求的内存量。请求的内存越多，在TLAB空间外分配内存的成本就越高。<li>可用内存量。如果JVM还有大量可用内存，那么增加TLAB空间相对容易。如果剩余空闲空闲很少，那么增加TLAB空间的成本就会相对较高。<li>内存争用量。如果JVM中有很多线程，每个线程都需要分配内存，那么增加TLAB空间可能比线程少时的情况花费的成本要高。</ul><p>假如一个线程的TLAB空间大小为100KB，已经使用80KB，当再分配一个30KB的对象时，就无法在TLAB中分配，遇到此种情况，有两种处理方案：<ol><li>直接在堆内存中分配对象。<li>废弃当前TLAB，重新申请TLAB并在其中为对象分配内存。</ol><p>为解决这两个问题，虚拟机设定了一个参数<code>refill_waste</code>，称为最大浪费空间。当请求分配的内存大于该参数值，则在堆内存中分配对象，当小于该值时则废弃当前TLAB并重新申请TLAB，然后在其中进行对象分配。<h4 id=1-4-5-6、PLAB><a class=headerlink href=#1-4-5-6、PLAB title=1.4.5.6、PLAB></a>1.4.5.6、PLAB</h4><h5 id=简介-11><a class=headerlink href=#简介-11 title=简介></a>简介</h5><p>垃圾回收器工作期间会有多个线程参与执行，当多个线程需要将存活对象转移至其它空闲内存中时，可能会发生向同一块内存中拷贝的现象，这显然是不正确的，但这种情况也确实可能存在。为了避免多个线程把存活对象向同一块内存中拷贝，<strong>JVM提出了Promotion Local Allocation Buffer，简称PLAB，意为晋升本地分配缓冲</strong>。<p>JVM会为每个线程创建一个独占私有的内存空间，这个内存空间就称为PLAB。当多个线程需要转移存活对象时，会将这些对象转移至自己独占的PLAB空间中，如此一来，就避免了转移冲突问题。<h5 id=参数-1><a class=headerlink href=#参数-1 title=参数></a>参数</h5><ul><li><code>-XX:-ResizePLAB</code>：表示关闭PLAB大小的自动调整。多线程环境下，关闭该功能可一定程度上提升性能。</ul><h4 id=1-4-5-7、SATB><a class=headerlink href=#1-4-5-7、SATB title=1.4.5.7、SATB></a>1.4.5.7、SATB</h4><h5 id=简介-12><a class=headerlink href=#简介-12 title=简介></a>简介</h5><p><strong>SATB是Snapshot At The Beginning的的缩写，意为开始时快照。SATB是由Taiichi Tuasa提出的增量式完全并发标记算法，主要用于使用标记清除算法的垃圾回收器的并发标记阶段</strong>。<p>每个线程都有一个独占的SATB缓冲区，初始大小为256条记录，当空间用完时会分配新的缓冲区继续使用，而旧的缓冲区会被加入全局列表。<p>SATB针对G1的Region分区来设计，又解决了CMS重新标记过程暂停时间长的问题。<h5 id=底层原理-3><a class=headerlink href=#底层原理-3 title=底层原理></a>底层原理</h5><p>SATB的核心思想是创建一个对象图，类似于堆的逻辑快照，确保在并发标记阶段能快速定位所有垃圾对象。<strong>当引用发生改变时，写前屏障会在引用变更前，将值记录在SATB的日志或缓冲区中</strong>。<p><strong>并发标记阶段，标记线程会定期检查和处理全局缓冲区列表中的记录。根据标记位图的标记位来扫描引用字段并更新RSet，这个过程称为并发标记或SATB写前屏障</strong>。<h2 id=1-5、垃圾收集器><a class=headerlink href=#1-5、垃圾收集器 title=1.5、垃圾收集器></a>1.5、垃圾收集器</h2><h3 id=1-5-1、Serial（JDK1-3）><a class=headerlink href=#1-5-1、Serial（JDK1-3） title=1.5.1、Serial（JDK1.3）></a>1.5.1、Serial（JDK1.3）</h3><h4 id=简介-13><a class=headerlink href=#简介-13 title=简介></a>简介</h4><p><strong>JDK1.3.1引入Serial GC，适用于存储器小，CPU少的环境。</strong><p>Serial 收集器工作于<strong>年轻代</strong>，采用<strong>复制算法</strong>、串行回收和“ Stop-the-World ”机制的方式执行内存回收。<p><strong>注意事项：JDK8及之前版本，Seril和CMS可以搭配使用，JDK9开始废除了这种搭配</strong>。<h4 id=参数-2><a class=headerlink href=#参数-2 title=参数></a>参数</h4><ul><li>-XX:+UseSerialGC：表示使用Serial垃圾回收器。年轻代会被Serial回收、老年代会被Serial Old回收。</ul><h3 id=1-5-2、Serial-Old><a title="1.5.2、Serial Old" class=headerlink href=#1-5-2、Serial-Old></a>1.5.2、Serial Old</h3><h4 id=简介-14><a class=headerlink href=#简介-14 title=简介></a>简介</h4><p>Serial Old收集器工作于<strong>老年代</strong>，采用单线程<strong>标记压缩算法</strong>。<blockquote><p>Serial Old是运行在Client模式下默认的老年代垃圾回收器。Serial Old在Server模式下主要有两个用途：与新生代的Parallel Scavenge配合使用；作为老年代CMS收集器的后备方案。</blockquote><h4 id=参数-3><a class=headerlink href=#参数-3 title=参数></a>参数</h4><ul><li>-XX:+UseSerialGC：表示使用Serial垃圾回收器。年轻代会被Serial回收、老年代会被Serial Old回收。</ul><h3 id=1-5-3、Parallel-Scavenge（JDK1-4）><a title="1.5.3、Parallel Scavenge（JDK1.4）" class=headerlink href=#1-5-3、Parallel-Scavenge（JDK1-4）></a>1.5.3、Parallel Scavenge（JDK1.4）</h3><h4 id=简介-15><a class=headerlink href=#简介-15 title=简介></a>简介</h4><p><strong>JDK1.4.2引入Parallel GC，JDK6中成为默认垃圾回收器。</strong><p>Parallel Scavenge收集器工作在<strong>年轻代</strong>，采用<strong>复制算法</strong>，关注吞吐量。与并行收集器一样都是多线程、独占式的收集器。<p>自适应调节策略是Parallel Scavenge与ParNew的一个重要区别。<blockquote><p>如果没有优化，JDK8默认使用Parallel Scavenge和Parallel Old，简称PS+PO。</blockquote><p><strong>注意事项：JDK14之前，Parallel Scavenge和Serial Old可以搭配使用。但JDK14开始废除了这种搭配</strong>。<h4 id=参数-4><a class=headerlink href=#参数-4 title=参数></a>参数</h4><ul><li>-XX:+UseParallelGC：年轻代使用并行回收收集器，老年代使用串行收集器。<li>-XX:+UseParallelOldGC：年轻代和老年代都使用井行垃圾回收器。<li>-XX:ParallelGCThreads：年轻代并行收集器的线程数量。默认当CPU数量小于8时线程数量等于CPU数量。当CPU数量大于8时线程数量值为<code>3 + [5 * cpu数量 / 8]</code>。<li>-XX MaxGCPauseMills：最大垃圾收集停顿时间（单位毫秒），它的值是一个大于0的整数。<li>-XX:+GCTimeRatio：垃圾收集时间占总时间的比例。取值范围为0~100，默认值为99，也就是垃圾回收时间占用不超过1%。与参数<code>-XX MaxGCPauseMills</code>有一定矛盾性。<li>-XX:+UseAdaptiveSizePolicy：开启自适应调节策略。在这种模式下，年轻代的大小、 Eden的比例、晋升老年代的对象年龄等参数会被自动调整，己达到在堆大小、吞吐量和停顿时间之间的平衡点。仅指定虚拟机的最大堆、目标的吞吐量（ GCTimeRatio ）和停顿时间（ MaxGCPauseMills) , 让虚拟机自己完成调优工作。</ul><h3 id=1-5-4、Parallel-Old><a title="1.5.4、Parallel Old" class=headerlink href=#1-5-4、Parallel-Old></a>1.5.4、Parallel Old</h3><h4 id=简介-16><a class=headerlink href=#简介-16 title=简介></a>简介</h4><p><strong>JDK6开始启用Parallel Old垃圾回收器，工作于老年代。它是一种采用标记压缩算法且基于并行回收和“Stop-the-World”机制的关注吞吐量的多线程并发收集器，。</strong><h4 id=如何开启？><a class=headerlink href=#如何开启？ title=如何开启？></a>如何开启？</h4><ul><li>-XX:+UseParallelOldGC：年轻代和老年代中都使用并行回收收集器；<li>-XX :ParallelGCThreads：垃圾回收时的线程数量；</ul><h3 id=1-5-5、ParNew><a class=headerlink href=#1-5-5、ParNew title=1.5.5、ParNew></a>1.5.5、ParNew</h3><h4 id=简介-17><a class=headerlink href=#简介-17 title=简介></a>简介</h4><p><strong>ParNew收集器是Serial收集器的多线程版本。</strong><p>ParNew收集器工作于<strong>年轻代</strong>，采用<strong>复制算法</strong>和<strong>Stop-the-World机制</strong>，并采用井行回收的方式执行内存回收。<p>ParNew是大多数JVM运行在Server模式下新生代的默认垃圾回收器。<p><strong>注意事项：JDK8及之前版本，ParNew和Serial Old可以搭配使用，JDK9开始废除了这种搭配。</strong><h4 id=优缺点-3><a class=headerlink href=#优缺点-3 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>单CPU环境下， ParNew 收集器不见得比 Serial 收集器更高效；<li>ParNew收集器可充分利用多核心CPU的优势，可更快速地完成垃圾收集，提升程序吞吐量；</ol><li>缺点</ul><h4 id=参数-5><a class=headerlink href=#参数-5 title=参数></a>参数</h4><ul><li>-XX:+UseParNewGC：使用 ParNew 收集器；<li>-XX:ParallelGCThreads：并发线程数量，默认与CPU数量相同。</ul><h4 id=ParNew-vs-Paraller-Scavenge><a title="ParNew vs Paraller Scavenge" class=headerlink href=#ParNew-vs-Paraller-Scavenge></a>ParNew vs Paraller Scavenge</h4><ol><li>PN响应时间优先，可配合CMS。<li>PS吞吐量优先。</ol><h3 id=1-5-6、CMS（JDK1-4）><a class=headerlink href=#1-5-6、CMS（JDK1-4） title=1.5.6、CMS（JDK1.4）></a>1.5.6、CMS（JDK1.4）</h3><h4 id=1-5-6-1、简介><a class=headerlink href=#1-5-6-1、简介 title=1.5.6.1、简介></a>1.5.6.1、简介</h4><p>CMS（Concurrent Mark Sweep）采用<strong>标记清除算法和STW机制</strong>，它可以确保工作线程和垃圾回收线程同时工作，拥有低延迟等特点。<p><font color=red>注意：HotSpot 中， 除了 CMS收集器外的任何老年代垃圾收集器都会执行Full GC，只有G1收集器较为特殊。</font><p><strong>注意事项：JDK 1.4.2引入CMS，JDK 14中删除了CMS</strong>。<h4 id=1-5-6-2、回收过程><a class=headerlink href=#1-5-6-2、回收过程 title=1.5.6.2、回收过程></a>1.5.6.2、回收过程</h4><p>CMS垃圾回收器的工作过程如下：<p><img alt=image-20240219151141264 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2024/02/19/image-20240219151141264.png><ol><li><strong>初始标记</strong>：<strong>STW</strong>暂停应用线程，<strong>单线程</strong>标记GC Roots能直接关联到的对象，标记完成后，恢复应用程序线程的运行。因直接关联对象比较小，故该阶段<strong>速度很快</strong>。<li><strong>并发标记</strong>：应用线程和垃圾回收线程<strong>同时工作</strong>，垃圾回收线程从GC Roots直接关联的对象开始遍历整个对象图。并发标记过程是应用线程和垃圾回收线程同时工作，故会出现垃圾对象漏标的情况（前一秒还不是垃圾，后一秒就变成了垃圾，反之亦然），此时就需要通过重新标记阶段来尽可能的标记这些漏标的垃圾对象。<li><strong>重新标记</strong>：<strong>STW</strong>停止应用线程，使用<strong>多线程</strong>对起死回生对象、漏标对象 进行重新标记。<li><strong>并发清理</strong>：应用线程和垃圾回收线程<strong>多线程同时工作</strong>，垃圾回收线程清理标记阶段已找出来的垃圾对象。因与应用线程一起执行，故该阶段会产生浮动垃圾。</ol><h4 id=1-5-6-3、优缺点><a class=headerlink href=#1-5-6-3、优缺点 title=1.5.6.3、优缺点></a>1.5.6.3、优缺点</h4><p>CMS优点：<strong>并发收集、低延迟</strong>。<p>CMS存在如下缺点：<ul><li><p><strong>会产生内存碎片</strong>：并发清理后存在内存碎片，可用空间不足会导致提前触发FULL GC。</p><li><p><strong>对CPU资源较敏感</strong>：并发执行占用了一部分的资源导致程序一定程度上变慢，总吞吐量会降低。</p><li><p><strong>无法处理浮动垃圾</strong>：应用线程与垃圾回收线程同时运行，期间可能出现前一秒不是垃圾对象，后一秒成了垃圾对象的现象，这种现象产生的垃圾称为浮动垃圾。并发标记阶段出现的浮动垃圾，可能不会在本次GC过程中被回收。</p></ul><p><font color=red>注意：CMS无法处理时会采用 单线程Serial Old收集器 进行标记压缩，速度会非常慢。</font><h4 id=1-5-6-4、参数><a class=headerlink href=#1-5-6-4、参数 title=1.5.6.4、参数></a>1.5.6.4、参数</h4><ul><li><strong>-XX:+UseConcMarkSweepGC</strong>：使用 CMS 收集器。开启该参数时会自动开启参数-XX:+UserParNewGC，最终的组合就是年轻代使用ParNew，老年代使用CMS和Serial Old。<li><strong>-XX:CMSInitiatingOccupanyFraction</strong>：堆内存使用率达到该阈值会触发垃圾回收。JDK5及之前版本默认值为68，即堆内存使用率达到68%时触发一次垃圾回收。JDK6及之后版本默认值为92。<li><strong>-XX:+UseCMSInitiatingOccupancyOnly</strong>： 只使用设定的回收阈值(-XX:CMSInitiatingOccupanyFraction值)。如果不开启该功能，则JVM仅在第一次使用设定值，后续会自动调整；<li><strong>-XX:+UseCMSCompactAtFullCollection</strong>：执行完Full GC后是否对内存进行压缩，压缩可避免内存碎片但停顿时间会更长。<li><strong>-XX:CMSFullGCsBeforeCompaction</strong>：执行多少次Full GC后对内存进行压缩。<li><strong>-XX:ParallelCMSThreads</strong>：CMS线程数量。默认线程数量为**(ParallelGCThreads + 3) / 4**，</ul><h4 id=1-5-6-5、卡表的使用><a class=headerlink href=#1-5-6-5、卡表的使用 title=1.5.6.5、卡表的使用></a>1.5.6.5、卡表的使用</h4><p>Card Table 在 CMS GC 中有使用，使用一块区域用来记录老年代中的每个 Card 指向新生代的引用（<code>points-out</code> 结构），YGC执行时会将该区域的对象作为 GC roots，而不需要扫描整个老年代。<p>并发标记时，如果某个对象的引用发生了变化，那么标记该对象所在的 Card 为 Dirty Card（通过 write-barrier）。在重新标记时，只需要重新扫描 Dirty Cards 即可，同时清除 Dirty 标记。<h3 id=1-5-7、G1（JDK7）><a class=headerlink href=#1-5-7、G1（JDK7） title=1.5.7、G1（JDK7）></a>1.5.7、G1（JDK7）</h3><h4 id=1-5-7-1、简介><a class=headerlink href=#1-5-7-1、简介 title=1.5.7.1、简介></a>1.5.7.1、简介</h4><p><strong>G1是一款服务器式垃圾回收器，适用于大内存多处理器的服务器。尽可能满足设定的垃圾回收目标，同时提高吞吐量。</strong><p>如果你的应用程序符合以下几点，那么使用G1将变得非常合适：<ul><li>超过50%的堆内存被实时数据占用。<li>对象分配率和晋升率有很大差异。</ul><p>G1有如下特点：<ol><li><strong>并发收集；</strong><li><strong>压缩空闲空间不会延长GC暂停时间</strong>；<li><strong>更易预测的GC暂停时间</strong>；<li><strong>适用于 低吞吐量 场景</strong>；</ol><blockquote><p>JDK 1.7u4中引入G1。<p>JDK9（JEP248）开始，G1成为默认垃圾收集器。<p>JDK12中增强了G1。</blockquote><h4 id=1-8-7-2、Region><a class=headerlink href=#1-8-7-2、Region title=1.8.7.2、Region></a>1.8.7.2、Region</h4><p><strong>G1 会把整个 Java 堆划分为不超过2048个大小独立的Region，每个 Region 大小要满足2的N次幂，范围在1MB-32MB 之间</strong>。Region的大小在 JVM 生命周期内不会被改变。<p>每一个Region在逻辑上属于某一个分代，该分代分为四种：<ol><li><strong>Eden区存放新对象</strong>；<li><strong>Survivor区放存活对象</strong>；<li><strong>old区存放老对象</strong>；<li><strong>Humongoous区存放大对象</strong>；（G1中通常会将H区作为老年代的一部分来看待。）</ol><blockquote><p>G1内存区域不是固定的E或O。G1新老年代比例动态变化无需显式指定，因为G1有预测停顿时间的基准。G1会跟踪每一次STW，据此动态设置各个Region的大小。<p><strong>超过Region一半大小的对象称为大对象</strong>。如果一个H区无法容纳一个大对象，那么会使用连续的H区来存储这个大对象。为了能找到连续的H区，有时不得不执行Full GC。G1不会复制巨型对象，巨型对象没有被引用时会在YGC阶段被回收。</blockquote><h4 id=1-5-7-4、GC回收过程><a class=headerlink href=#1-5-7-4、GC回收过程 title=1.5.7.4、GC回收过程></a>1.5.7.4、GC回收过程</h4><p>G1垃圾回收过程图示如下：<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-1.1-G1-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.png><h5 id=YGC阶段（标记复制-STW）><a title="YGC阶段（标记复制 / STW）" class=headerlink href=#YGC阶段（标记复制-STW）></a>YGC阶段（标记复制 / STW）</h5><p>创建好的对象先放到Eden区，<strong>当所有Eden区都满了，G1会启动一次年轻代垃圾回收</strong>：先停止应用线程（Stop-The-World），然后创建回收集（Collection Set），再将要被回收的内存放到回收集中，最终执行回收操作。<p><font color=red>注意</font>：YGC只会回收Eden区和Survivor区。回收集是指需要被回收的内存分段的集合，年轻代回收集包含年轻代Eden区和Survivor区所有的内存分段。<p>年轻代回收过程如下：<ol><li>根扫描：扫描根对象。根指的是静态变量指向的对象，正在执行的方法链条上的局部变量等。根引用和RSet记录的外部引用将作为扫描存活对象的入口。<li>更新RS：处理Dirty Card队列，更新RS。（RS可以反映老年代中的对象对年轻代对象的引用情况）<li>处理RS：识别老年代对象对Eden区中对象的引用，被指向的Eden区对象都被认为是存活对象。<li>对象拷贝：将Eden中的存活对象复制到Survivor中，Survivor中存活对象复制到其它空闲的Survivor中，且年龄未达阈值则将年龄加1，达到阈值则复制到老年代中。<strong>如果Survivor空间不足，Eden中部分数据会直接晋升至老年代</strong>。<li>处理引用：处理软引用，弱引用，虚引用、Final等引用。最终Eden中空间为空，GC停止，目标内存中对象连续，没有内存碎片，所以复制过程可以达到整理内存的效果。</ol><h5 id=并发标记><a class=headerlink href=#并发标记 title=并发标记></a>并发标记</h5><p><strong>年轻代回收后或 houmongous对象 分配后会检测当前堆内存使用情况，当堆内存（包括老年代和新生代）使用率达到参数<code>-XX:InitiatingHeapOccupancyPercent</code>（默认是45%）设置的百分比时会触发老年代回收。</strong><p><strong>老年代回收过程：垃圾回收线程与应用线程并发执行，垃圾回收线程会标记老年代的存活对象，因与应用程序线程并发执行，故会存在指针引用错误的情况。</strong>G1处理对象丢失的方法是使用 开始时快照技术（SATB，Snapshot At The Begging），这种技术会造成某些垃圾对象也被当做是存活对象，所以G1占用的内存比实际需要的内存要大。<p>并发标记过程如下：<ol><li><p>初始标记（STW）：<strong>STW</strong>停止应用线程，垃圾回收线程标记根节点直接可达的对象。该阶段会触发一次YGC。</p><li><p>根区域扫描：扫描Survivor区直接可达的老年代对象，并标记被引用的对象。<strong>该过程必须在YGC之前完成</strong>。</p><li><p>并发标记：<strong>应用线程与垃圾回收线程并发执行</strong>，垃圾回收线程标记可关联到的对象。<strong>并发标记阶段，若区域中的对象都是垃圾，那么该区域会被立即回收</strong>。同时会计算每个区域对象的活性（区域中存活对象的比例）。要注意的是，<strong>该过程可能被YGC中断</strong>。</p><li><p>再次标记（STW）：<strong>STW</strong>停止应用线程，垃圾回收线程再次标记可能遗漏的垃圾对象。因并发标记阶段中，应用线程和垃圾回收线程并发执行，故会存在漏标的垃圾对象，再次标记阶段就是为了尽可能找出这些漏标的垃圾对象。G1采用SATB（开始时快照技术）算法来尽快尽可能的找到这些漏标的垃圾对象。</p><li><p>独占清除（STW）：<strong>STW</strong>停止应用线程，计算各个区域存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。该阶段不会执行垃圾收集。</p><li><p>并发清理：识别并清理完全空闲的区域。</p></ol><h5 id=混合回收（Mixed-GC）><a title="混合回收（Mixed GC）" class=headerlink href=#混合回收（Mixed-GC）></a>混合回收（Mixed GC）</h5><p><strong>对象晋升到老年代Region后，为避免堆内存被耗尽，会触发一次混合回收（Mixed GC）。</strong>混合回收逻辑：<strong>回收整个年轻代和一部分老年代，至于回收多少老年代region，与设定的垃圾回收时间参数有关</strong>。<p>为满足设定的垃圾回收时间，虚拟机会自动选择或多或少的的老年代进行回收。可以被回收的老年代region，其实在并发标记阶段中的独占清理阶段已经按优先级排序过了，垃圾回收器在回收这些老年代region时，只需根据设定的垃圾回收时间和回收耗时来自动选择回收多少优先级较高的老年代region合适，以至于不超过设定的垃圾回收耗时。<p><strong>并发标记结束以后，老年代中百分百为垃圾的内存被回收了，部分为垃圾的内存也计算了出来。</strong><ul><li>-XX:G1MixedGCCountTarget：该参数表示 老年代内存分段会分多少次来回收，默认8次。<li>-XX:G1MixedGCLiveThresholdPercent：表示垃圾占内存分段比例要达到该参数值设定的百分比时才会被回收，默认为65%。垃圾占内存分段比例越高的，越优先被回收。<strong>老年代、Eden、Survivor from区中要被回收的内存分段合起来称为Collection Set，也即 回收集合</strong>。混合回收集（Collection Set）包括八分之一的老年代内存分段、Eden区内存分段、Survivor区内存分段，下次mixed GC 的evacuation阶段会把他们都一并清理。混合回收的算法和年轻代完全一样，只是回收集多了老年代的内存分段。混合回收并不一定要进行8次。具体执行逻辑与参数<code>-XX:G1HeapWastePercent</code>有关，详情如下。<li>-XX:G1HeapWastePercent：默认为10%，表示允许浪费整个堆内存10%的空间。也就是说 若垃圾占堆内存的比例低于10%，就不再执行混合回收，因为性价比很低。</ul><p><font color=red>注意：Mixed GC 并不是 Full GC。G1 GC回收足够数量的老年代区域 (通过多次混合回收) 后，G1将恢复到年轻代回收、全局并发标记、混合回收，以此逻辑循环执行。</font><h5 id=FGC><a class=headerlink href=#FGC title=FGC></a>FGC</h5><p>G1初衷是避免Full GC出现，但如果G1工作过程中出现问题，不能正常工作时会停止应用程序，使用单线程Serial收集器来完成垃圾清理工作，性能会非常差。<p>导致Full GC的原因有两个：<ul><li><em><strong>Evacuation时没有足够的to-space来存放晋升对象</strong></em>。<li><em><strong>并发处理过程完成之前空间耗尽</strong></em>。</ul><h4 id=1-5-7-5、三色标记算法><a class=headerlink href=#1-5-7-5、三色标记算法 title=1.5.7.5、三色标记算法></a>1.5.7.5、三色标记算法</h4><p>并发标记使用的是三色标记算法。它是描述追踪式回收器的一种有效方法，利用它可以推演回收器的正确性。 三色标记会将对象分成三种类型：<ul><li><strong>黑色</strong>：根对象，或者该对象与它的子对象都被扫描过。<li><strong>灰色</strong>：对象本身已被扫描过，但该对象的子对象还没有扫描。<li><strong>白色</strong>：未扫描过的对象，扫描完所有对象之后，最终为白色的就是不可达对象，即为垃圾对象。</ul><h4 id=1-5-7-8、G1优化><a class=headerlink href=#1-5-7-8、G1优化 title=1.5.7.8、G1优化></a>1.5.7.8、G1优化</h4><p>优化和注意事项分析如下：<ul><li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小。固定年轻代大小会覆盖暂停时间目标。<li>评估G1 GC吞吐量时，暂停时间目标不需要太严格，否则会直接影响吞吐量。</ul><h4 id=1-5-7-9、参数><a class=headerlink href=#1-5-7-9、参数 title=1.5.7.9、参数></a>1.5.7.9、参数</h4><ul><li>-XX:+UseG1GC：使用G1垃圾回收器。<li>-XX:G1HeapRegionSize：每个Region的大小。值是2的幂，范围1m~32m之间。目标是根据最小Java堆大小划分出约2048个区域，默认是堆内存的1/2000。<li>-XX:MaxGCPauseMillis：最大GC停顿时间指标。默认200ms。<li>-XX:ParallelGCThread：STW工作线程的数量，最多8个。<li>-XX:ConcGCThreads：并发标记的线程数量。建议该值为并行垃圾回收线程数量(ParallelGCThreads)的1/4左右。<li>-XX:InitiatingHeapOccupancyPercent：触发并发GC周期的堆占用率阈值。默认是45。</ul><h4 id=1-5-7-10、G1特有功能><a class=headerlink href=#1-5-7-10、G1特有功能 title=1.5.7.10、G1特有功能></a>1.5.7.10、G1特有功能</h4><h5 id=字符串去重><a class=headerlink href=#字符串去重 title=字符串去重></a>字符串去重</h5><p><strong>JDK8u20版本中，G1除了回收垃圾外，对字符串去重做了优化</strong>。G1会把所有新分配的字符串放入一个队列，当G1在回收年轻代时，会检查队列中是否存在重复字符串，如果存在重复的字符串，那么会让它们引用同一个char[]。<p>G1的这种优化与String.intern()不一样。String的intern关注的是字符串对象，而G1字符串去重关注的是char[]，在JVM内部使用了不同的字符串表。<h5 id=类卸载><a class=headerlink href=#类卸载 title=类卸载></a>类卸载</h5><p>并发标记工作执行完后，就可以确定哪些类不再使用。当一个类加载器加载的所有类不再使用时，就会卸载这些类。<p>通过参数<code>-XX:+ClassUnloadingWithConcurrentMark</code>可以开启自动检测类卸载功能。该功能默认开启。<h5 id=回收巨型对象><a class=headerlink href=#回收巨型对象 title=回收巨型对象></a>回收巨型对象</h5><p>对于G1中的巨型对象，G1不会对之进行拷贝，但回收时会被优先考虑。G1会跟踪老年代中对象对巨型对象的引用，当老年代中没有对象引用巨型对象时，<strong>G1会在新生代垃圾回收时处理掉关联的巨型对象</strong>。<h5 id=动态并发标记><a class=headerlink href=#动态并发标记 title=动态并发标记></a>动态并发标记</h5><p><strong>G1中的并发标记过程必须在堆空间被使用完前完成，否则会退化为FGC</strong>。<p>JDK9之前，可以通过参数<code>-XX:InitiatingHeapOccupancyPercent</code>来固定触发并发标记的阈值。该参数表示当所有老年代区占整个堆内存空间的比例达到该参数设置的百分比时就会触发执行并发标记工作。<p>JDK9开始可以实现自动调整这个触发阈值。要注意的是，仍然可以使用该参数设置初始触发阈值，但后期会通过数据采样来动态调整触发阈值。<h3 id=1-5-8、ZGC-（JDK11）><a title="1.5.8、ZGC （JDK11）" class=headerlink href=#1-5-8、ZGC-（JDK11）></a>1.5.8、ZGC （JDK11）</h3><h4 id=1-5-8-1、简介><a class=headerlink href=#1-5-8-1、简介 title=1.5.8.1、简介></a>1.5.8.1、简介</h4><h5 id=概述><a class=headerlink href=#概述 title=概述></a>概述</h5><p><strong>JDK11开始，加入了一款实验性质的可扩展低延迟垃圾收集器，即ZGC。目前仅支持Linux/x86-64。ZGC收集器是一款基于Region内存布局，（暂时）不设分代，使用读屏障、染色指针和内存多重映射等技术来实现可并发的标记整理算法，首要目标是实现低延迟。</strong><p>ZGC旨在实现以下几个目标：<ul><li>暂停时间不超过10毫秒。<li>暂停时间不会随着堆的增大或存活集的变多而增加。<li>可处理几百兆到几TB大小的堆。<li>与使用 G1 相比，应用程序吞吐量降低不超过 15%。<li>利用彩色指针和负载屏障为未来的GC功能和优化奠定基础。</ul><blockquote><p>JDK11环境下，使用ZGC需要两个参数：<code>-XX:+UnlockExperimentalVMOptions</code>和<code>-XX:+UseZGC</code>结合使用。该版本的ZGC存在如下一些限制：<ul><li>仅在linux/x64上可用。<li>不支持使用压缩的 oops 和/或压缩的类点。默认情况下， <code>-XX:+UseCompressedOops</code> 和 <code>-XX:+UseCompressedClassPointers</code> 选项处于禁用状态。启用它们将不起作用。<li>不支持类卸载。默认情况下， <code>-XX:+ClassUnloading</code> 和 <code>-XX:+ClassUnloadingWithConcurrentMark</code> 选项处于禁用状态。启用它们将不起作用。<li>不支持将 ZGC 与 Graal 结合使用。</ul><p>JDK11（JEP333）中引入ZGC。JDK13中增强ZGC。<p>JDK14（JEP364）提供了支持macOS系统的实验版ZGC，JDK14（JEP365）提供了支持Windows系统的实验版ZGC。<p>JDK15（JEP377）开始，ZGC可用于生产环境，直接使用一个参数<code>XX:+UseZGC</code>就可以使用ZGC。此JEP不建议更改默认GC，它仍然是G1。<p>JDK21（JEP439）提出了分代ZGC，且计划后期会作为默认配置。</blockquote><h5 id=分代ZGC><a class=headerlink href=#分代ZGC title=分代ZGC></a>分代ZGC</h5><p><strong>JDK21（JEP439）提出了分代ZGC，且计划后期会作为默认配置</strong>。分代ZGC可降低分配停滞的风险、降低堆内存开销、降低垃圾回收CPU开销。除此外，不需要手动配置分代大小、垃圾回收线程数量、对象在年轻代的存活时长。要使用分代ZGC，需要使用两个参数<code>-XX:+UseZGC</code>和<code>-XX:+ZGenerational</code>。<p>分代 ZGC 将堆分为两个逻辑代：年轻一代用于最近分配的对象，而老一代用于长期存在的对象。每一代都是独立收集的，因此ZGC可以专注于收集有利可图的年轻对象。<p>非分代 ZGC 同时使用彩色指针和负载屏障。分代 ZGC 还使用存储屏障来有效地跟踪从一代对象到另一代对象的引用。<h4 id=1-5-8-2、内存布局><a class=headerlink href=#1-5-8-2、内存布局 title=1.5.8.2、内存布局></a>1.5.8.2、内存布局</h4><p><strong>ZGC采用了与G1类似的Region堆内存布局，但ZGC中的称为ZPage，ZPage具有动态性（动态的创建和销毁，以及动态的区域容量大小）</strong>。<p>ZGC的Region可以分为三类：<ul><li>小型Region：容量固定为2MB，用于放置小于256KB的小对象。<li>中型Region：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。<li>大型Region：容量不固定，可以动态变化，但必须为2MB的整数倍，用于存放4MB或以上的大对象。并且<strong>每个大型Region只会存放一个对象</strong>。</ul><h4 id=1-5-8-3、染色指针><a class=headerlink href=#1-5-8-3、染色指针 title=1.5.8.3、染色指针></a>1.5.8.3、染色指针</h4><h5 id=简介-18><a class=headerlink href=#简介-18 title=简介></a>简介</h5><p>HotSpot的垃圾收集器，有几种不同的标记实现方案。<ul><li>把标记直接记录在对象头上（Serial 收集器）。<li>把标记记录在与对象相互独立的数据结构上（G1、Shenandoah使用了一种相当于堆内存的1/64大小的BitMap结构来记录标记信息）。<li><strong>ZGC染色指针直接把标记信息记录到引用对象的指针上</strong>。</ul><p>染色指针是一种直接<strong>将少量额外信息存储在指针上的技术</strong>。目前Linux下64位指针的高18位暂不使用，低42位用来寻址4T空间，43、44、45、46位用来标记对象的不同状态。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/ZGC%E9%A2%9C%E8%89%B2%E6%8C%87%E9%92%8801.png><p>ZGC将使用剩下46位的高4位来存储四个标志信息：<ol><li>Marked0：对象被标记为存活对象，并涂抹一种颜色。<li>Marked1：对象被标记为存活对象，涂抹另一种颜色，用于区分不同的垃圾回收周期。<li>Remapped：是否进入了重分配集。<li>Finalizable：是否只能通过finalize()方法才能被访问到。</ol><p><font color=red>注意：标志位占用4位，剩余42位可寻址4TB内存空间，所以ZGC能够管理的内存不能超过4TB。</font><h5 id=特点-1><a class=headerlink href=#特点-1 title=特点></a>特点</h5><ul><li><strong>染色指针可以确保某个Region的存活对象被移走之后，该Region会立即被释放和重用掉</strong>，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。<li><strong>染色指针可以减少在垃圾收集过程中内存屏障的使用数量</strong>。因为读、写内存屏障的主要目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。<li>染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</ul><h4 id=1-5-8-4、读屏障><a class=headerlink href=#1-5-8-4、读屏障 title=1.5.8.4、读屏障></a>1.5.8.4、读屏障</h4><p><strong>当从堆中加载对象时，就会使用读屏障（Load Barrier）</strong>。读屏障的主要作用就是<strong>检查指针上的三色标记位，根据标记位判断出对象是否被移动过，如果没有则可以直接访问，如果移动过就需要进行“自愈”</strong>。自愈会使对象访问变慢，但“自愈”完成后访问就会变快。<blockquote><p>当读取处于重分配集的对象时，会被读屏障拦截，通过 转发表记录 将访问转发到新复制对象上，并同时修正更新该引用的值，使其直接指向新对象。ZGC将这种行为叫做指针的“自愈能力”。</blockquote><h4 id=1-5-8-5、内存多重映射><a class=headerlink href=#1-5-8-5、内存多重映射 title=1.5.8.5、内存多重映射></a>1.5.8.5、内存多重映射</h4><h5 id=简介-19><a class=headerlink href=#简介-19 title=简介></a>简介</h5><p><strong>Linux/x86-64平台上ZGC使用了多重映射（Multi-Mapping），将多个不同的虚拟内存地址映射到同一物理内存地址上，这是一种多对一映射，意味着ZGC在虚拟内存中看到的地址空间要比实际的堆内存容量更大</strong>。把染色指针中的标志位看作是地址的分段符，那只要将这些不同的地址段都映射到同一物理内存空间，经过多重映射转换后，就可以使用染色指针进行正常寻址。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/ZGC%E5%86%85%E5%AD%98%E5%A4%9A%E9%87%8D%E6%98%A0%E5%B0%8401.png><h4 id=1-5-8-6、ZGC工作过程><a class=headerlink href=#1-5-8-6、ZGC工作过程 title=1.5.8.6、ZGC工作过程></a>1.5.8.6、ZGC工作过程</h4><p>ZGC工作过程大致可划分为以下四个阶段。四个阶段都可以并发执行，只不过两个阶段中间会存在短暂的小阶段停顿。<p><img alt=ZGC运行过程 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/ZGC%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B01><ol><li>并发标记（Concurrent Mark）：与G1、Shenandoah一样，<strong>并发标记是遍历对象图做可达性分析的阶段</strong>，前后也要经过类似于G1、Shenandoah的初始标记、最终标记的短暂停顿，而且这些停顿阶段所做的事情在目标上也是类似的。<li>并发预备重分配（ Concurrent Prepare for Relocate）：根据特定查询条件统计<strong>得到本次收集过程要清理的Region，并将这些Region组成重分配集（Relocation Set）</strong>。<li>并发重分配（Concurrent Relocate）：重分配是核心阶段，这个过程<strong>会把重分配集中的存活对象复制到新Region上，并为重分配集中的每个Region维护一个转发表（Forward Table）,记录从旧对象到新对象的转向关系</strong>。<li>并发重映射（Concurrent Remap）：<strong>重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用</strong>，并发映射并不是一个必须要“迫切”去完成的任务。ZGC会巧妙地把该阶段要做的工作合并到下一次垃圾收集循环中的并发标记阶段中去完成，反正都要遍历所有对象，这样合并后反而节省了一次遍历开销。</ol><h4 id=1-5-8-7、ZGC优缺点><a class=headerlink href=#1-5-8-7、ZGC优缺点 title=1.5.8.7、ZGC优缺点></a>1.5.8.7、ZGC优缺点</h4><h5 id=优点（高吞吐量、低延迟）><a class=headerlink href=#优点（高吞吐量、低延迟） title=优点（高吞吐量、低延迟）></a>优点（高吞吐量、低延迟）</h5><p><strong>ZGC支持<code>NUMA-Aware</code>内存分配</strong>。NUMA（Non-Uniform Memory Access，非统一内存访问架构）是一种多处理器或多核处理器计算机所设计的内存架构。<p>现在多CPU插槽的服务器都是Numa架构，比如两颗CPU插槽(24核)，64G内存的服务器，那一颗CPU 12个核，访问从属于它的32G本地内存，要比访问另外32G远端内存要快得多。<p>ZGC默认支持NUMA架构，在创建对象时，根据当前线程在哪个CPU执行，优先在靠近这个CPU的内存进行分配，这样可以显著的提高性能，在SPEC JBB 2005 基准测试里获得40%的提升。<h5 id=缺点（浮动垃圾）><a class=headerlink href=#缺点（浮动垃圾） title=缺点（浮动垃圾）></a>缺点（浮动垃圾）</h5><p>当ZGC准备要对一个很大的堆做一次完整的并发收集，则全过程要持续十分钟以上，由于应用的对象分配速率很高，将创造大量的新对象，这些新对象很难进入当次收集的标记范围，通常就只能全部作为存活对象来看待（尽管其中绝大部分对象都是朝生夕灭），这就<strong>产生了大量的浮动垃圾</strong>。<p>目前唯一的办法就是尽可能地去增加堆容量大小，获取更多喘息的时间。但若要从根本上解决，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后针对这个区域进行更频繁、更快的收集。<strong>庆幸的是，JDK21中提出了ZGC的分代垃圾收集</strong>。<h3 id=1-5-9、Epsilon（JDK11）><a class=headerlink href=#1-5-9、Epsilon（JDK11） title=1.5.9、Epsilon（JDK11）></a>1.5.9、Epsilon（JDK11）</h3><h4 id=1-5-9-1、简介><a class=headerlink href=#1-5-9-1、简介 title=1.5.9.1、简介></a>1.5.9.1、简介</h4><p>JDK 11中的JEP 318添加了一个名为Epsilon的垃圾回收器。<strong>Epsilon（A No-Op Garbage Collector）只负责分配内存不做任何垃圾回收操作</strong>。当堆内存空闲空间不足时会自动触发与<code>OutOfMemoryError</code>相关的处理。<h4 id=1-5-9-2、目标><a class=headerlink href=#1-5-9-2、目标 title=1.5.9.2、目标></a>1.5.9.2、目标</h4><p>Epsilon回收器设计目的或初衷：<ol><li>性能测试：测试应用在没有GC干预情况下的性能。<li>短生命周期应用：对于生命周期较短的应用，没有垃圾回收也是可以接受的。<li>内存管理：自己来管理内存。</ol><h4 id=1-5-9-3、使用场景><a class=headerlink href=#1-5-9-3、使用场景 title=1.5.9.3、使用场景></a>1.5.9.3、使用场景</h4><ul><li>Performance testing：什么都不执行的GC非常适合用于差异性分析。no-op GC可以用于过滤掉GC诱发的新能损耗，比如GC线程的调度，GC屏障的消耗，GC周期的不合适触发，内存位置变化等。此外有些延迟者不是由于GC引起的，比如scheduling hiccups, compiler transition hiccups，所以去除GC引发的延迟有助于统计这些延迟。<li>Memory pressure testing：在测试java代码时，确定分配内存的阈值有助于设置内存压力常量值。这时no-op就很有用，它可以简单地接受一个分配的内存分配上限，当内存超限时就失败。例如：测试需要分配小于1G的内存，就使用-Xmx1g参数来配置no-op GC，然后当内存耗尽的时候就直接crash。<li>VM interface testing：以VM开发视角，有一个简单的GC实现，有助于理解VM-GC的最小接口实现。它也用于证明VM-GC接口的健全性。<li>Extremely short lived jobs： 一个短声明周期的工作可能会依赖快速退出来释放资源，这个时候接收GC周期来清理heap其实是在浪费时间，因为heap会在退出时清理。并且GC周期可能会占用一会时间，因为它依赖heap上的数据量。<li>Last-drop latency improvements：对那些极端延迟敏感的应用，开发者十分清楚内存占用，或者是几乎没有垃圾回收的应用，此时耗时较长的GC周期将会是一件坏事。<li>Last-drop throughput improvements：即便对那些无需内存分配的工作，选择一个GC意味着选择了一系列的GC屏障，所有的OpenJDK GC都是分代的，所以他们至少会有一个写屏障。避免这些屏障可以带来一点点的吞吐量提升。</ul><h4 id=1-5-9-4、相关描述><a class=headerlink href=#1-5-9-4、相关描述 title=1.5.9.4、相关描述></a>1.5.9.4、相关描述</h4><p>通过参数<code>-XX:+UseEpsilonGC</code>可以开启Epsilon GC。<p>Epsilon GC通过在分配内存的单个连续块中实现线性分配来工作。这样就可以在GC中轻松实现无锁TLAB（线程本地分配缓冲区）发行代码，然后可以重用现有VM代码处理的无锁TLAB内部分配。发出TLAB还有助于使驻留内存占用的进程受实际分配的内存限制。大量/超出TLAB的分配由同一代码处理，因为在此方案中分配TLAB与分配大对象之间几乎没有区别。<p>Epsilon使用的障碍集完全为空/无操作，因为GC不执行任何GC循环，因此不关心对象图，对象标记，对象复制等。引入一种新的障碍集实现是可能是此实现中最具破坏性的JVM更改。<p>由于Epsilon的运行时接口的唯一重要部分是发布TLAB的时间，因此其延迟很大程度上取决于所发布的TLAB的大小。对于任意大的TLAB和任意大的堆，延迟开销可以由任意低的正值（因此称为名称）来描述。（替代起源故事：“ epsilon”通常表示“空符号”，与该GC的禁止操作性保持一致）。<p>Java堆耗尽就不可能进行分配，也不能进行内存回收。此时有几种选择：<ul><li>抛出一条带有描述性信息的<code>OutOfMemoryError</code>异常消息。<li>执行堆转储（启用<code>-XX:+HeapDumpOnOutOfMemoryError</code>）<li>关闭JVM，并有选择地执行外部操作（通常操作<code>-XX:OnOutOfMemoryError=...</code>），例如，启动调试器或向外部监视系统通知该失败。</ul><h3 id=1-5-10、Shenandoah><a class=headerlink href=#1-5-10、Shenandoah title=1.5.10、Shenandoah></a>1.5.10、Shenandoah</h3><p>待补充。<h3 id=1-5-11、总结><a class=headerlink href=#1-5-11、总结 title=1.5.11、总结></a>1.5.11、总结</h3><h4 id=1-5-11-1、垃圾收集器对比><a class=headerlink href=#1-5-11-1、垃圾收集器对比 title=1.5.11.1、垃圾收集器对比></a>1.5.11.1、垃圾收集器对比</h4><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-1.2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93.png><p><img alt=image-20210315120311771 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210315120311771.png><h4 id=1-5-11-2、注意事项><a class=headerlink href=#1-5-11-2、注意事项 title=1.5.11.2、注意事项></a>1.5.11.2、注意事项</h4><p>JEP173（JDK8）开始，不推荐使用的垃圾回收器组合：DefNew+CMS、ParNew+Serial Old、Incremental CMS。<p>JEP214（JDK9）中删除了JEP173中就已经不推荐的垃圾回收器组合，推荐使用ParallelScavenge+Serial Old组合。<p>JEP248（JDK9）中，将G1设为32位和64位服务器环境下的默认垃圾回收器。<p>JEP291（JDK9）中宣布弃用CMS垃圾回收器。JEP363（JDK14）中删除了CMS垃圾回收器。<p>JEP318（JDK11）中提出了<strong>实验性质</strong>的无操作垃圾回收器<strong>Epsilon</strong>。<p>JEP333（JDK11）中提出了<strong>实现性质</strong>的可扩展低延迟垃圾回收器<strong>ZGC</strong>。JDK14（JEP364）提供了支持macOS系统的实验版ZGC，JDK14（JEP365）提供了支持Windows系统的实验版ZGC。<h2 id=1-6、漏标问题><a class=headerlink href=#1-6、漏标问题 title=1.6、漏标问题></a>1.6、漏标问题</h2><h3 id=1-9-1、认识漏标><a class=headerlink href=#1-9-1、认识漏标 title=1.9.1、认识漏标></a>1.9.1、认识漏标</h3><p>CMS和G1的核心就是垃圾回收线程和应用线程同时执行，而该阶段会产生“漏标”问题。<p>问题：<strong>GC标记阶段中如果删除了所有灰色到白色的引用，且黑色指向了白色，则此时不对黑色对象的子对象进行重新扫描，就会出现漏标现象，会把白色对象当作垃圾被回收</strong>。<h3 id=1-9-2、解决漏标><a class=headerlink href=#1-9-2、解决漏标 title=1.9.2、解决漏标></a>1.9.2、解决漏标</h3><p><strong>（1）增量更新（Increment Update）</strong><p><img alt=image-20210314213906184 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210314213906184.png><p>如上图所示，若A指向D时，跟踪这个引用，并把A标记为灰色，下次扫描时就会重新扫描A的子对象D，这就叫做增量更新。<p>特点：<strong>当产生新标记后，关注引用的增加，CMS采用 增量更新+写屏障 解决了漏标问题</strong>。<p><strong>（2）SATB（snapshot at the beginning）</strong><p><img alt=image-20210314214048813 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210314214048813.png><p>如上图所示，刚开始做一个快照，当B和D之间的引用消失时要把这个引用推到GC的堆栈，保证D能够被扫描到。如果某一个引用消失了，会把白色对象放到GC堆栈中，下次扫描时直接扫描白色对象即可，这样白色就不会漏标了。<p>SATB有三个工作步骤：<ol><li>在开始标记时生成一个快照图，用来标记存活对象。<li>在并发标记时所有被改变的对象将会被加入到队列（在write barrier里把所有旧的引用所指向的对象都变成非白的）。<li>可能存在游离垃圾，将在下次被收集。</ol><p>特点：<strong>当引用被删除后，关注引用的删除，G1用 SATB+写屏障 解决了漏标问题</strong>。<blockquote><p>SATB 算法通过创建一个对象图的方式完成堆内存逻辑上的快照，即将堆内存里所有需要回收的对象全部呈现在它的这张对象图上，这个标记过程在并行标记阶段完成 。<p>SATB 算法维护的标记内容在数据结构上也分为两块， 一块是已经完成的标记，另一块是即将进行的标记。</blockquote><h3 id=1-9-3、总结><a class=headerlink href=#1-9-3、总结 title=1.9.3、总结></a>1.9.3、总结</h3><p>灰色指向白色的引用消失时，如果没有黑色指向白色，则该引用会直接被push到堆栈，下次扫描时，由于RSet的存在，不需要扫描整个堆去查找指向白色的引用，效率比较高。<blockquote><p>G1为什么使用SATB而不使用incremental update？因为如果使用增量更新，那么变成灰色后还要重新扫描，效率太低。</blockquote><h1 id=2、JVM参数><a class=headerlink href=#2、JVM参数 title=2、JVM参数></a>2、JVM参数</h1><h2 id=2-1、简介><a class=headerlink href=#2-1、简介 title=2.1、简介></a>2.1、简介</h2><h3 id=2-1-1、参数分类><a class=headerlink href=#2-1-1、参数分类 title=2.1.1、参数分类></a>2.1.1、参数分类</h3><ul><li><strong>-开头</strong>：标准类型，所有HotSpot都支持。<li><strong>-X开头</strong>：非标准类型，特定版本才支持。<li><strong>-XX开头</strong>：运行时选项，控制虚拟机的运行时行为。下个版本可能取消。<ol><li><strong>Boolean类型参数</strong>：-XX:+/- 某个属性值（+表示开启，-表示关闭）。<li><strong>K-V类型参数</strong>：-XX: key（属性）= value（属性值）</ol></ul><p>通过命令<code>jinfo -flag 配置项 进程号</code>可查看当前运行环境的配置项。<blockquote><p>如何解释-Xms和-Xmx参数属于-XX参数？<p>-Xms = -XX:InitialHeapSize=size / -Xmx = -XX:MaxHeapSize=size</blockquote><h3 id=2-1-2、查看参数值><a class=headerlink href=#2-1-2、查看参数值 title=2.1.2、查看参数值></a>2.1.2、查看参数值</h3><p><strong>（1）查看java进程相关参数</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>jinfo -flag 参数项 进程号</span><br><span class=line>jinfo -flags 进程号</span><br></pre></table></figure><p><strong>（2）查看默认值和最终值</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>java -XX:+PrintFlagsInitial   <span class=comment># 查看jvm未更改的默认参数</span></span><br><span class=line>java -XX:+PrintFlagsFinal     <span class=comment># 查看jvm已经更改过的参数</span></span><br></pre></table></figure><p>也可以在运行java命令的同时加入jvm参数，如：<code>java -XX:+PrintFlagsFinal UpdateJVMParamDemo</code><p><font color=red>注意：<code>:=</code>表示jvm启动时修改过的参数。<code>=</code>表示jvm没有更改过的默认参数。</font><p><strong>（3）打印命令行参数</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -XX:+PrintCommandLineFlags</span><br></pre></table></figure><p><strong>（4）查看可以被修改的参数</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -XX:+PrintFlagsFinal -version | grep manageable</span><br></pre></table></figure><h2 id=2-2、系统优化参数><a class=headerlink href=#2-2、系统优化参数 title=2.2、系统优化参数></a>2.2、系统优化参数</h2><ul><li><strong>-XX:-UseCompressedOops</strong>：禁用压缩指针。默认启用，当 Java 堆内存小于 32 GB 时将使用压缩指针。启用此选项后，对象引用表示为 32 位偏移量而不是 64 位指针。此选项仅适用于 64 位 JVM。当 Java 堆内存大于 32GB 时，也可以使用压缩指针。查看<code>-XX:ObjectAlignmentInBytes</code>选项。<li><strong>-XX:+Inline</strong>：启用方法内联。默认开启。要禁用方法内联，请指定<code>-XX:-Inline</code>。<li><strong>-XX:InlineSmallCode=大小</strong>：设置触发内联功能的已编译方法的代码大小（以字节为单位）。只有已编译代码小于指定大小时才会被内联。默认最大代码大小设置为 1000 字节：-XX:InlineSmallCode=1000。<li><strong>-XX:MaxInlineSize=大小</strong>：设置要内联的方法的最大字节码大小（以字节为单位）。默认最大字节码大小为 35 个字节：<code>-XX:MaxInlineSize=35</code>。<li><strong>-XX:MaxTrivialSize=大小</strong>：设置要内联的普通方法的最大字节码大小（以字节为单位）。默认普通方法的最大字节码大小为 6 个字节：<code>-XX:MaxTrivialSize=6</code>。<li><strong>-XX:+PrintInlining</strong>：启用内联决策打印，可以查看哪些方法正在被内联。默认禁用且不打印内联信息。参数<code>-XX:+PrintInlining</code>必须与参数<code>-XX:+UnlockDiagnosticVMOptions</code>一起使用。<li><strong>-XX:+OptimizeStringConcat</strong>：启用<code>String</code>连接优化。默认启用。要禁用<code>String</code>串联优化，请指定<code>-XX:-OptimizeStringConcat</code>。只有 Java HotSpot Server VM 支持此选项。<li><strong>-XX:+UseStringDeduplication</strong>：启用字符串重复数据删除。默认禁用。要想启用该功能就必须启用G1 垃圾收集器。</ul><h2 id=2-3、类加载参数><a class=headerlink href=#2-3、类加载参数 title=2.3、类加载参数></a>2.3、类加载参数</h2><ul><li><p><strong>-XX:+TraceClassLoading</strong>：启用类加载跟踪。</p><li><p><strong>-XX:+TraceClassLoadingPreorder</strong>：启用按引用顺序跟踪所有加载类。默认禁用且不跟踪。</p><li><p><strong>-XX:+TraceClassUnloading</strong>：启用类卸载跟踪。默认禁用且不跟踪。</p><li><p><strong>-XX:CICompilerCount=线程</strong>：设置用于编译的编译器线程数。默认线程数为 2，客户端线程数为 1，如果使用分层编译，它会扩展到内核数。</p><li><p><strong>-XX:CodeCacheMinimumFreeSpace=大小</strong>：编译所需最小空间（以字节为单位）。当剩余空间小于最小可用空间时将停止编译。默认空间大小为 500 KB。</p><li><p><strong>-XX:CompileOnly=方法</strong>：设置限制编译的方法列表（以逗号分隔）。</p> <figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-XX:CompileOnly=java/lang/String.length,java/util/List.size</span><br></pre></table></figure><li><p><strong>-XX:CompileThreshold=调用</strong>：设置 编译前解释方法次数。默认情况下，在服务器 JVM 中，JIT 编译器执行 10,000 次解释方法调用来收集信息以进行高效编译。对于客户端 JVM，默认为 1,500 次调用。启用分层编译时将忽略此选项；见选项<code>-XX:+TieredCompilation</code>。</p><li><p><strong>-XX:+BackgroundCompilation</strong>：启用后台编译。默认启用。要禁用后台编译，请指定<code>-XX:-BackgroundCompilation</code>（这等效于指定<code>-Xbatch</code>）。</p><li><p><strong>-XX:MaxNodeLimit=节点</strong>：设置单个方法编译期间要使用的最大节点数。默认情况下，最大节点数设置为 65,000：<code>-XX:MaxNodeLimit=65000</code>。</p><li><p><strong>-XX:+PrintCompilation</strong>：通过在每次编译方法时将消息打印到控制台来启用来自 JVM 的详细诊断输出。这可以查看实际编译了哪些方法。默认禁用该功能且不打印诊断输出。同时可以通过指定参数<code>-XX:+LogCompilation</code>将编译活动记录到文件中。</p><li><p><strong>-XX:ReservedCodeCacheSize=大小</strong>：设置 JIT 编译代码的最大代码缓存大小（以字节为单位）。默认最大代码缓存为 240 MB；如果指定参数<code>-XX:-TieredCompilation</code>禁用了分层编译，则默认大小为 48 MB。该参数最大限制为 2 GB，否则报错。最大代码缓存不应小于初始代码缓存；见选项<code>-XX:InitialCodeCacheSize</code>。此选项等效于<code>-Xmaxjitcodesize</code>。</p><li><p><strong>-XX:-TieredCompilation</strong>：禁用分层编译。默认启用。只有 Java HotSpot Server VM 支持此选项。</p></ul><h2 id=2-4、运行时数据区参数><a class=headerlink href=#2-4、运行时数据区参数 title=2.4、运行时数据区参数></a>2.4、运行时数据区参数</h2><h3 id=2-4-1、堆（Heap）><a class=headerlink href=#2-4-1、堆（Heap） title=2.4.1、堆（Heap）></a>2.4.1、堆（Heap）</h3><h4 id=基本参数><a class=headerlink href=#基本参数 title=基本参数></a>基本参数</h4><ul><li><strong>-Xms / -XX:InitialHeapSize=大小</strong>：堆内存最小值和初始大小。此值必须是 1024 的倍数且大于 1 MB。<li><strong>-Xmx / -XX:MaxHeapSize=大小</strong>：堆内存最大值（以字节为单位）。此值必须是 1024 的倍数且大于 2 MB。通常将<code>-Xms</code>并<code>-Xmx</code>设为相同值。<li><strong>-XX:+AggressiveHeap</strong>：启用 Java 堆优化。根据计算机配置（RAM 和 CPU）自动设置合适的参数值。默认禁用。<li><strong>-XX:NewRatio=比率</strong>：设置年轻代和年老代大小比例。默认为 2。<li><strong>-XX:+UseAdaptiveSizePolicy</strong>：启用自适应大小调整。默认启用。要禁用请指定参数<code>-XX:-UseAdaptiveSizePolicy</code>和 设置内存分配池的大小（请参阅<code>-XX:SurvivorRatio</code>选项）。<li><strong>-XX:InitialRAMPercentage=percent</strong>：将用于 Java 堆的初始内存量设置为 -XX:MaxRAM 选项中所述确定的最大内存量的百分比。默认值为 1.5625%。<li><strong>-XX:MaxRAMPercentage=百分比</strong>：Java 堆的最大内存量，设置为 -XX:MaxRAM 选项中所述确定的最大内存量的百分比。默认值为 25%。</ul><h4 id=年轻代><a class=headerlink href=#年轻代 title=年轻代></a>年轻代</h4><ul><li><strong>-XX:NewSize</strong>：年轻代初始大小。<li><strong>-XX:MaxNewSize</strong>：年轻代最大内存大小。<li><strong>-Xmn</strong>：年轻代 初始大小 和 最大大小。官方建议 年轻代大小 应在 整堆大小的四分之一到二分之一之间。<li><strong>-XX:SurvivorRatio</strong>：新生代中 Eden区 与 Survivor区 的占用比例，默认为8，意为eden区大小占年轻代的8/10，而survivor from区和to区各占1/10；<li><strong>-XX:+UseTLAB</strong>：在年轻代中使用TLAB。默认启用。要禁用 TLAB，请指定<code>-XX:-UseTLAB</code>。<li><strong>-XX:TLABSize=大小</strong>：TLAB 初始大小（以字节为单位）。参数值为 0 时表示自动选择初始大小。<li><strong>-XX:TargetSurvivorRatio=百分比</strong>：YGC后的幸存区（Surivivor区）使用占比。默认为 50%。</ul><h4 id=老年代><a class=headerlink href=#老年代 title=老年代></a>老年代</h4><h3 id=2-4-2、方法区（MethodArea）><a class=headerlink href=#2-4-2、方法区（MethodArea） title=2.4.2、方法区（MethodArea）></a>2.4.2、方法区（MethodArea）</h3><h4 id=永久代（JDK7及以前版本）><a class=headerlink href=#永久代（JDK7及以前版本） title=永久代（JDK7及以前版本）></a>永久代（JDK7及以前版本）</h4><ul><li><strong>-XX:PermSize=size</strong>：设置永久代初始大小（字节单位）,超过该大小，则触发垃圾回收。<li><strong>-XX:MaxPermSize=size</strong>：设置永久代最大容量。</ul><h4 id=元空间（JDK8及以后版本）><a class=headerlink href=#元空间（JDK8及以后版本） title=元空间（JDK8及以后版本）></a>元空间（JDK8及以后版本）</h4><ul><li><strong>-XX:MetaspaceSize=size</strong>：设置类元数据空间大小，该空间将在第一次超出时触发垃圾回收。根据使用的元数据量增加或减少垃圾收集的阈值。默认大小取决于平台。<li><strong>-XX:MaxMetaspaceSize=size</strong>：设置 类元数据 最大本机内存量。默认大小不受限制。<li><strong>-XX:+/-UseCompressedOops</strong>：开启或关闭对象指针压缩功能，默认开启。当 Java 堆大小小于 32 GB 时，将使用压缩指针。启用此选项后，对象引用将表示为 32 位偏移量，而不是 64 位指针。该参数选项只适用于64位的JVM。<li>-XX:+UseCompressedClassPointers：压缩类型指针。<li>-XX:CompressedClassSpaceSize：设置Klass Metaspace的大小，默认1G。</ul><h3 id=2-4-3、操作数栈（OperandStack）><a class=headerlink href=#2-4-3、操作数栈（OperandStack） title=2.4.3、操作数栈（OperandStack）></a>2.4.3、操作数栈（OperandStack）</h3><ul><li><strong>-Xss</strong>：设置线程栈大小（以字节为单位）等价于<code>-XX:ThreadStackSize=大小</code>。默认值取决于平台。<li><strong>-XX:+DoEscapeAnalysis</strong>：启用逃逸分析。默认启用。要禁用请指定<code>-XX:-DoEscapeAnalysis</code>。只有 Java HotSpot Server VM 支持此选项。</ul><h3 id=2-4-4、本地方法栈（LocalMethodStack）><a class=headerlink href=#2-4-4、本地方法栈（LocalMethodStack） title=2.4.4、本地方法栈（LocalMethodStack）></a>2.4.4、本地方法栈（LocalMethodStack）</h3><h3 id=2-4-5、程序计数器（ProgramRegister）><a class=headerlink href=#2-4-5、程序计数器（ProgramRegister） title=2.4.5、程序计数器（ProgramRegister）></a>2.4.5、程序计数器（ProgramRegister）</h3><h3 id=2-4-6、直接内存（DirectMemory）><a class=headerlink href=#2-4-6、直接内存（DirectMemory） title=2.4.6、直接内存（DirectMemory）></a>2.4.6、直接内存（DirectMemory）</h3><ul><li><strong>-XX:MaxDirectMemorySize=size</strong>：设置新 I/O（<code>java.nio</code>包）直接缓冲区分配的最大值（以字节为单位）。默认为 0，表示 JVM 会自动选择 NIO 直接缓冲区大小。</ul><h3 id=2-4-7、其它><a class=headerlink href=#2-4-7、其它 title=2.4.7、其它></a>2.4.7、其它</h3><ul><li><strong>-XX:ObjectAlignmentInBytes=对齐</strong>：设置 Java 对象的内存对齐（以字节为单位）。默认为 8 个字节。指定的值应该是 2 的幂，且必须在 8 到 256（含）范围内。堆大小限制（以字节为单位）的计算公式为：<code>4GB * ObjectAlignmentInBytes</code>。<li><strong>-XX:+PrintCommandLineFlags</strong>：启用打印当前JVM参数选项信息的功能。默认禁用。<li><strong>-XX:InitialCodeCacheSize=大小</strong>：设置 初始代码缓存大小（以字节为单位）。JDK17以前默认为 500 KB，JDK17及以后其默认值取决于平台。初始代码缓存大小应不小于系统的最小内存页大小。</ul><h2 id=2-5、垃圾回收参数><a class=headerlink href=#2-5、垃圾回收参数 title=2.5、垃圾回收参数></a>2.5、垃圾回收参数</h2><h3 id=2-5-1、基本参数><a class=headerlink href=#2-5-1、基本参数 title=2.5.1、基本参数></a>2.5.1、基本参数</h3><ul><li><p><strong>-Xnoclassgc</strong>：禁用类的垃圾回收 (GC)。</p><li><p><strong>-XX:ErrorFile=filename</strong>：发生错误时 将 错误数据 写入指定文件。文件默认在当前目录且命名为 hs_err_pid pid.log，其中 pid 是导致错误的进程标识符。</p><li><p><strong>-XX:+HeapDumpOnOutOfMemoryError</strong>：出现OOM异常时将错误信息导出到指定文件。可使用参数<code>-XX:HeapDumpPath</code>设置文件路径和名称。默认情况下，此选项处于禁用状态，并且在引发 <code>OutOfMemoryError</code> 异常时不会转储堆。</p><li><p><strong>-XX:HeapDumpPath=路径</strong>：设置该<code>-XX:+HeapDumpOnOutOfMemoryError</code>选项时，设置用于写入堆分析器 (HPROF) 提供的堆转储的路径和文件名。默认情况下，该文件在当前工作目录中创建，并命名为<code>java_pid</code><em>pid</em><code>.hprof</code>，其中 pid 是导致错误的进程标识符。以下示例设置默认文件（<code>%p</code>代表当前进程标识符）：</p> <figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>-XX:HeapDumpPath=./java_pid%p.hprof</span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>例如，将堆转储文件保存在/var/log/java/java_heapdump.hprof</span></span><br><span class=line>-XX:HeapDumpPath=/var/log/java/java_heapdump.hprof</span><br></pre></table></figure><li><p><strong>-XX:ActiveProcessorCount= x</strong>：覆盖 VM 用于计算其用于各种操作（例如垃圾收集和 ForkJoinPool）的线程池大小的 CPU 数量。</p><li><p><strong>-XX:MaxHeapFreeRatio=百分比</strong>：设置 GC后堆最大空闲空间占比（0 到 100）。如果GC后空闲空间占比大于该参数值，则将堆缩小。默认为 70%。</p><li><p><strong>-XX:MinHeapFreeRatio=百分比</strong>：设置 GC后堆最小空闲空间占比（0 到 100）。如果GC后空闲空间占比小于该参数值，则将堆扩大。默认为 40%。</p><li><p><strong>-XX:MaxTenuringThreshold=阈值</strong>：对象晋升至老年代的最大年龄阈值为 15。并行（吞吐量）收集器默认为 15，CMS 收集器默认为 6。</p><li><p><strong>-XX:MinRAMPercentage=百分比</strong>：将 JVM 可用于 Java 堆的最大内存量设置为如<code>-XX:MaxRAM</code>小堆选项中所述确定的最大内存量的百分比。小堆大约 125 MB。默认值为 50%。</p><li><p><strong>-XX:+ScavengeBeforeFullGC</strong>：FGC前先执行一次YGC，默认启用。Oracle 建议您不要禁用它。</p><li><p><strong>-XX:StringDeduplicationAgeThreshold=阈值</strong>：<code>String</code>达到指定年龄的对象被视为重复数据删除的候选对象。一个对象的年龄是衡量它在垃圾收集中幸存下来的次数。这有时被称为任期；</p><li><p><strong>-XX:+UseGCOverheadLimit</strong>：允许使用限制 JVM 在<code>OutOfMemoryError</code>抛出异常之前花费在 GC 上的时间比例的策略。默认情况下启用此选项，<code>OutOfMemoryError</code>如果总时间的 98% 以上用于垃圾收集并且堆的回收少于 2%，则并行 GC 将抛出异常。当堆很小时，此功能可用于防止应用程序长时间运行而几乎没有或没有进展。要禁用此选项请指定<code>-XX:-UseGCOverheadLimit</code>。</p><li><p><strong>-XX:+UseNUMA</strong>：通过增加应用程序对低延迟内存的使用，在具有非统一内存架构 (NUMA) 的机器上实现应用程序的性能优化。默认情况下，此选项处于禁用状态，并且不会对 NUMA 进行优化。该选项仅在使用并行垃圾收集器 ( <code>-XX:+UseParallelGC</code>)时可用。</p><li><p>-XX:PreTenureSizeThreshold：设置大对象大小；</p><li><p>-XX:MaxTenuringThreshold：表示对象晋升到老年代的年龄阈值；（默认值15，CMS为6，G1为15。）</p> <p><font color=red>注意，年龄小于该阈值时也可能会晋升，但晋升时对象的年龄永远不会超过该阈值。因为还有对象动态晋升机制的存在，动态晋升是指：当survivor区中所有相同大小对象的大小总和超过survivor区一半时，就需要将这些相同大小的对象和大于该大小的对象全部晋升到老年代中，使得survivor区中有空闲空间来供程序正常运行来用，否则没有空闲空间，程序将会出现问题。</font></p></ul><h3 id=2-5-2、垃圾收集器参数><a class=headerlink href=#2-5-2、垃圾收集器参数 title=2.5.2、垃圾收集器参数></a>2.5.2、垃圾收集器参数</h3><h4 id=基本参数-1><a class=headerlink href=#基本参数-1 title=基本参数></a>基本参数</h4><ul><li><strong>-XX:ConcGCThreads=线程</strong>：设置并发GC 线程数。默认值取决于 JVM 可用的 CPU 数量。<li><strong>-XX:+DisableExplicitGC</strong>：禁用代码块 System.gc()。<li><strong>-XX:InitiatingHeapOccupancyPercent=百分比</strong>：设置启动并发 GC 周期的堆占用百分比（0 到 100）。它被垃圾收集器使用，它们根据整个堆的占用率触发并发 GC 周期，而不仅仅是其中一代（例如，G1 垃圾收集器）。默认初始值为 45%。值 0 表示不间断 GC 循环。<li><strong>-XX:MaxGCPauseMillis=时间</strong>：设置 GC 最大暂停时间（以毫秒为单位）。默认 没有最大暂停时间值。</ul><h4 id=Serial-Old常用参数><a title="Serial Old常用参数" class=headerlink href=#Serial-Old常用参数></a>Serial Old常用参数</h4><ul><li><strong>-XX:+UseSerialGC</strong>：启用串行垃圾收集器。适用于小型的简单的应用程序。默认禁用，并根据机器配置和 JVM 类型自动选择收集器。</ul><h4 id=Parallel常用参数><a class=headerlink href=#Parallel常用参数 title=Parallel常用参数></a>Parallel常用参数</h4><ul><li><p><strong>-XX:+UseParallelGC</strong>：使用并行清理垃圾收集器（也称为吞吐量收集器）。默认禁用，并根据机器配置和 JVM 类型自动选择收集器。如果启用该选项，则默认同时启用<code>-XX:+UseParallelOldGC</code>，除非明确禁用它。</p><li><p><strong>-XX:+UseParallelOldGC</strong>：启用并行垃圾收集器。默认禁用。启用它会自动启用参数<code>-XX:+UseParallelGC</code>。</p><li><p><strong>-XX:+ParallelGCThreads=n</strong>：设置用于年轻代和年老代并行垃圾回收的线程数。默认值取决于 JVM 可用的 CPU 数量。同样适用于CMS。*</p> <p>按照逻辑处理器的数量来设置n值。n 的值应该与逻辑处理器的数量相同，最多为 8。如果逻辑处理器不止八个，则将 n 的值设置为逻辑处理器数量的 5/8 左右。这适用于大多数情况，除非是较大的 SPARC 系统，其中 n 值可以是逻辑处理器数的 5/16 左右。</p><li><p><strong>-XX:+UseAdaptiveSizePolicy</strong>：表示自动选择各区大小比例。</p><li><p><strong>-XX:InitialSurvivorRatio=比率</strong>：设置吞吐量垃圾收集器使用的初始幸存者空间比率（由<code>-XX:+UseParallelGC</code>和/或 -<code>XX:+UseParallelOldGC</code>选项启用）。默认吞吐量垃圾收集器使用<code>-XX:+UseParallelGC</code>和<code>-XX:+UseParallelOldGC</code>选项启用自适应大小调整，并根据应用程序行为调整幸存者空间大小，从初始值开始。如果禁用了自适应大小调整（使用该<code>-XX:-UseAdaptiveSizePolicy</code>选项），<code>-XX:SurvivorRatio</code>则应使用该选项为整个应用程序执行设置幸存者空间的大小。</p> <p>根据年轻代的大小（Y）和初始幸存者空间比率（R），可以使用以下公式计算幸存者空间的初始大小（S）：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>S=Y/(R+2)</span><br></pre></table></figure><li><p><strong>-XX:+ParallelRefProcEnabled</strong>：启用并行引用处理。默认禁用状态。</p><li><p><code>-XX:MaxGCPauseMillis</code>：设置垃圾收集器最大停顿时间。</p><li><p><code>-XX:GCTimeRatio</code>：垃圾收集时间占总时间的比例。</p></ul><h4 id=ParNew参数><a class=headerlink href=#ParNew参数 title=ParNew参数></a>ParNew参数</h4><ul><li>-XX:+UseParNewGC：年轻代中使用 并行线程 进行收集。默认禁用。设置参数<code>-XX:+UseConcMarkSweepGC</code>会自动启用。使用<code>-XX:+UseParNewGC</code>不带选项<code>-XX:+UseConcMarkSweepGC</code>的选择是在JDK 8弃用。</ul><h4 id=CMS常用参数><a class=headerlink href=#CMS常用参数 title=CMS常用参数></a>CMS常用参数</h4><ul><li><p>-XX:+UseConcMarkSweepGC：为老年代启用 CMS 垃圾收集器。Oracle 建议您在吞吐量 ( <code>-XX:+UseParallelGC</code>) 垃圾收集器无法满足应用程序延迟要求时使用 CMS 垃圾收集器。G1 垃圾收集器 ( <code>-XX:+UseG1GC</code>) 是另一种选择。</p> <p>默认情况下，此选项处于禁用状态，并根据机器的配置和 JVM 的类型自动选择收集器。当启用该选项时，<code>-XX:+UseParNewGC</code>选项将自动设置，你不应该禁用它，因为下面的选项组合已经在JDK 8被弃用：<code>-XX:+UseConcMarkSweepGC -XX:-UseParNewGC</code>。</p><li><p>-XX:ParallelCMSThreads：CMS线程数量。</p><li><p>-XX:CMSInitiatingOccupancyFraction：老年代内存使用率达到多少时执行CMS收集（低版本的 JDK 默认值为 68%, JDK6 及以上版本默认值为 92%），这里的内存回收范围仅限于老年代，而非整个堆空间，因此通过该选项便可以有效降低 Full GC 执行次数。如果频繁发生SerialOld卡顿，应该调小，（频繁CMS回收）。默认值设置为 -1。任何负值（包括默认值）都意味着<code>-XX:CMSTriggerRatio</code>用于定义初始占用率的值。</p><li><p>-XX:+UseCMSCompactAtFullCollection：执行FGC后是否进行压缩整理。</p><li><p>-XX:CMSFullGCsBeforeCompaction：执行FGC多少次后进行压缩整理。</p><li><p>-XX:+CMSClassUnloadingEnabled：表示对永久代进行垃圾回收；</p> <p>CMS收集器默认不会对永久代进行垃圾回收，如需回收设置该参数即可。在早期JVM版本中，要求设置额外的标志-XX:+CMSPermGenSweepingEnabled。注意，即使没有设置这个标志，一旦永久代耗尽空间也会尝试进行垃圾回收，但是收集不会是并行的，而再一次进行Full GC。</p><li><p>-XX:CMSInitiatingPermOccupancyFraction：达到什么比例时进行Perm回收。</p><li><p>GCTimeRatio：设置GC时间占用程序运行时间的百分比。</p><li><p>-XX:MaxGCPauseMillis：停顿时间，是一个建议时间，GC会尝试用各种手段达到这个时间，比如减小年轻代。</p><li><p>-XX:+CMSClassUnloadingEnabled：在使用并发标记清除 (CMS) 垃圾收集器时启用类卸载。默认启用。要禁用 CMS 垃圾收集器的类卸载，请指定<code>-XX:-CMSClassUnloadingEnabled</code>。</p><li><p>-XX:+CMSScavengeBeforeRemark：在 CMS 重新标记前启用清理。默认禁用。</p><li><p>-XX:CMSTriggerRatio=百分比：设置在<code>-XX:MinHeapFreeRatio</code>CMS 收集周期开始之前分配的指定值的百分比（0 到 100）。默认值设置为 80%。</p><li><p>-XX:+ExplicitGCInvokesConcurrent：通过使用<code>System.gc()</code>请求启用并发 GC 的调用。默认禁用，只能与<code>-XX:+UseConcMarkSweepGC</code>选项一起启用。</p><li><p>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses：通过在并发 GC 周期中使用 System.gc() 请求和卸载类来启用并发 GC 的调用。默认禁用，只能与 -XX:+UseConcMarkSweepGC 选项一起启用。</p><li><p>-XX:+UseCMSInitiatingOccupancyOnly：允许使用占用值作为启动 CMS 收集器的唯一标准。默认禁用，可以使用其他条件。</p></ul><h4 id=G1常用参数><a class=headerlink href=#G1常用参数 title=G1常用参数></a>G1常用参数</h4><ul><li><p>-XX:+UseG1GC：表示 使用G1收集器；</p><li><p>-XX:MaxGCPauseMillis：每次GC的停顿目标时间，默认值 200ms。G1会尝试调整Young区的个数来达到该值；</p><li><p>-XX:GCPauseIntervalMillis：GC间隔时间；</p><li><p>-XX:G1HeapRegionSize=n：分区大小，建议逐渐增大该值1、2、4、8、16、32。随着size增加，垃圾存活时间会更长，GC间隔会更长，但每次GC时间也会更长，ZGC做了改进（动态区块大小）；</p><li><p>-XX:G1HeapWastePercent：默认值5%，表示在全局并发标记结束后能够统计出所有可被回收的垃圾占Heap的比例值，如果超过5%，就会触发之后的多轮Mixed GC，mixed gc会同时回收年轻代+老年代，而这个参数可以指定mixed gc触发的时机；</p> <p>注意：该参数与 <code>InitiatingHeapOccupancyPercent</code> 结合使用可以实现提前回收老年代，让老年代提前释放空间。</p><li><p>-XX:InitiatingHeapOccupancyPercent=45：默认45%，表示在堆使用率达到该参数设定值时，就会触发 混合回收；</p><li><p>-XX:G1NewSizePercent：新生代最小比例，默认为5%。</p><li><p>-XX:G1MaxNewSizePercent：新生代最大比例，默认为60%；</p><li><p>-XX:G1MixedGCCountTarget：默认值8，表示最后的混合回收阶段会执行8次，一次只回收掉一部分Region，然后系统继续运行，过了一小段时间后，会再次进行混合回收，就这样重复8次；</p><li><p>-XX:G1MixedGCLiveThresholdPercent：默认值85%，表示 一个Region中的存活对象若大于Region大小的85%，那就无需回收这个Region，否则得不偿失；</p><li><p>-XX:GCTimeRatio：圾回收时间占程序运行时间的百分比；</p><li><p>-XX:ConcGCThreads=n：设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1/4 左右；</p><li><p><strong>-XX:G1HeapRegionSize=大小</strong>：使用G1收集器时 Java 堆细分的区域大小。该值介于 1 MB 和 32 MB 之间。默认区域大小是根据堆大小来定。</p><li><p><strong>-XX:+G1PrintHeapRegions</strong>：启用打印有关哪些区域已分配以及哪些由 G1 收集器回收的信息。默认情况下，此选项处于禁用状态。</p><li><p><strong>-XX:G1ReservePercent=百分比</strong>：设置保留为虚假上限的堆的百分比（0 到 50），以减少 G1 收集器升级失败的可能性。默认情况下，此选项设置为 10%。</p><li><p><strong>-XX:+UseStringDeduplication</strong>：启用字符串重复数据删除。默认禁用。要使用此选项，您必须启用G1垃圾收集器。</p></ul><h4 id=常见垃圾回收器参数><a class=headerlink href=#常见垃圾回收器参数 title=常见垃圾回收器参数></a>常见垃圾回收器参数</h4><p>设置串行收集器：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-XX:+UseSerialGC = Serial New(DefNew) + Serial Old</span><br></pre></table></figure><p>设置并行收集器：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>-XX:+UseParallelGC</span><br><span class=line>-XX:ParallelGCThreads=n     <span class=comment># 设置并行收集器工作时使用的CPU数量。</span></span><br><span class=line>-XX:MaxGCPauseMillis=n      <span class=comment># 设置并行收集器最大停顿时间。</span></span><br><span class=line>-XX:GCTimeRatio=n           <span class=comment># 设置垃圾回收时间占程序运行时间的百分比。</span></span><br></pre></table></figure><p>设置老年代并行收集器：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-XX:+UseParallelOldGC</span><br></pre></table></figure><p>设置并发收集器：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>-XX:+UseConcMarkSweepGC</span><br><span class=line>-XX:+CMSIncrementalMode <span class=comment># 设置为增量模式，适用于单CPU情况。</span></span><br><span class=line>-XX:ParallelGCThreads=n <span class=comment># 设置年轻代收集为并行收集时，并行GC线程的数量，一般最好和CPU核心数量一样。</span></span><br></pre></table></figure><p>其它参数如下：<ul><li><p>-XX:+UseParNewGC = ParNew + SerialOld</p><li><p>-XX:+UseConc(current)MarkSweepGC = ParNew + CMS + SerialOld</p><li><p>-XX:+UseParallelGC = Parallel Scavenge + Parallel Old</p><li><p>-XX:+UseG1GC = G1</p><li><p>查看Linux下默认GC的方法，而Windows中会打印UseParallelGC。</p> <ol><li>java -XX:+PrintCommandLineFlags - version<li>通过GC日志分辨。</ol><li><p>Linux下JDK8默认垃圾收集器？</p> <ol><li>1.8.0_181 默认看不出，Copy MarkCompact<li>1.8.0_222 默认PS + PO</ol></ul><h3 id=2-5-3、GC日志参数><a class=headerlink href=#2-5-3、GC日志参数 title=2.5.3、GC日志参数></a>2.5.3、GC日志参数</h3><h4 id=基本参数-2><a class=headerlink href=#基本参数-2 title=基本参数></a>基本参数</h4><ul><li><strong>-XX:LogFile=路径</strong>：设置写入日志数据的路径和文件名。默认该文件创建在当前工作目录中，并命名为<code>hotspot.log</code>.</ul><h4 id=日志打印参数><a class=headerlink href=#日志打印参数 title=日志打印参数></a>日志打印参数</h4><ul><li><strong>-XX:+PrintGC</strong>：每次 GC 时打印消息。默认禁用。<li><strong>-XX:+PrintGCDetails</strong>：每次 GC 时打印详细消息。默认禁用。<li><strong>-XX:+PrintGCTimeStamps</strong>：每次 GC 时打印时间戳。默认禁用。<li><strong>-XX:+PrintGCTaskTimeStamps</strong>：为每个单独的 GC 工作线程任务启用时间戳打印。默认禁用。<li><strong>-XX:+PrintGCCauses</strong><li><strong>-XX:+PrintGCApplicationConcurrentTime</strong>：启用打印自上次暂停（例如，GC 暂停）以来经过的时间。默认禁用。<li><strong>-XX:+PrintGCApplicationStoppedTime</strong>：启用打印暂停（例如，GC 暂停）持续的时间。默认禁用。<li><strong>-XX:+PrintGCDateStamps</strong>：每次 GC 时打印日期戳。默认禁用。<li><strong>-XX:+PrintStringDeduplicationStatistics</strong>：打印详细重复数据，删除统计信息。默认禁用。查看<code>-XX:+UseStringDeduplication</code>选项。<li><strong>-XX:+PrintTenuringDistribution</strong>：启用任期年龄信息的打印。<li><strong>-XX:SoftRefLRUPolicyMSPerMB=时间</strong>：软引用对象在上次被引用后在堆上保持活动的时间量（以毫秒为单位）。默认值是堆中每空闲兆字节的生命周期一秒。<li><strong>-XX:PrintHeapAtGC</strong>：GC执行前后打印出堆的信息；<li><strong>-Xloggc:filename</strong>：日志文件保存路径；</ul><p><font color=red>注意：total = eden区 + 1个survivor区。</font><h4 id=注意事项-1><a class=headerlink href=#注意事项-1 title=注意事项></a>注意事项</h4><p>JDK8及之前推荐配置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:文件路径</span><br></pre></table></figure><p>JDK9及之后推荐配置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-Xlog:gc*:file=文件路径</span><br></pre></table></figure><h2 id=2-6、Java锁参数><a class=headerlink href=#2-6、Java锁参数 title=2.6、Java锁参数></a>2.6、Java锁参数</h2><ul><li><strong>-XX:-UseBiasedLocking</strong>：禁用偏向锁。</ul><h2 id=2-7、JVM参数总结><a class=headerlink href=#2-7、JVM参数总结 title=2.7、JVM参数总结></a>2.7、JVM参数总结</h2><h3 id=2-7-1、GC常用参数><a class=headerlink href=#2-7-1、GC常用参数 title=2.7.1、GC常用参数></a>2.7.1、GC常用参数</h3><ul><li>-Xms / -Xmx / -Xmn / -Xss：最小堆 / 最大堆 / 年轻代 / 栈空间。<li>-XX:NewSize：JVM启动时分配的新生代内存大小。<li>-XX:OldSize：JVM启动时分配的老年代内存大小。<li>-XX:PermSize 和 -XX:MaxPermSize：JVM 永久代（方法区，JDK7之前）大小。<li>-XX SurvivorRatio：Eden空间和另外两个Survivor空间的比例，默认比例是<code>8:1</code>。<li>-XX:+UseTLAB：使用TLAB，默认打开。<li>-XX:+PrintTLAB：打印TLAB使用情况。<li>-XX:TLABSize：设置TLAB大小。<li>-XX:+DisableExplictGC：禁用System.gc()功能，FGC。<li>-XX:+PrintGC：打印GC日志信息。<li>-XX:+PrintGCDetails：打印GC详细的日志信息。<li>-XX:+PrintHeapAtGC：发生GC时打印堆信息。<li>-XX:+PrintGCTimeStamps：打印GC执行时间信息。<li>-XX:+PrintGCApplicationConcurrentTime (低)：打印应用程序时间。<li>-XX:+PrintGCApplicationStoppedTime（低）：打印暂停时长。<li>-XX:+PrintReferenceGC（重要性低）：记录回收了多少种不同引用类型的引用。<li>-verbose:class：类加载详细过程。<li>-XX:+PrintVMOptions：打印虚拟机的选项信息。<li>-XX:+PrintFlagsFinal -XX:+PrintFlagsInitial：必须会用。<li>-Xloggc:opt/log/gc.log：将生成的gc日志保存于指定的文件中。<li>-XX:MaxTenuringThreshold：升代年龄，最大值15。<li>-XX:PreBlockSpin：锁自旋次数参数（默认即可，不建议设置）。<li>-XX:CompileThreshold：热点代码检测参数、逃逸分析、标量替换（默认即可，不建议设置）。</ul><h3 id=2-7-2、堆内存常用配置><a class=headerlink href=#2-7-2、堆内存常用配置 title=2.7.2、堆内存常用配置></a>2.7.2、堆内存常用配置</h3><h4 id=参考1><a class=headerlink href=#参考1 title=参考1></a>参考1</h4><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -Xms3550m -Xmx3550m -Xmn2g -Xss128k</span><br></pre></table></figure><ul><li><p>-Xmx3550m：设置JVM最大可用内存为3550M。</p><li><p>-Xms3550m：设置JVM内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</p><li><p>-Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻代大小+老年代大小+持久代大小。持久代大小一般固定为64m，所以增大年轻代后，将会减小老年代大小。</p> <p><font color=red>注意：此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</font></p><li><p>-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p></ul><h4 id=参考2><a class=headerlink href=#参考2 title=参考2></a>参考2</h4><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -Xms3550m -Xmx3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0</span><br></pre></table></figure><ul><li>-XX:NewRatio=4：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4表示年轻代与年老代的比为<code>1:4</code>，年轻代占整个堆栈的1/5。<li>-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为<code>2:4</code>，一个Survivor区占整个年轻代的1/6。<li>-XX:MaxPermSize=16m：设置持久代大小为16m。JDK8中弃用，若使用JDK8及更新版本，则该参数被<code>-XX:MaxMetaspaceSize</code>替代。<li>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代即被回收的机会。</ul><h4 id=参考3><a class=headerlink href=#参考3 title=参考3></a>参考3</h4><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>-Xms1G -Xmx1G -Xss256K -XX:MaxMetaspaceSize=512M -XX:+DisableExplicitGC</span><br><span class=line>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/opt/dumps/my-service.hprof</span><br><span class=line>-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:文件路径</span><br></pre></table></figure><p>参数解析：<ul><li>-XX:MaxMetaspaceSize=512M：最大元空间大小为512M。<li>-XX:+DisableExplicitGC：禁用System.gc()功能。<li>-XX:+HeapDumpOnOutOfMemoryError：出现OutOfMemory错误时自动生成堆内存快照。<li>-XX:HeapDumpPath=/opt/dumps/my-service.hprof：堆内存快照的生成位置。与上一个参数一起用。<li>-XX:+PrintGCDetails：打印详细的垃圾回收日志。<li>-XX:+PrintGCDateStamps：打印垃圾回收使用。<li>-Xloggc:文件路径：日志文件输出位置。</ul><p>注意事项：JDK9及之后，gc日志输出参数可修改为：<code>-Xlog:gc*:file=文件名</code>。<h3 id=2-8-3、回收器常用配置><a class=headerlink href=#2-8-3、回收器常用配置 title=2.8.3、回收器常用配置></a>2.8.3、回收器常用配置</h3><h4 id=吞吐量优先><a class=headerlink href=#吞吐量优先 title=吞吐量优先></a>吞吐量优先</h4><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment># 方案1</span></span><br><span class=line>java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20</span><br><span class=line><span class=comment># 方案2</span></span><br><span class=line>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC</span><br><span class=line><span class=comment># 方案3</span></span><br><span class=line>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100</span><br><span class=line><span class=comment># 方案4</span></span><br><span class=line>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy</span><br></pre></table></figure><h4 id=响应时间优先><a class=headerlink href=#响应时间优先 title=响应时间优先></a>响应时间优先</h4><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># 方案1</span></span><br><span class=line>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</span><br><span class=line><span class=comment># 方案2</span></span><br><span class=line>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</span><br></pre></table></figure><h1 id=3、JVM调优><a class=headerlink href=#3、JVM调优 title=3、JVM调优></a>3、JVM调优</h1><h2 id=3-1、调优须知><a class=headerlink href=#3-1、调优须知 title=3.1、调优须知></a>3.1、调优须知</h2><h3 id=3-1-1、重要概念><a class=headerlink href=#3-1-1、重要概念 title=3.1.1、重要概念></a>3.1.1、重要概念</h3><h4 id=3-1-1-1、内存泄漏><a class=headerlink href=#3-1-1-1、内存泄漏 title=3.1.1.1、内存泄漏></a>3.1.1.1、内存泄漏</h4><p>内存泄漏（Memory Leak）：<strong>程序申请内存后无法释放已申请的内存空间。</strong>一次内存泄露可以忽略，但内存泄露堆积，后果很严重。<h4 id=3-1-1-2、内存溢出><a class=headerlink href=#3-1-1-2、内存溢出 title=3.1.1.2、内存溢出></a>3.1.1.2、内存溢出</h4><p>内存溢出（Out Of Memory）：<strong>程序申请内存时没有足够的内存空间供其使用会出现Out Of Memory。</strong><h4 id=3-1-1-3、QPS><a class=headerlink href=#3-1-1-3、QPS title=3.1.1.3、QPS></a>3.1.1.3、QPS</h4><p><strong>QPS</strong>：全称——Queries Per Second，意思是<em><strong>每秒查询率</strong></em>，是一台服务器每秒能够响应的查询次数（数据库中的每秒执行查询sql的次数），显然，这个不够全面，不能描述增删改，所以，不建议用qps来作为系统性能指标。<h4 id=3-1-1-4、TPS><a class=headerlink href=#3-1-1-4、TPS title=3.1.1.4、TPS></a>3.1.1.4、TPS</h4><p><strong>TPS</strong>：全称——Transactions Per Second，意思是<em><strong>每秒事务数</strong></em>，具体事务的定义，都是人为的，可以一个接口、多个接口、一个业务流程等等。一个事务是指事务内第一个请求发送到接收到最后一个请求的响应的过程，以此来计算使用的时间和完成的事务个数。<p>以单接口定义的事务为例，每个事务包括了如下3个过程：<ol><li>向服务器发请求。<li>服务器自己的内部处理（包含应用服务器、数据库服务器等）。<li>服务器返回结果给客户端。</ol><p>如果每秒能够完成N次这三个过程，那么TPS就是N；<p>如果多个接口定义为一个事务，且1、2、3过程执行一轮为一次，那么1秒能执行多少次，TPS就是多少。<h4 id=3-1-1-5、吞吐量><a class=headerlink href=#3-1-1-5、吞吐量 title=3.1.1.5、吞吐量></a>3.1.1.5、吞吐量</h4><p><strong>吞吐量</strong>：用户代码时间 / (用户代码执行时间 + 垃圾回收时间)。<p>科学计算、数据挖掘等场景会注重吞吐量。<h4 id=3-1-1-6、响应时间><a class=headerlink href=#3-1-1-6、响应时间 title=3.1.1.6、响应时间></a>3.1.1.6、响应时间</h4><p><strong>响应时间</strong>：服务器接收到请求到返回结果给客户端这么一个过程所耗费的时间。STW时间越短，响应时间越好。<h3 id=3-1-1、调优目标><a class=headerlink href=#3-1-1、调优目标 title=3.1.1、调优目标></a>3.1.1、调优目标</h3><p>GC调优包含：内存调优、锁竞争调优、CPU占用调优、IO调优等众多领域。<p>GC调优前，要先确定调优的目标是什么？比如，目标是追求响应时间、吞吐量等。<h3 id=3-1-2、调优思路><a class=headerlink href=#3-1-2、调优思路 title=3.1.2、调优思路></a>3.1.2、调优思路</h3><h4 id=3-1-2-1、思路分析><a class=headerlink href=#3-1-2-1、思路分析 title=3.1.2.1、思路分析></a>3.1.2.1、思路分析</h4><p>调优，从业务场景开始，同时要遵循无监控，不调优的规则。<p>常见的调优思路如下：<ol><li><p>熟悉业务场景（选择垃圾收集器，垃圾收集器只有合适的，没有最好的）。</p> <ul><li>响应时间：停顿时间，（推荐：CMS / G1 / ZGC）<li>吞吐量：代码时间 / (代码时间 + GC时间)，（推荐：PS）</ul><li><p>选择回收器组合。</p><li><p>计算内存需求。</p><li><p>选定CPU（越高越好，按预算来）。</p><li><p>设置各种内存区域的大小，及相关参数。</p><li><p>开启日志。</p></ol><h4 id=3-1-2-2、常用参数><a class=headerlink href=#3-1-2-2、常用参数 title=3.1.2.2、常用参数></a>3.1.2.2、常用参数</h4><h5 id=日志参数><a class=headerlink href=#日志参数 title=日志参数></a>日志参数</h5><p>与日志相关的常用参数如下：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>// JDK8及之前</span><br><span class=line>-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:文件路径</span><br><span class=line></span><br><span class=line>// JDK9开始</span><br><span class=line>-Xlog:gc*:file=文件路径</span><br></pre></table></figure><h5 id=其它命令><a class=headerlink href=#其它命令 title=其它命令></a>其它命令</h5><ol><li>java -XX:+PrintFlagsInitial：打印默认参数值；<li>java -XX:+PrintFlagsFinal：打印最终参数值；<li>java -XX:+PrintFlagsFinal | grep xxx：找到对应的参数；<li>java -XX:+PrintFlagsFinal -version | grep GC；</ol><h2 id=3-2、GC日志><a class=headerlink href=#3-2、GC日志 title=3.2、GC日志></a>3.2、GC日志</h2><h3 id=3-7-1、准备><a class=headerlink href=#3-7-1、准备 title=3.7.1、准备></a>3.7.1、准备</h3><p>测试代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">HelloGC</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        System.out.println(<span class=string>"HellGC."</span>);</span><br><span class=line>        <span class=type>List</span> <span class=variable>list</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">LinkedList</span>();</span><br><span class=line>        <span class=keyword>for</span> (;;){</span><br><span class=line>            <span class=type>byte</span>[] b = <span class=keyword>new</span> <span class="title class_">byte</span>[<span class=number>1024</span> * <span class=number>1024</span>];</span><br><span class=line>            list.add(b);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>测试一：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令</span></span><br><span class=line>java -XX:+PrintCommandLineFlags HelloGC</span><br><span class=line></span><br><span class=line><span class=comment># 输出</span></span><br><span class=line>-XX:InitialHeapSize=29592512 -XX:MaxHeapSize=473480192 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops </span><br><span class=line>HelloGC</span><br><span class=line>Exception <span class=keyword>in</span> thread <span class=string>"main"</span> java.lang.OutOfMemoryError: Java heap space at HelloGC.main(HelloGC.java:9)</span><br></pre></table></figure><p>测试二：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令</span></span><br><span class=line>java -Xmn10M -Xms40M -Xmx60M -XX:+PrintCommandLineFlags -XX:+PrintGC HelloGC PrintGCDetails PrintGCTimeStamps PrintGCCauses</span><br><span class=line></span><br><span class=line><span class=comment># 输出</span></span><br><span class=line>-XX:InitialHeapSize=41943040 -XX:MaxHeapSize=62914560 -XX:MaxNewSize=10485760 -XX:NewSize=10485760 -XX:+PrintCommandLineFlags -XX:+PrintGC -XX:+UseCompressedClassPointers -XX:+UseCompressedOops </span><br><span class=line>HelloGC</span><br><span class=line>[GC (Allocation Failure)  7675K->7426K(39936K), 0.0065081 secs]</span><br><span class=line>[GC (Allocation Failure)  14756K->14594K(39936K), 0.0066781 secs]</span><br><span class=line>[GC (Allocation Failure)  21916K->21762K(39936K), 0.0082077 secs]</span><br><span class=line>[GC (Allocation Failure)  29086K->28931K(39936K), 0.0062089 secs]</span><br><span class=line>[GC (Allocation Failure)  36256K->36099K(45076K), 0.0077737 secs]</span><br><span class=line>[Full GC (Allocation Failure)  36099K->36098K(45076K), 0.0023287 secs]</span><br><span class=line>[GC (Allocation Failure)  43424K->43266K(60416K), 0.0068826 secs]</span><br><span class=line>[GC (Allocation Failure)  50592K->50434K(60416K), 0.0075865 secs]</span><br><span class=line>[Full GC (Allocation Failure)  57761K->57603K(60416K), 0.0027358 secs]</span><br><span class=line>[Full GC (Allocation Failure)  57603K->57591K(60416K), 0.0022941 secs]</span><br><span class=line>Exception <span class=keyword>in</span> thread <span class=string>"main"</span> java.lang.OutOfMemoryError: Java heap space at HelloGC.main(HelloGC.java:9)</span><br></pre></table></figure><p>测试三：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令</span></span><br><span class=line>java -XX:+UseConcMarkSweepGC -XX:+PrintCommandLineFlags HelloGC</span><br><span class=line></span><br><span class=line> <span class=comment># 输出</span></span><br><span class=line>-XX:InitialHeapSize=29592512 -XX:MaxHeapSize=473480192 -XX:MaxNewSize=87244800 -XX:MaxTenuringThreshold=6 -XX:OldPLABSize=16 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC </span><br><span class=line>HelloGC</span><br><span class=line>Exception <span class=keyword>in</span> thread <span class=string>"main"</span> java.lang.OutOfMemoryError: Java heap space at HelloGC.main(HelloGC.java:9)</span><br></pre></table></figure><h3 id=3-7-2、示例日志1><a class=headerlink href=#3-7-2、示例日志1 title=3.7.2、示例日志1></a>3.7.2、示例日志1</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>[GC (Allocation Failure) [DefNew (promotion failed) : 123228K->138592K(138816K), <span class=number>0.0698705</span> secs][Tenured: 308488K->308488K(308608K), <span class=number>0.0097199</span> secs] 360036K->359693K(447424K), </span><br><span class=line>[Metaspace: 2500K->2500K(1056768K)], <span class=number>0.0796660</span> secs] </span><br><span class=line>[Times: user=<span class=number>0.02</span> sys=<span class=number>0.06</span>, real=<span class=number>0.07</span> secs]</span><br></pre></table></figure><ul><li>GC：指YGC。<li>(Allocation Failure)：GC原因。<li>DefNew：产生的年代，这里是年轻代；后面的：123228K->138592K(138816K), 0.0698705 secs，其从左到右分别代表：回收前年轻代大小->回收后年轻代大小(整个年轻代的大小)，回收所消耗的时间；<li>[Tenured: 308488K->308488K(308608K), 0.0097199 secs]：从左到右分别代表：回收前堆大小->回收后堆大小(整个堆的大小)，回收消耗的时间。<li>[Metaspace: 2500K->2500K(1056768K)], 0.0796660 secs]：从左到右分别代表：回收前元空间大小->回收后大小(整个元空间的大小)，回收消耗的时间。<li>[Times: user=0.02 sys=0.06, real=0.07 secs]：从左到右分别代表：用户态消耗的时间、内核态消耗的时间，整个过程实际消耗多长时间。</ul><h3 id=3-7-3、示例日志2><a class=headerlink href=#3-7-3、示例日志2 title=3.7.3、示例日志2></a>3.7.3、示例日志2</h3><p>一旦内存溢出，就会把整个堆 heap dump出来：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>Heap</span><br><span class=line> def <span class=keyword>new</span> <span class="title class_">generation</span>   total 138816K, used 138753K [<span class=number>0x00000000e3c00000</span>, <span class=number>0x00000000ed2a0000</span>, <span class=number>0x00000000ed2a0000</span>)</span><br><span class=line>  eden space 123392K, <span class=number>100</span>% used [<span class=number>0x00000000e3c00000</span>, <span class=number>0x00000000eb480000</span>, <span class=number>0x00000000eb480000</span>)</span><br><span class=line>  from space 15424K,  <span class=number>99</span>% used [<span class=number>0x00000000ec390000</span>, <span class=number>0x00000000ed290478</span>, <span class=number>0x00000000ed2a0000</span>)</span><br><span class=line>  to   space 15424K,   <span class=number>0</span>% used [<span class=number>0x00000000eb480000</span>, <span class=number>0x00000000eb480000</span>, <span class=number>0x00000000ec390000</span>)</span><br><span class=line> tenured generation   total 308608K, used 308477K [<span class=number>0x00000000ed2a0000</span>, <span class=number>0x0000000100000000</span>, <span class=number>0x0000000100000000</span>)</span><br><span class=line>   the space 308608K,  <span class=number>99</span>% used [<span class=number>0x00000000ed2a0000</span>, <span class=number>0x00000000fffdf618</span>, <span class=number>0x00000000fffdf800</span>, <span class=number>0x0000000100000000</span>)</span><br><span class=line> Metaspace       used 2531K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class=line>  <span class=keyword>class</span> <span class="title class_">space</span>    used 272K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></table></figure><ul><li><p>Metaspace used 2531K, capacity 4486K, committed 4864K, reserved 1056768K：2531K表示已使用；4486K表示总容量；4864K表示虚拟内存占用；1056768K表示虚拟内存保留容量。</p><li><p>total = eden + 一个survivor</p><li><p>年轻代大小加起来不相等？因为除了new的对象和年轻代外还有其他信息。观察日志主要看的是变化。</p></ul><h2 id=3-3、调优工具><a class=headerlink href=#3-3、调优工具 title=3.3、调优工具></a>3.3、调优工具</h2><h3 id=3-5-1、Arthas><a class=headerlink href=#3-5-1、Arthas title=3.5.1、Arthas></a>3.5.1、Arthas</h3><h4 id=常用命令><a class=headerlink href=#常用命令 title=常用命令></a>常用命令</h4><p>1、dump到指定文件（使用jhat进行分析）<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>heapdump</span> <span class=string>/tmp/dump.hprof</span></span><br></pre></table></figure><p>2、仅dump live对象<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>heapdump</span> <span class=string>--live /tmp/dump.hprof</span></span><br></pre></table></figure><p>3、展示当前进程信息<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>dashboard</span></span><br></pre></table></figure><p>4、打印线程ID的栈信息<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>thread</span> <span class=string>id </span></span><br></pre></table></figure><p>5、可以方便查看死锁<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>thread</span> <span class=string>-b id</span></span><br></pre></table></figure><p>6、反编译<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>jad</span> <span class=string>*.class    如：jad HelloGC</span></span><br></pre></table></figure><p>反编译需要注意以下问题：<ol><li><font color=red>动态代理生成类问题；</font><li><font color=red>第三方类；（观察代码）</font><li><font color=red>版本问题；（确定自己最新提交的版本是不是被使用）</font></ol><p><font color=red>注意：配合热替换使用，但要注意热替换的限制问题。</font><p>7、热替换<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>redefine /opt/XXX.class</span><br></pre></table></figure><p>实现步骤：<ol><li>运行测试类A；（A中有方法m，m中打印数字1。）<li>现需要修改类A中方法m的逻辑，让其打印数字2；<li>在不停掉1步骤中类A的情况下，直接修改类A中方法m的逻辑（打印2），然后重新编译（javac A.java）；<li>执行arthas命令：<code>redefine /opt/A.class</code>，即可实现热替换；（命令中的A.class是修改后的最新版本）</ol><p>限制条件有：<ol><li>只能修改方法实现；（方法已经运行）<li>不能改方法名；<li>不能改属性；</ol><h3 id=3-5-2、VisualVM><a class=headerlink href=#3-5-2、VisualVM title=3.5.2、VisualVM></a>3.5.2、VisualVM</h3><h3 id=3-5-3、Profiler><a class=headerlink href=#3-5-3、Profiler title=3.5.3、Profiler></a>3.5.3、Profiler</h3><h3 id=3-5-4、GCEasy><a class=headerlink href=#3-5-4、GCEasy title=3.5.4、GCEasy></a>3.5.4、GCEasy</h3><h3 id=3-5-5、GCViewer><a class=headerlink href=#3-5-5、GCViewer title=3.5.5、GCViewer></a>3.5.5、GCViewer</h3><p>GCViewer是一个将GC日志转为可视化图表的工具。<p>通过命令<code>java -jar gcviewer_1.3.4.jar 日志文件.log</code>即可查看转换结果。<h2 id=3-4、调优建议><a class=headerlink href=#3-4、调优建议 title=3.4、调优建议></a>3.4、调优建议</h2><h3 id=3-4-1、选择垃圾回收器><a class=headerlink href=#3-4-1、选择垃圾回收器 title=3.4.1、选择垃圾回收器></a>3.4.1、选择垃圾回收器</h3><p>没有最好的垃圾回收器，只有最合适的垃圾回收器。要想程序运行表现符合自己的期望，就要选择适合当前程序的垃圾回收器。<p>对于一个程序或项目来说，<strong>如果追求更快的响应时间，希望提升用户的整体体验，那么可以选择响应时间优先的垃圾回收器，即CMS、G1、ZGC。如果追求的是吞吐量，对响应时间并无苛刻要求，那么可以选择使用吞吐量优先的垃圾回收器，即ParallelGC</strong>。<h3 id=3-4-2、新生代调优><a class=headerlink href=#3-4-2、新生代调优 title=3.4.2、新生代调优></a>3.4.2、新生代调优</h3><h4 id=3-4-2-1、概述><a class=headerlink href=#3-4-2-1、概述 title=3.4.2.1、概述></a>3.4.2.1、概述</h4><p>当线程创建一个对象时，需要在Eden区中当前线程私有的TLAB中为该对象分配内存。当多个线程多次创建对象并在Eden区中分配内存时，Eden区的空间将会被逐渐消耗完。当Eden区中没有空闲空间用来分配新创建的对象时，就会触发垃圾回收器的YGC操作，垃圾回收器会通过YGC操作将Eden区和Survivor From区中的存活对象转移至Survivor To区中，然后对Eden区和Survivor From区中剩余的垃圾对象进行清除回收，回收后的空间就可以再次被用于新对象的内存分配。注意的是，每当执行一次年轻代垃圾回收，Survivor区的From和To会交换角色，如此一来，每次都可以将存活对象转移到To区中。<p>新生代调优要考虑的方面为：<strong>为新生代分配合适的可以满足（单次请求响应*并发量）需要的内存大小，尽量避免YGC的频繁执行</strong>。<p>参数<code>-XX:NewSize</code>可设置新生代初始大小，参数<code>-XX:MaxNewSize</code>可设置新生代最大空间。除了这两个参数外，可以使用参数<code>-Xmn大小</code>来设置新生代的初始和最大内存，该参数可替代前面两个参数。参数值的单位可以是M、K、字节。<p><strong>oracle官方建议：年轻代的大小应该保持在堆总大小的1/4~1/2之间</strong>。<h4 id=3-4-2-2、Survivor区><a class=headerlink href=#3-4-2-2、Survivor区 title=3.4.2.2、Survivor区></a>3.4.2.2、Survivor区</h4><p>Survivor区也成为幸存区，分为From和To两个部分。Survivor To区中主要存储Eden区和Survivor From区中转移过来的存活对象，这种转移在底层通过<strong>复制算法</strong>完成，转移完成后这些存活对象的年龄会加1。这些存活对象经过多次复制转移，年龄会依次递增，当年龄达到晋升阈值时，会将这些年龄到达阈值的存活对象复制到老年代中。<p>复制算法复制转移对象的成本相对较高，因此，对于Survivor区优化来说，可以考虑的方面为：<strong>适当降低对象晋升至老年代时的年龄阈值，避免多次无意义的复制操作，一定程度上减少了性能的损耗</strong>。<p>参数<code>-XX:MaxTenuringThreshold=threshold</code>可设置触发对象晋升至老年代的年龄阈值。参数<code>-XX:+PrintTenuringDistribution</code>可实现打印对象晋升时相关日志。<h3 id=3-4-3、老年代调优><a class=headerlink href=#3-4-3、老年代调优 title=3.4.3、老年代调优></a>3.4.3、老年代调优</h3><h4 id=3-4-3-1、CMS垃圾回收器><a class=headerlink href=#3-4-3-1、CMS垃圾回收器 title=3.4.3.1、CMS垃圾回收器></a>3.4.3.1、CMS垃圾回收器</h4><p>对于基于CMS垃圾回收器的程序或应用来调优时，可参考如下几点：<ul><li>老年代空间尽可能大一点。<li>当发生FGC时，先尝试调优新生代。<li>如果FGC并非因新生代的问题触发，则先观察FGC触发时老年代内存的占用情况。如果老年代内存偏小，则需根据实际情况通过扩容或降低触发GC的阈值来尝试解决。</ul><p>FGC的触发，可能是硬件原因，也可能是年轻代、老年代本身的原因。硬件原因说的是当前的硬件资源环境不能满足程序的良好运行，因此导致了问题的出现。年轻代、老年代原因说的是没有根据实际情况对堆内存做出合适的配置和优化，进而导致问题的出现。<p><strong>如果FGC是由硬件资源不足导致，可通过增加硬件资源来改善和避免。如果FGC是因年轻代、老年代等的不合理配置导致，则可以通过实验得出较合理的配置</strong>。比如，若老年代空间不足，则可以尝试为其扩容1/4~1/3来解决，也可以通过参数<code>-XX:CMSInitiatingOccupancyFraction=percent</code>来设置合适的GC触发阈值，让GC提前执行来尝试解决。<h2 id=3-5、调优案例><a class=headerlink href=#3-5、调优案例 title=3.5、调优案例></a>3.5、调优案例</h2><h3 id=3-5-1、案例一><a class=headerlink href=#3-5-1、案例一 title=3.5.1、案例一></a>3.5.1、案例一</h3><h4 id=案例代码><a class=headerlink href=#案例代码 title=案例代码></a>案例代码</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.math.BigDecimal;</span><br><span class=line><span class=keyword>import</span> java.util.ArrayList;</span><br><span class=line><span class=keyword>import</span> java.util.Date;</span><br><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.TimeUnit;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">FullGC_Problem01</span> {</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">CardInfo</span>{</span><br><span class=line>        <span class=type>BigDecimal</span> <span class=variable>bigDecimal</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">BigDecimal</span>(<span class=number>0.0</span>);</span><br><span class=line>        <span class=type>String</span> <span class=variable>name</span> <span class=operator>=</span> <span class=string>"ZhangSan"</span>;</span><br><span class=line>        <span class=type>int</span> <span class=variable>age</span> <span class=operator>=</span> <span class=number>18</span>;</span><br><span class=line>        <span class=type>Date</span> <span class=variable>birthdate</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Date</span>();</span><br><span class=line></span><br><span class=line>        <span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">m</span><span class=params>()</span>{}</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>ScheduledThreadPoolExecutor</span> <span class=variable>executor</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class=number>50</span>, <span class=keyword>new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy());</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> Exception{</span><br><span class=line>        executor.setMaximumPoolSize(<span class=number>50</span>);</span><br><span class=line>        <span class=keyword>for</span> (;;){</span><br><span class=line>            modelFit();</span><br><span class=line>            Thread.sleep(<span class=number>100</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">modelFit</span><span class=params>()</span>{</span><br><span class=line>        List&LTCardInfo> taskList = getAllCardInfo();</span><br><span class=line>        taskList.forEach(info -> {</span><br><span class=line>            executor.scheduleWithFixedDelay(() -> {</span><br><span class=line>                info.m();</span><br><span class=line>            }, <span class=number>2</span>, <span class=number>3</span>, TimeUnit.SECONDS);</span><br><span class=line>        });</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> List&LTCardInfo> <span class="title function_">getAllCardInfo</span><span class=params>()</span>{</span><br><span class=line>        List&LTCardInfo> taskList = <span class=keyword>new</span> <span class="title class_">ArrayList</span><>();</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < <span class=number>100</span>; i++){</span><br><span class=line>            <span class=type>CardInfo</span> <span class=variable>ci</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">CardInfo</span>();</span><br><span class=line>            taskList.add(ci);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> taskList;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h4 id=排查过程><a class=headerlink href=#排查过程 title=排查过程></a>排查过程</h4><p><strong>1）运行测试程序</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -Xms200m -Xmx200m -XX:+PrintGC -XX:+HeapDumpOnOutOfMemoryError FullGC_Problem01</span><br></pre></table></figure><p><strong>2）查看CPU占用，拿到占比较高的进程ID。</strong><p>通过命令 top 查找耗费CPU最高的进程PID，比如3568。<p><strong>3）找到CPU占用最高的线程ID，查看线程运行情况。</strong><ol><li>通过命令<code>top -Hp 3568</code>查找当前进程中耗费CPU最高的线程PID，比如1374；<li>通过命令<code>printf "%x\n" 1374</code>可以把线程PID转为16进制，比如转换后得到 55e；<li>通过命令<code>jstack 3568 | grep -20 55e</code>查找当前线程阻塞的位置；</ol><p><strong>4）查看线程运行情况</strong>：执行<code>jinfo pid</code>命令。<p><strong>5）观察GC执行情况。</strong><p>通过命令<code>jstat -gc PID</code> 观察gc动态情况，阅读GC日志发现频繁GC，arthas观察，jconsole，jvisualVM，Jprofiler（最好用）。<p>通过命令<code>jstat -gc 4655 500</code>实现每500毫秒打印一次GC情况。<blockquote><p>注意：图形界面监控一般适用于测试阶段，线上系统监控一般使用命令行调式工具——cmdline、Arthas。</blockquote><p><strong>6）查看对象创建的数量。</strong><p>通过命令<code>jmap -histo pid | head -20</code>查看对象创建数量排名前20的对象信息。<p><strong>7）导出dump信息文件。</strong><p>通过命令<code>jmap -dump:format=b,file=D:\test\heap.hprof 6956</code>将当前堆栈信息导出到一个文件中。<blockquote><p>线上系统，内存特别大，jmap执行期间会对进程产生很大影响，甚至卡顿（电商不适合）<ol><li>设定参数HeapDump，OOM的时会自动产生堆转储文件（不是很专业，因为多有监控，内存增长就会报警。<li>多服务器备份（高可用），停掉这台服务器对其他服务器不影响。<li>在线定位(一般小点儿公司用不到)。<li>在测试环境中压测（产生类似内存增长问题，在堆还不是很大的时候进行转储）。</ol></blockquote><p><strong>8）重新运行测试程序。</strong><p><code>java -Xms20M -Xmx20M -XX:+UseParallelGC -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/opt/test_jvm/gc_out/ FullGC_Problem01</code><p><strong>9）分析dump文件。</strong><p>使用<code>MAT、jhat、jvisualvm</code>工具来分析dump文件。<p>执行命令<code>jhat -J-Xmx512M xxx.hprof</code>后会在7000端口开启一个服务，通过浏览器可以访问该服务并对其执行相关操作，比如可以使用OQL查找特定问题对象。<p><strong>10）找出代码问题。</strong><h2 id=3-6、OOM问题案例><a class=headerlink href=#3-6、OOM问题案例 title=3.6、OOM问题案例></a>3.6、OOM问题案例</h2><h3 id=3-6-1、堆内存溢出><a class=headerlink href=#3-6-1、堆内存溢出 title=3.6.1、堆内存溢出></a>3.6.1、堆内存溢出</h3><p><strong>（1）创建了大且多的对象</strong><h3 id=3-6-2、方法区内存溢出><a class=headerlink href=#3-6-2、方法区内存溢出 title=3.6.2、方法区内存溢出></a>3.6.2、方法区内存溢出</h3><p><strong>（1）动态生成类</strong><h3 id=3-6-3、栈溢出><a class=headerlink href=#3-6-3、栈溢出 title=3.6.3、栈溢出></a>3.6.3、栈溢出</h3><p><strong>（1）递归深度多大</strong><h3 id=3-6-4、直接内存溢出><a class=headerlink href=#3-6-4、直接内存溢出 title=3.6.4、直接内存溢出></a>3.6.4、直接内存溢出</h3><p><strong>（1）NIO操作</strong><h3 id=3-6-5、其它><a class=headerlink href=#3-6-5、其它 title=3.6.5、其它></a>3.6.5、其它</h3><p><strong>（1）创建大量线程</strong><p><strong>（2）连接池多且大，且连接没有关闭</strong><p><strong>（3）第三方库问题，或使用不当造成</strong><h2 id=3-7、垃圾回收器调优><a class=headerlink href=#3-7、垃圾回收器调优 title=3.7、垃圾回收器调优></a>3.7、垃圾回收器调优</h2><h3 id=3-7-1、G1调优><a class=headerlink href=#3-7-1、G1调优 title=3.7.1、G1调优></a>3.7.1、G1调优</h3><p>触发FGC的情况如下：<p><strong>（1）并发模式失败</strong><p>G1启动标记周期，但在Mix GC之前，老年代就被填满，此时G1会放弃标记周期。这种情形下，需要增加堆大小，或者调整周期（例如增加线程数-XX:ConcGCThreads等）。<p><strong>（2）晋升失败或疏散失败</strong><p><strong>G1 GC时如果没有足够的内存供存活对象或晋升对象使用时会触发Full GC。可以在日志中看到（to-space exhausted）或者（to-space overflow）。</strong>解决该问题的方式如下：<ol><li>增加参数<code>-XX:G1ReservePercent</code>的值（并相应增加总的堆大小），为“目标空间”增加预留内存。<li>减少参数<code>-XX:InitiatingHeapOccupancyPercent</code>的值，提前启动标记周期。<li>增加参数<code>-XX:ConcGCThreads</code>的值，增加并行标记线程的数目。</ol><p><strong>（3）巨型对象分配失败</strong><p>当巨型对象找不到空闲空间分配时会触发Full GC来释放空间。这种情况下，应该避免分配大量的巨型对象，增加内存或者增大<code>-XX:G1HeapRegionSize</code>，使巨型对象不再是巨型对象。<h2 id=3-8、场景分析优化><a class=headerlink href=#3-8、场景分析优化 title=3.8、场景分析优化></a>3.8、场景分析优化</h2><h3 id=3-8-1、卡慢场景><a class=headerlink href=#3-8-1、卡慢场景 title=3.8.1、卡慢场景></a>3.8.1、卡慢场景</h3><p><strong>场景1</strong>：原服务器32位、1.5G内存堆，用户反馈慢。优化升级为64位、16G内存堆后，反馈更慢，反而不如从前。<p><strong>1）原网站为啥慢？</strong><p>多用户访问数据，故大量数据加载至内存，从而造成内存不足、频繁GC、STW长、响应时间慢等问题。<p><strong>2）为什么会卡顿？</strong><p>内存越大，FGC时间就会越长。<p><strong>3）如何应对？</strong><p>PS 更改为 PN + CMS 或者 G1。<h3 id=3-8-2、CPU消耗高问题><a class=headerlink href=#3-8-2、CPU消耗高问题 title=3.8.2、CPU消耗高问题></a>3.8.2、CPU消耗高问题</h3><p>场景1：系统CPU经常100%，如何调优？<p>解决方案参考如下：<ol><li>找出消耗CPU较高的进程；可使用 top 命令查看。<li>该进程中哪个线程消耗CPU较高；可使用 top -Hp 命令查看。<li>导出该线程的堆栈；可使用 jstack 命令实现。<li>查找哪个方法（栈帧）导致的问题。<li>工作线程占比高 | 垃圾回收线程占比高。</ol><h3 id=3-8-3、内存消耗高问题><a class=headerlink href=#3-8-3、内存消耗高问题 title=3.8.3、内存消耗高问题></a>3.8.3、内存消耗高问题</h3><p>场景1：系统内存飙高，如何定位及应对？<p>参考解决方案如下：<ol><li>堆栈比较多，导出堆信息；可使用 jmap 命令实现。<li>通过工具分析，分析工具有：jhat、jvisualvm、mat、jprofiler等。</ol><h3 id=3-8-4、如何监控JVM><a class=headerlink href=#3-8-4、如何监控JVM title=3.8.4、如何监控JVM></a>3.8.4、如何监控JVM</h3><p>工具：jstat、jvisualvm、jprofiler、arthas、top。</div><footer class=post-footer><div class=post-tags><a href=/tags/JVM/ rel=tag># JVM</a></div><div class=post-nav><div class=post-nav-item><a href=/2024/10/12/Java%E4%B9%8BASM%E7%9F%A5%E8%AF%86%E7%AF%87/ rel=prev title=Java系列-ASM> <i class="fa fa-angle-left"></i> Java系列-ASM </a></div><div class=post-nav-item><a href=/2024/10/12/Java%E4%B9%8BWeb%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AF%87/ rel=next> <i class="fa fa-angle-right"></i> </a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script>