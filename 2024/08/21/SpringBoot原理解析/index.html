<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hgprivate.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="启动初始化SpringBoot的启动和初始化步骤主要由 SpringApplication.run(String..) 方法和AbstractApplicationContext.refresh() 方法完成。 SpringApplication.run(String…)中会调用AbstractApplicationContext.run()方法。 当然，最初先调用SprirngApplicati" name=description><meta content=article property=og:type><meta content=SpringBoot系列-SpringBoot原理解析 property=og:title><meta content=https://hgprivate.github.io/2024/08/21/SpringBoot%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content="启动初始化SpringBoot的启动和初始化步骤主要由 SpringApplication.run(String..) 方法和AbstractApplicationContext.refresh() 方法完成。 SpringApplication.run(String…)中会调用AbstractApplicationContext.run()方法。 当然，最初先调用SprirngApplicati" property=og:description><meta content=zh_CN property=og:locale><meta content=2024-08-21T13:39:14.704Z property=article:published_time><meta content=2023-10-03T14:02:20.348Z property=article:modified_time><meta content=豪哥 property=article:author><meta content=SpringBoot property=article:tag><meta content=SpringBoot原理 property=article:tag><meta content=summary name=twitter:card><link href=https://hgprivate.github.io/2024/08/21/SpringBoot%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hgprivate.github.io/2024/08/21/SpringBoot%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","path":"2024/08/21/SpringBoot原理解析/","title":"SpringBoot系列-SpringBoot原理解析"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>SpringBoot系列-SpringBoot原理解析 | 豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>豪哥博客</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%90%AF%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96><span class=nav-number>1.</span> <span class=nav-text>启动初始化</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81SpringApplication-run-String%E2%80%A6><span class=nav-number>1.1.</span> <span class=nav-text>1.1、SpringApplication.run(String…)</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-1%E3%80%81SpringApplication-createBootstrapContext><span class=nav-number>1.1.1.</span> <span class=nav-text>1.1.1、SpringApplication.createBootstrapContext()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-2%E3%80%81SpringApplication-configureHeadlessProperty><span class=nav-number>1.1.2.</span> <span class=nav-text>1.1.2、SpringApplication.configureHeadlessProperty()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-3%E3%80%81SpringApplication-getRunListeners><span class=nav-number>1.1.3.</span> <span class=nav-text>1.1.3、SpringApplication.getRunListeners(.)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-4%E3%80%81SpringApplicationRunListeners-starting><span class=nav-number>1.1.4.</span> <span class=nav-text>1.1.4、SpringApplicationRunListeners.starting(..)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-5%E3%80%81new-DefaultApplicationArguments-args><span class=nav-number>1.1.5.</span> <span class=nav-text>1.1.5、new DefaultApplicationArguments(args)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-6%E3%80%81SpringApplication-prepareEnvironment-%E2%80%A6><span class=nav-number>1.1.6.</span> <span class=nav-text>1.1.6、SpringApplication.prepareEnvironment(…)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-7%E3%80%81SpringApplication-configureIgnoreBeanInfo><span class=nav-number>1.1.7.</span> <span class=nav-text>1.1.7、SpringApplication.configureIgnoreBeanInfo()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-8%E3%80%81SpringApplication-printBanner><span class=nav-number>1.1.8.</span> <span class=nav-text>1.1.8、SpringApplication.printBanner(.)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-9%E3%80%81SpringApplication-createApplicationContext><span class=nav-number>1.1.9.</span> <span class=nav-text>1.1.9、SpringApplication.createApplicationContext()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-10%E3%80%81GenericApplicationContext-setApplicationStartup><span class=nav-number>1.1.10.</span> <span class=nav-text>1.1.10、GenericApplicationContext.setApplicationStartup(.)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-11%E3%80%81SpringApplicationContext-prepareContext><span class=nav-number>1.1.11.</span> <span class=nav-text>1.1.11、SpringApplicationContext.prepareContext()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-12%E3%80%81SpringApplication-refreshContext><span class=nav-number>1.1.12.</span> <span class=nav-text>1.1.12、SpringApplication.refreshContext(.)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-13%E3%80%81SpringApplication-afterRefresh><span class=nav-number>1.1.13.</span> <span class=nav-text>1.1.13、SpringApplication.afterRefresh(..)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-14%E3%80%81SpringApplicationRunListeners-started><span class=nav-number>1.1.14.</span> <span class=nav-text>1.1.14、SpringApplicationRunListeners.started(..)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-15%E3%80%81SpringApplication-callRunners><span class=nav-number>1.1.15.</span> <span class=nav-text>1.1.15、SpringApplication.callRunners(..)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-16%E3%80%81catch-Throwable><span class=nav-number>1.1.16.</span> <span class=nav-text>1.1.16、catch:Throwable</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-17%E3%80%81SpringApplicationRunListeners-ready><span class=nav-number>1.1.17.</span> <span class=nav-text>1.1.17、SpringApplicationRunListeners.ready(..)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-18%E3%80%81catch-Throwable><span class=nav-number>1.1.18.</span> <span class=nav-text>1.1.18、catch:Throwable</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-2%E3%80%81AbstractApplicationContext-refresh><span class=nav-number>1.2.</span> <span class=nav-text>1.2、AbstractApplicationContext.refresh()</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-1%E3%80%81DefaultApplicationStartup-start-%E2%80%9Cspring-context-refresh%E2%80%9D><span class=nav-number>1.2.1.</span> <span class=nav-text>1.2.1、DefaultApplicationStartup.start(“spring.context.refresh”)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-2%E3%80%81AnnnotationConfigServletWebServerApplicationContext-prepareRefresh><span class=nav-number>1.2.2.</span> <span class=nav-text>1.2.2、AnnnotationConfigServletWebServerApplicationContext.prepareRefresh()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-3%E3%80%81AbstractApplicationContext-obtainFreshBeanFactory><span class=nav-number>1.2.3.</span> <span class=nav-text>1.2.3、AbstractApplicationContext.obtainFreshBeanFactory()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-4%E3%80%81AbstractApplicationContext-prepareBeanFactory><span class=nav-number>1.2.4.</span> <span class=nav-text>1.2.4、AbstractApplicationContext.prepareBeanFactory()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-5%E3%80%81AnnotationConfigServletWebServerApplicationContext-postProcessBeanFactory><span class=nav-number>1.2.5.</span> <span class=nav-text>1.2.5、AnnotationConfigServletWebServerApplicationContext.postProcessBeanFactory(.)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-6%E3%80%81DefaultApplicationStartup-start-%E2%80%9Cspring-context-beans-post-process%E2%80%9D><span class=nav-number>1.2.6.</span> <span class=nav-text>1.2.6、DefaultApplicationStartup.start(“spring.context.beans.post-process”)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-7%E3%80%81AbstractApplicationContext-invokeBeanFactoryPostProcessors><span class=nav-number>1.2.7.</span> <span class=nav-text>1.2.7、AbstractApplicationContext.invokeBeanFactoryPostProcessors(.)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-8%E3%80%81AbstractApplicationContext-registerBeanPostProcessors><span class=nav-number>1.2.8.</span> <span class=nav-text>1.2.8、AbstractApplicationContext.registerBeanPostProcessors(.)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-9%E3%80%81DefaultApplicationStartup-DefaultStartupStep-end><span class=nav-number>1.2.9.</span> <span class=nav-text>1.2.9、DefaultApplicationStartup.DefaultStartupStep.end()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-10%E3%80%81AbstractApplicationContext-initMessageSource><span class=nav-number>1.2.10.</span> <span class=nav-text>1.2.10、AbstractApplicationContext.initMessageSource()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-11%E3%80%81AbstractApplicationContext-initApplicationEventMulticaster><span class=nav-number>1.2.11.</span> <span class=nav-text>1.2.11、AbstractApplicationContext.initApplicationEventMulticaster()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-12%E3%80%81ServletWebServerApplicationContext-onRefresh><span class=nav-number>1.2.12.</span> <span class=nav-text>1.2.12、ServletWebServerApplicationContext.onRefresh()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-13%E3%80%81AbstractApplicationContext-registerListeners><span class=nav-number>1.2.13.</span> <span class=nav-text>1.2.13、AbstractApplicationContext.registerListeners()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-14%E3%80%81AbstractApplicationContext-finishBeanFactoryInitialization><span class=nav-number>1.2.14.</span> <span class=nav-text>1.2.14、AbstractApplicationContext.finishBeanFactoryInitialization(.)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-15%E3%80%81AbstractApplicationContext-finishRefresh><span class=nav-number>1.2.15.</span> <span class=nav-text>1.2.15、AbstractApplicationContext.finishRefresh()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-16%E3%80%81catch-BeanException><span class=nav-number>1.2.16.</span> <span class=nav-text>1.2.16、catch:BeanException</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-18%E3%80%81finally><span class=nav-number>1.2.17.</span> <span class=nav-text>1.2.18、finally</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#Web%E5%BC%80%E5%8F%91><span class=nav-number>2.</span> <span class=nav-text>Web开发</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81%E6%A6%82%E8%BF%B0><span class=nav-number>2.1.</span> <span class=nav-text>1.1、概述</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-2%E3%80%81Servlet%E5%BA%94%E7%94%A8><span class=nav-number>2.2.</span> <span class=nav-text>1.2、Servlet应用</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-1%E3%80%81%E6%A6%82%E8%BF%B0><span class=nav-number>2.2.1.</span> <span class=nav-text>1.2.1、概述</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-2%E3%80%81ErrorMvcAutoConfiguration><span class=nav-number>2.2.2.</span> <span class=nav-text>1.2.2、ErrorMvcAutoConfiguration</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-3%E3%80%81ServletWebServerFactoryAutoConfiguration><span class=nav-number>2.2.3.</span> <span class=nav-text>1.2.3、ServletWebServerFactoryAutoConfiguration</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-4%E3%80%81DispatcherServletAutoConfiguration><span class=nav-number>2.2.4.</span> <span class=nav-text>1.2.4、DispatcherServletAutoConfiguration</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-5%E3%80%81TaskExecutionAutoConfiguration><span class=nav-number>2.2.5.</span> <span class=nav-text>1.2.5、TaskExecutionAutoConfiguration</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-6%E3%80%81ValidationAutoConfiguration><span class=nav-number>2.2.6.</span> <span class=nav-text>1.2.6、ValidationAutoConfiguration</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-7%E3%80%81WebMvcAutoConfiguration><span class=nav-number>2.2.7.</span> <span class=nav-text>1.2.7、WebMvcAutoConfiguration</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-3%E3%80%81Client%E5%BA%94%E7%94%A8><span class=nav-number>2.3.</span> <span class=nav-text>1.3、Client应用</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-1%E3%80%81GsonAutoConfiguration><span class=nav-number>2.3.1.</span> <span class=nav-text>1.3.1、GsonAutoConfiguration</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-2%E3%80%81JacksonAutoConfiguration><span class=nav-number>2.3.2.</span> <span class=nav-text>1.3.2、JacksonAutoConfiguration</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-3%E3%80%81JsonbAutoConfiguration><span class=nav-number>2.3.3.</span> <span class=nav-text>1.3.3、JsonbAutoConfiguration</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-4%E3%80%81HttpMessageConvertersAutoConfiguration><span class=nav-number>2.3.4.</span> <span class=nav-text>1.3.4、HttpMessageConvertersAutoConfiguration</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-5%E3%80%81RestTemplateAutoConfiguration><span class=nav-number>2.3.5.</span> <span class=nav-text>1.3.5、RestTemplateAutoConfiguration</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-4%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BA%94%E7%94%A8><span class=nav-number>2.4.</span> <span class=nav-text>1.4、嵌入式应用</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-1%E3%80%81EmbeddedWebServerFactoryCustomizerAutoConfiguration><span class=nav-number>2.4.1.</span> <span class=nav-text>1.4.1、EmbeddedWebServerFactoryCustomizerAutoConfiguration</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-5%E3%80%81Reactive%E5%BA%94%E7%94%A8><span class=nav-number>2.5.</span> <span class=nav-text>1.5、Reactive应用</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#AOP%E7%AE%A1%E7%90%86><span class=nav-number>3.</span> <span class=nav-text>AOP管理</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81%E6%A6%82%E8%BF%B0-1><span class=nav-number>3.1.</span> <span class=nav-text>1.1、概述</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-2%E3%80%81AopAutoConfiguration><span class=nav-number>3.2.</span> <span class=nav-text>1.2、AopAutoConfiguration</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86><span class=nav-number>4.</span> <span class=nav-text>事务管理</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81%E6%A6%82%E8%BF%B0-2><span class=nav-number>4.1.</span> <span class=nav-text>1.1、概述</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-2%E3%80%81TransactionAutoConfiguration><span class=nav-number>4.2.</span> <span class=nav-text>1.2、TransactionAutoConfiguration</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-3%E3%80%81JtaAutoConfiguration><span class=nav-number>4.3.</span> <span class=nav-text>1.3、JtaAutoConfiguration</span></a></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>117</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>36</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>129</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://hgprivate.github.io/2024/08/21/SpringBoot%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="SpringBoot系列-SpringBoot原理解析 | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>SpringBoot系列-SpringBoot原理解析</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-03 22:02:20" datetime=2023-10-03T22:02:20+08:00 itemprop=dateModified>2023-10-03</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/SpringBoot/ itemprop=url rel=index><span itemprop=name>SpringBoot</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=启动初始化><a class=headerlink href=#启动初始化 title=启动初始化></a>启动初始化</h1><p><strong>SpringBoot的启动和初始化步骤主要由 SpringApplication.run(String..) 方法和AbstractApplicationContext.refresh() 方法完成</strong>。<p>SpringApplication.run(String…)中会调用AbstractApplicationContext.run()方法。<p>当然，<em><strong>最初先调用SprirngApplication(ResourceLoader, Class)来构造SpringApplication对象</strong></em>，详情如下：<p><strong>（1）初始化相关参数</strong><p>初始化bannerModel为Console，logStartupInfo为true，addCommandLineProperties为true，addConversionService为true，headLess为true，registerShutdownHook为true，isCustomEnvironment为false，lazyInitialization为false，applicationContextFactory为DefaultApplicationContextFactory，applicationStartup为DefaultApplicationStartup。<p><strong>（2）初始化当前应用的类型</strong><p><strong>如果存在DispatcherHandler，不存在DispatcherServlet和ServletContainer，那么应用类型为Reactive</strong>。<p><strong>如果不存在Servlet或ConfigurableWebApplicationContext，那么应用类型为None</strong>。<p><strong>除了上面两种情况，其它情况都属于Servlet应用</strong>。<p><strong>（3）初始化接口实现和确定主启动类</strong><p>初始化集合bootstrapRegistryInitializers为接口BootstrapRegistryInitializer的所有实现，初始化initializers为接口ApplicationContextInitializer的所有实现，初始化listeners为接口ApplicationListener的所有实现，初始化mainApplicationClass为启动类Class。<h2 id=1-1、SpringApplication-run-String…><a class=headerlink href=#1-1、SpringApplication-run-String… title=1.1、SpringApplication.run(String…)></a>1.1、SpringApplication.run(String…)</h2><h3 id=1-1-1、SpringApplication-createBootstrapContext><a class=headerlink href=#1-1-1、SpringApplication-createBootstrapContext title=1.1.1、SpringApplication.createBootstrapContext()></a>1.1.1、SpringApplication.createBootstrapContext()</h3><p>（1）创建DefaultBootstrapContext实例，实例名为bootstrapContext。<p>（2）遍历接口BootstrapRegistryInitializer的所有实现类，并调用每个实现类的initialize(bootstrapContext)方法，将bootstrapContext作为参数传进去。<p>（3）最终将创建的bootstrapContext实例return。<h3 id=1-1-2、SpringApplication-configureHeadlessProperty><a class=headerlink href=#1-1-2、SpringApplication-configureHeadlessProperty title=1.1.2、SpringApplication.configureHeadlessProperty()></a>1.1.2、SpringApplication.configureHeadlessProperty()</h3><p>（1）配置Headless属性<p>配置属性java.awt.headless，值默认为true。<h3 id=1-1-3、SpringApplication-getRunListeners><a class=headerlink href=#1-1-3、SpringApplication-getRunListeners title=1.1.3、SpringApplication.getRunListeners(.)></a>1.1.3、SpringApplication.getRunListeners(.)</h3><p><strong>（1）SpringApplication.getSpringFactoriesInstances(…)</strong><p>扫描<code>META-INF/spring.factories</code>文件，获取接口SpringApplicaitonRunListener的所有实现类。如果没有自定义，那么默认有1个，就是：org.springframework.boot.context.event.EventPublishingRunListener。<p>通过反射拿到每个实现类的构造器，调用其构造器实例化对象，然后通过集合List的默认排序方法进行排序。<p><strong>（2）return new SpringApplicationRunListeners(…)</strong><p>由LogAdapter.Sfl4jLocationAwareLog、上一步拿到的实现类实例、DefaultApplicationStartup作为参数来创建SpringApplicationRunListeners实例对象并return。<h3 id=1-1-4、SpringApplicationRunListeners-starting><a class=headerlink href=#1-1-4、SpringApplicationRunListeners-starting title=1.1.4、SpringApplicationRunListeners.starting(..)></a>1.1.4、SpringApplicationRunListeners.starting(..)</h3><p><strong>（1）构造3个参数，一个是String，两个是Consumer对象</strong>。<p>参数1：spring.boot.application.starting；参数2：DefaultBootstrapContext作为参数，调用传进来listener的starting方法；参数3：如果主类不为null，那么将字符串mainApplicationClass、字符串主类的全类名作为参数，调用传进来参数的tag方法。<p><strong>（2）SpringApplicationRunListeners.doWithListeners(String, Consumer, Consumer)</strong><p>调用DefaultApplicationStartup.start(“spring.boot.application.starting”)方法返回一个DefaultApplicationStartup.DefaultStartupStep实例对象。<p>执行参数2的Consumer，也就是执行所有listener的starting方法。执行参数3的Consumer，也就是调用上面返回的DefaultApplicationStartup.DefaultStartupStep实例对象的tag方法，然后调用end方法。<h3 id=1-1-5、new-DefaultApplicationArguments-args><a title="1.1.5、new DefaultApplicationArguments(args)" class=headerlink href=#1-1-5、new-DefaultApplicationArguments-args></a>1.1.5、new DefaultApplicationArguments(args)</h3><p>初始化DefaultApplicationArguments的source变量为DefaultApplicationArguments.Source，变量source的name参数值为commandLineArgs，nonOptionArgsPropertyName参数值为nonOptionArgs。<p>初始化DefaultApplicationArguments的args变量为空的String类型数组。<h3 id=1-1-6、SpringApplication-prepareEnvironment-…><a class=headerlink href=#1-1-6、SpringApplication-prepareEnvironment-… title=1.1.6、SpringApplication.prepareEnvironment(…)></a>1.1.6、SpringApplication.prepareEnvironment(…)</h3><p><strong>（1）SpringApplication.getOrCreateEnvironment()</strong><p>如果SpringApplication的变量ConfigurableEnvironment environment不为null，那么可以直接返回，不用往下执行了。<p>调用DefaultApplicationContextFactory.getFromSpringFactories(…)方法从META-INF/spring.factories文件中获取接口ApplicationContextFactory的所有实现，默认有2个，分别是AnnotationConfigReactiveWebServerApplicationContext.Factory和AnnotationConfigServletWebServerApplicationContext.Factory，并创建每个实现类的实例对象。<p>将实现类对象、WebApplicationType作为参数调用ApplicationContextFactory.createEnvironment()方法，然后将该方法的返回值return，如果项目是servlet项目，那么这里返回的是ApplicationServletEnvironment，最终会再将之强转为ConfigurableEnvironment返回。<p>如果上一步最终返回为null，那么会默认创建一个ApplicationEnvironment对象返回。<p><strong>（2）SpringApplication.configureEnvironment(..)</strong><p>如果允许添加转换服务，那么为当前环境对象ApplicationServletEnvironment添加一个ApplicationConversionService实例对象。<p>配置属性源，也就是说项目会读取哪里的配置。<p>配置Profiles，默认方法空实现。<p><strong>（3）调用ConfigurationPropertySources.attach(.)</strong><p>获取当前environment的属性源MutablePropertySources。默认有4个，详情如下：<ul><li>servletConfigInitParams<li>servletContextInitParams<li>systemProperties（67个属性）<li>systemEnvironment（42个属性）</ul><p>将这4个属性源封装成ConfigurationPropertySourcesPropertySource，将这个封装好的属性源和上面4个组合到一起，封装好的放第一个，然后再将这5个添加进MutablePropertySources中。<p><strong>（4）SpringApplicationRunListeners.environmentPrepared()</strong><p>构造2个参数，一个是String，一个是Consumer对象。参数1：spring.boot.application.environement-prepared；参数2：DefaultBootstrapContext、environment作为参数，调用传进来listener的environmentPrepared方法。<p>调用SpringApplicationRunListeners.doWithListeners(String, Consumer, Consumer)方法来处理：调用DefaultApplicationStartup.start(“spring.boot.application.environment-prepared”)方法返回一个DefaultApplicationStartup.DefaultStartupStep实例对象。执行参数2的Consumer，也就是执行所有listener的environmentPrepared方法。调用上面返回的DefaultApplicationStartup.DefaultStartupStep实例对象的end方法。<p><strong>（5）DefaultPropertiesPropertySource.moveToEnd(.)</strong><p>将名字为defaultProperties的属性源移动到列表最后一个。<p><strong>（6）SpringApplication.bindToSpringApplication()</strong><p><strong>（7）EnvironmentConverter.converEnvironmentIfNecessary()</strong><p>如果不是自定义环境environment，那么需要使用环境转换器对当前环境进行转换。<h3 id=1-1-7、SpringApplication-configureIgnoreBeanInfo><a class=headerlink href=#1-1-7、SpringApplication-configureIgnoreBeanInfo title=1.1.7、SpringApplication.configureIgnoreBeanInfo()></a>1.1.7、SpringApplication.configureIgnoreBeanInfo()</h3><p>设置环境属性spring.beaninfo.ignore，值为true。<h3 id=1-1-8、SpringApplication-printBanner><a class=headerlink href=#1-1-8、SpringApplication-printBanner title=1.1.8、SpringApplication.printBanner(.)></a>1.1.8、SpringApplication.printBanner(.)</h3><p>打印Banner信息。<h3 id=1-1-9、SpringApplication-createApplicationContext><a class=headerlink href=#1-1-9、SpringApplication-createApplicationContext title=1.1.9、SpringApplication.createApplicationContext()></a>1.1.9、SpringApplication.createApplicationContext()</h3><p>（1）构建3个参数，一个是项目类型Servlet，一个是Consumer，一个是方法引用。<p>（2）基于这些参数尝试从META-INF/spring.factories文件中获取接口ApplicationContextFactory的所有实现。<h3 id=1-1-10、GenericApplicationContext-setApplicationStartup><a class=headerlink href=#1-1-10、GenericApplicationContext-setApplicationStartup title=1.1.10、GenericApplicationContext.setApplicationStartup(.)></a>1.1.10、GenericApplicationContext.setApplicationStartup(.)</h3><p>为AnnotationConfigServletWebServerApplicationContext添加一个DefaultApplicationStartup类实例。<h3 id=1-1-11、SpringApplicationContext-prepareContext><a class=headerlink href=#1-1-11、SpringApplicationContext-prepareContext title=1.1.11、SpringApplicationContext.prepareContext()></a>1.1.11、SpringApplicationContext.prepareContext()</h3><p><strong>（1）为AnnotationConfigServletWebServerApplicationContext设置环境environment。</strong><p><strong>（2）为AnnotationConfigServletWebServerApplicationContext中的BeanFactory设置一个转换服务ApplicationConversionService。</strong><p><strong>（3）应用所有的初始化器。</strong><p>默认有8个：DelegatingApplicationContextInitializer、SharedMetadataReaderFactoryContextInitializer、ContextIdApplicationContextInitializer、MyApplicationContextInitializer、ConfigurationWarningsApplicationContextInitializer、RSocketPortInfoApplicationContextInitializer、ServerPortInfoApplicationContextInitializer、ConditionEvaluationReportLoggingListener。<p>将AnnotationConfigServletWebServerApplicationContext作为参数调用每个initialize的initialize方法。<p><strong>（4）调用形参SpringApplicationRunListeners的contextPrepared方法。</strong><p><strong>（5）调用形参DefaultBootstrapContext的close方法，发布BootstrapContextClosedEvent事件。</strong><p><strong>（6）使用BeanFactory注册一个单例springApplicationArguments。</strong><p><strong>（7）使用BeanFactory注册一个单例springBootBanner。</strong><p><strong>（8）设置允许Bean循环应用，允许Bean定义信息被重写。</strong><p><strong>（9）如果允许延迟实例化Bean，那么为context 注册一个LazyInitializationBeanFactoryPostProcessor。</strong><p><strong>（10）加载Bean定义信息。</strong><p>创建一个Bean定义加载器BeanDefinitionLoader，该加载器中已经初始化好了AnnotatedBeanDifinitionReader、XmlBeanDefinitionReader、ClassPathBeanDefinitionScanner。<p>加载源souce默认只有一个，就是启动类。默认只能加载4种类型的源，分别是Class、Resouce、Package、CharSequence。调用BeanDefinitionLoader.load()方法来加载每一个源，默认是启动类。<p>以启动类为例来分析。会调用AnnotatedBeanDefinitionReader.doRegisterBean方法来注册启动类Class。在该方法中会先将启动类包装成BeanDefinition，为该BeanDefinition设置名字为启动类名字首字母小写，设置Scope为singleton，并处理启动类上注解为Lazy、DependsOn、Role、Description等信息并做相关操作，没有就跳过。最终将该Beean定义注册到容器中。<p><strong>（11）以字符串spring.boot.application.context-loaded为参数调用StartupStep的start和end方法，以context为参数调用SpringApplicationRunListeners的contextLoaded方法</strong>。<h3 id=1-1-12、SpringApplication-refreshContext><a class=headerlink href=#1-1-12、SpringApplication-refreshContext title=1.1.12、SpringApplication.refreshContext(.)></a>1.1.12、SpringApplication.refreshContext(.)</h3><p>详情参考1.2章节。<h3 id=1-1-13、SpringApplication-afterRefresh><a class=headerlink href=#1-1-13、SpringApplication-afterRefresh title=1.1.13、SpringApplication.afterRefresh(..)></a>1.1.13、SpringApplication.afterRefresh(..)</h3><p>默认空实现。<h3 id=1-1-14、SpringApplicationRunListeners-started><a class=headerlink href=#1-1-14、SpringApplicationRunListeners-started title=1.1.14、SpringApplicationRunListeners.started(..)></a>1.1.14、SpringApplicationRunListeners.started(..)</h3><p>以字符串spring.boot.application.started为参数调用StartupStep的start和end方法，以context为参数调用SpringApplicationRunListeners为参数调用listener的started方法。<h3 id=1-1-15、SpringApplication-callRunners><a class=headerlink href=#1-1-15、SpringApplication-callRunners title=1.1.15、SpringApplication.callRunners(..)></a>1.1.15、SpringApplication.callRunners(..)</h3><p>（1）获取接口ApplicationRunner、CommandLineRunner的所有实现类装进List集合中，然后使用List的默认排序方式进行排序。<p>（2）遍历所有的Runner，并执行它们的run方法。先执行ApplicationRunner的实现类的run方法，再执行CommandLineRunner的实现类。<h3 id=1-1-16、catch-Throwable><a class=headerlink href=#1-1-16、catch-Throwable title=1.1.16、catch:Throwable></a>1.1.16、catch:Throwable</h3><p>（1）SpringApplication.handleRunFailure(…)<h3 id=1-1-17、SpringApplicationRunListeners-ready><a class=headerlink href=#1-1-17、SpringApplicationRunListeners-ready title=1.1.17、SpringApplicationRunListeners.ready(..)></a>1.1.17、SpringApplicationRunListeners.ready(..)</h3><p>以字符串spring.boot.application.ready为参数调用StartupStep的start和end方法，以context为参数调用SpringApplicationRunListeners为参数调用listener的ready方法。<p>最终将初始化好的context实例返回，结束SpringBoot的启动和初始化。下一步就是处理HTTP请求的流程。<h3 id=1-1-18、catch-Throwable><a class=headerlink href=#1-1-18、catch-Throwable title=1.1.18、catch:Throwable></a>1.1.18、catch:Throwable</h3><p>（1）SpringApplication.handleRunFailure(…)<h2 id=1-2、AbstractApplicationContext-refresh><a class=headerlink href=#1-2、AbstractApplicationContext-refresh title=1.2、AbstractApplicationContext.refresh()></a>1.2、AbstractApplicationContext.refresh()</h2><h3 id=1-2-1、DefaultApplicationStartup-start-“spring-context-refresh”><a class=headerlink href=#1-2-1、DefaultApplicationStartup-start-“spring-context-refresh” title=1.2.1、DefaultApplicationStartup.start(“spring.context.refresh”)></a>1.2.1、DefaultApplicationStartup.start(“spring.context.refresh”)</h3><p>创建一个DefaultApplicationStartup.DefaultStartupStep实例。<h3 id=1-2-2、AnnnotationConfigServletWebServerApplicationContext-prepareRefresh><a class=headerlink href=#1-2-2、AnnnotationConfigServletWebServerApplicationContext-prepareRefresh title=1.2.2、AnnnotationConfigServletWebServerApplicationContext.prepareRefresh()></a>1.2.2、AnnnotationConfigServletWebServerApplicationContext.prepareRefresh()</h3><p><strong>（1）清空缓存</strong><p>如果Map集合metadataReaderCache属于LocalResourceCache类型，那么清空该集合。<p>如果Map集合metadataReaderCache为null，那么初始化一个容量为256的集合LocalResourceCache。<p><strong>（2）准备刷新</strong><p>初始化属性源，验证Required配置。初始化Set集合earlyApplicationListeners，为集合导入13个ApplicationListener。<h3 id=1-2-3、AbstractApplicationContext-obtainFreshBeanFactory><a class=headerlink href=#1-2-3、AbstractApplicationContext-obtainFreshBeanFactory title=1.2.3、AbstractApplicationContext.obtainFreshBeanFactory()></a>1.2.3、AbstractApplicationContext.obtainFreshBeanFactory()</h3><p>为BeanFactory设置序列化ID为字符串application，然后返回。<h3 id=1-2-4、AbstractApplicationContext-prepareBeanFactory><a class=headerlink href=#1-2-4、AbstractApplicationContext-prepareBeanFactory title=1.2.4、AbstractApplicationContext.prepareBeanFactory()></a>1.2.4、AbstractApplicationContext.prepareBeanFactory()</h3><p><strong>（1）为BeanFactory设置Bean类加载器Launcher.AppClassLoader。</strong><p><strong>（2）为BeanFactory设置Bean表达式解析器StandardBeanExpressionResolver。</strong><p><strong>（3）为BeanFactory添加属性编辑注册器ResourceEditorRegistrar。</strong><p><strong>（4）为BeanFactory添加Bean增强器ApplicationContextAwareProcessor。</strong><p><strong>（5）设置要忽略的依赖接口</strong><p>这些接口包括：EnvironmentAware、EmbeddedValueResolverAware、ResourceLoader、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware、ApplicationStartupAware。<p><strong>（6）注册分解依赖</strong><p>这些依赖包括：BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext。<p><strong>（7）为BeanFactory添加一个Bean增强器ApplicationListenerDetector。</strong><p><strong>（8）如果BeanFactory中没有environment、systemProperties、systemEnvironment、applicationStartup，那么将它们注册为单例Bean。</strong><h3 id=1-2-5、AnnotationConfigServletWebServerApplicationContext-postProcessBeanFactory><a class=headerlink href=#1-2-5、AnnotationConfigServletWebServerApplicationContext-postProcessBeanFactory title=1.2.5、AnnotationConfigServletWebServerApplicationContext.postProcessBeanFactory(.)></a>1.2.5、AnnotationConfigServletWebServerApplicationContext.postProcessBeanFactory(.)</h3><p><strong>（1）ServletWebServerApplicationContext.postProcessBeanFactory(.)</strong><p>为当前BeanFactory添加一个Bean增强器WebApplicationContextServletContextAwareProcessor，并设置忽略依赖的接口ServletContextAware。<p>注册Web应用的Scope。先注册现有的Scope，再注册其它的Scope：request:RequestScope、session:SessionScope、注册可解析的依赖：ServletRequest:RequestObjectFactory、ServletResponse:ResponseObjectFactory、HttpSession:SessionObjectFactory、WebRequest:WebRequestObjectFactory。如果有必要会注册门面依赖：FacesContext、ExternalContext。<p><strong>（2）如果basePackages、annotatedClasses不为空，那么扫描这些包并注册这些注解。</strong><h3 id=1-2-6、DefaultApplicationStartup-start-“spring-context-beans-post-process”><a class=headerlink href=#1-2-6、DefaultApplicationStartup-start-“spring-context-beans-post-process” title=1.2.6、DefaultApplicationStartup.start(“spring.context.beans.post-process”)></a>1.2.6、DefaultApplicationStartup.start(“spring.context.beans.post-process”)</h3><p>以字符串spring.context.beans.post-process为参数调用DefaultApplicationStartup.start方法创建一个DefaultApplicationStartup.DefaultStartupStep实例。<h3 id=1-2-7、AbstractApplicationContext-invokeBeanFactoryPostProcessors><a class=headerlink href=#1-2-7、AbstractApplicationContext-invokeBeanFactoryPostProcessors title=1.2.7、AbstractApplicationContext.invokeBeanFactoryPostProcessors(.)></a>1.2.7、AbstractApplicationContext.invokeBeanFactoryPostProcessors(.)</h3><p>入口从AbstractApplicationContext.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory)开始。<p>该方法会做如下事情：<ol><li>执行BanFactory增强器。<li>如果不是原生镜像，且当前beanFactory的临时类加载器为null，且beanFactory中包含名字是loadTimeWeaver的Bean，那么为当前BeanFactory添加一个Bean增强器LoadTimeWeaverAwareProcessor并设置一个临时类加载器。</ol><p>（1）<code>AbstractApplicationContext.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List&LTBeanFactoryPostProcessor>)</code><p>调用<code>PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessor(Collection&LTBeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry, ApplicationStartup)</code>方法来注册BeanDefinition信息。<p>（2）<code>PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessor(Collection&LTBeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry, ApplicationStartup)</code><p>遍历BeanDefinitionRegistryPostProcessor集合，默认集合只有一个ConfigurationClassPostProcessor，执行其postProcessBeanDefinitionRegistry(BeanDefinitionRegistry)方法来完成BeanDefinition的注入。<p>（3）ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry)<p>调用ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry)方法来处理配置的BeanDefinition信息。<p>（4）ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry)<p>调用<code>ConfiguraionClassParser.parse(Set&LTBeanDefinitionHolder>)</code>方法来解析配置类。<p>（5）<code>ConfiguraionClassParser.parse(Set&LTBeanDefinitionHolder>)</code><p>调用ConfigurationClassParser.DeferredImportSelectorHandler.process()方法来处理。<p>（6）ConfigurationClassParser.DeferredImportSelectorHandler.process()<p>调用ConfigurationClassParser.DeferredImportSelectorGroupingHandler.processGroupImports()方法来处理。<p>（7）ConfigurationClassParser.DeferredImportSelectorGroupingHandler.processGroupImports()<p>调用ConfigurationClassParser.DeferedImportSelectorGrouping.getImports()方法获取要导入的配置类信息。<p>遍历所有的配置类信息，调用ConfigurationClassParser.processImports(…..)来将这些配置类导入到容器中。<p>（8）ConfigurationClassParser.DeferedImportSelectorGrouping.getImports()<p>调用AutoConfigurationImportSelector.AutoConfigurationGroup.process()方法来处理。<p>调用AutoConfigurationImportSelector.AutoConfigurationGroup.selectImports()来处理。<p>（9）AutoConfigurationImportSelector.AutoConfigurationGroup.process()<p>调用AutoConfigurationImportSelector.getAutoConfigurationEntry()方法来获取配置类，然后将这些配置类装进Map中。<p>（10）AutoConfigurationImportSelector.getAutoConfigurationEntry()<p>调用AutoConfigurationImportSelector.getCandidateConfiguration()方法来读取项目META-INFO/spring.factories文件和项目META-INFO/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件中的自动配置类信息。<p>对扫描的配置类进行过滤，过滤掉要排除的配置类，将最终剩下的需要使用的全部配置类整体打包成AutoConfigurationEntry并返回。<h3 id=1-2-8、AbstractApplicationContext-registerBeanPostProcessors><a class=headerlink href=#1-2-8、AbstractApplicationContext-registerBeanPostProcessors title=1.2.8、AbstractApplicationContext.registerBeanPostProcessors(.)></a>1.2.8、AbstractApplicationContext.registerBeanPostProcessors(.)</h3><p><em><strong>会调用PostProcessorRegistrationDelegate.registerBeanPostProcessors(..)方法来处理</strong></em>。<p>获取接口BeanPostProcessor的所有实现类，默认有7个，分别是：internalAutowiredAnnotationProcessor、internalCommonAnnotationProcessor、ConfigurationPropertiesBindingPostProcessor、webServerFactoryCustomizerBeanPostProcessor、errorPageRegistrarBeanPostProcessor、internalAutoProxyCreator、persistenceExceptionTranslationPostProcessor。<p><em><strong>为当前BeanFactory添加Bean增强器BeanPostProcessorChecker</strong></em>。<p>遍历所有的Bean增强器，将这些Bean增强器按照实现了PriorityOrdered、实现Ordered、普通的分类装进不同的List集合中。先将实现了PriorityOrder的所有Bean增强器添加进BeanFactory中。把实现了Ordered的Bean增强器中挑选处实现了MergeBeanDefinitionPostProcessor的装进对应的集合中。然后将实现了Ordered的Bean增强器添加进BeanFactory中。从普通的Bean增强器中也挑选出MergeBeanDefinitionPostProcessor类型的装进对应的集合中，然后将普通的Bean增强器装进BeanFactory中，然后将普通的MergeBeanDefinitionPostProcessor类型的也装进去。<p>最后再为BeanFactory添加一个Bean增强器ApplicationListenerDetector。<h3 id=1-2-9、DefaultApplicationStartup-DefaultStartupStep-end><a class=headerlink href=#1-2-9、DefaultApplicationStartup-DefaultStartupStep-end title=1.2.9、DefaultApplicationStartup.DefaultStartupStep.end()></a>1.2.9、DefaultApplicationStartup.DefaultStartupStep.end()</h3><p>默认空实现。<h3 id=1-2-10、AbstractApplicationContext-initMessageSource><a class=headerlink href=#1-2-10、AbstractApplicationContext-initMessageSource title=1.2.10、AbstractApplicationContext.initMessageSource()></a>1.2.10、AbstractApplicationContext.initMessageSource()</h3><p>（1）如果BeanFactory中包含名字为messageSource的Bean，且该Bean属于HierarchicalMessageSource类型，那么为该类型的Bean设置父消息源。<p>（2）如果BeanFactory中没有名字为messageSource的Bean，那么创建一个空的DelegatingMessageSource，并初始化父消息源，然后将之赋值给this.messageSource，然后将该messageSource注册成一个单例。<h3 id=1-2-11、AbstractApplicationContext-initApplicationEventMulticaster><a class=headerlink href=#1-2-11、AbstractApplicationContext-initApplicationEventMulticaster title=1.2.11、AbstractApplicationContext.initApplicationEventMulticaster()></a>1.2.11、AbstractApplicationContext.initApplicationEventMulticaster()</h3><p>（1）如果BeanFactory中存在一个名字为applicationEventMulticaster的Bean，那么获取该Bean并将之赋值给this.applicationEventMulticaster。<p>（2）如果BeanFactory中没有名字为applicationEventMulticaster的Bean，那么创建一个SimpleApplicationEventMulticaster并赋值给this.applicationEventMulticaster，并将该实例以applicationEventMulticaster为名字注册为单例。<h3 id=1-2-12、ServletWebServerApplicationContext-onRefresh><a class=headerlink href=#1-2-12、ServletWebServerApplicationContext-onRefresh title=1.2.12、ServletWebServerApplicationContext.onRefresh()></a>1.2.12、ServletWebServerApplicationContext.onRefresh()</h3><p><strong>（1）调用父类的onRefresh()方法</strong><p>初始化主题源this.themSource为ResourceBundleThemeSource。<p><strong>（2）调用ServletWebServerApplicationContext.createWebServer()方法创建WebServer</strong><p>如果WebServer、ServletContext不为null，那么获取自定义初始化器，并调用其onstartup方法。<p>如果WebServer、ServletContext为null，那么获取WebServerFactory，再通过Factory获取WebServer。<p><strong>（3）获取WebServerFactory和WebServer</strong><p>获取接口ServletWebServerFactory的所有实现类名字，默认会获取到一个tomcatServletWebServerFactory，然后根据该名字尝试从BeanFactory中获取。<p>调用TomcatServletWebServerFactory.getWebServer()方法来获取WebServer，参数是一个ServletContextInitializer类型的数组，符合要求时会调用实现类的onStartup()方法。<p>创建Tomcat类实例对象，为其设置BaseDir为/var/folders/ys/xxxxxxxx/T/tomcat.9001.xxxxxxxxx。如果存在接口LifecycleListener的实现类，那么将这些实现类添加进当前tomcat实例的Server中。<p>基于Http11NioProtocol创建Connector类实例，然后将该实例添加进tomcat实例的Service中。对该Connector实例进行自定义设置，比如：设置端口号；如果connector的ProtocolHandler是AbstractProtocol类型，那么对其进行自定义配置，执行它们的customize(protocolHandler)方法；设置URIEncoding为UTF-8；设置属性bindOnInit为false；如果开启了HTTP2，那么使用Http2Protocol；如果开启了SSL，那么对其进行配置；使用TomcatConnectorCustomizer对connector进行定制；<p>为当前tomcat实例设置定制后的connector实例，并关闭tomcat实例中Host的自动部署功能，设置tomcat实例的Engine后台处理延迟为10秒。如果当前存在连接Connector，那么为tomcat实例的Service添加connector。<p>准备上下文Context。为context设置name为””，设置displayName为application，设置path为””，设置DocBase为/var/folders/ys/xxxxxxx/T/tomcat-docbase.9001.xxxxx，为context添加生命周期监听器Tomcat.FixContextListener，设置父类加载器，设置默认本地映射：en:UTF-8、fr:UTF-8、ja:UTF-8，设置创建上传目标为true，为context的StandardJarScanner设置StandardJarScanFilter。为context设置Wrapper加载器WrapperLoader，该WrapperLoader会加载TomcatEmbeddedWebappClassLoader。为context添加LifecycleListener的StaticResourceConfigurer。<p>将当前context添加进Host中，然后再对context做一些配置。<p><strong>最后基于参数tomcat实例、true、名字是IMMEDIATE的Shutdown实例创建TomcatWebServer实例返回。</strong><p><strong>（4）注册两个Lifecycle</strong><p>一个是名字为webServerGracefulShutdown的WebServerGracefulShuedownLifecycle。<p>一个是名字为webServerStartStop的WebServerStartStopLifecycle。<p><strong>（5）调用GenericWebApplicationContext.initPropertySources()方法来初始化属性源。</strong><h3 id=1-2-13、AbstractApplicationContext-registerListeners><a class=headerlink href=#1-2-13、AbstractApplicationContext-registerListeners title=1.2.13、AbstractApplicationContext.registerListeners()></a>1.2.13、AbstractApplicationContext.registerListeners()</h3><p>（1）获取所有ApplicationListener实现类，然后将这些实现类添加进SimpleApplicationEventMulticaster中。<p>（2）如果存在早期的ApplicationEvent，那么通过上一步获取事件多播器触发这些Event。<h3 id=1-2-14、AbstractApplicationContext-finishBeanFactoryInitialization><a class=headerlink href=#1-2-14、AbstractApplicationContext-finishBeanFactoryInitialization title=1.2.14、AbstractApplicationContext.finishBeanFactoryInitialization(.)></a>1.2.14、AbstractApplicationContext.finishBeanFactoryInitialization(.)</h3><p>（1）如果BeanFactory中存在名字为conversionService的Bean那么为BeanFactory设置该Bean。<p>（2）如果BeanFactory中不存在StringValueResolver，那么为之设置一个，该Resolver会调用当前environment来解析占位符。<p>（3）如果BeanFactory中存在类型LoadTimeWeaverAware的Bean定义名字，那么实例话这个Bean并放入容器中。<p>（4）冻结配置<p><strong>（5）预实例化Bean。会将所有的Bean定义进行实例化并放入容器中</strong>。<p>遍历所有的Bean定义名字，先实例化非FactoryBean类型的、抽象的、非单例的、懒加载的那些Bean，其中先处理SmartInitializingSingleton类型的Bean，并执行这些bean的afterSingletonsInstantiated()方法，然后基于bean名字获取合并的bean定义。<p>如果当前bean属于FactoryBean类型，那么在bean名字前拼接符号&来尝试获取bean，如果不属于FactoryBean类型，那么直接通过bean名字尝试获取bean。<p>如果当前bean是FactoryBean类型<h3 id=1-2-15、AbstractApplicationContext-finishRefresh><a class=headerlink href=#1-2-15、AbstractApplicationContext-finishRefresh title=1.2.15、AbstractApplicationContext.finishRefresh()></a>1.2.15、AbstractApplicationContext.finishRefresh()</h3><p>入口从AbstractApplicationContext.finishRefresh()方法开始。该方法会做如下事情：<ol><li><strong>初始化生命周期处理器并调用其刷新方法完成刷新。内置Tomcat的启动在这一步实现。</strong><li><strong>发布ContextRefreshedEvent事件。监听到该事件的监听器会做自己的相关操作。</strong></ol><p><strong>（1）AbstractApplicationContext.finishRefresh()</strong><p>调用DefaultLifecycleProcessor.onRefresh()方法来处理。<p><strong>（2）DefaultLifecycleProcessor.onRefresh()</strong><p>调用DefaultLifecycleProcessor.startBeans(true)方法来处理。<p><strong>（3）DefaultLifecycleProcessor.startBeans(true)</strong><p>调用DefaultLifecycleProcessor.start()方法来处理。<p><strong>（4）DefaultLifecycleProcessor.start()</strong><p>调用DefaultLifecycleProcessor.doStart()方法来处理。<p><strong>（5）DefaultLifecycleProcessor.doStart()</strong><p>这一步会调用实现Lifecycle接口的所有实现类的start方法。以WebServerStartStopLifecycle.start()方法为例来分析。<p><strong>（6）WebServerStartStopLifecycle.start()</strong><p>调用TomcatWebServer.start()方法来处理，然后设置running为true，最后发布ServletWebServerInitializedEvent事件。<p><strong>（7）TomcatWebServer.start()</strong><p>调用TomcatWebServer.addPreviouslyRemovedConnectorrs()方法来为所有的service添加connector。<p><strong>（8）TomcatWebServer.addPreviouslyRemovedConnectorrs()</strong><p>遍历所有service，通过每个service获取所有的connector，然后再调用StandardService.addConnector(Connector) 方法将这些connector添加进对应的service中。<p><strong>（9）StandardService.addConnector(Connector)</strong><p>调用当前Connector的start()方法开启Tomcat初始化等操作。详情查看Tomcat原理解析章节。<h3 id=1-2-16、catch-BeanException><a class=headerlink href=#1-2-16、catch-BeanException title=1.2.16、catch:BeanException></a>1.2.16、catch:BeanException</h3><p>（1）AbstractApplicationContext.destroyBeans()<p>（2）AbstractApplicaitonContext.cancelRefresh(.)<h3 id=1-2-18、finally><a class=headerlink href=#1-2-18、finally title=1.2.18、finally></a>1.2.18、finally</h3><p>（1）AbstractApplicationContext.resetCommonCaches()<p>清理定义的方法和字段缓存，清理注册过滤器缓存，清理解析类型缓存，清理缓存操作关连的类加载器。<p>（2）DefaultApplicationStartup.DefaultStartupStep.end()<p>调用end方法标识执行结束。<h1 id=Web开发><a class=headerlink href=#Web开发 title=Web开发></a>Web开发</h1><h2 id=1-1、概述><a class=headerlink href=#1-1、概述 title=1.1、概述></a>1.1、概述</h2><p>web开发场景下，springboot默认使用的自动配置类如下<ul><li><strong>Client</strong><ul><li>RestTemplateAutoConfiguration<ul><li>HttpMessageConvertersAutoConfiguration<ul><li>GsonAutoConfiguration：会使用GsonProperties读取前缀为spring.gson的配置，<li>JacksonAutoConfiguration：会使用JacksonProperties读取前缀为spring.jackson的配置。<li>JsonbAutoConfiguration</ul></ul></ul><li><strong>Embedded</strong><ul><li>EmbeddedWebServerFactoryCustomizerAutoConfiguration：会使用ServerPropertie读取前缀为server的配置。</ul><li><strong>Servlet应用</strong><ul><li>DispatcherServletAutoConfiguration：会使用WebMvcProperties读取前缀为spring.mvc的配置。<li>ServletWebServerFactoryAutoConfiguration：会使用ServerProperties读取前缀为server的配置。<li>ErrorMvcAutoConfiguration：会使用ServerProperties读取前缀为server的配置，使用WebMvcProperties读取前缀为spring.mvc的配置，使用WebProperties读取前缀为spring.web的配置。<li>HttpEncodingAutoConfiguration：会使用ServerProperties读取前缀为server的配置。<li>MultipartAutoConfiguration：会使用MultipartProperties读取前缀为spring.servlet.multipart的配置。<li>WebMvcAutoConfiguration：会使用WebProperties读取前缀spring.web的配置，使用WebMvcProperties读取spring.mvc的配置。</ul><li><strong>Reactive应用</strong><ul><li>HttpHandlerAutoConfiguration<li>ReactiveMultipartAutoConfiguration<li>ReactiveWebServerFactoryAutoConfiguration<li>WebFluxAutoConfiguration<li>WebSessionIdResolverAutoConfiguration<li>ErrorWebFluxAutoConfiguration<li>ClientHttpConnectorAutoConfiguration<li>WebClientAutoConfiguration</ul></ul><h2 id=1-2、Servlet应用><a class=headerlink href=#1-2、Servlet应用 title=1.2、Servlet应用></a>1.2、Servlet应用</h2><h3 id=1-2-1、概述><a class=headerlink href=#1-2-1、概述 title=1.2.1、概述></a>1.2.1、概述</h3><p><font color=red>注意事项：当显式使用注解 @EnableWebMvc 时，WebMvcAutoConfiguration将不再有效。因为 WebMvcAutoConfiguration 生效的前提是容器中没有 WebMvcConfigurationSupport，而注解 @EnableWebMvc 会间接向容器中注入一个 WebMvcConfigurationSupport。</font><p>自动配置加载顺序如下：<ol><li>ErrorMvcAutoConfiguration<li>ServletWebServerFactoryAutoConfiguration<li>DispatcherServletAutoConfiguration<li>TaskExecutionAutoConfiguration<li>ValidationAutoConfiguration<li>WebMvcAutoConfiguration<li>HttpEncodingAutoConfiguration<li>MultipartAutoConfiguration</ol><h3 id=1-2-2、ErrorMvcAutoConfiguration><a class=headerlink href=#1-2-2、ErrorMvcAutoConfiguration title=1.2.2、ErrorMvcAutoConfiguration></a>1.2.2、ErrorMvcAutoConfiguration</h3><p>自动配置类<code>ErrorMvcAutoConfiguration</code>生效的前提条件如下：<ol><li>项目类型是servlet类型.<li>存在class：Servlet.class、DispatcherServlet.class。</ol><p>自动配置类<code>ErrorMvcAutoConfiguration</code>会读取ServerProperties.class、WebMvcProperties.class。<p>自动配置类<code>ErrorMvcAutoConfiguration</code>拥有如下内部类或接口：<ul><li><strong>DefaultErrorViewResolverConfiguration</strong><li><strong>ErrorPageCustomizer</strong><li><strong>ErrorTemplateMissingCondition</strong><li><strong>PreserverErrorControllerTargetClassPostProcessor</strong><li><strong>StaticView</strong><li><strong>WhitelabelErrorViewConfiguration</strong></ul><p><strong>1. 内部类 DefaultErrorViewResolverConfiguration</strong><p>如果存在DispatcherServlet.class，且没有ErrorViewResolver.class时，向容器中注入一个DefaulErrorViewResolver。<p><strong>2. 内部类 ErrorPageCustomizer</strong><p>获取错误页面的路径，如果配置了属性error.path，则以配置的为准，否则以默认路径<code>/error</code>为准。<p>从错误路径下获取所有的错误页面，将这些错误页面添加进错误页面注册器ErrorPageRegistry中。<p><strong>3. 内部类 ErrorTemplateMissingCondition</strong><p>配置错误模板缺失匹配规则 ErrorTemplateMissingCondition。<p><strong>4. 内部类 PreserverErrorControllerTargetClassPostProcessor</strong><p>实现BeanFactoryPostProcessor的postProcessBeanFactory方法。<p>获取类型为ErrorController.class的所有Bean的定义，为所有Bean的定义设置属性值 preserveTargetClass=true。<p>ErrorController.class类型的Bean默认有1个，即 BasicErrorController。<p><em><strong>BasicErrorController会拦截请求路径为 server.error.path 或 error.path 或 /error 的请求，且处理方式分两种</strong></em>：<ul><li><p><strong>将错误信息以JSON格式返回</strong></p> <p>当对响应数据的格式没有要求，会被方法error拦截，该方法会将错误信息以JSON格式返回；</p><li><p><strong>将错误信息以错误视图方式返回</strong></p> <p>当要求响应数据的媒体类型是<code>text/html</code>，会被方法 errorHtml 拦截，该方法会以错误视图页面的方式返回。</p> <p><strong>错误视图的查找匹配规则如下</strong>：</p> <ol><li>精确匹配响应码为名字的页面，比如404.html、500.html等。如果使用了模板引擎，那么会先到路径 <code>resources/templates/error/</code>下查找；如果没有使用模板引擎，那么会到静态资源路径下查找。<li>匹配通用模糊错误页面，比如4xx.html、5xx.html等。如果使用了模板引擎，那么会先到路径<code>resources/templates/error/</code>下查找；如果没有使用模板引擎，那么会到静态资源路径下查找。<li>如果通用模糊错误页面也没有找到，那么会直接查找名字为 error 的页面。<li>如果名字为 error 的页面也没有找到，那么会使用spring boot的默认 error 页面，也就是白页。</ol></ul><p><strong>5. 内部类 StaticView</strong><p>在方法 render 中进行错误视图的渲染，也就是将错误信息渲染到白页中，然后在浏览器中展示。<p><strong>6. 内部类 WhitelabelErrorViewConfiguration</strong><p>如果配置了属性 server.error.whitelabel.enabled，但属性值不为true，且符合内部类ErrorTemplateMissingCondition定义的规则，那么继续。<p>如果容器中缺少名字为 error，类型是View的Bean，那么向容器中注入一个名字为 error 类型是 StaticView（白页） 的Bean。<p>如果容器中缺少名字为 beanNameViewResolver 类型是 BeanNameViewResolver 的Bean，那么向容器中注入一个名字是 beanNameViewResolver 类型是 BeanNameViewResolver 的Bean。<h3 id=1-2-3、ServletWebServerFactoryAutoConfiguration><a class=headerlink href=#1-2-3、ServletWebServerFactoryAutoConfiguration title=1.2.3、ServletWebServerFactoryAutoConfiguration></a>1.2.3、ServletWebServerFactoryAutoConfiguration</h3><p>自动配置类<code>ServletWebServerFactoryAutoConfiguration</code>生效的前提条件如下：<ol><li>项目类型是servlet类型.<li>存在class：ServletRequest.class。</ol><p>自动配置类<code>ServletWebServerFactoryAutoConfiguration</code>会读取ServerProperties.class、WebMvcProperties.class。<p>自动配置类<code>ServletWebServerFactoryAutoConfiguration</code>拥有如下内部类或接口：<ul><li><strong>BeanPostProcessorsRegistrar</strong><li><strong>ForwardedHeaderFilterConfiguration</strong><li><strong>ForwardedHeaderFilterCustomizer</strong></ul><p><strong>1. 自动配置类本身操作</strong><p>会通过@Import导入如下类：<ul><li><strong>BeanPostProcessorsRegistrar</strong><li><strong>ServletWebServerFactoryConfiguration.EmbeddedTomcat</strong><li><strong>ServletWebServerFactoryConfiguration.EmbeddedJetty</strong><li><strong>ServletWebServerFactoryConfiguration.EmbeddedUndertow</strong></ul><p>会向容器中注入类：<ul><li><strong>ServletWebServerFactoryCustomizer</strong><li>如果存在org.apache.catalina.startup.Tomcat，那么导入TomcatServletWebServerFactoryCustomizer</ul><p><strong>2. 内部类BeanPostProcessorsRegistrar操作</strong><p>实现了接口 ImportBeanDefinitionRegistrar 的 registerBeanDefinitions方法，如果缺失就注册两个bean：webServerFactoryCustomizerBeanPostProcessor、errorPageRegistrarBeanPostProcessor。<p><strong>3. 内部类ForwardedHeaderFilterConfiguration操作</strong><p>如果配置了属性server.forward-headers-strategy=framework，那么配置有效。<p>如果存在org.apache.catalina.startup.Tomcat，那么向容器中注入一个ForwardedHeaderFilterCustomizer。<p>向容器中注入一个FilterRegistrationBean。<h3 id=1-2-4、DispatcherServletAutoConfiguration><a class=headerlink href=#1-2-4、DispatcherServletAutoConfiguration title=1.2.4、DispatcherServletAutoConfiguration></a>1.2.4、DispatcherServletAutoConfiguration</h3><p>该自动配置类生效的前提是：<ol><li>已经加载了执行了ServletWebServerFactoryAutoConfiguration<li>项目是servlet类型。<li>存在class：DispatcherServlet.class。</ol><p>该自动配置类存在如下内部类：<ul><li>DispatcherServletRegistrationConfiguration<li>DispatcherServletConfiguration</ul><p><strong>1. 静态内部类：DispatcherServletRegistrationConfiguration</strong><p>该配置生效的前提是存在class：ServletRegistration。<p>该配置类会导入DispatcherServletConfiguration。<p>如果已经存在名字为dispatcherServlet的DispatcherServlet，那么创建DispatcherServletRegistrationBean，设置其名字为dispatcherServlet，并为其设置文件上传，最后放入容器。<p><strong>2. 静态内部类：DispatcherServletConfiguration</strong><p>该自动配置类生效的前提是存在class：ServletRegistration。<p>该配置类会读取WebMvcProperties绑定的前缀为<code>spring.mvc</code>的配置。<p>创建名字为 dispatcherServlet 的 DispatcherServlet，为其设置WebMvcProperties绑定的dispatchOptionsRequest、dispatchTraceRequest、异常抛出、事件发布、日志记录等配置，最后放入容器中。<p>如果存在Bean：MultipartResolver，且缺失名字为multipartResolver的Bean，那么创建MultipartResolver并放入容器。<h3 id=1-2-5、TaskExecutionAutoConfiguration><a class=headerlink href=#1-2-5、TaskExecutionAutoConfiguration title=1.2.5、TaskExecutionAutoConfiguration></a>1.2.5、TaskExecutionAutoConfiguration</h3><p>该自动配置生效的前提是存在class：ThreadPoolTaskExecutor。<p>如果容器中缺少名字为 taskExecutorBuilder 的 TaskExecutorBuilder，那么创建它并放入容器中。<p>如果缺少Bean：Executor，那么创建名为 applicationTaskExecutor 或 taskExecutor 的 ThreadPoolTaskExecutor。<h3 id=1-2-6、ValidationAutoConfiguration><a class=headerlink href=#1-2-6、ValidationAutoConfiguration title=1.2.6、ValidationAutoConfiguration></a>1.2.6、ValidationAutoConfiguration</h3><p>该自动配置生效的前提如下：<ul><li>存在class：ExecutableValidator。<li>存在resource：classpath:META-INF/services/javax.validation.spi.ValidationProvider</ul><p>该自动配置会导入PrimaryDefaultValidatorPostProcessor。<p>如果缺少Bean：Validator，那么创建名字 defaultValidator 的 LocalValidatorFactoryBean 放入容器。<p>如果当前查找策略缺失，那么创建名为 methodValidationPostProcessor 的 FilteredMethodValidationPostProcessor，为其设置验证器，设置proxyTargetClass的值为属性spring.aop.proxy-target-class的值，最后将之放入容器。<h3 id=1-2-7、WebMvcAutoConfiguration><a class=headerlink href=#1-2-7、WebMvcAutoConfiguration title=1.2.7、WebMvcAutoConfiguration></a>1.2.7、WebMvcAutoConfiguration</h3><p><strong>自动配置类<code>WebMvcAutoConfiguration</code>生效的前提条件如下：</strong><ol><li>自动配置类<code>DispatcherServletAutoConfiguration、TaskExecutionAutoConfiguration、ValidationAutoConfiguration</code>已经加载配置完毕。<li>当前项目类型必须是Servlet类型。<li>必须存在class：<code>Servlet.class、DispatcherServlet.class、WebMvcConfigurer.class</code>。<li>项目没有手动配置<code>WebMvcConfigurationSupport.class</code>。</ol><p><strong>自动配置类<code>WebMvcAutoConfiguration</code>内部类或接口如下：</strong><ul><li>EnableWebMvcConfiguration<li>WebMvcAutoConfigurationAdapter<li>OptionPathExtensionContentNegotiationStrategy<li>ProblemDetailsErrorHandingConfiguration<li>ReourceChainCustomizerConfiguration<li>ResourceChainResourceHandlerRegistrationCustomizer<li>接口 ResourceHandlerRegistrationCustomizer<li>接口 WelcomePageHandlerMappingFactory</ul><p>**1. WebMvcAutoConfiguration本身操作 **<p>向容器中注入两个Filter<ul><li>OrderedHiddenHttpMethodFilter：页面表单提交Rest请求（GET、POST、PUT、DELETE）。<li>OrderedFormContentFilter：表单内容Filter，GET请求数据放地址后面，POST请求数据放请求体，PUT、DELET请求会被忽略。</ul><p><strong>2. 静态内部类：EnableWebMvcConfiguration</strong><p>该内部类继承了 DelegatingWebMvcConfiguration，间接继承了 WebMvcConfigurationSupport。<strong>通过DelegatingWebMvcConfiguration 可以获取 WebMvcConfigurer 的所有实现类实现定制化配置，通过 WebMvcConfigurationSupport 可以为 DispatcherServlet 初始化必要的组件</strong>。<p>创建 RequestMappingHandlerAdapter、WelcomePageHandlerMapping、WelcomePageNotAcceptableHandlerMapping、LocaleResolver并注入到容器中。<p>如果不存在名字为 themeResolver 的 ThemeResolver，那么就创建一个名字为 themeResolver 的ThemeResolver。如果不存在名字为 flashMapManager的 FlashMapManager，那么就创建一个名字为 flashMapManager 的FlashMapManager。<p>创建名字为 mvcConversionService 的 FormattingConversionService 并注入到容器中。创建名字为 nvcValidator 的 Validator 并注入到容器中。创建名字为 mvcContentNegotiationManager 的 ContentNegotiationManager 并注入到容器中。<p><strong>3. 静态内部类：WebMvcAutoConfigurationAdapter</strong><p>首先导入一个配置类 EnableWebMvcConfiguration.class。<p>该内部类实现了 WebMvcConfigurer、ServletContextAware，通过 WebMvcConfigurer 可以定制化一些底层组件。<p>如果没有 InternalResourceViewResolver，那么创建名为 defaultViewResolver 的 InternalResourceViewResolver 并注入到容器中。<p>如果存在 View.calss，但没有 BeanNameViewResolver，那么创建名为 beanNameViewResolver 的 BeanNameViewResolver 并注入到容器中。<p>如果存在 ViewResolver.class，但没有名字为 viewResolver 的 ContentNegotiatingViewResolver，那么就创建名字为 viewResolver 的 ContentNegotiatingViewResolver 并注入到容器中。<p>如果没有 RequestContextListener、RequestContextFilter、RequestContextFilter，那么创建名为 requestContextFilter 的 OrderedRequestContextFilter 并注入到容器中。<p><strong>4. 静态内部类：OptionPathExtensionContentNegotiationStrategy</strong><p>配置内容协商策略，默认支持所有类型的内容，即MediaType.ALL。如果显式配置了协商策略，则以自定义配置的为准。<p><strong>5. 静态内部类：ProblemDetailsErrorHandingConfiguration</strong><p>如果配置了 spring.mvc.problemdetails.enabled : true，该配置才会生效。<p>如果不存在 ResponseEntityExceptionHandler.class，那么创建 ProblemDetailsExceptionHandler 并注入到容器中。<p>ProblemDetailsExceptionHandler 被注解 @ControllerAdvice 标示，且继承了 ResponseEntityExceptionHnadler，ResponseEntityExceptionHnadler中方法handlerException被注解 @ExceptionHandler 标示，该方法可以处理常见的16个异常。 该方法在处理异常时，会使用新媒体类型<code>application/problem+json</code>来返回错误信息。<p><strong>6. 静态内部类：ReourceChainCustomizerConfiguration</strong><p>如果开启了资源链功能，那么向容器中注入一个ResourceChainResourceHandlerRegistrationCustomizer。<p><strong>7. 静态内部类：ResourceChainResourceHandlerRegistrationCustomizer</strong><p>如果在配置文件中spring.web开头下配置了资源链，那么应用配置的内容。<p><strong>8. 接口 ResourceHandlerRegistrationCustomizer</strong><p><strong>9. 接口 WelcomePageHandlerMappingFactory</strong><h2 id=1-3、Client应用><a class=headerlink href=#1-3、Client应用 title=1.3、Client应用></a>1.3、Client应用</h2><p>自动配置加载顺序如下：<ol><li>GsonAutoConfiguration<li>JacksonAutoConfiguration<li>JsonbAutoConfiguration<li>HttpMessageConvertersAutoConfiguration<li>RestTemplateAutoConfiguration</ol><h3 id=1-3-1、GsonAutoConfiguration><a class=headerlink href=#1-3-1、GsonAutoConfiguration title=1.3.1、GsonAutoConfiguration></a>1.3.1、GsonAutoConfiguration</h3><p><strong>当前自动配置生效的前提是存在calss：Gson</strong>。<p>如果缺失GsonBuilder，那么创建一个名为 gsonBuilder 的 GsonBuilder，使用GsonBuilderCustomizer的所有实现对该builder进行定制化，最后将该builder放入容器。<p>如果缺失Gson，那么创建一个名为 gson 的 Gson 放入容器。<p>创建一个名为 standardGsonBuilderCustomizer 的 StandardGsonBuilderCustomizer 放入容器。<p><strong>1. 静态内部类：StandardGsonBuilderCustomizer</strong><p>创建接口 GsonBuilderCustomizer 的实现 StandardGsonBuilderCustomizer，在customize方法中配置对 GsonBuilder 进行定制化处理。<h3 id=1-3-2、JacksonAutoConfiguration><a class=headerlink href=#1-3-2、JacksonAutoConfiguration title=1.3.2、JacksonAutoConfiguration></a>1.3.2、JacksonAutoConfiguration</h3><p>自动配置生效的前提是存在class：ObjectMapper。<p>初始化 FEATURE_DEFAULTS，设置<code>SerializationFeature.WRITE_DATES_AS_TIMESTAMPS</code>为 false，<code>SerializationFeature.WRITE_DURATIONS_AS_TIMESTAMPS</code>为false。<p>创建一个JsonComponentModule放入容器。基于自动配置包名创建一个 JsonMixinModule 放入容器。<p><strong>1. 静态内部类：Jackson2ObjectMapperBuilderCustomizerConfiguration</strong><p>生效的前提是存在class：Jackson2ObjectMapperBuilder。<p>创建StandardJackson2ObjectMapperBuilderCustomizer放入容器。<p>创建接口 Jackson2ObjectMapperBuilderCustomizer 的实现StandardJackson2ObjectMapperBuilderCustomizer，通过customize方法对 Jackson2ObjectMapperBuilder 进行定制化处理。<p><strong>2. 静态内部类：JacksonObjectMapperBuilderConfiguration</strong><p>生效的前提是存在class：Jackson2ObjectMapperBuilder。<p>创建Jackson2ObjectMapperBuilder，并基于 Jackson2ObjectMapperBuilderCustomizer 的所有实现对该 builder 进行定制化处理，最后将builder放入容器。<p><strong>3. 静态内部类：ParameterNamesModuleConfiguration</strong><p>生效的前提是存在class：ParameterNamesModule。<p>如果缺失 ParameterNamesModule，那么基于默认模式创建 ParameterNamesModule 并放入容器。<p><strong>4. 静态内部类：JacksonObjectMapperConfiguration</strong><p>生效的前提是存在class：Jackson2ObjectMapperBuilder。<p>如果缺失 ObjectMapper，那么创建名为 jacksonObjectMapper 的 ObjectMapper 并放入容器。<h3 id=1-3-3、JsonbAutoConfiguration><a class=headerlink href=#1-3-3、JsonbAutoConfiguration title=1.3.3、JsonbAutoConfiguration></a>1.3.3、JsonbAutoConfiguration</h3><p>生效的前提是存在class：Jsonb，且存在resource：classpath:META-INF/services/javax.json.bind.spi.JsonbProvider”, “classpath:META-INF/services/javax.json.spi.JsonProvider。<p>创建名为 jsonb 的 Jsonb 放入容器。<h3 id=1-3-4、HttpMessageConvertersAutoConfiguration><a class=headerlink href=#1-3-4、HttpMessageConvertersAutoConfiguration title=1.3.4、HttpMessageConvertersAutoConfiguration></a>1.3.4、HttpMessageConvertersAutoConfiguration</h3><p>该自动配置类生效的前提：<ul><li>已经加载了配置：GsonAutoConfiguration、JacksonAutoConfiguration、JsonbAutoConfiguration。<li>存在class：HttpMessageConverter。<li>NotReactiveWebApplicationCondition符合要求。</ul><p>该自动配置类会导入如下配置：<ul><li>JacksonHttpMessageConvertersConfiguration<li>GsonHttpMessageConvertersConfiguration<li>JsonbHttpMessageConvertersConfiguration</ul><p>如果缺失 HttpMessageConverters ，那么基于基于所有的 HttpMessageConverter 创建 HttpMessageConverters并放入容器。<p><strong>1. 静态内部类：StringHttpMessageConverterConfiguration</strong><p>该配置生效前提是存在class：StringHttpMessageConverter。<p>如果缺失 StringHttpMessageConverter，那么创建 StringHttpMessageConverter 并放入容器。<h3 id=1-3-5、RestTemplateAutoConfiguration><a class=headerlink href=#1-3-5、RestTemplateAutoConfiguration title=1.3.5、RestTemplateAutoConfiguration></a>1.3.5、RestTemplateAutoConfiguration</h3><p>该配置生效的前提如下：<ul><li>已经加载配置 HttpMessageConvertersAutoConfiguration。<li>存在class：RestTemplate。<li>NotReactiveWebApplicationCondition符合要求。</ul><p>如果缺失 RestTemplateBuilderConfigurer，那么创建 RestTemplateBuilderConfigurer，设置为懒加载，并放入容器。<p>如果缺失 RestTemplateBuilder，那么创建 RestTemplateBuilder，使用 RestTemplateBuilderConfigurer 对该builder进行配置，设置该builder为懒加载，并放入容器。<h2 id=1-4、嵌入式应用><a class=headerlink href=#1-4、嵌入式应用 title=1.4、嵌入式应用></a>1.4、嵌入式应用</h2><p>自动配置如下：<ul><li>EmbeddedWebServerFactoryCustomizerAutoConfiguration</ul><h3 id=1-4-1、EmbeddedWebServerFactoryCustomizerAutoConfiguration><a class=headerlink href=#1-4-1、EmbeddedWebServerFactoryCustomizerAutoConfiguration title=1.4.1、EmbeddedWebServerFactoryCustomizerAutoConfiguration></a>1.4.1、EmbeddedWebServerFactoryCustomizerAutoConfiguration</h3><p>该自动配置生效的前提：<ul><li>当前项目是web应用<li>非传统war包部署的应用程序</ul><p><strong>1. 静态内部类：TomcatWebServerFactoryCustomizerConfiguration</strong><p>该配置生效的前提是存在class：Tomcat、UpgradeProtocol。<p>创建 TomcatWebServerFactoryCustomizer 放入容器。<p><strong>2. 静态内部类：JettyWebServerFactoryCustomizerConfiguration</strong><p>该配置生效的前提是存在class：Server、Loader、WebAppContext。<p>创建 JettyWebServerFactoryCustomizer 放入容器。<p><strong>3. 静态内部类：UndertowWebServerFactoryCustomizerConfiguration</strong><p>该配置生效的前提是存在class：Undertow、SslClientAuthMode。<p>创建 UndertowWebServerFactoryCustomizer 放入容器。<p><strong>4. 静态内部类：NettyWebServerFactoryCustomizerConfiguration</strong><p>该配置生效的前提是存在class：HttpServer。<p>创建 NettyWebServerFactoryCustomizer 放入容器。<h2 id=1-5、Reactive应用><a class=headerlink href=#1-5、Reactive应用 title=1.5、Reactive应用></a>1.5、Reactive应用</h2><p>待补充。<h1 id=AOP管理><a class=headerlink href=#AOP管理 title=AOP管理></a>AOP管理</h1><h2 id=1-1、概述-1><a class=headerlink href=#1-1、概述-1 title=1.1、概述></a>1.1、概述</h2><p><strong>对于AOP功能，springboot默认加载的自动配置为 AopAutoConfiguration</strong>。<h2 id=1-2、AopAutoConfiguration><a class=headerlink href=#1-2、AopAutoConfiguration title=1.2、AopAutoConfiguration></a>1.2、AopAutoConfiguration</h2><p>该配置生效的前提是设置了属性<code>spring.aop.auto=true</code>。<p><strong>1. 静态内部类：AspectJAutoProxyingConfiguration</strong><p>该配置生效的前提是存在class：Advice。<p><strong>如果设置了属性<code>spring.aop.proxy-target-class=false</code>，开启JDK动态代理。</strong>会向容器中导入一个AspectJAutoProxyRegistrar，该类实现了 ImportBeanDefinitionRegistrar 的 registerBeanDefinitions方法，在该方法中会获取自动代理创建器的bean定义信息，为该bean定义设置属性proxyTargetClass=true。<p><strong>如果设置了属性<code>spring.aop.proxy-target-class=true</code>，或没有配置该属性，那么都会开启CGLib代理。</strong>会向容器中导入一个AspectJAutoProxyRegistrar，该类实现了 ImportBeanDefinitionRegistrar 的 registerBeanDefinitions方法，在该方法中会获取自动代理创建器的bean定义信息，为该bean定义设置属性exposeProxy=true。<p><strong>2. 静态内部类：ClassProxyingConfiguration</strong><p>该配置生效的前提如下：<ul><li>缺失class：org.aspectj.weaver.Advice。<li>设置了属性 spring.aop.proxy-target-class=true。</ul><p>创建一个BeanFactoryPostProcessor，通过该增强器向容器中放入一个代理创建器，实现最终代理对象的创建。<h1 id=事务管理><a class=headerlink href=#事务管理 title=事务管理></a>事务管理</h1><h2 id=1-1、概述-2><a class=headerlink href=#1-1、概述-2 title=1.1、概述></a>1.1、概述</h2><p>对于事务管理，springboot默认自动配置如下：<ul><li><strong>TransactionAutoConfiguration</strong>：会读取TransactionProperties绑定的前缀为<code>spring.transaction</code>的配置。<li><strong>JtaAutoConfiguration</strong>：</ul><h2 id=1-2、TransactionAutoConfiguration><a class=headerlink href=#1-2、TransactionAutoConfiguration title=1.2、TransactionAutoConfiguration></a>1.2、TransactionAutoConfiguration</h2><p>该配置生效的前提是存在class：PlatformTransactionManager。<p>如果缺失 TransactionManagerCustomizers，那么创建 TransactionManagerCustomizers 放入容器。<p>如果缺失 TransactionalOperator，且只存在一个ReactiveTransactionManager，那么创建 TransactionalOperator 放入容器。<p><strong>1. 静态内部类：TransactionTemplateConfiguration</strong><p>该配置生效的前提是容器中只有一个 PlatformTransactionManager。<p>如果缺失 TransactionOperations，那么创建 TransactionTemplate 放入容器。<p><strong>2. 静态内部类：EnableTransactionManagementConfiguration</strong><p>该配置生效的前提是存在TransactionManager，且不存在 AbstractTransactionManagementConfiguration。<p>如果设置了属性spring.aop.proxy-target-class=false，那么使用注解@EnableTransactionManagement(proxyTargetClass=false) 标示 JdkDynamicAutoProxyConfiguration。<p>如果设置了属性spring.aop.proxy-target-class=true，或没有设置，那么使用注解@EnableTransactionManagement(proxyTargetClass=true) 标示 CglibAutoProxyConfiguration。<h2 id=1-3、JtaAutoConfiguration><a class=headerlink href=#1-3、JtaAutoConfiguration title=1.3、JtaAutoConfiguration></a>1.3、JtaAutoConfiguration</h2><p>该配置生效的前提如下：<ul><li>存在class：javax.transaction.Transaction。<li>设置了属性spring.jta.enabled。</ul><p>该配置会导入如下配置：<ul><li>JndiJtaConfiguration<li>AtomikosJtaConfiguration</ul><p>该配置加载完后会加载如下配置：<ul><li>XADataSourceAutoConfiguration<li>ActiveMQAutoConfiguration<li>ArtemisAutoConfiguration<li>HibernateJpaAutoConfiguration<li>TransactionAutoConfiguration</ul></div><footer class=post-footer><div class=post-tags><a href=/tags/SpringBoot/ rel=tag># SpringBoot</a><a href=/tags/SpringBoot%E5%8E%9F%E7%90%86/ rel=tag># SpringBoot原理</a></div><div class=post-nav><div class=post-nav-item><a href=/2024/08/21/Shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87/ rel=prev title=Linux系列-Shell基础应用> <i class="fa fa-angle-left"></i> Linux系列-Shell基础应用 </a></div><div class=post-nav-item><a href=/2024/08/21/SpringAOP/ rel=next title=Spring系列-SpringAOP> Spring系列-SpringAOP <i class="fa fa-angle-right"></i> </a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script>