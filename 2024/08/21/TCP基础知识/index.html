<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hshz21.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="1、必备知识1.1、协议分类 IP（Internet Protocol）：⽹络协议。 TCP（Transmission Control Protocol）：传输控制协议。  四层协议，五层协议和七层协议的关系如下：  OSI七层协议模型包括：应⽤层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、⽹络层（Network）、数据链" name=description><meta content=article property=og:type><meta content=计算机系列-TCP基础知识 property=og:title><meta content=https://hshz21.gitee.io/2024/08/21/TCP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content="1、必备知识1.1、协议分类 IP（Internet Protocol）：⽹络协议。 TCP（Transmission Control Protocol）：传输控制协议。  四层协议，五层协议和七层协议的关系如下：  OSI七层协议模型包括：应⽤层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、⽹络层（Network）、数据链" property=og:description><meta content=zh_CN property=og:locale><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908153007750.png?token=AIGEF3OXKJLRJVGY7BKNGT3EZZSC4 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908153446067.png?token=AIGEF3MHOACQR3H4HWPIOTLEZZSEQ property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908153709918.png?token=AIGEF3LVR6MEHVKFNPKBES3EZZSFW property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908154657846.png?token=AIGEF3N2N3XRRUWMR5BLBTLEZZSG2 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908154817025.png?token=AIGEF3LSU3H6CSN4IXYNLEDEZZSIK property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908154934881.png?token=AIGEF3K3BICJ4RAVDA6FX5DEZZSJM property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908155442522.png?token=AIGEF3K7PY4QWVYOGZYWZVTEZZSKO property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417191856726.png?token=AIGEF3JFZ4N7DOLCPI6YDITEZZSL4 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805230506940.png?token=AIGEF3NDN664QOJTSGLSWZ3EZZSWA property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417192532442.png?token=AIGEF3OWNFJJ37OTKLX7PSTEZZSQW property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417192649183.png?token=AIGEF3N7O4DGC7GNOHFY3ZDEZZSXE property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417192824629.png?token=AIGEF3NGIFIJ6IYJR26U4ITEZZSYA property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417192939108.png?token=AIGEF3MC6M5ADE6ZJVKFGVLEZZSZM property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417232739572.png?token=AIGEF3LMMC7SAUWHAW4ESDLEZZS2Q property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417233420965.png?token=AIGEF3OFM47VCTUWQ2PHFSLEZZS3W property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417233640884.png?token=AIGEF3N7ZKU5MFNTOKTN77TEZZS4W property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417233800922.png?token=AIGEF3PO4B6SO3FWJ7PH7ZLEZZS7G property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417234245342.png?token=AIGEF3LJEO3GN6F43A5XBSTEZZTAU property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417234516493.png?token=AIGEF3LNHDRZTZB6B3XLCOTEZZTCG property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417234958826.png?token=AIGEF3JMC6ZT7FSRXEKBN53EZZTD2 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417235253264.png?token=AIGEF3IUVHCAKAB25MIWCRLEZZTE4 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417235319675.png?token=AIGEF3OPAGFASP2EYLYQ53LEZZTF2 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805102056836.png?token=AIGEF3N2GDJ5NWRU4F4XQYDEZZTIE property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417235921203.png?token=AIGEF3I6C25RFPERRQ7TVFTEZZTJY property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418180447932.png?token=AIGEF3P3HVCKSTZZK3AUCBDEZZTLM property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418180514513.png?token=AIGEF3IXPTYRPDYKT6VPVDDEZZTM4 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418181534600.png?token=AIGEF3OZCRTI7FAGMHYAVKDEZZTOG property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418181843933.png?token=AIGEF3PA4IMXWL5XUJHRXR3EZZTPO property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418182234840.png?token=AIGEF3NARXVMDYNKWI25NNLEZZTQQ property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418182508676.png?token=AIGEF3JXO2IAKFUPH5NXLZ3EZZTRY property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418182907615.png?token=AIGEF3J5YB22J346SPF5US3EZZTTK property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418184842512.png?token=AIGEF3OVHEKLN4G5UWD33ODEZZTVQ property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418190150299.png?token=AIGEF3KSEBJ2ISXTJSHR5ODEZZTWQ property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418190500847.png?token=AIGEF3JQ4TJUE2EKGKDAEYTEZZTXS property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418190824253.png?token=AIGEF3OMNX6UPRX5HTWPQ4LEZZTYW property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418190933705.png?token=AIGEF3O7Y4XVQBQTANPYGO3EZZTZ2 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418200853587.png?token=AIGEF3PKZQ5DN2HYA6BCJCDEZZT2Y property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418200928818.png?token=AIGEF3LE7BG2HJ6Z6QJ6XKDEZZT32 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418201102398.png?token=AIGEF3MOTGYQRFXHFW5SSXTEZZT4Y property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202018005.png?token=AIGEF3PR3UMRW7WSX34RVLDEZZT6S property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202153188.png?token=AIGEF3JDYMONIYRUTC5QUJ3EZZT7S property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202233550.png?token=AIGEF3JSAG777JY5DJFM5H3EZZUAO property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202341149.png?token=AIGEF3NE7TGUGCNVKOK7L7TEZZUBM property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202433581.png?token=AIGEF3LYEPBDR246AOHSDEDEZZUC2 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202450402.png?token=AIGEF3IAGE5H6T7P3G44GKLEZZUDU property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202537593.png?token=AIGEF3KA4HVZAA4VGZDTMADEZZUEQ property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202615907.png?token=AIGEF3LIA34H3VZQALS4XEDEZZUFK property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202715040.png?token=AIGEF3MST7XUUM4TWEWOZTLEZZUGG property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202743734.png?token=AIGEF3KFXAKORLXG72225EDEZZUHE property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202819569.png?token=AIGEF3IDCHC3R3GHJWZ363DEZZUIC property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202908422.png?token=AIGEF3J3LN4DYGVK62II6WDEZZUJG property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805102847562.png?token=AIGEF3K4IHX6PSTQALISP6TEZZUKI property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418203046836.png?token=AIGEF3JHJ2G323ECIVG3Y4DEZZULS property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418203159568.png?token=AIGEF3NJGPQKHQAGFYI24ADEZZUNA property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418203407354.png?token=AIGEF3J3SFLUFVYQIXAAD4DEZZUN4 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418203616446.png?token=AIGEF3NTMZYSYP57CGLLTFTEZZUO4 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418203701456.png?token=AIGEF3O3LKGSZ333JXPZHWTEZZUQA property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418203828453.png?token=AIGEF3NYDNTGIFJQDUNTOUTEZZURC property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418204051701.png?token=AIGEF3J335BODYBV3SZHHUDEZZUSI property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418204332745.png?token=AIGEF3LI4BBBZGHTKCMH7Y3EZZUTU property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418204448802.png?token=AIGEF3NJBMGXP7VKHIXI3UDEZZUVY property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418204505382.png?token=AIGEF3IARNNM3GI3IT34CELEZZUWW property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418204559635.png?token=AIGEF3MRLKYYVVHK6L3S3Y3EZZUXY property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418204818957.png?token=AIGEF3LZ62PJJVNTIUR4BBTEZZUZE property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205021190.png?token=AIGEF3MHXN4WBSV26XSBUELEZZU22 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205117533.png?token=AIGEF3MFFBYKXCNBGCX3D5LEZZU4A property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205305424.png?token=AIGEF3MWW57T5KNZR3E4N7TEZZU5I property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205329777.png?token=AIGEF3ORD7GOE7HCQEI4Z4TEZZU6K property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805103313643.png?token=AIGEF3NSSNDSGZCKRVNFJ4TEZZVAM property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205502767.png?token=AIGEF3NJ2QH5KMH6NFUXLH3EZZVBG property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205550656.png?token=AIGEF3JWSRU23OMVRDXEAVDEZZVCI property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205726162.png?token=AIGEF3MS2IW2ALHPL7GD3TTEZZVDU property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205745092.png?token=AIGEF3N4L43FUN4U3HXAS4LEZZVEW property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205925842.png?token=AIGEF3L2IHRNUBIAAQ46BKDEZZVF2 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418210021774.png?token=AIGEF3NILLHJKEH27TJVW6DEZZVG2 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418210742380.png?token=AIGEF3OFI37WZUHK74FQJ4LEZZVIA property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418210838615.png?token=AIGEF3JNA7QROZIRJVZKGA3EZZVJI property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418211048586.png?token=AIGEF3IOPQFQ3WYV3C6BLKDEZZVKO property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418211130135.png?token=AIGEF3KM5Z6JBRZWQT46ATLEZZVLS property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418211148700.png?token=AIGEF3IJM24JBAGI3R5MYHDEZZVMS property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418211558531.png?token=AIGEF3LAXJXBB2UQVRVMKZTEZZVN4 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418211755905.png?token=AIGEF3LEEIIBZJGXRG66WQLEZZVO6 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805103619338.png?token=AIGEF3PLZVBEFGJZGDTQLH3EZZVP6 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418212006158.png?token=AIGEF3PV7PYPGEIURYGJ24LEZZVQ4 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418212037121.png?token=AIGEF3KUWGGEUR7OLOSZG4DEZZVSQ property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418212216740.png?token=AIGEF3KQCLYZSR6Y7FSCUWLEZZVTW property=og:image><meta content=2024-08-21T13:39:14.805Z property=article:published_time><meta content=2023-10-06T14:54:09.495Z property=article:modified_time><meta content=豪哥 property=article:author><meta content=网络协议 property=article:tag><meta content=TCP property=article:tag><meta content=summary name=twitter:card><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908153007750.png?token=AIGEF3OXKJLRJVGY7BKNGT3EZZSC4 name=twitter:image><link href=https://hshz21.gitee.io/2024/08/21/TCP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hshz21.gitee.io/2024/08/21/TCP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","path":"2024/08/21/TCP基础知识/","title":"计算机系列-TCP基础知识"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>计算机系列-TCP基础知识 | 豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>豪哥博客</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#1%E3%80%81%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86><span class=nav-number>1.</span> <span class=nav-text>1、必备知识</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81%E5%8D%8F%E8%AE%AE%E5%88%86%E7%B1%BB><span class=nav-number>1.1.</span> <span class=nav-text>1.1、协议分类</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-2%E3%80%81OSI%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE><span class=nav-number>1.2.</span> <span class=nav-text>1.2、OSI七层协议</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-3%E3%80%81TCP-IP%E5%9B%9B%E5%B1%82%E5%8D%8F%E8%AE%AE><span class=nav-number>1.3.</span> <span class=nav-text>1.3、TCP/IP四层协议</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#2%E3%80%81TCP%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90><span class=nav-number>2.</span> <span class=nav-text>2、TCP深度剖析</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#2-1%E3%80%81TCP%E4%B8%8EUDP><span class=nav-number>2.1.</span> <span class=nav-text>2.1、TCP与UDP</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-2%E3%80%81TCP-IP%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BB%93%E6%9E%84><span class=nav-number>2.2.</span> <span class=nav-text>2.2、TCP/IP数据包结构</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-1%E3%80%81TCP%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BB%93%E6%9E%84><span class=nav-number>2.2.1.</span> <span class=nav-text>2.2.1、TCP数据包结构</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-2%E3%80%81IP%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BB%93%E6%9E%84><span class=nav-number>2.2.2.</span> <span class=nav-text>2.2.2、IP数据包结构</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#3%E3%80%81TCP%E4%BC%A0%E8%BE%93><span class=nav-number>3.</span> <span class=nav-text>3、TCP传输</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#3-1%E3%80%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B><span class=nav-number>3.1.</span> <span class=nav-text>3.1、三次握手</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-2%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B><span class=nav-number>3.2.</span> <span class=nav-text>3.2、四次挥手</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-3%E3%80%81%E6%80%BB%E7%BB%93><span class=nav-number>3.3.</span> <span class=nav-text>3.3、总结</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-3-1%E3%80%81%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F><span class=nav-number>3.3.1.</span> <span class=nav-text>3.3.1、为何需要三次握手？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-3-2%E3%80%81%E4%B8%BA%E4%BD%95%E6%8F%A1%E6%89%8B%E8%A6%81%E4%B8%89%E6%AC%A1%EF%BC%8C%E8%80%8C%E6%8C%A5%E6%89%8B%E8%A6%81%E5%9B%9B%E6%AC%A1%EF%BC%9F><span class=nav-number>3.3.2.</span> <span class=nav-text>3.3.2、为何握手要三次，而挥手要四次？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-3-3%E3%80%81%E4%B8%BA%E4%BD%95%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%8F%91%E9%80%81%E7%A1%AE%E8%AE%A4%E6%8A%A5%E6%96%87%E5%90%8E%E8%BF%98%E8%A6%81%E7%AD%892MSL%E5%90%8E%E6%89%8D%E5%85%B3%E9%97%AD%EF%BC%9F><span class=nav-number>3.3.3.</span> <span class=nav-text>3.3.3、为何客户端第四次发送确认报文后还要等2MSL后才关闭？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-3-4%E3%80%81%E8%8B%A5%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AA%81%E7%84%B6%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%EF%BC%8C%E9%82%A3%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F><span class=nav-number>3.3.4.</span> <span class=nav-text>3.3.4、若已经建立连接，但客户端突然出现故障，那如何解决？</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#4%E3%80%81TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93><span class=nav-number>4.</span> <span class=nav-text>4、TCP可靠传输</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#4-1%E3%80%81%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6><span class=nav-number>4.1.</span> <span class=nav-text>4.1、重传机制</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#5-1-1%E3%80%81%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0><span class=nav-number>4.1.1.</span> <span class=nav-text>5.1.1、超时重传</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BD%95%E4%B8%BA%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0><span class=nav-number>4.1.1.1.</span> <span class=nav-text>何为超时重传</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%A7%A6%E5%8F%91%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0><span class=nav-number>4.1.1.2.</span> <span class=nav-text>触发超时重传</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E8%AE%BE%E7%BD%AE%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4><span class=nav-number>4.1.1.3.</span> <span class=nav-text>设置超时时间</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#5-1-2%E3%80%81%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0><span class=nav-number>4.1.2.</span> <span class=nav-text>5.1.2、快速重传</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#5-1-3%E3%80%81SACK><span class=nav-number>4.1.3.</span> <span class=nav-text>5.1.3、SACK</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#5-1-4%E3%80%81D-SACK><span class=nav-number>4.1.4.</span> <span class=nav-text>5.1.4、D-SACK</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#4-2%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3><span class=nav-number>4.2.</span> <span class=nav-text>4.2、滑动窗口</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-2-1%E3%80%81%E7%AA%97%E5%8F%A3%E4%BD%9C%E7%94%A8><span class=nav-number>4.2.1.</span> <span class=nav-text>4.2.1、窗口作用</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-2-2%E3%80%81%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E8%B0%81%E6%9D%A5%E5%86%B3%E5%AE%9A><span class=nav-number>4.2.2.</span> <span class=nav-text>4.2.2、窗口大小谁来决定</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-2-3%E3%80%81%E5%8F%91%E9%80%81%E6%96%B9%E7%AA%97%E5%8F%A3><span class=nav-number>4.2.3.</span> <span class=nav-text>4.2.3、发送方窗口</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-2-4%E3%80%81%E6%8E%A5%E6%94%B6%E6%96%B9%E7%AA%97%E5%8F%A3><span class=nav-number>4.2.4.</span> <span class=nav-text>4.2.4、接收方窗口</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#4-3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6><span class=nav-number>4.3.</span> <span class=nav-text>4.3、流量控制</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-3-1%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9D%A5%E6%BA%90><span class=nav-number>4.3.1.</span> <span class=nav-text>4.3.1、流量控制来源</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-3-2%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB><span class=nav-number>4.3.2.</span> <span class=nav-text>4.3.2、操作系统缓冲区与滑动窗口的关系</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#4-3-2-1%E3%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A6%82%E4%BD%95%E5%93%8D%E5%BA%94%E5%8F%91%E9%80%81-%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3><span class=nav-number>4.3.2.1.</span> <span class=nav-text>4.3.2.1、缓冲区如何响应发送/接收窗口</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#4-3-3%E3%80%81%E7%AA%97%E5%8F%A3%E5%85%B3%E9%97%AD><span class=nav-number>4.3.3.</span> <span class=nav-text>4.3.3、窗口关闭</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#5-3-3-1%E3%80%81%E7%AA%97%E5%8F%A3%E5%85%B3%E9%97%AD%E6%BD%9C%E5%9C%A8%E5%8D%B1%E9%99%A9><span class=nav-number>4.3.3.1.</span> <span class=nav-text>5.3.3.1、窗口关闭潜在危险</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-3-3-2%E3%80%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%AA%97%E5%8F%A3%E5%85%B3%E9%97%AD%E6%97%B6%E7%9A%84%E6%AD%BB%E9%94%81%E7%8E%B0%E8%B1%A1><span class=nav-number>4.3.3.2.</span> <span class=nav-text>5.3.3.2、如何解决窗口关闭时的死锁现象</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#5-3-4%E3%80%81%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E7%97%87><span class=nav-number>4.3.4.</span> <span class=nav-text>5.3.4、糊涂窗口综合症</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#5-3-4-1%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%A9%E6%8E%A5%E6%94%B6%E6%96%B9%E4%B8%8D%E9%80%9A%E5%91%8A%E5%B0%8F%E7%AA%97%E5%8F%A3><span class=nav-number>4.3.4.1.</span> <span class=nav-text>5.3.4.1、如何让接收方不通告小窗口</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-3-4-2%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%A9%E5%8F%91%E9%80%81%E6%96%B9%E9%81%BF%E5%85%8D%E5%8F%91%E9%80%81%E5%B0%8F%E6%95%B0%E6%8D%AE><span class=nav-number>4.3.4.2.</span> <span class=nav-text>5.3.4.2、如何让发送方避免发送小数据</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#4-4%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6><span class=nav-number>4.4.</span> <span class=nav-text>4.4、拥塞控制</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-4-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>4.4.1.</span> <span class=nav-text>4.4.1、简介</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#4-4-1-1%E3%80%81%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6><span class=nav-number>4.4.1.1.</span> <span class=nav-text>4.4.1.1、为何需要拥塞控制</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-4-1-2%E3%80%81%E4%BD%95%E4%B8%BA%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3%EF%BC%8C%E4%B8%8E%E5%8F%91%E9%80%81%E7%AA%97%E5%8F%A3%E6%9C%89%E5%95%A5%E5%85%B3%E7%B3%BB%EF%BC%9F><span class=nav-number>4.4.1.2.</span> <span class=nav-text>4.4.1.2、何为拥塞窗口，与发送窗口有啥关系？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-4-1-3%E3%80%81%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%BD%91%E7%BB%9C%E6%8B%A5%E5%A1%9E%E4%BA%86%EF%BC%9F><span class=nav-number>4.4.1.3.</span> <span class=nav-text>4.4.1.3、如何判断网络拥塞了？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-4-1-4%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95><span class=nav-number>4.4.1.4.</span> <span class=nav-text>4.4.1.4、拥塞控制算法</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#4-4-2%E3%80%81%E6%85%A2%E5%90%AF%E5%8A%A8><span class=nav-number>4.4.2.</span> <span class=nav-text>4.4.2、慢启动</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#4-4-2-1%E3%80%81%E6%85%A2%E5%90%AF%E5%8A%A8%E6%B6%A8%E5%88%B0%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%BB%93%E6%9D%9F><span class=nav-number>4.4.2.1.</span> <span class=nav-text>4.4.2.1、慢启动涨到什么时候结束</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#4-4-3%E3%80%81%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95><span class=nav-number>4.4.3.</span> <span class=nav-text>4.4.3、拥塞避免算法</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-4-4%E3%80%81%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F><span class=nav-number>4.4.4.</span> <span class=nav-text>4.4.4、拥塞发生</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#4-4-4-1%E3%80%81%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F%E7%AE%97%E6%B3%95><span class=nav-number>4.4.4.1.</span> <span class=nav-text>4.4.4.1、超时重传拥塞发生算法</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-4-4-2%E3%80%81%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F%E7%AE%97%E6%B3%95><span class=nav-number>4.4.4.2.</span> <span class=nav-text>4.4.4.2、快速重传拥塞发生算法</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#4-4-5%E3%80%81%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D><span class=nav-number>4.4.5.</span> <span class=nav-text>4.4.5、快速恢复</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-4-6%E3%80%81%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95%E7%A4%BA%E6%84%8F%E5%9B%BE><span class=nav-number>4.4.6.</span> <span class=nav-text>4.4.6、拥塞算法示意图</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#5%E3%80%81TCP%E6%80%A7%E8%83%BD%E4%BC%A0%E8%BE%93><span class=nav-number>5.</span> <span class=nav-text>5、TCP性能传输</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#5-1%E3%80%81%E6%8F%90%E5%8D%87TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%80%A7%E8%83%BD><span class=nav-number>5.1.</span> <span class=nav-text>5.1、提升TCP三次握手性能</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#5-1-1%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96><span class=nav-number>5.1.1.</span> <span class=nav-text>5.1.1、客户端优化</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#5-1-1-1%E3%80%81SYN-SENT-%E7%8A%B6%E6%80%81%E4%BC%98%E5%8C%96><span class=nav-number>5.1.1.1.</span> <span class=nav-text>5.1.1.1、SYN_SENT 状态优化</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#5-1-2%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%98%E5%8C%96><span class=nav-number>5.1.2.</span> <span class=nav-text>5.1.2、服务端优化</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#5-1-2-1%E3%80%81%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%94%B1%E4%BA%8E-SYN-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%B7%B2%E6%BB%A1%E2%BD%BD%E8%A2%AB%E4%B8%A2%E5%BC%83%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F><span class=nav-number>5.1.2.1.</span> <span class=nav-text>5.1.2.1、如何查看由于 SYN 半连接队列已满⽽被丢弃连接的情况？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-1-2-2%E3%80%81%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4-SYN-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E2%BC%A4%E2%BC%A9%EF%BC%9F><span class=nav-number>5.1.2.2.</span> <span class=nav-text>5.1.2.2、如何调整 SYN 半连接队列⼤⼩？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-1-2-3%E3%80%81%E5%A6%82%E6%9E%9C-SYN-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%B7%B2%E6%BB%A1%EF%BC%8C%E5%8F%AA%E8%83%BD%E4%B8%A2%E5%BC%83%E8%BF%9E%E6%8E%A5%E5%90%97%EF%BC%9F><span class=nav-number>5.1.2.3.</span> <span class=nav-text>5.1.2.3、如果 SYN 半连接队列已满，只能丢弃连接吗？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-1-2-4%E3%80%81SYN-RCV-%E7%8A%B6%E6%80%81%E4%BC%98%E5%8C%96><span class=nav-number>5.1.2.4.</span> <span class=nav-text>5.1.2.4、SYN_RCV 状态优化</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-1-2-5%E3%80%81accept-%E9%98%9F%E5%88%97%E5%B7%B2%E6%BB%A1%EF%BC%8C%E5%8F%AA%E8%83%BD%E4%B8%A2%E5%BC%83%E8%BF%9E%E6%8E%A5%E5%90%97%EF%BC%9F><span class=nav-number>5.1.2.5.</span> <span class=nav-text>5.1.2.5、accept 队列已满，只能丢弃连接吗？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-1-2-6%E3%80%81%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4-accept-%E9%98%9F%E5%88%97%E7%9A%84%E2%BB%93%E5%BA%A6%EF%BC%9F><span class=nav-number>5.1.2.6.</span> <span class=nav-text>5.1.2.6、如何调整 accept 队列的⻓度？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-1-2-7%E3%80%81%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%94%B1%E4%BA%8E-accept-%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%B7%B2%E6%BB%A1%EF%BC%8C%E2%BD%BD%E8%A2%AB%E4%B8%A2%E5%BC%83%E7%9A%84%E8%BF%9E%E6%8E%A5%EF%BC%9F><span class=nav-number>5.1.2.7.</span> <span class=nav-text>5.1.2.7、如何查看由于 accept 连接队列已满，⽽被丢弃的连接？</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#5-1-3%E3%80%81%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B><span class=nav-number>5.1.3.</span> <span class=nav-text>5.1.3、如何绕过三次握手</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#5-1-3-1%E3%80%81TCP-Fast-Open-%E2%BC%AF%E4%BD%9C%E2%BD%85%E5%BC%8F%E3%80%82><span class=nav-number>5.1.3.1.</span> <span class=nav-text>5.1.3.1、TCP Fast Open ⼯作⽅式。</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-1-3-2%E3%80%81Linux-%E4%B8%8B%E5%A6%82%E4%BD%95%E6%89%93%E5%BC%80-TCP-Fast-Open-%E5%8A%9F%E8%83%BD><span class=nav-number>5.1.3.2.</span> <span class=nav-text>5.1.3.2、Linux 下如何打开 TCP Fast Open 功能</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#5-1-4%E3%80%81%E5%B0%8F%E7%BB%93><span class=nav-number>5.1.4.</span> <span class=nav-text>5.1.4、小结</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#5-1-4-1%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%98%E5%8C%96><span class=nav-number>5.1.4.1.</span> <span class=nav-text>5.1.4.1、客户端优化</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-1-4-2%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%98%E5%8C%96><span class=nav-number>5.1.4.2.</span> <span class=nav-text>5.1.4.2、服务端优化</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-1-4-3%E3%80%81%E7%BB%95%E8%BF%87%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B><span class=nav-number>5.1.4.3.</span> <span class=nav-text>5.1.4.3、绕过三次握手</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#5-2%E3%80%81%E6%8F%90%E5%8D%87TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%80%A7%E8%83%BD><span class=nav-number>5.2.</span> <span class=nav-text>5.2、提升TCP四次挥手性能</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#5-2-1%E3%80%81%E4%B8%BB%E5%8A%A8%E6%96%B9%E4%BC%98%E5%8C%96><span class=nav-number>5.2.1.</span> <span class=nav-text>5.2.1、主动方优化</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#5-2-1-1%E3%80%81-close-%E5%87%BD%E6%95%B0%E5%92%8C-shutdown-%E5%87%BD%E6%95%B0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F><span class=nav-number>5.2.1.1.</span> <span class=nav-text>5.2.1.1、 close 函数和 shutdown 函数有什么区别？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-2-1-2%E3%80%81FIN-WAIT1-%E7%8A%B6%E6%80%81%E7%9A%84%E4%BC%98%E5%8C%96><span class=nav-number>5.2.1.2.</span> <span class=nav-text>5.2.1.2、FIN_WAIT1 状态的优化</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-2-1-3%E3%80%81FIN-WAIT2-%E7%8A%B6%E6%80%81%E7%9A%84%E4%BC%98%E5%8C%96><span class=nav-number>5.2.1.3.</span> <span class=nav-text>5.2.1.3、FIN_WAIT2 状态的优化</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-2-1-4%E3%80%81TIME-WAIT-%E7%8A%B6%E6%80%81%E7%9A%84%E4%BC%98%E5%8C%96><span class=nav-number>5.2.1.4.</span> <span class=nav-text>5.2.1.4、TIME_WAIT 状态的优化</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#5-2-2%E3%80%81%E8%A2%AB%E5%8A%A8%E6%96%B9%E4%BC%98%E5%8C%96><span class=nav-number>5.2.2.</span> <span class=nav-text>5.2.2、被动方优化</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#5-2-2-1%E3%80%81%E5%A6%82%E6%9E%9C%E8%BF%9E%E6%8E%A5%E5%8F%8C%E2%BD%85%E5%90%8C%E6%97%B6%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F><span class=nav-number>5.2.2.1.</span> <span class=nav-text>5.2.2.1、如果连接双⽅同时关闭连接，会怎么样？</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#5-2-3%E3%80%81%E5%B0%8F%E7%BB%93><span class=nav-number>5.2.3.</span> <span class=nav-text>5.2.3、小结</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#5-2-3-1%E3%80%81%E4%B8%BB%E5%8A%A8%E6%96%B9%E4%BC%98%E5%8C%96><span class=nav-number>5.2.3.1.</span> <span class=nav-text>5.2.3.1、主动方优化</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-2-3-2%E3%80%81%E8%A2%AB%E5%8A%A8%E2%BD%85%E7%9A%84%E4%BC%98%E5%8C%96><span class=nav-number>5.2.3.2.</span> <span class=nav-text>5.2.3.2、被动⽅的优化</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#5-3%E3%80%81%E6%8F%90%E5%8D%87TCP%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E6%80%A7%E8%83%BD><span class=nav-number>5.3.</span> <span class=nav-text>5.3、提升TCP传输数据性能</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#5-3-1%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E2%BC%9D%E5%BD%B1%E5%93%8D%E4%BC%A0%E8%BE%93%E9%80%9F%E5%BA%A6><span class=nav-number>5.3.1.</span> <span class=nav-text>5.3.1、滑动窗⼝影响传输速度</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#5-3-2%E3%80%81%E7%A1%AE%E5%AE%9A%E6%9C%80%E2%BC%A4%E4%BC%A0%E8%BE%93%E9%80%9F%E5%BA%A6><span class=nav-number>5.3.2.</span> <span class=nav-text>5.3.2、确定最⼤传输速度</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#5-3-3%E3%80%81%E8%B0%83%E6%95%B4%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%A7%E5%B0%8F><span class=nav-number>5.3.3.</span> <span class=nav-text>5.3.3、调整缓冲区大小</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#5-3-3-1%E3%80%81%E8%B0%83%E8%8A%82%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E8%8C%83%E5%9B%B4><span class=nav-number>5.3.3.1.</span> <span class=nav-text>5.3.3.1、调节发送缓冲区范围</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-3-3-2%E3%80%81%E8%B0%83%E8%8A%82%E6%8E%A5%E6%94%B6%E7%BC%93%E5%86%B2%E5%8C%BA%E8%8C%83%E5%9B%B4><span class=nav-number>5.3.3.2.</span> <span class=nav-text>5.3.3.2、调节接收缓冲区范围</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-3-3-3%E3%80%81%E8%B0%83%E8%8A%82-TCP-%E5%86%85%E5%AD%98%E8%8C%83%E5%9B%B4><span class=nav-number>5.3.3.3.</span> <span class=nav-text>5.3.3.3、调节 TCP 内存范围</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-3-3-4%E3%80%81%E6%A0%B9%E6%8D%AE%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF%E8%B0%83%E8%8A%82%E7%9A%84%E7%AD%96%E7%95%A5><span class=nav-number>5.3.3.4.</span> <span class=nav-text>5.3.3.4、根据实际场景调节的策略</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#5-3-4%E3%80%81%E5%B0%8F%E7%BB%93><span class=nav-number>5.3.4.</span> <span class=nav-text>5.3.4、小结</span></a></ol></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>116</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>36</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>129</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://hshz21.gitee.io/2024/08/21/TCP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="计算机系列-TCP基础知识 | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>计算机系列-TCP基础知识</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-06 22:54:09" datetime=2023-10-06T22:54:09+08:00 itemprop=dateModified>2023-10-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/ itemprop=url rel=index><span itemprop=name>计算机</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、必备知识><a class=headerlink href=#1、必备知识 title=1、必备知识></a>1、必备知识</h1><h2 id=1-1、协议分类><a class=headerlink href=#1-1、协议分类 title=1.1、协议分类></a>1.1、协议分类</h2><ul><li>IP（Internet Protocol）：⽹络协议。<li>TCP（Transmission Control Protocol）：传输控制协议。</ul><p>四层协议，五层协议和七层协议的关系如下：<ul><li><p>OSI七层协议模型包括：应⽤层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、⽹络层（Network）、数据链路层（Data Link）、物理层（Physical）。</p><li><p>TCP/IP四层体系结构包括：应⽤层、运输层、⽹际层和⽹络接⼝层。</p></ul><p><img alt=image-20200908153007750 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908153007750.png?token=AIGEF3OXKJLRJVGY7BKNGT3EZZSC4><blockquote><p>注：五层协议体系结构只是为了介绍⽹络原理⽽设计，实际应⽤还是 TCP/IP 四层体系结构。</blockquote><h2 id=1-2、OSI七层协议><a class=headerlink href=#1-2、OSI七层协议 title=1.2、OSI七层协议></a>1.2、OSI七层协议</h2><ol><li><font color=orange>物理层（Physical）</font>：网线、网卡、集线器、调制解调器；<li><font color=orange>数据链路层（Data Link）</font>：网桥、交换机、基于mac地址的物理寻址；例如以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP。<li><font color=orange>⽹络层（Network）</font>：路由器；例如IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、 X.25。<li><font color=orange>传输层（Transport）</font>：TLS协议、SSL协议；例如TCP、UDP、RTP、SCTP、SPX、ATP、IL。<li><font color=orange>会话层（Session）</font>：例如ASAP、TLS、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets。<li><font color=orange>表示层（Presentation）</font>：例如XDR、ASN.1、SMB、AFP、NCP。<li><font color=orange>应⽤层（Application）</font>：例如HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP。</ol><blockquote><p>传输层安全性协议（英语：Transport Layer Security，缩写TLS）的前身是安全套接层（Secure Sockets Layer，缩写作SSL）协议。该协议主要为互联网通信提供安全及数据完整性保障。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。<p>TLS协议采用主从式架构模型，用于在两个应用间透过网络创建安全连线，防止在交换数据时被窃听及篡改。</blockquote><h2 id=1-3、TCP-IP四层协议><a class=headerlink href=#1-3、TCP-IP四层协议 title=1.3、TCP/IP四层协议></a>1.3、TCP/IP四层协议</h2><p>TCP/IP 被分为 4 层，每层的 任务 和 ⼯作⽅式 都不同，每层封装上层数据的⽅式也不同：<ol><li>应⽤层：应⽤程序通过该层访问⽹络，该层协议有HTTP、FTP、TFTP、SMTP、SNMP、DNS 和 TELNET；数据格式为数据报文。<li>传输层：TCP协议、UDP协议；数据格式为 数据段。<li>⽹络层：IP协议、ICMP协议、IGMP协议等；数据格式为 数据包。<li>⽹络接⼝层：ARP协议、RARP协议；该层是TCP/IP 协议的基层，负责数据帧的发送和接收。数据格式为 数据帧和bit。</ol><h1 id=2、TCP深度剖析><a class=headerlink href=#2、TCP深度剖析 title=2、TCP深度剖析></a>2、TCP深度剖析</h1><h2 id=2-1、TCP与UDP><a class=headerlink href=#2-1、TCP与UDP title=2.1、TCP与UDP></a>2.1、TCP与UDP</h2><ul><li>TCP（传输控制协议）：提供⾯向连接的，可靠的数据传输服务。<li>UDP（⽤户数据协议）：提供⽆连接的，尽最⼤努⼒的数据传输服务（不保证数据传输的可靠性）。</ul><p><img alt=image-20200908153446067 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908153446067.png?token=AIGEF3MHOACQR3H4HWPIOTLEZZSEQ><h2 id=2-2、TCP-IP数据包结构><a class=headerlink href=#2-2、TCP-IP数据包结构 title=2.2、TCP/IP数据包结构></a>2.2、TCP/IP数据包结构</h2><h3 id=2-2-1、TCP数据包结构><a class=headerlink href=#2-2-1、TCP数据包结构 title=2.2.1、TCP数据包结构></a>2.2.1、TCP数据包结构</h3><p><img alt=image-20200908153709918 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908153709918.png?token=AIGEF3LVR6MEHVKFNPKBES3EZZSFW><ol><li>第一行：源端口2字节，目的端口2字节；</ol><p>表示发送方和接收方的端口号。<ol start=2><li><p>第二、三行：序列号4字节，确认号4字节；</p> <ul><li>序列号是指该报文段在发送方数据字节流中的位置，在TCP字节流中，每个数据字节都被编号；<li>确认号是指本机希望收到的下一个字节的序号；<li>序列号和确认号分别对应报文发送方向和相反方向的数据流；<li>报文被分解成多个报文段时，序列号就是首字节在整个报文中的偏移量，确认号指定下一个期待的字节；<li>序列号和确认号的最大表示范围均为2^32-1=4294967295≈42.9亿；</ul><li><p>第四行：首部长度4位，保留6位，标志位6位，窗口大小16位；</p> <ul><li><p>首部长度：指明首部共有多少行（每行4个字节），则TCP首部的最大长度为（2^4-1)*4=60字节；</p><li><p>标志位：公有6位，每一项含义分别如下：</p> <ol><li><font color=orange>SYN：建立连接 - 同步序号用来发起一个连接。</font><li><font color=orange>FIN：关闭连接 - 发端完成发送任务。</font><li><font color=orange>ACK：响应 - 确认序号有效。</font><li><font color=orange>PSH：有data数据传输 - 接收方尽快将这个报文段交给应用层。</font><li><font color=orange>RST：重建连接。</font><li><font color=orange>URG：紧急指针有效。</font></ol><li><p>窗口大小：即发送数据的窗口大小，告诉对方在不等待确认的情况下，可以发来多大的数据；这里表示的最大长度是2^16-1=65535，如需要使用更大的窗口大小，需要使用选项中的窗口扩大因子选项；</p></ul><li><p>第五行：TCP校验和16位，紧急指针16位；</p> <ul><li>TCP校验和：检查TCP报文段的完整性。TCP报文段咋源主机中被创建时会计算一个校验和，后将该校验和放入TCP头部的校验字段。目标主机收到后也会计算一个校验和，然后与之比较，如何两者相同说明TCP报文段完整，否则标识不完整。<li>紧急指针：当URG标志为1时紧急指针才有效，紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号（即序列号到紧急指针之间的数据为紧急数据，后面的数据才是正常数据）。</ul><li><p>第六行开始是选项部分：每个选项的开头是1字节的kind字段，表示选项类型。</p></ol><h3 id=2-2-2、IP数据包结构><a class=headerlink href=#2-2-2、IP数据包结构 title=2.2.2、IP数据包结构></a>2.2.2、IP数据包结构</h3><p><img alt=image-20200908154657846 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908154657846.png?token=AIGEF3N2N3XRRUWMR5BLBTLEZZSG2><h1 id=3、TCP传输><a class=headerlink href=#3、TCP传输 title=3、TCP传输></a>3、TCP传输</h1><h2 id=3-1、三次握手><a class=headerlink href=#3-1、三次握手 title=3.1、三次握手></a>3.1、三次握手</h2><p><img alt=image-20200908154817025 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908154817025.png?token=AIGEF3LSU3H6CSN4IXYNLEDEZZSIK><p><img alt=image-20200908154934881 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908154934881.png?token=AIGEF3K3BICJ4RAVDA6FX5DEZZSJM><h2 id=3-2、四次挥手><a class=headerlink href=#3-2、四次挥手 title=3.2、四次挥手></a>3.2、四次挥手</h2><p><img alt=image-20200908155442522 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908155442522.png?token=AIGEF3K7PY4QWVYOGZYWZVTEZZSKO><p><strong>最⼤分段寿命（MSL, Maximum Segment Lifetime）表示⼀个 TCP 分段可以存在于互联⽹系统中的最⼤时间，由 TCP 实现，超出这个寿命的分⽚都会被丢弃</strong>。<p>centOS中被定义为 30s，可通过<code>/proc/sys/net/ipv4/tcp_fin_timeout</code>⽂件查看和修改这个值。<blockquote><p>Socket：套接字，ip + port : ip + port。每台主机可以有65535个连接。</blockquote><h2 id=3-3、总结><a class=headerlink href=#3-3、总结 title=3.3、总结></a>3.3、总结</h2><h3 id=3-3-1、为何需要三次握手？><a class=headerlink href=#3-3-1、为何需要三次握手？ title=3.3.1、为何需要三次握手？></a>3.3.1、为何需要三次握手？</h3><p>A->B —> B->A —> A->B<p>因为需要考虑连接时的丢包问题。<p>如果只握⼿两次，即 B响应A后就开始收发数据。假如此时B响应A的确认包在传送过程中丢失了，且A因为⼀直无法收到B的确认包可能会关掉⾃⼰的socket，而B认为A一直在就会一直发送资源，最终会⽩⽩浪费掉B的资源。如果存在三次握⼿，就可避免上述问题。因为B在⼀段时间内没有收到A的确认ack报⽂，那么就会重发SYN报⽂段给A，A收到重发报⽂段后会再次发送确认ack报⽂给B。<h3 id=3-3-2、为何握手要三次，而挥手要四次？><a class=headerlink href=#3-3-2、为何握手要三次，而挥手要四次？ title=3.3.2、为何握手要三次，而挥手要四次？></a>3.3.2、为何握手要三次，而挥手要四次？</h3><ol><li><p>A -> <em>FIN</em> -> B</p><li><p>B -> <em>ACK</em> -> A</p> <p>……….数据传输………</p><li><p>B -> <em>FIN</em> -> A</p><li><p>A -> <em>ACK</em> -> B</p><li><p>B收到A的回应后立即关闭，A则等待2MSL，若期间无任何动静再立即关闭。</p></ol><p><strong>因为只有在客户端和服务端都没有数据要发送时才能断开TCP</strong>。A发送FIN报⽂时只能证明A没有数据要发了，服务端B是否还有数据发给客户端A是不知道的。⽽服务端B收到客户端A的FIN报⽂后只能先回复客户端A⼀个确认报⽂我已收到，但我服务端B还有⼀些数据没发完，等这些数据发完了服务端B才能给客户端A发FIN报⽂(所以不能⼀次性将确认报⽂和FIN报⽂发给客户端，就是这⾥多出来了⼀次)。<h3 id=3-3-3、为何客户端第四次发送确认报文后还要等2MSL后才关闭？><a class=headerlink href=#3-3-3、为何客户端第四次发送确认报文后还要等2MSL后才关闭？ title=3.3.3、为何客户端第四次发送确认报文后还要等2MSL后才关闭？></a>3.3.3、为何客户端第四次发送确认报文后还要等2MSL后才关闭？</h3><p>因为同样是考虑到丢包问题。<p>第4次挥⼿报⽂发过之后，A并不知道B是否接到⾃⼰的ACK。但是A发送ACK后只有两种结果：<ol><li>如果B没有收到A发送的ACK，B会超时重传FIN，那么A再次接到重传FIN，进而会再次发送ACK。<li>如果B收到了A发送的ACK，被动关闭的B⽆需任何wait time，直接释放资源。也不会再发任何消息，包括ACK。</ol><p>所以A要取这两种情况等待时间的最⼤值，以应对最坏情况发⽣，最坏情况就是第⼀种情况：<strong>去向ACK消息最⼤存活时间（MSL) + 来向FIN消息最⼤存活时间(MSL)，刚好是2MSL( Maximum Segment Life)。等待2MSL时间，A就可以放⼼地释放TCP占⽤的资源、端⼝号，此时可以使⽤该端⼝号连接任何服务器</strong>。<p>还有⼀个重要概念——端⼝重⽤。<blockquote><p>每个MSL是2分钟，2个MSL就是4分钟。MSL是<code>maximium segment lifetime</code>的缩写，意为最长报文寿命。这个时间由官方RFC协议规定。</blockquote><h3 id=3-3-4、若已经建立连接，但客户端突然出现故障，那如何解决？><a class=headerlink href=#3-3-4、若已经建立连接，但客户端突然出现故障，那如何解决？ title=3.3.4、若已经建立连接，但客户端突然出现故障，那如何解决？></a>3.3.4、若已经建立连接，但客户端突然出现故障，那如何解决？</h3><p><strong>因TCP有⼀个保活计时器，故客户端出现故障时不会导致服务器⼀直等下去</strong>。<p>服务器每次收到客户端请求后都会重新复位计时器，时间通常为2⼩时，若两⼩时后依然没有收到客户端任何数据，则服务器就会发送探测报⽂段来进行判断。以每75秒发送⼀次连续发送10次后依然无响应，则服务器就会认为客户端出了故障，然后关闭连接。<h1 id=4、TCP可靠传输><a class=headerlink href=#4、TCP可靠传输 title=4、TCP可靠传输></a>4、TCP可靠传输</h1><p><strong>TCP 是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输</strong>。<h2 id=4-1、重传机制><a class=headerlink href=#4-1、重传机制 title=4.1、重传机制></a>4.1、重传机制</h2><p><strong>TCP 实现 可靠传输 的⽅式之⼀就是 通过序列号与确认应答</strong>。<p>TCP传输中，主机B在收到主机A的请求后会发送响应给主机A。<p><img alt=image-20210417191856726 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417191856726.png?token=AIGEF3JFZ4N7DOLCPI6YDITEZZSL4><p>在错综复杂的⽹络中，顺利进行数据传输是不一定成立的，所以<strong>TCP 针对数据包丢失的情况，会⽤重传机制解决</strong>。<p>常⻅重传机制有：<ol><li>超时重传<li>快速重传<li>SACK<li>D-SACK</ol><h3 id=5-1-1、超时重传><a class=headerlink href=#5-1-1、超时重传 title=5.1.1、超时重传></a>5.1.1、超时重传</h3><h4 id=何为超时重传><a class=headerlink href=#何为超时重传 title=何为超时重传></a>何为超时重传</h4><p><strong>发送数据时设定⼀个定时器，当超过指定时间还没有收到对⽅ ACK 确认应答报⽂时就重发该数据，也就是我们常说的超时重传</strong>。<h4 id=触发超时重传><a class=headerlink href=#触发超时重传 title=触发超时重传></a>触发超时重传</h4><p>TCP 会在以下两种情况中 执行 超时重传操作：<ol><li>数据包丢失<li>确认应答丢失</ol><p><img alt=image-20230805230506940 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805230506940.png?token=AIGEF3NDN664QOJTSGLSWZ3EZZSWA><h4 id=设置超时时间><a class=headerlink href=#设置超时时间 title=设置超时时间></a>设置超时时间</h4><p>何为RTT（Round-Trip Time 往返时延），可从下图中找到答案：<p><img alt=image-20210417192532442 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417192532442.png?token=AIGEF3OWNFJJ37OTKLX7PSTEZZSQW><p><strong>RTT 就是数据从⽹络⼀端传送到另⼀端所需的时间，也就是包的往返时间</strong>。<p>超时重传时间会以 RTO （Retransmission Timeout 超时重传时间）表示。<p>重传环境下，超时时间 RTO 较⻓或较短时，会发⽣什么？<p><img alt=image-20210417192649183 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417192649183.png?token=AIGEF3N7O4DGC7GNOHFY3ZDEZZSXE><p>上图中有两种超时时间不同的情况：<ul><li>当超时时间 RTO 较⼤时，重发就慢，丢了⽼半天才重发，没有效率，性能差；<li>当超时时间 RTO 较⼩时，会导致可能并没有丢就重发，于是重发就快，会增加⽹络拥塞，导致 更多超时，更多超时导致更多重发。</ul><p>精确的测量超时时间 RTO 的值是⾮常重要的，这可让我们的重传机制更⾼效。<p>根据上述的两种情况可得知：<strong>超时重传时间 RTO 的值应该略⼤于报⽂往返 RTT 的值</strong>。<p><img alt=image-20210417192824629 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417192824629.png?token=AIGEF3NGIFIJ6IYJR26U4ITEZZSYA><p>⾄此，可能⼤家觉得超时᯿传时间 RTO 的值计算，也不是很复杂嘛。<p>好像就是在发送端发包时记下 t0 ，然后接收端再把这个 ack 回来时再记⼀个 t1 ，于是 RTT = t1 – t0 。没那么简单，这只是⼀个采样，不能代表普遍情况。<p>实际上「报⽂往返 RTT 的值」是经常变化的，因为我们的⽹络也是时常变化的。也就因为「报⽂往返 RTT 的值」 是经常波动变化的，所以「超时᯿传时间 RTO 的值」应该是⼀个动态变化的值。<p>我们来看看 Linux 是如何计算 RTO 的呢？<p>计算往返时间，需要参考如下两项：<ol><li>TCP 通过采样 RTT 时间，然后进⾏加权平均，算出⼀个平滑 RTT 值，⽽且该值还是要 不断变化的，因为⽹络状况不断地变化。<li>除了采样 RTT，还要采样 RTT 的波动范围，这样就避免了 RTT 若有⼀个⼤波动的话，就会很难被发现的情况。</ol><p>RFC6289 建议使⽤以下的公式计算 RTO：<p><img alt=image-20210417192939108 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417192939108.png?token=AIGEF3MC6M5ADE6ZJVKFGVLEZZSZM><p>其中，SRTT 是计算平滑RTT ， DevRTR 是计算平滑RTT 与 最新 RTT 的差距。<p>在 Linux 下，α = 0.125，β = 0.25， μ = 1，∂ = 4。别问怎么来的，问就是⼤量实验中调出来的。<p><strong>如果超时重发的数据再次超时且⼜需要重传时，TCP 的策略是超时间加倍</strong>。<p>也就是每当遇到⼀次超时重传的时候，都会将下⼀次超时时间间隔设为先前值的两倍。两次超时，就说明⽹络环境差，不宜频繁反复发送。<p>超时重传存在的问题是，超时周期可能相对较⻓。那是不是有更快的⽅式呢？<p>于是就可以⽤「快速重传」机制来解决超时重发的时间等待。<h3 id=5-1-2、快速重传><a class=headerlink href=#5-1-2、快速重传 title=5.1.2、快速重传></a>5.1.2、快速重传</h3><p><strong>快速重传（Fast Retransmit）机制不以时间为驱动，⽽是以数据驱动重传</strong>。<p>快速重传机制，是如何⼯作的呢？其实很简单，⼀图胜千⾔。<p><img alt=image-20210417232739572 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417232739572.png?token=AIGEF3LMMC7SAUWHAW4ESDLEZZS2Q><p>在上图，发送⽅发出了 1，2，3，4，5 份数据：<ol><li>第⼀份 Seq1 先送到了，于是就 Ack 回 2；<li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；<li>后⾯的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；<li>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失 的 Seq2。<li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</ol><p>所以， 快速重传的⼯作⽅式是当收到三个相同 ACK 报⽂时，会在定时器过期之前重传丢失的报⽂段。<p><strong>快速重传机制只解决了超时时间问题，还有重传一个还是重传所有的问题</strong>。<p>⽐如对于上⾯的例⼦，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清 楚这连续的三个 Ack 2 是谁传回来的。<p>因为TCP的不同实现，故以上两种情况都有可能发生。这是⼀把双刃剑。<p><strong>通过 SACK ⽅法可以解决 到底该重传哪些 TCP 报⽂的问题</strong>。<h3 id=5-1-3、SACK><a class=headerlink href=#5-1-3、SACK title=5.1.3、SACK></a>5.1.3、SACK</h3><p><strong>SACK （ Selective Acknowledgment 选择性确认）需要在 TCP 头部「选项」字段中加⼀个 SACK，它可以将缓存的地图送给发送⽅， 发送方可根据该地图来判断哪些收到了哪些没有收到，然后只重发那些没有收到的</strong>。<p>如下图，发送⽅收到了三次同样的 ACK 确认报⽂，于是就会触发快速重发机制，通过 SACK 信息发现 只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进⾏重复。<p><img alt=image-20210417233420965 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417233420965.png?token=AIGEF3OFM47VCTUWQ2PHFSLEZZS3W><p>如果要⽀持 SACK ，必须双⽅都要⽀持。Linux下可通过 net.ipv4.tcp_sack 参数打开这个功能（Linux 2.4 后默认打开）。<h3 id=5-1-4、D-SACK><a class=headerlink href=#5-1-4、D-SACK title=5.1.4、D-SACK></a>5.1.4、D-SACK</h3><p><strong>Duplicate SACK ⼜称 D-SACK ，主要通过 SACK 来告诉「发送⽅」哪些数据被重复接收了</strong>。<p>下⾯举两个栗⼦，来说明 D-SACK 的作⽤。<p><strong>栗⼦⼀号：ACK 丢包</strong><p><img alt=image-20210417233640884 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417233640884.png?token=AIGEF3N7ZKU5MFNTOKTN77TEZZS4W><ul><li>「接收⽅」发给「发送⽅」的两个 ACK 确认应答都丢失了，所以发送⽅超时后，᯿传第⼀个数据 包（3000 ~ 3499）<li>于是「接收⽅」发现数据是重复收到的，于是回了⼀个 SACK = 3000<del>3500，告诉「发送⽅」 3000</del>3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都 已收到，所以这个 SACK 就代表着 D-SACK 。<li>这样「发送⽅」就知道了，数据没有丢，是「接收⽅」的 ACK 确认报⽂丢了。</ul><p><strong>栗子二号：网络延时</strong><p><img alt=image-20210417233800922 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417233800922.png?token=AIGEF3PO4B6SO3FWJ7PH7ZLEZZS7G><ul><li>数据包（1000~1499） 被⽹络延迟了，导致「发送⽅」没有收到 Ack 1500 的确认报⽂。<li>⽽后⾯报⽂到达的三个相同的 ACK 确认报⽂，就触发了快速᯿传机制，但是在᯿传后，被延迟的 数据包（1000~1499）⼜到了「接收⽅」；<li>所以「接收⽅」回了⼀个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 DSACK，表示收到了重复的包。<li>这样发送⽅就知道快速᯿传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，⽽ 是因为⽹络延迟了。</ul><p>可⻅， D-SACK 有这么⼏个好处：<ol><li>可以让「发送⽅」知道，是发出去的包丢了，还是接收⽅回应的 ACK 包丢了；<li>可以知道是不是「发送⽅」的数据包被⽹络延迟了；<li>可以知道⽹络中是不是把「发送⽅」的数据包给复制了;</ol><p><strong>Linux 下可通过参数 net.ipv4.tcp_dsack 开启/关闭这个功能（Linux 2.4 后默认打开）</strong>。<h2 id=4-2、滑动窗口><a class=headerlink href=#4-2、滑动窗口 title=4.2、滑动窗口></a>4.2、滑动窗口</h2><h3 id=4-2-1、窗口作用><a class=headerlink href=#4-2-1、窗口作用 title=4.2.1、窗口作用></a>4.2.1、窗口作用</h3><p>我们都知道 TCP 每发送⼀个数据，都要进⾏⼀次确认应答。当上⼀个数据包收到了应答， 再发送下⼀个。<p><img alt=image-20210417234245342 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417234245342.png?token=AIGEF3LJEO3GN6F43A5XBSTEZZTAU><p>所以，这样的传输⽅式有⼀个缺点：数据包的往返时间越⻓，通信的效率就越低。<p>为解决这个问题，TCP 引⼊了窗⼝这个概念。<p>有了窗⼝，就可以指定窗⼝⼤⼩。窗⼝⼤⼩是指：⽆需等待确认应答就可以继续发送数据的最⼤值。<p><strong>窗⼝的实现实际上是操作系统开辟的⼀个缓存空间，发送⽅主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除</strong>。<p>假设窗⼝⼤⼩为 3 个 TCP 段，那么发送⽅就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下⼀个确认应答进⾏确认」。如下图：<p><img alt=image-20210417234516493 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417234516493.png?token=AIGEF3LNHDRZTZB6B3XLCOTEZZTCG><p>图中的 ACK 600 确认应答报⽂丢失，也没关系，因为可以通过下⼀个确认应答进⾏确认，只要发送⽅ 收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收⽅」都收到了。这个模式就叫累计确认或者累计应答。<h3 id=4-2-2、窗口大小谁来决定><a class=headerlink href=#4-2-2、窗口大小谁来决定 title=4.2.2、窗口大小谁来决定></a>4.2.2、窗口大小谁来决定</h3><p>TCP 头⾥有⼀个字段叫 Window ，也就是窗⼝⼤⼩。 这个字段是接收端告诉发送端⾃⼰还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能⼒来发送数据，⽽不会导致接收端处理不过来。 所以，<strong>通常窗⼝的⼤⼩是由接收⽅窗⼝⼤⼩来决定的</strong>。发送⽅发送的数据⼤⼩不能超过接收⽅的窗⼝⼤⼩，否则接收⽅就⽆法正常接收到数据。<h3 id=4-2-3、发送方窗口><a class=headerlink href=#4-2-3、发送方窗口 title=4.2.3、发送方窗口></a>4.2.3、发送方窗口</h3><p>我们先来看看发送⽅窗⼝，下图就是发送⽅缓存数据，根据处理的情况分成四个部分，其中 深蓝⾊⽅框 是发送窗⼝，紫⾊⽅框是可⽤窗⼝：<p><img alt=image-20210417234958826 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417234958826.png?token=AIGEF3JMC6ZT7FSRXEKBN53EZZTD2><ul><li>#1 是已发送并收到 ACK确认的数据：1~31 字节。<li>#2 是已发送但未收到 ACK确认的数据：32~45 字节。<li>#3 是未发送但总⼤⼩在接收⽅处理范围内（接收⽅还有空间）：46~51字节。<li>#4 是未发送但总⼤⼩超过接收⽅处理范围（接收⽅没有空间）：52字节以后。</ul><p>在下图，当发送⽅把数据「全部」都⼀下发送出去后，可⽤窗⼝的⼤⼩就为 0 了，表明可⽤窗⼝耗尽， 在没收到 ACK 确认之前是⽆法继续发送数据了。<p><img alt=image-20210417235253264 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417235253264.png?token=AIGEF3IUVHCAKAB25MIWCRLEZZTE4><p>在下图，当收到之前发送的数据 32<del>36 字节的 ACK 确认应答后，如果发送窗⼝的⼤⼩没有变化，则 滑动窗⼝往右边移动 5 个字节，因为有 5 个字节的数据被应答确认，接下来 52</del>56 字节⼜变成了可⽤ 窗⼝，那么后续也就可以发送 52~56 这 5 个字节的数据了。<p><img alt=image-20210417235319675 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417235319675.png?token=AIGEF3OPAGFASP2EYLYQ53LEZZTF2><p><strong>程序如何表示发送方四个部分呢？</strong><p>TCP 滑动窗⼝⽅案使⽤三个指针来跟踪在四个传输类别中的每⼀个类别中的字节。其中两个指针是绝对 指针（指特定的序列号），⼀个是相对指针（需要做偏移）。<p><img alt=image-20230805102056836 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805102056836.png?token=AIGEF3N2GDJ5NWRU4F4XQYDEZZTIE><ul><li>SND.WND ：表示发送窗⼝的⼤⼩（⼤⼩是由接收⽅指定的）；<li>SND.UNA ：是⼀个绝对指针，它指向的是已发送但未收到确认的第⼀个字节的序列号，也就是 #2 的第⼀个字节。<li>SND.NXT ：也是⼀个绝对指针，它指向未发送但可发送范围的第⼀个字节的序列号，也就是 #3 的 第⼀个字节。<li>指向 #4 的第⼀个字节是个相对指针，它需要 SND.UNA 指针加上 SND.WND ⼤⼩的偏移量，就可以 指向 #4 的第⼀个字节了。</ul><p>那么可⽤窗⼝⼤⼩的计算公式就是： <code>可⽤窗⼝⼤ = SND.WND -（SND.NXT - SND.UNA）</code>。<h3 id=4-2-4、接收方窗口><a class=headerlink href=#4-2-4、接收方窗口 title=4.2.4、接收方窗口></a>4.2.4、接收方窗口</h3><p>接下来我们看看接收⽅窗⼝，接收窗⼝相对简单⼀些，根据处理情况分成三个部分：<ul><li>#1 + #2 是已成功接收并确认的数据（等待应⽤进程读取）；<li>#3 是未收到数据但可以接收的数据；<li>#4 未收到数据并不可以接收的数据；</ul><p><img alt=image-20210417235921203 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417235921203.png?token=AIGEF3I6C25RFPERRQ7TVFTEZZTJY><p>其中三个接收部分，使⽤两个指针进⾏划分：<ul><li>RCV.WND 表示接收窗⼝的⼤⼩，它会通告给发送⽅。<li>RCV.NXT ：是⼀个指针，它指向期望从发送⽅发送来的下⼀个数据字节的序列号，也就是 #3 的第 ⼀个字节。<li>指向 #4 的第⼀个字节是个相对指针，它需要 RCV.NXT 指针加上 RCV.WND ⼤⼩的偏移量，就可以指向 #4 的第⼀个字节了。</ul><p>接收窗口和发送窗口大小一样吗？<p>并不是完全相等，<strong>接收窗⼝⼤⼩ 约等于 发送窗⼝⼤⼩</strong>。<p>因为滑动窗⼝并不是⼀成不变的。⽐如，当接收⽅的应⽤进程读取数据的速度⾮常快的话，接收窗⼝可以很快的腾出空闲空间。那么新的接收窗⼝⼤⼩，是通过 TCP 报⽂中的 Windows 字段来告诉发送⽅。那么这个传输过程是存在时延的，所以接收窗⼝的大小和发送窗⼝是约等于的关系。<h2 id=4-3、流量控制><a class=headerlink href=#4-3、流量控制 title=4.3、流量控制></a>4.3、流量控制</h2><h3 id=4-3-1、流量控制来源><a class=headerlink href=#4-3-1、流量控制来源 title=4.3.1、流量控制来源></a>4.3.1、流量控制来源</h3><p>发送⽅不能⽆脑的发数据给接收⽅，要考虑接收⽅处理能⼒。<p>如果⼀直⽆脑的发数据给对⽅，但对⽅处理不过来，那么就会导致触发重发机制，从⽽导致⽹络流量的⽆端的浪费。<p>为了解决这种现象发⽣，<strong>TCP 提供⼀种机制可以让「发送⽅」根据「接收⽅」的实际接收能⼒ 控制发送的数据量，这就是流量控制</strong>。<p>下⾯举个栗⼦，为了简单起⻅，假设以下场景：<ul><li>客户端是接收⽅，服务端是发送⽅。<li>假设接收窗⼝和发送窗⼝相同，都为 200。<li>假设两个设备在整个传输过程中都保持相同的窗⼝⼤⼩，不受外界影响。</ul><p><img alt=image-20210418180447932 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418180447932.png?token=AIGEF3P3HVCKSTZZK3AUCBDEZZTLM><p><img alt=image-20210418180514513 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418180514513.png?token=AIGEF3IXPTYRPDYKT6VPVDDEZZTM4><p>根据上图的流量控制，说明下每个过程：<ol><li>客户端向服务端发送请求数据报⽂。这⾥要说明下，本次例⼦是把服务端作为发送⽅，所以没有画 出服务端的接收窗⼝。<li>服务端收到请求报⽂后，发送确认报⽂和 80 字节的数据，于是可⽤窗⼝ Usable 减少为 120 字 节，同时 SND.NXT 指针也向右偏移 80 字节后，指向 321，这意味着下次发送数据的时候，序列号 是 321。<li>客户端收到 80 字节数据后，于是接收窗⼝往右移动 80 字节， RCV.NXT 也就指向 321，这意味着 客户端期望的下⼀个报⽂的序列号是 321，接着发送确认报⽂给服务端。<li>服务端再次发送了 120 字节数据，于是可⽤窗⼝耗尽为 0，服务端⽆法再继续发送数据。<li>客户端收到 120 字节的数据后，于是接收窗⼝往右移动 120 字节， RCV.NXT 也就指向 441，接着 发送确认报⽂给服务端。<li>服务端收到对 80 字节数据的确认报⽂后， SND.UNA 指针往右偏移后指向 321，于是可⽤窗⼝ Usable 增⼤到 80。<li>服务端收到对 120 字节数据的确认报⽂后， SND.UNA 指针往右偏移后指向 441，于是可⽤窗⼝ Usable 增⼤到 200。<li>服务端可以继续发送了，于是发送了 160 字节的数据后， SND.NXT 指向 601，于是可⽤窗⼝ Usable 减少到 40。<li>客户端收到 160 字节后，接收窗⼝往右移动了 160 字节， RCV.NXT 也就是指向了 601，接着发送 确认报⽂给服务端。<li>服务端收到对 160 字节数据的确认报⽂后，发送窗⼝往右移动了 160 字节，于是 SND.UNA 指针偏 移了 160 后指向 601，可⽤窗⼝ Usable 也就增⼤⾄了 200。</ol><h3 id=4-3-2、操作系统缓冲区与滑动窗口的关系><a class=headerlink href=#4-3-2、操作系统缓冲区与滑动窗口的关系 title=4.3.2、操作系统缓冲区与滑动窗口的关系></a>4.3.2、操作系统缓冲区与滑动窗口的关系</h3><p>假定了发送窗⼝和接收窗⼝是不变的，但实际上，发送窗⼝和接收窗⼝中所存放的字节数，都是放在操作系统内存缓冲区中，⽽操作系统的缓冲区，会被操作系统调整。<p>当应⽤进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响。<h4 id=4-3-2-1、缓冲区如何响应发送-接收窗口><a class=headerlink href=#4-3-2-1、缓冲区如何响应发送-接收窗口 title=4.3.2.1、缓冲区如何响应发送/接收窗口></a>4.3.2.1、缓冲区如何响应发送/接收窗口</h4><p><strong>例⼦一</strong><p>当应⽤程序没有及时读取缓存时，发送窗⼝和接收窗⼝的变化。<p>考虑以下场景：<ul><li>客户端作为发送⽅，服务端作为接收⽅，发送窗⼝和接收窗⼝初始⼤⼩为 360 ；<li>服务端⾮常的繁忙，当收到客户端的数据时，应⽤层不能及时读取数据。</ul><p><img alt=image-20210418181534600 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418181534600.png?token=AIGEF3OZCRTI7FAGMHYAVKDEZZTOG><p>根据上图的流量控制，说明下每个过程：<ol><li>客户端发送 140 字节数据后，可⽤窗⼝变为 220 （360 - 140）。<li>服务端收到 140 字节数据，但是服务端⾮常繁忙，应⽤进程只读取了 40 个字节，还有 100 字节占 ⽤着缓冲区，于是接收窗⼝收缩到了 260 （360 - 100），最后发送确认信息时，将窗⼝⼤⼩通告 给客户端。<li>客户端收到确认和窗⼝通告报⽂后，发送窗⼝减少为 260。<li>客户端发送 180 字节数据，此时可⽤窗⼝减少到 80。<li>服务端收到 180 字节数据，但是应⽤程序没有读取任何数据，这 180 字节直接就留在了缓冲区，于 是接收窗⼝收缩到了 80 （260 - 180），并在发送确认信息时，通过窗⼝⼤⼩给客户端。<li>客户端收到确认和窗⼝通告报⽂后，发送窗⼝减少为 80。<li>客户端发送 80 字节数据后，可⽤窗⼝耗尽。<li>服务端收到 80 字节数据，但是应⽤程序依然没有读取任何数据，这 80 字节留在了缓冲区，于是接 收窗⼝收缩到了 0，并在发送确认信息时，通过窗⼝⼤⼩给客户端。<li>客户端收到确认和窗⼝通告报⽂后，发送窗⼝减少为 0。</ol><p>可⻅最后窗⼝都收缩为 0 了，也就是发⽣了窗⼝关闭。当发送⽅可⽤窗⼝变为 0 时，发送⽅实际上会定 时发送窗⼝探测报⽂，以便知道接收⽅的窗⼝是否发⽣了改变，这个内容后⾯会说，这⾥先简单提⼀ 下。<p><strong>例⼦二</strong><p>当服务端系统资源⾮常紧张的时候，操⼼系统可能会直接减少了接收缓冲区⼤⼩，这时应⽤程序⼜⽆法 及时读取缓存数据，那么这时候就有严᯿的事情发⽣了，会出现数据包丢失的现象<p><img alt=image-20210418181843933 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418181843933.png?token=AIGEF3PA4IMXWL5XUJHRXR3EZZTPO><p>说明下每个过程：<ol><li>客户端发送 140 字节的数据，于是可⽤窗⼝减少到了 220。<li>服务端因为现在⾮常的繁忙，操作系统于是就把接收缓存减少了 120 字节，当收到 140 字节数据 后，⼜因为应⽤程序没有读取任何数据，所以 140 字节留在了缓冲区中，于是接收窗⼝⼤⼩从 360 收缩成了 100，最后发送确认信息时，通告窗⼝⼤⼩给对⽅。<li>此时客户端因为还没有收到服务端的通告窗⼝报⽂，所以不知道此时接收窗⼝收缩成了 100，客户 端只会看⾃⼰的可⽤窗⼝还有 220，所以客户端就发送了 180 字节数据，于是可⽤窗⼝减少到 40。<li>服务端收到了 180 字节数据时，发现数据⼤⼩超过了接收窗⼝的⼤⼩，于是就把数据包丢失了。<li>客户端收到第 2 步时，服务端发送的确认报⽂和通告窗⼝报⽂，尝试减少发送窗⼝到 100，把窗⼝ 的右端向左收缩了 80，此时可⽤窗⼝的⼤⼩就会出现诡异的负值。</ol><p>所以，如果发⽣了先减少缓存，再收缩窗⼝，就会出现丢包的现象。<p>为了防⽌这种情况发⽣，TCP 规定是不允许同时减少缓存⼜收缩窗⼝的，⽽是采⽤先收缩窗⼝，过段时 间再减少缓存，这样就可以避免了丢包情况。<h3 id=4-3-3、窗口关闭><a class=headerlink href=#4-3-3、窗口关闭 title=4.3.3、窗口关闭></a>4.3.3、窗口关闭</h3><p>在前⾯我们都看到了，TCP 通过让接收⽅指明希望从发送⽅接收的数据⼤⼩（窗⼝⼤⼩）来进⾏流量控制。<p><strong>窗⼝⼤⼩为 0 时，就会阻⽌发送⽅给接收⽅传递数据，直到窗⼝变为⾮ 0 为⽌，这就是窗⼝关闭</strong>。<h4 id=5-3-3-1、窗口关闭潜在危险><a class=headerlink href=#5-3-3-1、窗口关闭潜在危险 title=5.3.3.1、窗口关闭潜在危险></a>5.3.3.1、窗口关闭潜在危险</h4><p><strong>接收⽅通过 ACK 报⽂来向发送⽅通告窗⼝⼤⼩</strong>。<p>当发⽣窗⼝关闭时，接收⽅处理完数据后会向发送⽅通告⼀个窗⼝⾮ 0 的 ACK 报⽂，如果这个通告窗⼝的 ACK 报⽂在⽹络中丢失了，那麻烦就⼤了。<p><img alt=image-20210418182234840 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418182234840.png?token=AIGEF3NARXVMDYNKWI25NNLEZZTQQ><p>这会导致发送⽅⼀直等待接收⽅的⾮ 0 窗⼝通知，接收⽅也⼀直等待发送⽅的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。<h4 id=5-3-3-2、如何解决窗口关闭时的死锁现象><a class=headerlink href=#5-3-3-2、如何解决窗口关闭时的死锁现象 title=5.3.3.2、如何解决窗口关闭时的死锁现象></a>5.3.3.2、如何解决窗口关闭时的死锁现象</h4><p>为了解决这个问题，TCP 为每个连接设有⼀个持续定时器，只要 TCP 连接⼀⽅收到对⽅的零窗⼝通知，就启动持续计时器。如果持续计时器超时，就会发送窗⼝探测 ( Window probe ) 报⽂，⽽对⽅在确认这个探测报⽂时，给出⾃⼰现在的接收窗⼝⼤⼩。<p><img alt=image-20210418182508676 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418182508676.png?token=AIGEF3JXO2IAKFUPH5NXLZ3EZZTRY><ul><li>如果接收窗⼝仍然为 0，那么收到这个报⽂的⼀⽅就会᯿新启动持续计时器；<li>如果接收窗⼝不是 0，那么死锁的局⾯就可以被打破了。</ul><p><strong>窗⼝探测的次数⼀般为 3 次，每次⼤约 30-60 秒（不同的实现可能会不⼀样）。如果 3 次过后接收窗⼝还是 0 的话，有的 TCP 实现就会发 RST 报⽂来中断连接</strong>。<h3 id=5-3-4、糊涂窗口综合症><a class=headerlink href=#5-3-4、糊涂窗口综合症 title=5.3.4、糊涂窗口综合症></a>5.3.4、糊涂窗口综合症</h3><p>如果接收⽅太忙了，来不及取⾛接收窗⼝⾥的数据，那么就会导致发送⽅的发送窗⼝越来越⼩。<p>到最后，如果接收⽅腾出⼏个字节并告诉发送⽅现在有⼏个字节的窗⼝，⽽发送⽅会义⽆反顾地发送这⼏个字节，这就是糊涂窗⼝综合症。<p>要知道，我们的 TCP + IP 头有 40 个字节，为了传输那⼏个字节的数据，要达上这么⼤的开销，这太不经济了。<p>就好像⼀个可以承载 50 ⼈的⼤巴⻋，每次来了⼀两个⼈，就直接发⻋。除⾮家⾥有矿的⼤巴司机，才敢这样玩，不然迟早破产。要解决这个问题也不难，⼤巴司机等乘客数量超过了 25 个，才认定可以发车。<p>现举个糊涂窗⼝综合症的栗⼦，考虑以下场景：<p>接收⽅的窗⼝⼤⼩是 360 字节，但接收⽅由于某些原因陷⼊困境，假设接收⽅的应⽤层读取的能⼒如下：<ul><li>接收⽅每接收 3 个字节，应⽤程序就只能从缓冲区中读取 1 个字节的数据；<li>在下⼀个发送⽅的 TCP 段到达之前，应⽤程序还从缓冲区中读取了 40 个额外的字节；</ul><p><img alt=image-20210418182907615 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418182907615.png?token=AIGEF3J5YB22J346SPF5US3EZZTTK><p>每个过程的窗⼝⼤⼩的变化，在图中都描述的很清楚了，可以发现窗⼝不断减少了，并且发送的数据都 是⽐较⼩的了。<p>所以，糊涂窗⼝综合症的现象是可以发⽣在发送⽅和接收⽅：<ul><li>接收⽅可以通告⼀个⼩的窗⼝。<li>⽽发送⽅可以发送⼩数据。</ul><p>于是，要解决糊涂窗⼝综合症，就解决上⾯两个问题就可以了<ul><li>让接收⽅不通告⼩窗⼝给发送⽅。<li>让发送⽅避免发送⼩数据。</ul><h4 id=5-3-4-1、如何让接收方不通告小窗口><a class=headerlink href=#5-3-4-1、如何让接收方不通告小窗口 title=5.3.4.1、如何让接收方不通告小窗口></a>5.3.4.1、如何让接收方不通告小窗口</h4><p>接收⽅通常的策略如下：<p><strong>当「窗⼝⼤⼩」⼩于 min( MSS，缓存空间/2 ) ，也就是⼩于 MSS 与 1/2 缓存⼤⼩中的最⼩值时，就会向发送⽅通告窗⼝为 0 ，也就阻⽌了发送⽅再发数据过来</strong>。<p>等到接收⽅处理了⼀些数据后，窗⼝⼤⼩ >= MSS，或者接收⽅缓存空间有⼀半可以使⽤，就可以把窗⼝打开让发送⽅发送数据过来。<h4 id=5-3-4-2、如何让发送方避免发送小数据><a class=headerlink href=#5-3-4-2、如何让发送方避免发送小数据 title=5.3.4.2、如何让发送方避免发送小数据></a>5.3.4.2、如何让发送方避免发送小数据</h4><p>发送⽅通常的策略：<p><strong>使⽤ Nagle 算法，该算法的思路是延时处理，它满⾜以下两个条件中的⼀条才可以发送数据</strong>：<ul><li>要等到窗⼝⼤⼩ >= MSS 或是数据⼤⼩ >= MSS<li>收到之前发送数据的 ack 回包</ul><p><strong>只要没满⾜上⾯条件中的⼀条，发送⽅⼀直在囤积数据，直到满⾜上⾯的发送条件</strong>。<p>另外，<strong>Nagle 算法默认打开</strong>，如果对于⼀些需要⼩数据包交互的场景的程序，⽐如，telnet 或 ssh 这样的交互性⽐较强的程序，则需要关闭 Nagle 算法。<p>可以在 Socket 设置 TCP_NODELAY 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每 个应⽤⾃⼰的特点来关闭）<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (<span class=type>char</span> *)&value, sizeof(<span class=type>int</span>));</span><br></pre></table></figure><h2 id=4-4、拥塞控制><a class=headerlink href=#4-4、拥塞控制 title=4.4、拥塞控制></a>4.4、拥塞控制</h2><h3 id=4-4-1、简介><a class=headerlink href=#4-4-1、简介 title=4.4.1、简介></a>4.4.1、简介</h3><h4 id=4-4-1-1、为何需要拥塞控制><a class=headerlink href=#4-4-1-1、为何需要拥塞控制 title=4.4.1.1、为何需要拥塞控制></a>4.4.1.1、为何需要拥塞控制</h4><p>前⾯的流量控制是避免「发送⽅」的数据填满「接收⽅」的缓存，但是并不知道⽹络中发⽣了什么。<p>⼀般来说，计算机⽹络都处在⼀个共享的环境。因此也有可能会因为其他主机之间的通信使得⽹络拥堵。<p>在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传 数据，但是⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进 ⼊恶性循环被不断地放⼤…. 。<p>所以，TCP 不能忽略⽹络中发⽣的事，它被设计成⼀个⽆私的协议，当⽹络发送拥塞时，TCP 会⾃我 牺牲，降低发送的数据量。<p>于是，就有了<strong>拥塞控制，控制的⽬的就是避免「发送⽅」的数据填满整个⽹络</strong>。<p><strong>为了调节「发送⽅」所要发送数据的量，定义了⼀个叫做「拥塞窗⼝」的概念</strong>。<h4 id=4-4-1-2、何为拥塞窗口，与发送窗口有啥关系？><a class=headerlink href=#4-4-1-2、何为拥塞窗口，与发送窗口有啥关系？ title=4.4.1.2、何为拥塞窗口，与发送窗口有啥关系？></a>4.4.1.2、何为拥塞窗口，与发送窗口有啥关系？</h4><p>拥塞窗⼝ cwnd是发送⽅维护的⼀个状态变量，它会根据⽹络的拥塞程度动态变化。<p>我们在前⾯提到过发送窗⼝ swnd 和接收窗⼝ rwnd 是约等于的关系，那么加⼊拥塞窗⼝的概念后，此时发送窗⼝的值是swnd = min(cwnd, rwnd)，也就是拥塞窗⼝和接收窗⼝中的最⼩值。<p>拥塞窗⼝ cwnd 变化规则：<ul><li>⽹络中没有出现拥塞， cwnd 就会增⼤；<li>⽹络中出现了拥塞， cwnd 就减少；</ul><h4 id=4-4-1-3、如何判断网络拥塞了？><a class=headerlink href=#4-4-1-3、如何判断网络拥塞了？ title=4.4.1.3、如何判断网络拥塞了？></a>4.4.1.3、如何判断网络拥塞了？</h4><p><strong>只要「发送⽅」没有在规定时间内接收到 ACK 应答报⽂，也就是发⽣了超时重传，就会认为⽹络出现了拥塞</strong>。<h4 id=4-4-1-4、拥塞控制算法><a class=headerlink href=#4-4-1-4、拥塞控制算法 title=4.4.1.4、拥塞控制算法></a>4.4.1.4、拥塞控制算法</h4><p>拥塞控制主要四个算法：<ol><li>慢启动<li>拥塞避免<li>拥塞发⽣<li>快速恢复</ol><h3 id=4-4-2、慢启动><a class=headerlink href=#4-4-2、慢启动 title=4.4.2、慢启动></a>4.4.2、慢启动</h3><p><strong>TCP 在刚建⽴连接完成后，⾸先有个慢启动过程，这个慢启动意思就是⼀点⼀点提⾼发送数据包的数量</strong>。如果⼀上来就发⼤量的数据，这不是给⽹络添堵吗？<p><strong>慢启动算法记住⼀个规则就⾏：当发送⽅每收到⼀个 ACK，拥塞窗⼝ cwnd 的⼤⼩就会加 1</strong>。<p>这⾥假定拥塞窗⼝ cwnd 和发送窗⼝ swnd 相等，下⾯举个栗⼦：<ul><li>连接建⽴完成后，⼀开始初始化 cwnd = 1 ，表示可以传⼀个 MSS ⼤⼩的数据。<li>当收到⼀个 ACK 确认应答后，cwnd 增加 1，于是⼀次能够发送 2 个<li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以⽐之前多发2 个，所以这⼀次能够发送 4 个<li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以⽐ 之前多发 4 个，所以这⼀次能够发送 8 个。</ul><p><img alt=image-20210418184842512 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418184842512.png?token=AIGEF3OVHEKLN4G5UWD33ODEZZTVQ><p>可以看出慢启动算法，发包的个数是指数性的增⻓。<h4 id=4-4-2-1、慢启动涨到什么时候结束><a class=headerlink href=#4-4-2-1、慢启动涨到什么时候结束 title=4.4.2.1、慢启动涨到什么时候结束></a>4.4.2.1、慢启动涨到什么时候结束</h4><p>有⼀个叫慢启动⻔限 ssthresh （slow start threshold）状态变量。<ul><li>当 cwnd < ssthresh 时，使⽤慢启动算法。<li>当 cwnd >= ssthresh 时，就会使⽤「拥塞避免算法」。</ul><h3 id=4-4-3、拥塞避免算法><a class=headerlink href=#4-4-3、拥塞避免算法 title=4.4.3、拥塞避免算法></a>4.4.3、拥塞避免算法</h3><p>前⾯说道，当拥塞窗⼝ cwnd 「超过」慢启动⻔限 ssthresh 就会进⼊拥塞避免算法。<p>⼀般来说 ssthresh 的⼤⼩是 65535 字节。<p>那么进⼊拥塞避免算法后，它的规则是：每当收到⼀个 ACK 时，cwnd 增加 1/cwnd。<p>接上前⾯的慢启动的栗⼦，现假定 ssthresh 为 8 ：<ul><li>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd ⼀共增加 1，于是这⼀次 能够发送 9 个 MSS ⼤⼩的数据，变成了线性增⻓。</ul><p><img alt=image-20210418190150299 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418190150299.png?token=AIGEF3KSEBJ2ISXTJSHR5ODEZZTWQ><p>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增⻓变成了线性增⻓，还是增⻓阶 段，但是增⻓速度缓慢了⼀些。<p>就这么⼀直增⻓着后，⽹络就会慢慢进⼊了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失 的数据包进⾏᯿传。<p>当触发了重传机制，也就进⼊了「拥塞发⽣算法」<h3 id=4-4-4、拥塞发生><a class=headerlink href=#4-4-4、拥塞发生 title=4.4.4、拥塞发生></a>4.4.4、拥塞发生</h3><p>当⽹络出现拥塞，也就是会发⽣数据包᯿传，重传机制主要有两种：<ul><li>超时重传<li>快速重传</ul><h4 id=4-4-4-1、超时重传拥塞发生算法><a class=headerlink href=#4-4-4-1、超时重传拥塞发生算法 title=4.4.4.1、超时重传拥塞发生算法></a>4.4.4.1、超时重传拥塞发生算法</h4><p>当发⽣了「超时重传」，则就会使⽤拥塞发⽣算法。<p>这个时候，ssthresh 和 cwnd 的值会发⽣变化：<ul><li>ssthresh 设为 cwnd/2。<li>cwnd ᯿置为 1。</ul><p><img alt=image-20210418190500847 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418190500847.png?token=AIGEF3JQ4TJUE2EKGKDAEYTEZZTXS><p>接着，就᯿新开始慢启动，慢启动是会突然减少数据流的。这真是⼀旦「超时᯿传」，⻢上回到解放 前。但是这种⽅式太激进了，反应也很强烈，会造成⽹络卡顿。<p>就好像本来在秋名⼭⾼速漂移着，突然来个紧急刹⻋，轮胎受得了吗。<h4 id=4-4-4-2、快速重传拥塞发生算法><a class=headerlink href=#4-4-4-2、快速重传拥塞发生算法 title=4.4.4.2、快速重传拥塞发生算法></a>4.4.4.2、快速重传拥塞发生算法</h4><p>还有更好的⽅式，前⾯我们讲过「快速᯿传算法」。当接收⽅发现丢了⼀个中间包的时候，发送三次前⼀个包的 ACK，于是发送端就会快速地᯿传，不必等待超时再᯿传。<p>TCP 认为这种情况不严重，因为⼤部分没丢，只丢了⼀⼩部分，则 ssthresh 和 cwnd 变化如下：<ul><li>cwnd = cwnd/2 ，也就是设置为原来的⼀半;<li>ssthresh = cwnd ;<li>进⼊快速恢复算法</ul><h3 id=4-4-5、快速恢复><a class=headerlink href=#4-4-5、快速恢复 title=4.4.5、快速恢复></a>4.4.5、快速恢复</h3><p>快速重传和快速恢复算法⼀般同时使⽤，快速恢复算法是认为，你还能收到 3 个᯿复 ACK 说明⽹络也 不那么糟糕，所以没有必要像 RTO 超时那么强烈。<p>正如前⾯所说，进⼊快速恢复之前， cwnd 和 ssthresh 已被更新了：<ul><li>cwnd = cwnd/2 ，也就是设置为原来的⼀半;<li>ssthresh = cwnd ;</ul><p>然后，进⼊快速恢复算法如下：<ul><li>拥塞窗⼝ cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；<li>重传丢失的数据包；<li>如果再收到᯿复的 ACK，那么 cwnd 增加 1；<li>如果收到新数据的 ACK 后，把 cwnd 设置为第⼀步中的 ssthresh 的值，原因是该 ACK 确认了新 的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的 状态了，也即再次进⼊拥塞避免状态；</ul><p><img alt=image-20210418190824253 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418190824253.png?token=AIGEF3OMNX6UPRX5HTWPQ4LEZZTYW><p>也就是没有像「超时᯿传」⼀夜回到解放前，⽽是还在⽐较⾼的值，后续呈线性增⻓。<h3 id=4-4-6、拥塞算法示意图><a class=headerlink href=#4-4-6、拥塞算法示意图 title=4.4.6、拥塞算法示意图></a>4.4.6、拥塞算法示意图</h3><p>好了，以上就是拥塞控制的全部内容了，看完后，你再来看下⾯这张图⽚，每个过程我相信你都能明⽩：<p><img alt=image-20210418190933705 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418190933705.png?token=AIGEF3O7Y4XVQBQTANPYGO3EZZTZ2><h1 id=5、TCP性能传输><a class=headerlink href=#5、TCP性能传输 title=5、TCP性能传输></a>5、TCP性能传输</h1><h2 id=5-1、提升TCP三次握手性能><a class=headerlink href=#5-1、提升TCP三次握手性能 title=5.1、提升TCP三次握手性能></a>5.1、提升TCP三次握手性能</h2><p><strong>TCP 是⾯向连接的、可靠的、双向传输的传输层通信协议。在传输数据之前需要经过三次握⼿才能建⽴连接</strong>。<p><img alt=image-20210418200853587 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418200853587.png?token=AIGEF3PKZQ5DN2HYA6BCJCDEZZT2Y><p>那么，三次握⼿时间消耗在⼀个 HTTP 请求的平均时间中占⽐ 10% 以上，在⽹络状态不佳、⾼并发或者遭遇 SYN 攻击等场景中，如果不能有效正确的调节三次握⼿中的参数，就会对性能产⽣很多的影响。<p>如何正确有效的使⽤这些参数，来提⾼ TCP 三次握⼿的性能，这就需要理解「三次握⼿的状态变迁」，<strong>当出现问题时，先⽤ netstat 命令查看是哪个握⼿阶段出现问题，再来对症下药，⽽不是病急乱投医</strong>。<p><img alt=image-20210418200928818 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418200928818.png?token=AIGEF3LE7BG2HJ6Z6QJ6XKDEZZT32><p>客户端和服务端都可以通过三次握⼿优化性能。主动发起连接的客户端优化相对简单些，⽽服务端需要 监听端⼝，属于被动连接⽅，其间保持许多的中间状态，优化⽅法相对复杂⼀些。<p>所以，客户端（主动发起连接⽅）和服务端（被动连接⽅）优化的⽅式是不同的，接下来分别针对客户端和服务端来进行优化。<h3 id=5-1-1、客户端优化><a class=headerlink href=#5-1-1、客户端优化 title=5.1.1、客户端优化></a>5.1.1、客户端优化</h3><p><strong>三次握⼿建⽴连接⾸要⽬的是同步序列号</strong>。<p>SYN 的全称就叫 Synchronize Sequence Numbers（同步序列号）。<p><img alt=image-20210418201102398 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418201102398.png?token=AIGEF3MOTGYQRFXHFW5SSXTEZZT4Y><h4 id=5-1-1-1、SYN-SENT-状态优化><a title="5.1.1.1、SYN_SENT 状态优化" class=headerlink href=#5-1-1-1、SYN-SENT-状态优化></a>5.1.1.1、SYN_SENT 状态优化</h4><p>客户端 先发送 SYN 包，然后进入 SYN_SENT 状态。<p>如果客户端⻓时间没有收到 SYN+ACK 报⽂，则会重发 SYN 包，重发次数由 tcp_syn_retries 参数控制， 默认是 5 次：<p><img alt=image-20210418202018005 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202018005.png?token=AIGEF3PR3UMRW7WSX34RVLDEZZT6S><p>通常，第⼀次超时重传是在 1 秒后，第⼆次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。<strong>每次超时的时间是上⼀次的 2 倍</strong>。当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就会终⽌三次握⼿。<p>所以，<strong>总耗时是 1+2+4+8+16+32=63 秒，⼤约 1 分钟左右</strong>。<p><img alt=image-20210418202153188 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202153188.png?token=AIGEF3JDYMONIYRUTC5QUJ3EZZT7S><p>客户端优化参考如下：<strong>根据 ⽹络稳定性 和 服务器繁忙程度 来修改 SYN 重传次数，调整客户端三次握⼿时间上限</strong>。<h3 id=5-1-2、服务端优化><a class=headerlink href=#5-1-2、服务端优化 title=5.1.2、服务端优化></a>5.1.2、服务端优化</h3><p>服务端收到 SYN 包后会⽴⻢回复 SYN+ACK 包，表明收到了客户端序列号，同时也把⾃⼰的序列号发给对⽅。<p>服务端 收到 新连接 就会 进入SYN_RCV状态，同时 Linux 内核就会建⽴⼀个「半连接队列」来维护「未完成」的握⼿信息，当半连接队列溢出后，服务端就⽆法再建⽴新连接。<p><img alt=image-20210418202233550 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202233550.png?token=AIGEF3JSAG777JY5DJFM5H3EZZUAO><p>SYN 攻击半连接队列。<h4 id=5-1-2-1、如何查看由于-SYN-半连接队列已满⽽被丢弃连接的情况？><a title="5.1.2.1、如何查看由于 SYN 半连接队列已满⽽被丢弃连接的情况？" class=headerlink href=#5-1-2-1、如何查看由于-SYN-半连接队列已满⽽被丢弃连接的情况？></a>5.1.2.1、如何查看由于 SYN 半连接队列已满⽽被丢弃连接的情况？</h4><p>可以从 <code>netstat -s</code> 命令返回的统计结果中得到由于半连接队列已满而引发的失败次数：<p><img alt=image-20210418202341149 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202341149.png?token=AIGEF3NE7TGUGCNVKOK7L7TEZZUBM><p>上⾯输出的数值是累计值，表示共有多少个 TCP 连接因半连接队列溢出⽽被丢弃。隔⼏秒执⾏⼏次，如果有上升趋势，说明当前存在半连接队列溢出现象。<h4 id=5-1-2-2、如何调整-SYN-半连接队列⼤⼩？><a title="5.1.2.2、如何调整 SYN 半连接队列⼤⼩？" class=headerlink href=#5-1-2-2、如何调整-SYN-半连接队列⼤⼩？></a>5.1.2.2、如何调整 SYN 半连接队列⼤⼩？</h4><p><strong>要想增⼤半连接队列，不仅需要增大 <code>tcp_max_syn_backlog</code> 的值，还需增⼤ accept 队列。</strong>两者缺一不可，否则⽆效。<p>增⼤ <code>tcp_max_syn_backlog</code> 和 <code>somaxconn</code> 的⽅法是修改 Linux 内核参数：<p><img alt=image-20210418202433581 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202433581.png?token=AIGEF3LYEPBDR246AOHSDEDEZZUC2><p>增⼤ backlog 的⽅式，每个 Web 服务都不同，⽐如 Nginx 增⼤ backlog 的⽅法如下：<p><img alt=image-20210418202450402 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202450402.png?token=AIGEF3IAGE5H6T7P3G44GKLEZZUDU><p>最后，改变了如上这些参数后，要᯿启 Nginx 服务，因为 SYN 半连接队列和 accept 队列都是在 listen() 初始化的。<h4 id=5-1-2-3、如果-SYN-半连接队列已满，只能丢弃连接吗？><a title="5.1.2.3、如果 SYN 半连接队列已满，只能丢弃连接吗？" class=headerlink href=#5-1-2-3、如果-SYN-半连接队列已满，只能丢弃连接吗？></a>5.1.2.3、如果 SYN 半连接队列已满，只能丢弃连接吗？</h4><p>事实并非如此，开启 syncookies 功能就可实现不使⽤ SYN 半连接队列的情况下成功建⽴连接。<p>syncookies ⼯作原理：服务器根据当前状态计算出⼀个值，放在⼰⽅的 SYN+ACK 报⽂中并发出，当客户端返回 ACK 报⽂时，取出该值验证，如果合法，就认为连接建⽴成功，如下图所示。<p><img alt=image-20210418202537593 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202537593.png?token=AIGEF3KA4HVZAA4VGZDTMADEZZUEQ><p>syncookies 参数主要有以下三个值：<ul><li>0：表示关闭该功能；<li>1：表示仅当 SYN 半连接队列放不下时，再启⽤它；<li>2：表示⽆条件开启功能；</ul><p>在应对 SYN 攻击时，只需设为 1 即可：<p><img alt=image-20210418202615907 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202615907.png?token=AIGEF3LIA34H3VZQALS4XEDEZZUFK><h4 id=5-1-2-4、SYN-RCV-状态优化><a title="5.1.2.4、SYN_RCV 状态优化" class=headerlink href=#5-1-2-4、SYN-RCV-状态优化></a>5.1.2.4、SYN_RCV 状态优化</h4><p>当客户端接收到服务器发来的 SYN+ACK 报⽂后，就会回复 ACK 给服务器，同时客户端连接状态从 SYN_SENT 转换为 ESTABLISHED，表示连接建⽴成功。<p>服务器端连接成功建⽴的时间还要再往后，等到服务端收到客户端的 ACK 后，服务端的连接状态才变 为 ESTABLISHED。<p>如果服务器没有收到 ACK，就会重发 SYN+ACK 报⽂，同时⼀直处于 SYN_RCV 状态。<p>当⽹络繁忙、不稳定时，报⽂丢失就会变严重，此时应该调⼤᯿发次数。反之则可以调⼩重发次数。修改重发次数的⽅法是，调整 tcp_synack_retries 参数：<p><img alt=image-20210418202715040 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202715040.png?token=AIGEF3MST7XUUM4TWEWOZTLEZZUGG><p>tcp_synack_retries 的默认重试次数是 5 次，与客户端重传 SYN 类似，它的重传会经历 1、2、4、8、 16 秒，最后⼀次重传后会继续等待 32 秒，如果服务端仍然没有收到 ACK，才会关闭连接，故共需要等待 63 秒。<p>服务器收到 ACK 后连接建⽴成功，此时，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调⽤ accept 函数时把连接取出来。<p>如果进程不能及时地调⽤ accept 函数，就会造成 accept 队列（也称全连接队列）溢出，最终导致建⽴ 好的 TCP 连接被丢弃。<p><img alt=image-20210418202743734 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202743734.png?token=AIGEF3KFXAKORLXG72225EDEZZUHE><h4 id=5-1-2-5、accept-队列已满，只能丢弃连接吗？><a title="5.1.2.5、accept 队列已满，只能丢弃连接吗？" class=headerlink href=#5-1-2-5、accept-队列已满，只能丢弃连接吗？></a>5.1.2.5、accept 队列已满，只能丢弃连接吗？</h4><p>丢弃连接只是 Linux 的默认⾏为，我们还可以选择向客户端发送 RST 复位报⽂，告诉客户端连接已经 建⽴失败。打开这⼀功能需要将 tcp_abort_on_overflow 参数设置为 1。<p><img alt=image-20210418202819569 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202819569.png?token=AIGEF3IDCHC3R3GHJWZ363DEZZUIC><p>tcp_abort_on_overflow 共有两个值分别是 0 和 1，其分别表示：<ul><li>0 ：如果 accept 队列满了，那么 server 扔掉 client 发过来的 ack ；<li>1 ：如果 accept 队列满了，server 发送⼀个 RST 包给 client，表示废掉这个握⼿过程和这个连接；</ul><p>如果要想知道客户端连接不上服务端，是不是服务端 TCP 全连接队列满的原因，那么可以把 tcp_abort_on_overflow 设置为 1，这时如果在客户端异常中可以看到很多 connection reset by peer 的错误，那么就可以证明是由于服务端 TCP 全连接队列溢出的问题。<p>通常情况下，应当把 tcp_abort_on_overflow 设置为 0，因为这样更有利于应对突发流量。<p>举个例⼦，当 accept 队列满导致服务器丢掉了 ACK，与此同时，客户端的连接状态却是 ESTABLISHED，客户端进程就在建⽴好的连接上发送请求。只要服务器没有为请求回复 ACK，客户端 的请求就会被多次「᯿发」。如果服务器上的进程只是短暂的繁忙造成 accept 队列满，那么当 accept 队列有空位时，再次接收到的请求报⽂由于含有 ACK，仍然会触发服务器端成功建⽴连接。<p><img alt=image-20210418202908422 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202908422.png?token=AIGEF3J3LN4DYGVK62II6WDEZZUJG><p>所以，tcp_abort_on_overflow 设为 0 可以提⾼连接建⽴的成功率，只有你⾮常肯定 TCP 全连接队列会 ⻓期溢出时，才能设置为 1 以尽快通知客户端。<h4 id=5-1-2-6、如何调整-accept-队列的⻓度？><a title="5.1.2.6、如何调整 accept 队列的⻓度？" class=headerlink href=#5-1-2-6、如何调整-accept-队列的⻓度？></a>5.1.2.6、如何调整 accept 队列的⻓度？</h4><p>可以通过 ss -lnt 命令查看：<p><img alt=image-20230805102847562 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805102847562.png?token=AIGEF3K4IHX6PSTQALISP6TEZZUKI><ul><li>Recv-Q：当前 accept 队列的⼤⼩，也就是当前已完成三次握⼿并等待服务端 accept() 的 TCP 连接；<li>Send-Q：accept 队列最⼤⻓度，上⾯的输出结果说明监听 8088 端⼝的 TCP 服务，accept 队列的 最⼤⻓度为 128；</ul><h4 id=5-1-2-7、如何查看由于-accept-连接队列已满，⽽被丢弃的连接？><a title="5.1.2.7、如何查看由于 accept 连接队列已满，⽽被丢弃的连接？" class=headerlink href=#5-1-2-7、如何查看由于-accept-连接队列已满，⽽被丢弃的连接？></a>5.1.2.7、如何查看由于 accept 连接队列已满，⽽被丢弃的连接？</h4><p>当超过了 accept 连接队列，服务端则会丢掉后续进来的 TCP 连接，丢掉的 TCP 连接个数会被统计，可使⽤ netstat -s 命令来查看：<p><img alt=image-20210418203046836 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418203046836.png?token=AIGEF3JHJ2G323ECIVG3Y4DEZZULS><p>上⾯看到的 41150 times ，表示 accept 队列溢出的次数，注意这个是累计值。可以隔⼏秒钟执⾏下， 如果这个数字⼀直在增加的话，说明 accept 连接队列偶尔满了。<p>如果持续不断地有连接因为 accept 队列溢出被丢弃，就应该调⼤ backlog 以及 somaxconn 参数。<h3 id=5-1-3、如何绕过三次握手><a class=headerlink href=#5-1-3、如何绕过三次握手 title=5.1.3、如何绕过三次握手></a>5.1.3、如何绕过三次握手</h3><p>下面我们看看如何绕过三次握⼿发送数据。<p>三次握⼿建⽴连接造成的后果就是，HTTP 请求必须在⼀个 RTT（客户端到服务器⼀个往返时间） 后才能发送。<p><img alt=image-20210418203159568 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418203159568.png?token=AIGEF3NJGPQKHQAGFYI24ADEZZUNA><p><strong>Linux 3.7内核版本之后提供了 TCP Fast Open 功能，这个功能可以减少 TCP 连接建⽴的时延</strong>。<h4 id=5-1-3-1、TCP-Fast-Open-⼯作⽅式。><a title="5.1.3.1、TCP Fast Open ⼯作⽅式。" class=headerlink href=#5-1-3-1、TCP-Fast-Open-⼯作⽅式。></a>5.1.3.1、TCP Fast Open ⼯作⽅式。</h4><p><img alt=image-20210418203407354 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418203407354.png?token=AIGEF3J3SFLUFVYQIXAAD4DEZZUN4><p>在客户端⾸次建⽴连接时的过程：<ol><li>客户端发送 SYN 报⽂，该报⽂包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie；<li>⽀持 TCP Fast Open 的服务器⽣成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以 发回客户端；<li>客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。</ol><p>所以，第⼀次发起 HTTP GET 请求的时候，还是需要正常的三次握⼿流程。<p>之后，如果客户端再次向服务器建⽴连接时的过程：<ol><li>客户端发送 SYN 报⽂，该报⽂包含「数据」（对于⾮ TFO 的普通 TCP 握⼿过程，SYN 报⽂中不 包含「数据」）以及此前记录的 Cookie；<li>⽀持 TCP Fast Open 的服务器会对收到 Cookie 进⾏校验：如果 Cookie 有效，服务器将在 SYNACK 报⽂中对 SYN 和「数据」进⾏确认，服务器随后将「数据」递送⾄相应的应⽤程序；如果 Cookie ⽆效，服务器将丢弃 SYN 报⽂中包含的「数据」，且其随后发出的 SYN-ACK 报⽂将只确 认 SYN 的对应序列号；<li>如果服务器接受了 SYN 报⽂中的「数据」，服务器可在握⼿完成之前发送「数据」，这就减少了 握⼿带来的 1 个 RTT 的时间消耗；<li>客户端将发送 ACK 确认服务器发回的 SYN 以及「数据」，但如果客户端在初始的 SYN 报⽂中发 送的「数据」没有被确认，则客户端将᯿新发送「数据」；<li>此后的 TCP 连接的数据传输过程和⾮ TFO 的正常情况⼀致。</ol><p>所以，之后发起 HTTP GET 请求的时候，可以绕过三次握⼿，这就减少了握⼿带来的 1 个 RTT 的时间消耗。<p>开启了 TFO 功能，cookie 的值是存放到 TCP option 字段⾥的：<p><img alt=image-20210418203616446 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418203616446.png?token=AIGEF3NTMZYSYP57CGLLTFTEZZUO4><p>注：客户端在请求并存储了 Fast Open Cookie 之后，可以不断᯿复 TCP Fast Open 直⾄服务器认为 Cookie ⽆效（通常为过期）。<h4 id=5-1-3-2、Linux-下如何打开-TCP-Fast-Open-功能><a title="5.1.3.2、Linux 下如何打开 TCP Fast Open 功能" class=headerlink href=#5-1-3-2、Linux-下如何打开-TCP-Fast-Open-功能></a>5.1.3.2、Linux 下如何打开 TCP Fast Open 功能</h4><p><strong>Linux环境中可通过设置 tcp_fastopn 内核参数来打开 Fast Open 功能</strong>：<p><img alt=image-20210418203701456 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418203701456.png?token=AIGEF3O3LKGSZ333JXPZHWTEZZUQA><p>tcp_fastopn 各个值的意义：<ul><li>0 关闭 1 作为客户端使⽤ Fast Open 功能；<li>2 作为服务端使⽤ Fast Open 功能；<li>3 ⽆论作为客户端还是服务器，都可以使⽤ Fast Open 功能；</ul><p>TCP Fast Open 功能需要客户端和服务端同时⽀持，才有效果。<h3 id=5-1-4、小结><a class=headerlink href=#5-1-4、小结 title=5.1.4、小结></a>5.1.4、小结</h3><p>TCP 三次握⼿参数。<p><img alt=image-20210418203828453 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418203828453.png?token=AIGEF3NYDNTGIFJQDUNTOUTEZZURC><h4 id=5-1-4-1、客户端优化><a class=headerlink href=#5-1-4-1、客户端优化 title=5.1.4.1、客户端优化></a>5.1.4.1、客户端优化</h4><p><strong>当客户端发起 SYN 包时，可以通过 <code>tcp_syn_retries</code> 控制其重传次数</strong>。<h4 id=5-1-4-2、服务端优化><a class=headerlink href=#5-1-4-2、服务端优化 title=5.1.4.2、服务端优化></a>5.1.4.2、服务端优化</h4><p>当服务端 SYN 半连接队列溢出后，会导致后续连接被丢弃，可以通过 netstat -s 观察半连接队列溢出的情况，如果 SYN 半连接队列溢出情况⽐较严重，可以通过 <code>tcp_max_syn_backlog</code>、<code>somaxconn</code>、 <code>backlog</code> 参数来调整 SYN 半连接队列的⼤⼩。<p>服务端回复 SYN+ACK 的᯿传次数由 <code>tcp_synack_retries</code> 参数控制。如果遭受 SYN 攻击，应把 <code>tcp_syncookies</code> 参数设置为 1，表示仅在 SYN 队列满后开启 syncookie 功能，可以保证正常的连接 成功建⽴。<p>服务端收到客户端返回的 ACK，会把连接移⼊ accpet 队列，等待进⾏调⽤ accpet() 函数取出连接。<p>可以通过 ss -lnt 查看服务端进程的 accept 队列⻓度，如果 accept 队列溢出，系统默认丢弃 ACK，如果可以把 <code>tcp_abort_on_overflow</code> 设置为 1 ，表示⽤ RST 通知客户端连接建⽴失败。<p>如果 accpet 队列溢出严重，可以通过 listen 函数的 backlog 参数和 somaxconn 系统参数提⾼队列⼤ ⼩，accept 队列⻓度取决于 min(backlog, somaxconn)。<h4 id=5-1-4-3、绕过三次握手><a class=headerlink href=#5-1-4-3、绕过三次握手 title=5.1.4.3、绕过三次握手></a>5.1.4.3、绕过三次握手</h4><p><strong>TCP Fast Open可绕过三次握⼿，使得 HTTP 请求减少 1 个 RTT 时间，Linux 下可通过 <code>tcp_fastopen</code> 开启该功能，同时必须保证服务端和客户端同时⽀持</strong>。<h2 id=5-2、提升TCP四次挥手性能><a class=headerlink href=#5-2、提升TCP四次挥手性能 title=5.2、提升TCP四次挥手性能></a>5.2、提升TCP四次挥手性能</h2><p>开始之前，需要先了解四次挥⼿状态变迁过程。<p>客户端和服务端双⽅都可以主动断开连接，通常先关闭连接的⼀⽅称为主动⽅，后关闭连接的⼀⽅称为被动⽅。<p><img alt=image-20210418204051701 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418204051701.png?token=AIGEF3J335BODYBV3SZHHUDEZZUSI><p>可以看到，四次挥⼿过程只涉及了两种报⽂，分别是 FIN 和 ACK：<ul><li>FIN 就是结束连接的意思，谁发出 FIN 报⽂，就表示它将不会再发送任何数据，关闭这⼀⽅向上的 传输通道；<li>ACK 就是确认的意思，⽤来通知对⽅：你⽅的发送通道已经关闭；</ul><p>四次挥⼿过程：<ol><li>当主动⽅关闭连接时，会发送 FIN 报⽂，此时发送⽅的 TCP 连接将从 ESTABLISHED 变成 FIN_WAIT1。<li>当被动⽅收到 FIN 报⽂后会⾃动回复 ACK 报⽂，连接状态将从 ESTABLISHED 变成 CLOSE_WAIT，表示被动⽅在等待进程调⽤ close 函数关闭连接。<li>当主动⽅收到这个 ACK 后，连接状态由 FIN_WAIT1 变为 FIN_WAIT2，也就是表示主动⽅的发送通 道就关闭了。<li>当被动⽅进⼊ CLOSE_WAIT 时，被动⽅还会继续处理数据，等到进程的 read 函数返回 0 后，应⽤ 程序就会调⽤ close 函数，进⽽触发内核发送 FIN 报⽂，此时被动⽅的连接状态变为 LAST_ACK。<li>当主动⽅收到这个 FIN 报⽂后，内核会回复 ACK 报⽂给被动⽅，同时主动⽅的连接状态由 FIN_WAIT2 变为 TIME_WAIT，在 Linux 系统下⼤约等待 1 分钟后，TIME_WAIT 状态的连接才会 彻底关闭。<li>当被动⽅收到最后的 ACK 报⽂后，被动⽅的连接就会关闭。</ol><p>你可以看到，每个⽅向都需要⼀个 FIN 和⼀个 ACK，因此通常被称为 四次挥⼿。<p><font color=red>注意：主动关闭连接的才有 TIME_WAIT 状态。</font><h3 id=5-2-1、主动方优化><a class=headerlink href=#5-2-1、主动方优化 title=5.2.1、主动方优化></a>5.2.1、主动方优化</h3><p><strong>关闭连接的⽅式通常有两种，分别是 RST报⽂关闭 和 FIN报⽂关闭</strong>。<p>如果进程异常退出了，内核就会发送 RST 报⽂来关闭，它可以不⾛四次挥⼿流程，是⼀个暴⼒关闭连接的⽅式。<p>安全关闭连接的⽅式必须通过四次挥⼿，它由进程调⽤ close 和 shutdown 函数发起 FIN 报⽂ （shutdown 参数须传⼊ <code>SHUT_WR</code> 或者 <code>SHUT_RDWR</code> 才会发送 FIN）。<h4 id=5-2-1-1、-close-函数和-shutdown-函数有什么区别？><a title="5.2.1.1、 close 函数和 shutdown 函数有什么区别？" class=headerlink href=#5-2-1-1、-close-函数和-shutdown-函数有什么区别？></a>5.2.1.1、 close 函数和 shutdown 函数有什么区别？</h4><p>调⽤了 close 函数意味着完全断开连接，完全断开后⽆法传输数据，且也不能发送数据。 此时， 调⽤了 close 函数的⼀⽅的连接叫做「孤⼉连接」，如果你⽤ netstat -p 命令，会发现连接对应的进程名为空。<p>使⽤ close 函数关闭连接是不优雅的。于是，就出现了⼀种优雅关闭连接的 shutdown 函数，它可以控制只关闭⼀个⽅向的连接：<p><img alt=image-20210418204332745 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418204332745.png?token=AIGEF3LI4BBBZGHTKCMH7Y3EZZUTU><p>第⼆个参数决定断开连接的⽅式，主要有以下三种⽅式：<ul><li>SHUT_RD(0)：关闭连接的「读」这个⽅向，如果接收缓冲区有已接收的数据，则将会被丢弃，并 且后续再收到新的数据，会对数据进⾏ ACK，然后悄悄地丢弃。也就是说，对端还是会接收到 ACK，在这种情况下根本不知道数据已经被丢弃了。<li>SHUT_WR(1)：关闭连接的「写」这个⽅向，这就是常被称为「半关闭」的连接。如果发送缓冲区 还有未发送的数据，将被⽴即发送出去，并发送⼀个 FIN 报⽂给对端。<li>SHUT_RDWR(2)：相当于 SHUT_RD 和 SHUT_WR 操作各⼀次，关闭套接字的读和写两个⽅向。</ul><p>close 和 shutdown 函数都可以关闭连接，但这两种⽅式关闭的连接，不仅仅在功能上存在差异，控制它们的 Linux 参数也不相同。<h4 id=5-2-1-2、FIN-WAIT1-状态的优化><a title="5.2.1.2、FIN_WAIT1 状态的优化" class=headerlink href=#5-2-1-2、FIN-WAIT1-状态的优化></a>5.2.1.2、FIN_WAIT1 状态的优化</h4><p>主动⽅发送 FIN 报⽂后，连接就处于 FIN_WAIT1 状态，正常情况下，如果能及时收到被动⽅的 ACK， 则会很快变为 FIN_WAIT2 状态。<p>但是当迟迟收不到对⽅返回的 ACK 时，连接就会⼀直处于 FIN_WAIT1 状态。此时，内核会定时重发 FIN 报⽂，其中重发次数由 <code>tcp_orphan_retries</code> 参数控制（注意，orphan 虽然是孤⼉的意思，该参数 却不只对孤⼉连接有效，事实上，它对所有 FIN_WAIT1 状态下的连接都有效），默认值是 0。<p><img alt=image-20210418204448802 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418204448802.png?token=AIGEF3NJBMGXP7VKHIXI3UDEZZUVY><p>你可能会好奇，这 0 表示⼏次？实际上当为 0 时，特指 8 次，从下⾯的内核源码可知：<p><img alt=image-20210418204505382 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418204505382.png?token=AIGEF3IARNNM3GI3IT34CELEZZUWW><p>如果 FIN_WAIT1 状态连接很多，我们就需要考虑降低 tcp_orphan_retries 的值，当᯿传次数超过 tcp_orphan_retries 时，连接就会直接关闭掉。<p>对于普遍正常情况时，调低 tcp_orphan_retries 就已经可以了。如果遇到恶意攻击，FIN 报⽂根本⽆法 发送出去，这由 TCP 两个特性导致的：<ul><li>⾸先，TCP 必须保证报⽂是有序发送的，FIN 报⽂也不例外，当发送缓冲区还有数据没有发送时， FIN 报⽂也不能提前发送。<li>其次，TCP 有流量控制功能，当接收⽅接收窗⼝为 0 时，发送⽅就不能再发送数据。所以，当攻击 者下载⼤⽂件时，就可以通过接收窗⼝设为 0 ，这就会使得 FIN 报⽂都⽆法发送出去，那么连接会 ⼀直处于 FIN_WAIT1 状态。</ul><p>解决这种问题的⽅法，是调整 tcp_max_orphans 参数，它定义了「孤⼉连接」的最⼤数量：<p><img alt=image-20210418204559635 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418204559635.png?token=AIGEF3MRLKYYVVHK6L3S3Y3EZZUXY><p>当进程调⽤了 close 函数关闭连接，此时连接就会是「孤⼉连接」，因为它⽆法再发送和接收数据。 Linux 系统为了防⽌孤⼉连接过多，导致系统资源⻓时间被占⽤，就提供了 tcp_max_orphans 参数。 如果孤⼉连接数量⼤于它，新增的孤⼉连接将不再⾛四次挥⼿，⽽是直接发送 RST 复位报⽂强制关 闭。<h4 id=5-2-1-3、FIN-WAIT2-状态的优化><a title="5.2.1.3、FIN_WAIT2 状态的优化" class=headerlink href=#5-2-1-3、FIN-WAIT2-状态的优化></a>5.2.1.3、FIN_WAIT2 状态的优化</h4><p>当主动⽅收到 ACK 报⽂后，会处于 FIN_WAIT2 状态，就表示主动⽅的发送通道已经关闭，接下来将等待对⽅发送 FIN 报⽂，关闭对⽅的发送通道。<p>这时，如果连接是⽤ shutdown 函数关闭的，连接可以⼀直处于 FIN_WAIT2 状态，因为它可能还可以 发送或接收数据。但对于 close 函数关闭的孤⼉连接，由于⽆法再发送和接收数据，所以这个状态不可以持续太久，⽽ tcp_fin_timeout 控制了这个状态下连接的持续时⻓，默认值是 60 秒：<p><img alt=image-20210418204818957 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418204818957.png?token=AIGEF3LZ62PJJVNTIUR4BBTEZZUZE><p>它意味着对于孤⼉连接（调⽤ close 关闭的连接），如果在 60 秒后还没有收到 FIN 报⽂，连接就会直 接关闭。<p>这个 60 秒不是随便决定的，它与 TIME_WAIT 状态持续的时间是相同的，后⾯我们再来说说为什么是 60 秒。<h4 id=5-2-1-4、TIME-WAIT-状态的优化><a title="5.2.1.4、TIME_WAIT 状态的优化" class=headerlink href=#5-2-1-4、TIME-WAIT-状态的优化></a>5.2.1.4、TIME_WAIT 状态的优化</h4><p>TIME_WAIT 是主动⽅四次挥⼿的最后⼀个状态，也是最常遇⻅的状态。<p>当收到被动⽅发来的 FIN 报⽂后，主动⽅会⽴刻回复 ACK，表示确认对⽅的发送通道已经关闭，接着 就处于 TIME_WAIT 状态。在 Linux 系统，TIME_WAIT 状态会持续 60 秒后才会进⼊关闭状态。<p>TIME_WAIT 状态的连接，在主动⽅看来确实快已经关闭了。然后，被动⽅没有收到 ACK 报⽂前，还是处于 <code>LAST_ACK</code> 状态。如果这个 ACK 报⽂没有到达被动⽅，被动⽅就会重发 FIN 报⽂。重发次数仍然由前⾯介绍过的 <code>tcp_orphan_retries</code>参数控制。<p>TIME-WAIT 的状态尤其重要，主要是两个原因：<ul><li>防⽌具有相同「四元组」的「旧」数据包被收到；<li>保证「被动关闭连接」的⼀⽅能被正确的关闭，即保证最后的 ACK 能让被动关闭⽅接收，从⽽帮 助其正常关闭；</ul><p><strong>原因⼀：防⽌旧连接的数据包</strong><p>TIME-WAIT 的⼀个作⽤是防⽌收到历史数据，从⽽导致数据错乱的问题。<p>假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发⽣什么呢？<p><img alt=image-20210418205021190 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205021190.png?token=AIGEF3MHXN4WBSV26XSBUELEZZU22><ul><li>如上图⻩⾊框框服务端在关闭连接之前发送的 SEQ = 301 报⽂，被⽹络延迟了。<li>这时有相同端⼝的 TCP 连接被复⽤后，被延迟的 SEQ = 301 抵达了客户端，那么客户端是有可能 正常接收这个过期的报⽂，这就会产⽣数据错乱等严᯿的问题。</ul><p>所以，TCP 就设计出了这么⼀个机制，经过 2MSL 这个时间，⾜以让两个⽅向上的数据包都被丢弃， 使得原来连接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣的。<p><strong>原因⼆：保证连接正确关闭</strong><p>TIME-WAIT 的另外⼀个作⽤是等待⾜够的时间以确保最后的 ACK 能让被动关闭⽅接收，从⽽帮助其正 常关闭。<p>假设 TIME-WAIT 没有等待时间或时间过短，断开连接会造成什么问题呢？<p><img alt=image-20210418205117533 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205117533.png?token=AIGEF3MFFBYKXCNBGCX3D5LEZZU4A><ul><li>如上图红⾊框框客户端四次挥⼿的最后⼀个 ACK 报⽂如果在⽹络中被丢失了，此时如果客户端 TIME-WAIT 过短或没有，则就直接进⼊了 CLOSE 状态了，那么服务端则会⼀直处在 LAST-ACK 状态。<li>当客户端发起建⽴连接的 SYN 请求报⽂后，服务端会发送 RST 报⽂给客户端，连接建⽴的过程 就会被终⽌。</ul><p>我们再回过头来看看，为什么 TIME_WAIT 状态要保持 60 秒呢？这与孤⼉连接 FIN_WAIT2 状态默认保 留 60 秒的原理是⼀样的，因为这两个状态都需要保持 2MSL 时⻓。MSL 全称是 Maximum Segment Lifetime，它定义了⼀个报⽂在⽹络中的最⻓⽣存时间（报⽂每经过⼀次路由器的转发，IP 头部的 TTL 字段就会减 1，减到 0 时报⽂就被丢弃，这就限制了报⽂的最⻓存活时间）。<p>为什么是 2 MSL 的时⻓呢？这其实是相当于⾄少允许报⽂丢失⼀次。⽐如，若 ACK 在⼀个 MSL 内丢 失，这样被动⽅᯿发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。<p>为什么不是 4 或者 8 MSL 的时⻓呢？你可以想象⼀个丢包率达到百分之⼀的糟糕⽹络，连续两次丢包 的概率只有万分之⼀，这个概率实在是太⼩了，忽略它⽐解决它更具性价⽐。<p>因此，TIME_WAIT 和 FIN_WAIT2 状态的最⼤时⻓都是 2 MSL，由于在 Linux 系统中，MSL 的值固定 为 30 秒，所以它们都是 60 秒。<p>虽然 TIME_WAIT 状态有存在的必要，但它毕竟会消耗系统资源。如果发起连接⼀⽅的 TIME_WAIT 状 态过多，占满了所有端⼝资源，则会导致⽆法创建新连接。<ul><li><p>客户端受端⼝资源限制</p> <p>如果客户端 TIME_WAIT 过多，就会导致端⼝资源被占⽤，因为端⼝就 65536个，被占满就会导致⽆法创建新的连接；</p><li><p>服务端受系统资源限制</p> <p>由于⼀个四元组表示TCP连接，理论上服务端可以建⽴很多连接，服务端 确实只监听⼀个端⼝，但是会把连接扔给处理线程，所以理论上监听的端⼝可以继续监听。但是线 程池处理不了那么多⼀直不断的连接了。所以当服务端出现⼤量 TIME_WAIT 时，系统资源被占满 时，会导致处理不过来新的连接；</p></ul><p>另外，Linux 提供了 tcp_max_tw_buckets 参数，当 TIME_WAIT 的连接数量超过该参数时，新关闭 的连接就不再经历 TIME_WAIT ⽽直接关闭：<p><img alt=image-20210418205305424 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205305424.png?token=AIGEF3MWW57T5KNZR3E4N7TEZZU5I><p>当服务器的并发连接增多时，相应地，同时处于 TIME_WAIT 状态的连接数量也会变多，此时就应当调 ⼤ tcp_max_tw_buckets 参数，减少不同连接间数据错乱的概率。<p>tcp_max_tw_buckets 也不是越⼤越好，毕竟内存和端⼝都是有限的。<p>有⼀种⽅式可以在建⽴新连接时，复⽤处于 TIME_WAIT 状态的连接，那就是打开 tcp_tw_reuse 参 数。但是需要注意，该参数是只⽤于客户端（建⽴连接的发起⽅），因为是在调⽤ connect() 时起作⽤ 的，⽽对于服务端（被动连接⽅）是没有⽤的。<p><img alt=image-20210418205329777 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205329777.png?token=AIGEF3ORD7GOE7HCQEI4Z4TEZZU6K><p>tcp_tw_reuse 从协议⻆度理解是安全可控的，可以复⽤处于 TIME_WAIT 的端⼝为新的连接所⽤。<p>什么是协议⻆度理解的安全可控呢？主要有两点：<ul><li>只适⽤于连接发起⽅，也就是 C/S 模型中的客户端；<li>对应的 TIME_WAIT 状态的连接创建时间超过 1 秒才可以被复⽤。</ul><p>使⽤这个选项，还有⼀个前提，需要打开对 TCP 时间戳的⽀持（对⽅也要打开 ）：<p><img alt=image-20230805103313643 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805103313643.png?token=AIGEF3NSSNDSGZCKRVNFJ4TEZZVAM><p>由于引⼊了时间戳，它能带来了些好处：<ul><li>我们在前⾯提到的 2MSL 问题就不复存在了，因为᯿复的数据包会因为时间戳过期被⾃然丢弃；<li>同时，它还可以防⽌序列号绕回，也是因为᯿复的数据包会由于时间戳过期被⾃然丢弃；</ul><p>时间戳是在 TCP 的选项字段⾥定义的，开启了时间戳功能，在 TCP 报⽂传输的时候会带上发送报⽂的 时间戳。<p><img alt=image-20210418205502767 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205502767.png?token=AIGEF3NJ2QH5KMH6NFUXLH3EZZVBG><p>我们来看看开启了 tcp_tw_reuse 功能，如果四次挥⼿中的最后⼀次 ACK 在⽹络中丢失了，会发⽣什么？<p><img alt=image-20210418205550656 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205550656.png?token=AIGEF3JWSRU23OMVRDXEAVDEZZVCI><p>上图的流程：<ul><li>四次挥⼿中的最后⼀次 ACK 在⽹络中丢失了，服务端⼀直处于 LAST_ACK 状态；<li>客户端由于开启了 tcp_tw_reuse 功能，客户端再次发起新连接的时候，会复⽤超过 1 秒后的 time_wait 状态的连接。但客户端新发的 SYN 包会被忽略（由于时间戳），因为服务端⽐较了客户 端的上⼀个报⽂与 SYN 报⽂的时间戳，过期的报⽂就会被服务端丢弃；<li>服务端 FIN 报⽂迟迟没有收到四次挥⼿的最后⼀次 ACK，于是超时᯿发了 FIN 报⽂给客户端；<li>处于 SYN_SENT 状态的客户端，由于收到了 FIN 报⽂，则会回 RST 给服务端，于是服务端就离开 了 LAST_ACK 状态；<li>最初的客户端 SYN 报⽂超时重发了（ 1 秒钟后），此时就与服务端能正确的三次握⼿了。</ul><p>所以⼤家都会说开启了 tcp_tw_reuse，可以在复⽤了 time_wait 状态的 1 秒过后成功建⽴连接，这 1 秒 主要是花费在 SYN 包᯿传。<p>另外，⽼版本的 Linux 还提供了 tcp_tw_recycle 参数，但是当开启了它，就有两个坑：<ul><li>Linux 会加快客户端和服务端 TIME_WAIT 状态的时间，也就是它会使得 TIME_WAIT 状态会⼩于 60 秒，很容易导致数据错乱；<li>另外，Linux 会丢弃所有来⾃远端时间戳⼩于上次记录的时间戳（由同⼀个远端发送的）的任何数 据包。就是说要使⽤该选项，则必须保证数据包的时间戳是单调递增的。那么，问题在于，此处的 时间戳并不是我们通常意义上⾯的绝对时间，⽽是⼀个相对时间。很多情况下，我们是没法保证时 间戳单调递增的，⽐如使⽤了 NAT、LVS 等情况；</ul><p>所以，不建议设置为 1 ，在 Linux 4.12 版本后，Linux 内核直接取消了这⼀参数，建议关闭它：<p><img alt=image-20210418205726162 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205726162.png?token=AIGEF3MS2IW2ALHPL7GD3TTEZZVDU><p>另外，我们可以在程序中设置 socket 选项，来设置调⽤ close 关闭连接⾏为。<p><img alt=image-20210418205745092 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205745092.png?token=AIGEF3N4L43FUN4U3HXAS4LEZZVEW><p>如果 l_onoff 为⾮ 0， 且 l_linger 值为 0，那么调⽤ close 后，会⽴该发送⼀个 RST 标志给对 端，该 TCP 连接将跳过四次挥⼿，也就跳过了 TIME_WAIT 状态，直接关闭。<p>但这为跨越 TIME_WAIT 状态提供了⼀个可能，不过是⼀个⾮常危险的⾏为，不值得提倡。<h3 id=5-2-2、被动方优化><a class=headerlink href=#5-2-2、被动方优化 title=5.2.2、被动方优化></a>5.2.2、被动方优化</h3><p>当被动⽅收到 FIN 报⽂时，内核会⾃动回复 ACK，同时连接处于 CLOSE_WAIT 状态，顾名思义，它表示等待应⽤进程调⽤ close 函数关闭连接。<p>内核没有权利替代进程去关闭连接，因为如果主动⽅是通过 shutdown 关闭连接，那么它就是想在半关 闭连接上接收数据或发送数据。因此，Linux 并没有限制 CLOSE_WAIT 状态的持续时间。<p>当然，⼤多数应⽤程序并不使⽤ shutdown 函数关闭连接。所以，当你⽤ netstat 命令发现⼤量 CLOSE_WAIT 状态。就需要排查你的应⽤程序，因为可能因为应⽤程序出现了 Bug，read 函数返回 0 时，没有调⽤ close 函数。<p>处于 CLOSE_WAIT 状态时，调⽤了 close 函数，内核就会发出 FIN 报⽂关闭发送通道，同时连接进⼊ LAST_ACK 状态，等待主动⽅返回 ACK 来确认连接关闭。<p>如果迟迟收不到这个 ACK，内核就会重发 FIN 报⽂，᯿发次数仍然由 tcp_orphan_retries 参数控制，这 与主动⽅重发 FIN 报⽂的优化策略⼀致。<p>还有⼀点我们需要注意的，如果被动⽅迅速调⽤ close 函数，那么被动⽅的 ACK 和 FIN 有可能在⼀个 报⽂中发送，这样看起来，四次挥⼿会变成三次挥⼿，这只是⼀种特殊情况，不⽤在意。<h4 id=5-2-2-1、如果连接双⽅同时关闭连接，会怎么样？><a class=headerlink href=#5-2-2-1、如果连接双⽅同时关闭连接，会怎么样？ title=5.2.2.1、如果连接双⽅同时关闭连接，会怎么样？></a>5.2.2.1、如果连接双⽅同时关闭连接，会怎么样？</h4><p>由于 TCP 是双全⼯的协议，所以是会出现两⽅同时关闭连接的现象，也就是同时发送了 FIN 报⽂。<p>此时，上⾯介绍的优化策略仍然适⽤。两⽅发送 FIN 报⽂时，都认为⾃⼰是主动⽅，所以都进⼊了 FIN_WAIT1 状态，FIN 报⽂的᯿发次数仍由 tcp_orphan_retries 参数控制。<p><img alt=image-20210418205925842 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205925842.png?token=AIGEF3L2IHRNUBIAAQ46BKDEZZVF2><p>接下来，双⽅在等待 ACK 报⽂的过程中，都等来了 FIN 报⽂。这是⼀种新情况，所以连接会进⼊⼀种 叫做 CLOSING 的新状态，它替代了 FIN_WAIT2 状态。接着，双⽅内核回复 ACK 确认对⽅发送通道 的关闭后，进⼊ TIME_WAIT 状态，等待 2MSL 的时间后，连接⾃动关闭。<h3 id=5-2-3、小结><a class=headerlink href=#5-2-3、小结 title=5.2.3、小结></a>5.2.3、小结</h3><p>针对 TCP 四次挥⼿的优化，我们需要根据主动⽅和被动⽅四次挥⼿状态变化来调整系统 TCP 内核参数。<p><img alt=image-20210418210021774 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418210021774.png?token=AIGEF3NILLHJKEH27TJVW6DEZZVG2><h4 id=5-2-3-1、主动方优化><a class=headerlink href=#5-2-3-1、主动方优化 title=5.2.3.1、主动方优化></a>5.2.3.1、主动方优化</h4><p>主动发起 FIN 报⽂断开连接的⼀⽅，如果迟迟没收到对⽅的 ACK 回复，则会重传 FIN 报⽂，重传次数 由 tcp_orphan_retries 参数决定。<p>当主动⽅收到 ACK 报⽂后，连接就进⼊ FIN_WAIT2 状态，根据关闭的⽅式不同，优化的⽅式也不同：<ul><li>如果这是 close 函数关闭的连接，那么它就是孤⼉连接。如果 tcp_fin_timeout 秒内没有收到对 ⽅的 FIN 报⽂，连接就直接关闭。同时，为了应对孤⼉连接占⽤太多的资源， tcp_max_orphans 定义了最⼤孤⼉连接的数量，超过时连接就会直接释放。<li>反之是 shutdown 函数关闭的连接，则不受此参数限制；</ul><p>当主动⽅接收到 FIN 报⽂，并返回 ACK 后，主动⽅的连接进⼊ TIME_WAIT 状态。这⼀状态会持续 1 分钟，为了防⽌ TIME_WAIT 状态占⽤太多的资源， tcp_max_tw_buckets 定义了最⼤数量，超过时连 接也会直接释放。<p>当 TIME_WAIT 状态过多时，还可以通过设置 tcp_tw_reuse 和 tcp_timestamps 为 1 ，将 TIME_WAIT 状态的端⼝复⽤于作为客户端的新连接，注意该参数只适⽤于客户端。<h4 id=5-2-3-2、被动⽅的优化><a class=headerlink href=#5-2-3-2、被动⽅的优化 title=5.2.3.2、被动⽅的优化></a>5.2.3.2、被动⽅的优化</h4><p>被动关闭的连接⽅应对⾮常简单，它在回复 ACK 后就进⼊了 CLOSE_WAIT 状态，等待进程调⽤ close 函数关闭连接。因此，出现⼤量 CLOSE_WAIT 状态的连接时，应当从应⽤程序中找问题。<p>当被动⽅发送 FIN 报⽂后，连接就进⼊ LAST_ACK 状态，在未等到 ACK 时，会在 tcp_orphan_retries 参数的控制下重发 FIN 报⽂。<h2 id=5-3、提升TCP传输数据性能><a class=headerlink href=#5-3、提升TCP传输数据性能 title=5.3、提升TCP传输数据性能></a>5.3、提升TCP传输数据性能</h2><p>在前⾯介绍的是三次握⼿和四次挥⼿的优化策略，接下来主要介绍的是 TCP 传输数据时的优化策略。<p>TCP 连接由内核维护，内核会为每个连接建⽴内存缓冲区：<ul><li>如果连接的内存配置过⼩，就⽆法充分使⽤⽹络带宽，TCP 传输效率就会降低；<li>如果连接的内存配置过⼤，很容易把服务器资源耗尽，这样就会导致新连接⽆法建⽴；</ul><p>因此，我们必须理解 Linux 下 TCP 内存的⽤途，才能正确地配置内存⼤⼩。<h3 id=5-3-1、滑动窗⼝影响传输速度><a class=headerlink href=#5-3-1、滑动窗⼝影响传输速度 title=5.3.1、滑动窗⼝影响传输速度></a>5.3.1、滑动窗⼝影响传输速度</h3><p>TCP 会保证每⼀个报⽂都能够抵达对⽅，它的机制是：报⽂发出去后，必须接收到对⽅返回的确认报⽂ ACK，如果迟迟未收到，就会超时重发该报⽂，直到收到对⽅的 ACK 为⽌。<p>所以，TCP 报⽂发出去后，并不会⽴⻢从内存中删除，因为重传时还需要⽤到它。<p>由于 TCP 是内核维护的，所以报⽂存放在内核缓冲区。如果连接⾮常多，我们可以通过 free 命令观察到 buff/cache 内存是否增⼤。<p>如果 TCP 是每发送⼀个数据，都要进⾏⼀次确认应答。当上⼀个数据包收到了应答了， 再发送下⼀ 个。这个模式就有点像我和你⾯对⾯聊天，你⼀句我⼀句，但这种⽅式的缺点就是 效率很低。<p><img alt=image-20210418210742380 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418210742380.png?token=AIGEF3OFI37WZUHK74FQJ4LEZZVIA><p>所以，这样的传输⽅式有⼀个缺点：<strong>数据包的往返时间越⻓，通信的效率就越低</strong>。<p>要解决这⼀问题不难，并⾏批量发送报⽂，再批量确认报⽂即可。<p><img alt=image-20210418210838615 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418210838615.png?token=AIGEF3JNA7QROZIRJVZKGA3EZZVJI><p>然⽽，这引出了另⼀个问题，发送⽅可以随⼼所欲的发送报⽂吗？当然不行，我们还得考虑接收⽅的处理能⼒。<p>当接收⽅硬件不如发送⽅，或者系统繁忙、资源紧张时，是⽆法瞬间处理这么多报⽂的。于是，这些报 ⽂只能被丢掉，使得⽹络效率⾮常低。<p>为了解决这种现象发⽣，TCP 提供⼀种机制可以让「发送⽅」根据「接收⽅」的实际接收能⼒控制发送 的数据量，这就是滑动窗⼝的由来。<p>接收⽅根据它的缓冲区，可以计算出后续能够接收多少字节的报⽂，这个数字叫做接收窗⼝。当内核接 收到报⽂时，必须⽤缓冲区存放它们，这样剩余缓冲区空间变⼩，接收窗⼝也就变⼩了；当进程调⽤ read 函数后，数据被读⼊了⽤户空间，内核缓冲区就被清空，这意味着主机可以接收更多的报⽂，接收 窗⼝就会变⼤。<p>因此，接收窗⼝并不是恒定不变的，接收⽅会把当前可接收的⼤⼩放在 TCP 报⽂头部中的窗⼝字段， 这样就可以起到窗⼝⼤⼩通知的作⽤。<p>发送⽅的窗⼝等价于接收⽅的窗⼝吗？如果不考虑拥塞控制，发送⽅的窗⼝⼤⼩「约等于」接收⽅的窗⼝⼤⼩，因为窗⼝通知报⽂在⽹络传输是存在时延的，所以是约等于的关系。<p><img alt=image-20210418211048586 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418211048586.png?token=AIGEF3IOPQFQ3WYV3C6BLKDEZZVKO><p>从上图中可以看到，窗⼝字段只有 2 个字节，因此它最多能表达 65535 字节⼤⼩的窗⼝，也就是 64KB ⼤⼩。<p>这个窗⼝⼤⼩最⼤值，在当今⾼速⽹络下，很明显是不够⽤的。所以后续有了扩充窗⼝的⽅法：在 TCP 选项字段定义了窗⼝扩⼤因⼦，⽤于扩⼤ TCP 通告窗⼝，其值⼤⼩是 2^14，这样就使 TCP 的窗⼝⼤ ⼩从 16 位扩⼤为 30 位（2^16 * 2^ 14 = 2^30），所以此时窗⼝的最⼤值可以达到 1GB。<p><img alt=image-20210418211130135 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418211130135.png?token=AIGEF3KM5Z6JBRZWQT46ATLEZZVLS><p>Linux 中打开这⼀功能，需要把 <code>tcp_window_scaling</code> 配置设为 1（默认打开）：<p><img alt=image-20210418211148700 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418211148700.png?token=AIGEF3IJM24JBAGI3R5MYHDEZZVMS><p>要使⽤窗⼝扩⼤选项，通讯双⽅必须在各⾃的 SYN 报⽂中发送这个选项：<ul><li>主动建⽴连接的⼀⽅在 SYN 报⽂中发送这个选项；<li>⽽被动建⽴连接的⼀⽅只有在收到带窗⼝扩⼤选项的 SYN 报⽂之后才能发送这个选项。</ul><p>这样看来，只要进程能及时地调⽤ read 函数读取数据，并且接收缓冲区配置得⾜够⼤，那么接收窗⼝ 就可以⽆限地放⼤，发送⽅也就⽆限地提升发送速度。<p>这是不可能的，因为⽹络的传输能⼒是有限的，当发送⽅依据发送窗⼝，发送超过⽹络处理能⼒的报⽂ 时，路由器会直接丢弃这些报⽂。因此，缓冲区的内存并不是越⼤越好。<h3 id=5-3-2、确定最⼤传输速度><a class=headerlink href=#5-3-2、确定最⼤传输速度 title=5.3.2、确定最⼤传输速度></a>5.3.2、确定最⼤传输速度</h3><p>我们知道 TCP 的传输速度受制于发送窗⼝与接收窗⼝，以及⽹络设备传输能⼒。其中，窗⼝⼤⼩由内核缓冲区⼤⼩决定。如果缓冲区与⽹络传输能⼒匹配，那么缓冲区的利⽤率就达到了最⼤化。<p>问题来了，如何计算⽹络的传输能⼒呢？<p>相信⼤家都知道⽹络是有「带宽」限制的，带宽描述的是⽹络传输能⼒，它与内核缓冲区的计量单位不同：<ul><li>带宽是单位时间内的流量，表达是「速度」，⽐如常⻅的带宽 100 MB/s；<li>缓冲区单位是字节，当⽹络速度乘以时间才能得到字节数；</ul><p>这⾥需要说⼀个概念，就是带宽时延积，它决定⽹络中⻜⾏报⽂的⼤⼩，它的计算⽅式<p><img alt=image-20210418211558531 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418211558531.png?token=AIGEF3LAXJXBB2UQVRVMKZTEZZVN4><p>⽐如最⼤带宽是 100 MB/s，⽹络时延（RTT）是 10ms 时，意味着客户端到服务端的⽹络⼀共可以存 放 100MB/s * 0.01s = 1MB 的字节。<p>这个 1MB 是带宽和时延的乘积，所以它就叫「带宽时延积」（缩写为 BDP，Bandwidth Delay Product）。同时，这 1MB 也表示「⻜⾏中」的 TCP 报⽂⼤⼩，它们就在⽹络线路、路由器等⽹络设 备上。如果⻜⾏报⽂超过了 1 MB，就会导致⽹络过载，容易丢包。<p>由于发送缓冲区⼤⼩决定了发送窗⼝的上限，⽽发送窗⼝⼜决定了「已发送未确认」的⻜⾏报⽂的上 限。因此，发送缓冲区不能超过「带宽时延积」。<p>发送缓冲区与带宽时延积的关系：<ul><li>如果发送缓冲区「超过」带宽时延积，超出的部分就没办法有效的⽹络传输，同时导致⽹络过载， 容易丢包；<li>如果发送缓冲区「⼩于」带宽时延积，就不能很好的发挥出⽹络的传输效率。</ul><p>所以，发送缓冲区的⼤⼩最好是往带宽时延积靠近。<h3 id=5-3-3、调整缓冲区大小><a class=headerlink href=#5-3-3、调整缓冲区大小 title=5.3.3、调整缓冲区大小></a>5.3.3、调整缓冲区大小</h3><p>Linux中发送缓冲区和接收缓冲可⽤参数调节。设置完后，Linux 会根据你设置的缓冲区进⾏动态调节。<h4 id=5-3-3-1、调节发送缓冲区范围><a class=headerlink href=#5-3-3-1、调节发送缓冲区范围 title=5.3.3.1、调节发送缓冲区范围></a>5.3.3.1、调节发送缓冲区范围</h4><p>先来看看发送缓冲区，它的范围通过 <code>tcp_wmem</code> 参数配置；<p><img alt=image-20210418211755905 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418211755905.png?token=AIGEF3LEEIIBZJGXRG66WQLEZZVO6><p>上⾯三个数字单位都是字节，它们分别表示：<ul><li>第⼀个数值是动态范围的最⼩值，4096 byte = 4K；<li>第⼆个数值是初始默认值，87380 byte ≈ 86K；<li>第三个数值是动态范围的最⼤值，4194304 byte = 4096K（4M）；</ul><p>发送缓冲区是⾃⾏调节的，当发送⽅发送的数据被确认后，并且没有新的数据要发送，就会把发送缓冲区的内存释放掉。<h4 id=5-3-3-2、调节接收缓冲区范围><a class=headerlink href=#5-3-3-2、调节接收缓冲区范围 title=5.3.3.2、调节接收缓冲区范围></a>5.3.3.2、调节接收缓冲区范围</h4><p>⽽接收缓冲区的调整就⽐较复杂⼀些，先来看看设置接收缓冲区范围的 tcp_rmem 参数：<p><img alt=image-20230805103619338 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805103619338.png?token=AIGEF3PLZVBEFGJZGDTQLH3EZZVP6><p>上⾯三个数字单位都是字节，它们分别表示：<ul><li>第⼀个数值是动态范围的最⼩值，表示即使在内存压⼒下也可以保证的最⼩接收缓冲区⼤⼩，4096 byte = 4K；<li>第⼆个数值是初始默认值，87380 byte ≈ 86K；<li>第三个数值是动态范围的最⼤值，6291456 byte = 6144K（6M）；</ul><p>接收缓冲区可以根据系统空闲内存的⼤⼩来调节接收窗⼝：<ul><li>如果系统的空闲内存很多，就可以⾃动把缓冲区增⼤⼀些，这样传给对⽅的接收窗⼝也会变⼤，因 ⽽提升发送⽅发送的传输数据数量；<li>反之，如果系统的内存很紧张，就会减少缓冲区，这虽然会降低传输效率，可以保证更多的并发连 接正常⼯作；</ul><p>发送缓冲区的调节功能是⾃动开启的，⽽接收缓冲区则需要配置 <code>tcp_moderate_rcvbuf</code> 为 1 来开启调节功能：<p><img alt=image-20210418212006158 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418212006158.png?token=AIGEF3PV7PYPGEIURYGJ24LEZZVQ4><h4 id=5-3-3-3、调节-TCP-内存范围><a title="5.3.3.3、调节 TCP 内存范围" class=headerlink href=#5-3-3-3、调节-TCP-内存范围></a>5.3.3.3、调节 TCP 内存范围</h4><p>接收缓冲区调节时，怎么知道当前内存是否紧张或充分呢？这是通过 <code>tcp_mem</code> 配置完成的：<p><img alt=image-20210418212037121 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418212037121.png?token=AIGEF3KUWGGEUR7OLOSZG4DEZZVSQ><p>上⾯三个数字单位不是字节，⽽是「⻚⾯⼤⼩」，1 ⻚表示 4KB，它们分别表示：<ul><li>当 TCP 内存⼩于第 1 个值时，不需要进⾏⾃动调节；<li>在第 1 和第 2 个值之间时，内核开始调节接收缓冲区的⼤⼩；<li>⼤于第 3 个值时，内核不再为 TCP 分配新内存，此时新连接是⽆法建⽴的；</ul><p>⼀般情况下这些值是在系统启动时根据系统内存数量计算得到的。根据当前 <code>tcp_mem</code> 最⼤内存⻚⾯数是 177120，当内存为 (177120 * 4) / 1024K ≈ 692M 时，系统将⽆法为新的 TCP 连接分配内存，即 TCP 连接将被拒绝。<h4 id=5-3-3-4、根据实际场景调节的策略><a class=headerlink href=#5-3-3-4、根据实际场景调节的策略 title=5.3.3.4、根据实际场景调节的策略></a>5.3.3.4、根据实际场景调节的策略</h4><p>在⾼并发服务器中，为了兼顾⽹速与⼤量的并发连接，我们应当保证缓冲区的动态调整的最⼤值达到带宽时延积，⽽最⼩值保持默认的 4K 不变即可。⽽对于内存紧张的服务⽽⾔，调低默认值是提⾼并发的 有效⼿段。<p>同时，如果这是⽹络 IO 型服务器，那么，调⼤ <code>tcp_mem</code> 的上限可以让 TCP 连接使⽤更多的系统内存，这有利于提升并发能⼒。需要注意的是，<code>tcp_wmem</code> 和 <code>tcp_rmem</code> 的单位是字节，⽽ <code>tcp_mem</code> 的单位是⻚⾯⼤⼩。⽽且，千万不要在 socket 上直接设置 <code>SO_SNDBUF</code> 或者 <code>SO_RCVBUF</code>，这样会关闭缓冲区的动态调整功能。<h3 id=5-3-4、小结><a class=headerlink href=#5-3-4、小结 title=5.3.4、小结></a>5.3.4、小结</h3><p><img alt=image-20210418212216740 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418212216740.png?token=AIGEF3KQCLYZSR6Y7FSCUWLEZZVTW><p><strong>TCP 可靠性通过ACK确认报⽂实现，⼜依赖滑动窗⼝提升了发送速度也兼顾了接收⽅的处理能⼒</strong>。<p>可是，默认的滑动窗⼝最⼤值只有 64 KB，不满⾜当今的⾼速⽹络要求，要提升发送速度必须提升滑动窗⼝上限，在 Linux 下是通过设置 <code>tcp_window_scaling</code> 为 1 做到，此时最⼤值可⾼达 1GB。<p>滑动窗⼝定义了⽹络中⻜⾏报⽂的最⼤字节数，当它超过带宽时延积时，⽹络过载，就会发⽣丢包。⽽当它⼩于带宽时延积时，就⽆法充分利⽤⽹络带宽。因此，滑动窗⼝的设置，必须参考带宽时延积。<p>内核缓冲区决定了滑动窗⼝的上限，缓冲区可分为：发送缓冲区 <code>tcp_wmem</code> 和接收缓冲区 <code>tcp_rmem</code>。<p>Linux 会对缓冲区动态调节，我们应该把缓冲区的上限设置为带宽时延积。发送缓冲区的调节功能是⾃ 动打开的，⽽接收缓冲区需要把 <code>tcp_moderate_rcvbuf</code> 设置为 1 来开启。其中，调节的依据是 TCP 内存范围 <code>tcp_mem</code>。<p>但需要注意的是，如果程序中的 socket 设置了 <code>SO_SNDBUF</code> 和 <code>SO_RCVBUF</code>，则会关闭缓冲区的动态调整功能，所以不建议在程序中设置它们，⽽是交给内核⾃动调整⽐较好。<p>有效配置这些参数后，既能够最⼤程度地保持并发性，也能让资源充裕时连接传输速度达到最⼤值。</div><footer class=post-footer><div class=post-tags><a href=/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/ rel=tag># 网络协议</a><a href=/tags/TCP/ rel=tag># TCP</a></div><div class=post-nav><div class=post-nav-item><a href=/2024/08/21/Spring%E4%BA%8B%E5%8A%A1/ rel=prev title=Spring系列-Spring事务> <i class="fa fa-angle-left"></i> Spring系列-Spring事务 </a></div><div class=post-nav-item><a href=/2024/08/21/Spring%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/ rel=next title=Spring系列-Spring原理解析> Spring系列-Spring原理解析 <i class="fa fa-angle-right"></i> </a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script>