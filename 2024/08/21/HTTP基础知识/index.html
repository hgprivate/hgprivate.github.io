<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hshz21.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="1、HTTP必知1.1、啥是HTTPHTTP 是 HyperText Transfer Protocol 的缩写，超⽂本传输协议。 超⽂本传输协议可拆分为三个部分：超⽂本、传输、协议。 1.1.1、超文本HTTP传输的内容是超⽂本。  ⽂本：在互联⽹早期时只是简单的字符⽂字，但现在的含义已经可以扩展为图⽚、视频、压缩包等，在 HTTP 眼⾥这些都算作⽂本。  超⽂本：超越了普通⽂本的⽂本，它是⽂字" name=description><meta content=article property=og:type><meta content=计算机系列-HTTP基础知识 property=og:title><meta content=https://hshz21.gitee.io/2024/08/21/HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content="1、HTTP必知1.1、啥是HTTPHTTP 是 HyperText Transfer Protocol 的缩写，超⽂本传输协议。 超⽂本传输协议可拆分为三个部分：超⽂本、传输、协议。 1.1.1、超文本HTTP传输的内容是超⽂本。  ⽂本：在互联⽹早期时只是简单的字符⽂字，但现在的含义已经可以扩展为图⽚、视频、压缩包等，在 HTTP 眼⾥这些都算作⽂本。  超⽂本：超越了普通⽂本的⽂本，它是⽂字" property=og:description><meta content=zh_CN property=og:locale><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805094440407.png?token=AIGEF3MNNEBKKP2VOUZ45SDEZZNHW property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415173330840.png?token=AIGEF3LWYPYIFXOCK23HHETEZZOHI property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415173628892.png?token=AIGEF3JEZCLCLR2WACWIMG3EZZPPM property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415173849046.png?token=AIGEF3N7PSIDEUUTQSL4Q3TEZZPQA property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415173517081.png?token=AIGEF3OXJ6KPF746WLYMBLDEZZPQS property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415174030419.png?token=AIGEF3NROJQIG5QLYSPNEXTEZZPRI property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/http%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%8401.jpg?token=AIGEF3MVXDHXPPWAYO4262TEZZPR6 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E8%AF%B7%E6%B1%82%E8%A1%8C-%E8%AF%B7%E6%B1%82%E5%9C%B0%E5%9D%80%E5%9B%BE%E7%A4%BA.jpg?token=AIGEF3LVUQOTQAUZJWSARH3EZZPTA property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%9B%BE%E7%A4%BA.jpg?token=AIGEF3LUS5OXWSK7DEGAWVLEZZPTQ property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/HTTP%E5%93%8D%E5%BA%94%E6%95%B4%E4%BD%93%E5%9B%BE%E7%A4%BA.jpg?token=AIGEF3JLOBG3WTMHBSSYPBTEZZPUE property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E5%93%8D%E5%BA%94%E5%A4%B4%E5%9B%BE%E7%A4%BA.jpg?token=AIGEF3LTW4EZZIYMTCXXFJTEZZPWY property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415180426292.png?token=AIGEF3ORLSC3ZA2BLR5LH43EZZP3I property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415180822708.png?token=AIGEF3M37TWIAH6H5LR25WTEZZP34 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415182015246.png?token=AIGEF3IWSVAJ73UNNB4TXE3EZZP5Y property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415182326356.png?token=AIGEF3I4JU5HIWM3DDG72FLEZZP6Q property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415182616713.png?token=AIGEF3OHAOIT7PDXSJUVURTEZZP7G property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415183012254.png?token=AIGEF3KKEW4DNJEU4UAEHYTEZZP74 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415183132165.png?token=AIGEF3PK45S4GR7EE3YWP4LEZZQAQ property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415184254532.png?token=AIGEF3LQDA677F2OTIUQVNLEZZQBS property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415184608092.png?token=AIGEF3OR5RKZEEJUHVEWHZDEZZQCE property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415185214946.png?token=AIGEF3LH2DFTTVDUAOCE3WTEZZQDA property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805095840581.png?token=AIGEF3IQMU723LDXPVNHQ3LEZZPLK property=og:image><meta content=2024-08-21T13:39:13.735Z property=article:published_time><meta content=2023-10-06T13:08:45.157Z property=article:modified_time><meta content=豪哥 property=article:author><meta content=网络协议 property=article:tag><meta content=HTTP property=article:tag><meta content=summary name=twitter:card><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805094440407.png?token=AIGEF3MNNEBKKP2VOUZ45SDEZZNHW name=twitter:image><link href=https://hshz21.gitee.io/2024/08/21/HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hshz21.gitee.io/2024/08/21/HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","path":"2024/08/21/HTTP基础知识/","title":"计算机系列-HTTP基础知识"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>计算机系列-HTTP基础知识 | 豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>豪哥博客</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#1%E3%80%81HTTP%E5%BF%85%E7%9F%A5><span class=nav-number>1.</span> <span class=nav-text>1、HTTP必知</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81%E5%95%A5%E6%98%AFHTTP><span class=nav-number>1.1.</span> <span class=nav-text>1.1、啥是HTTP</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-1%E3%80%81%E8%B6%85%E6%96%87%E6%9C%AC><span class=nav-number>1.1.1.</span> <span class=nav-text>1.1.1、超文本</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-2%E3%80%81%E4%BC%A0%E8%BE%93><span class=nav-number>1.1.2.</span> <span class=nav-text>1.1.2、传输</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-3%E3%80%81%E5%8D%8F%E8%AE%AE><span class=nav-number>1.1.3.</span> <span class=nav-text>1.1.3、协议</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-2%E3%80%81HTTP%E7%8A%B6%E6%80%81%E7%A0%81><span class=nav-number>1.2.</span> <span class=nav-text>1.2、HTTP状态码</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-3%E3%80%81HTTP%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%AD%97%E6%AE%B5><span class=nav-number>1.3.</span> <span class=nav-text>1.3、HTTP请求头字段</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-1%E3%80%81user-agent%EF%BC%88%E8%AF%B7%E6%B1%82%E5%8F%91%E9%80%81%E6%96%B9-%E8%B0%81%E5%8F%91%E7%9A%84%EF%BC%89><span class=nav-number>1.3.1.</span> <span class=nav-text>1.3.1、user-agent（请求发送方 - 谁发的）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-2%E3%80%81HOST%EF%BC%88%E8%AF%B7%E6%B1%82%E6%8E%A5%E6%94%B6%E6%96%B9-%E5%8F%91%E7%BB%99%E8%B0%81%EF%BC%89><span class=nav-number>1.3.2.</span> <span class=nav-text>1.3.2、HOST（请求接收方 - 发给谁）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-3%E3%80%81Connection%EF%BC%88%E4%BD%BF%E7%94%A8%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5%EF%BC%89><span class=nav-number>1.3.3.</span> <span class=nav-text>1.3.3、Connection（使用持久连接）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-4%E3%80%81Content-Type%EF%BC%88%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%EF%BC%89><span class=nav-number>1.3.4.</span> <span class=nav-text>1.3.4、Content-Type（响应数据格式）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-5%E3%80%81Content-Length%EF%BC%88%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6%EF%BC%89><span class=nav-number>1.3.5.</span> <span class=nav-text>1.3.5、Content-Length（响应数据长度）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-6%E3%80%81Content-Encoding%EF%BC%88%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%8B%E7%BC%A9%E6%A0%BC%E5%BC%8F%EF%BC%89><span class=nav-number>1.3.6.</span> <span class=nav-text>1.3.6、Content-Encoding（响应数据的压缩格式）</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-4%E3%80%81HTTP%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94><span class=nav-number>1.4.</span> <span class=nav-text>1.4、HTTP请求和响应</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-1%E3%80%81HTTP%E8%AF%B7%E6%B1%82><span class=nav-number>1.4.1.</span> <span class=nav-text>1.4.1、HTTP请求</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-2%E3%80%81HTTP%E5%93%8D%E5%BA%94><span class=nav-number>1.4.2.</span> <span class=nav-text>1.4.2、HTTP响应</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-3%E3%80%81%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5><span class=nav-number>1.4.3.</span> <span class=nav-text>1.4.3、关闭连接</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#2%E3%80%81GET%E4%B8%8EPOST><span class=nav-number>2.</span> <span class=nav-text>2、GET与POST</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#2-1%E3%80%81GET%E4%B8%8EPOST%E5%8C%BA%E5%88%AB><span class=nav-number>2.1.</span> <span class=nav-text>2.1、GET与POST区别</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-2%E3%80%81GET%E4%B8%8EPOST%E7%9A%84%E5%AE%89%E5%85%A8%E5%92%8C%E5%B9%82%E7%AD%89><span class=nav-number>2.2.</span> <span class=nav-text>2.2、GET与POST的安全和幂等</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-1%E3%80%81%E5%AE%89%E5%85%A8%E5%92%8C%E5%B9%82%E7%AD%89%E6%A6%82%E5%BF%B5><span class=nav-number>2.2.1.</span> <span class=nav-text>2.2.1、安全和幂等概念</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-2%E3%80%81GET%E5%AE%89%E5%85%A8%E4%B8%8E%E5%B9%82%E7%AD%89><span class=nav-number>2.2.2.</span> <span class=nav-text>2.2.2、GET安全与幂等</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-3%E3%80%81POST%E5%AE%89%E5%85%A8%E4%B8%8E%E5%B9%82%E7%AD%89><span class=nav-number>2.2.3.</span> <span class=nav-text>2.2.3、POST安全与幂等</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#3%E3%80%81HTTP%E7%89%B9%E6%80%A7><span class=nav-number>3.</span> <span class=nav-text>3、HTTP特性</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#3-1%E3%80%81HTTP1-1%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9><span class=nav-number>3.1.</span> <span class=nav-text>3.1、HTTP1.1优点与缺点</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-1%E3%80%81%E4%BC%98%E7%82%B9><span class=nav-number>3.1.1.</span> <span class=nav-text>3.1.1、优点</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-2%E3%80%81%E7%BC%BA%E7%82%B9><span class=nav-number>3.1.2.</span> <span class=nav-text>3.1.2、缺点</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-2%E3%80%81HTTP1-1%E6%80%A7%E8%83%BD><span class=nav-number>3.2.</span> <span class=nav-text>3.2、HTTP1.1性能</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-2-1%E3%80%81%E9%95%BF%E8%BF%9E%E6%8E%A5><span class=nav-number>3.2.1.</span> <span class=nav-text>3.2.1、长连接</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-2-2%E3%80%81%E7%AE%A1%E9%81%93%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93><span class=nav-number>3.2.2.</span> <span class=nav-text>3.2.2、管道网络传输</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-2-3%E3%80%81%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E><span class=nav-number>3.2.3.</span> <span class=nav-text>3.2.3、队头阻塞</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#4%E3%80%81HTTP%E4%B8%8EHTTPS><span class=nav-number>4.</span> <span class=nav-text>4、HTTP与HTTPS</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#4-1%E3%80%81HTTP%E4%B8%8EHTTPS%E5%8C%BA%E5%88%AB><span class=nav-number>4.1.</span> <span class=nav-text>4.1、HTTP与HTTPS区别</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#4-2%E3%80%81HTTPS%E8%A7%A3%E5%86%B3%E4%BA%86HTTP%E9%82%A3%E4%BA%9B%E9%97%AE%E9%A2%98><span class=nav-number>4.2.</span> <span class=nav-text>4.2、HTTPS解决了HTTP那些问题</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#4-3%E3%80%81HTTPS%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86><span class=nav-number>4.3.</span> <span class=nav-text>4.3、HTTPS加密原理</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-3-1%E3%80%81%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86><span class=nav-number>4.3.1.</span> <span class=nav-text>4.3.1、混合加密</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-3-2%E3%80%81%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95><span class=nav-number>4.3.2.</span> <span class=nav-text>3.3.2、摘要算法</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-3-3%E3%80%81%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6><span class=nav-number>4.3.3.</span> <span class=nav-text>4.3.3、数字证书</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#4-4%E3%80%81HTTPS%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5><span class=nav-number>4.4.</span> <span class=nav-text>4.4、HTTPS如何建立连接</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-4-1%E3%80%81SSL-TLS%E5%8D%8F%E8%AE%AE%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B><span class=nav-number>4.4.1.</span> <span class=nav-text>4.4.1、SSL/TLS协议基本流程</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-4-2%E3%80%81SSL-TLS%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B><span class=nav-number>4.4.2.</span> <span class=nav-text>4.4.2、SSL/TLS协议详细流程</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#5%E3%80%81HTTP%E7%89%88%E6%9C%AC%E6%BC%94%E5%8F%98><span class=nav-number>5.</span> <span class=nav-text>5、HTTP版本演变</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#5-1%E3%80%81HTTP-1-0><span class=nav-number>5.1.</span> <span class=nav-text>5.1、HTTP/1.0</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#5-2%E3%80%81HTTP-1-1><span class=nav-number>5.2.</span> <span class=nav-text>5.2、HTTP/1.1</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#5-3%E3%80%81HTTP-2><span class=nav-number>5.3.</span> <span class=nav-text>5.3、HTTP/2</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#5-3-1%E3%80%81HTTP-2%E6%A6%82%E8%BF%B0><span class=nav-number>5.3.1.</span> <span class=nav-text>5.3.1、HTTP/2概述</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#5-3-1-1%E3%80%81%E5%A4%B4%E9%83%A8%E5%8E%8B%E7%BC%A9><span class=nav-number>5.3.1.1.</span> <span class=nav-text>5.3.1.1、头部压缩</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-3-1-2%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A0%BC%E5%BC%8F><span class=nav-number>5.3.1.2.</span> <span class=nav-text>5.3.1.2、二进制格式</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-3-1-3%E3%80%81%E6%95%B0%E6%8D%AE%E6%B5%81><span class=nav-number>5.3.1.3.</span> <span class=nav-text>5.3.1.3、数据流</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-3-1-4%E3%80%81%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8><span class=nav-number>5.3.1.4.</span> <span class=nav-text>5.3.1.4、多路复用</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-3-1-5%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81><span class=nav-number>5.3.1.5.</span> <span class=nav-text>5.3.1.5、服务器推送</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#5-3-2%E3%80%81HTTP-2%E7%BC%BA%E9%99%B7><span class=nav-number>5.3.2.</span> <span class=nav-text>5.3.2、HTTP/2缺陷</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#5-4%E3%80%81HTTP3><span class=nav-number>5.4.</span> <span class=nav-text>5.4、HTTP3</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#5-5%E3%80%81%E5%B0%8F%E6%80%BB%E7%BB%93><span class=nav-number>5.5.</span> <span class=nav-text>5.5、小总结</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#5-5-1%E3%80%81Http1-0-VS-Htpp1-1><span class=nav-number>5.5.1.</span> <span class=nav-text>5.5.1、Http1.0 VS Htpp1.1</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#5-5-2%E3%80%81Http1-1-VS-Htpp2><span class=nav-number>5.5.2.</span> <span class=nav-text>5.5.2、Http1.1 VS Htpp2</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#6%E3%80%81HTTP-TCP-Keep-Alive><span class=nav-number>6.</span> <span class=nav-text>6、HTTP/TCP Keep-Alive</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#6-1%E3%80%81HTTP-Keep-Alive><span class=nav-number>6.1.</span> <span class=nav-text>6.1、HTTP Keep-Alive</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#6-1-1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88HTTP%E6%98%AF%E7%9F%AD%E8%BF%9E%E6%8E%A5><span class=nav-number>6.1.1.</span> <span class=nav-text>6.1.1、为什么HTTP是短连接</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#6-1-2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5keep-alive><span class=nav-number>6.1.2.</span> <span class=nav-text>6.1.2、为什么要引入keep-alive</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#6-1-3%E3%80%81Server%E7%AB%AF%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Keep-Alive><span class=nav-number>6.1.3.</span> <span class=nav-text>6.1.3、Server端如何处理Keep-Alive</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#6-1-4%E3%80%81JDK%E5%AF%B9keep-alive%E7%9A%84%E6%94%AF%E6%8C%81><span class=nav-number>6.1.4.</span> <span class=nav-text>6.1.4、JDK对keep-alive的支持</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#6-2%E3%80%81TCP-Keep-Alive><span class=nav-number>6.2.</span> <span class=nav-text>6.2、TCP Keep-Alive</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#6-2-1%E3%80%81TCP-Keep-Alive%E6%8E%A2%E9%92%88><span class=nav-number>6.2.1.</span> <span class=nav-text>6.2.1、TCP Keep-Alive探针</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#6-2-2%E3%80%81TCP-Keep-Alive%E7%BC%BA%E7%82%B9><span class=nav-number>6.2.2.</span> <span class=nav-text>6.2.2、TCP Keep-Alive缺点</span></a></ol></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>116</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>35</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>128</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://hshz21.gitee.io/2024/08/21/HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="计算机系列-HTTP基础知识 | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>计算机系列-HTTP基础知识</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-06 21:08:45" datetime=2023-10-06T21:08:45+08:00 itemprop=dateModified>2023-10-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/ itemprop=url rel=index><span itemprop=name>计算机</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、HTTP必知><a class=headerlink href=#1、HTTP必知 title=1、HTTP必知></a>1、HTTP必知</h1><h2 id=1-1、啥是HTTP><a class=headerlink href=#1-1、啥是HTTP title=1.1、啥是HTTP></a>1.1、啥是HTTP</h2><p><strong>HTTP 是 HyperText Transfer Protocol 的缩写，超⽂本传输协议</strong>。<p>超⽂本传输协议可拆分为三个部分：超⽂本、传输、协议。<h3 id=1-1-1、超文本><a class=headerlink href=#1-1-1、超文本 title=1.1.1、超文本></a>1.1.1、超文本</h3><p><strong>HTTP传输的内容是超⽂本</strong>。<ul><li><p>⽂本：在互联⽹早期时只是简单的字符⽂字，但现在的含义已经可以扩展为图⽚、视频、压缩包等，在 HTTP 眼⾥这些都算作⽂本。</p><li><p>超⽂本：超越了普通⽂本的⽂本，它是⽂字、图⽚、视频等的混合体，最关键有超链接，能从⼀个超⽂本跳转到另外⼀个超⽂本。</p> <p>HTML 就是最常⻅的超⽂本了，它本身只是纯⽂字⽂件，但内部⽤很多标签定义了图⽚、视频等的链接，再经过浏览器的解释，呈现给我们的就是⼀个有⽂字、有画⾯的⽹⻚。</p></ul><p><strong>HTTP是计算机间传输⽂字、图⽚、⾳频、视频等超⽂本数据的约定和规范</strong>。<h3 id=1-1-2、传输><a class=headerlink href=#1-1-2、传输 title=1.1.2、传输></a>1.1.2、传输</h3><p>传输包含两项信息：<ol><li>HTTP 协议是⼀个双向协议。<li>数据虽然是在 A 和 B 之间传输，但允许中间有中转或接⼒。</ol><p>HTTP 是计算机中两点之间传输数据的约定和规范。<h3 id=1-1-3、协议><a class=headerlink href=#1-1-3、协议 title=1.1.3、协议></a>1.1.3、协议</h3><p>HTTP是计算机世界中的协议。它确⽴了计算机之间交流通信的规范，以及相关的各种控制和错误处理⽅式（⾏为约定和规范）。<h2 id=1-2、HTTP状态码><a class=headerlink href=#1-2、HTTP状态码 title=1.2、HTTP状态码></a>1.2、HTTP状态码</h2><p><img alt=image-20230805094440407.png src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805094440407.png?token=AIGEF3MNNEBKKP2VOUZ45SDEZZNHW><h2 id=1-3、HTTP请求头字段><a class=headerlink href=#1-3、HTTP请求头字段 title=1.3、HTTP请求头字段></a>1.3、HTTP请求头字段</h2><h3 id=1-3-1、user-agent（请求发送方-谁发的）><a title="1.3.1、user-agent（请求发送方 - 谁发的）" class=headerlink href=#1-3-1、user-agent（请求发送方-谁发的）></a>1.3.1、user-agent（请求发送方 - 谁发的）</h3><h3 id=1-3-2、HOST（请求接收方-发给谁）><a title="1.3.2、HOST（请求接收方 - 发给谁）" class=headerlink href=#1-3-2、HOST（请求接收方-发给谁）></a>1.3.2、HOST（请求接收方 - 发给谁）</h3><p><strong>客户端发送请求时，⽤来指定服务器的域名</strong>。<p><img alt=image-20210415173330840 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415173330840.png?token=AIGEF3LWYPYIFXOCK23HHETEZZOHI><p>有了 Host 字段，就可以将请求发往同⼀台服务器上的不同⽹站。<h3 id=1-3-3、Connection（使用持久连接）><a class=headerlink href=#1-3-3、Connection（使用持久连接） title=1.3.3、Connection（使用持久连接）></a>1.3.3、Connection（使用持久连接）</h3><p><strong>Connection字段用于告知服务器使⽤ TCP 持久连接，以便其他请求复⽤</strong>。<p><img alt=image-20210415173628892 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415173628892.png?token=AIGEF3JEZCLCLR2WACWIMG3EZZPPM><p>HTTP/1.1 版本的默认连接都是持久连接，但为了兼容⽼版本的 HTTP，需要指定 Connection ⾸部字段的值为 Keep-Alive 。 ⼀个可以复⽤的 TCP 连接就建⽴了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。<h3 id=1-3-4、Content-Type（响应数据格式）><a class=headerlink href=#1-3-4、Content-Type（响应数据格式） title=1.3.4、Content-Type（响应数据格式）></a>1.3.4、Content-Type（响应数据格式）</h3><p><strong>Content-Type字段⽤于告诉客户端，本次数据是什么格式</strong>。<p><img alt=image-20210415173849046 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415173849046.png?token=AIGEF3N7PSIDEUUTQSL4Q3TEZZPQA><p>上⾯的类型表明，发送的是⽹⻚，⽽且编码是UTF-8。 客户端请求的时候，可以使⽤ Accept 字段声明⾃⼰可以接受哪些数据格式。<figure class="highlight http"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line># 客户端声明⾃⼰可以接受任何格式的数据</span><br><span class=line>Accept：*/*</span><br></pre></table></figure><h3 id=1-3-5、Content-Length（响应数据长度）><a class=headerlink href=#1-3-5、Content-Length（响应数据长度） title=1.3.5、Content-Length（响应数据长度）></a>1.3.5、Content-Length（响应数据长度）</h3><p><strong>Content-Length 字段用于表示服务端响应数据的⻓度</strong>。<p><img alt=image-20210415173517081 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415173517081.png?token=AIGEF3OXJ6KPF746WLYMBLDEZZPQS><p>比如，上⾯就是告诉浏览器，本次服务器回应的数据⻓度是 1000 个字节，后⾯的字节就属于下⼀个回应了。<h3 id=1-3-6、Content-Encoding（响应数据的压缩格式）><a class=headerlink href=#1-3-6、Content-Encoding（响应数据的压缩格式） title=1.3.6、Content-Encoding（响应数据的压缩格式）></a>1.3.6、Content-Encoding（响应数据的压缩格式）</h3><p><strong>Content-Encoding字段用于表示服务器返回的数据使⽤了什么压缩格式</strong>。<p><img alt=image-20210415174030419 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415174030419.png?token=AIGEF3NROJQIG5QLYSPNEXTEZZPRI><p>上⾯表示服务器返回的数据采⽤了 gzip ⽅式压缩，告知客户端需要⽤此⽅式解压。 客户端在请求时，⽤ Accept-Encoding 字段说明⾃⼰可以接受哪些压缩⽅法。<h2 id=1-4、HTTP请求和响应><a class=headerlink href=#1-4、HTTP请求和响应 title=1.4、HTTP请求和响应></a>1.4、HTTP请求和响应</h2><h3 id=1-4-1、HTTP请求><a class=headerlink href=#1-4-1、HTTP请求 title=1.4.1、HTTP请求></a>1.4.1、HTTP请求</h3><p><strong>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行 和 请求数据 4个部分组成</strong>，请求报文的一般格式如下图：<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/http%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%8401.jpg?token=AIGEF3MVXDHXPPWAYO4262TEZZPR6><p>下面针对每一项进行分析：<p><strong>（1）请求行</strong><p><strong>请求行分为三个部分：请求方式、请求地址和协议版本</strong>。<ol><li><p><font color=orange>请求方式</font></p> <p>HTTP/1.1 定义的请求方式有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</p> <p>最常的两种GET和POST，如果是RestFul接口，则一般会用到GET、POST、DELETE、PUT。</p><li><p><font color=orange>请求地址</font></p> <p>组成：<协议>：//<主机>：<端口>/<路径></p> <p>端口和路径有时可以省略（HTTP默认端口号是80）：</p> <p><img alt=img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E8%AF%B7%E6%B1%82%E8%A1%8C-%E8%AF%B7%E6%B1%82%E5%9C%B0%E5%9D%80%E5%9B%BE%E7%A4%BA.jpg?token=AIGEF3LVUQOTQAUZJWSARH3EZZPTA></p><li><p><font color=orange>协议版本</font></p> <p>协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1。</p></ol><p>请求行示例如下：<figure class="highlight http"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>POST /index.php　HTTP/1.1</span><br></pre></table></figure><p><strong>（2）请求头</strong><p>请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。<p>常见请求头如下：<p><img alt=img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%9B%BE%E7%A4%BA.jpg?token=AIGEF3LUS5OXWSK7DEGAWVLEZZPTQ><p>请求头示例如下：<figure class="highlight http"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=attribute>Host</span><span class=punctuation>: </span>localhost</span><br><span class=line><span class=attribute>User-Agent</span><span class=punctuation>: </span>Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2</span><br><span class=line><span class=attribute>Accept</span><span class=punctuation>: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class=line><span class=attribute>Accept-Language</span><span class=punctuation>: </span>zh-cn,zh;q=0.5</span><br><span class=line><span class=attribute>Accept-Encoding</span><span class=punctuation>: </span>gzip, deflate</span><br><span class=line><span class=attribute>Connection</span><span class=punctuation>: </span>keep-alive</span><br><span class=line><span class=attribute>Referer</span><span class=punctuation>: </span>[http://localhost/](https://link.jianshu.com?t=http://localhost/)</span><br><span class=line>Content-Length：25</span><br><span class=line>Content-Type：application/x-www-form-urlencoded</span><br></pre></table></figure><p><strong>（3）空行</strong><p>空行用于隔离请求头和请求体，否则服务器无法解析请求信息。<p><strong>（4）请求数据</strong><p>可选部分，比如GET请求就没有请求数据。<p>请求数据示例：<figure class="highlight http"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>username=aa&password=1234</span><br></pre></table></figure><h3 id=1-4-2、HTTP响应><a class=headerlink href=#1-4-2、HTTP响应 title=1.4.2、HTTP响应></a>1.4.2、HTTP响应</h3><p><strong>HTTP响应报文主要由 状态行、响应头、空行 和 响应数据 组成</strong>。结构如下图所示：<p><img alt=img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/HTTP%E5%93%8D%E5%BA%94%E6%95%B4%E4%BD%93%E5%9B%BE%E7%A4%BA.jpg?token=AIGEF3JLOBG3WTMHBSSYPBTEZZPUE><p>下面针对每一项进行分析：<p><strong>（1）状态行</strong><p><strong>状态行由协议版本，状态码，状态码描述3部分组成</strong>。<p>其中协议版本与请求报文一致，状态码描述是对状态码的简单描述。<p>状态码分类如下：<table><thead><tr><th align=left>分类<th align=left>分类描述<tbody><tr><td align=left>1**<td align=left>信息，服务器收到请求，需要请求者继续执行操作。<tr><td align=left>2**<td align=left>成功，操作被成功接收并处理。<tr><td align=left>3**<td align=left>重定向，需要进一步的操作以完成请求。<tr><td align=left>4**<td align=left>客户端错误，请求包含语法错误或无法完成请求。<tr><td align=left>5**<td align=left>服务器错误，服务器在处理请求的过程中发生了错误。</table><p>常见状态如下所示：<ul><li>200：响应成功。<li>302：跳转，其跳转地址通过响应头中的location属性来指定。<li>400：客户端请求有语法错误，不能被服务器识别。<li>403：服务器接收到请求，但拒绝提供服务（认证失败）。<li>404：请求资源不存在。<li>500：服务器内部错误。</ul><p>状态行示例如下：<figure class="highlight http"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=meta>HTTP/1.1</span> <span class=number>200</span> OK</span><br></pre></table></figure><p><strong>（2）响应头</strong><p>与请求头部类似，为响应报文添加了一些附加信息。<p>常见响应头部如下：<p><img alt=img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E5%93%8D%E5%BA%94%E5%A4%B4%E5%9B%BE%E7%A4%BA.jpg?token=AIGEF3LTW4EZZIYMTCXXFJTEZZPWY><p>响应头示例如下：<figure class="highlight http"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=attribute>Date</span><span class=punctuation>: </span>Sun, 17 Mar 2013 08:12:54 GMT</span><br><span class=line><span class=attribute>Server</span><span class=punctuation>: </span>Apache/2.2.8 (Win32) PHP/5.2.5</span><br><span class=line><span class=attribute>X-Powered-By</span><span class=punctuation>: </span>PHP/5.2.5</span><br><span class=line><span class=attribute>Set-Cookie</span><span class=punctuation>: </span>PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/</span><br><span class=line><span class=attribute>Expires</span><span class=punctuation>: </span>Thu, 19 Nov 1981 08:52:00 GMT</span><br><span class=line><span class=attribute>Cache-Control</span><span class=punctuation>: </span>no-store, no-cache, must-revalidate, post-check=0, pre-check=0</span><br><span class=line><span class=attribute>Pragma</span><span class=punctuation>: </span>no-cache</span><br><span class=line><span class=attribute>Content-Length</span><span class=punctuation>: </span>4393</span><br><span class=line><span class=attribute>Keep-Alive</span><span class=punctuation>: </span>timeout=5, max=100</span><br><span class=line><span class=attribute>Connection</span><span class=punctuation>: </span>Keep-Alive</span><br><span class=line><span class=attribute>Content-Type</span><span class=punctuation>: </span>text/html; charset=utf-8</span><br></pre></table></figure><p><strong>（3）空行</strong><p>至关重要，不能缺少。与请求中空行作用类似。<p><strong>（4）响应数据</strong><p>用于存放需要返回给客户端的数据信息。<p>响应数据示例：<figure class="highlight http"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>&LThtml></span><br><span class=line>    &LThead></span><br><span class=line>    &LTtitle>HTTP响应示例&LTtitle></span><br><span class=line>    &LT/head></span><br><span class=line>    &LTbody></span><br><span class=line>    Hello HTTP!</span><br><span class=line>    &LT/body></span><br><span class=line>&LT/html></span><br></pre></table></figure><p>通过以上步骤，数据已经传递完毕。HTTP/1.1会维持持久连接一段时间后才会关闭。<h3 id=1-4-3、关闭连接><a class=headerlink href=#1-4-3、关闭连接 title=1.4.3、关闭连接></a>1.4.3、关闭连接</h3><p><strong>客户端或服务端都可以关闭连接。每个请求都使用一个单独的网络连接</strong>。<p><font color=red>注意：服务器不会记住之前的连接处理状态，这种不记忆过去请求状态的协议称为无状态(stateless)协议。</font><h1 id=2、GET与POST><a class=headerlink href=#2、GET与POST title=2、GET与POST></a>2、GET与POST</h1><h2 id=2-1、GET与POST区别><a class=headerlink href=#2-1、GET与POST区别 title=2.1、GET与POST区别></a>2.1、GET与POST区别</h2><ul><li>GET：GET ⽅法是请求从服务器获取资源，这个资源可以是静态的⽂本、⻚⾯、图⽚视频等。<li>POST：POST ⽅法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报⽂的 body ⾥。</ul><h2 id=2-2、GET与POST的安全和幂等><a class=headerlink href=#2-2、GET与POST的安全和幂等 title=2.2、GET与POST的安全和幂等></a>2.2、GET与POST的安全和幂等</h2><h3 id=2-2-1、安全和幂等概念><a class=headerlink href=#2-2-1、安全和幂等概念 title=2.2.1、安全和幂等概念></a>2.2.1、安全和幂等概念</h3><p>安全：<strong>请求⽅法不会「破坏」服务器上的资源</strong>。<p>幂等：<strong>多次执⾏相同的操作，其结果与执行一次的结果相同</strong>。<h3 id=2-2-2、GET安全与幂等><a class=headerlink href=#2-2-2、GET安全与幂等 title=2.2.2、GET安全与幂等></a>2.2.2、GET安全与幂等</h3><p>GET⽅法安全且幂等，因为它是只读操作，⽆论操作多少次，服务器上的数据都是安全的，且每次结果都相同。<h3 id=2-2-3、POST安全与幂等><a class=headerlink href=#2-2-3、POST安全与幂等 title=2.2.3、POST安全与幂等></a>2.2.3、POST安全与幂等</h3><p>POST方法非安全非幂等，因为是新增或提交数据的操作，会创建和修改服务器上的资源，所以非安全非幂等。<h1 id=3、HTTP特性><a class=headerlink href=#3、HTTP特性 title=3、HTTP特性></a>3、HTTP特性</h1><h2 id=3-1、HTTP1-1优点与缺点><a class=headerlink href=#3-1、HTTP1-1优点与缺点 title=3.1、HTTP1.1优点与缺点></a>3.1、HTTP1.1优点与缺点</h2><h3 id=3-1-1、优点><a class=headerlink href=#3-1-1、优点 title=3.1.1、优点></a>3.1.1、优点</h3><p><strong>HTTP 突出优点是简单、灵活、易扩展、跨平台、应用广泛</strong>。<ol><li><p>简单：HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式，易于理解， 降低了学习和使⽤的⻔槛。</p><li><p>灵活易扩展：HTTP协议⾥的各类请求⽅法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开 发⼈员⾃定义和扩充。 同时 HTTP 由于是⼯作在应⽤层（ OSI 第七层），则它下层可以随意变化。 HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚⾄把 TCP 层换成了基 于 UDP 的 QUIC。</p><li><p>跨平台且应用广泛：互联⽹发展⾄今，HTTP 的应⽤范围⾮常的⼴泛，从台式机的浏览器到⼿机上的各种 APP，从看新闻、 刷贴吧到购物、理财、吃鸡，HTTP 的应⽤⽚地开花，同时天然具有跨平台的优越性。</p></ol><h3 id=3-1-2、缺点><a class=headerlink href=#3-1-2、缺点 title=3.1.2、缺点></a>3.1.2、缺点</h3><p><strong>HTTP 协议是⽆状态、明⽂传输，不安全</strong>。<ol><li><p><font color=orange>⽆状态双刃剑</font></p> <p>⽆状态的好处：因为服务器不会去记忆 HTTP 状态，这能减轻服务器的负担，减少资源占用。</p> <p>⽆状态的坏处：服务器没有记忆能⼒，在完成有关联性的操作时会⾮常麻烦。</p> <p>对于⽆状态的问题，解法⽅案有很多种，其中⽐较简单的⽅式⽤ Cookie 技术。 Cookie 通过在请求和响应报⽂中写⼊ Cookie 信息来控制客户端的状态。 相当于，在客户端第⼀次请求后，服务器会下发⼀个装有客户信息的「⼩贴纸」，后续客户端请求服务器的时候，带上「⼩贴纸」，服务器就能认得。</p><li><p><font color=orange>明⽂传输双刃剑</font></p> <p>好处：明⽂意味着可⽅便阅读，可以直接⾁眼查看（通过浏览器的 F12 控制台或 Wireshark 抓包都可），提高了调试⼯作的便利性。</p> <p>坏处：HTTP 的所有信息都暴露了。在漫⻓的传输过程中很容易被窃取。</p><li><p><font color=orange>不安全</font></p> <p>HTTP ⽐较严重的缺点就是不安全：</p> <ol><li>通信使⽤明⽂，内容可能会被窃听。⽐如，账号信息容易泄漏，那你号没了。<li>不验证通信⽅的身份，因此有可能遭遇伪装。⽐如，访问假的淘宝、拼多多，那你钱没了。<li>⽆法证明报⽂的完整性，所以有可能已遭篡改。⽐如，⽹⻚上植⼊垃圾⼴告，视觉污染，眼没了。</ol> <p>HTTP 的安全问题，可以⽤ HTTPS 的⽅式解决，也就是通过引⼊ SSL/TLS 层，使得在安全上达到了极 致。</p></ol><h2 id=3-2、HTTP1-1性能><a class=headerlink href=#3-2、HTTP1-1性能 title=3.2、HTTP1.1性能></a>3.2、HTTP1.1性能</h2><p><strong>HTTP 协议基于TCP/IP，且使⽤了请求应答通信模式，所以性能的关键就在这两点中</strong>。<ol><li>长连接<li>管道网络传输<li>队头阻塞</ol><h3 id=3-2-1、长连接><a class=headerlink href=#3-2-1、长连接 title=3.2.1、长连接></a>3.2.1、长连接</h3><p>HTTP/1.0中，每发起⼀个请求，都要建立⼀次 TCP 连接（三次握⼿），且是串⾏请求，增加了通信开销。<p>HTTP/1.1 提出了⻓连接通信⽅式，也叫持久连接。<p>持久连接的特点是：<strong>只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态</strong>。<p><img alt=image-20210415180426292 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415180426292.png?token=AIGEF3ORLSC3ZA2BLR5LH43EZZP3I><h3 id=3-2-2、管道网络传输><a class=headerlink href=#3-2-2、管道网络传输 title=3.2.2、管道网络传输></a>3.2.2、管道网络传输</h3><p><strong>HTTP/1.1 采⽤了⻓连接，这使得管道（pipeline）⽹络传输成为了可能</strong>。<p><strong>同⼀个 TCP 连接中，客户端可以连续发起多个请求，后一个请求不必等待前一个请求处理完毕就可以继续发送。但服务器还是按照顺序先回应 A 请求，再回应 B 请求。要是前⾯的回应特别慢，后⾯就会有许多请求排队等待</strong>。这称为队头堵塞。<h3 id=3-2-3、队头阻塞><a class=headerlink href=#3-2-3、队头阻塞 title=3.2.3、队头阻塞></a>3.2.3、队头阻塞</h3><p>当顺序发送的请求序列中有⼀个请求被阻塞时，后⾯排队的请求也会⼀同被阻塞，这会导致客户端⼀直请求不到数据，这就是队头阻塞。<p><img alt=image-20210415180822708 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415180822708.png?token=AIGEF3M37TWIAH6H5LR25WTEZZP34><h1 id=4、HTTP与HTTPS><a class=headerlink href=#4、HTTP与HTTPS title=4、HTTP与HTTPS></a>4、HTTP与HTTPS</h1><h2 id=4-1、HTTP与HTTPS区别><a class=headerlink href=#4-1、HTTP与HTTPS区别 title=4.1、HTTP与HTTPS区别></a>4.1、HTTP与HTTPS区别</h2><ol><li><p>安全性</p> <p>HTTP是超⽂本传输协议，明⽂传输存在安全⻛险。HTTPS在TCP和HTTP⽹络层之间加⼊了SSL/TLS安全协议，可实现报文加密传输。</p><li><p>建立连接</p> <p>HTTP连接建⽴相对简单， TCP三次握⼿之后便可进⾏ HTTP 的报⽂传输。HTTPS在TCP三次握⼿之后还需进⾏SSL/TLS的握⼿过程才可进行加密报⽂的传输。</p><li><p>端口号</p> <p>HTTP端⼝号是80，HTTPS端⼝号是443。</p><li><p>身份验证</p> <p>HTTP不验证通信方的身份是否可信；</p> <p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p></ol><h2 id=4-2、HTTPS解决了HTTP那些问题><a class=headerlink href=#4-2、HTTPS解决了HTTP那些问题 title=4.2、HTTPS解决了HTTP那些问题></a>4.2、HTTPS解决了HTTP那些问题</h2><p>由于HTTP 是明⽂传输，所以安全上存在以下三个⻛险：<ol><li>窃听⻛险：⽐如通信链路上可以获取通信内容，⽤户号容易没。<li>篡改⻛险：⽐如强制植⼊垃圾⼴告，视觉污染，⽤户眼容易瞎。<li>冒充⻛险：⽐如冒充淘宝⽹站，⽤户钱容易没。</ol><p><strong>HTTPS在HTTP与TCP层之间加⼊了SSL/TLS协议，该方式可解决和避免上述⻛险</strong>：<ol><li>信息加密：交互信息⽆法被窃取，但你的号会因为「⾃身忘记」账号⽽没。<li>校验机制：⽆法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾⼴告。<li>身份证书：证明淘宝是真的淘宝⽹，但你的钱还是会因为「剁⼿」⽽没。</ol><p>可⻅，只要⾃身不做「恶」，SSL/TLS 协议可以保证通信安全。<h2 id=4-3、HTTPS加密原理><a class=headerlink href=#4-3、HTTPS加密原理 title=4.3、HTTPS加密原理></a>4.3、HTTPS加密原理</h2><ol><li>混合加密：保证信息机密性，解决窃听⻛险。<li>摘要算法：实现完整性，能够生产校验数据完整性的指纹，解决了篡改⻛险。<li>数字证书：将服务器公钥放⼊到数字证书，解决了冒充⻛险。</ol><h3 id=4-3-1、混合加密><a class=headerlink href=#4-3-1、混合加密 title=4.3.1、混合加密></a>4.3.1、混合加密</h3><p><strong>混合加密可以保证信息机密性，解决窃听⻛险</strong>。<p><img alt=image-20210415182015246 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415182015246.png?token=AIGEF3IWSVAJ73UNNB4TXE3EZZP5Y><p><strong>HTTPS采⽤对称加密和⾮对称加密互相结合的「混合加密」⽅式</strong>：<ul><li>在通信建⽴前采⽤ ⾮对称加密 ⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。<li>在通信过程中全部使⽤ 对称加密 方式「会话秘钥」来加密明⽂数据。</ul><p>采⽤「混合加密」方式的原因：<ol><li><strong>对称加密只使⽤⼀个密钥</strong>，运算速度快，密钥必须保密，⽆法做到安全的密钥交换。<li><strong>⾮对称加密使⽤两个密钥</strong>：公钥和私钥，公钥可以任意分发⽽私钥必须保密，解决了密钥交换的安全问题，但速度会变慢。</ol><h3 id=3-3-2、摘要算法><a class=headerlink href=#3-3-2、摘要算法 title=3.3.2、摘要算法></a>3.3.2、摘要算法</h3><p><strong>摘要算法用于实现完整性，能生成校验数据完整性的指纹，解决了篡改⻛险</strong>。<p><img alt=image-20210415182326356 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415182326356.png?token=AIGEF3I4JU5HIWM3DDG72FLEZZP6Q><p>客户端通过摘要算法算出明⽂的指纹，后将指纹、明⽂⼀同加密后发送给服务器。服务器通过相同的摘要算法计算得出明⽂，通过对比客户端携带的指纹和当前计算得出的指纹，若指纹相同，说明数据完整。<h3 id=4-3-3、数字证书><a class=headerlink href=#4-3-3、数字证书 title=4.3.3、数字证书></a>4.3.3、数字证书</h3><p><strong>客户端先向服务端索要公钥，然后⽤公钥加密信息，服务器收到密⽂后，⽤⾃⼰的私钥解密</strong>。<p>这就存在些问题，如何保证公钥信任度及不被篡改呢？<p>这就需要借助第三⽅权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。<p><img alt=image-20210415182616713 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415182616713.png?token=AIGEF3OHAOIT7PDXSJUVURTEZZP7G><p><strong>通过数字证书的⽅式保证服务器公钥的身份，解决冒充的⻛险</strong>。<h2 id=4-4、HTTPS如何建立连接><a class=headerlink href=#4-4、HTTPS如何建立连接 title=4.4、HTTPS如何建立连接></a>4.4、HTTPS如何建立连接</h2><h3 id=4-4-1、SSL-TLS协议基本流程><a class=headerlink href=#4-4-1、SSL-TLS协议基本流程 title=4.4.1、SSL/TLS协议基本流程></a>4.4.1、SSL/TLS协议基本流程</h3><ol><li>客户端向服务器索要公钥并验证。<li>双⽅协商⽣成「会话秘钥」。<li>双⽅通过「会话秘钥」进⾏加密通信。</ol><p>前两步也就是 SSL/TLS 握⼿阶段。<p>SSL/TLS 的「握⼿阶段」涉及四次通信，可⻅下图：<p><img alt=image-20210415183012254 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415183012254.png?token=AIGEF3KKEW4DNJEU4UAEHYTEZZP74><p><img alt=image-20210415183132165 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415183132165.png?token=AIGEF3PK45S4GR7EE3YWP4LEZZQAQ><h3 id=4-4-2、SSL-TLS协议详细流程><a class=headerlink href=#4-4-2、SSL-TLS协议详细流程 title=4.4.2、SSL/TLS协议详细流程></a>4.4.2、SSL/TLS协议详细流程</h3><p>SSL/TLS 协议建⽴的详细流程：<ol><li><p>Client Hello</p> <p><strong>⾸先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求</strong>。</p> <p>在这⼀步，客户端主要向服务器发送以下信息：</p> <ol><li>客户端⽀持的 <strong>SSL/TLS 协议版本</strong>，如 TLS 1.2 版本。<li>客户端⽣成的<strong>随机数</strong>（ Client Random ），后⾯⽤于生成「会话秘钥」。<li>客户端⽀持的<strong>密码套件列表</strong>，如 RSA 加密算法。</ol><li><p>Sever Hello</p> <p><strong>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello</strong> 。</p> <p>服务器回应的内容有如下内容：</p> <ol><li>确认 SSL/ TLS 协议版本，如果浏览器不⽀持，则关闭加密通信。<li>服务器⽣成<strong>随机数</strong>（ Server Random ），后⾯⽤于⽣产「会话秘钥」。<li>确认<strong>密码套件列表</strong>，如 RSA 加密算法。<li><strong>服务器数字证书</strong>。</ol><li><p>客户端回应</p> <p>客户端收到服务器回应之后，<strong>先通过浏览器或者操作系统中的 CA 公钥来确认服务器数字证书的真实性。 如果证书没有问题，客户端会从数字证书中取出服务器公钥，然后使⽤它加密报⽂并向服务器发送如下信息</strong>：</p> <ol><li><p>⼀个<strong>随机数</strong>（ pre-master key ）。该随机数会被服务器公钥加密。</p><li><p><strong>加密通信算法改变通知</strong>，表示随后的信息都将⽤「会话秘钥」加密通信。</p><li><p><strong>客户端握⼿结束通知</strong>，表示客户端的握⼿阶段已经结束。这⼀项同时把之前所有内容发⽣的数据做个摘要，⽤来供服务端校验。</p></ol> <p>上⾯第1项中的随机数是整个握⼿阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就⽤双⽅协商的加密算法，各⾃⽣成本次通信的「会话秘钥」。</p><li><p>服务器最后回应</p> <p><strong>服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法计算出本次通信的「会话秘钥」。然后向客户端发送最后信息</strong>：</p> <ol><li>加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。<li>服务器握⼿结束通知，表示服务器的握⼿阶段已经结束。这⼀项同时把之前所有内容发⽣的数据做个摘要，⽤来供客户端校验。</ol> <p>⾄此，整个 SSL/TLS 的握⼿阶段全部结束。接下来，客户端与服务器进⼊加密通信，就完全是使⽤普通的 HTTP 协议，只不过⽤「会话秘钥」加密内容。</p></ol><h1 id=5、HTTP版本演变><a class=headerlink href=#5、HTTP版本演变 title=5、HTTP版本演变></a>5、HTTP版本演变</h1><h2 id=5-1、HTTP-1-0><a class=headerlink href=#5-1、HTTP-1-0 title=5.1、HTTP/1.0></a>5.1、HTTP/1.0</h2><p><strong>1996年5月，HTTP/1.0 发布</strong>，HTTP/1.0 规定浏览器与服务器只保持短暂连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。<p><strong>TCP连接建立需要三次握手，很耗费，HTTP/1.0的性能比较差</strong>。<h2 id=5-2、HTTP-1-1><a class=headerlink href=#5-2、HTTP-1-1 title=5.2、HTTP/1.1></a>5.2、HTTP/1.1</h2><p>HTTP/1.1 相⽐ HTTP/1.0 性能上的改进：<ol><li><strong>TCP长连接</strong>：使⽤ TCP⻓连接⽅式来降低开销性能开销；<li><strong>管道（pipeline）⽹络传输</strong>：只要第⼀个请求发出去了，不必等其回应就可以发第⼆个请求，减少了整体的响应时间。</ol><p>但是，HTTP/1.1 也有如下缺点：<ol><li>请求/响应头部未经压缩就发送，⾸部信息越多延迟越⼤，只能压缩Body部分；<li>发送冗⻓的⾸部。互相发送相同的⾸部造成了浪费；<li>服务器按请求顺序响应，如果响应中的某个请求阻塞了，那么后面请求会被全部阻塞，会导致客户端⼀直请求不到数据，这就是队头阻塞；<li><strong>没有请求优先级控制</strong>；<li><strong>请求只能从客户端开始，服务器只能被动响应</strong>。</ol><h2 id=5-3、HTTP-2><a class=headerlink href=#5-3、HTTP-2 title=5.3、HTTP/2></a>5.3、HTTP/2</h2><h3 id=5-3-1、HTTP-2概述><a class=headerlink href=#5-3-1、HTTP-2概述 title=5.3.1、HTTP/2概述></a>5.3.1、HTTP/2概述</h3><p><strong>HTTP/2 协议基于 HTTPS ，所以 HTTP/2 安全有保障</strong>。<p>HTTP/2 相⽐ HTTP/1.1，在性能上的改进如下：<ol><li>头部压缩（Hpack压缩算法、QPack算法）<li>二进制格式<li>数据流（Stream）<li>多路复用<li>服务器推送</ol><h4 id=5-3-1-1、头部压缩><a class=headerlink href=#5-3-1-1、头部压缩 title=5.3.1.1、头部压缩></a>5.3.1.1、头部压缩</h4><p><strong>HTTP/2 会压缩头部（Header），如果同时发出多个请求且它们的头相同或相似时，协议会帮你消除重复部分</strong>。<p>HPACK 算法：<strong>在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表并为每个字段⽣成⼀个索引号，后续只需发送索引号即可，进一步提升了性能</strong>。<h4 id=5-3-1-2、二进制格式><a class=headerlink href=#5-3-1-2、二进制格式 title=5.3.1.2、二进制格式></a>5.3.1.2、二进制格式</h4><p><strong>HTTP/2 中不再有 HTTP/1.1 中纯⽂本形式的报⽂了，⽽是全⾯采⽤⼆进制格式。头信息和数据体都是⼆进制，且统称为帧（frame）：头信息帧和数据帧</strong>。<p><img alt=image-20210415184254532 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415184254532.png?token=AIGEF3LQDA677F2OTIUQVNLEZZQBS><p>计算机只懂⼆进制，故收到报⽂后就可以直接解析，避免了转换的步骤，增加了数据传输的效率。<h4 id=5-3-1-3、数据流><a class=headerlink href=#5-3-1-3、数据流 title=5.3.1.3、数据流></a>5.3.1.3、数据流</h4><p>HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。<p><strong>每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编号，规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</strong>。<p><strong>客户端还可以指定数据流优先级</strong>。优先级⾼的请求，服务器会优先对该请求响应。<p><img alt=image-20210415184608092 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415184608092.png?token=AIGEF3OR5RKZEEJUHVEWHZDEZZQCE><h4 id=5-3-1-4、多路复用><a class=headerlink href=#5-3-1-4、多路复用 title=5.3.1.4、多路复用></a>5.3.1.4、多路复用</h4><p><strong>HTTP/2 可以在⼀个连接中并发执行多个请求或回应，且无需按照顺序⼀⼀对应</strong>。<p>移除 HTTP/1.1 串⾏请求，无需排队等待，故也就不会再出现「队头阻塞」问题，降低了延迟， ⼤幅度提⾼了连接利⽤率。<p>举例来说，在⼀个 TCP 连接⾥，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程⾮常耗时，那么就会先回应 A 请求已经处理好的部分，然后回应 B 请求，当B请求的响应完成后，再回来继续回应 A 请求剩下的部分。<h4 id=5-3-1-5、服务器推送><a class=headerlink href=#5-3-1-5、服务器推送 title=5.3.1.5、服务器推送></a>5.3.1.5、服务器推送</h4><p><strong>HTTP/2 ⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务端不再是被动响应，也可以主动 向客户端发送消息</strong>。<p>举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会⽤到的 JS、CSS ⽂件等静态资源主动发给 客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。<h3 id=5-3-2、HTTP-2缺陷><a class=headerlink href=#5-3-2、HTTP-2缺陷 title=5.3.2、HTTP/2缺陷></a>5.3.2、HTTP/2缺陷</h3><p>HTTP/2 主要问题：<strong>多个 HTTP 请求复⽤⼀个 TCP 连接时，下层的 TCP 协议不知道有多少 HTTP 请求。所以⼀旦发⽣了丢包现象就会触发 TCP 重传机制，⼀个 TCP 连接中的所有 HTTP 请求都必须等待这个丢了的包被重传回来时才能继续走下去</strong>。<p>HTTP/2丢包阻塞与HTTP/1.1管道阻塞的区别如下：<ul><li>HTTP/1.1 管道（ pipeline）传输中如果某个请求被阻塞了，那么该请求后的请求也会被统统阻塞住。<li>HTTP/2 多个请求复⽤⼀个TCP连接，⼀旦发⽣丢包，随后的所有数据帧都会延迟。</ul><h2 id=5-4、HTTP3><a class=headerlink href=#5-4、HTTP3 title=5.4、HTTP3></a>5.4、HTTP3</h2><p>HTTP/2的缺陷来源于 TCP 传输层，故，HTTP/3 把 HTTP 下层的 TCP 协议换成了 UDP。<p><img alt=image-20210415185214946 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415185214946.png?token=AIGEF3LH2DFTTVDUAOCE3WTEZZQDA><p>UDP 不管顺序，也不管丢包，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的丢包全部重传问题。<p><strong>UDP 是不可靠传输，但基于UDP的QUIC协议可以帮助其达到类似TCP的可靠性传输效果</strong>。<ul><li><strong>QUIC 有⾃⼰的⼀套机制可以保证传输的可靠性。当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到影响</strong>。<li><strong>TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack</strong> 。<li>HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是TCP三次握⼿，然后 TLS/1.3 三次握⼿。 QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。</ul><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805095840581.png?token=AIGEF3IQMU723LDXPVNHQ3LEZZPLK><p>所以， QUIC 是⼀个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复⽤协议。<p>很多⽹络设根本不知道什么是 QUIC，只会当做 UDP，这样会出现新问题。所以 HTTP/3 普及速度⾮常缓慢，未来 UDP 是否能够逆袭 TCP也很难说。<h2 id=5-5、小总结><a class=headerlink href=#5-5、小总结 title=5.5、小总结></a>5.5、小总结</h2><h3 id=5-5-1、Http1-0-VS-Htpp1-1><a title="5.5.1、Http1.0 VS Htpp1.1" class=headerlink href=#5-5-1、Http1-0-VS-Htpp1-1></a>5.5.1、Http1.0 VS Htpp1.1</h3><table><thead><tr><th align=center><th align=center>HTTP/1.0<th align=center>HTTP/1.1<tbody><tr><td align=center><strong>连接持久性</strong><td align=center>http1.0默认非持久连接，每次请求后会断开连接。<td align=center>http1.1支持持久连接，允许在单个连接上执行多个请求和响应。<tr><td align=center><strong>主机头部</strong><td align=center>http1.0不要求host头。<td align=center>http1.1中host头是必需的，允许基于名称的虚拟主机。<tr><td align=center><strong>管道</strong><td align=center>http1.0不支持管道化操作。<td align=center>http1.1支持请求管道化，允许在一个请求得到响应前继续发送其它请求，但响应仍然需要按请求顺序返回。<tr><td align=center><strong>缓存控制</strong><td align=center>http1.0中的缓存是通过<code>Pragmatic:no-cache</code>来控制。<td align=center>http1.1中引入了新的缓存控制头部，比如<code>Cache-Control</code>。<tr><td align=center><strong>错误通知</strong><td align=center>http1.0对于错误的通知不太明确。<td align=center>http1.1引入更多状态码来更精确的描述错误状态。<tr><td align=center><strong>方法和状态码</strong><td align=center>http1.0提供了有限的方法和状态码。<td align=center>http1.1引入了新的方法（OPTIONS、PUT、DELET等）和新的状态码。<tr><td align=center><strong>分块传输编码</strong><td align=center>http1.0不支持。<td align=center>http1.1允许服务器动态生成内容并在不知道整体大小的情况下发送给客户端。<tr><td align=center><strong>范围请求</strong><td align=center>http1.0不支持。<td align=center>http1.1允许客户端请求资源的一部分，这对于大文件和断点续传很有用。</table><h3 id=5-5-2、Http1-1-VS-Htpp2><a title="5.5.2、Http1.1 VS Htpp2" class=headerlink href=#5-5-2、Http1-1-VS-Htpp2></a>5.5.2、Http1.1 VS Htpp2</h3><table><thead><tr><th align=center><th align=center>HTTP/1.1<th align=center>HTTP/2<tbody><tr><td align=center><strong>多路复用</strong><td align=center>http1.1中的每个请求需要一个独立的TCP连接，或需要排队等待其它请求完成。<td align=center>http2中的单个连接可以进行多个并发请求和响应的交换，消除了对头阻塞问题。<tr><td align=center><strong>帧与流</strong><td align=center>http1.1中数据的发送方式较为简单，没有明确的结构。<td align=center>http2中的数据被分解为帧并在流中发送，每个流有一个唯一标识和优先级。<tr><td align=center><strong>头部压缩</strong><td align=center>http1.1的头部以文本形式发送，可能导致冗余。<td align=center>http2中使用HPack压缩格式，进一步减小了头部。<tr><td align=center><strong>服务器推送</strong><td align=center>http1.1中服务器只负责响应客户端的请求。<td align=center>http2中的服务器可以主动推送资源给客户端。<tr><td align=center><strong>二进制协议</strong><td align=center>http1.1中基于文本。<td align=center>http2中基于二进制，使得解析、实现、优化等变得更高效。<tr><td align=center><strong>流控制与优先级</strong><td align=center>http1.1缺少明确的流控制和请求优先级机制。<td align=center>http2中提供应用层的流控制和请求优先级。</table><h1 id=6、HTTP-TCP-Keep-Alive><a title="6、HTTP/TCP Keep-Alive" class=headerlink href=#6、HTTP-TCP-Keep-Alive></a>6、HTTP/TCP Keep-Alive</h1><h2 id=6-1、HTTP-Keep-Alive><a title="6.1、HTTP Keep-Alive" class=headerlink href=#6-1、HTTP-Keep-Alive></a>6.1、HTTP Keep-Alive</h2><h3 id=6-1-1、为什么HTTP是短连接><a class=headerlink href=#6-1-1、为什么HTTP是短连接 title=6.1.1、为什么HTTP是短连接></a>6.1.1、为什么HTTP是短连接</h3><p>众所周知，HTTP是短连接，client向server发送一个request，得到response后，连接就关闭。之所以这样设计使用，主要是考虑到实际情况。例如，用户通过浏览器访问一个web站点上的某个网页，当网页内容加载完毕之后，用户可能需要花费几分钟甚至更多的时间来浏览网页内容，此时完全没有必要继续维持底层连接。当用户需要访问其他网页时，再创建新的连接即可。<p>因此，HTTP连接的寿命通常都很短。这样做的好处是，可以极大的减轻服务端的压力。一般而言，一个站点能支撑的最大并发连接数也是有限的，面对这么多客户端浏览器，不可能长期维持所有连接。每个客户端取得自己所需的内容后，即关闭连接，更加合理。<h3 id=6-1-2、为什么要引入keep-alive><a class=headerlink href=#6-1-2、为什么要引入keep-alive title=6.1.2、为什么要引入keep-alive></a>6.1.2、为什么要引入keep-alive</h3><p>一个网页中，可能引入了几十个js、css文件，上百张图片，如果每请求一个资源就创建一个连接，代价会很大。<p>为解决该问题，只需保证一个连接能在<strong>短时间</strong>内得到复用即可，这就是HTTP协议中keep-alive属性的作用。<blockquote><ul><li>HTTP 1.0 默认关闭Keep-Alive，若要启用 则需要在http头中加入”Connection: Keep-Alive”；<li>HTTP 1.1 默认启用Keep-Alive，若要关闭 则需要在http头中加入”Connection: close “。</ul></blockquote><h3 id=6-1-3、Server端如何处理Keep-Alive><a class=headerlink href=#6-1-3、Server端如何处理Keep-Alive title=6.1.3、Server端如何处理Keep-Alive></a>6.1.3、Server端如何处理Keep-Alive</h3><p><strong>一个连接的复用时间长短，通常由web服务器控制</strong>。<p><strong>HTTP协议中，Keep-Alive属性保持连接的时间长短由服务端决定，通常都在几十秒左右</strong>。除此之外，一些异常情况会导致 keepalive失效。<h3 id=6-1-4、JDK对keep-alive的支持><a class=headerlink href=#6-1-4、JDK对keep-alive的支持 title=6.1.4、JDK对keep-alive的支持></a>6.1.4、JDK对keep-alive的支持</h3><p>当创建一个HttpUrlConnection对象时，底层实际上会创建一个对应的Socket对象。<strong>要复用的并非是HttpUrlConnection，而是底层的Socket</strong>。<p>JDK对keepalive的支持是默认开启，我们要做的是学会如何正确有效使用。<p>参见：<a href=https://link.zhihu.com/?target=https://docs.oracle.com/javase/8/docs/technotes/guides/net/http-keepalive.html>https://docs.oracle.com/javase/8/docs/technotes/guides/net/http-keepalive.html</a><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>When the application finishes reading the response body or when the application calls <span class="title function_">close</span><span class=params>()</span> </span><br><span class=line>on the InputStream returned by URLConnection.getInputStream(), </span><br><span class=line>the JDK<span class=string>'s HTTP protocol handler will try to clean up the connection and if successful, </span></span><br><span class=line><span class=string>put the connection into a connection cache for reuse by future HTTP requests.</span></span><br></pre></table></figure><p>这段话的含义是：当通过URLConnection.getInputStream()读取响应数据之后(这里是HttpUrlConnection)，应该调用InputStream的close方法关闭输入流，JDK http协议处理器会将这个连接放到一个连接缓存中，以便后续HTTP请求来复用。<h2 id=6-2、TCP-Keep-Alive><a title="6.2、TCP Keep-Alive" class=headerlink href=#6-2、TCP-Keep-Alive></a>6.2、TCP Keep-Alive</h2><h3 id=6-2-1、TCP-Keep-Alive探针><a title="6.2.1、TCP Keep-Alive探针" class=headerlink href=#6-2-1、TCP-Keep-Alive探针></a>6.2.1、TCP Keep-Alive探针</h3><p><strong>对于一方发起的keepalive探针，另一方必须响应</strong>。响应可能是以下三种形式之一：<ol><li><p>对方回应了ACK：说明一切OK。如果接下来2小时还没有数据传输，那么还会继续发送keepalive探针，以确保连接存活。</p><li><p>对方回复RST：表示这个连接已经不存在。例如一方服务宕机后重启，此时接收到探针，因为不存在对应的连接。</p><li><p>没有回复：说明socket已经被关闭了。</p> <ul><li><p>tcp_keepalive_intvl：keepalive探测包的发送间隔，默认为75秒。</p><li><p>tcp_keepalive_probes：如果对方不予应答，探测包的最大发送次数，默认为9次。即连续9次发送，都没有应答的话，则关闭连接。</p><li><p>tcp_keepalive_time：连接的最大空闲(idle)时间，默认为7200秒，即2个小时。需要注意的是，这2个小时，指的是只有keepalive探测包，如果期间存在其他数据传输，则重新计时。</p></ul></ol><p>这些默认值在 /proc/sys/net/ipv4 目录下可以找到，文件中的值就是默认值。<p><strong>TCP中的SO_KEEPALIVE是一个开关选项，默认关闭，需要在代码中显式开启。当开启后，通信双方没有数据传输时操作系统底层会定时发送keepalive探测包，以保证连接存活</strong>。<p>在Java 中可以通过Socket设置keepAlive为true：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>Socket socket=<span class=keyword>new</span> <span class="title class_">Socket</span>();</span><br><span class=line>socket.setKeepAlive(<span class=literal>true</span>);  <span class=comment>//开启keep alive</span></span><br><span class=line>socket.connect(<span class=keyword>new</span> <span class="title class_">InetSocketAddress</span>(<span class=string>"127.0.0.1"</span>, <span class=number>8080</span>));</span><br></pre></table></figure><h3 id=6-2-2、TCP-Keep-Alive缺点><a title="6.2.2、TCP Keep-Alive缺点" class=headerlink href=#6-2-2、TCP-Keep-Alive缺点></a>6.2.2、TCP Keep-Alive缺点</h3><ol><li><strong>keep alive只能检测连接是否存活，不能检测连接是否可用</strong>。例如，某一方发生了死锁，无法在连接上进行任何读写操作，但是操作系统仍然可以响应网络层keepalive包。<li><strong>TCP keepalive 机制依赖于操作系统实现，灵活性不够，默认关闭，且keepalive 心跳时间默认是两个小时，时间较长</strong>。<li><strong>代理(如socks proxy)、负载均衡器等工具会让tcp keep-alive失效</strong>。</ol></div><footer class=post-footer><div class=post-tags><a href=/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/ rel=tag># 网络协议</a><a href=/tags/HTTP/ rel=tag># HTTP</a></div><div class=post-nav><div class=post-nav-item><a href=/2024/08/21/HTTP%E5%B8%B8%E8%A7%81%E9%97%AE%E7%AD%94/ rel=prev title=计算机系列-HTTP常见问题> <i class="fa fa-angle-left"></i> 计算机系列-HTTP常见问题 </a></div><div class=post-nav-item><a href=/2024/08/21/IO%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ rel=next title=计算机系列-IO> 计算机系列-IO <i class="fa fa-angle-right"></i> </a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script>