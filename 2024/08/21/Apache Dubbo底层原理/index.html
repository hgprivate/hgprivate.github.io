<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hshz21.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="1、Dubbo底层架构1.1、官方解释Dubbo官方架构图如下：  节点角色说明：    节点 角色名称    Provider 服务提供方   Consumer 服务消费方   Registry 注册中心   Monitor 监控中心（统计服务调用次数和调用时间）   Container 服务运行容器    1、虚线表示异步访问，实线表示同步访问。2、蓝色虚线表示在启动时完成的功能。3、红色虚线" name=description><meta content=article property=og:type><meta content=Dubbo系列-Dubbo原理解析 property=og:title><meta content=https://hshz21.gitee.io/2024/08/21/Apache%20Dubbo%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content="1、Dubbo底层架构1.1、官方解释Dubbo官方架构图如下：  节点角色说明：    节点 角色名称    Provider 服务提供方   Consumer 服务消费方   Registry 注册中心   Monitor 监控中心（统计服务调用次数和调用时间）   Container 服务运行容器    1、虚线表示异步访问，实线表示同步访问。2、蓝色虚线表示在启动时完成的功能。3、红色虚线" property=og:description><meta content=zh_CN property=og:locale><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210523002015383.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/dubbo%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE01.jpg property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20230807161954071.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/dubbo%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E6%9A%B4%E6%BC%8F%E6%9C%8D%E5%8A%A1%E6%B5%81%E7%A8%8B01.jpg property=og:image><meta content=2024-08-21T13:39:13.296Z property=article:published_time><meta content=2023-10-02T07:10:28.722Z property=article:modified_time><meta content=豪哥 property=article:author><meta content=Dubbo property=article:tag><meta content=Dubbo原理 property=article:tag><meta content=summary name=twitter:card><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210523002015383.png name=twitter:image><link href=https://hshz21.gitee.io/2024/08/21/Apache%20Dubbo%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hshz21.gitee.io/2024/08/21/Apache%20Dubbo%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","path":"2024/08/21/Apache Dubbo底层原理/","title":"Dubbo系列-Dubbo原理解析"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>Dubbo系列-Dubbo原理解析 | 豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>豪哥博客</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#1%E3%80%81Dubbo%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84><span class=nav-number>1.</span> <span class=nav-text>1、Dubbo底层架构</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81%E5%AE%98%E6%96%B9%E8%A7%A3%E9%87%8A><span class=nav-number>1.1.</span> <span class=nav-text>1.1、官方解释</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-2%E3%80%81%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B><span class=nav-number>1.2.</span> <span class=nav-text>1.2、调用流程</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#2%E3%80%81Dubbo%E5%8D%8F%E8%AE%AE><span class=nav-number>2.</span> <span class=nav-text>2、Dubbo协议</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#2-1%E3%80%81dubbo%E5%8D%8F%E8%AE%AE><span class=nav-number>2.1.</span> <span class=nav-text>2.1、dubbo协议</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%89%B9%E7%82%B9><span class=nav-number>2.1.1.</span> <span class=nav-text>特点</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%80%BB%E7%BB%93><span class=nav-number>2.1.2.</span> <span class=nav-text>总结</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-2%E3%80%81rmi%E5%8D%8F%E8%AE%AE><span class=nav-number>2.2.</span> <span class=nav-text>2.2、rmi协议</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%89%B9%E7%82%B9-1><span class=nav-number>2.2.1.</span> <span class=nav-text>特点</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%80%BB%E7%BB%93-1><span class=nav-number>2.2.2.</span> <span class=nav-text>总结</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-3%E3%80%81hessian%E5%8D%8F%E8%AE%AE><span class=nav-number>2.3.</span> <span class=nav-text>2.3、hessian协议</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%89%B9%E7%82%B9-2><span class=nav-number>2.3.1.</span> <span class=nav-text>特点</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%80%BB%E7%BB%93-2><span class=nav-number>2.3.2.</span> <span class=nav-text>总结</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-4%E3%80%81http%E5%8D%8F%E8%AE%AE><span class=nav-number>2.4.</span> <span class=nav-text>2.4、http协议</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%89%B9%E7%82%B9-3><span class=nav-number>2.4.1.</span> <span class=nav-text>特点</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%80%BB%E7%BB%93-3><span class=nav-number>2.4.2.</span> <span class=nav-text>总结</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-5%E3%80%81webservice%E5%8D%8F%E8%AE%AE><span class=nav-number>2.5.</span> <span class=nav-text>2.5、webservice协议</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E7%89%B9%E7%82%B9-4><span class=nav-number>2.5.1.</span> <span class=nav-text>特点</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%80%BB%E7%BB%93-4><span class=nav-number>2.5.2.</span> <span class=nav-text>总结</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-6%E3%80%81thrift%E5%8D%8F%E8%AE%AE><span class=nav-number>2.6.</span> <span class=nav-text>2.6、thrift协议</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-7%E3%80%81memcached%E5%8D%8F%E8%AE%AE><span class=nav-number>2.7.</span> <span class=nav-text>2.7、memcached协议</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-8%E3%80%81redis%E5%8D%8F%E8%AE%AE><span class=nav-number>2.8.</span> <span class=nav-text>2.8、redis协议</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#3%E3%80%81Dubbo%E5%BA%8F%E5%88%97%E5%8C%96><span class=nav-number>3.</span> <span class=nav-text>3、Dubbo序列化</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#3-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>3.1.</span> <span class=nav-text>3.1、简介</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-2%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E7%B1%BB%E5%9E%8B><span class=nav-number>3.2.</span> <span class=nav-text>3.2、序列化类型</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-3%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%89%A9%E5%B1%95><span class=nav-number>3.3.</span> <span class=nav-text>3.3、序列化扩展</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#4%E3%80%81%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0><span class=nav-number>4.</span> <span class=nav-text>4、底层实现</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#4-1%E3%80%81%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83><span class=nav-number>4.1.</span> <span class=nav-text>4.1、服务注册中心</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#4-2%E3%80%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86Proxy><span class=nav-number>4.2.</span> <span class=nav-text>4.2、动态代理Proxy</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#4-3%E3%80%81Cluster%E9%9B%86%E7%BE%A4%E5%B1%82><span class=nav-number>4.3.</span> <span class=nav-text>4.3、Cluster集群层</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-3-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>4.3.1.</span> <span class=nav-text>4.3.1、简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-3-2%E3%80%81LoadBlance%E7%BB%84%E4%BB%B6><span class=nav-number>4.3.2.</span> <span class=nav-text>4.3.2、LoadBlance组件</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#4-4%E3%80%81Exchange%E4%BF%A1%E6%81%AF%E4%BA%A4%E6%8D%A2%E5%B1%82><span class=nav-number>4.4.</span> <span class=nav-text>4.4、Exchange信息交换层</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#4-5%E3%80%81Transport-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%B1%82><span class=nav-number>4.5.</span> <span class=nav-text>4.5、Transport 网络通信层</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#4-6%E3%80%81%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%E6%8E%A5%E6%94%B6%E5%88%B0%E5%93%8D%E5%BA%94><span class=nav-number>4.6.</span> <span class=nav-text>4.6、服务消费者接收到响应</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#5%E3%80%81Dubbo-SPI%E6%9C%BA%E5%88%B6><span class=nav-number>5.</span> <span class=nav-text>5、Dubbo SPI机制</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#5-1%E3%80%81SPI%E5%AE%9A%E4%B9%89><span class=nav-number>5.1.</span> <span class=nav-text>5.1、SPI定义</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#5-2%E3%80%81JDK-SPI-%E5%92%8C-Dubbo-SPI><span class=nav-number>5.2.</span> <span class=nav-text>5.2、JDK SPI 和 Dubbo SPI</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#5-2-1%E3%80%81JDK-SPI><span class=nav-number>5.2.1.</span> <span class=nav-text>5.2.1、JDK SPI</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%AE%80%E4%BB%8B><span class=nav-number>5.2.1.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%80%BB%E7%BB%93-5><span class=nav-number>5.2.1.2.</span> <span class=nav-text>总结</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#5-2-2%E3%80%81Dubbo-SPI><span class=nav-number>5.2.2.</span> <span class=nav-text>5.2.2、Dubbo SPI</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-1><span class=nav-number>5.2.2.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90><span class=nav-number>5.2.2.2.</span> <span class=nav-text>源码分析</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#5-3%E3%80%81Dubbo-SPI-%E5%AE%9E%E7%8E%B0-IOC%E5%92%8CAOP><span class=nav-number>5.3.</span> <span class=nav-text>5.3、Dubbo SPI 实现 IOC和AOP</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#5-3-1%E3%80%81Dubbo-IOC><span class=nav-number>5.3.1.</span> <span class=nav-text>5.3.1、Dubbo IOC</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#5-3-2%E3%80%81Dubbo-AOP><span class=nav-number>5.3.2.</span> <span class=nav-text>5.3.2、Dubbo AOP</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#6%E3%80%81Dubbo%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91><span class=nav-number>6.</span> <span class=nav-text>6、Dubbo动态编译</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#6-1%E3%80%81Javassist><span class=nav-number>6.1.</span> <span class=nav-text>6.1、Javassist</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#6-2%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90><span class=nav-number>6.2.</span> <span class=nav-text>6.2、源码分析</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#7%E3%80%81%E6%9C%8D%E5%8A%A1%E6%9A%B4%E6%BC%8F%E4%B8%8E%E5%8F%91%E7%8E%B0><span class=nav-number>7.</span> <span class=nav-text>7、服务暴漏与发现</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#7-1%E3%80%81%E6%9C%8D%E5%8A%A1%E6%9A%B4%E6%BC%8F><span class=nav-number>7.1.</span> <span class=nav-text>7.1、服务暴漏</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#7-1-1%E3%80%81%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A><span class=nav-number>7.1.1.</span> <span class=nav-text>7.1.1、名词解释</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#7-1-2%E3%80%81%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B><span class=nav-number>7.1.2.</span> <span class=nav-text>7.1.2、整体流程</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#7-1-3%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90><span class=nav-number>7.1.3.</span> <span class=nav-text>7.1.3、源码分析</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#7-1-4%E3%80%81%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C><span class=nav-number>7.1.4.</span> <span class=nav-text>7.1.4、服务注册</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#X%E3%80%81%E6%80%BB%E7%BB%93><span class=nav-number>8.</span> <span class=nav-text>X、总结</span></a></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>116</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>36</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>129</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://hshz21.gitee.io/2024/08/21/Apache%20Dubbo%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="Dubbo系列-Dubbo原理解析 | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>Dubbo系列-Dubbo原理解析</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 15:10:28" datetime=2023-10-02T15:10:28+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Dubbo/ itemprop=url rel=index><span itemprop=name>Dubbo</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、Dubbo底层架构><a class=headerlink href=#1、Dubbo底层架构 title=1、Dubbo底层架构></a>1、Dubbo底层架构</h1><h2 id=1-1、官方解释><a class=headerlink href=#1-1、官方解释 title=1.1、官方解释></a>1.1、官方解释</h2><p>Dubbo官方架构图如下：<p><img alt=image-20210523002015383 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210523002015383.png><p>节点角色说明：<table><thead><tr><th>节点<th>角色名称<tbody><tr><td>Provider<td>服务提供方<tr><td>Consumer<td>服务消费方<tr><td>Registry<td>注册中心<tr><td>Monitor<td>监控中心（统计服务调用次数和调用时间）<tr><td>Container<td>服务运行容器</table><blockquote><p>1、虚线表示异步访问，实线表示同步访问。<br>2、蓝色虚线表示在启动时完成的功能。<br>3、红色虚线(实线)都表示程序运行过程中执行的功能。</blockquote><p>调用关系说明：<ol start=0><li>服务容器负责启动，加载，运行服务提供者。<li>服务提供者在启动时，向注册中心注册自己。<li>服务消费者在启动时，向注册中心订阅自己所需的服务。<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于【长连接】推送变更数据给消费者。<li>服务消费者基于【软负载均衡算法】从服务提供者地址列表中挑选一个来调用，如果调用失败，则再选另一个。<li>服务消费者和提供者在内存中的【累计调用次数和调用时间】等统计数据会被定时每分钟发送一次到监控中心。</ol><h2 id=1-2、调用流程><a class=headerlink href=#1-2、调用流程 title=1.2、调用流程></a>1.2、调用流程</h2><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/dubbo%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE01.jpg><p>对照上面的整体架构图可以大致分为以下步骤：<ol><li>服务提供者启动，开启Netty服务，创建Zookeeper客户端，向注册中心注册服务。<li>服务消费者启动，通过Zookeeper注册中心获取服务提供者列表，并与服务提供者通过Netty建立长连接。<li>服务消费者通过接口调用远程服务，ProxyFactory通过初始化Proxy对象，Proxy通过创建动态代理对象。<li>动态代理对象通过invoke方法，层层包装生成一个Invoker对象，该对象包含了代理对象。<li>Invoker通过路由，负载均衡选择了一个最合适的服务提供者，在通过加入各种过滤器，协议层包装生成一个新的DubboInvoker对象。<li>再通过交换将DubboInvoker对象包装成一个Reuqest对象，该对象被序列化后通过NettyClient传输到服务提供者的NettyServer端。<li>到了服务提供者这边，再通过反序列化、协议解密等操作生成一个DubboExporter对象，再经过层层传递处理后会生成一个服务提供端的Invoker对象。<li>这个Invoker对象会调用本地服务，获得结果后再通过层层回调返回至服务消费者，服务消费者拿到结果后，再解析获得最终结果。</ol><h1 id=2、Dubbo协议><a class=headerlink href=#2、Dubbo协议 title=2、Dubbo协议></a>2、Dubbo协议</h1><p>dubbo支持的协议如下：<ol><li>dubbo 协议 (默认)（单-长-T-N异-H）<li>rmi 协议（多-短-T-同-J）<li>hessian 协议（多-短-H-同-表）<li>http 协议（多-短-H-同-表）<li>WebService 协议（多-短-H-同-SOAP）<li>thrift 协议（）<li>memcached 协议<li>redis 协议</ol><h2 id=2-1、dubbo协议><a class=headerlink href=#2-1、dubbo协议 title=2.1、dubbo协议></a>2.1、dubbo协议</h2><h3 id=特点><a class=headerlink href=#特点 title=特点></a>特点</h3><p>缺省协议，使用基于mina1.1.7+hessian3.2.1的tbremoting交互。<ul><li>连接个数：<strong>单连接</strong><li>连接方式：<strong>长连接</strong><li>传输协议：<strong>TCP</strong><li>传输方式：NIO异步传输<li>序列化：<strong>Hessian 二进制序列化</strong><li>适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者数量多，单一消费者无法压满提供者，尽量不要用dubbo协议传输大文件或超大字符串。<li>适用场景：常规远程服务方法调用</ul><h3 id=总结><a class=headerlink href=#总结 title=总结></a>总结</h3><ol><li><p>dubbo默认采用dubbo协议，dubbo协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。</p><li><p>他不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"dubbo"</span> <span class=attr>port</span>=<span class=string>"20880"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Set default protocol: --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:provider</span> <span class=attr>protocol</span>=<span class=string>"dubbo"</span> /></span></span><br><span class=line><~-- Set service protocol --></span><br><span class=line><span class=tag><<span class=name>dubbo:service</span> <span class=attr>protocol</span>=<span class=string>"dubbo"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Multi port --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>id</span>=<span class=string>"dubbo1"</span> <span class=attr>name</span>=<span class=string>"dubbo"</span> <span class=attr>port</span>=<span class=string>"20880"</span> /></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>id</span>=<span class=string>"dubbo2"</span> <span class=attr>name</span>=<span class=string>"dubbo"</span> <span class=attr>port</span>=<span class=string>"20881"</span> /></span>.</span><br><span class=line><span class=comment>&LT!-- Dubbo protocol options: --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"dubbo"</span> <span class=attr>port</span>=<span class=string>"9090"</span> <span class=attr>server</span>=<span class=string>"netty"</span> <span class=attr>client</span>=<span class=string>"netty"</span> <span class=attr>codec</span>=<span class=string>“dubbo”</span> </span></span><br><span class=line><span class=tag><span class=attr>serialization</span>=<span class=string>“hessian2”</span> <span class=attr>charset</span>=<span class=string>“UTF-8”</span> <span class=attr>threadpool</span>=<span class=string>“fixed”</span> <span class=attr>threads</span>=<span class=string>“100”</span> <span class=attr>queues</span>=<span class=string>“0”</span> <span class=attr>iothreads</span>=<span class=string>“9”</span> </span></span><br><span class=line><span class=tag><span class=attr>buffer</span>=<span class=string>“8192”</span> <span class=attr>accepts</span>=<span class=string>“1000”</span> <span class=attr>payload</span>=<span class=string>“8388608”</span> /></span></span><br></pre></table></figure><li><p>Dubbo协议缺省每服务每提供者每消费者使用单一长连接，如果数据量较大，可以使用多个连接。</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"dubbo"</span> <span class=attr>connections</span>=<span class=string>"2"</span>/></span></span><br><span class=line></span><br><span class=line><span class=comment>&LT!-- 表示该服务使用JVM共享长连接。(缺省)  --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:service</span> <span class=attr>connections</span>=<span class=string>”0”</span>></span>或<span class=tag><<span class=name>dubbo:reference</span> <span class=attr>connections</span>=<span class=string>”0”</span>></span></span><br><span class=line><span class=comment>&LT!-- 表示该服务使用独立长连接。  --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:service</span> <span class=attr>connections</span>=<span class=string>”1”</span>></span>或<span class=tag><<span class=name>dubbo:reference</span> <span class=attr>connections</span>=<span class=string>”1”</span>></span></span><br><span class=line><span class=comment>&LT!-- 表示该服务使用独立两条长连接 --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:service</span> <span class=attr>connections</span>=<span class=string>”2”</span>></span>或<span class=tag><<span class=name>dubbo:reference</span> <span class=attr>connections</span>=<span class=string>”2”</span>></span></span><br></pre></table></figure><li><p>为防止被大量连接压死，可在服务提供方限制最大连接数，以实现服务提供方自我保护。</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"dubbo"</span> <span class=attr>accepts</span>=<span class=string>"1000"</span> /></span></span><br></pre></table></figure></ol><blockquote><p>**为什么消费者比提供者数量多？ **<br>因dubbo协议采用单一长连接，假设网络为千兆网卡(1024Mbit=128MByte)，根据测试经验数据每条连接最多只能压满7MByte(不同的环境可能不一样，供参考)，理论上1个服务提供者需要20个服务消费者才能压满网卡<p><strong>为什么不能传大包？</strong><br>因dubbo协议采用单一长连接，如果每次请求的数据包大小为500KByte，假设网络为千兆网卡(1024Mbit=128MByte)，每条连接最大7MByte(不同的环境可能不一样，供参考)，单个服务提供者的TPS(每秒处理事务数)最大为：128MByte / 500KByte = 262。单个消费者调用单个服务提供者的TPS(每秒处理事务数)最大为：7MByte / 500KByte = 14。如果能接受，可以考虑使用，否则网络将成为瓶颈。<p><strong>为什么采用异步单一长连接？</strong><br>因为服务的现状大都是服务提供者少，通常只有几台机器，而服务的消费者多，可能整个网站都在访问该服务。比如Morgan的提供者只有6个，但却有上百个消费者，每天1.5亿次调用，如果采用常规的hessian服务，服务提供者很容易就被压跨，通过单一连接，保证单一消费者不会压死提供者，长连接，减少连接握手验证等，并使用异步IO，复用线程池，防止C10K问题。<p>接口增加方法，对客户端无影响，如果该方法不是客户端需要的，客户端不需要重新部署； 输入参数和结果集中增加属性，对客户端无影响，如果客户端并不需要新属性，不用重新部署；<p>输入参数和结果集属性名变化，对客户端序列化无影响，但是如果客户端不重新部署，不管输入还是输出，属性名变化的属性值是获取不到的。<p>总结：服务器端 和 客户端 对 领域对象 来说并不要求必须完全一致，而是按照最大匹配原则。<p>如果不集成Spring，单独配置如：<code>dubbo.service.protocol=dubbo</code></blockquote><h2 id=2-2、rmi协议><a class=headerlink href=#2-2、rmi协议 title=2.2、rmi协议></a>2.2、rmi协议</h2><h3 id=特点-1><a class=headerlink href=#特点-1 title=特点></a>特点</h3><p>Java标准的远程调用协议。<ul><li>连接个数：多连接<li>连接方式：短连接<li>传输协议：TCP<li>传输方式：同步传输<li>序列化：Java标准二进制序列化<li>适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。<li>适用场景：常规远程服务方法调用，与原生RMI服务互操作</ul><h3 id=总结-1><a class=headerlink href=#总结-1 title=总结></a>总结</h3><p>RMI协议采用JDK标准的<code>java.rmi.*</code>实现，采用阻塞式短连接和JDK标准序列化方式<br>注： 如果正在使用RMI提供服务给外部访问（公司内网环境应该不会有攻击风险），同时应用里依赖了老的common-collections包（dubbo不会依赖这个包，请排查自己的应用有没有使用）的情况下，存在反序列化安全风险。 请检查应用：<ol><li>将commons-collections3 请升级到3.2.2版本：<br><a href=https://commons.apache.org/proper/commons-collections/release_3_2_2.html rel=noopener target=_blank>https://commons.apache.org/proper/commons-collections/release_3_2_2.html</a><li>将commons-collections4 请升级到4.1版本：<a href=https://commons.apache.org/proper/commons-collections/release_4_1.html rel=noopener target=_blank>https://commons.apache.org/proper/commons-collections/release_4_1.html</a><br>新版本的commons-collections解决了该问题</ol><p>如果服务接口继承了<code>java.rmi.Remote</code>接口，可以和原生RMI互操作，即： 提供者用Dubbo的RMI协议暴露服务，消费者直接用标准RMI接口调用，或者提供方用标准RMI暴露服务，消费方用Dubbo的RMI协议调用。<p>如果服务接口没有继承<code>java.rmi.Remote</code>接口，缺省Dubbo将自动生成一个com.xxx.XxxService$Remote的接口，并继承<code>java.rmi.Remote</code>接口，并以此接口暴露服务，<p>但如果设置了<code>&LTdubbo:protocol name="rmi" codec="spring" /></code>，将不生成$Remote接口，而使用Spring的<code>RmiInvocationHandler</code>接口暴露服务，和Spring兼容。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- Define rmi protocol --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"rmi"</span> <span class=attr>port</span>=<span class=string>"1099"</span> /></span>.</span><br><span class=line><span class=comment>&LT!-- Set default protocol: --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:provider</span> <span class=attr>protocol</span>=<span class=string>"rmi"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Set service protocol: --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:service</span> <span class=attr>protocol</span>=<span class=string>"rmi"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Multi port --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>id</span>=<span class=string>"rmi1"</span> <span class=attr>name</span>=<span class=string>"rmi"</span> <span class=attr>port</span>=<span class=string>"1099"</span> /></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>id</span>=<span class=string>"rmi2"</span> <span class=attr>name</span>=<span class=string>"rmi"</span> <span class=attr>port</span>=<span class=string>"2099"</span> /></span></span><br><span class=line><span class=tag><<span class=name>dubbo:service</span> <span class=attr>protocol</span>=<span class=string>"rmi1"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Spring compatible: --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"rmi"</span> <span class=attr>codec</span>=<span class=string>"spring"</span> /></span></span><br></pre></table></figure><h2 id=2-3、hessian协议><a class=headerlink href=#2-3、hessian协议 title=2.3、hessian协议></a>2.3、hessian协议</h2><h3 id=特点-2><a class=headerlink href=#特点-2 title=特点></a>特点</h3><p>基于Hessian的远程调用协议。Hessian 协议用于集成 Hessian 服务，Hessian 底层采用 Http 通讯，采用Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器并实现基于 Hessian 的远程调用协议。<ul><li>连接个数：多连接<li>连接方式：短连接<li>传输协议：HTTP<li>传输方式：同步传输<li>序列化：表单序列化<li>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。<li>适用场景：需同时给应用程序和浏览器JS使用的服务。</ul><h3 id=总结-2><a class=headerlink href=#总结-2 title=总结></a>总结</h3><ol><li><p>Hessian协议用于集成Hessian服务，Hessian底层通过Http通讯，通过Servlet暴露服务，Dubbo缺省内嵌Jetty服务器实现。</p><li><p>Hessian是Caucho开源的一个RPC框架：<a href=http://hessian.caucho.com,其通讯效率高于webservice和java自带的序列化./ rel=noopener target=_blank>http://hessian.caucho.com，其通讯效率高于WebService和Java自带的序列化。</a> 需要的依赖：</p></ol><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>com.caucho<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>hessian<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>4.0.7<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><p>可以和原生Hessian服务互操作，即： 提供者用Dubbo的Hessian协议暴露服务，消费者直接用标准Hessian接口调用，或者提供方用标准Hessian暴露服务，消费方用Dubbo的Hessian协议调用。<p>约束<ol><li><p>参数及返回值需实现Serializable接口。</p><li><p>参数及返回值不能自定义实现List、Map、Number、Date、Calendar等接口，只能用JDK自带的实现，因为hessian会做特殊处理，自定义实现类中的属性值都会丢失。</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- Define hessian protocol: --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"hessian"</span> <span class=attr>port</span>=<span class=string>"8080"</span> <span class=attr>server</span>=<span class=string>"jetty"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Set default protocol: --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:provider</span> <span class=attr>protocol</span>=<span class=string>"hessian"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Set service protocol: --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:service</span> <span class=attr>protocol</span>=<span class=string>"hessian"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Multi port: --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>id</span>=<span class=string>"hessian1"</span> <span class=attr>name</span>=<span class=string>"hessian"</span> <span class=attr>port</span>=<span class=string>"8080"</span> /></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>id</span>=<span class=string>"hessian2"</span> <span class=attr>name</span>=<span class=string>"hessian"</span> <span class=attr>port</span>=<span class=string>"8081"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Directly provider: --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"helloService"</span> <span class=attr>interface</span>=<span class=string>"HelloWorld"</span> <span class=attr>url</span>=<span class=string>"hessian://10.20.153.10:8080/helloWorld"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Jetty Server --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>...</span> <span class=attr>server</span>=<span class=string>"jetty"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Servlet Bridge Server --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>...</span> <span class=attr>server</span>=<span class=string>"servlet"</span> /></span></span><br></pre></table></figure></ol><p>web.xml配置:<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>servlet</span>></span></span><br><span class=line>     <span class=tag><<span class=name>servlet-name</span>></span>dubbo<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>     <span class=tag><<span class=name>servlet-class</span>></span>com.alibaba.dubbo.remoting.http.servlet.DispatcherServlet<span class=tag>&LT/<span class=name>servlet-class</span>></span></span><br><span class=line>     <span class=tag><<span class=name>load-on-startup</span>></span>1<span class=tag>&LT/<span class=name>load-on-startup</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet</span>></span></span><br><span class=line><span class=tag><<span class=name>servlet-mapping</span>></span></span><br><span class=line>     <span class=tag><<span class=name>servlet-name</span>></span>dubbo<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>     <span class=tag><<span class=name>url-pattern</span>></span>/*<span class=tag>&LT/<span class=name>url-pattern</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet-mapping</span>></span></span><br></pre></table></figure><p><font color=red>注意：使用servlet派发请求协议的端口必须与servlet容器的端口相同， 协议的上下文路径必须与servlet应用的上下文路径相同。</font><h2 id=2-4、http协议><a class=headerlink href=#2-4、http协议 title=2.4、http协议></a>2.4、http协议</h2><h3 id=特点-3><a class=headerlink href=#特点-3 title=特点></a>特点</h3><p>基于http表单的远程调用协议。<ul><li>连接个数：多连接<li>连接方式：短连接<li>传输协议：HTTP<li>传输方式：同步传输<li>序列化：表单序列化<li>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。<li>适用场景：需同时给应用程序和浏览器JS使用的服务。</ul><h3 id=总结-3><a class=headerlink href=#总结-3 title=总结></a>总结</h3><p>采用Spring的 HttpInvoker 实现配置：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"http"</span> <span class=attr>port</span>=<span class=string>"8080"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Jetty Server --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>...</span> <span class=attr>server</span>=<span class=string>"jetty"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Servlet Bridge Server --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>...</span> <span class=attr>server</span>=<span class=string>"servlet"</span> /></span></span><br></pre></table></figure><p>web.xml配置：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>servlet</span>></span></span><br><span class=line>     <span class=tag><<span class=name>servlet-name</span>></span>dubbo<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>     <span class=tag><<span class=name>servlet-class</span>></span>com.alibaba.dubbo.remoting.http.servlet.DispatcherServlet<span class=tag>&LT/<span class=name>servlet-class</span>></span></span><br><span class=line>     <span class=tag><<span class=name>load-on-startup</span>></span>1<span class=tag>&LT/<span class=name>load-on-startup</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet</span>></span></span><br><span class=line><span class=tag><<span class=name>servlet-mapping</span>></span></span><br><span class=line>     <span class=tag><<span class=name>servlet-name</span>></span>dubbo<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>     <span class=tag><<span class=name>url-pattern</span>></span>/*<span class=tag>&LT/<span class=name>url-pattern</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet-mapping</span>></span></span><br></pre></table></figure><p><font color=red>注意：如果使用 servlet 派发请求 协议的端口<code>&LTdubbo:protocol port="8080" /></code>必须与servlet容器的端口相同， 协议的上下文路径<code>&LTdubbo:protocol contextpath="foo" /></code>必须与servlet应用的上下文路径相同。</font><h2 id=2-5、webservice协议><a class=headerlink href=#2-5、webservice协议 title=2.5、webservice协议></a>2.5、webservice协议</h2><h3 id=特点-4><a class=headerlink href=#特点-4 title=特点></a>特点</h3><p>基于WebService的远程调用协议<ul><li>连接个数：多连接<li>连接方式：短连接<<li>传输协议：HTTP<li>传输方式：同步传输<li>序列化：SOAP文本序列化<li>适用场景：系统集成，跨语言调用</ul><h3 id=总结-4><a class=headerlink href=#总结-4 title=总结></a>总结</h3><ol><li>基于CXF的 frontend-simple 和 transports-http 实现。<li>CXF是Apache开源的一个RPC框架：<a href=http://cxf.apache.org,由xfire和celtix合并而来/ rel=noopener target=_blank>http://cxf.apache.org，由Xfire和Celtix合并而来</a> 。</ol><p>依赖如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.apache.cxf<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>cxf-rt-frontend-simple<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>2.6.1<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.apache.cxf<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>cxf-rt-transports-http<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>2.6.1<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><p>可以和原生WebService服务互操作，即： 提供者用Dubbo的WebService协议暴露服务，消费者直接用标准WebService接口调用，或者提供方用标准WebService暴露服务，消费方用Dubbo的WebService协议调用。<p>约束：<ol><li>参数及返回值需实现Serializable接口。<li>参数尽量使用基本类型和POJO。</ol><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- Define webservice protocol --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"webservice"</span> <span class=attr>port</span>=<span class=string>"8080"</span> <span class=attr>server</span>=<span class=string>"jetty"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Set default protocol --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:provider</span> <span class=attr>protocol</span>=<span class=string>"webservice"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Set service protocol --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:service</span> <span class=attr>protocol</span>=<span class=string>"webservice"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Multi port --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>id</span>=<span class=string>"webservice1"</span> <span class=attr>name</span>=<span class=string>"webservice"</span> <span class=attr>port</span>=<span class=string>"8080"</span> /></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>id</span>=<span class=string>"webservice2"</span> <span class=attr>name</span>=<span class=string>"webservice"</span> <span class=attr>port</span>=<span class=string>"8081"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Directly provider --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"helloService"</span> <span class=attr>interface</span>=<span class=string>"HelloWorld"</span> <span class=attr>url</span>=<span class=string>"webservice://10.20.153.10:8080/com.foo.HelloWorld"</span> /></span></span><br><span class=line><span class=comment>&LT!-- WSDL --></span></span><br><span class=line>http://10.20.153.10:8080/com.foo.HelloWorld?wsdl</span><br><span class=line><span class=comment>&LT!-- Jetty Server: (default) --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>...</span> <span class=attr>server</span>=<span class=string>"jetty"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Servlet Bridge Server: (recommend) --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>...</span> <span class=attr>server</span>=<span class=string>"servlet"</span> /></span></span><br></pre></table></figure><p>web.xml：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>servlet</span>></span></span><br><span class=line>     <span class=tag><<span class=name>servlet-name</span>></span>dubbo<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>     <span class=tag><<span class=name>servlet-class</span>></span>com.alibaba.dubbo.remoting.http.servlet.DispatcherServlet<span class=tag>&LT/<span class=name>servlet-class</span>></span></span><br><span class=line>     <span class=tag><<span class=name>load-on-startup</span>></span>1<span class=tag>&LT/<span class=name>load-on-startup</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet</span>></span></span><br><span class=line><span class=tag><<span class=name>servlet-mapping</span>></span></span><br><span class=line>     <span class=tag><<span class=name>servlet-name</span>></span>dubbo<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>     <span class=tag><<span class=name>url-pattern</span>></span>/*<span class=tag>&LT/<span class=name>url-pattern</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet-mapping</span>></span></span><br></pre></table></figure><p>注意:如果使用servlet派发请求： 协议的端口必须与servlet容器的端口相同，协议的上下文路径必须与servlet应用的上下文路径相同。<h2 id=2-6、thrift协议><a class=headerlink href=#2-6、thrift协议 title=2.6、thrift协议></a>2.6、thrift协议</h2><p><strong>当前 dubbo 支持的 thrift 协议是对 thrift 原生协议的扩展，在原生协议的基础上添加了一些额外的头信息，比如service name，magic number等。</strong>使用dubbo thrift协议同样需要使用thrift的idl compiler编译生成相应的java代码，后续版本中会在这方面做一些增强。<p>依赖：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.apache.thrift<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>libthrift<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>0.8.0<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><p>配置：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"thrift"</span> <span class=attr>port</span>=<span class=string>"3030"</span> /></span></span><br></pre></table></figure><p><font color=red>注意：Thrift不支持null值，不能在协议中传null。</font><h2 id=2-7、memcached协议><a class=headerlink href=#2-7、memcached协议 title=2.7、memcached协议></a>2.7、memcached协议</h2><p>可以通过脚本或监控中心手工填写表单注册memcached服务的地址：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</span><br><span class=line>Registry registry = registryFactory.getRegistry(URL.valueOf(<span class=string>"zookeeper://10.20.153.10:2181"</span>));</span><br><span class=line>registry.register(URL.valueOf(<span class=string>"memcached://10.20.153.11/com.foo.BarService?category=providers&dynamic=false&application=foo&group=member&loadbalance=consistenthash"</span>));</span><br></pre></table></figure><p>然后在客户端使用时，不需要感知Memcached的地址：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"cache"</span> </span></span><br><span class=line><span class=tag>            <span class=attr>interface</span>=<span class=string>"http://10.20.160.198/wiki/display/dubbo/java.util.Map"</span> <span class=attr>group</span>=<span class=string>"member"</span> /></span></span><br></pre></table></figure><p>或者点对点直连<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"cache"</span> <span class=attr>interface</span>=<span class=string>"http://10.20.160.198/wiki/display/dubbo/java.util.Map"</span> <span class=attr>url</span>=<span class=string>"memcached://10.20.153.10:11211"</span> /></span></span><br></pre></table></figure><p>自定义接口<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"cache"</span> <span class=attr>interface</span>=<span class=string>"com.foo.CacheService"</span> <span class=attr>url</span>=<span class=string>"memcached://10.20.153.10:11211"</span> /></span></span><br></pre></table></figure><p>方法名建议和memcached的标准方法名相同，即：get(key), set(key, value), delete(key)。<br>如果方法名和memcached的标准方法名不相同，则需要配置映射关系：(其中”p:xxx”为spring的标准p标签)<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"cache"</span> <span class=attr>interface</span>=<span class=string>"com.foo.CacheService"</span> <span class=attr>url</span>=<span class=string>"memcached://10.20.153.10:11211"</span> <span class=attr>p:set</span>=<span class=string>"putFoo"</span> <span class=attr>p:get</span>=<span class=string>"getFoo"</span> <span class=attr>p:delete</span>=<span class=string>"removeFoo"</span> /></span></span><br></pre></table></figure><h2 id=2-8、redis协议><a class=headerlink href=#2-8、redis协议 title=2.8、redis协议></a>2.8、redis协议</h2><p>可通过脚本或监控中心手工填写表单注册redis服务地址：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</span><br><span class=line>Registry registry = registryFactory.getRegistry(URL.valueOf(<span class=string>"zookeeper://10.20.153.10:2181"</span>));</span><br><span class=line>registry.register(URL.valueOf(<span class=string>"redis://10.20.153.11/com.foo.BarService?category=providers&dynamic=false&application=foo&group=member&loadbalance=consistenthash"</span>));</span><br></pre></table></figure><p>然后在客户端使用时，不需要感知Redis的地址：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"store"</span> <span class=attr>interface</span>=<span class=string>"http://10.20.160.198/wiki/display/dubbo/java.util.Map"</span> <span class=attr>group</span>=<span class=string>"member"</span> /></span></span><br></pre></table></figure><p>点对点直连<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"store"</span> <span class=attr>interface</span>=<span class=string>"http://10.20.160.198/wiki/display/dubbo/java.util.Map"</span> <span class=attr>url</span>=<span class=string>"redis://10.20.153.10:6379"</span> /></span></span><br></pre></table></figure><p>自定义接口<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"store"</span> <span class=attr>interface</span>=<span class=string>"com.foo.StoreService"</span> <span class=attr>url</span>=<span class=string>"redis://10.20.153.10:6379"</span> /></span></span><br></pre></table></figure><p>方法名建议和redis的标准方法名相同，即：get(key), set(key, value), delete(key)。<br>如果方法名和redis的标准方法名不相同，则需要配置映射关系：(其中”p:xxx”为spring的标准p标签)<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"cache"</span> <span class=attr>interface</span>=<span class=string>"com.foo.CacheService"</span> <span class=attr>url</span>=<span class=string>"memcached://10.20.153.10:11211"</span> <span class=attr>p:set</span>=<span class=string>"putFoo"</span> <span class=attr>p:get</span>=<span class=string>"getFoo"</span> <span class=attr>p:delete</span>=<span class=string>"removeFoo"</span> /></span></span><br></pre></table></figure><h1 id=3、Dubbo序列化><a class=headerlink href=#3、Dubbo序列化 title=3、Dubbo序列化></a>3、Dubbo序列化</h1><h2 id=3-1、简介><a class=headerlink href=#3-1、简介 title=3.1、简介></a>3.1、简介</h2><p><strong>dubbo 跨JVM调用需要进行网络通信，故需要使用序列化与反序列化。</strong><p>dubbo 中定义ObjectInput、ObjectOutput 与 Serialization 来进行数据的序列化与反序列化。<p>Serialization接口定义如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@SPI("hessian2")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Serialization</span> {</span><br><span class=line>    <span class=type>byte</span> <span class="title function_">getContentTypeId</span><span class=params>()</span>;</span><br><span class=line>    String <span class="title function_">getContentType</span><span class=params>()</span>;</span><br><span class=line>    <span class=meta>@Adaptive</span></span><br><span class=line>    ObjectOutput <span class="title function_">serialize</span><span class=params>(URL url, OutputStream output)</span> <span class=keyword>throws</span> IOException;</span><br><span class=line>    <span class=meta>@Adaptive</span></span><br><span class=line>    ObjectInput <span class="title function_">deserialize</span><span class=params>(URL url, InputStream input)</span> <span class=keyword>throws</span> IOException;</span><br><span class=line>}</span><br></pre></table></figure><p>这个接口里面定义了 4 个方法：<ul><li>getContentTypeId：获取序列化 ContextType 的 id。<li>getContentType：获取序列化的 ContentType。<li>serialize：创建一个 ObjectOutput (序列化器)，用于把对象转换序列化字节序列。<li>deserialize：创建一个 ObjectInput (反序列化器)，用于把字节序列恢复成对象。</ul><h2 id=3-2、序列化类型><a class=headerlink href=#3-2、序列化类型 title=3.2、序列化类型></a>3.2、序列化类型</h2><p>Dubbo序列化支持java、compactedjava、nativejava、fastjson、dubbo、fst、hessian2、kryo，其中默认hessian2。其中java、compactedjava、nativejava属于原生Java序列化。<ol><li><font color=orange>dubbo序列化</font>：阿里开发，尚未成熟，生产中不建议使用。<li><font color=orange>hessian2序列化</font>：hessian是一种跨语言高效二进制序列化方式。但该序列化方式不是原生的hessian2序列化，而是阿里修改过的，它是dubbo RPC默认启用的序列化方式。<li><font color=orange>json序列化</font>：一种是阿里的fastjson库，另一种是dubbo自己实现的json库，但都不是特别成熟，且json这种文本序列化性能一般，不如前两种二进制序列化。<li><font color=orange>java序列化</font>：JDK自带的序列化实现，性能不理想。</ol><p>以上 四种序列化方式的性能从上到下依次递减，dubbo默认采用hessian2序列化方式。<p>除了上面那些序列化方式外，新的高效序列化方式层出不穷，典型的包括：<ul><li>专门针对Java语言的：Kryo，FST等。<li>跨语言的：Protostuff，ProtoBuf，Thrift，Avro，MsgPack等。</ul><p>使用Kryo和FST非常简单，只需要在dubbo RPC的XML配置中添加一个属性即可：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"dubbo"</span> <span class=attr>serialization</span>=<span class=string>"kryo"</span>/></span></span><br></pre></table></figure><p>或者<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"dubbo"</span> <span class=attr>serialization</span>=<span class=string>"fst"</span>/></span></span><br></pre></table></figure><h2 id=3-3、序列化扩展><a class=headerlink href=#3-3、序列化扩展 title=3.3、序列化扩展></a>3.3、序列化扩展</h2><p><strong>可以通过扩展 Serialization、ObjectInput、ObjectOutput 来进行 dubbo 序列化的扩展。</strong><p>项目目录：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>src</span><br><span class=line> |-main</span><br><span class=line>    |-java</span><br><span class=line>        |-com</span><br><span class=line>            |-xxx</span><br><span class=line>                |-XxxSerialization.java (实现Serialization接口)</span><br><span class=line>                |-XxxObjectInput.java (实现ObjectInput接口)</span><br><span class=line>                |-XxxObjectOutput.java (实现ObjectOutput接口)</span><br><span class=line>    |-resources</span><br><span class=line>        |-META-INF</span><br><span class=line>            |-dubbo</span><br><span class=line>                |-com.alibaba.dubbo.common.serialize.Serialization (纯文本文件，内容为：xxx=com.xxx.XxxSerialization)</span><br></pre></table></figure><p>XxxSerialization.java：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.xxx;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> com.alibaba.dubbo.common.serialize.Serialization;</span><br><span class=line><span class=keyword>import</span> com.alibaba.dubbo.common.serialize.ObjectInput;</span><br><span class=line><span class=keyword>import</span> com.alibaba.dubbo.common.serialize.ObjectOutput;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">XxxSerialization</span> <span class=keyword>implements</span> <span class="title class_">Serialization</span> {</span><br><span class=line>    <span class=keyword>public</span> ObjectOutput <span class="title function_">serialize</span><span class=params>(Parameters parameters, OutputStream output)</span> <span class=keyword>throws</span> IOException {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">XxxObjectOutput</span>(output);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> ObjectInput <span class="title function_">deserialize</span><span class=params>(Parameters parameters, InputStream input)</span> <span class=keyword>throws</span> IOException {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">XxxObjectInput</span>(input);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>META-INF/dubbo/com.alibaba.dubbo.common.serialize.Serialization：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>xxx=com.xxx.XxxSerialization</span><br></pre></table></figure><p>并且通过以下配置来使用新扩展。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- 协议 序列化方式 --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>serialization</span>=<span class=string>"xxx"</span> /></span></span><br><span class=line><span class=comment>&LT!-- 缺省值设置，当&LTdubbo:protocol>没有配置serialization时，使用此配置 --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:provider</span> <span class=attr>serialization</span>=<span class=string>"xxx"</span> /></span></span><br></pre></table></figure><h1 id=4、底层实现><a class=headerlink href=#4、底层实现 title=4、底层实现></a>4、底层实现</h1><h2 id=4-1、服务注册中心><a class=headerlink href=#4-1、服务注册中心 title=4.1、服务注册中心></a>4.1、服务注册中心</h2><p>分布式系统的必备组件，服务提供者和服务消费者在启动时都会注册自己至服务注册中心。<h2 id=4-2、动态代理Proxy><a class=headerlink href=#4-2、动态代理Proxy title=4.2、动态代理Proxy></a>4.2、动态代理Proxy</h2><p>该类框架基本思想：接口生成一个代理对象，然后在代理对象中编写功能实现。<p>所以只需每个服务都提供接口，且在消费者调用时创建一个动态代理对象，然后消费者可通过该代理对象进行调用。<h2 id=4-3、Cluster集群层><a class=headerlink href=#4-3、Cluster集群层 title=4.3、Cluster集群层></a>4.3、Cluster集群层</h2><h3 id=4-3-1、简介><a class=headerlink href=#4-3-1、简介 title=4.3.1、简介></a>4.3.1、简介</h3><p><img alt=image-20230807161954071 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20230807161954071.png><p>各节点关系：<ul><li><p>Cluster</p> <p>将Directory中的多个Invoker伪装成一个 Invoker，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个；</p><li><p>Invoker</p> <p>是Provider的一个可调用Service的抽象，Invoker封装了Provider地址及Service接口信息；</p><li><p>Directory</p> <p>代表多个Invoker，可以看成是List ，但与List不同的是，它的值可能动态变化，比如注册中心推送变更；</p><li><p>Router</p> <p>负责从多个Invoker中按路由规则选出子集，比如读写分离，应用隔离等；</p><li><p>LoadBalance</p> <p>负责从多个Invoker中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选；</p></ul><p><strong>Cluster层使命：挑选并返回一个服务提供者。</strong><p>Cluster层在选择一个服务时，必须先获取所有服务提供者，获取的过程称为 动态感知。成功获取后，会通过Cluster层中的负载均衡组件<code>LoadBlance</code>（Cluster层有很多组件，比如 Directory、Router、LoadBalance等）来挑选一个服务。<h3 id=4-3-2、LoadBlance组件><a class=headerlink href=#4-3-2、LoadBlance组件 title=4.3.2、LoadBlance组件></a>4.3.2、LoadBlance组件</h3><p>dubbo默认提供了多种策略：<ul><li><font color=orange>Random LoadBalance（随机）</font>：按权重设置随机概率，在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重；<li><font color=orange>RoundRobin LoadBalance（轮询）</font>：按公约后的权重设置轮询比率；存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上；<li><font color=orange>LeastActive LoadBalance（最小活跃数，相同则随机）</font>：活跃数是指调用前后计数差；使得 效率低的服务提供者收到更少请求，因为提供者效率越低其调用前后计数差就会越大；<li><font color=orange>ConsistentHash LoadBalance（一致性hash）</font>：相同参数的请求会被提交给同一提供者；当某一台提供者挂时，原本发往该提供者的请求会基于虚拟节点平摊给其它提供者，不会引起剧烈变动；</ul><p>SPI定义默认策略为<code>Random LoadBalance</code>，提供了一个select方法，通过策略 从服务列表中选择一个invoker。可以自行扩展负载均衡策略；接口类如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>@SPI(RandomLoadBalance.NAME)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">LoadBalance</span> {</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * select one invoker in list.</span></span><br><span class=line><span class=comment>     *</span></span><br><span class=line><span class=comment>     * <span class=doctag>@param</span> invokers   invokers.</span></span><br><span class=line><span class=comment>     * <span class=doctag>@param</span> url        refer url</span></span><br><span class=line><span class=comment>     * <span class=doctag>@param</span> invocation invocation.</span></span><br><span class=line><span class=comment>     * <span class=doctag>@return</span> selected invoker.</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=meta>@Adaptive("loadbalance")</span></span><br><span class=line>    &LTT> Invoker&LTT> <span class="title function_">select</span><span class=params>(List&LTInvoker&LTT>> invokers, URL url, Invocation invocation)</span> <span class=keyword>throws</span> RpcException;</span><br><span class=line>}</span><br></pre></table></figure><h2 id=4-4、Exchange信息交换层><a class=headerlink href=#4-4、Exchange信息交换层 title=4.4、Exchange信息交换层></a>4.4、Exchange信息交换层</h2><p>该层使命：<strong>把我们的请求数据包装成 Request 或 Response</strong> 。<h2 id=4-5、Transport-网络通信层><a title="4.5、Transport 网络通信层" class=headerlink href=#4-5、Transport-网络通信层></a>4.5、Transport 网络通信层</h2><p>该层使命： <strong>消费者将封装好的请求先进行序列化，再通过一个网络通信框架（比如netty） 发送至某一个服务提供者。</strong><blockquote><p>序列化方式有多种，比如Json、Protobuf、Protostuff、Hessian、Kryo等、Java序列化等。</blockquote><h2 id=4-6、服务消费者接收到响应><a class=headerlink href=#4-6、服务消费者接收到响应 title=4.6、服务消费者接收到响应></a>4.6、服务消费者接收到响应</h2><p>服务提供者也需要通过一个网络通信框架（比如netty）去监听消费者开放的端口。收到请求后先反序列化再解析，然后创建一个动态代理对象，并调用我们的服务提供者接口来返回数据。<h1 id=5、Dubbo-SPI机制><a title="5、Dubbo SPI机制" class=headerlink href=#5、Dubbo-SPI机制></a>5、Dubbo SPI机制</h1><h2 id=5-1、SPI定义><a class=headerlink href=#5-1、SPI定义 title=5.1、SPI定义></a>5.1、SPI定义</h2><p><strong>SPI 是 Service Provider Interface 的缩写，意为服务提供接口，是一种服务发现机制。SPI的本质是将接口的实现类全限定名定义在配置文件中，然后服务器读取配置文件并加载实现类。这样就可以在运行时动态为接口修改实现类。</strong><h2 id=5-2、JDK-SPI-和-Dubbo-SPI><a title="5.2、JDK SPI 和 Dubbo SPI" class=headerlink href=#5-2、JDK-SPI-和-Dubbo-SPI></a>5.2、JDK SPI 和 Dubbo SPI</h2><h3 id=5-2-1、JDK-SPI><a title="5.2.1、JDK SPI" class=headerlink href=#5-2-1、JDK-SPI></a>5.2.1、JDK SPI</h3><h4 id=简介><a class=headerlink href=#简介 title=简介></a>简介</h4><p><strong>Java SPI 实际上是 接口编程＋策略模式＋配置文件 组合实现的动态加载机制。</strong><p>定义一个接口和两个实现：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">User</span> {</span><br><span class=line>    String <span class="title function_">showName</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line><span class=comment>// ---</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Student</span> <span class=keyword>implements</span> <span class="title class_">User</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">showName</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"my name is laowang"</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=comment>// ---</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Teacher</span> <span class=keyword>implements</span> <span class="title class_">User</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">showName</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"my name is zhangsan"</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>在resources目录下创建文件夹META-INF.services，并在该文件夹下创建一个名称与User的全路径一致的文件，例如cn.shh.service.User，然后在文件中写入，两个实现类的全路径名：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>cn.shh.service.impl.Student</span><br><span class=line>cn.shh.service.impl.Teacher</span><br></pre></table></figure><p>编写一个测试类来测试其效果：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SpiTest</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        ServiceLoader&LTUser> serviceLoader = ServiceLoader.load(User.class);</span><br><span class=line>        serviceLoader.forEach(User::showName);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>通过SPI机制，可以自动运行两个实现类。通过查看源码可知其原理：<strong>读取配置文件中实现类的全路径类名，然后通过反射创建对象并放入providers容器中。</strong><h4 id=总结-5><a class=headerlink href=#总结-5 title=总结></a>总结</h4><ul><li><p>调用过程</p> <p>调用<code>ServiceLoader.load</code>创建一个新ServiceLoader，并实例化该类中的成员变量，通过迭代器获取对象实例。ServiceLoader先判断成员变量 providers 对象中（LinkedHashMap&LTString,S>类型）是否有缓存实例对象，如果有缓存，直接返回。如果没有缓存，执行类的装载。</p><li><p>优点</p> <ol><li>Java SPI 优点是解耦，使得接口的定义与具体业务实现分离。<li>应用进程可以根据实际业务情况启用或替换具体组件。</ol><li><p>缺点</p> <ol><li>不能按需加载。虽然ServiceLoader 做了延迟载入，但是基本只能通过遍历全部来获取，也就是接口的实现类得全部载入并实例化一遍。<li>获取某个实现类的方式不够灵活，只能通过Iterator 遍历来获取，不能根据某个参数来获取对应的实现类。<li>多线程使用ServiceLoader实例，不安全。<li>加载不到实现类时会抛出一个无关异常，很难定位错误。</ol></ul><h3 id=5-2-2、Dubbo-SPI><a title="5.2.2、Dubbo SPI" class=headerlink href=#5-2-2、Dubbo-SPI></a>5.2.2、Dubbo SPI</h3><h4 id=简介-1><a class=headerlink href=#简介-1 title=简介></a>简介</h4><p>Dubbo 并未使用Java SPI，而是重新实现了一套功能更强的SPI 机制。Dubbo SPI 的相关逻辑被封装在了ExtensionLoader 类中，通过ExtensionLoader可以加载指定的实现类。<p><strong>与Java SPI不同，Dubbo SPI是通过键值对方式进行配置，这样可以按需加载指定实现类。</strong>比如：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>optimusPrime=org.apache.spi.OptimusPrime</span><br><span class=line>bumblebee=org.apache.spi.Bumblebee</span><br></pre></table></figure><p><strong>在使用Dubbo SPI 时，需要在接口上标注@SPI 注解。</strong>例如：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@SPI</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Robot</span> {</span><br><span class=line>	<span class=keyword>void</span> <span class="title function_">sayHello</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>通过ExtensionLoader，我们可以加载指定的实现类，下面来演示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DubboSPITest</span> {</span><br><span class=line>   <span class=meta>@Test</span></span><br><span class=line>   <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">sayHello</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>       ExtensionLoader&LTRobot> extensionLoader = ExtensionLoader.getExtensionLoader(Robot.class);</span><br><span class=line>       <span class=type>Robot</span> <span class=variable>optimusPrime</span> <span class=operator>=</span> extensionLoader.getExtension(<span class=string>"optimusPrime"</span>);</span><br><span class=line>       optimusPrime.sayHello();</span><br><span class=line>       <span class=type>Robot</span> <span class=variable>bumblebee</span> <span class=operator>=</span> extensionLoader.getExtension(<span class=string>"bumblebee"</span>);</span><br><span class=line>       bumblebee.sayHello();</span><br><span class=line>   }</span><br><span class=line>}</span><br></pre></table></figure><p><font color=red>注意：Dubbo SPI 除了支持按需加载接口实现类外，还增加了IOC 和AOP 等特性。</font><h4 id=源码分析><a class=headerlink href=#源码分析 title=源码分析></a>源码分析</h4><p>ExtensionLoader 的getExtensionLoader 方法获取一个ExtensionLoader 实例，然后再通过ExtensionLoader 的getExtension 方法获取拓展类对象。<p>下面我们从ExtensionLoader 的getExtension 方法作为入口，对拓展类对象的获取过程进行详细的分析。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> T <span class="title function_">getExtension</span><span class=params>(String name)</span> {</span><br><span class=line>       <span class=keyword>if</span> (StringUtils.isEmpty(name)) {</span><br><span class=line>           <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalArgumentException</span>(<span class=string>"Extension name == null"</span>);</span><br><span class=line>       }</span><br><span class=line>       <span class=keyword>if</span> (<span class=string>"true"</span>.equals(name)) {</span><br><span class=line>            <span class=comment>// 获取默认的拓展实现类</span></span><br><span class=line>           <span class=keyword>return</span> getDefaultExtension();</span><br><span class=line>       }</span><br><span class=line>       <span class=comment>// Holder，顾名思义，用于持有目标对象 就是从容器中获取,如果没有直接new一个Holder</span></span><br><span class=line>       Holder&LTObject> holder = getOrCreateHolder(name);</span><br><span class=line>       <span class=comment>//获取目标对象实例</span></span><br><span class=line>       <span class=type>Object</span> <span class=variable>instance</span> <span class=operator>=</span> holder.get();</span><br><span class=line>        <span class=comment>// 如果目标对象实例为null 就需要通过双重检查创建实例</span></span><br><span class=line>       <span class=keyword>if</span> (instance == <span class=literal>null</span>) {</span><br><span class=line>           <span class=keyword>synchronized</span> (holder) {</span><br><span class=line>               instance = holder.get();</span><br><span class=line>               <span class=keyword>if</span> (instance == <span class=literal>null</span>) {</span><br><span class=line>                   <span class=comment>// 创建拓展实例</span></span><br><span class=line>                   instance = createExtension(name);</span><br><span class=line>                   <span class=comment>// 设置实例到 holder 中</span></span><br><span class=line>                   holder.set(instance);</span><br><span class=line>               }</span><br><span class=line>           }</span><br><span class=line>       }</span><br><span class=line>       <span class=keyword>return</span> (T) instance;</span><br><span class=line>}</span><br></pre></table></figure><p>上面代码逻辑比较简单，首先检查缓存，缓存未命中则创建拓展对象。<p>下面我们来看一下创建拓展对象的过程是怎样的。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> T <span class="title function_">createExtension</span><span class=params>(String name)</span> {</span><br><span class=line>   <span class=comment>// 从配置文件中加载所有的拓展类，可得到“配置项名称”到“配置类”的映射关系表</span></span><br><span class=line>   Class&LT?> clazz = getExtensionClasses().get(name);</span><br><span class=line>   <span class=keyword>if</span> (clazz == <span class=literal>null</span>) {</span><br><span class=line>       <span class=keyword>throw</span> findException(name);</span><br><span class=line>   }</span><br><span class=line>   <span class=keyword>try</span> {</span><br><span class=line>       <span class=comment>//从容器中获取对应的实例对象 如果不存在就通过反射创建</span></span><br><span class=line>       <span class=type>T</span> <span class=variable>instance</span> <span class=operator>=</span> (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class=line>       <span class=keyword>if</span> (instance == <span class=literal>null</span>) {</span><br><span class=line>           <span class=comment>// 通过反射创建实例</span></span><br><span class=line>           EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class=line>           instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class=line>       }</span><br><span class=line>       <span class=comment>// 向实例中注入依赖 下面是IOC和AOP的实现</span></span><br><span class=line>       injectExtension(instance);</span><br><span class=line>       Set&LTClass&LT?>> wrapperClasses = cachedWrapperClasses;</span><br><span class=line>       <span class=keyword>if</span> (CollectionUtils.isNotEmpty(wrapperClasses)) {</span><br><span class=line>             <span class=comment>// 循环创建 Wrapper 实例</span></span><br><span class=line>           <span class=keyword>for</span> (Class&LT?> wrapperClass : wrapperClasses) {</span><br><span class=line>               <span class=comment>// 将当前 instance 作为参数传给 Wrapper 的构造方法，并通过反射创建Wrapper 实例。</span></span><br><span class=line>               <span class=comment>// 然后向 Wrapper 实例中注入依赖，最后将 Wrapper 实例再次赋值给instance 变量</span></span><br><span class=line>               instance = injectExtension(</span><br><span class=line>                   (T)</span><br><span class=line>wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class=line>           }</span><br><span class=line>}</span><br></pre></table></figure><p>createExtension 方法的逻辑稍复杂一下，包含了如下的步骤：<ol><li>通过getExtensionClasses 获取所有的拓展类<li>通过反射创建拓展对象<li>向拓展对象中注入依赖<li>将拓展对象包裹在相应的Wrapper 对象中</ol><p>以上步骤中，第一个步骤是加载拓展类的关键，第三和第四个步骤是Dubbo IOC 与AOP 的具体实现。由于此类设计源码较多，这里简单的总结下ExtensionLoader整个执行逻辑：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>getExtension(String name)  #根据key获取拓展对象</span><br><span class=line>    -->createExtension(String name) #创建拓展实例</span><br><span class=line>        -->getExtensionClasses #根据路径获取所有的拓展类</span><br><span class=line>            -->loadExtensionClasses #加载拓展类</span><br><span class=line>                -->cacheDefaultExtensionName #解析@SPI注解</span><br><span class=line>            -->loadDirectory #方法加载指定文件夹配置文件</span><br><span class=line>                -->loadResource #加载资源</span><br><span class=line>                    -->loadClass #加载类，并通过 loadClass 方法对类进行缓存</span><br></pre></table></figure><h2 id=5-3、Dubbo-SPI-实现-IOC和AOP><a title="5.3、Dubbo SPI 实现 IOC和AOP" class=headerlink href=#5-3、Dubbo-SPI-实现-IOC和AOP></a>5.3、Dubbo SPI 实现 IOC和AOP</h2><h3 id=5-3-1、Dubbo-IOC><a title="5.3.1、Dubbo IOC" class=headerlink href=#5-3-1、Dubbo-IOC></a>5.3.1、Dubbo IOC</h3><p><strong>Dubbo IOC 是通过 setter方式 注入依赖。Dubbo 首先会通过反射获取实例所有方法，然后再遍历方法列表，检测方法名是否具有setter 方法特征。若有，则通过 ObjectFactory 获取依赖对象，最后通过反射调用setter 方法将依赖设置到目标对象中。</strong><h3 id=5-3-2、Dubbo-AOP><a title="5.3.2、Dubbo AOP" class=headerlink href=#5-3-2、Dubbo-AOP></a>5.3.2、Dubbo AOP</h3><p>分析之前先了解一下装饰者模式<p>装饰者模式：在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象来包裹真实对象。<p>Dubbo Aop原理：<strong>Dubbo支持AOP得益于Dubbo中称为Wrapper的类。通过装饰者模式，使用包装类包装原始的扩展点实例，在原始扩展点实现前后插入其他逻辑，实现AOP功能。</strong><p>装饰者模式 一般有如下参与者：<ol><li><font color=orange>Component</font>：装饰者和被装饰者共同的父类，是一个接口或者抽象类，用来定义基本行为。<li><font color=orange>ConcreteComponent</font>：定义具体对象，即被装饰者。<li><font color=orange>Decorator</font>：抽象装饰者，继承自Component，从外类来扩展ConcreteComponent。对于ConcreteComponent来说，不需要知道Decorator的存在，Decorator是一个接口或抽象类。<li><font color=orange>ConcreteDecorator</font>：具体装饰者，用于扩展ConcreteComponent。</ol><p>cachedWrapperClasses是一个set集合，那么集合何时添加元素呢?<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> Set&LTClass&LT?>> cachedWrapperClasses;</span><br></pre></table></figure><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">cacheWrapperClass</span><span class=params>(Class&LT?> clazz)</span> {</span><br><span class=line>    <span class=keyword>if</span> (cachedWrapperClasses == <span class=literal>null</span>) {</span><br><span class=line>        cachedWrapperClasses = <span class=keyword>new</span> <span class="title class_">ConcurrentHashSet</span><>();</span><br><span class=line>    }</span><br><span class=line>    cachedWrapperClasses.add(clazz);</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=type>boolean</span> <span class="title function_">isWrapperClass</span><span class=params>(Class&LT?> clazz)</span> {</span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        clazz.getConstructor(type);</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    } <span class=keyword>catch</span> (NoSuchMethodException e) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h1 id=6、Dubbo动态编译><a class=headerlink href=#6、Dubbo动态编译 title=6、Dubbo动态编译></a>6、Dubbo动态编译</h1><p>Dubbo很多拓展 都是通过【SPI 机制】加载，比如Protocol、Cluster、LoadBalance、ProxyFactory 等。但是有些拓展并不希望在框架启动时就去加载，而是希望在拓展方法被调用时根据参数来进行加载，即根据参数动态加载实现类。<p><strong>运行时根据方法参数动态决定使用何种拓展方式就叫 扩展点自适应实例。</strong>其实就是一个扩展点代理，将扩展的选择时机从Dubbo启动时延迟到RPC调用时。Dubbo中每一个扩展点都有一个自适应类，如果没有显式提供，Dubbo会自动为我们创建一个，默认使用Javaassist。<p>自适应拓展机制 实现逻辑 如下：<ol><li>首先Dubbo 会为拓展接口生成具有代理功能的代码；<li>通过Javassist 或JDK编译这段代码，得到Class 类；<li>通过反射创建代理类；<li>在代理类中，通过URL对象的参数来确定到底调用哪个实现类；</ol><h2 id=6-1、Javassist><a class=headerlink href=#6-1、Javassist title=6.1、Javassist></a>6.1、Javassist</h2><p><strong>Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的Shigeru Chiba （千叶滋）创建。</strong><p>Javassist是Jboss的一个子项目，其主要优点是简单、快速。直接通过Java编码而不需要了解虚拟机指令就能动态改变类的结构，或者动态生成类。<h2 id=6-2、源码分析><a class=headerlink href=#6-2、源码分析 title=6.2、源码分析></a>6.2、源码分析</h2><p>Adaptive注解：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=meta>@Documented</span></span><br><span class=line><span class=meta>@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=line><span class=meta>@Target({ElementType.TYPE, ElementType.METHOD})</span></span><br><span class=line><span class=keyword>public</span> <span class=meta>@interface</span> Adaptive {</span><br><span class=line>   String[] value() <span class=keyword>default</span> {};</span><br><span class=line>}</span><br></pre></table></figure><p>Adaptive 可注解在类或方法上。<ul><li>标注在类上：Dubbo 不会为该类生成代理类。<li>标注在方法上：Dubbo 会为该方法生成代理逻辑，表示当前方法需要根据 参数URL 调用对应的扩展点实现。</ul><p>dubbo中每一个扩展点都有一个自适应类，如果没有显式提供，Dubbo会自动为我们创建一个，默认使用Javaassist。 先来看下创建自适应扩展类的代码。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br></pre><td class=code><pre><span class=line><span class=comment>// 1、看下extensionLoader的获取方法</span></span><br><span class=line>ExtensionLoader&LTRobot>extensionLoader=ExtensionLoader.getExtensionLoader(Robot.class);</span><br><span class=line></span><br><span class=line><span class=comment>// 2、最终调用的是ExtensionLoader的构造方法</span></span><br><span class=line><span class=keyword>private</span> <span class="title function_">ExtensionLoader</span><span class=params>(Class&LT?> type)</span> {</span><br><span class=line>        <span class=built_in>this</span>.type = type;</span><br><span class=line>        objectFactory = (type == ExtensionFactory.class ? <span class=literal>null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 3、getAdaptiveExtension()看看干了什么事</span></span><br><span class=line><span class=keyword>public</span> T <span class="title function_">getAdaptiveExtension</span><span class=params>()</span> {</span><br><span class=line>    <span class=comment>// 获取自适应扩展类，如果没有就初始化一个</span></span><br><span class=line>    <span class=type>Object</span> <span class=variable>instance</span> <span class=operator>=</span> cachedAdaptiveInstance.get();</span><br><span class=line>    <span class=keyword>if</span> (instance == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>if</span> (createAdaptiveInstanceError == <span class=literal>null</span>) {</span><br><span class=line>            <span class=keyword>synchronized</span> (cachedAdaptiveInstance) {</span><br><span class=line>                instance = cachedAdaptiveInstance.get();</span><br><span class=line>                <span class=keyword>if</span> (instance == <span class=literal>null</span>) {</span><br><span class=line>                    <span class=keyword>try</span> {</span><br><span class=line>                        <span class=comment>// 创建一个自适应扩展类</span></span><br><span class=line>                        instance = createAdaptiveExtension();</span><br><span class=line>                        cachedAdaptiveInstance.set(instance);</span><br><span class=line>                    } <span class=keyword>catch</span> (Throwable t) {</span><br><span class=line>                        createAdaptiveInstanceError = t;</span><br><span class=line>                        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalStateException</span>(<span class=string>"Failed to create adaptive instance: "</span> + t.toString(), t);</span><br><span class=line>                    }</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalStateException</span>(<span class=string>"Failed to create adaptive instance: "</span> + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> (T) instance;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>//看看createAdaptiveExtension()</span></span><br><span class=line><span class=keyword>private</span> T <span class="title function_">createAdaptiveExtension</span><span class=params>()</span> {</span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        <span class=keyword>return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class=line>    } <span class=keyword>catch</span> (Exception e) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalStateException</span>(<span class=string>"Can't create adaptive extension "</span> + type + <span class=string>", cause: "</span> + e.getMessage(), e);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>//再进到getAdaptiveExtensionClass()</span></span><br><span class=line><span class=keyword>private</span> Class&LT?> getAdaptiveExtensionClass() {</span><br><span class=line>    getExtensionClasses();</span><br><span class=line>    <span class=keyword>if</span> (cachedAdaptiveClass != <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>return</span> cachedAdaptiveClass;</span><br><span class=line>    }</span><br><span class=line>    <span class=type>return</span> <span class=variable>cachedAdaptiveClass</span> <span class=operator>=</span> createAdaptiveExtensionClass();</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>//继续追进去createAdaptiveExtensionClass()</span></span><br><span class=line><span class=keyword>private</span> Class&LT?> createAdaptiveExtensionClass() {</span><br><span class=line>        <span class=type>String</span> <span class=variable>code</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AdaptiveClassCodeGenerator</span>(type, cachedDefaultName).generate();</span><br><span class=line>        <span class=type>ClassLoader</span> <span class=variable>classLoader</span> <span class=operator>=</span> findClassLoader();</span><br><span class=line>        org.apache.dubbo.common.compiler.<span class=type>Compiler</span> <span class=variable>compiler</span> <span class=operator>=</span> ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class=line>        <span class=keyword>return</span> compiler.compile(code, classLoader);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>//看看compiler</span></span><br><span class=line><span class=meta>@SPI("javassist")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Compiler</span> {</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * Compile java source code.</span></span><br><span class=line><span class=comment>     *</span></span><br><span class=line><span class=comment>     * <span class=doctag>@param</span> code        Java source code</span></span><br><span class=line><span class=comment>     * <span class=doctag>@param</span> classLoader classloader</span></span><br><span class=line><span class=comment>     * <span class=doctag>@return</span> Compiled class</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    Class&LT?> compile(String code, ClassLoader classLoader);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>//其实到这里就知道了,通过生成一个类的字符串,再通过javassist生成一个对象</span></span><br></pre></table></figure><p>createAdaptiveExtensionClassCode()方法中使用一个 StringBuilder 来构建自适应类的Java源码。这种生成字节码的方式是：先生成Java源代码，然后编译并加载到JVM中。<p>通过这种方式，可以更好的控制生成的Java类。而且不用关心字节码框架API的使用。因为xxx.java文件是Java通用的，也是我们最熟悉的。只是代码的可读性不强，需要一点一点构建xx.java的内容。<h1 id=7、服务暴漏与发现><a class=headerlink href=#7、服务暴漏与发现 title=7、服务暴漏与发现></a>7、服务暴漏与发现</h1><h2 id=7-1、服务暴漏><a class=headerlink href=#7-1、服务暴漏 title=7.1、服务暴漏></a>7.1、服务暴漏</h2><h3 id=7-1-1、名词解释><a class=headerlink href=#7-1-1、名词解释 title=7.1.1、名词解释></a>7.1.1、名词解释</h3><ul><li><font color=orange>Invoker实体域</font>：它是Dubbo 的核心模型，其它模型可转换成它，它代表一个可执行体，可向它发起invoke 调用，它有可能是一个本地实现、或远程实现、或集群实现。在服务提供方，Invoker用于调用服务提供类。在服务消费方，Invoker用于执行远程调用。<li><font color=orange>Protocol 服务域</font>：它是Invoker 暴露和引用的主功能入口，负责Invoker 的生命周期管理。<ul><li>export：暴露远程服务；<li>refer：引用远程服务；</ul><li><font color=orange>proxyFactory</font>：获取一个接口的代理类；<ul><li>getInvoker：针对server端，将服务对象，如DemoServiceImpl包装成一个Invoker对象；<li>getProxy：针对client端，创建接口的代理对象，例如DemoService的接口；</ul><li><font color=orange>Invocation会话域</font>：它持有调用过程中的变量，比如方法名，参数等；</ul><h3 id=7-1-2、整体流程><a class=headerlink href=#7-1-2、整体流程 title=7.1.2、整体流程></a>7.1.2、整体流程</h3><p><strong>Dubbo 服务暴露分两分：第一步 将持有的服务实例 通过代理 转换成 Invoker，第二步将Invoker 通过具体的协议（比如Dubbo）转换成Exporter，框架做了这层抽象也大大方便了功能扩展。</strong><p>服务提供方暴露服务的初始化链，时序图如下：<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/dubbo%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E6%9A%B4%E6%BC%8F%E6%9C%8D%E5%8A%A1%E6%B5%81%E7%A8%8B01.jpg><h3 id=7-1-3、源码分析><a class=headerlink href=#7-1-3、源码分析 title=7.1.3、源码分析></a>7.1.3、源码分析</h3><p>服务导出 入口方法是 ServiceBean 的 onApplicationEvent。onApplicationEvent 是一个事件响应方法，该方法会在收到Spring 上下文刷新事件后执行服务导出操作。方法代码如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">onApplicationEvent</span><span class=params>(ContextRefreshedEvent event)</span> {</span><br><span class=line>        <span class=keyword>if</span> (!isExported() && !isUnexported()) {</span><br><span class=line>            <span class=keyword>if</span> (logger.isInfoEnabled()) {</span><br><span class=line>                logger.info(<span class=string>"The service ready on spring started. service: "</span> + getInterface());</span><br><span class=line>            }</span><br><span class=line>            export();</span><br><span class=line>        }</span><br><span class=line>    }</span><br></pre></table></figure><p>通过export最终找到doExportUrls()方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">doExportUrls</span><span class=params>()</span> {</span><br><span class=line>    	<span class=comment>//加载配置文件中的所有注册中心，并且封装为dubbo内部的URL对象列表</span></span><br><span class=line>        List&LTURL> registryURLs = loadRegistries(<span class=literal>true</span>);</span><br><span class=line>        <span class=comment>//循环所有协议配置，根据不同的协议，向注册中心中发起注册</span></span><br><span class=line>        <span class=keyword>for</span> (ProtocolConfig protocolConfig : protocols) {</span><br><span class=line>            <span class=type>String</span> <span class=variable>pathKey</span> <span class=operator>=</span> URL.buildKey(getContextPath(protocolConfig).map(p -> p + <span class=string>"/"</span> + path).orElse(path), group, version);</span><br><span class=line>            <span class=type>ProviderModel</span> <span class=variable>providerModel</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ProviderModel</span>(pathKey, ref, interfaceClass);</span><br><span class=line>            ApplicationModel.initProviderModel(pathKey, providerModel);</span><br><span class=line>            <span class=comment>//服务暴露方法</span></span><br><span class=line>            doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class=line>        }</span><br><span class=line>    }</span><br></pre></table></figure><p>doExportUrlsFor1Protocol()方法代码老多了，我们只关系核心的地方：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br></pre><td class=code><pre><span class=line><span class=keyword>if</span> (!SCOPE_NONE.equalsIgnoreCase(scope)) {</span><br><span class=line>    <span class=comment>//本地暴露，将服务数据记录到本地JVM中</span></span><br><span class=line>    <span class=keyword>if</span> (!SCOPE_REMOTE.equalsIgnoreCase(scope)) {</span><br><span class=line>        exportLocal(url);</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>//远程暴露，向注册中心发送数据</span></span><br><span class=line>    <span class=keyword>if</span> (!SCOPE_LOCAL.equalsIgnoreCase(scope)) {</span><br><span class=line>        <span class=keyword>if</span> (!isOnlyInJvm() && logger.isInfoEnabled()) {</span><br><span class=line>            logger.info(<span class=string>"Export dubbo service "</span> + interfaceClass.getName() + <span class=string>" to url "</span> + url);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (CollectionUtils.isNotEmpty(registryURLs)) {</span><br><span class=line>            <span class=keyword>for</span> (URL registryURL : registryURLs) {</span><br><span class=line>                <span class=comment>//if protocol is only injvm ,not register</span></span><br><span class=line>                <span class=keyword>if</span> (LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) {</span><br><span class=line>                    <span class=keyword>continue</span>;</span><br><span class=line>                }</span><br><span class=line>                url = url.addParameterIfAbsent(DYNAMIC_KEY, registryURL.getParameter(DYNAMIC_KEY));</span><br><span class=line>                <span class=type>URL</span> <span class=variable>monitorUrl</span> <span class=operator>=</span> loadMonitor(registryURL);</span><br><span class=line>                <span class=keyword>if</span> (monitorUrl != <span class=literal>null</span>) {</span><br><span class=line>                    url = url.addParameterAndEncoded(MONITOR_KEY, monitorUrl.toFullString());</span><br><span class=line>                }</span><br><span class=line>                <span class=keyword>if</span> (logger.isInfoEnabled()) {</span><br><span class=line>                    logger.info(<span class=string>"Register dubbo service "</span> + interfaceClass.getName() + <span class=string>" url "</span> + url + <span class=string>" to registry "</span> + registryURL);</span><br><span class=line>                }</span><br><span class=line></span><br><span class=line>                <span class=comment>// For providers, this is used to enable custom proxy to generate invoker</span></span><br><span class=line>                <span class=type>String</span> <span class=variable>proxy</span> <span class=operator>=</span> url.getParameter(PROXY_KEY);</span><br><span class=line>                <span class=keyword>if</span> (StringUtils.isNotEmpty(proxy)) {</span><br><span class=line>                    registryURL = registryURL.addParameter(PROXY_KEY, proxy);</span><br><span class=line>                }</span><br><span class=line>                <span class=comment>// 为服务提供类(ref)生成 Invoker</span></span><br><span class=line>                Invoker&LT?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));</span><br><span class=line>                <span class=comment>// DelegateProviderMetaDataInvoker 用于持有 Invoker 和ServiceConfig</span></span><br><span class=line>                <span class=type>DelegateProviderMetaDataInvoker</span> <span class=variable>wrapperInvoker</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">DelegateProviderMetaDataInvoker</span>(invoker, <span class=built_in>this</span>);</span><br><span class=line>                <span class=comment>// 导出服务，并生成 Exporter</span></span><br><span class=line>                Exporter&LT?> exporter = protocol.export(wrapperInvoker);</span><br><span class=line>                exporters.add(exporter);</span><br><span class=line>            }</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=comment>//不存在注册中心,仅导出服务</span></span><br><span class=line>            ....</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>/**</span></span><br><span class=line><span class=comment>                 * <span class=doctag>@since</span> 2.7.0</span></span><br><span class=line><span class=comment>                 * ServiceData Store</span></span><br><span class=line><span class=comment>                 */</span></span><br><span class=line>        <span class=type>MetadataReportService</span> <span class=variable>metadataReportService</span> <span class=operator>=</span> <span class=literal>null</span>;</span><br><span class=line>        <span class=keyword>if</span> ((metadataReportService = getMetadataReportService()) != <span class=literal>null</span>) {</span><br><span class=line>            metadataReportService.publishProvider(url);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=built_in>this</span>.urls.add(url);</span><br></pre></table></figure><p>上面代码根据url 中的scope 参数决定服务导出方式，分别如下：<ul><li>scope = none，不导出服务；<li>scope != remote，导出到本地；<li>scope != local，导出到远程；</ul><p><strong>不管是导出到本地，还是远程。服务导出之前一定要先创建Invoker。</strong>因此下面先来分析Invoker 的创建过程。Invoker 是由ProxyFactory 创建而来，Dubbo 默认的ProxyFactory 实现类是JavassistProxyFactory。下面我从JavassistProxyFactory 源码中分析Invoker 的创建过程。源码如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> &LTT> Invoker&LTT> <span class="title function_">getInvoker</span><span class=params>(T proxy, Class&LTT> type, URL url)</span> {</span><br><span class=line>    <span class=comment>// 为目标类创建warpper</span></span><br><span class=line>    <span class=keyword>final</span> <span class=type>Wrapper</span> <span class=variable>wrapper</span> <span class=operator>=</span> Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class=string>'$'</span>) < <span class=number>0</span> ? proxy.getClass() : type);</span><br><span class=line>    <span class=comment>// 创建匿名才invoker对象，并实现doinvoke方法</span></span><br><span class=line>    <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">AbstractProxyInvoker</span>&LTT>(proxy, type, url) {</span><br><span class=line>        <span class=meta>@Override</span></span><br><span class=line>        <span class=keyword>protected</span> Object <span class="title function_">doInvoke</span><span class=params>(T proxy, String methodName,</span></span><br><span class=line><span class=params>                                  Class&LT?>[] parameterTypes,</span></span><br><span class=line><span class=params>                                  Object[] arguments)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>            <span class=comment>// 调用 Wrapper 的 invokeMethod 方法，invokeMethod 最终会调用目标方法</span></span><br><span class=line>            <span class=keyword>return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class=line>        }</span><br><span class=line>    };</span><br><span class=line>}</span><br></pre></table></figure><p>Invoke创建成功之后，接下来我们来看本地导出：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">exportLocal</span><span class=params>(URL url)</span> {</span><br><span class=line>    <span class=type>URL</span> <span class=variable>local</span> <span class=operator>=</span> URLBuilder.from(url)</span><br><span class=line>        .setProtocol(LOCAL_PROTOCOL)  <span class=comment>// 设置协议头为 injvm</span></span><br><span class=line>        .setHost(LOCALHOST_VALUE)     <span class=comment>// 本地ip:127.0.0.1</span></span><br><span class=line>        .setPort(<span class=number>0</span>)</span><br><span class=line>        .build();</span><br><span class=line>    <span class=comment>// 创建 Invoker 并导出服务，protocol会在运行时调用InjvmProtocol的export方法</span></span><br><span class=line>    Exporter&LT?> exporter = protocol.export(</span><br><span class=line>        proxyFactory.getInvoker(ref, (Class) interfaceClass, local));</span><br><span class=line>    exporters.add(exporter);</span><br><span class=line>    logger.info(<span class=string>"Export dubbo service "</span> + interfaceClass.getName() + <span class=string>" to local registry url : "</span> + local);</span><br><span class=line>}</span><br></pre></table></figure><p>exportLocal 方法比较简单，首先根据URL 协议头决定是否导出服务。若需导出，则创建一个新的URL并将协议头、主机名以及端口设置成新的值。然后创建Invoker，并调用InjvmProtocol 的export 方法导出服务。下面我们来看一下InjvmProtocol 的export 方法都做了哪些事情。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> &LTT> Exporter&LTT> <span class="title function_">export</span><span class=params>(Invoker&LTT> invoker)</span> <span class=keyword>throws</span> RpcException {</span><br><span class=line>	<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">InjvmExporter</span>&LTT>(invoker, invoker.getUrl().getServiceKey(), exporterMap);</span><br><span class=line>}</span><br></pre></table></figure><p>如上，InjvmProtocol 的export 方法仅创建了一个InjvmExporter，无其他逻辑。到此导出服务到本地就分析完了。<p>接下来，我们继续分析导出服务到远程的过程。导出服务到远程包含了服务导出与服务注册两个过程。先来分析服务导出逻辑。我们把目光移动到RegistryProtocol 的export 方法上。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> &LTT> Exporter&LTT> <span class="title function_">export</span><span class=params>(<span class=keyword>final</span> Invoker&LTT> originInvoker)</span> <span class=keyword>throws</span> RpcException {</span><br><span class=line>    <span class=comment>// 获取注册中心 URL</span></span><br><span class=line>    <span class=type>URL</span> <span class=variable>registryUrl</span> <span class=operator>=</span> getRegistryUrl(originInvoker);</span><br><span class=line>    <span class=type>URL</span> <span class=variable>providerUrl</span> <span class=operator>=</span> getProviderUrl(originInvoker);</span><br><span class=line>    <span class=keyword>final</span> <span class=type>URL</span> <span class=variable>overrideSubscribeUrl</span> <span class=operator>=</span> getSubscribedOverrideUrl(providerUrl);</span><br><span class=line>    <span class=keyword>final</span> <span class=type>OverrideListener</span> <span class=variable>overrideSubscribeListener</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">OverrideListener</span>(overrideSubscribeUrl, originInvoker);</span><br><span class=line>    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class=line>    providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);</span><br><span class=line>    <span class=comment>//导出服务</span></span><br><span class=line>    <span class=keyword>final</span> ExporterChangeableWrapper&LTT> exporter = doLocalExport(originInvoker, providerUrl);</span><br><span class=line>    <span class=comment>// 根据 URL 加载 Registry 实现类，比如 ZookeeperRegistry</span></span><br><span class=line>    <span class=keyword>final</span> <span class=type>Registry</span> <span class=variable>registry</span> <span class=operator>=</span> getRegistry(originInvoker);</span><br><span class=line>    <span class=comment>//获取已注册的服务提供者 URL，</span></span><br><span class=line>    <span class=keyword>final</span> <span class=type>URL</span> <span class=variable>registeredProviderUrl</span> <span class=operator>=</span> getRegisteredProviderUrl(providerUrl, registryUrl);</span><br><span class=line>    ProviderInvokerWrapper&LTT> providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,</span><br><span class=line>                                                                                                 registryUrl, registeredProviderUrl);</span><br><span class=line>    <span class=comment>//to judge if we need to delay publish</span></span><br><span class=line>    <span class=type>boolean</span> <span class=variable>register</span> <span class=operator>=</span> registeredProviderUrl.getParameter(<span class=string>"register"</span>, <span class=literal>true</span>);</span><br><span class=line>    <span class=keyword>if</span> (register) {</span><br><span class=line>        <span class=comment>// 向注册中心注册服务</span></span><br><span class=line>        register(registryUrl, registeredProviderUrl);</span><br><span class=line>        providerInvokerWrapper.setReg(<span class=literal>true</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>//  向注册中心进行订阅 override 数据</span></span><br><span class=line>    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class=line>    exporter.setRegisterUrl(registeredProviderUrl);</span><br><span class=line>    exporter.setSubscribeUrl(overrideSubscribeUrl);</span><br><span class=line>    <span class=comment>// 创建并返回 DestroyableExporter</span></span><br><span class=line>    <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">DestroyableExporter</span><>(exporter);</span><br><span class=line>}</span><br></pre></table></figure><p>上面代码看起来比较复杂，主要做如下一些操作：<ol><li>调用doLocalExport 导出服务<li>向注册中心注册服务<li>向注册中心进行订阅override 数据<li>创建并返回DestroyableExporter</ol><p>看看doLocalExport 做了什么<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> &LTT> ExporterChangeableWrapper&LTT> <span class="title function_">doLocalExport</span><span class=params>(<span class=keyword>final</span> Invoker&LTT> originInvoker, URL providerUrl)</span> {</span><br><span class=line>    <span class=type>String</span> <span class=variable>key</span> <span class=operator>=</span> getCacheKey(originInvoker);</span><br><span class=line>    <span class=keyword>return</span> (ExporterChangeableWrapper&LTT>) bounds.computeIfAbsent(key, s -> {</span><br><span class=line>        Invoker&LT?> invokerDelegate = <span class=keyword>new</span> <span class="title class_">InvokerDelegate</span><>(originInvoker, providerUrl);</span><br><span class=line>        <span class=comment>//protocol和配置的协议相关（dubbo：DubboProtocol）</span></span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">ExporterChangeableWrapper</span><>((Exporter&LTT>) protocol.export(invokerDelegate), originInvoker);</span><br><span class=line>    });</span><br><span class=line>}</span><br></pre></table></figure><p>接下来，我们把重点放在Protocol 的export 方法上。假设运行时协议为dubbo，此处的protocol 变量会在运行时加载DubboProtocol，并调用DubboProtocol 的export 方法。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> &LTT> Exporter&LTT> <span class="title function_">export</span><span class=params>(Invoker&LTT> invoker)</span> <span class=keyword>throws</span> RpcException {</span><br><span class=line>    <span class=type>URL</span> <span class=variable>url</span> <span class=operator>=</span> invoker.getUrl();</span><br><span class=line>    <span class=comment>// export service.获取服务标识，理解成服务坐标也行。由服务组名，服务名，服务版本号以及端口组成。比如：demoGroup/com.alibaba.dubbo.demo.DemoService:1.0.1:20880</span></span><br><span class=line>    <span class=type>String</span> <span class=variable>key</span> <span class=operator>=</span> serviceKey(url);</span><br><span class=line>    <span class=comment>//创建DubboExporter</span></span><br><span class=line>    DubboExporter&LTT> exporter = <span class=keyword>new</span> <span class="title class_">DubboExporter</span>&LTT>(invoker, key, exporterMap);</span><br><span class=line>    exporterMap.put(key, exporter); <span class=comment>//key：接口 （DemoService）</span></span><br><span class=line></span><br><span class=line>    <span class=comment>//export an stub service for dispatching event</span></span><br><span class=line>    <span class=type>Boolean</span> <span class=variable>isStubSupportEvent</span> <span class=operator>=</span> url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT);</span><br><span class=line>    <span class=type>Boolean</span> <span class=variable>isCallbackservice</span> <span class=operator>=</span> url.getParameter(IS_CALLBACK_SERVICE, <span class=literal>false</span>);</span><br><span class=line>    <span class=keyword>if</span> (isStubSupportEvent && !isCallbackservice) {</span><br><span class=line>        <span class=type>String</span> <span class=variable>stubServiceMethods</span> <span class=operator>=</span> url.getParameter(STUB_EVENT_METHODS_KEY);</span><br><span class=line>        <span class=keyword>if</span> (stubServiceMethods == <span class=literal>null</span> || stubServiceMethods.length() == <span class=number>0</span>) {</span><br><span class=line>            <span class=keyword>if</span> (logger.isWarnEnabled()) {</span><br><span class=line>                logger.warn(<span class=keyword>new</span> <span class="title class_">IllegalStateException</span>(<span class=string>"consumer ["</span> + url.getParameter(INTERFACE_KEY) +</span><br><span class=line>                                                      <span class=string>"], has set stubproxy support event ,but no stub methods founded."</span>));</span><br><span class=line>            }</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>//启动服务</span></span><br><span class=line>    openServer(url);</span><br><span class=line>    <span class=comment>//优化序列器</span></span><br><span class=line>    optimizeSerialization(url);</span><br><span class=line>    <span class=keyword>return</span> exporter;</span><br><span class=line>}</span><br></pre></table></figure><p>如上，我们重点关注DubboExporter 的创建以及openServer 方法，其他逻辑看不懂也没关系，不影响理解服务导出过程。下面分析openServer 方法。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">openServer</span><span class=params>(URL url)</span> {</span><br><span class=line>    <span class=comment>// find server.</span></span><br><span class=line>    <span class=type>String</span> <span class=variable>key</span> <span class=operator>=</span> url.getAddress();</span><br><span class=line>    <span class=comment>//client can export a service which's only for server to invoke</span></span><br><span class=line>    <span class=type>boolean</span> <span class=variable>isServer</span> <span class=operator>=</span> url.getParameter(IS_SERVER_KEY, <span class=literal>true</span>);</span><br><span class=line>    <span class=keyword>if</span> (isServer) {</span><br><span class=line>        <span class=comment>//访问缓存</span></span><br><span class=line>        <span class=type>ExchangeServer</span> <span class=variable>server</span> <span class=operator>=</span> serverMap.get(key);</span><br><span class=line>        <span class=keyword>if</span> (server == <span class=literal>null</span>) {</span><br><span class=line>            <span class=keyword>synchronized</span> (<span class=built_in>this</span>) {</span><br><span class=line>                server = serverMap.get(key);</span><br><span class=line>                <span class=keyword>if</span> (server == <span class=literal>null</span>) {</span><br><span class=line>                    <span class=comment>//创建服务器实例</span></span><br><span class=line>                    serverMap.put(key, createServer(url));</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=comment>// server supports reset, use together with override</span></span><br><span class=line>            server.reset(url);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>接下来分析服务器实例的创建过程。如下<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> ExchangeServer <span class="title function_">createServer</span><span class=params>(URL url)</span> {</span><br><span class=line>    url = URLBuilder.from(url)</span><br><span class=line>        <span class=comment>// send readonly event when server closes, it's enabled by default</span></span><br><span class=line>        .addParameterIfAbsent(CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString())</span><br><span class=line>        <span class=comment>// enable heartbeat by default</span></span><br><span class=line>        .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT))</span><br><span class=line>        .addParameter(CODEC_KEY, DubboCodec.NAME)</span><br><span class=line>        .build();</span><br><span class=line>    <span class=type>String</span> <span class=variable>str</span> <span class=operator>=</span> url.getParameter(SERVER_KEY, DEFAULT_REMOTING_SERVER);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 通过 SPI 检测是否存在 server 参数所代表的 Transporter 拓展，不存在则抛出异常</span></span><br><span class=line>    <span class=keyword>if</span> (str != <span class=literal>null</span> && str.length() > <span class=number>0</span> && !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">RpcException</span>(<span class=string>"Unsupported server type: "</span> + str + <span class=string>", url: "</span> + url);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    ExchangeServer server;</span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        <span class=comment>// 创建 ExchangeServer</span></span><br><span class=line>        server = Exchangers.bind(url, requestHandler);</span><br><span class=line>    } <span class=keyword>catch</span> (RemotingException e) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">RpcException</span>(<span class=string>"Fail to start server(url: "</span> + url + <span class=string>") "</span> + e.getMessage(), e);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 获取 client 参数，可指定 netty，mina</span></span><br><span class=line>    str = url.getParameter(CLIENT_KEY);</span><br><span class=line>    <span class=keyword>if</span> (str != <span class=literal>null</span> && str.length() > <span class=number>0</span>) {</span><br><span class=line>        <span class=comment>// 获取所有的 Transporter 实现类名称集合，比如 supportedTypes = [netty, mina]</span></span><br><span class=line>        Set&LTString> supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();</span><br><span class=line>        <span class=comment>// 检测当前 Dubbo 所支持的 Transporter 实现类名称列表中，</span></span><br><span class=line>        <span class=comment>// 是否包含 client 所表示的 Transporter，若不包含，则抛出异常</span></span><br><span class=line>        <span class=keyword>if</span> (!supportedTypes.contains(str)) {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">RpcException</span>(<span class=string>"Unsupported client type: "</span> + str);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> server;</span><br><span class=line>}</span><br></pre></table></figure><p>createServer 包含三个核心逻辑：<ol><li>检测是否存在server 参数所代表的Transporter 拓展，不存在则抛出异常。<li>创建服务器实例。<li>检测是否支持client 参数所表示的Transporter 拓展，不存在也是抛出异常。两次检测操作所对应的代码较直白了，无需多说。但创建服务器的操作目前还不是很清晰，我们继续往下看。</ol><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> ExchangeServer <span class="title function_">bind</span><span class=params>(URL url, ExchangeHandler handler)</span> <span class=keyword>throws</span> RemotingException {</span><br><span class=line>    <span class=keyword>if</span> (url == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalArgumentException</span>(<span class=string>"url == null"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>if</span> (handler == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalArgumentException</span>(<span class=string>"handler == null"</span>);</span><br><span class=line>    }</span><br><span class=line>    url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class=string>"exchange"</span>);</span><br><span class=line>    <span class=comment>// 获取 Exchanger，默认为 HeaderExchanger。</span></span><br><span class=line>    <span class=comment>// 紧接着调用 HeaderExchanger 的 bind 方法创建 ExchangeServer 实例</span></span><br><span class=line>    <span class=keyword>return</span> getExchanger(url).bind(url, handler);</span><br><span class=line>}</span><br></pre></table></figure><p>上面代码比较简单，就不多说了。下面看一下HeaderExchanger 的bind 方法。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> ExchangeServer <span class="title function_">bind</span><span class=params>(URL url, ExchangeHandler handler)</span> <span class=keyword>throws</span> RemotingException {</span><br><span class=line>    <span class=comment>// 创建 HeaderExchangeServer 实例，该方法包含了多个逻辑，分别如下：</span></span><br><span class=line>    <span class=comment>//   1. new HeaderExchangeHandler(handler)</span></span><br><span class=line>    <span class=comment>//   2. new DecodeHandler(new HeaderExchangeHandler(handler))</span></span><br><span class=line>    <span class=comment>//   3. Transporters.bind(url, new DecodeHandler(new</span></span><br><span class=line>    HeaderExchangeHandler(handler)))</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">HeaderExchangeServer</span>(Transporters.bind(url, <span class=keyword>new</span> <span class="title class_">ChannelHandler</span>[]{<span class=keyword>new</span> <span class="title class_">DecodeHandler</span>(<span class=keyword>new</span> <span class="title class_">HeaderExchangeHandler</span>(handler))}));</span><br><span class=line>}</span><br></pre></table></figure><p>HeaderExchanger 的bind 方法包含的逻辑比较多，但目前我们仅需关心Transporters 的bind 方法逻<br>辑即可。该方法的代码如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> Server <span class="title function_">bind</span><span class=params>(URL url, ChannelHandler... handlers)</span> <span class=keyword>throws</span> RemotingException {</span><br><span class=line>    <span class=keyword>if</span> (url == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalArgumentException</span>(<span class=string>"url == null"</span>);</span><br><span class=line>    } <span class=keyword>else</span> <span class=keyword>if</span> (handlers != <span class=literal>null</span> && handlers.length != <span class=number>0</span>) {</span><br><span class=line>        Object handler;</span><br><span class=line>        <span class=keyword>if</span> (handlers.length == <span class=number>1</span>) {</span><br><span class=line>            handler = handlers[<span class=number>0</span>];</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=comment>// 如果 handlers 元素数量大于1，则创建 ChannelHandler 分发器</span></span><br><span class=line>            handler = <span class=keyword>new</span> <span class="title class_">ChannelHandlerDispatcher</span>(handlers);</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 获取自适应 Transporter 实例，并调用实例方法</span></span><br><span class=line>        <span class=keyword>return</span> getTransporter().bind(url, (ChannelHandler)handler);</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalArgumentException</span>(<span class=string>"handlers == null"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>如上，getTransporter() 方法获取的Transporter 是在运行时动态创建的，类名为TransporterAdaptive，也就是自适应拓展类。TransporterAdaptive 会在运行时根据传入的URL 参数决定加载什么类型的Transporter，默认为NettyTransporter。调用 NettyTransporter.bind(URL,ChannelHandler) 方法。创建一个 NettyServer 实例。调用 NettyServer.doOPen() 方法，服务器被开启，服务也被暴露出来了。<h3 id=7-1-4、服务注册><a class=headerlink href=#7-1-4、服务注册 title=7.1.4、服务注册></a>7.1.4、服务注册</h3><p>以Zookeeper 注册中心为例，从服务注册的入口方法开始分析。<p>我们把目光再次移到RegistryProtocol 的export 方法上。如下：<p>进入到register()方法<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">register</span><span class=params>(URL registryUrl, URL registeredProviderUrl)</span> {</span><br><span class=line>    <span class=comment>//获得注册中心实例</span></span><br><span class=line>    <span class=type>Registry</span> <span class=variable>registry</span> <span class=operator>=</span> registryFactory.getRegistry(registryUrl);</span><br><span class=line>    <span class=comment>//进行注册</span></span><br><span class=line>    registry.register(registeredProviderUrl);</span><br><span class=line>}</span><br></pre></table></figure><p>看看getRegistry()方法<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> Registry <span class="title function_">getRegistry</span><span class=params>(URL url)</span> {</span><br><span class=line>    url = URLBuilder.from(url)</span><br><span class=line>        .setPath(RegistryService.class.getName())</span><br><span class=line>        .addParameter(INTERFACE_KEY, RegistryService.class.getName())</span><br><span class=line>        .removeParameters(EXPORT_KEY, REFER_KEY)</span><br><span class=line>        .build();</span><br><span class=line>    <span class=type>String</span> <span class=variable>key</span> <span class=operator>=</span> url.toServiceStringWithoutResolving();</span><br><span class=line>    <span class=comment>// Lock the registry access process to ensure a single instance of the registry</span></span><br><span class=line>    LOCK.lock();</span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        <span class=type>Registry</span> <span class=variable>registry</span> <span class=operator>=</span> REGISTRIES.get(key);</span><br><span class=line>        <span class=keyword>if</span> (registry != <span class=literal>null</span>) {</span><br><span class=line>            <span class=keyword>return</span> registry;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>//create registry by spi/ioc</span></span><br><span class=line>        registry = createRegistry(url);</span><br><span class=line>        <span class=keyword>if</span> (registry == <span class=literal>null</span>) {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalStateException</span>(<span class=string>"Can not create registry "</span> + url);</span><br><span class=line>        }</span><br><span class=line>        REGISTRIES.put(key, registry);</span><br><span class=line>        <span class=keyword>return</span> registry;</span><br><span class=line>    } <span class=keyword>finally</span> {</span><br><span class=line>        <span class=comment>// Release the lock</span></span><br><span class=line>        LOCK.unlock();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>进入createRegistry()方法<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> Registry <span class="title function_">createRegistry</span><span class=params>(URL url)</span> {</span><br><span class=line>    <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">ZookeeperRegistry</span>(url, zookeeperTransporter);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class="title function_">ZookeeperRegistry</span><span class=params>(URL url, ZookeeperTransporter zookeeperTransporter)</span> {</span><br><span class=line>    <span class=built_in>super</span>(url);</span><br><span class=line>    <span class=keyword>if</span> (url.isAnyHost()) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalStateException</span>(<span class=string>"registry address == null"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>//// 获取组名，默认为 dubbo</span></span><br><span class=line>    <span class=type>String</span> <span class=variable>group</span> <span class=operator>=</span> url.getParameter(GROUP_KEY, DEFAULT_ROOT);</span><br><span class=line>    <span class=keyword>if</span> (!group.startsWith(PATH_SEPARATOR)) {</span><br><span class=line>        group = PATH_SEPARATOR + group;</span><br><span class=line>    }</span><br><span class=line>    <span class=built_in>this</span>.root = group;</span><br><span class=line>    <span class=comment>// 创建 Zookeeper 客户端，默认为 CuratorZookeeperTransporter</span></span><br><span class=line>    zkClient = zookeeperTransporter.connect(url);</span><br><span class=line>    <span class=comment>// 添加状态监听器</span></span><br><span class=line>    zkClient.addStateListener(state -> {</span><br><span class=line>        <span class=keyword>if</span> (state == StateListener.RECONNECTED) {</span><br><span class=line>            <span class=keyword>try</span> {</span><br><span class=line>                recover();</span><br><span class=line>            } <span class=keyword>catch</span> (Exception e) {</span><br><span class=line>                logger.error(e.getMessage(), e);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    });</span><br><span class=line>}</span><br></pre></table></figure><p>上面代码要重点关注ZookeeperTransporter 的 connect方法的调用，该方法用于创建 Zookeeper 客户端。创建好Zookeeper 客户端意味着注册中心的创建过程就结束了。<p>搞懂了服务注册的本质，接下来就可以去阅读服务注册的代码了。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doRegister</span><span class=params>(URL url)</span> {</span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        <span class=comment>// 通过 Zookeeper 客户端创建节点，节点路径由 toUrlPath 方法生成，路径格式如下:</span></span><br><span class=line>        <span class=comment>//  /${group}/${serviceInterface}/providers/${url}</span></span><br><span class=line>        <span class=comment>// 比如 /dubbo/org.apache.dubbo.DemoService/providers/dubbo%3A%2F%2F127.0.0.1......</span></span><br><span class=line>        zkClient.create(toUrlPath(url), url.getParameter(DYNAMIC_KEY, <span class=literal>true</span>));</span><br><span class=line>    } <span class=keyword>catch</span> (Throwable e) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">RpcException</span>(<span class=string>"Failed to register "</span> + url + <span class=string>" to zookeeper "</span> + getUrl() + <span class=string>", cause: "</span> + e.getMessage(), e);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">create</span><span class=params>(String path, <span class=type>boolean</span> ephemeral)</span> {</span><br><span class=line>    <span class=keyword>if</span> (!ephemeral) {</span><br><span class=line>        <span class=comment>// 如果要创建的节点类型非临时节点，那么这里要检测节点是否存在</span></span><br><span class=line>        <span class=keyword>if</span> (checkExists(path)) {</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> path.lastIndexOf(<span class=string>'/'</span>);</span><br><span class=line>    <span class=keyword>if</span> (i > <span class=number>0</span>) {</span><br><span class=line>        <span class=comment>// 递归创建上一级路径</span></span><br><span class=line>        create(path.substring(<span class=number>0</span>, i), <span class=literal>false</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 根据 ephemeral 的值创建临时或持久节点</span></span><br><span class=line>    <span class=keyword>if</span> (ephemeral) {</span><br><span class=line>        createEphemeral(path);</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>        createPersistent(path);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>整个过程可总结为：<strong>先创建注册中心实例，再将服务提供者注册至注册中心。</strong><h1 id=X、总结><a class=headerlink href=#X、总结 title=X、总结></a>X、总结</h1><ol><li>注册 服务提供者 时，ServiceConfig 解析出的URL 格式为：<code>registry:// registry-host/org.apache.dubbo.registry.RegistryService?export=URL.encode("dubbo://service-host/{服务名}/{版本号}")</code>。<li>基于Dubbo SPI 自适应机制，通过<code>URL registry:// 协议头</code>识别，就调用<code>RegistryProtocol#export()</code> 方法。<li>将具体服务类名，比如<code>DubboServiceRegistryImpl</code>，通过ProxyFactory 包装成Invoker 实例。<li>调用doLocalExport 方法，使用 <code>DubboProtocol</code> 将Invoker 转化为Exporter 实例，并打开Netty 服务端监听客户请求。<li>创建Registry 实例，连接Zookeeper，并在服务节点下写入提供者的URL 地址，注册服务。<li>向注册中心订阅override 数据，并返回一个Exporter 实例。<li>根据URL 格式中的 <code>"dubbo://service-host/{服务名}/{版本号}"</code> 中协议头 dubbo:// 识别，调用<code>DubboProtocol#export()</code>方法，开放服务端口。<li><code>RegistryProtocol#export()</code> 返回的Exporter 实例存放到ServiceConfig 的 <code>List&LTExporter>exporters</code> 中。</ol></div><footer class=post-footer><div class=post-tags><a href=/tags/Dubbo/ rel=tag># Dubbo</a><a href=/tags/Dubbo%E5%8E%9F%E7%90%86/ rel=tag># Dubbo原理</a></div><div class=post-nav><div class=post-nav-item><a href=/2024/08/21/Apache%20Dubbo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E5%BA%94%E5%AF%B9/ rel=prev title=Dubbo系列-Dubbo常见问题> <i class="fa fa-angle-left"></i> Dubbo系列-Dubbo常见问题 </a></div><div class=post-nav-item><a href=/2024/08/21/Apache%20Dubbo%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/ rel=next title=Dubbo系列-Dubbo基础应用> Dubbo系列-Dubbo基础应用 <i class="fa fa-angle-right"></i> </a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script>