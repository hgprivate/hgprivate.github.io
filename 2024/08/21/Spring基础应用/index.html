<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hshz21.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="1、认识Spring1.1、前言Spring框架为任何类型的部署平台上的基于Java的现代企业应用程序提供了全面的编程和配置模型。 Spring的一个关键元素是在应用程序级别的基础架构支持：Spring专注于企业应用程序的“管道”，以便团队可以专注于应用程序级别的业务逻辑，而不必与特定的部署环境建立不必要的联系。 1.2、啥是Spring术语“春天”在不同的上下文中表示不同的事物。它可以用来指代S" name=description><meta content=article property=og:type><meta content=Spring系列-基础应用 property=og:title><meta content=https://hshz21.gitee.io/2024/08/21/Spring%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content="1、认识Spring1.1、前言Spring框架为任何类型的部署平台上的基于Java的现代企业应用程序提供了全面的编程和配置模型。 Spring的一个关键元素是在应用程序级别的基础架构支持：Spring专注于企业应用程序的“管道”，以便团队可以专注于应用程序级别的业务逻辑，而不必与特定的部署环境建立不必要的联系。 1.2、啥是Spring术语“春天”在不同的上下文中表示不同的事物。它可以用来指代S" property=og:description><meta content=zh_CN property=og:locale><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210107190234847.png property=og:image><meta content=c:\Users\shihao\Desktop\%E5%9B%BE%E7%89%87\%E5%B7%A5%E4%BD%9C\Spring\%E5%8D%95%E4%BE%8BBean%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F01 property=og:image><meta content=https://docs.spring.io/spring-framework/docs/current/reference/html/images/aop-proxy-plain-pojo-call.png property=og:image><meta content=https://docs.spring.io/spring-framework/docs/current/reference/html/images/aop-proxy-call.png property=og:image><meta content=2024-08-21T13:39:14.758Z property=article:published_time><meta content=2023-08-06T07:33:47.889Z property=article:modified_time><meta content=豪哥 property=article:author><meta content=Spring property=article:tag><meta content=summary name=twitter:card><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210107190234847.png name=twitter:image><link href=https://hshz21.gitee.io/2024/08/21/Spring%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hshz21.gitee.io/2024/08/21/Spring%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/","path":"2024/08/21/Spring基础应用/","title":"Spring系列-基础应用"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>Spring系列-基础应用 | 豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>豪哥博客</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#1%E3%80%81%E8%AE%A4%E8%AF%86Spring><span class=nav-number>1.</span> <span class=nav-text>1、认识Spring</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81%E5%89%8D%E8%A8%80><span class=nav-number>1.1.</span> <span class=nav-text>1.1、前言</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-2%E3%80%81%E5%95%A5%E6%98%AFSpring><span class=nav-number>1.2.</span> <span class=nav-text>1.2、啥是Spring</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-3%E3%80%81Spring%E6%A8%A1%E5%9D%97><span class=nav-number>1.3.</span> <span class=nav-text>1.3、Spring模块</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-4%E3%80%81%E6%94%AF%E6%8C%81%E7%89%88%E6%9C%AC><span class=nav-number>1.4.</span> <span class=nav-text>1.4、支持版本</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-5%E3%80%81JDK%E7%89%88%E6%9C%AC%E8%8C%83%E5%9B%B4><span class=nav-number>1.5.</span> <span class=nav-text>1.5、JDK版本范围</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-6%E3%80%81Spring%E5%8E%86%E5%8F%B2><span class=nav-number>1.6.</span> <span class=nav-text>1.6、Spring历史</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#2%E3%80%81%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF><span class=nav-number>2.</span> <span class=nav-text>2、核心技术</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#2-1%E3%80%81IOC%E5%AE%B9%E5%99%A8><span class=nav-number>2.1.</span> <span class=nav-text>2.1、IOC容器</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-1%E3%80%81IOC%E5%AE%B9%E5%99%A8%E5%92%8CBean%E7%AE%80%E4%BB%8B><span class=nav-number>2.1.1.</span> <span class=nav-text>2.1.1、IOC容器和Bean简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-2%E3%80%81IOC%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0><span class=nav-number>2.1.2.</span> <span class=nav-text>2.1.2、IOC容器概述</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-2-1%E3%80%81%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE><span class=nav-number>2.1.2.1.</span> <span class=nav-text>2.1.2.1、配置元数据</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-2-2%E3%80%81%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AE%B9%E5%99%A8><span class=nav-number>2.1.2.2.</span> <span class=nav-text>2.1.2.2、实例化容器</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%9E%84%E6%88%90%E5%9F%BA%E4%BA%8EXML%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE><span class=nav-number>2.1.2.2.1.</span> <span class=nav-text>构成基于XML配置元数据</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Groovy-Bean-%E5%AE%9A%E4%B9%89-DSL><span class=nav-number>2.1.2.2.2.</span> <span class=nav-text>Groovy Bean 定义 DSL</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-2-3%E3%80%81%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8><span class=nav-number>2.1.2.3.</span> <span class=nav-text>2.1.2.3、使用容器</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-3%E3%80%81Bean%E6%80%BB%E8%A7%88><span class=nav-number>2.1.3.</span> <span class=nav-text>2.1.3、Bean总览</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-3-1%E3%80%81%E5%91%BD%E5%90%8DBean><span class=nav-number>2.1.3.1.</span> <span class=nav-text>2.1.3.1、命名Bean</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%AE%80%E4%BB%8B><span class=nav-number>2.1.3.1.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%9F%BA%E4%BA%8EXML%E8%B5%B7%E5%88%AB%E5%90%8D><span class=nav-number>2.1.3.1.2.</span> <span class=nav-text>基于XML起别名</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E8%B5%B7%E5%88%AB%E5%90%8D><span class=nav-number>2.1.3.1.3.</span> <span class=nav-text>基于注解起别名</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-3-2%E3%80%81%E5%AE%9E%E4%BE%8B%E5%8C%96-Bean><span class=nav-number>2.1.3.2.</span> <span class=nav-text>2.1.3.2、实例化 Bean</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%AE%80%E4%BB%8B-1><span class=nav-number>2.1.3.2.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%9F%BA%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%AE%9E%E4%BE%8B%E5%8C%96><span class=nav-number>2.1.3.2.2.</span> <span class=nav-text>基于构造函数实例化</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%9F%BA%E4%BA%8E%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96><span class=nav-number>2.1.3.2.3.</span> <span class=nav-text>基于静态工厂方法实例化</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%9F%BA%E4%BA%8E%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%AE%9E%E4%BE%8B%E5%8C%96><span class=nav-number>2.1.3.2.4.</span> <span class=nav-text>基于实例工厂方法实例化</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%A1%AE%E5%AE%9ABean%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B><span class=nav-number>2.1.3.2.5.</span> <span class=nav-text>确定Bean的运行时类型</span></a></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-4%E3%80%81Dependencies><span class=nav-number>2.1.4.</span> <span class=nav-text>2.1.4、Dependencies</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-4-1%E3%80%81%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5><span class=nav-number>2.1.4.1.</span> <span class=nav-text>2.1.4.1、依赖注入</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%9F%BA%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5><span class=nav-number>2.1.4.1.1.</span> <span class=nav-text>基于构造函数的依赖注入</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90><span class=nav-number>2.1.4.1.1.1.</span> <span class=nav-text>构造函数参数解析</span></a></ol><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%9F%BA%E4%BA%8ESetter%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5><span class=nav-number>2.1.4.1.2.</span> <span class=nav-text>基于Setter的依赖注入</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BE%9D%E8%B5%96%E6%80%A7%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B><span class=nav-number>2.1.4.1.3.</span> <span class=nav-text>依赖性解析过程</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%A4%BA%E4%BE%8B><span class=nav-number>2.1.4.1.4.</span> <span class=nav-text>依赖注入示例</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#%E5%9F%BA%E4%BA%8EXML%E7%9A%84Setter%E6%B3%A8%E5%85%A5><span class=nav-number>2.1.4.1.4.1.</span> <span class=nav-text>基于XML的Setter注入</span></a><li class="nav-item nav-level-6"><a class=nav-link href=#%E5%9F%BA%E4%BA%8EXML%E7%9A%84%E6%9E%84%E9%80%A0%E6%B3%A8%E5%85%A5><span class=nav-number>2.1.4.1.4.2.</span> <span class=nav-text>基于XML的构造注入</span></a></ol></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-4-2%E3%80%81%E4%BE%9D%E8%B5%96%E6%80%A7%E5%92%8C%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE><span class=nav-number>2.1.4.2.</span> <span class=nav-text>2.1.4.2、依赖性和详细配置</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#straight-values%EF%BC%88%E5%8E%9F%E8%AF%AD%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AD%89%EF%BC%89><span class=nav-number>2.1.4.2.1.</span> <span class=nav-text>straight values（原语、字符串等）</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%AF%B9%E5%85%B6%E4%BB%96Bean%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%88%E5%8D%8F%E4%BD%9C%E8%80%85%EF%BC%89><span class=nav-number>2.1.4.2.2.</span> <span class=nav-text>对其他Bean的引用（协作者）</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%86%85%E9%83%A8Bean><span class=nav-number>2.1.4.2.3.</span> <span class=nav-text>内部Bean</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%9B%86%E5%90%88><span class=nav-number>2.1.4.2.4.</span> <span class=nav-text>集合</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#%E9%9B%86%E5%90%88%E5%90%88%E5%B9%B6><span class=nav-number>2.1.4.2.4.1.</span> <span class=nav-text>集合合并</span></a><li class="nav-item nav-level-6"><a class=nav-link href=#%E9%9B%86%E5%90%88%E5%90%88%E5%B9%B6%E7%9A%84%E5%B1%80%E9%99%90><span class=nav-number>2.1.4.2.4.2.</span> <span class=nav-text>集合合并的局限</span></a><li class="nav-item nav-level-6"><a class=nav-link href=#%E5%BC%BA%E7%B1%BB%E5%9E%8B%E9%9B%86%E5%90%88><span class=nav-number>2.1.4.2.4.3.</span> <span class=nav-text>强类型集合</span></a></ol><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%80%BC%E5%92%8C%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2><span class=nav-number>2.1.4.2.5.</span> <span class=nav-text>空字符串值和空字符串</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%85%B7%E6%9C%89P-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84XML%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F><span class=nav-number>2.1.4.2.6.</span> <span class=nav-text>具有P-命名空间的XML快捷方式</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%85%B7%E6%9C%89C-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84XML%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F><span class=nav-number>2.1.4.2.7.</span> <span class=nav-text>具有C-命名空间的XML快捷方式</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%A4%8D%E5%90%88%E5%B1%9E%E6%80%A7%E5%90%8D%E7%A7%B0><span class=nav-number>2.1.4.2.8.</span> <span class=nav-text>复合属性名称</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-4-3%E3%80%81%E4%BD%BF%E7%94%A8-depends-on><span class=nav-number>2.1.4.3.</span> <span class=nav-text>2.1.4.3、使用 depends-on</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-4-4%E3%80%81%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96Bean><span class=nav-number>2.1.4.4.</span> <span class=nav-text>2.1.4.4、延迟初始化Bean</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-4-5%E3%80%81%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8D%8F%E4%BD%9C%E5%99%A8><span class=nav-number>2.1.4.5.</span> <span class=nav-text>2.1.4.5、自动装配协作器</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7%E5%92%8C%E7%BC%BA%E7%82%B9><span class=nav-number>2.1.4.5.1.</span> <span class=nav-text>自动装配的局限性和缺点</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BB%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E4%B8%AD%E6%8E%92%E9%99%A4Bean><span class=nav-number>2.1.4.5.2.</span> <span class=nav-text>从自动装配中排除Bean</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-4-6%E3%80%81%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5><span class=nav-number>2.1.4.6.</span> <span class=nav-text>2.1.4.6、方法注入</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5><span class=nav-number>2.1.4.6.1.</span> <span class=nav-text>查找方法注入</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BB%BB%E6%84%8F%E6%96%B9%E6%B3%95%E6%9B%BF%E6%8D%A2><span class=nav-number>2.1.4.6.2.</span> <span class=nav-text>任意方法替换</span></a></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-5%E3%80%81Bean%E4%BD%9C%E7%94%A8%E5%9F%9F><span class=nav-number>2.1.5.</span> <span class=nav-text>2.1.5、Bean作用域</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-5-1%E3%80%81singleton-scope><span class=nav-number>2.1.5.1.</span> <span class=nav-text>2.1.5.1、singleton scope</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-5-2%E3%80%81prototype-scope><span class=nav-number>2.1.5.2.</span> <span class=nav-text>2.1.5.2、prototype scope</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-5-3%E3%80%81%E5%85%B7%E6%9C%89%E5%8E%9F%E5%9E%8Bbean%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E7%9A%84singleton-bena><span class=nav-number>2.1.5.3.</span> <span class=nav-text>2.1.5.3、具有原型bean依赖关系的singleton bena</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-5-4%E3%80%81request%E3%80%81session%E3%80%81application%E3%80%81websocket-scope><span class=nav-number>2.1.5.4.</span> <span class=nav-text>2.1.5.4、request、session、application、websocket scope</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%88%9D%E5%A7%8BWeb%E9%85%8D%E7%BD%AE><span class=nav-number>2.1.5.4.1.</span> <span class=nav-text>初始Web配置</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#request-scope><span class=nav-number>2.1.5.4.2.</span> <span class=nav-text>request scope</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#session-scope><span class=nav-number>2.1.5.4.3.</span> <span class=nav-text>session scope</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#application-scope><span class=nav-number>2.1.5.4.4.</span> <span class=nav-text>application scope</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%9C%E7%94%A8%E5%9F%9Fbean%E4%BD%9C%E4%B8%BA%E4%BE%9D%E8%B5%96%E9%A1%B9><span class=nav-number>2.1.5.4.5.</span> <span class=nav-text>作用域bean作为依赖项</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#%E9%80%89%E6%8B%A9%E8%A6%81%E5%88%9B%E5%BB%BA%E7%9A%84%E4%BB%A3%E7%90%86%E7%B1%BB%E5%9E%8B><span class=nav-number>2.1.5.4.5.1.</span> <span class=nav-text>选择要创建的代理类型</span></a></ol></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-5-5%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8C%83%E5%9B%B4><span class=nav-number>2.1.5.5.</span> <span class=nav-text>2.1.5.5、自定义范围</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8C%83%E5%9B%B4><span class=nav-number>2.1.5.5.1.</span> <span class=nav-text>创建自定义范围</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8C%83%E5%9B%B4><span class=nav-number>2.1.5.5.2.</span> <span class=nav-text>使用自定义范围</span></a></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-6%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89Bean%E6%80%A7%E8%B4%A8><span class=nav-number>2.1.6.</span> <span class=nav-text>2.1.6、自定义Bean性质</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-6-1%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83><span class=nav-number>2.1.6.1.</span> <span class=nav-text>2.1.6.1、生命周期回调</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9B%9E%E8%B0%83><span class=nav-number>2.1.6.1.1.</span> <span class=nav-text>初始化回调</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%94%80%E6%AF%81%E5%9B%9E%E8%B0%83><span class=nav-number>2.1.6.1.2.</span> <span class=nav-text>销毁回调</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95><span class=nav-number>2.1.6.1.3.</span> <span class=nav-text>默认初始化和销毁方法</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%BB%84%E5%90%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%BA%E5%88%B6><span class=nav-number>2.1.6.1.4.</span> <span class=nav-text>组合生命周期机制</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%90%AF%E5%8A%A8%E5%92%8C%E5%85%B3%E9%97%AD%E5%9B%9E%E8%B0%83><span class=nav-number>2.1.6.1.5.</span> <span class=nav-text>启动和关闭回调</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%9D%9EWeb%E5%BA%94%E7%94%A8%E4%B8%AD%E6%AD%A3%E5%B8%B8%E5%85%B3%E9%97%ADSpring-IOC%E5%AE%B9%E5%99%A8><span class=nav-number>2.1.6.1.6.</span> <span class=nav-text>非Web应用中正常关闭Spring IOC容器</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-6-2%E3%80%81ApplicationContextAware%E5%92%8CBeanNameAware><span class=nav-number>2.1.6.2.</span> <span class=nav-text>2.1.6.2、ApplicationContextAware和BeanNameAware</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-6-3%E3%80%81%E5%85%B6%E5%AE%83Aware%E6%8E%A5%E5%8F%A3><span class=nav-number>2.1.6.3.</span> <span class=nav-text>2.1.6.3、其它Aware接口</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-7%E3%80%81Bean%E5%AE%9A%E4%B9%89%E7%BB%A7%E6%89%BF><span class=nav-number>2.1.7.</span> <span class=nav-text>2.1.7、Bean定义继承</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-8%E3%80%81%E5%AE%B9%E5%99%A8%E5%BB%B6%E4%BC%B8><span class=nav-number>2.1.8.</span> <span class=nav-text>2.1.8、容器延伸</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-8-1%E3%80%81%E4%BD%BF%E7%94%A8BeanPostProcessor%E5%AE%9A%E4%B9%89Bean><span class=nav-number>2.1.8.1.</span> <span class=nav-text>2.1.8.1、使用BeanPostProcessor定义Bean</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%A4%BA%E4%BE%8B%EF%BC%9AHello-world%EF%BC%8CBeanPostProcessor><span class=nav-number>2.1.8.1.1.</span> <span class=nav-text>示例：Hello world，BeanPostProcessor</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%A4%BA%E4%BE%8B%EF%BC%9A-RequiredAnnotationBeanPostProcessor><span class=nav-number>2.1.8.1.2.</span> <span class=nav-text>示例： RequiredAnnotationBeanPostProcessor</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-8-2%E3%80%81%E4%BD%BF%E7%94%A8BeanFactoryPostProcessor%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E5%85%83%E6%95%B0%E6%8D%AE><span class=nav-number>2.1.8.2.</span> <span class=nav-text>2.1.8.2、使用BeanFactoryPostProcessor自定义配置元数据</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%B1%BB%E5%90%8D%E6%9B%BF%E6%8D%A2-PropertySourcesPlaceholderConfigurer><span class=nav-number>2.1.8.2.1.</span> <span class=nav-text>示例：类名替换 PropertySourcesPlaceholderConfigurer</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%A4%BA%E4%BE%8B%EF%BC%9A-PropertyOverrideConfigurer><span class=nav-number>2.1.8.2.2.</span> <span class=nav-text>示例： PropertyOverrideConfigurer</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-8-3%E3%80%81%E4%BD%BF%E7%94%A8FactoryBean%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E4%BE%8B%E5%8C%96><span class=nav-number>2.1.8.3.</span> <span class=nav-text>2.1.8.3、使用FactoryBean自定义实例化</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-9%E3%80%81%E5%9F%BA%E4%BA%8E%E6%B3%A8%E9%87%8A%E7%9A%84%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE><span class=nav-number>2.1.9.</span> <span class=nav-text>2.1.9、基于注释的容器配置</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-9-1%E3%80%81-Required><span class=nav-number>2.1.9.1.</span> <span class=nav-text>2.1.9.1、@Required</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-9-2%E3%80%81%E4%BD%BF%E7%94%A8-Autowired><span class=nav-number>2.1.9.2.</span> <span class=nav-text>2.1.9.2、使用@Autowired</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-9-3%E3%80%81%E4%BD%BF%E7%94%A8-Primary><span class=nav-number>2.1.9.3.</span> <span class=nav-text>2.1.9.3、使用@Primary</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-9-4%E3%80%81%E4%BD%BF%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6><span class=nav-number>2.1.9.4.</span> <span class=nav-text>2.1.9.4、使用限定符</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-9-5%E3%80%81%E5%B0%86%E6%B3%9B%E5%9E%8B%E7%94%A8%E4%BD%9C%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E9%99%90%E5%AE%9A%E7%AC%A6><span class=nav-number>2.1.9.5.</span> <span class=nav-text>2.1.9.5、将泛型用作自动装配限定符</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-9-6%E3%80%81%E4%BD%BF%E7%94%A8CustomAutowireConfigurer><span class=nav-number>2.1.9.6.</span> <span class=nav-text>2.1.9.6、使用CustomAutowireConfigurer</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-9-7%E3%80%81%E4%BD%BF%E7%94%A8-Resource%E6%B3%A8%E5%85%A5><span class=nav-number>2.1.9.7.</span> <span class=nav-text>2.1.9.7、使用@Resource注入</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-9-8%E3%80%81%E4%BD%BF%E7%94%A8-Value><span class=nav-number>2.1.9.8.</span> <span class=nav-text>2.1.9.8、使用@Value</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-9-9%E3%80%81%E4%BD%BF%E7%94%A8-PostConstruct%E5%92%8C-PreDestroy><span class=nav-number>2.1.9.9.</span> <span class=nav-text>2.1.9.9、使用@PostConstruct和@PreDestroy</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-10%E3%80%81%E7%B1%BB%E8%B7%AF%E5%BE%84%E6%89%AB%E6%8F%8F%E5%92%8C%E6%89%98%E7%AE%A1%E7%BB%84%E4%BB%B6><span class=nav-number>2.1.10.</span> <span class=nav-text>2.1.10、类路径扫描和托管组件</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-10-1%E3%80%81-Component%E5%92%8C%E5%85%B6%E5%AE%83%E6%B3%A8%E8%A7%A3><span class=nav-number>2.1.10.1.</span> <span class=nav-text>2.1.10.1、@Component和其它注解</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-10-2%E3%80%81%E4%BD%BF%E7%94%A8%E5%85%83%E6%B3%A8%E9%87%8A%E5%92%8C%E7%BB%84%E5%90%88%E6%B3%A8%E9%87%8A><span class=nav-number>2.1.10.2.</span> <span class=nav-text>2.1.10.2、使用元注释和组合注释</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-10-3%E3%80%81%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E7%B1%BB%E5%B9%B6%E6%B3%A8%E5%86%8CBean%E5%AE%9A%E4%B9%89><span class=nav-number>2.1.10.3.</span> <span class=nav-text>2.1.10.3、自动检测类并注册Bean定义</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-10-4%E3%80%81%E4%BD%BF%E7%94%A8%E8%BF%87%E6%BB%A4%E5%99%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%AB%E6%8F%8F><span class=nav-number>2.1.10.4.</span> <span class=nav-text>2.1.10.4、使用过滤器自定义扫描</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-10-5%E3%80%81%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%AE%9A%E4%B9%89Bean%E5%85%83%E6%95%B0%E6%8D%AE><span class=nav-number>2.1.10.5.</span> <span class=nav-text>2.1.10.5、在组件中定义Bean元数据</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-10-6%E3%80%81%E5%91%BD%E5%90%8D%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E7%9A%84%E7%BB%84%E4%BB%B6><span class=nav-number>2.1.10.6.</span> <span class=nav-text>2.1.10.6、命名自动检测的组件</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-10-7%E3%80%81%E6%8F%90%E4%BE%9B%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E7%BB%84%E4%BB%B6%E7%9A%84%E8%8C%83%E5%9B%B4><span class=nav-number>2.1.10.7.</span> <span class=nav-text>2.1.10.7、提供自动检测组件的范围</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-10-8%E3%80%81%E6%8F%90%E4%BE%9B%E5%B8%A6%E6%B3%A8%E9%87%8A%E7%9A%84%E9%99%90%E5%AE%9A%E7%AC%A6%E5%85%83%E6%95%B0%E6%8D%AE><span class=nav-number>2.1.10.8.</span> <span class=nav-text>2.1.10.8、提供带注释的限定符元数据</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-10-9%E3%80%81%E7%94%9F%E6%88%90%E5%80%99%E9%80%89%E7%BB%84%E4%BB%B6%E7%9A%84%E7%B4%A2%E5%BC%95><span class=nav-number>2.1.10.9.</span> <span class=nav-text>2.1.10.9、生成候选组件的索引</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-11%E3%80%81%E4%BD%BF%E7%94%A8-JSR330-%E6%A0%87%E5%87%86%E6%B3%A8%E9%87%8A><span class=nav-number>2.1.11.</span> <span class=nav-text>2.1.11、使用 JSR330 标准注释</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-11-1%E3%80%81-Inject%E5%92%8C-Named%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5><span class=nav-number>2.1.11.1.</span> <span class=nav-text>2.1.11.1、@Inject和@Named的依赖注入</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-11-2%E3%80%81-Named%E5%92%8C-ManagedBean%EF%BC%9A-Component%E6%B3%A8%E9%87%8A%E7%9A%84%E6%A0%87%E5%87%86%E7%AD%89%E6%95%88%E9%A1%B9><span class=nav-number>2.1.11.2.</span> <span class=nav-text>2.1.11.2、@Named和@ManagedBean：@Component注释的标准等效项</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-11-3%E3%80%81JSR-330%E6%A0%87%E5%87%86%E6%B3%A8%E9%87%8A%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7><span class=nav-number>2.1.11.3.</span> <span class=nav-text>2.1.11.3、JSR-330标准注释的局限性</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-12%E3%80%81%E5%9F%BA%E4%BA%8EJava%E7%9A%84%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE><span class=nav-number>2.1.12.</span> <span class=nav-text>2.1.12、基于Java的容器配置</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-12-1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A-Bean%E5%92%8C-Configuration><span class=nav-number>2.1.12.1.</span> <span class=nav-text>2.1.12.1、基本概念：@Bean和@Configuration</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-12-2%E3%80%81%E4%BD%BF%E7%94%A8AnnotationConfigApplicationContext%E5%AE%9E%E4%BE%8B%E5%8C%96Spring%E5%AE%B9%E5%99%A8><span class=nav-number>2.1.12.2.</span> <span class=nav-text>2.1.12.2、使用AnnotationConfigApplicationContext实例化Spring容器</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#Simple-Construction><span class=nav-number>2.1.12.2.1.</span> <span class=nav-text>Simple Construction</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%80%9A%E8%BF%87%E4%BD%BF%E7%94%A8register-Class%E2%80%A6-%E4%BB%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8><span class=nav-number>2.1.12.2.2.</span> <span class=nav-text>通过使用register(Class&LT?>…)以编程方式构建容器</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%BF%E7%94%A8scan-String%E2%80%A6-%E5%90%AF%E7%94%A8%E7%BB%84%E4%BB%B6%E6%89%AB%E6%8F%8F><span class=nav-number>2.1.12.2.3.</span> <span class=nav-text>使用scan(String…)启用组件扫描</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%80%9A%E8%BF%87AnnotationConfigWebApplicationContext%E6%94%AF%E6%8C%81Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F><span class=nav-number>2.1.12.2.4.</span> <span class=nav-text>通过AnnotationConfigWebApplicationContext支持Web应用程序</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-12-3%E3%80%81%E4%BD%BF%E7%94%A8-Bean%E6%B3%A8%E9%87%8A><span class=nav-number>2.1.12.3.</span> <span class=nav-text>2.1.12.3、使用@Bean注释</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AABean><span class=nav-number>2.1.12.3.1.</span> <span class=nav-text>声明一个Bean</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Bean%E4%BE%9D%E8%B5%96><span class=nav-number>2.1.12.3.2.</span> <span class=nav-text>Bean依赖</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%8E%A5%E6%94%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%9E%E8%B0%83><span class=nav-number>2.1.12.3.3.</span> <span class=nav-text>接收生命周期回调</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%8C%87%E5%AE%9ABean%E8%8C%83%E5%9B%B4><span class=nav-number>2.1.12.3.4.</span> <span class=nav-text>指定Bean范围</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#%E4%BD%BF%E7%94%A8-Scope%E6%B3%A8%E9%87%8A><span class=nav-number>2.1.12.3.4.1.</span> <span class=nav-text>使用@Scope注释</span></a><li class="nav-item nav-level-6"><a class=nav-link href=#Scope%E5%92%8C-scoped-proxy><span class=nav-number>2.1.12.3.4.2.</span> <span class=nav-text>@Scope和 scoped-proxy</span></a></ol><li class="nav-item nav-level-5"><a class=nav-link href=#%E8%87%AA%E5%AE%9A%E4%B9%89Bean%E5%91%BD%E5%90%8D><span class=nav-number>2.1.12.3.5.</span> <span class=nav-text>自定义Bean命名</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Bean%E5%88%AB%E5%90%8D><span class=nav-number>2.1.12.3.6.</span> <span class=nav-text>Bean别名</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Bean%E6%8F%8F%E8%BF%B0><span class=nav-number>2.1.12.3.7.</span> <span class=nav-text>Bean描述</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-12-4%E3%80%81%E4%BD%BF%E7%94%A8-Configuration%E6%B3%A8%E9%87%8A><span class=nav-number>2.1.12.4.</span> <span class=nav-text>2.1.12.4、使用@Configuration注释</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%B3%A8%E5%85%A5bean%E9%97%B4%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB><span class=nav-number>2.1.12.4.1.</span> <span class=nav-text>注入bean间的依赖关系</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%9F%A5%E6%89%BE%E6%96%B9%E6%B3%95%E6%B3%A8%E5%85%A5-1><span class=nav-number>2.1.12.4.2.</span> <span class=nav-text>查找方法注入</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%9C%89%E5%85%B3%E5%9F%BA%E4%BA%8EJava%E7%9A%84%E9%85%8D%E7%BD%AE%E5%A6%82%E4%BD%95%E5%9C%A8%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%9B%B4%E5%A4%9A%E4%BF%A1%E6%81%AF><span class=nav-number>2.1.12.4.3.</span> <span class=nav-text>有关基于Java的配置如何在内部工作的更多信息</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-12-5%E3%80%81%E7%BB%84%E6%88%90%E5%9F%BA%E4%BA%8EJava%E7%9A%84%E9%85%8D%E7%BD%AE><span class=nav-number>2.1.12.5.</span> <span class=nav-text>2.1.12.5、组成基于Java的配置</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%BF%E7%94%A8-Import%E6%B3%A8%E9%87%8A><span class=nav-number>2.1.12.5.1.</span> <span class=nav-text>使用@Import注释</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#%E6%B3%A8%E5%85%A5%E5%AF%B9%E5%AF%BC%E5%85%A5-Bean%E5%AE%9A%E4%B9%89%E7%9A%84%E4%BE%9D%E8%B5%96><span class=nav-number>2.1.12.5.1.1.</span> <span class=nav-text>注入对导入@Bean定义的依赖</span></a></ol><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%9C%89%E6%9D%A1%E4%BB%B6%E5%9C%B0%E5%8C%85%E5%90%AB-Configuration%E7%B1%BB%E6%88%96-Bean%E6%96%B9%E6%B3%95><span class=nav-number>2.1.12.5.2.</span> <span class=nav-text>有条件地包含@Configuration类或@Bean方法</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%BB%93%E5%90%88Java%E5%92%8CXML%E9%85%8D%E7%BD%AE><span class=nav-number>2.1.12.5.3.</span> <span class=nav-text>结合Java和XML配置</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#%E4%BB%A5XML%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84-Configuration%E7%B1%BB%E4%BD%BF%E7%94%A8><span class=nav-number>2.1.12.5.3.1.</span> <span class=nav-text>以XML为中心的@Configuration类使用</span></a></ol></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-13%E3%80%81%E6%8A%BD%E8%B1%A1%E7%8E%AF%E5%A2%83><span class=nav-number>2.1.13.</span> <span class=nav-text>2.1.13、抽象环境</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-13-1%E3%80%81Bean%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6><span class=nav-number>2.1.13.1.</span> <span class=nav-text>2.1.13.1、Bean定义配置文件</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%BF%E7%94%A8-Profile><span class=nav-number>2.1.13.1.1.</span> <span class=nav-text>使用 @Profile</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#XML-Bean%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6><span class=nav-number>2.1.13.1.2.</span> <span class=nav-text>XML Bean定义配置文件</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%BF%80%E6%B4%BBProfile><span class=nav-number>2.1.13.1.3.</span> <span class=nav-text>激活Profile</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6><span class=nav-number>2.1.13.1.4.</span> <span class=nav-text>默认配置文件</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-13-2%E3%80%81PropertySource%E6%8A%BD%E8%B1%A1><span class=nav-number>2.1.13.2.</span> <span class=nav-text>2.1.13.2、PropertySource抽象</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-13-3%E3%80%82%E4%BD%BF%E7%94%A8-PropertySource><span class=nav-number>2.1.13.3.</span> <span class=nav-text>2.1.13.3。使用@PropertySource</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-13-4%E3%80%82%E5%A3%B0%E6%98%8E%E4%B8%AD%E7%9A%84%E5%8D%A0%E4%BD%8D%E7%AC%A6%E8%A7%A3%E6%9E%90><span class=nav-number>2.1.13.4.</span> <span class=nav-text>2.1.13.4。声明中的占位符解析</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-14%E3%80%81%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AALoadTimeWeaver><span class=nav-number>2.1.14.</span> <span class=nav-text>2.1.14、注册一个LoadTimeWeaver</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-15%E3%80%81ApplicationContext%E7%9A%84%E5%85%B6%E5%AE%83%E5%8A%9F%E8%83%BD><span class=nav-number>2.1.15.</span> <span class=nav-text>2.1.15、ApplicationContext的其它功能</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-15-1%E3%80%81%E4%BD%BF%E7%94%A8MessageSource%E8%BF%9B%E8%A1%8C%E5%9B%BD%E9%99%85%E5%8C%96><span class=nav-number>2.1.15.1.</span> <span class=nav-text>2.1.15.1、使用MessageSource进行国际化</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-15-2%E3%80%81%E6%A0%87%E5%87%86%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6><span class=nav-number>2.1.15.2.</span> <span class=nav-text>2.1.15.2、标准和自定义事件</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E9%87%8A%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BE%A6%E5%90%AC%E5%99%A8><span class=nav-number>2.1.15.2.1.</span> <span class=nav-text>基于注释的事件侦听器</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%BC%82%E6%AD%A5%E4%BE%A6%E5%90%AC%E5%99%A8><span class=nav-number>2.1.15.2.2.</span> <span class=nav-text>异步侦听器</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%B8%80%E8%88%AC%E4%BA%8B%E4%BB%B6><span class=nav-number>2.1.15.2.3.</span> <span class=nav-text>一般事件</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-15-3%E3%80%81%E6%96%B9%E4%BE%BF%E5%9C%B0%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90><span class=nav-number>2.1.15.3.</span> <span class=nav-text>2.1.15.3、方便地访问资源</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-15-4%E3%80%81%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%B7%9F%E8%B8%AA><span class=nav-number>2.1.15.4.</span> <span class=nav-text>2.1.15.4、应用程序启动跟踪</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-15-5%E3%80%81Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BE%BF%E6%8D%B7><span class=nav-number>2.1.15.5.</span> <span class=nav-text>2.1.15.5、Web应用程序的便捷</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-15-6%E3%80%81%E5%B0%86SpringApplicationContext%E9%83%A8%E7%BD%B2%E4%B8%BAJava-EE-RAR%E6%96%87%E4%BB%B6><span class=nav-number>2.1.15.6.</span> <span class=nav-text>2.1.15.6、将SpringApplicationContext部署为Java EE RAR文件</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-16%E3%80%81BeanFactory><span class=nav-number>2.1.16.</span> <span class=nav-text>2.1.16、BeanFactory</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-16-1%E3%80%81BeanFactory%E8%BF%98%E6%98%AFApplicationContext><span class=nav-number>2.1.16.1.</span> <span class=nav-text>2.1.16.1、BeanFactory还是ApplicationContext</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-2%E3%80%81AOP-API><span class=nav-number>2.2.</span> <span class=nav-text>2.2、AOP API</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-1%E3%80%81Spring%E4%B8%AD%E7%9A%84Pointcut-API><span class=nav-number>2.2.1.</span> <span class=nav-text>2.2.1、Spring中的Pointcut API</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-1-1%E3%80%81%E6%A6%82%E5%BF%B5><span class=nav-number>2.2.1.1.</span> <span class=nav-text>2.2.1.1、概念</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-1-2%E3%80%81%E5%88%87%E5%85%A5%E7%82%B9%E6%93%8D%E4%BD%9C><span class=nav-number>2.2.1.2.</span> <span class=nav-text>2.2.1.2、切入点操作</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-1-3%E3%80%81AspectJ%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F><span class=nav-number>2.2.1.3.</span> <span class=nav-text>2.2.1.3、AspectJ切入点表达式</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-1-4%E3%80%81%E4%BE%BF%E6%8D%B7%E5%88%87%E5%85%A5%E7%82%B9%E5%AE%9E%E7%8E%B0><span class=nav-number>2.2.1.4.</span> <span class=nav-text>2.2.1.4、便捷切入点实现</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%9D%99%E6%80%81%E5%88%87%E5%85%A5%E7%82%B9><span class=nav-number>2.2.1.4.1.</span> <span class=nav-text>静态切入点</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%87%E5%85%A5%E7%82%B9><span class=nav-number>2.2.1.4.1.1.</span> <span class=nav-text>正则表达式切入点</span></a><li class="nav-item nav-level-6"><a class=nav-link href=#%E5%B1%9E%E6%80%A7%E9%A9%B1%E5%8A%A8%E5%88%87%E5%85%A5%E7%82%B9><span class=nav-number>2.2.1.4.1.2.</span> <span class=nav-text>属性驱动切入点</span></a></ol><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%8A%A8%E6%80%81%E5%88%87%E5%85%A5%E7%82%B9><span class=nav-number>2.2.1.4.2.</span> <span class=nav-text>动态切入点</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#%E6%8E%A7%E5%88%B6%E6%B5%81%E5%88%87%E5%85%A5%E7%82%B9><span class=nav-number>2.2.1.4.2.1.</span> <span class=nav-text>控制流切入点</span></a></ol></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-1-5%E3%80%81%E5%88%87%E5%85%A5%E7%82%B9%E8%B6%85%E7%B1%BB><span class=nav-number>2.2.1.5.</span> <span class=nav-text>2.2.1.5、切入点超类</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-1-6%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%87%E5%85%A5%E7%82%B9><span class=nav-number>2.2.1.6.</span> <span class=nav-text>2.2.1.6、自定义切入点</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-2%E3%80%81Spring-Advice-API><span class=nav-number>2.2.2.</span> <span class=nav-text>2.2.2、Spring Advice API</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-2-1%E3%80%81Advice%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F><span class=nav-number>2.2.2.1.</span> <span class=nav-text>2.2.2.1、Advice生命周期</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-2-2%E3%80%81Advice%E7%B1%BB%E5%9E%8B><span class=nav-number>2.2.2.2.</span> <span class=nav-text>2.2.2.2、Advice类型</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%8B%A6%E6%88%AA%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5><span class=nav-number>2.2.2.2.1.</span> <span class=nav-text>拦截环绕通知</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5><span class=nav-number>2.2.2.2.2.</span> <span class=nav-text>前置通知</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%BC%82%E5%B8%B8%E9%80%9A%E7%9F%A5><span class=nav-number>2.2.2.2.3.</span> <span class=nav-text>异常通知</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E8%BF%94%E5%9B%9E%E5%90%8E%E9%80%9A%E7%9F%A5><span class=nav-number>2.2.2.2.4.</span> <span class=nav-text>返回后通知</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%BC%95%E5%85%A5%E9%80%9A%E7%9F%A5><span class=nav-number>2.2.2.2.5.</span> <span class=nav-text>引入通知</span></a></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-3%E3%80%81Spring-Advisor-API><span class=nav-number>2.2.3.</span> <span class=nav-text>2.2.3、Spring Advisor API</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-4%E3%80%81%E4%BD%BF%E7%94%A8ProxyFactoryBean%E5%88%9B%E5%BB%BAAOP%E4%BB%A3%E7%90%86><span class=nav-number>2.2.4.</span> <span class=nav-text>2.2.4、使用ProxyFactoryBean创建AOP代理</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-4-1%E3%80%81Base><span class=nav-number>2.2.4.1.</span> <span class=nav-text>2.2.4.1、Base</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-4-2%E3%80%81Java-Bean%E5%B1%9E%E6%80%A7><span class=nav-number>2.2.4.2.</span> <span class=nav-text>2.2.4.2、Java Bean属性</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-4-3%E3%80%81JDK%E5%92%8CCGLIB%E4%BB%A3%E7%90%86><span class=nav-number>2.2.4.3.</span> <span class=nav-text>2.2.4.3、JDK和CGLIB代理</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-4-4%E3%80%81%E4%BB%A3%E7%90%86%E6%8E%A5%E5%8F%A3><span class=nav-number>2.2.4.4.</span> <span class=nav-text>2.2.4.4、代理接口</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-4-5%E3%80%81%E4%BB%A3%E7%90%86Class><span class=nav-number>2.2.4.5.</span> <span class=nav-text>2.2.4.5、代理Class</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-4-6%E3%80%81%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E9%80%9A%E7%9F%A5><span class=nav-number>2.2.4.6.</span> <span class=nav-text>2.2.4.6、使用全局通知</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-5%E3%80%81%E7%AE%80%E6%B4%81%E4%BB%A3%E7%90%86%E5%AE%9A%E4%B9%89><span class=nav-number>2.2.5.</span> <span class=nav-text>2.2.5、简洁代理定义</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-6%E3%80%81%E4%BD%BF%E7%94%A8ProxyFactory%E4%BB%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0AOP%E4%BB%A3%E7%90%86><span class=nav-number>2.2.6.</span> <span class=nav-text>2.2.6、使用ProxyFactory以编程方式实现AOP代理</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-7%E3%80%81%E6%93%8D%E4%BD%9C%E9%80%9A%E7%9F%A5%E5%AF%B9%E8%B1%A1><span class=nav-number>2.2.7.</span> <span class=nav-text>2.2.7、操作通知对象</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-8%E3%80%81%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%90%86%E5%8A%9F%E8%83%BD><span class=nav-number>2.2.8.</span> <span class=nav-text>2.2.8、使用自动代理功能</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-8-1%E3%80%81%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%90%86Bean%E5%AE%9A%E4%B9%89><span class=nav-number>2.2.8.1.</span> <span class=nav-text>2.2.8.1、自动代理Bean定义</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#BeanNameAutoProxyCreator><span class=nav-number>2.2.8.1.1.</span> <span class=nav-text>BeanNameAutoProxyCreator</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#DefaultAdvisorAutoProxyCreator><span class=nav-number>2.2.8.1.2.</span> <span class=nav-text>DefaultAdvisorAutoProxyCreator</span></a></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-9%E3%80%81%E4%BD%BF%E7%94%A8TargetSource%E5%AE%9E%E6%96%BD><span class=nav-number>2.2.9.</span> <span class=nav-text>2.2.9、使用TargetSource实施</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-9-1%E3%80%81%E7%83%AD%E6%8F%92%E6%8B%94%E7%9B%AE%E6%A0%87%E6%BA%90><span class=nav-number>2.2.9.1.</span> <span class=nav-text>2.2.9.1、热插拔目标源</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-9-2%E3%80%81%E6%B1%87%E9%9B%86%E7%9B%AE%E6%A0%87%E6%BA%90><span class=nav-number>2.2.9.2.</span> <span class=nav-text>2.2.9.2、汇集目标源</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-9-3%E3%80%81%E5%8E%9F%E5%9E%8B%E7%9B%AE%E6%A0%87%E6%BA%90><span class=nav-number>2.2.9.3.</span> <span class=nav-text>2.2.9.3、原型目标源</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-9-4%E3%80%81ThreadLocal%E7%9B%AE%E6%A0%87%E6%9D%A5%E6%BA%90><span class=nav-number>2.2.9.4.</span> <span class=nav-text>2.2.9.4、ThreadLocal目标来源</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-10%E3%80%81%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E5%BB%BA%E8%AE%AE%E7%B1%BB%E5%9E%8B><span class=nav-number>2.2.10.</span> <span class=nav-text>2.2.10、定义新的建议类型</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-3%E3%80%81AOP><span class=nav-number>2.3.</span> <span class=nav-text>2.3、AOP</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-1%E3%80%81AOP%E6%A6%82%E5%BF%B5><span class=nav-number>2.3.1.</span> <span class=nav-text>2.3.1、AOP概念</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-2%E3%80%81Spring-AOP%E8%83%BD%E5%8A%9B%E5%92%8C%E7%9B%AE%E6%A0%87><span class=nav-number>2.3.2.</span> <span class=nav-text>2.3.2、Spring AOP能力和目标</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-3%E3%80%81AOP%E4%BB%A3%E7%90%86><span class=nav-number>2.3.3.</span> <span class=nav-text>2.3.3、AOP代理</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-4%E3%80%81-AspectJ%E6%94%AF%E6%8C%81><span class=nav-number>2.3.4.</span> <span class=nav-text>2.3.4、@AspectJ支持</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-4-1%E3%80%81%E5%90%AF%E7%94%A8-AspectJ%E6%94%AF%E6%8C%81><span class=nav-number>2.3.4.1.</span> <span class=nav-text>2.3.4.1、启用@AspectJ支持</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%80%9A%E8%BF%87Java%E9%85%8D%E7%BD%AE%E5%90%AF%E7%94%A8-AspectJ%E6%94%AF%E6%8C%81><span class=nav-number>2.3.4.1.1.</span> <span class=nav-text>通过Java配置启用@AspectJ支持</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%80%9A%E8%BF%87XML%E9%85%8D%E7%BD%AE%E5%90%AF%E7%94%A8-AspectJ%E6%94%AF%E6%8C%81><span class=nav-number>2.3.4.1.2.</span> <span class=nav-text>通过XML配置启用@AspectJ支持</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-4-2%E3%80%81%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E6%96%B9%E9%9D%A2><span class=nav-number>2.3.4.2.</span> <span class=nav-text>2.3.4.2、声明一个方面</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-4-3%E3%80%81%E5%A3%B0%E6%98%8E%E5%88%87%E5%85%A5%E7%82%B9><span class=nav-number>2.3.4.3.</span> <span class=nav-text>2.3.4.3、声明切入点</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%94%AF%E6%8C%81%E7%9A%84%E5%88%87%E5%85%A5%E7%82%B9%E6%8C%87%E7%A4%BA%E7%AC%A6><span class=nav-number>2.3.4.3.1.</span> <span class=nav-text>支持的切入点指示符</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%BB%84%E5%90%88%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F><span class=nav-number>2.3.4.3.2.</span> <span class=nav-text>组合切入点表达式</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%85%B1%E4%BA%AB%E9%80%9A%E7%94%A8%E5%88%87%E5%85%A5%E7%82%B9%E5%AE%9A%E4%B9%89><span class=nav-number>2.3.4.3.3.</span> <span class=nav-text>共享通用切入点定义</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%BC%96%E5%86%99%E5%A5%BD%E7%9A%84%E5%88%87%E5%85%A5%E7%82%B9><span class=nav-number>2.3.4.3.4.</span> <span class=nav-text>编写好的切入点</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-4-4%E3%80%81%E5%A3%B0%E6%98%8E%E9%80%9A%E7%9F%A5><span class=nav-number>2.3.4.4.</span> <span class=nav-text>2.3.4.4、声明通知</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#before%E9%80%9A%E7%9F%A5><span class=nav-number>2.3.4.4.1.</span> <span class=nav-text>before通知</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#after%E9%80%9A%E7%9F%A5><span class=nav-number>2.3.4.4.2.</span> <span class=nav-text>after通知</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E8%BF%94%E5%9B%9E%E5%90%8E%E9%80%9A%E7%9F%A5-1><span class=nav-number>2.3.4.4.3.</span> <span class=nav-text>返回后通知</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%BC%82%E5%B8%B8%E5%90%8E%E9%80%9A%E7%9F%A5><span class=nav-number>2.3.4.4.4.</span> <span class=nav-text>异常后通知</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5><span class=nav-number>2.3.4.4.5.</span> <span class=nav-text>环绕通知</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%80%9A%E7%9F%A5%E5%8F%82%E6%95%B0><span class=nav-number>2.3.4.4.6.</span> <span class=nav-text>通知参数</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#%E8%AE%BF%E9%97%AE%E5%BD%93%E5%89%8DJoinPoint><span class=nav-number>2.3.4.4.6.1.</span> <span class=nav-text>访问当前JoinPoint</span></a><li class="nav-item nav-level-6"><a class=nav-link href=#%E5%B0%86%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E7%BB%99%E9%80%9A%E7%9F%A5><span class=nav-number>2.3.4.4.6.2.</span> <span class=nav-text>将参数传递给通知</span></a><li class="nav-item nav-level-6"><a class=nav-link href=#%E9%80%9A%E7%9F%A5%E5%8F%82%E6%95%B0%E5%92%8C%E6%B3%9B%E5%9E%8B><span class=nav-number>2.3.4.4.6.3.</span> <span class=nav-text>通知参数和泛型</span></a><li class="nav-item nav-level-6"><a class=nav-link href=#%E7%A1%AE%E5%AE%9A%E5%8F%82%E6%95%B0%E5%91%BD%E5%90%8D%E7%A7%B0><span class=nav-number>2.3.4.4.6.4.</span> <span class=nav-text>确定参数命名称</span></a><li class="nav-item nav-level-6"><a class=nav-link href=#%E8%BF%9B%E8%A1%8C%E8%AE%BA%E8%AF%81><span class=nav-number>2.3.4.4.6.5.</span> <span class=nav-text>进行论证</span></a></ol><li class="nav-item nav-level-5"><a class=nav-link href=#%E8%AE%A2%E8%B4%AD%E9%80%9A%E7%9F%A5><span class=nav-number>2.3.4.4.7.</span> <span class=nav-text>订购通知</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-4-5%E3%80%81%E5%BC%95%E8%A8%80><span class=nav-number>2.3.4.5.</span> <span class=nav-text>2.3.4.5、引言</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-4-6%E3%80%81%E6%96%B9%E9%9D%A2%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%A8%A1%E5%9E%8B><span class=nav-number>2.3.4.6.</span> <span class=nav-text>2.3.4.6、方面实例化模型</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-4-7%E3%80%81AOP%E7%A4%BA%E4%BE%8B><span class=nav-number>2.3.4.7.</span> <span class=nav-text>2.3.4.7、AOP示例</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-5%E3%80%81%E5%9F%BA%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84AOP%E6%94%AF%E6%8C%81><span class=nav-number>2.3.5.</span> <span class=nav-text>2.3.5、基于架构的AOP支持</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-5-1%E3%80%81%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E6%96%B9%E9%9D%A2><span class=nav-number>2.3.5.1.</span> <span class=nav-text>2.3.5.1、声明一个方面</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-5-2%E3%80%81%E5%A3%B0%E6%98%8E%E5%88%87%E5%85%A5%E7%82%B9><span class=nav-number>2.3.5.2.</span> <span class=nav-text>2.3.5.2、声明切入点</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-5-3%E3%80%81%E5%AE%A3%E5%91%8A%E9%80%9A%E7%9F%A5><span class=nav-number>2.3.5.3.</span> <span class=nav-text>2.3.5.3、宣告通知</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%89%8D%E7%BD%AE%E9%80%9A%E7%9F%A5-1><span class=nav-number>2.3.5.3.1.</span> <span class=nav-text>前置通知</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E8%BF%94%E5%9B%9E%E5%90%8E%E9%80%9A%E7%9F%A5-2><span class=nav-number>2.3.5.3.2.</span> <span class=nav-text>返回后通知</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%BC%82%E5%B8%B8%E9%80%9A%E7%9F%A5-1><span class=nav-number>2.3.5.3.3.</span> <span class=nav-text>异常通知</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%90%8E%E7%BD%AE%E9%80%9A%E7%9F%A5><span class=nav-number>2.3.5.3.4.</span> <span class=nav-text>后置通知</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5-1><span class=nav-number>2.3.5.3.5.</span> <span class=nav-text>环绕通知</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%80%9A%E7%9F%A5%E5%8F%82%E6%95%B0-1><span class=nav-number>2.3.5.3.6.</span> <span class=nav-text>通知参数</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E8%AE%A2%E8%B4%AD%E9%80%9A%E7%9F%A5-1><span class=nav-number>2.3.5.3.7.</span> <span class=nav-text>订购通知</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-5-4%E3%80%81%E5%BC%95%E8%A8%80><span class=nav-number>2.3.5.4.</span> <span class=nav-text>2.3.5.4、引言</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-5-5%E3%80%81%E6%96%B9%E9%9D%A2%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%A8%A1%E5%9E%8B><span class=nav-number>2.3.5.5.</span> <span class=nav-text>2.3.5.5、方面实例化模型</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-5-6%E3%80%81%E9%80%9A%E7%9F%A5><span class=nav-number>2.3.5.6.</span> <span class=nav-text>2.3.5.6、通知</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-5-7%E3%80%81AOP%E6%A8%A1%E5%BC%8F%E7%A4%BA%E4%BE%8B><span class=nav-number>2.3.5.7.</span> <span class=nav-text>2.3.5.7、AOP模式示例</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-6%E3%80%81%E9%80%89%E6%8B%A9%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84AOP%E5%A3%B0%E6%98%8E%E6%A0%B7%E5%BC%8F><span class=nav-number>2.3.6.</span> <span class=nav-text>2.3.6、选择要使用的AOP声明样式</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-6-1%E3%80%81Spring-AOP%E8%BF%98%E6%98%AF-Full-AspectJ%EF%BC%9F><span class=nav-number>2.3.6.1.</span> <span class=nav-text>2.3.6.1、Spring AOP还是 Full AspectJ？</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-6-2%E3%80%81-AspectJ%E6%88%96Spring-AOP%E7%9A%84XML%EF%BC%9F><span class=nav-number>2.3.6.2.</span> <span class=nav-text>2.3.6.2、@AspectJ或Spring AOP的XML？</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-7%E3%80%81%E6%B7%B7%E5%90%88%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B><span class=nav-number>2.3.7.</span> <span class=nav-text>2.3.7、混合通知类型</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-8%E3%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6><span class=nav-number>2.3.8.</span> <span class=nav-text>2.3.8、代理机制</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-8-1%E3%80%81%E4%BA%86%E8%A7%A3AOP%E4%BB%A3%E7%90%86><span class=nav-number>2.3.8.1.</span> <span class=nav-text>2.3.8.1、了解AOP代理</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-9%E3%80%81%E4%BB%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA-AspectJ%E4%BB%A3%E7%90%86><span class=nav-number>2.3.9.</span> <span class=nav-text>2.3.9、以编程方式创建@AspectJ代理</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-10%E3%80%81%E5%9C%A8Spring%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8AspectJ><span class=nav-number>2.3.10.</span> <span class=nav-text>2.3.10、在Spring应用程序中使用AspectJ</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-10-1%E3%80%81%E4%BD%BF%E7%94%A8AspectJ%E9%80%9A%E8%BF%87Spring%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%9F%9F%E5%AF%B9%E8%B1%A1><span class=nav-number>2.3.10.1.</span> <span class=nav-text>2.3.10.1、使用AspectJ通过Spring依赖注入域对象</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Configurable%E5%AF%B9%E8%B1%A1><span class=nav-number>2.3.10.1.1.</span> <span class=nav-text>单元测试@Configurable对象</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8A%E4%B8%8B%E6%96%87><span class=nav-number>2.3.10.1.2.</span> <span class=nav-text>使用多个应用程序上下文</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-10-2%E3%80%81AspectJ%E7%9A%84%E5%85%B6%E4%BB%96Spring%E6%96%B9%E9%9D%A2><span class=nav-number>2.3.10.2.</span> <span class=nav-text>2.3.10.2、AspectJ的其他Spring方面</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-10-3%E3%80%81%E4%BD%BF%E7%94%A8Spring-IoC%E9%85%8D%E7%BD%AEAspectJ-Aspects><span class=nav-number>2.3.10.3.</span> <span class=nav-text>2.3.10.3、使用Spring IoC配置AspectJ Aspects</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-3-10-4%E3%80%81%E5%9C%A8Spring-Framework%E4%B8%AD%E4%BD%BF%E7%94%A8AspectJ%E8%BF%9B%E8%A1%8C%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%BC%96%E7%BB%87><span class=nav-number>2.3.10.4.</span> <span class=nav-text>2.3.10.4、在Spring Framework中使用AspectJ进行加载时编织</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90><span class=nav-number>2.3.10.4.1.</span> <span class=nav-text>第一个例子</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%96%B9%E9%9D%A2><span class=nav-number>2.3.10.4.2.</span> <span class=nav-text>方面</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#META-INF-aop-xml%E2%80%99><span class=nav-number>2.3.10.4.3.</span> <span class=nav-text>META-INF / aop.xml’</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%89%80%E9%9C%80%E7%9A%84%E5%BA%93%EF%BC%88JARS%EF%BC%89><span class=nav-number>2.3.10.4.4.</span> <span class=nav-text>所需的库（JARS）</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%BC%B9%E7%B0%A7%E9%85%8D%E7%BD%AE><span class=nav-number>2.3.10.4.5.</span> <span class=nav-text>弹簧配置</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%89%B9%E5%AE%9A%E4%BA%8E%E7%8E%AF%E5%A2%83%E7%9A%84%E9%85%8D%E7%BD%AE><span class=nav-number>2.3.10.4.6.</span> <span class=nav-text>特定于环境的配置</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#Tomcat%EF%BC%8CJBoss%EF%BC%8CWebSphere%EF%BC%8CWebLogic><span class=nav-number>2.3.10.4.6.1.</span> <span class=nav-text>Tomcat，JBoss，WebSphere，WebLogic</span></a><li class="nav-item nav-level-6"><a class=nav-link href=#%E9%80%9A%E7%94%A8Java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F><span class=nav-number>2.3.10.4.6.2.</span> <span class=nav-text>通用Java应用程序</span></a></ol></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-11%E3%80%81%E6%9B%B4%E5%A4%9A%E8%B5%84%E6%BA%90><span class=nav-number>2.3.11.</span> <span class=nav-text>2.3.11、更多资源</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-4%E3%80%81Spring%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E8%A8%80><span class=nav-number>2.4.</span> <span class=nav-text>2.4、Spring表达式语言</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-1%E3%80%81Evaluation><span class=nav-number>2.4.1.</span> <span class=nav-text>2.4.1、Evaluation</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-1-1%E3%80%81%E4%BA%86%E8%A7%A3%E8%AF%84%E4%BC%B0%E4%B8%8A%E4%B8%8B%E6%96%87><span class=nav-number>2.4.1.1.</span> <span class=nav-text>2.4.1.1、了解评估上下文</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#Type-Conversion><span class=nav-number>2.4.1.1.1.</span> <span class=nav-text>Type Conversion</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-1-2%E3%80%81%E8%A7%A3%E6%9E%90%E5%99%A8%E9%85%8D%E7%BD%AE><span class=nav-number>2.4.1.2.</span> <span class=nav-text>2.4.1.2、解析器配置</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-1-3%E3%80%81SpEL%E7%BC%96%E8%AF%91><span class=nav-number>2.4.1.3.</span> <span class=nav-text>2.4.1.3、SpEL编译</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#Compiler-Configuration><span class=nav-number>2.4.1.3.1.</span> <span class=nav-text>Compiler Configuration</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Compiler-Limitations><span class=nav-number>2.4.1.3.2.</span> <span class=nav-text>Compiler Limitations</span></a></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-2%E3%80%81Bean%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F><span class=nav-number>2.4.2.</span> <span class=nav-text>2.4.2、Bean定义中的表达式</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-2-1%E3%80%81XML%E9%85%8D%E7%BD%AE><span class=nav-number>2.4.2.1.</span> <span class=nav-text>2.4.2.1、XML配置</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-2-2%E3%80%81%E6%B3%A8%E8%A7%A3%E9%85%8D%E7%BD%AE><span class=nav-number>2.4.2.2.</span> <span class=nav-text>2.4.2.2、注解配置</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-3%E3%80%81%E8%AF%AD%E8%A8%80%E5%8F%82%E8%80%83><span class=nav-number>2.4.3.</span> <span class=nav-text>2.4.3、语言参考</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-3-1%E3%80%81Literals%E8%A1%A8%E8%BE%BE><span class=nav-number>2.4.3.1.</span> <span class=nav-text>2.4.3.1、Literals表达</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-3-2%E3%80%81%E5%B1%9E%E6%80%A7%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%88%97%E8%A1%A8%E3%80%81Map%E5%92%8C%E7%B4%A2%E5%BC%95%E5%99%A8><span class=nav-number>2.4.3.2.</span> <span class=nav-text>2.4.3.2、属性、数组、列表、Map和索引器</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-3-3%E3%80%81%E5%86%85%E8%81%94%E5%88%97%E8%A1%A8><span class=nav-number>2.4.3.3.</span> <span class=nav-text>2.4.3.3、内联列表</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-3-4%E3%80%81%E5%86%85%E8%81%94Map><span class=nav-number>2.4.3.4.</span> <span class=nav-text>2.4.3.4、内联Map</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-3-5%E3%80%81%E9%98%B5%E5%88%97%E6%9E%84%E9%80%A0><span class=nav-number>2.4.3.5.</span> <span class=nav-text>2.4.3.5、阵列构造</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-3-6%E3%80%81Methods><span class=nav-number>2.4.3.6.</span> <span class=nav-text>2.4.3.6、Methods</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-3-7%E3%80%81Operators><span class=nav-number>2.4.3.7.</span> <span class=nav-text>2.4.3.7、Operators</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#Relational-Operators><span class=nav-number>2.4.3.7.1.</span> <span class=nav-text>Relational Operators</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Logical-Operators><span class=nav-number>2.4.3.7.2.</span> <span class=nav-text>Logical Operators</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Mathematical-Operators><span class=nav-number>2.4.3.7.3.</span> <span class=nav-text>Mathematical Operators</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6><span class=nav-number>2.4.3.7.4.</span> <span class=nav-text>赋值运算符</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-3-8%E3%80%81Types><span class=nav-number>2.4.3.8.</span> <span class=nav-text>2.4.3.8、Types</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-3-9%E3%80%81Constructors><span class=nav-number>2.4.3.9.</span> <span class=nav-text>2.4.3.9、Constructors</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-3-10%E3%80%81Variables><span class=nav-number>2.4.3.10.</span> <span class=nav-text>2.4.3.10、Variables</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#this-%E5%92%8C-root-%E5%8F%98%E9%87%8F><span class=nav-number>2.4.3.10.1.</span> <span class=nav-text>#this 和#root 变量</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-3-11%E3%80%81Functions><span class=nav-number>2.4.3.11.</span> <span class=nav-text>2.4.3.11、Functions</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-3-12-Bean-%E5%8F%82%E8%80%83><span class=nav-number>2.4.3.12.</span> <span class=nav-text>2.4.3.12. Bean 参考</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-3-13%E3%80%81%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88if-then-else%EF%BC%89><span class=nav-number>2.4.3.13.</span> <span class=nav-text>2.4.3.13、三元运算符（if-then-else）</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-3-14%E3%80%81Elvisoperator><span class=nav-number>2.4.3.14.</span> <span class=nav-text>2.4.3.14、Elvisoperator</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-3-15%E3%80%81%E5%AE%89%E5%85%A8%E5%AF%BC%E8%88%AA%E6%93%8D%E4%BD%9C%E5%91%98><span class=nav-number>2.4.3.15.</span> <span class=nav-text>2.4.3.15、安全导航操作员</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-3-16%E3%80%81Collections%E9%80%89%E6%8B%A9><span class=nav-number>2.4.3.16.</span> <span class=nav-text>2.4.3.16、Collections选择</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-3-17%E3%80%81%E9%9B%86%E5%90%88%E6%8A%95%E5%BD%B1><span class=nav-number>2.4.3.17.</span> <span class=nav-text>2.4.3.17、集合投影</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-4-3-18%E3%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E6%9D%BF><span class=nav-number>2.4.3.18.</span> <span class=nav-text>2.4.3.18、表达式模板</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-4%E3%80%81%E7%A4%BA%E4%BE%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B1%BB><span class=nav-number>2.4.4.</span> <span class=nav-text>2.4.4、示例中使用的类</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-5%E3%80%81%E7%A9%BA%E5%AE%89%E5%85%A8><span class=nav-number>2.5.</span> <span class=nav-text>2.5、空安全</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-5-1%E3%80%81%E7%94%A8%E4%BE%8B><span class=nav-number>2.5.1.</span> <span class=nav-text>2.5.1、用例</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-5-2%E3%80%81JSR-305%E5%85%83%E6%B3%A8%E9%87%8A><span class=nav-number>2.5.2.</span> <span class=nav-text>2.5.2、JSR-305元注释</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-6%E3%80%81Appendix><span class=nav-number>2.6.</span> <span class=nav-text>2.6、Appendix</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-6-1%E3%80%81XML%E6%A8%A1%E5%BC%8F><span class=nav-number>2.6.1.</span> <span class=nav-text>2.6.1、XML模式</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-6-1-1%E3%80%81%E5%AE%9E%E7%94%A8%E6%A8%A1%E5%BC%8F><span class=nav-number>2.6.1.1.</span> <span class=nav-text>2.6.1.1、实用模式</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%BF%E7%94%A8util-constant><span class=nav-number>2.6.1.1.1.</span> <span class=nav-text>使用util:constant/</span></a><ol class=nav-child><li class="nav-item nav-level-6"><a class=nav-link href=#%E6%A0%B9%E6%8D%AE%E5%AD%97%E6%AE%B5%E5%80%BC%E8%AE%BE%E7%BD%AE-Bean-%E5%B1%9E%E6%80%A7%E6%88%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0><span class=nav-number>2.6.1.1.1.1.</span> <span class=nav-text>根据字段值设置 Bean 属性或构造函数参数</span></a></ol><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%BF%E7%94%A8util-property-path><span class=nav-number>2.6.1.1.2.</span> <span class=nav-text>使用util:property-path/</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%BF%E7%94%A8util-properties><span class=nav-number>2.6.1.1.3.</span> <span class=nav-text>使用util:properties/</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%BF%E7%94%A8util-list><span class=nav-number>2.6.1.1.4.</span> <span class=nav-text>使用util:list/</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%BF%E7%94%A8util-map><span class=nav-number>2.6.1.1.5.</span> <span class=nav-text>使用util:map/</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%BF%E7%94%A8util-set><span class=nav-number>2.6.1.1.6.</span> <span class=nav-text>使用util:set/</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-6-1-2%E3%80%81aop%E6%A8%A1%E5%BC%8F><span class=nav-number>2.6.1.2.</span> <span class=nav-text>2.6.1.2、aop模式</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-6-1-3%E3%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A8%A1%E5%BC%8F><span class=nav-number>2.6.1.3.</span> <span class=nav-text>2.6.1.3、上下文模式</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%BF%E7%94%A8><span class=nav-number>2.6.1.3.1.</span> <span class=nav-text>使用&LTproperty-placeholder/></span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%BF%E7%94%A8-1><span class=nav-number>2.6.1.3.2.</span> <span class=nav-text>使用&LTannotation-config/></span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%BF%E7%94%A8-2><span class=nav-number>2.6.1.3.3.</span> <span class=nav-text>使用&LTcomponent-scan/></span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%BF%E7%94%A8-3><span class=nav-number>2.6.1.3.4.</span> <span class=nav-text>使用&LTload-time-weaver/></span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%BF%E7%94%A8-4><span class=nav-number>2.6.1.3.5.</span> <span class=nav-text>使用&LTspring-configured/></span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%BF%E7%94%A8-5><span class=nav-number>2.6.1.3.6.</span> <span class=nav-text>使用&LTmbean-export/></span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-6-1-4%E3%80%81Bean%E6%A8%A1%E5%BC%8F><span class=nav-number>2.6.1.4.</span> <span class=nav-text>2.6.1.4、Bean模式</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-6-2%E3%80%81XML%E6%A8%A1%E5%BC%8F%E5%88%9B%E4%BD%9C><span class=nav-number>2.6.2.</span> <span class=nav-text>2.6.2、XML模式创作</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-6-2-1%E3%80%81%E7%BC%96%E5%86%99%E6%9E%B6%E6%9E%84><span class=nav-number>2.6.2.1.</span> <span class=nav-text>2.6.2.1、编写架构</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-6-2-2%E3%80%81%E7%BC%96%E7%A0%81-NamespaceHandler><span class=nav-number>2.6.2.2.</span> <span class=nav-text>2.6.2.2、编码 NamespaceHandler</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-6-2-3%E3%80%81%E4%BD%BF%E7%94%A8BeanDefinitionParser><span class=nav-number>2.6.2.3.</span> <span class=nav-text>2.6.2.3、使用BeanDefinitionParser</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-6-2-4%E3%80%81%E6%B3%A8%E5%86%8C%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%9E%B6%E6%9E%84><span class=nav-number>2.6.2.4.</span> <span class=nav-text>2.6.2.4、注册处理程序和架构</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#Writing-META-INF-spring-handlers><span class=nav-number>2.6.2.4.1.</span> <span class=nav-text>Writing META-INF/spring.handlers</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Writing-%E2%80%98META-INF-spring-schemas%E2%80%99><span class=nav-number>2.6.2.4.2.</span> <span class=nav-text>Writing ‘META-INF/spring.schemas’</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#2-6-2-5%E3%80%81%E5%9C%A8-Spring-XML-%E9%85%8D%E7%BD%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%A9%E5%B1%95><span class=nav-number>2.6.2.5.</span> <span class=nav-text>2.6.2.5、在 Spring XML 配置中使用自定义扩展</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-6-2-6%E3%80%81%E6%9B%B4%E8%AF%A6%E7%BB%86%E7%9A%84%E4%BE%8B%E5%AD%90><span class=nav-number>2.6.2.6.</span> <span class=nav-text>2.6.2.6、更详细的例子</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%9C%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B4%A0%E4%B8%AD%E5%B5%8C%E5%A5%97%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E7%B4%A0><span class=nav-number>2.6.2.6.1.</span> <span class=nav-text>在自定义元素中嵌套自定义元素</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E2%80%9C%E5%B8%B8%E8%A7%84%E2%80%9D%E5%85%83%E7%B4%A0%E4%B8%8A%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7><span class=nav-number>2.6.2.6.2.</span> <span class=nav-text>“常规”元素上的自定义属性</span></a></ol></ol></ol></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>116</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>35</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>128</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://hshz21.gitee.io/2024/08/21/Spring%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="Spring系列-基础应用 | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>Spring系列-基础应用</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-06 15:33:47" datetime=2023-08-06T15:33:47+08:00 itemprop=dateModified>2023-08-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Spring/ itemprop=url rel=index><span itemprop=name>Spring</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、认识Spring><a class=headerlink href=#1、认识Spring title=1、认识Spring></a>1、认识Spring</h1><h2 id=1-1、前言><a class=headerlink href=#1-1、前言 title=1.1、前言></a>1.1、前言</h2><p>Spring框架为任何类型的部署平台上的基于Java的现代企业应用程序提供了全面的编程和配置模型。<p>Spring的一个关键元素是在应用程序级别的基础架构支持：Spring专注于企业应用程序的“管道”，以便团队可以专注于应用程序级别的业务逻辑，而不必与特定的部署环境建立不必要的联系。<h2 id=1-2、啥是Spring><a class=headerlink href=#1-2、啥是Spring title=1.2、啥是Spring></a>1.2、啥是Spring</h2><p>术语“春天”在不同的上下文中表示不同的事物。它可以用来指代Spring Framework项目本身，而这一切都是从这里开始的。随着时间的流逝，其他Spring项目已经在Spring Framework的基础上构建。通常，当人们说“春天”时，它们表示整个项目系列。<p>Spring框架分为多个模块。应用程序可以选择所需的模块。核心容器的模块是核心，包括配置模型和依赖项注入机制。除此之外，Spring框架还为不同的应用程序体系结构提供了基础支持，包括消息传递，事务性数据和持久性以及Web。它还包括基于Servlet的Spring MVC Web框架，以及并行的Spring WebFlux反应式Web框架。<p>Spring使创建Java企业应用程序变得容易。它提供了在企业环境中使用Java语言所需的一切，并支持Groovy和Kotlin作为JVM上的替代语言，并且可以根据应用程序的需求灵活地创建多种体系结构。从Spring Framework 5.1开始，Spring需要JDK 8+（Java SE 8+），并提供对JDK 11 LTS的现成支持。建议将Java SE 8更新60作为Java 8的最低修补程序版本，但通常建议使用最新的修补程序版本。<p>Spring是开源的。它拥有一个庞大而活跃的社区，可以根据各种实际用例提供持续的反馈。<h2 id=1-3、Spring模块><a class=headerlink href=#1-3、Spring模块 title=1.3、Spring模块></a>1.3、Spring模块</h2><ul><li><a href=https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html rel=noopener target=_blank>核心技术</a>：依赖项注入，事件，资源，i18n，验证，数据绑定，类型转换，SpEL，AOP。<li><a href=https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/testing.html rel=noopener target=_blank>测试</a>：模拟对象，TestContext框架，Spring MVC测试，<code>WebTestClient</code>。<li><a href=https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/data-access.html rel=noopener target=_blank>数据访问</a>：事务，DAO支持，JDBC，ORM，封送XML。<li><a href=https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html rel=noopener target=_blank>Spring MVC</a>和 <a href=https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html rel=noopener target=_blank>Spring WebFlux</a> Web框架。<li><a href=https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/integration.html rel=noopener target=_blank>集成</a>：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。<li><a href=https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/languages.html rel=noopener target=_blank>语言</a>：Kotlin，Groovy，动态语言。</ul><h2 id=1-4、支持版本><a class=headerlink href=#1-4、支持版本 title=1.4、支持版本></a>1.4、支持版本</h2><ul><li>5.3.x是第5代产品的最后一个功能分支，也是最新的生产线（截至2020年10月，GA），并将提供长期支持（在JDK 8，JDK 11和即将在2007年发布的JDK 17 LTS版本） 2021年9月）。<li>5.2.x是之前的生产线（GA截至2019年9月），将得到积极支持，直到2021年年底。<li>5.1.x和5.0.x不再受到积极支持，到2020年12月已由5.2.x和5.3.x取代。<li>4.3.x是第四代的最后一个功能分支。<em>4.3.x将于2020年12月31日达到其正式停产（报废）。</em><li><em>截至2016年12月31日，3.2.x属于产品停产（寿命终止）。该产品线中没有计划进一步的维护和安全补丁。</em></ul><p>此时，我们建议从Maven Central升级到最新的Spring Framework 5.3.x版本。<h2 id=1-5、JDK版本范围><a class=headerlink href=#1-5、JDK版本范围 title=1.5、JDK版本范围></a>1.5、JDK版本范围</h2><ul><li>Spring Framework 5.3.x：JDK 8-17（预期）<li>Spring Framework 5.2.x：JDK 8-15<li>Spring Framework 5.1.x：JDK 8-12<li>Spring Framework 5.0.x：JDK 8-10<li>Spring Framework 4.3.x：JDK 6-8</ul><p>我们全面测试并支持JDK的Spring on Long-Term Support（LTS）发行版，即当前的JDK 8和11（两者的有效期至2023年），并期望JDK 17（将于2021年末发布）。此外，它还对中间版本（例如JDK 9/10/12/13/14/15）和即将发布的JDK 16尽最大努力提供了支持，这意味着我们接受错误报告，并将尝试从技术上解决它们。可能，但不会提供任何服务水平保证。<p><em>请升级到支持JDK 11+的Spring Framework 5.1+（和相应的Spring Boot 2.1+），作为从JDK 8开始的常见长期支持迁移路径。JDK11上没有正式支持较早的Spring版本，尤其是不支持JDK 11字节码级别。请注意，第三方组件可能尚未完全支持JDK 11，因此您可能会受到全栈选项的限制。</em><h2 id=1-6、Spring历史><a class=headerlink href=#1-6、Spring历史 title=1.6、Spring历史></a>1.6、Spring历史</h2><p>响应于早期<a href=https://en.wikipedia.org/wiki/Java_Platform,_Enterprise_Edition rel=noopener target=_blank>J2EE</a>规范的复杂性，Spring于2003年应运而生 。尽管有些人认为Java EE和Spring竞争，但Spring实际上是Java EE的补充。Spring编程模型不包含Java EE平台规范。相反，它与J2EE中的各个规范集成在一起：<ul><li>Servlet API（<a href=https://jcp.org/en/jsr/detail?id=340 rel=noopener target=_blank>JSR 340</a>）<li>WebSocket API（<a href=https://www.jcp.org/en/jsr/detail?id=356 rel=noopener target=_blank>JSR 356</a>）<li>并发实用程序（<a href=https://www.jcp.org/en/jsr/detail?id=236 rel=noopener target=_blank>JSR 236</a>）<li>JSON绑定API（<a href=https://jcp.org/en/jsr/detail?id=367 rel=noopener target=_blank>JSR 367</a>）<li>Bean验证（<a href=https://jcp.org/en/jsr/detail?id=303 rel=noopener target=_blank>JSR 303</a>）<li>JPA（<a href=https://jcp.org/en/jsr/detail?id=338 rel=noopener target=_blank>JSR 338</a>）<li>JMS（<a href=https://jcp.org/en/jsr/detail?id=914 rel=noopener target=_blank>JSR 914</a>）<li>以及必要时用于事务协调的JTA / JCA设置。</ul><p>Spring框架还支持依赖注入（<a href=https://www.jcp.org/en/jsr/detail?id=330 rel=noopener target=_blank>JSR 330</a>）和通用注释（<a href=https://jcp.org/en/jsr/detail?id=250 rel=noopener target=_blank>JSR 250</a>）规范，应用程序开发人员可以选择使用这些规范来代替Spring框架提供的特定于Spring的机制。<h1 id=2、核心技术><a class=headerlink href=#2、核心技术 title=2、核心技术></a>2、核心技术</h1><h2 id=2-1、IOC容器><a class=headerlink href=#2-1、IOC容器 title=2.1、IOC容器></a>2.1、IOC容器</h2><h3 id=2-1-1、IOC容器和Bean简介><a class=headerlink href=#2-1-1、IOC容器和Bean简介 title=2.1.1、IOC容器和Bean简介></a>2.1.1、IOC容器和Bean简介</h3><p>IoC也称为依赖注入（DI）。在此过程中，对象仅通过构造函数参数，工厂方法的参数或在构造或从工厂方法返回后在对象实例上设置的属性来定义其依赖项（即，与它们一起使用的其他对象） 。然后，容器在创建bean时注入那些依赖项。此过程从根本上讲是通过使用类的直接构造或诸如服务定位器模式之类的控件来控制其依赖项的实例化或bean本身位置的逆过程（因此称为Control的倒置）。<p><code>org.springframework.beans</code>和<code>org.springframework.context</code>包是Spring框架的IoC容器的基础。该 <a href=https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/beans/factory/BeanFactory.html rel=noopener target=_blank><code>BeanFactory</code></a> 界面提供了一种高级配置机制，能够管理任何类型的对象。 <a href=https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/context/ApplicationContext.html rel=noopener target=_blank><code>ApplicationContext</code></a> 是<code>BeanFactory</code>的子接口。它增加了：<ul><li>与Spring的AOP功能轻松集成<li>消息资源处理（用于国际化）<li>活动发布<li>应用层特定的上下文，例如用于Web应用程序中的<code>WebApplicationContext</code> 。</ul><p>在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。Bean是由Spring IoC容器实例化，组装和管理的对象。否则，bean仅仅是应用程序中许多对象之一。Bean及其之间的依赖关系反映在容器使用的配置元数据中。<h3 id=2-1-2、IOC容器概述><a class=headerlink href=#2-1-2、IOC容器概述 title=2.1.2、IOC容器概述></a>2.1.2、IOC容器概述</h3><p><code>org.springframework.context.ApplicationContext</code>接口代表Spring IoC容器，并负责实例化，配置和组装Bean。<p>Spring提供了<code>ApplicationContext</code>接口的几种实现。在独立应用程序中，通常创建<code>ClassPathXmlApplicationContext</code> 或 <code>FileSystemXmlApplicationContext</code>的实例。尽管XML是定义配置元数据的传统格式，但是您可以通过提供少量XML配置来声明性地启用对这些其他元数据格式的支持，从而指示容器将Java注释或代码用作元数据格式。<p>下图显示了Spring的工作原理。<p><img alt=image-20210107190234847 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210107190234847.png><h4 id=2-1-2-1、配置元数据><a class=headerlink href=#2-1-2-1、配置元数据 title=2.1.2.1、配置元数据></a>2.1.2.1、配置元数据</h4><p>传统上，配置元数据以简单直观的XML实现。 基于XML的元数据不是配置元数据的唯一允许形式。如今，大多数选择基于Java的配置实现。<p>常见的配置元数据方式如下：<ul><li><p>基于注释的配置</p> <p>Spring 2.5 引入了对基于注解的配置元数据的支持。主要体现为：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>       <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>       <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>                           https://www.springframework.org/schema/beans/spring-beans.xsd"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"..."</span> <span class=attr>class</span>=<span class=string>"..."</span>></span>  </span><br><span class=line>        <span class=comment>&LT!-- collaborators and configuration for this bean go here --></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"..."</span> <span class=attr>class</span>=<span class=string>"..."</span>></span></span><br><span class=line>        <span class=comment>&LT!-- collaborators and configuration for this bean go here --></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- more bean definitions go here --></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure><li><p>基于Java的配置</p> <p>从Spring 3.0开始，其底层实现是基于Spring JavaConfig项目提供的许多功能成为Spring核心的一部分。因此，您可以使用 Java 而不是 XML 文件来定义应用程序类外部的 bean。要使用这些新功能，请参见<a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html rel=noopener target=_blank>@Configuration</a>，<a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html rel=noopener target=_blank>@Bean</a>，<a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html rel=noopener target=_blank>@Import</a>和<a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html rel=noopener target=_blank>@DependsOn</a>注解。</p></ul><h4 id=2-1-2-2、实例化容器><a class=headerlink href=#2-1-2-2、实例化容器 title=2.1.2.2、实例化容器></a>2.1.2.2、实例化容器</h4><p>提供给<code>ApplicationContext</code>构造函数的位置路径是资源字符串，这些资源字符串使容器可以从各种外部资源(例如本地文件系统，Java <code>CLASSPATH</code>等)加载配置元数据。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>ApplicationContext</span> <span class=variable>context</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class=string>"services.xml"</span>, <span class=string>"daos.xml"</span>);</span><br></pre></table></figure><p>services.xml 文件内容如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- services --></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"petStore"</span> <span class=attr>class</span>=<span class=string>"org.springframework.samples.jpetstore.services.PetStoreServiceImpl"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"accountDao"</span> <span class=attr>ref</span>=<span class=string>"accountDao"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"itemDao"</span> <span class=attr>ref</span>=<span class=string>"itemDao"</span>/></span></span><br><span class=line>        <span class=comment>&LT!-- additional collaborators and configuration for this bean go here --></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- more bean definitions for services go here --></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure><p>daos.xml 文件内容如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"accountDao"</span></span></span><br><span class=line><span class=tag>        <span class=attr>class</span>=<span class=string>"org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"</span>></span></span><br><span class=line>        <span class=comment>&LT!-- additional collaborators and configuration for this bean go here --></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"itemDao"</span> <span class=attr>class</span>=<span class=string>"org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"</span>></span></span><br><span class=line>        <span class=comment>&LT!-- additional collaborators and configuration for this bean go here --></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- more bean definitions for data access objects go here --></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure><h5 id=构成基于XML配置元数据><a class=headerlink href=#构成基于XML配置元数据 title=构成基于XML配置元数据></a>构成基于XML配置元数据</h5><p>使bean定义跨越多个XML文件可能很有用。通常，每个单独的XML配置文件都代表体系结构中的逻辑层或模块。<p>您可以使用应用程序上下文构造函数从所有这些 XML 片段中加载 bean 定义。该构造函数具有多个<code>Resource</code>位置，如<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-instantiation rel=noopener target=_blank>previous section</a>所示。或者，使用一个或多个<code>&LTimport/></code>元素从另一个文件中加载 bean 定义。以下示例显示了如何执行此操作：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>import</span> <span class=attr>resource</span>=<span class=string>"services.xml"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>import</span> <span class=attr>resource</span>=<span class=string>"resources/messageSource.xml"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>import</span> <span class=attr>resource</span>=<span class=string>"/resources/themeSource.xml"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"bean1"</span> <span class=attr>class</span>=<span class=string>"..."</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"bean2"</span> <span class=attr>class</span>=<span class=string>"..."</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure><p>在前面的示例中，从三个文件<code>services.xml</code>，<code>messageSource.xml</code>和<code>themeSource.xml</code>加载了外部 bean 定义。所有位置路径都相对于进行导入的定义文件，因此<code>services.xml</code>必须与进行导入的文件位于同一目录或 Classpath 位置，而<code>messageSource.xml</code>和<code>themeSource.xml</code>必须位于导入文件位置下方的<code>resources</code>位置。如您所见，斜杠被忽略。但是，鉴于这些路径是相对的，最好不要使用任何斜线。根据 Spring Schema，导入的文件的内容(包括顶级<code>&LTbeans/></code>元素)必须是有效的 XML bean 定义。<blockquote><p>可以但不建议使用相对的“ ../”路径引用父目录中的文件。这样做会创建对当前应用程序外部文件的依赖。特别是，不建议对<code>classpath:</code>URL（例如<code>classpath:../services.xml</code>）使用此引用，在URL中，运行时解析过程会选择“最近的”类路径根，然后查看其父目录。类路径配置的更改可能导致选择其他错误的目录。</blockquote><h5 id=Groovy-Bean-定义-DSL><a title="Groovy Bean 定义 DSL" class=headerlink href=#Groovy-Bean-定义-DSL></a>Groovy Bean 定义 DSL</h5><p>作为外部化配置元数据的另一个示例，Bean 定义也可以在 Spring 的 Groovy Bean 定义 DSL 中表达，如 Grails 框架所知。通常，这种配置位于“ .groovy”文件中，其结构如以下示例所示：<figure class="highlight groovy"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line>beans {</span><br><span class=line>    dataSource(BasicDataSource) {</span><br><span class=line>        driverClassName = <span class=string>"org.hsqldb.jdbcDriver"</span></span><br><span class=line>        url = <span class=string>"jdbc:hsqldb:mem:grailsDB"</span></span><br><span class=line>        username = <span class=string>"sa"</span></span><br><span class=line>        password = <span class=string>""</span></span><br><span class=line>        settings = [<span class=attr>mynew:</span><span class=string>"setting"</span>]</span><br><span class=line>    }</span><br><span class=line>    sessionFactory(SessionFactory) {</span><br><span class=line>        dataSource = dataSource</span><br><span class=line>    }</span><br><span class=line>    myService(MyService) {</span><br><span class=line>        nestedBean = { AnotherBean bean -></span><br><span class=line>            dataSource = dataSource</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>这种配置样式在很大程度上等同于XML bean定义，甚至支持Spring的XML配置名称空间。它还允许通过<code>importBeans</code>指令导入XML bean定义文件。<h4 id=2-1-2-3、使用容器><a class=headerlink href=#2-1-2-3、使用容器 title=2.1.2.3、使用容器></a>2.1.2.3、使用容器</h4><ul><li><p>基于 XML 使用容器</p> <p><code>ApplicationContext</code>是高级工厂的界面，该工厂能够维护不同 bean 及其依赖关系的注册表。通过使用方法<code>T getBean(String name, Class&LTT> requiredType)</code>，您可以检索 bean 的实例。</p> <p><code>ApplicationContext</code>允许您读取 bean 定义并访问它们，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// create and configure beans</span></span><br><span class=line><span class=type>ApplicationContext</span> <span class=variable>context</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class=string>"services.xml"</span>, <span class=string>"daos.xml"</span>);</span><br><span class=line><span class=comment>// retrieve configured instance</span></span><br><span class=line><span class=type>PetStoreService</span> <span class=variable>service</span> <span class=operator>=</span> context.getBean(<span class=string>"petStore"</span>, PetStoreService.class);</span><br><span class=line><span class=comment>// use configured instance</span></span><br><span class=line>List&LTString> userList = service.getUsernameList();</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>GenericApplicationContext</span> <span class=variable>context</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class=line><span class=keyword>new</span> <span class="title class_">XmlBeanDefinitionReader</span>(context).loadBeanDefinitions(<span class=string>"services.xml"</span>, <span class=string>"daos.xml"</span>);</span><br><span class=line>context.refresh();</span><br></pre></table></figure><li><p>基于 Groovy 使用容器</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>ApplicationContext</span> <span class=variable>context</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">GenericGroovyApplicationContext</span>(<span class=string>"services.groovy"</span>, <span class=string>"daos.groovy"</span>);</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>GenericApplicationContext</span> <span class=variable>context</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class=line><span class=keyword>new</span> <span class="title class_">GroovyBeanDefinitionReader</span>(context).loadBeanDefinitions(<span class=string>"services.groovy"</span>, <span class=string>"daos.groovy"</span>);</span><br><span class=line>context.refresh();</span><br></pre></table></figure></ul><h3 id=2-1-3、Bean总览><a class=headerlink href=#2-1-3、Bean总览 title=2.1.3、Bean总览></a>2.1.3、Bean总览</h3><p>Spring IoC容器管理一个或多个bean。在容器本身内，这些bean定义表示为<code>BeanDefinition</code> 对象，这些对象包含（除其他信息外）以下元数据：<ul><li>包限定的类名称：通常，定义了Bean的实际实现类。<li>Bean行为配置元素，用于声明Bean在容器中的行为（作用域，生命周期回调等）。<li>引用该bean完成其工作所需的其他bean。这些引用也称为协作者或依赖项。<li>要在新创建的对象中设置的其他配置设置-例如，池的大小限制或要在管理连接池的bean中使用的连接数。</ul><p>该元数据转换为构成每个bean定义的一组属性。下表描述了这些属性：<p><em>表 1. bean 定义</em><table><thead><tr><th>Property<th>Explained in…<tbody><tr><td>Class<td><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-class rel=noopener target=_blank>Instantiating Beans</a><tr><td>Name<td><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-beanname rel=noopener target=_blank>Naming Beans</a><tr><td>Scope<td><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes rel=noopener target=_blank>Bean Scopes</a><tr><td>Constructor arguments<td><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-collaborators rel=noopener target=_blank>Dependency Injection</a><tr><td>Properties<td><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-collaborators rel=noopener target=_blank>Dependency Injection</a><tr><td>Autowiring mode<td><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-autowire rel=noopener target=_blank>Autowiring Collaborators</a><tr><td>延迟初始化模式<td><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lazy-init rel=noopener target=_blank>Lazy-initialized Beans</a><tr><td>Initialization method<td><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean rel=noopener target=_blank>Initialization Callbacks</a><tr><td>Destruction method<td><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-disposablebean rel=noopener target=_blank>Destruction Callbacks</a></table><p>除了包含有关如何创建特定 bean 的信息的 bean 定义之外，<code>ApplicationContext</code>实现还允许注册在容器外部(由用户)创建的现有对象。这是通过<code>getBeanFactory()</code>方法访问 ApplicationContext 的 BeanFactory 来完成的，该方法返回 BeanFactory <code>DefaultListableBeanFactory</code>的实现。 <code>DefaultListableBeanFactory</code>通过<code>registerSingleton(..)</code>和<code>registerBeanDefinition(..)</code>方法支持此注册。但是，典型的应用程序只能与通过常规 bean 定义元数据定义的 bean 一起使用。<h4 id=2-1-3-1、命名Bean><a class=headerlink href=#2-1-3-1、命名Bean title=2.1.3.1、命名Bean></a>2.1.3.1、命名Bean</h4><h5 id=简介><a class=headerlink href=#简介 title=简介></a>简介</h5><p>每个 Bean 具有一个或多个标识符，这些标识符必须唯一。一个 bean 通常只有一个标识符。但是，如果需要多个，则可以将多余的别名视为别名。<p>在 XML 文件中，可以使用 id 和 name 属性指定标识符。id 属性代表bena的唯一性，通常 id 属性的名字构成可以是字母、数字，也可以使用特殊字符。如果要为 bean 设置别名，可以在 name 属性中设定，并用逗号、分号或空格隔开。<p>Spring 3.1 之前，id 属性被定义为一种 xsd:ID 类型，该类型限制了可能的字符。从 3.1 开始，它被定义为 xsd:string 类型。bena 的 id 属性仍然由容器强制执行。<p>如果不显式设定 id 和 name 属性，则容器会为该 bean 生成一个唯一的名称。但是，如果通过该名称获取该 bean，则必须通过使用 ref 元素或服务定位器样式来提供名称。<blockquote><p>Bean 命名约定：约定是在命名bean时将标准Java约定用于实例字段名称。也就是说，bean名称以小写字母开头，并从那里用驼峰式大小写。</blockquote><h5 id=基于XML起别名><a class=headerlink href=#基于XML起别名 title=基于XML起别名></a>基于XML起别名</h5><p>基于XML起别名的方式如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>alias</span> <span class=attr>name</span>=<span class=string>"myApp-dataSource"</span> <span class=attr>alias</span>=<span class=string>"subsystemA-dataSource"</span>/></span></span><br><span class=line><span class=tag><<span class=name>alias</span> <span class=attr>name</span>=<span class=string>"myApp-dataSource"</span> <span class=attr>alias</span>=<span class=string>"subsystemB-dataSource"</span>/></span></span><br></pre></table></figure><h5 id=基于注解起别名><a class=headerlink href=#基于注解起别名 title=基于注解起别名></a>基于注解起别名</h5><p>如果使用Java配置，则<code>@Bean</code>注释可用于提供别名。<h4 id=2-1-3-2、实例化-Bean><a title="2.1.3.2、实例化 Bean" class=headerlink href=#2-1-3-2、实例化-Bean></a>2.1.3.2、实例化 Bean</h4><h5 id=简介-1><a class=headerlink href=#简介-1 title=简介></a>简介</h5><p>Bean 定义实质上是创建一个或多个对象的方法。当被询问时，容器将查看命名 bean 的配方，并使用该 bean 定义封装的配置元数据来创建(或获取)实际对象。<p>如果使用基于 XML 的配置元数据，则可以在<code>&LTbean/></code>元素的<code>class</code>属性中指定要实例化的对象的类型(或类)。通常，此<code>class</code>属性(在内部是<code>BeanDefinition</code>实例上的<code>Class</code>属性)。可以通过以下两种方式之一使用<code>Class</code>属性：<ol><li>通常，在容器本身通过反射性地调用其构造函数直接创建 Bean 的情况下，指定要构造的 Bean 类，这在某种程度上等效于<code>new</code>运算符的 Java 代码。<li>要指定包含被调用以创建对象的<code>static</code>工厂方法的实际类，在不太常见的情况下，容器将在类上调用<code>static</code>工厂方法以创建 Bean。从<code>static</code>工厂方法的调用返回的对象类型可以是同一类，也可以是完全不同的另一类。</ol><blockquote><p>定义内部类：如果要为 静态内部类 配置Bean定义，则必须使用嵌套类的二进制名称。定义静态内部类方式如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>< bean id="" name="" class="com.example.SomeThing$OtherThing" /></span><br></pre></table></figure><p>请注意，名称中使用了<code>$</code>字符以将嵌套的类名与外部类名分开。</blockquote><h5 id=基于构造函数实例化><a class=headerlink href=#基于构造函数实例化 title=基于构造函数实例化></a>基于构造函数实例化</h5><p>当通过构造方法创建一个bean时，所有普通类都可以被Spring使用并兼容。也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。只需指定bean类就足够了。但是，根据您用于该特定bean的IoC的类型，您可能需要一个默认（空）构造函数。<p>Spring IoC 容器几乎可以 Management 您要 Management 的任何类。它不仅限于 Managementtrue 的 JavaBean。大多数 Spring 用户更喜欢实际的 JavaBean，它仅具有默认(无参数)构造函数，并具有根据容器中的属性建模的适当的 setter 和 getter。您还可以在容器中具有更多奇特的非 bean 样式类。<p>使用基于 XML 的配置元数据，您可以如下指定 bean 类：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"examples.ExampleBean"</span>/></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>name</span>=<span class=string>"anotherExample"</span> <span class=attr>class</span>=<span class=string>"examples.ExampleBeanTwo"</span>/></span></span><br></pre></table></figure><p>有关向构造函数提供参数(如果需要)并在构造对象之后设置对象实例属性的机制的详细信息，请参见<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-collaborators rel=noopener target=_blank>Injecting Dependencies</a>。<h5 id=基于静态工厂方法实例化><a class=headerlink href=#基于静态工厂方法实例化 title=基于静态工厂方法实例化></a>基于静态工厂方法实例化</h5><p>定义使用静态工厂方法创建的 bean 时，请使用<code>class</code>属性来指定包含<code>static</code>工厂方法的类，并使用名为<code>factory-method</code>的属性来指定工厂方法本身的名称。您应该能够调用此方法(带有可选参数，如稍后所述)并返回一个活动对象，该对象随后将被视为已通过构造函数创建。这种 bean 定义的一种用法是在旧代码中调用<code>static</code>工厂。<p>以下bean定义指定通过调用工厂方法来创建bean。该定义不指定返回对象的类型（类），而仅指定包含工厂方法的类。在此示例中，该<code>createInstance()</code> 方法必须是静态方法。以下示例显示如何指定工厂方法：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"clientService"</span> <span class=attr>class</span>=<span class=string>"examples.ClientService"</span> <span class=attr>factory-method</span>=<span class=string>"createInstance"</span>/></span></span><br></pre></table></figure><p>以下示例显示了可与前面的bean定义一起使用的类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ClientService</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>ClientService</span> <span class=variable>clientService</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClientService</span>();</span><br><span class=line>    <span class=keyword>private</span> <span class="title function_">ClientService</span><span class=params>()</span> {}</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> ClientService <span class="title function_">createInstance</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> clientService;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h5 id=基于实例工厂方法实例化><a class=headerlink href=#基于实例工厂方法实例化 title=基于实例工厂方法实例化></a>基于实例工厂方法实例化</h5><p>似于通过静态工厂方法进行实例化，使用实例工厂方法进行实例化会从容器中调用现有bean的非静态方法来创建新bean。要使用此机制，请将<code>class</code>属性留空，并在<code>factory-bean</code>属性中，在当前(或父容器或祖先容器)中指定包含要创建该对象的实例方法的 bean 的名称。使用<code>factory-method</code>属性设置工厂方法本身的名称。以下示例显示了如何配置此类 Bean：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"serviceLocator"</span> <span class=attr>class</span>=<span class=string>"examples.DefaultServiceLocator"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- inject any dependencies required by this locator bean --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"clientService"</span></span></span><br><span class=line><span class=tag>    <span class=attr>factory-bean</span>=<span class=string>"serviceLocator"</span></span></span><br><span class=line><span class=tag>    <span class=attr>factory-method</span>=<span class=string>"createClientServiceInstance"</span>/></span></span><br></pre></table></figure><p>相关的类如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DefaultServiceLocator</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>ClientService</span> <span class=variable>clientService</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class=line>    <span class=keyword>public</span> ClientService <span class="title function_">createClientServiceInstance</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> clientService;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>一个工厂类也可以包含一个以上的工厂方法，如以下示例所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"serviceLocator"</span> <span class=attr>class</span>=<span class=string>"examples.DefaultServiceLocator"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- inject any dependencies required by this locator bean --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"clientService"</span> <span class=attr>factory-bean</span>=<span class=string>"serviceLocator"</span> <span class=attr>factory-method</span>=<span class=string>"createClientServiceInstance"</span>/></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"accountService"</span> <span class=attr>factory-bean</span>=<span class=string>"serviceLocator"</span> <span class=attr>factory-method</span>=<span class=string>"createAccountServiceInstance"</span>/></span></span><br></pre></table></figure><p>相关类如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DefaultServiceLocator</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>ClientService</span> <span class=variable>clientService</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>AccountService</span> <span class=variable>accountService</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AccountServiceImpl</span>();</span><br><span class=line>    <span class=keyword>public</span> ClientService <span class="title function_">createClientServiceInstance</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> clientService;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> AccountService <span class="title function_">createAccountServiceInstance</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> accountService;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>这种方法表明，工厂Bean本身可以通过依赖项注入（DI）进行管理和配置。<h5 id=确定Bean的运行时类型><a class=headerlink href=#确定Bean的运行时类型 title=确定Bean的运行时类型></a>确定Bean的运行时类型</h5><p>找出特定bean的实际运行时类型的推荐方法是<code>BeanFactory.getType</code>调用指定的bean名称。并返回了<code>BeanFactory.getBean</code>针对相同bean名称的调用将要返回的对象的类型。<h3 id=2-1-4、Dependencies><a class=headerlink href=#2-1-4、Dependencies title=2.1.4、Dependencies></a>2.1.4、Dependencies</h3><h4 id=2-1-4-1、依赖注入><a class=headerlink href=#2-1-4-1、依赖注入 title=2.1.4.1、依赖注入></a>2.1.4.1、依赖注入</h4><p>依赖注入(DI)是一个过程，通过该过程，对象只能通过构造函数参数，工厂方法的参数或在构造或创建对象实例后在对象实例上设置的属性来定义其依赖关系(即，与它们一起工作的其他对象)。从工厂方法返回。然后，容器在创建 bean 时注入那些依赖项。从根本上讲，此过程是通过使用类的直接构造或服务定位器模式来自己控制其依赖关系的实例化或位置的 Bean 本身的逆过程(因此称为 Control Inversion)。<p>DI存在两个主要变体：基于构造函数的依赖注入和基于Setter的依赖注入。<h5 id=基于构造函数的依赖注入><a class=headerlink href=#基于构造函数的依赖注入 title=基于构造函数的依赖注入></a>基于构造函数的依赖注入</h5><p>基于构造函数的 DI 是通过容器调用具有多个参数(每个参数代表一个依赖项)的构造函数来完成的。调用带有特定参数的<code>static</code>工厂方法来构造 Bean 几乎是等效的。<p>以下示例显示了只能通过构造函数注入进行依赖项注入的类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">SimpleMovieLister</span><span class=params>(MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>注意，该类没有什么特别的。它是一个 POJO，不依赖于特定于容器的接口，Base Class 或 注解。<h6 id=构造函数参数解析><a class=headerlink href=#构造函数参数解析 title=构造函数参数解析></a>构造函数参数解析</h6><p>构造函数参数解析匹配通过使用参数的类型进行。如果Bean定义的构造函数参数中不存在潜在的歧义，则在实例化Bean时，在Bean定义中定义构造函数参数的顺序就是将这些参数提供给适当的构造函数的顺序。考虑以下情况：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> x.y;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ThingOne</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ThingOne</span><span class=params>(ThingTwo thingTwo, ThingThree thingThree)</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>假设<code>ThingTwo</code>和<code>ThingThree</code>类不是通过继承关联的，则不存在潜在的歧义。因此，以下配置可以正常工作，并且您无需在<code>&LTconstructor-arg/></code> 元素中显式指定构造函数参数索引或类型。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"beanOne"</span> <span class=attr>class</span>=<span class=string>"x.y.ThingOne"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>constructor-arg</span> <span class=attr>ref</span>=<span class=string>"beanTwo"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>constructor-arg</span> <span class=attr>ref</span>=<span class=string>"beanThree"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"beanTwo"</span> <span class=attr>class</span>=<span class=string>"x.y.ThingTwo"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"beanThree"</span> <span class=attr>class</span>=<span class=string>"x.y.ThingThree"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure><p>当引用另一个bean时，类型是已知的，并且可以发生匹配（与前面的示例一样）。当使用简单类型(例如<code>&LTvalue>true&LT/value></code>)时，Spring 无法确定值的类型，因此在没有帮助的情况下无法按类型进行匹配。考虑以下类别：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> examples;</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleBean</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> years;</span><br><span class=line>    <span class=keyword>private</span> String ultimateAnswer;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ExampleBean</span><span class=params>(<span class=type>int</span> years, String ultimateAnswer)</span> {</span><br><span class=line>        <span class=built_in>this</span>.years = years;</span><br><span class=line>        <span class=built_in>this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><ul><li><p>构造函数参数类型匹配</p> <p>在上述情况下，如果通过使用<code>type</code>属性显式指定构造函数参数的类型，则容器可以使用简单类型的类型匹配。如下例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"examples.ExampleBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>type</span>=<span class=string>"int"</span> <span class=attr>value</span>=<span class=string>"7500000"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>type</span>=<span class=string>"java.lang.String"</span> <span class=attr>value</span>=<span class=string>"42"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure><li><p>构造函数参数索引</p> <p>您可以使用该<code>index</code>属性来明确指定构造函数参数的索引，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"examples.ExampleBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>index</span>=<span class=string>"0"</span> <span class=attr>value</span>=<span class=string>"7500000"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>index</span>=<span class=string>"1"</span> <span class=attr>value</span>=<span class=string>"42"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>除了解决多个简单值的歧义性之外，指定索引还可以解决歧义，其中构造函数具有两个相同类型的参数。</p><li><p>构造函数参数名称</p> <p>您还可以使用构造函数参数名称来消除歧义，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"examples.ExampleBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>name</span>=<span class=string>"years"</span> <span class=attr>value</span>=<span class=string>"7500000"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>name</span>=<span class=string>"ultimateAnswer"</span> <span class=attr>value</span>=<span class=string>"42"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>请记住，要立即使用该功能，必须在启用调试标志的情况下编译代码，以便 Spring 可以从构造函数中查找参数名称。如果您不能或不想使用 debug 标志编译代码，则可以使用<a href=https://download.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html rel=noopener target=_blank>@ConstructorProperties</a> JDK注解 显式命名构造函数参数。然后，该示例类必须如下所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> examples;</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleBean</span> {</span><br><span class=line>    <span class=meta>@ConstructorProperties({"years", "ultimateAnswer"})</span></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ExampleBean</span><span class=params>(<span class=type>int</span> years, String ultimateAnswer)</span> {</span><br><span class=line>        <span class=built_in>this</span>.years = years;</span><br><span class=line>        <span class=built_in>this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure></ul><h5 id=基于Setter的依赖注入><a class=headerlink href=#基于Setter的依赖注入 title=基于Setter的依赖注入></a>基于Setter的依赖注入</h5><p>基于Setter的DI是通过在调用无参数构造函数或无参数<code>static</code>工厂方法以实例化您的bean之后，在您的bean上调用setter方法来完成的。<p>下面的示例显示只能通过Setter来注入的一种情况。此类是常规的 Java。它是一个 POJO，不依赖于容器特定的接口，Base Class 或 注解。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>//...</span></span><br><span class=line>}</span><br></pre></table></figure><p><code>ApplicationContext</code>支持其 Management 的 bean 的基于构造函数和基于 setter 的 DI。在已经通过构造函数方法注入了某些依赖项之后，它还支持基于 setter 的 DI。您可以以<code>BeanDefinition</code>的形式配置依赖项，并与<code>PropertyEditor</code>实例结合使用以将属性从一种格式转换为另一种格式。但是，大多数 Spring 用户不是直接(即以编程方式)使用这些类，而是使用 XML <code>bean</code>定义，带注解的组件(即以<code>@Component</code>，<code>@Controller</code>等进行注解的类)或基于 Java 的<code>@Bean</code>方法。 <code>@Configuration</code>个类。然后将这些源在内部转换为<code>BeanDefinition</code>的实例，并用于加载整个 Spring IoC 容器实例。<blockquote><p>两种注入方式该如何选择呢？<p>由于可以混合使用基于构造函数的DI和基于设定值的DI，因此将构造函数用于强制性依赖项并将setter方法或配置方法用于可选的依赖项是一个很好的经验法则。注意， 在setter方法上使用<code>@Required</code>批注可以使该属性成为必需的依赖项。但是，最好使用带有参数的程序验证的构造函数注入。<p>Spring团队通常提倡使用构造函数注入，因为它可以让您将应用程序组件实现为不可变对象，并确保不存在必需的依赖项<code>null</code>。此外，注入构造函数的组件始终以完全初始化的状态返回到客户端（调用）代码。附带说明一下，大量的构造函数自变量是一种不好的代码味，这表明该类可能承担了太多的职责，应该对其进行重构以更好地解决关注点分离问题。<p>Setter注入主要应仅用于可以在类中分配合理的默认值的可选依赖项。否则，必须在代码使用依赖项的任何地方执行非空检查。setter注入的一个好处是，setter方法使该类的对象在以后可以重新配置或重新注入。因此，通过<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#jmx rel=noopener target=_blank>JMX MBean进行</a>管理是用于setter注入的引人注目的用例。</blockquote><h5 id=依赖性解析过程><a class=headerlink href=#依赖性解析过程 title=依赖性解析过程></a>依赖性解析过程</h5><p>容器执行bean依赖项解析，如下所示：<ul><li><code>ApplicationContext</code>使用描述所有bean的配置元数据创建和初始化。可以通过XML，Java代码或注释指定配置元数据。<li>对于每个bean，其依赖关系都以属性，构造函数参数或static-factory方法的参数的形式表示（如果使用它而不是普通的构造函数）。实际创建Bean时，会将这些依赖项提供给Bean。<li>每个属性或构造函数参数都是要设置的值的实际定义，或者是对容器中另一个bean的引用。<li>作为值的每个属性或构造函数参数都将从其指定的格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring能够以String类型提供值转换成所有内置类型，比如<code>int</code>， <code>long</code>，<code>String</code>，<code>boolean</code>，等等。</ul><p>在创建容器时，Spring容器会验证每个bean的配置。但是，在实际创建Bean之前，不会设置Bean属性本身。创建容器时，将创建具有单例作用域并设置为预先实例化（默认）的Bean。范围在<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes rel=noopener target=_blank>Bean范围</a>中定义。否则，仅在请求时才创建Bean。创建和分配bean的依赖关系及其依赖关系（依此类推）时，创建bean可能会导致创建一个bean图。请注意，这些依赖项之间的分辨率不匹配可能会显示得较晚-即在第一次创建受影响的bean时。<blockquote><p>循环依赖问题<p>如果主要使用构造函数注入，则可能会创建无法解决的循环依赖方案。<p>例如：A类通过构造函数注入需要B类的实例，而B类通过构造函数注入需要A类的实例。如果您将A类和B类的bean配置为相互注入，则Spring IoC容器会在运行时检测到此循环引用，并抛出 <code>BeanCurrentlyInCreationException</code>。<p>一种可能的解决方案是编辑某些类的源代码，这些类的源代码由设置者而不是构造函数来配置。或者，避免构造函数注入，而仅使用setter注入。换句话说，尽管不建议这样做，但是您可以使用setter注入配置循环依赖项。<p>典型情况（没有循环依赖关系）不同，Bean A和Bean B之间的循环依赖关系迫使其中一个Bean在完全完全初始化之前被注入另一个Bean（经典的“鸡与蛋”场景）。</blockquote><p>如果不存在循环依赖关系，则在将一个或多个协作Bean注入到从属Bean中时，每个协作Bean都将被完全配置，然后再注入到从属Bean中。这意味着，如果bean A依赖于bean B，则Spring IoC容器会在对bean A调用setter方法之前完全配置beanB。换句话说，bean被实例化（如果不是预先实例化的singleton）。 ），设置其依赖项，并调用相关的生命周期方法（例如已[配置的 init 方法或 InitializingBean 回调方法）。<h5 id=依赖注入示例><a class=headerlink href=#依赖注入示例 title=依赖注入示例></a>依赖注入示例</h5><h6 id=基于XML的Setter注入><a class=headerlink href=#基于XML的Setter注入 title=基于XML的Setter注入></a>基于XML的Setter注入</h6><p>以下示例基于XML来实现 Setter注入。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"examples.ExampleBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"beanOne"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>ref</span> <span class=attr>bean</span>=<span class=string>"anotherExampleBean"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"beanTwo"</span> <span class=attr>ref</span>=<span class=string>"yetAnotherBean"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"integerProperty"</span> <span class=attr>value</span>=<span class=string>"1"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"anotherExampleBean"</span> <span class=attr>class</span>=<span class=string>"examples.AnotherBean"</span>/></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"yetAnotherBean"</span> <span class=attr>class</span>=<span class=string>"examples.YetAnotherBean"</span>/></span></span><br></pre></table></figure><p>类ExampleBean如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleBean</span> {</span><br><span class=line>    <span class=keyword>private</span> AnotherBean beanOne;</span><br><span class=line>    <span class=keyword>private</span> YetAnotherBean beanTwo;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> i;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setBeanOne</span><span class=params>(AnotherBean beanOne)</span> {</span><br><span class=line>        <span class=built_in>this</span>.beanOne = beanOne;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setBeanTwo</span><span class=params>(YetAnotherBean beanTwo)</span> {</span><br><span class=line>        <span class=built_in>this</span>.beanTwo = beanTwo;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setIntegerProperty</span><span class=params>(<span class=type>int</span> i)</span> {</span><br><span class=line>        <span class=built_in>this</span>.i = i;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h6 id=基于XML的构造注入><a class=headerlink href=#基于XML的构造注入 title=基于XML的构造注入></a>基于XML的构造注入</h6><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"examples.ExampleBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span>></span></span><br><span class=line>        <span class=tag><<span class=name>ref</span> <span class=attr>bean</span>=<span class=string>"anotherExampleBean"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>constructor-arg</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>ref</span>=<span class=string>"yetAnotherBean"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>type</span>=<span class=string>"int"</span> <span class=attr>value</span>=<span class=string>"1"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"anotherExampleBean"</span> <span class=attr>class</span>=<span class=string>"examples.AnotherBean"</span>/></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"yetAnotherBean"</span> <span class=attr>class</span>=<span class=string>"examples.YetAnotherBean"</span>/></span></span><br></pre></table></figure><p>类 ExampleBean 如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleBean</span> {</span><br><span class=line>    <span class=keyword>private</span> AnotherBean beanOne;</span><br><span class=line>    <span class=keyword>private</span> YetAnotherBean beanTwo;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> i;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ExampleBean</span><span class=params>(</span></span><br><span class=line><span class=params>        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class=type>int</span> i)</span> {</span><br><span class=line>        <span class=built_in>this</span>.beanOne = anotherBean;</span><br><span class=line>        <span class=built_in>this</span>.beanTwo = yetAnotherBean;</span><br><span class=line>        <span class=built_in>this</span>.i = i;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>现在考虑该示例的一个变体，在该变体中，不是使用构造函数，而是告诉Spring调用<code>static</code>工厂方法以返回对象的实例：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"examples.ExampleBean"</span> <span class=attr>factory-method</span>=<span class=string>"createInstance"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>ref</span>=<span class=string>"anotherExampleBean"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>ref</span>=<span class=string>"yetAnotherBean"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>value</span>=<span class=string>"1"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"anotherExampleBean"</span> <span class=attr>class</span>=<span class=string>"examples.AnotherBean"</span>/></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"yetAnotherBean"</span> <span class=attr>class</span>=<span class=string>"examples.YetAnotherBean"</span>/></span></span><br></pre></table></figure><p>以下示例显示了相应的<code>ExampleBean</code>类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleBean</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class="title function_">ExampleBean</span><span class=params>(...)</span> {</span><br><span class=line>        <span class=comment>//...</span></span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> ExampleBean <span class="title function_">createInstance</span> <span class=params>(</span></span><br><span class=line><span class=params>        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class=type>int</span> i)</span> {</span><br><span class=line>        <span class=type>ExampleBean</span> <span class=variable>eb</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ExampleBean</span> (...);</span><br><span class=line>        <span class=comment>//...</span></span><br><span class=line>        <span class=keyword>return</span> eb;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><code>static</code>工厂方法的参数由<code>&LTconstructor-arg/></code>元素提供，与实际使用构造函数的情况完全相同。 factory 方法返回的类的类型不必与包含<code>static</code> factory 方法的类的类型相同(尽管在此示例中为)。实例(非静态)工厂方法可以以基本上相同的方式使用(除了使用<code>factory-bean</code>属性而不是<code>class</code>属性)，因此在此不讨论这些细节。<h4 id=2-1-4-2、依赖性和详细配置><a class=headerlink href=#2-1-4-2、依赖性和详细配置 title=2.1.4.2、依赖性和详细配置></a>2.1.4.2、依赖性和详细配置</h4><h5 id=straight-values（原语、字符串等）><a title="straight values（原语、字符串等）" class=headerlink href=#straight-values（原语、字符串等）></a>straight values（原语、字符串等）</h5><p><code>&LTproperty/></code>元素的<code>value</code>属性将属性或构造函数参数指定为人类可读的字符串表示形式。 Spring 的<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#core-convert-ConversionService-API rel=noopener target=_blank>conversion service</a>用于将这些值从<code>String</code>转换为属性或参数的实际类型。以下示例显示了设置的各种值：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"myDataSource"</span> <span class=attr>class</span>=<span class=string>"org.apache.commons.dbcp.BasicDataSource"</span> <span class=attr>destroy-method</span>=<span class=string>"close"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"driverClassName"</span> <span class=attr>value</span>=<span class=string>"com.mysql.jdbc.Driver"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"url"</span> <span class=attr>value</span>=<span class=string>"jdbc:mysql://localhost:3306/mydb"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"username"</span> <span class=attr>value</span>=<span class=string>"root"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"password"</span> <span class=attr>value</span>=<span class=string>"misterkaoli"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure><p>以下示例使用<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-p-namespace rel=noopener target=_blank>p-namespace</a>进行更简洁的XML配置：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:p</span>=<span class=string>"http://www.springframework.org/schema/p"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>    https://www.springframework.org/schema/beans/spring-beans.xsd"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"myDataSource"</span> <span class=attr>class</span>=<span class=string>"org.apache.commons.dbcp.BasicDataSource"</span></span></span><br><span class=line><span class=tag>        <span class=attr>destroy-method</span>=<span class=string>"close"</span></span></span><br><span class=line><span class=tag>        <span class=attr>p:driverClassName</span>=<span class=string>"com.mysql.jdbc.Driver"</span></span></span><br><span class=line><span class=tag>        <span class=attr>p:url</span>=<span class=string>"jdbc:mysql://localhost:3306/mydb"</span></span></span><br><span class=line><span class=tag>        <span class=attr>p:username</span>=<span class=string>"root"</span></span></span><br><span class=line><span class=tag>        <span class=attr>p:password</span>=<span class=string>"misterkaoli"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure><p>前面的XML更简洁。但是，除非在创建bean定义时使用支持自动属性完成的IDE，否则错误是在运行时而不是设计时发现的。<p>您还可以配置<code>java.util.Properties</code>实例，如下所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"mappings"</span> <span class=attr>class</span>=<span class=string>"org.springframework.context.support.PropertySourcesPlaceholderConfigurer"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"properties"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>value</span>></span></span><br><span class=line>            jdbc.driver.className=com.mysql.jdbc.Driver</span><br><span class=line>            jdbc.url=jdbc:mysql://localhost:3306/mydb</span><br><span class=line>        <span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure><p>Spring 容器使用 JavaBeans <code>PropertyEditor</code>机制将<code>&LTvalue/></code>元素内的文本转换为<code>java.util.Properties</code>实例。这是一个不错的捷径，并且是 Spring 团队偏爱使用嵌套<code>&LTvalue/></code>元素而不是<code>value</code>属性样式的几个地方之一。<ul><li><p>idref元素</p> <p><code>idref</code>元素只是将容器中另一个 bean 的<code>id</code>(字符串值-不是引用)传递给<code>&LTconstructor-arg/></code>或<code>&LTproperty/></code>元素的一种防错方法。以下示例显示了如何使用它：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"theTargetBean"</span> <span class=attr>class</span>=<span class=string>"..."</span>/></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"theClientBean"</span> <span class=attr>class</span>=<span class=string>"..."</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"targetName"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>idref</span> <span class=attr>bean</span>=<span class=string>"theTargetBean"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure></ul><p>前面的bean定义片段（在运行时）与下面的片段完全等效：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"theTargetBean"</span> <span class=attr>class</span>=<span class=string>"..."</span> /></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"client"</span> <span class=attr>class</span>=<span class=string>"..."</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"targetName"</span> <span class=attr>value</span>=<span class=string>"theTargetBean"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure><p>第一种形式优于第二种形式，因为使用<code>idref</code>标签可以使容器在部署时验证所引用的命名 Bean 实际上是否存在。在第二个变体中，不对传递给<code>client</code> bean 的<code>targetName</code>属性的值执行验证。仅在实际实例化<code>client</code> bean 时才发现拼写错误(极有可能导致致命的结果)。如果<code>client</code> bean 是<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes rel=noopener target=_blank>prototype</a> bean，则只能在部署容器很长时间之后发现此错字和所产生的异常。<h5 id=对其他Bean的引用（协作者）><a class=headerlink href=#对其他Bean的引用（协作者） title=对其他Bean的引用（协作者）></a>对其他Bean的引用（协作者）</h5><p>通过<code>&LTref/></code>标签的<code>bean</code>属性指定目标 bean 是最通用的形式，并且允许创建对同一容器或父容器中任何 bean 的引用，而不管它是否在同一 XML 文件中。 <code>bean</code>属性的值可以与目标 Bean 的<code>id</code>属性相同，也可以与目标 Bean 的<code>name</code>属性中的值之一相同。下面的示例演示如何使用<code>ref</code>元素：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>ref</span> <span class=attr>bean</span>=<span class=string>"someBean"</span>/></span></span><br></pre></table></figure><p>通过<code>parent</code>属性指定目标 bean 将创建对当前容器的父容器中的 bean 的引用。 <code>parent</code>属性的值可以与目标 Bean 的<code>id</code>属性或目标 Bean 的<code>name</code>属性中的值相同。目标 Bean 必须位于当前容器的父容器中。主要在具有容器层次结构并且要使用与父 bean 名称相同的代理将现有 bean 封装在父容器中时，才应使用此 bean 参考变量。以下一对清单显示了如何使用<code>parent</code>属性：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- in the parent context --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"accountService"</span> <span class=attr>class</span>=<span class=string>"com.something.SimpleAccountService"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- insert dependencies as required as here --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- in the child (descendant) context --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"accountService"</span> &LT!<span class=attr>--</span> <span class=attr>bean</span> <span class=attr>name</span> <span class=attr>is</span> <span class=attr>the</span> <span class=attr>same</span> <span class=attr>as</span> <span class=attr>the</span> <span class=attr>parent</span> <span class=attr>bean</span> <span class=attr>--</span>></span></span><br><span class=line>    class="org.springframework.aop.framework.ProxyFactoryBean"></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"target"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>ref</span> <span class=attr>parent</span>=<span class=string>"accountService"</span>/></span> </span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure><blockquote><p><code>ref</code>元素上的<code>local</code>属性在 4.0 bean XSD 中不再受支持，因为它不再提供常规<code>bean</code>引用上的值。升级到 4.0 模式时，将现有的<code>ref local</code>引用更改为<code>ref bean</code>。</blockquote><h5 id=内部Bean><a class=headerlink href=#内部Bean title=内部Bean></a>内部Bean</h5><p><code>&LTproperty/></code>或<code>&LTconstructor-arg/></code>元素内的<code>&LTbean/></code>元素定义了一个内部 bean，如以下示例所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"outer"</span> <span class=attr>class</span>=<span class=string>"..."</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"target"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"com.example.Person"</span>></span> <span class=comment>&LT!-- this is the inner bean --></span></span><br><span class=line>            <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"Fiona Apple"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"age"</span> <span class=attr>value</span>=<span class=string>"25"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure><p>内部 bean 定义不需要定义的 ID 或名称。如果指定，则容器不使用该值作为标识符。容器在创建时也将忽略<code>scope</code>标志，因为内部 Bean 始终是匿名的，并且始终与外部 Bean 一起创建。不可能独立地访问内部 bean 或将其注入到协作 bean 中而不是封装到封闭 bean 中。<h5 id=集合><a class=headerlink href=#集合 title=集合></a>集合</h5><p><code>&LTlist/></code>，<code>&LTset/></code>，<code>&LTmap/></code>和<code>&LTprops/></code>元素分别设置 Java <code>Collection</code>类型<code>List</code>，<code>Set</code>，<code>Map</code>和<code>Properties</code>的属性和参数。以下示例显示了如何使用它们：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"moreComplexObject"</span> <span class=attr>class</span>=<span class=string>"example.ComplexObject"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- results in a setAdminEmails(java.util.Properties) call --></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"adminEmails"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>props</span>></span></span><br><span class=line>            <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"administrator"</span>></span>administrator@example.org<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>            <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"support"</span>></span>support@example.org<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>            <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"development"</span>></span>development@example.org<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>props</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=comment>&LT!-- results in a setSomeList(java.util.List) call --></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"someList"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>list</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>a list element followed by a reference<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>ref</span> <span class=attr>bean</span>=<span class=string>"myDataSource"</span> /></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>list</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=comment>&LT!-- results in a setSomeMap(java.util.Map) call --></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"someMap"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>map</span>></span></span><br><span class=line>            <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"an entry"</span> <span class=attr>value</span>=<span class=string>"just some string"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>entry</span> <span class=attr>key</span> =<span class=string>"a ref"</span> <span class=attr>value-ref</span>=<span class=string>"myDataSource"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>map</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=comment>&LT!-- results in a setSomeSet(java.util.Set) call --></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"someSet"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>set</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>just some string<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>ref</span> <span class=attr>bean</span>=<span class=string>"myDataSource"</span> /></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>set</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure><p>Map 键或值的值或设置值也可以是以下任意元素：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>bean | ref | idref | list | set | map | props | value | null</span><br></pre></table></figure><h6 id=集合合并><a class=headerlink href=#集合合并 title=集合合并></a>集合合并</h6><p>Spring 容器还支持合并集合。应用程序开发人员可以定义父级<list>，<map>，<set>或<props>元素，并使子级<list>，<map>，<set>或<props>元素继承并覆盖父级集合中的值。也就是说，子集合的值是合并父集合和子集合的元素的结果，子集合的元素将覆盖父集合中指定的值。 <p>下面的示例演示了集合合并：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"parent"</span> <span class=attr>abstract</span>=<span class=string>"true"</span> <span class=attr>class</span>=<span class=string>"example.ComplexObject"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"adminEmails"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>props</span>></span></span><br><span class=line>                <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"administrator"</span>></span>administrator@example.com<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>                <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"support"</span>></span>support@example.com<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>props</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"child"</span> <span class=attr>parent</span>=<span class=string>"parent"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"adminEmails"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>props</span> <span class=attr>merge</span>=<span class=string>"true"</span>></span></span><br><span class=line>                <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"sales"</span>></span>sales@example.com<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>                <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"support"</span>></span>support@example.co.uk<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>props</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag><<span class=name>beans</span>></span></span><br></pre></table></figure> <h6 id=集合合并的局限><a class=headerlink href=#集合合并的局限 title=集合合并的局限></a>集合合并的局限</h6><p>您不能合并不同的集合类型(例如<code>Map</code>和<code>List</code>)。如果尝试这样做，则会抛出一个适当的<code>Exception</code>。 <code>merge</code>属性必须在较低的继承的子定义中指定。在父集合定义上指定<code>merge</code>属性是多余的，不会导致所需的合并。</p> <h6 id=强类型集合><a class=headerlink href=#强类型集合 title=强类型集合></a>强类型集合</h6><p>随着 Java 5 中泛型类型的引入，您可以使用强类型集合。也就是说，可以声明<code>Collection</code>类型，使其只能包含(例如)<code>String</code>元素。如果使用 Spring 将强类型的<code>Collection</code>依赖项注入到 bean 中，则可以利用 Spring 的类型转换支持，以便将强类型<code>Collection</code>实例的元素转换为适当的类型，然后再添加到<code>Collection</code>。以下 Java 类和 bean 定义显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SomeClass</span> {</span><br><span class=line>    <span class=keyword>private</span> Map&LTString, Float> accounts;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setAccounts</span><span class=params>(Map&LTString, Float> accounts)</span> {</span><br><span class=line>        <span class=built_in>this</span>.accounts = accounts;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"something"</span> <span class=attr>class</span>=<span class=string>"x.y.SomeClass"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"accounts"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>map</span>></span></span><br><span class=line>                <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"one"</span> <span class=attr>value</span>=<span class=string>"9.99"</span>/></span></span><br><span class=line>                <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"two"</span> <span class=attr>value</span>=<span class=string>"2.75"</span>/></span></span><br><span class=line>                <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"six"</span> <span class=attr>value</span>=<span class=string>"3.99"</span>/></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>map</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>当准备注入<code>something</code> bean 的<code>accounts</code>属性时，可以通过反射获得有关强类型<code>Map&LTString, Float></code>的元素类型的泛型信息。因此，Spring 的类型转换基础结构将各种值元素识别为<code>Float</code>类型，并且字符串值(<code>9.99, 2.75</code>和<code>3.99</code>)被转换为实际的<code>Float</code>类型。</p> <h5 id=空字符串值和空字符串><a class=headerlink href=#空字符串值和空字符串 title=空字符串值和空字符串></a>空字符串值和空字符串</h5><p>Spring将属性等的空参数视为空 <code>Strings</code>。以下基于XML的配置元数据片段将<code>email</code>属性设置为空 <code>String</code>值（“”）。</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"ExampleBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"email"</span> <span class=attr>value</span>=<span class=string>""</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>前面的示例等效于以下Java代码：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>exampleBean.setEmail(<span class=string>""</span>);</span><br></pre></table></figure> <p><code>&LTnull/></code>元素处理<code>null</code>的值。以下清单显示了一个示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"ExampleBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"email"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>null</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>前面的配置等效于下面的Java代码：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>exampleBean.setEmail(<span class=literal>null</span>);</span><br></pre></table></figure> <h5 id=具有P-命名空间的XML快捷方式><a class=headerlink href=#具有P-命名空间的XML快捷方式 title=具有P-命名空间的XML快捷方式></a>具有P-命名空间的XML快捷方式</h5><p>p-namespace 允许您使用<code>bean</code>元素的属性(而不是嵌套的<code>&LTproperty/></code>元素)来描述协作 Bean 的属性值，或同时使用这两者。</p> <p>Spring 支持基于 XML Schema 定义的可扩展配置格式<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-schemas rel=noopener target=_blank>with namespaces</a>。</p> <p>以下示例显示了两个XML代码段（第一个使用标准XML格式，第二个使用p-命名空间），它们可以解析为相同的结果：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:p</span>=<span class=string>"http://www.springframework.org/schema/p"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>name</span>=<span class=string>"classic"</span> <span class=attr>class</span>=<span class=string>"com.example.ExampleBean"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"email"</span> <span class=attr>value</span>=<span class=string>"someone@somewhere.com"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>name</span>=<span class=string>"p-namespace"</span> <span class=attr>class</span>=<span class=string>"com.example.ExampleBean"</span></span></span><br><span class=line><span class=tag>        <span class=attr>p:email</span>=<span class=string>"someone@somewhere.com"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>该示例显示了 p 命名空间中 Bean 定义中名为<code>email</code>的属性。这告诉 Spring 包含一个属性声明。如前所述，p 名称空间没有架构定义，因此可以将属性名称设置为属性名称。</p> <p>下一个示例包括另外两个bean定义，它们都引用了另一个bean：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:p</span>=<span class=string>"http://www.springframework.org/schema/p"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>name</span>=<span class=string>"john-classic"</span> <span class=attr>class</span>=<span class=string>"com.example.Person"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"John Doe"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"spouse"</span> <span class=attr>ref</span>=<span class=string>"jane"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>name</span>=<span class=string>"john-modern"</span> <span class=attr>class</span>=<span class=string>"com.example.Person"</span></span></span><br><span class=line><span class=tag>          <span class=attr>p:name</span>=<span class=string>"John Doe"</span></span></span><br><span class=line><span class=tag>          <span class=attr>p:spouse-ref</span>=<span class=string>"jane"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>name</span>=<span class=string>"jane"</span> <span class=attr>class</span>=<span class=string>"com.example.Person"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"Jane Doe"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>此示例不仅包括使用 p-namespace 的属性值，还使用特殊格式声明属性引用。第一个 bean 定义使用<code>&LTproperty name="spouse" ref="jane"/></code>创建从 bean <code>john</code>到 Bean <code>jane</code>的引用，而第二个 bean 定义使用<code>p:spouse-ref="jane"</code>作为属性来执行完全相同的操作。在这种情况下，<code>spouse</code>是属性名称，而<code>-ref</code>部分表示这不是一个直接值，而是对另一个 bean 的引用。</p> <h5 id=具有C-命名空间的XML快捷方式><a class=headerlink href=#具有C-命名空间的XML快捷方式 title=具有C-命名空间的XML快捷方式></a>具有C-命名空间的XML快捷方式</h5><p>在Spring 3.1中引入的c-namespace允许使用内联属性来配置构造函数参数，而不是嵌套<code>constructor-arg</code>元素。</p> <p>下面的示例使用<code>c:</code>名称空间执行与 基于构造函数的依赖注入相同的操作：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:c</span>=<span class=string>"http://www.springframework.org/schema/c"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"beanTwo"</span> <span class=attr>class</span>=<span class=string>"x.y.ThingTwo"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"beanThree"</span> <span class=attr>class</span>=<span class=string>"x.y.ThingThree"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- traditional declaration with optional argument names --></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"beanOne"</span> <span class=attr>class</span>=<span class=string>"x.y.ThingOne"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>constructor-arg</span> <span class=attr>name</span>=<span class=string>"thingTwo"</span> <span class=attr>ref</span>=<span class=string>"beanTwo"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>constructor-arg</span> <span class=attr>name</span>=<span class=string>"thingThree"</span> <span class=attr>ref</span>=<span class=string>"beanThree"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>constructor-arg</span> <span class=attr>name</span>=<span class=string>"email"</span> <span class=attr>value</span>=<span class=string>"something@somewhere.com"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- c-namespace declaration with argument names --></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"beanOne"</span> <span class=attr>class</span>=<span class=string>"x.y.ThingOne"</span> <span class=attr>c:thingTwo-ref</span>=<span class=string>"beanTwo"</span></span></span><br><span class=line><span class=tag>        <span class=attr>c:thingThree-ref</span>=<span class=string>"beanThree"</span> <span class=attr>c:email</span>=<span class=string>"something@somewhere.com"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p><code>c:</code>名称空间使用与<code>p:</code>相同的约定(对于 Bean 引用，尾随<code>-ref</code>)以其名称设置构造函数参数。同样，即使未在 XSD 模式中定义它(也存在于 Spring 内核中)也需要声明它。</p> <p>对于极少数情况下无法使用构造函数自变量名称的情况(通常，如果字节码是在没有调试信息的情况下编译的)，可以对参数索引使用后备，如下所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- c-namespace index declaration --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"beanOne"</span> <span class=attr>class</span>=<span class=string>"x.y.ThingOne"</span> <span class=attr>c:_0-ref</span>=<span class=string>"beanTwo"</span> <span class=attr>c:_1-ref</span>=<span class=string>"beanThree"</span> <span class=attr>c:_2</span>=<span class=string>"something@somewhere.com"</span>/></span></span><br></pre></table></figure> <blockquote><p>由于XML语法的原因，索引表示法要求使用前导<code>_</code>，因为XML属性名称不能以数字开头（即使某些IDE允许）。相应的索引符号也可用于<code>&LTconstructor-arg></code>元素，但并不常用，因为声明的简单顺序通常就足够了。</blockquote> <h5 id=复合属性名称><a class=headerlink href=#复合属性名称 title=复合属性名称></a>复合属性名称</h5><p>设置bean属性时，可以使用复合属性名称或嵌套属性名称，只要路径中除最终属性名称之外的所有组件都不是<code>null</code>即可。考虑以下bean定义：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"something"</span> <span class=attr>class</span>=<span class=string>"things.ThingOne"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"fred.bob.sammy"</span> <span class=attr>value</span>=<span class=string>"123"</span> /></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p><code>something</code> bean 具有<code>fred</code>属性，该属性具有<code>bob</code>属性，该属性具有<code>sammy</code>属性，并且最终的<code>sammy</code>属性被设置为<code>123</code>的值。为了使它起作用，在构造 bean 之后，<code>something</code>的<code>fred</code>属性和<code>fred</code>的<code>bob</code>属性一定不能为<code>null</code>。否则，将抛出<code>NullPointerException</code>。</p> <h4 id=2-1-4-3、使用-depends-on><a title="2.1.4.3、使用 depends-on" class=headerlink href=#2-1-4-3、使用-depends-on></a>2.1.4.3、使用 depends-on</h4><p>以下示例使用该<code>depends-on</code>属性表示对单个bean的依赖关系：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"beanOne"</span> <span class=attr>class</span>=<span class=string>"ExampleBean"</span> <span class=attr>depends-on</span>=<span class=string>"manager"</span>/></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"manager"</span> <span class=attr>class</span>=<span class=string>"ManagerBean"</span> /></span></span><br></pre></table></figure> <p>要表达对多个bean的依赖性，请提供一个bean名称列表作为<code>depends-on</code>属性值（逗号，空格和分号是有效的分隔符）：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"beanOne"</span> <span class=attr>class</span>=<span class=string>"ExampleBean"</span> <span class=attr>depends-on</span>=<span class=string>"manager,accountDao"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"manager"</span> <span class=attr>ref</span>=<span class=string>"manager"</span> /></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"manager"</span> <span class=attr>class</span>=<span class=string>"ManagerBean"</span> /></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"accountDao"</span> <span class=attr>class</span>=<span class=string>"x.y.jdbc.JdbcAccountDao"</span> /></span></span><br></pre></table></figure> <blockquote><p>该<code>depends-on</code>属性既可以指定初始化时间相关性，也可以指定单例情况 。</blockquote> <h4 id=2-1-4-4、延迟初始化Bean><a class=headerlink href=#2-1-4-4、延迟初始化Bean title=2.1.4.4、延迟初始化Bean></a>2.1.4.4、延迟初始化Bean</h4><p>在XML中，此行为由元素上的lazy-init属性控制，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"lazy"</span> <span class=attr>class</span>=<span class=string>"com.something.ExpensiveToCreateBean"</span> <span class=attr>lazy-init</span>=<span class=string>"true"</span>/></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>name</span>=<span class=string>"not.lazy"</span> <span class=attr>class</span>=<span class=string>"com.something.AnotherBean"</span>/></span></span><br></pre></table></figure> <p>当<code>ApplicationContext</code>消耗了前面的配置时，<code>ApplicationContext</code>启动时就不会急于预先实例化<code>lazy</code> bean，而<code>not.lazy</code> Bean 则会急于预先实例化。</p> <p>但是，当延迟初始化的 bean 是未延迟初始化的单例 bean 的依赖项时，<code>ApplicationContext</code>将在启动时创建延迟初始化的 bean，因为它必须满足单例的依赖关系。延迟初始化的 bean 被注入到其他未延迟初始化的单例 bean 中。</p> <p>您还可以使用<code>&LTbeans/></code>元素上的<code>default-lazy-init</code>属性在容器级别控制延迟初始化，以下示例显示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>default-lazy-init</span>=<span class=string>"true"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- no beans will be pre-instantiated... --></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h4 id=2-1-4-5、自动装配协作器><a class=headerlink href=#2-1-4-5、自动装配协作器 title=2.1.4.5、自动装配协作器></a>2.1.4.5、自动装配协作器</h4><p>自动装配具有以下优点：</p> <ul><li>自动装配可以大大减少指定属性或构造函数参数的需要。<li>随着对象的发展，自动装配可以更新配置。例如，如果需要将依赖项添加到类中，则无需修改配置即可自动满足该依赖项。因此，自动装配在开发过程中特别有用，而不必担心在代码库变得更稳定时切换到显式接线的选择。</ul> <p>使用基于 XML 的配置元数据时，可以使用<code>&LTbean/></code>元素的<code>autowire</code>属性为 bean 定义指定自动装配模式。自动装配功能具有四种模式。您可以为每个 bean 指定自动装配，因此可以选择要自动装配的装配。下表描述了四种自动装配模式：</p> <table><thead><tr><th align=left>模式<th align=left>说明<tbody><tr><td align=left><code>no</code><td align=left>（默认）无自动装配。Bean引用必须由<code>ref</code>元素定义。对于较大的部署，建议不要更改默认设置，因为明确指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了系统的结构。<tr><td align=left><code>byName</code><td align=left>按属性名称自动布线。Spring查找与需要自动装配的属性同名的bean。例如，如果一个bean定义被设置为按名称自动装配并且包含一个<code>master</code>属性（即它具有一个 <code>setMaster(..)</code>方法），那么Spring将查找一个名为的bean定义，<code>master</code>并使用它来设置该属性。<tr><td align=left><code>byType</code><td align=left>如果容器中恰好存在一个属性类型的bean，则使该属性自动连接。如果存在多个错误，则会引发致命异常，这表明您可能无法<code>byType</code>对该bean使用自动装配。如果没有匹配的bean，则什么都不会发生（未设置该属性）。<tr><td align=left><code>constructor</code><td align=left>类似于<code>byType</code>但适用于构造函数参数。如果容器中不存在构造函数参数类型的一个bean，则将引发致命错误。</table> <p>使用<code>byType</code>或<code>constructor</code>自动装配模式，您可以连接阵列和键入的集合。在这种情况下，将提供容器中与预期类型匹配的所有自动装配候选，以满足相关性。如果预期的密钥类型为<code>String</code>，则可以自动连接强类型的<code>Map</code>实例。自动连接的<code>Map</code>实例的值包含与期望的类型匹配的所有 bean 实例，并且<code>Map</code>实例的键包含相应的 Bean 名称。</p> <h5 id=自动装配的局限性和缺点><a class=headerlink href=#自动装配的局限性和缺点 title=自动装配的局限性和缺点></a>自动装配的局限性和缺点</h5><p>自动装配的缺点和局限：</p> <ul><li><code>property</code>和<code>constructor-arg</code>设置中的显式依赖项始终会覆盖自动装配。您不能自动连接简单属性，例如基元，<code>Strings</code>和<code>Classes</code>(以及此类简单属性的数组)。此限制是设计使然。<li>自动装配不如显式装配精确。<li>装配信息可能不适用于从Spring容器生成文档的工具。<li>容器内的多个bean定义可能与要自动装配的setter方法或构造函数参数指定的类型匹配。对于数组，集合或 <code>Map</code>实例，这不一定是问题。但是，对于需要单个值的依赖项，不会任意解决此歧义。如果没有唯一的bean定义可用，则会引发异常。</ul> <p>在后一种情况下，您有几种选择：</p> <ul><li>放弃自动装配，转而使用显式装配。<li>如<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-autowire-candidate rel=noopener target=_blank>next section</a>中所述，通过将其<code>autowire-candidate</code>属性设置为<code>false</code>来避免自动装配 bean 定义。<li>通过将其<code>&LTbean/></code>元素的<code>primary</code>属性设置为<code>true</code>，将单个 bean 定义指定为主要候选对象。<li>如<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-annotation-config rel=noopener target=_blank>基于注解的容器配置</a>中所述，通过基于注解的配置实现更细粒度的控件。</ul> <h5 id=从自动装配中排除Bean><a class=headerlink href=#从自动装配中排除Bean title=从自动装配中排除Bean></a>从自动装配中排除Bean</h5><p>在每个bean的基础上，您可以从自动装配中排除一个bean。使用Spring的XML格式，将元素的<code>autowire-candidate</code>属性设置<code>&LTbean/></code>为<code>false</code>。容器使特定的 bean 定义对于自动装配基础结构不可用(包括注解样式配置，例如<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-autowired-annotation rel=noopener target=_blank>@Autowired</a>)。</p> <blockquote><p><code>autowire-candidate</code>属性旨在仅影响基于类型的自动装配。它不会影响按名称显示的显式引用，即使未将指定的 Bean 标记为自动装配候选，该名称也可得到解析。因此，如果名称匹配，按名称自动装配仍会注入 Bean。</blockquote> <h4 id=2-1-4-6、方法注入><a class=headerlink href=#2-1-4-6、方法注入 title=2.1.4.6、方法注入></a>2.1.4.6、方法注入</h4><p>在大多数应用场景中，容器中的大多数bean是 <a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton rel=noopener target=_blank>singletons</a>。当一个单例Bean需要与另一个单例Bean协作或一个非单例Bean需要与另一个非单例Bean协作时，通常可以通过将一个Bean定义为另一个Bean的属性来处理依赖关系。当bean的生命周期不同时会出现问题。假设单例bean A需要使用非单例（原型）bean B，也许在A的每个方法调用上都使用。容器仅创建一次单例bean A，因此只有一次机会来设置属性。每次需要一个容器时，容器都无法为bean A提供一个新的bean B实例。</p> <p>一个解决方案是放弃某些控制反转。您可以通过实现<code>ApplicationContextAware</code>接口来<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-aware rel=noopener target=_blank>使 bean A 知道容器</a>，并在每次 bean A 需要它时<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-client rel=noopener target=_blank>对容器进行 getBean(“ B”)调用</a>询问(通常是新的)bean B 实例。以下示例显示了此方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> fiona.apple;</span><br><span class=line><span class=comment>// Spring-API imports</span></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.BeansException;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.ApplicationContext;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.ApplicationContextAware;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CommandManager</span> <span class=keyword>implements</span> <span class="title class_">ApplicationContextAware</span> {</span><br><span class=line>    <span class=keyword>private</span> ApplicationContext applicationContext;</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">process</span><span class=params>(Map commandState)</span> {</span><br><span class=line>        <span class=comment>// grab a new instance of the appropriate Command</span></span><br><span class=line>        <span class=type>Command</span> <span class=variable>command</span> <span class=operator>=</span> createCommand();</span><br><span class=line>        <span class=comment>// set the state on the (hopefully brand new) Command instance</span></span><br><span class=line>        command.setState(commandState);</span><br><span class=line>        <span class=keyword>return</span> command.execute();</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>protected</span> Command <span class="title function_">createCommand</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// notice the Spring API dependency!</span></span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.applicationContext.getBean(<span class=string>"command"</span>, Command.class);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setApplicationContext</span><span class=params>(</span></span><br><span class=line><span class=params>            ApplicationContext applicationContext)</span> <span class=keyword>throws</span> BeansException {</span><br><span class=line>        <span class=built_in>this</span>.applicationContext = applicationContext;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>前面的内容是不理想的，因为业务代码知道并耦合到Spring框架。方法注入是Spring IoC容器的一项高级功能，使您可以干净地处理此用例。</p> <h5 id=查找方法注入><a class=headerlink href=#查找方法注入 title=查找方法注入></a>查找方法注入</h5><p>查找方法注入是容器重写容器管理的Bean上的方法并返回容器中另一个命名Bean的查找结果的能力。查找通常涉及原型bean。Spring框架通过使用CGLIB库中的字节码生成来动态生成覆盖该方法的子类，从而实现此方法的注入。</p> <blockquote><ul><li>为了使此动态子类起作用，Spring Bean容器子类的类也不能为<code>final</code>，要覆盖的方法也不能为<code>final</code>。<li>对具有<code>abstract</code>方法的类进行单元测试需要您自己对该类进行子类化，并提供该<code>abstract</code>方法的存根实现。<li>组件扫描也需要具体的方法，这需要具体的类。<li>另一个关键限制是，查找方法不适用于工厂方法，尤其不适用于配置类中的<code>@Bean</code>方法，因为在这种情况下，容器不负责创建实例，因此无法创建运行时生成的子类。</ul></blockquote> <p>对于前面的代码片段中的<code>CommandManager</code>类，Spring 容器将动态覆盖<code>createCommand()</code>方法的实现。 <code>CommandManager</code>类没有任何 Spring 依赖项，如重做的示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> fiona.apple;</span><br><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">CommandManager</span> {</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">process</span><span class=params>(Object commandState)</span> {</span><br><span class=line>        <span class=comment>// grab a new instance of the appropriate Command interface</span></span><br><span class=line>        <span class=type>Command</span> <span class=variable>command</span> <span class=operator>=</span> createCommand();</span><br><span class=line>        <span class=comment>// set the state on the (hopefully brand new) Command instance</span></span><br><span class=line>        command.setState(commandState);</span><br><span class=line>        <span class=keyword>return</span> command.execute();</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// okay... but where is the implementation of this method?</span></span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>abstract</span> Command <span class="title function_">createCommand</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>在包含要注入的方法的客户端类（<code>CommandManager</code>在本例中为）中，要注入的方法需要以下形式的签名：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>&LTpublic|protected> [abstract] <span class=tag><<span class=name>return-type</span>></span> theMethodName(no-arguments);</span><br></pre></table></figure> <p>如果方法为<code>abstract</code>，则动态生成的子类将实现该方法。否则，动态生成的子类将覆盖原始类中定义的具体方法。考虑以下示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- a stateful bean deployed as a prototype (non-singleton) --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"myCommand"</span> <span class=attr>class</span>=<span class=string>"fiona.apple.AsyncCommand"</span> <span class=attr>scope</span>=<span class=string>"prototype"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- inject dependencies here as required --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=comment>&LT!-- commandProcessor uses statefulCommandHelper --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"commandManager"</span> <span class=attr>class</span>=<span class=string>"fiona.apple.CommandManager"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>lookup-method</span> <span class=attr>name</span>=<span class=string>"createCommand"</span> <span class=attr>bean</span>=<span class=string>"myCommand"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>每当需要<code>myCommand</code> bean 的新实例时，标识为<code>commandManager</code>的 bean 就会调用其自己的<code>createCommand()</code>方法。如果确实需要<code>myCommand</code> bean 作为原型，则必须小心。如果它是<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-singleton rel=noopener target=_blank>singleton</a>，则每次都返回<code>myCommand</code> bean 的相同实例。</p> <p>另外，在基于注解的组件模型中，您可以通过<code>@Lookup</code>注解 声明一个查找方法，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">CommandManager</span> {</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">process</span><span class=params>(Object commandState)</span> {</span><br><span class=line>        <span class=type>Command</span> <span class=variable>command</span> <span class=operator>=</span> createCommand();</span><br><span class=line>        command.setState(commandState);</span><br><span class=line>        <span class=keyword>return</span> command.execute();</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Lookup("myCommand")</span></span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>abstract</span> Command <span class="title function_">createCommand</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>或者，更惯用的是，您可以依赖于目标bean根据lookup方法的声明的返回类型来解析：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">CommandManager</span> {</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">process</span><span class=params>(Object commandState)</span> {</span><br><span class=line>        <span class=type>MyCommand</span> <span class=variable>command</span> <span class=operator>=</span> createCommand();</span><br><span class=line>        command.setState(commandState);</span><br><span class=line>        <span class=keyword>return</span> command.execute();</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Lookup</span></span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>abstract</span> MyCommand <span class="title function_">createCommand</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=任意方法替换><a class=headerlink href=#任意方法替换 title=任意方法替换></a>任意方法替换</h5><p>与查找方法注入相比，方法注入的一种不太有用的形式是能够用另一种方法实现替换托管bean中的任意方法。</p> <h3 id=2-1-5、Bean作用域><a class=headerlink href=#2-1-5、Bean作用域 title=2.1.5、Bean作用域></a>2.1.5、Bean作用域</h3><p>下表描述了受支持的范围：</p> <table><thead><tr><th align=left>范围<th align=left>描述<tbody><tr><td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton rel=noopener target=_blank>singleton</a><td align=left>（默认值）将每个Spring IoC容器的单个bean定义范围限定为单个对象实例。<tr><td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-prototype rel=noopener target=_blank>prototype</a><td align=left>将单个bean定义的作用域限定为任意数量的对象实例。<tr><td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-request rel=noopener target=_blank>request</a><td align=left>将单个bean定义的范围限定为单个HTTP请求的生命周期。也就是说，每个HTTP请求都有一个自己的bean实例，它是在单个bean定义的后面创建的。仅在可感知网络的Spring上下文中有效<code>ApplicationContext</code>。<tr><td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-session rel=noopener target=_blank>session</a><td align=left>将单个bean定义的范围限定为HTTP的生命周期<code>Session</code>。仅在基于Web的Spring上下文中有效<code>ApplicationContext</code>.<tr><td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-application rel=noopener target=_blank>application</a><td align=left>将单个bean定义的作用域限定为的生命周期<code>ServletContext</code>。仅在可感知网络的Spring上下文中有效<code>ApplicationContext</code>。<tr><td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-websocket-scope rel=noopener target=_blank>websocket</a><td align=left>将单个bean定义的作用域限定为的生命周期<code>WebSocket</code>。仅在可感知网络的Spring上下文中有效<code>ApplicationContext</code>。</table> <blockquote><p>从Spring 3.0开始，线程作用域可用，但默认情况下未注册。</blockquote> <h4 id=2-1-5-1、singleton-scope><a title="2.1.5.1、singleton scope" class=headerlink href=#2-1-5-1、singleton-scope></a>2.1.5.1、singleton scope</h4><p>当您定义一个bean定义并且其作用域为单例时，Spring IoC容器将为该bean定义所定义的对象创建一个实例。该单个实例存储在此类单例bean的高速缓存中，并且对该命名bean的所有后续请求和引用都返回该高速缓存的对象。下图显示了单例作用域的工作方式：</p> <p><img alt=singleton src=C:\Users\shihao\Desktop\图片\工作\Spring\单例Bean工作方式01></p> <p>要将bean定义为XML中的单例，可以定义bean，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"accountService"</span> <span class=attr>class</span>=<span class=string>"com.something.DefaultAccountService"</span>/></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"accountService"</span> <span class=attr>class</span>=<span class=string>"com.something.DefaultAccountService"</span> <span class=attr>scope</span>=<span class=string>"singleton"</span>/></span></span><br></pre></table></figure> <h4 id=2-1-5-2、prototype-scope><a title="2.1.5.2、prototype scope" class=headerlink href=#2-1-5-2、prototype-scope></a>2.1.5.2、prototype scope</h4><p>每次对特定 bean 提出请求时，bean 部署的非单一原型范围都会导致创建一个新 bean 实例。也就是说，将 Bean 注入到另一个 Bean 中，或者您可以通过容器上的<code>getBean()</code>方法调用来请求它。通常，应将原型作用域用于所有有状态 Bean，将单例作用域用于 StatelessBean。</p> <p>以下示例将bean定义为XML原型：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"accountService"</span> <span class=attr>class</span>=<span class=string>"com.something.DefaultAccountService"</span> <span class=attr>scope</span>=<span class=string>"prototype"</span>/></span></span><br></pre></table></figure> <h4 id=2-1-5-3、具有原型bean依赖关系的singleton-bena><a title="2.1.5.3、具有原型bean依赖关系的singleton bena" class=headerlink href=#2-1-5-3、具有原型bean依赖关系的singleton-bena></a>2.1.5.3、具有原型bean依赖关系的singleton bena</h4><p>当您使用对原型 bean 有依赖性的单例作用域 Bean 时，请注意，依赖关系在实例化时已解决。因此，如果将依赖项原型的 bean 依赖项注入到单例范围的 bean 中，则将实例化新的原型 bean，然后将依赖项注入到单例 bean 中。原型实例是曾经提供给单例范围的 bean 的唯一实例。</p> <p>但是，假设您希望单例作用域的 bean 在运行时重复获取原型作用域的 bean 的新实例。您不能将原型作用域的 bean 依赖项注入到您的单例 bean 中，因为当 Spring 容器实例化单例 bean 并解析并注入其依赖项时，该注入仅发生一次。</p> <h4 id=2-1-5-4、request、session、application、websocket-scope><a title="2.1.5.4、request、session、application、websocket scope" class=headerlink href=#2-1-5-4、request、session、application、websocket-scope></a>2.1.5.4、request、session、application、websocket scope</h4><p><code>request</code>，<code>session</code>，<code>application</code>和<code>websocket</code>范围仅在使用 Web 感知的 Spring <code>ApplicationContext</code>实现(例如<code>XmlWebApplicationContext</code>)时可用。如果将这些作用域与常规的 Spring IoC 容器(例如<code>ClassPathXmlApplicationContext</code>)一起使用，则会引发未知 bean 作用域的<code>IllegalStateException</code>。</p> <h5 id=初始Web配置><a class=headerlink href=#初始Web配置 title=初始Web配置></a>初始Web配置</h5><p>如何完成此初始设置取决于您的特定Servlet环境。</p> <p>如果实际上在 Spring <code>DispatcherServlet</code>处理的请求中访问 Spring Web MVC 中的作用域 Bean，则不需要特殊的设置。 <code>DispatcherServlet</code>已经公开了所有相关状态。</p> <p>如果您使用 Servlet 2.5 Web 容器，并且在 Spring 的<code>DispatcherServlet</code>之外处理请求(例如，当使用 JSF 或 Struts 时)，则需要注册<code>org.springframework.web.context.request.RequestContextListener</code> <code>ServletRequestListener</code>。对于 Servlet 3.0，可以使用<code>WebApplicationInitializer</code>接口以编程方式完成此操作。或者，或者对于较旧的容器，将以下声明添加到 Web 应用程序的<code>web.xml</code>文件中：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>web-app</span>></span></span><br><span class=line>    ...</span><br><span class=line>    <span class=tag><<span class=name>listener</span>></span></span><br><span class=line>        <span class=tag><<span class=name>listener-class</span>></span></span><br><span class=line>            org.springframework.web.context.request.RequestContextListener</span><br><span class=line>        <span class=tag>&LT/<span class=name>listener-class</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>listener</span>></span></span><br><span class=line>    ...</span><br><span class=line><span class=tag>&LT/<span class=name>web-app</span>></span></span><br></pre></table></figure> <p>另外，如果您的监听器设置存在问题，请考虑使用 Spring 的<code>RequestContextFilter</code>。过滤器 Map 取决于周围的 Web 应用程序配置，因此您必须适当地对其进行更改。以下清单显示了 Web 应用程序的过滤器部分：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>web-app</span>></span></span><br><span class=line>    ...</span><br><span class=line>    <span class=tag><<span class=name>filter</span>></span></span><br><span class=line>        <span class=tag><<span class=name>filter-name</span>></span>requestContextFilter<span class=tag>&LT/<span class=name>filter-name</span>></span></span><br><span class=line>        <span class=tag><<span class=name>filter-class</span>></span>org.springframework.web.filter.RequestContextFilter<span class=tag>&LT/<span class=name>filter-class</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>filter</span>></span></span><br><span class=line>    <span class=tag><<span class=name>filter-mapping</span>></span></span><br><span class=line>        <span class=tag><<span class=name>filter-name</span>></span>requestContextFilter<span class=tag>&LT/<span class=name>filter-name</span>></span></span><br><span class=line>        <span class=tag><<span class=name>url-pattern</span>></span>/*<span class=tag>&LT/<span class=name>url-pattern</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>filter-mapping</span>></span></span><br><span class=line>    ...</span><br><span class=line><span class=tag>&LT/<span class=name>web-app</span>></span></span><br></pre></table></figure> <p><code>DispatcherServlet</code>，<code>RequestContextListener</code>和<code>RequestContextFilter</code>都做完全相同的事情，即将 HTTP 请求对象绑定到正在为该请求提供服务的<code>Thread</code>上。这使得在请求链和会话范围内的 Bean 可以在调用链的更下游使用。</p> <h5 id=request-scope><a title="request scope" class=headerlink href=#request-scope></a>request scope</h5><p>考虑以下XML配置来定义bean：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"loginAction"</span> <span class=attr>class</span>=<span class=string>"com.something.LoginAction"</span> <span class=attr>scope</span>=<span class=string>"request"</span>/></span></span><br></pre></table></figure> <p>Spring 容器通过为每个 HTTP 请求使用<code>loginAction</code> bean 定义来创建<code>LoginAction</code> bean 的新实例。也就是说，<code>loginAction</code> bean 的作用域是 HTTP 请求级别。您可以根据需要更改创建实例的内部状态，因为从同一<code>loginAction</code> bean 定义创建的其他实例看不到这些状态更改。它们特定于单个请求。当请求完成处理时，将限制作用于该请求的 Bean。</p> <p>使用注解驱动的组件或 Java 配置时，可以使用<code>@RequestScope</code>注解 将组件分配给<code>request</code>范围。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@RequestScope</span></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">LoginAction</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <h5 id=session-scope><a title="session scope" class=headerlink href=#session-scope></a>session scope</h5><p>考虑以下XML配置来定义bean：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"userPreferences"</span> <span class=attr>class</span>=<span class=string>"com.something.UserPreferences"</span> <span class=attr>scope</span>=<span class=string>"session"</span>/></span></span><br></pre></table></figure> <p>在单个 HTTP <code>Session</code>的生存期内，Spring 容器通过使用<code>userPreferences</code> bean 定义来创建<code>UserPreferences</code> bean 的新实例。换句话说，<code>userPreferences</code> bean 的作用域实际上是 HTTP <code>Session</code>级别。与请求范围的 Bean 一样，您可以根据需要任意更改所创建实例的内部状态，因为知道其他 HTTP <code>Session</code>实例(也使用从相同<code>userPreferences</code> Bean 定义创建的实例)不会看到这些状态更改，因为它们特定于单个 HTTP <code>Session</code>。当最终丢弃 HTTP <code>Session</code>时，也将丢弃作用于该特定 HTTP <code>Session</code>的 bean。</p> <p>使用注解驱动的组件或 Java 配置时，可以使用<code>@SessionScope</code>注解 将组件分配给<code>session</code>范围。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@SessionScope</span></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">UserPreferences</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <h5 id=application-scope><a title="application scope" class=headerlink href=#application-scope></a>application scope</h5><p>考虑以下XML配置来定义bean：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"appPreferences"</span> <span class=attr>class</span>=<span class=string>"com.something.AppPreferences"</span> <span class=attr>scope</span>=<span class=string>"application"</span>/></span></span><br></pre></table></figure> <p>Spring 容器通过对整个 Web 应用程序使用<code>appPreferences</code> bean 定义来创建<code>AppPreferences</code> bean 的新实例。也就是说，<code>appPreferences</code> bean 的作用域为<code>ServletContext</code>级别，并存储为常规<code>ServletContext</code>属性。这有点类似于 Spring 单例 bean，但是有两个重要的区别：它是每个<code>ServletContext</code>而不是每个 Spring’ApplicationContext’(在任何给定的 Web 应用程序中可能都有多个)，并且实际上是公开的，因此可见为<code>ServletContext</code>属性。</p> <p>使用注解驱动的组件或 Java 配置时，可以使用<code>@ApplicationScope</code>注解 将组件分配给<code>application</code>范围。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@ApplicationScope</span></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppPreferences</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <h5 id=作用域bean作为依赖项><a class=headerlink href=#作用域bean作为依赖项 title=作用域bean作为依赖项></a>作用域bean作为依赖项</h5><p>Spring IoC 容器不仅管理 对象(bean)的实例化，而且还 Management 协作者(或依赖项)的连接。如果要将(例如)HTTP 请求范围的 Bean 注入(例如)另一个作用域更长的 Bean，则可以选择注入 AOP 代理来代替已定义范围的 Bean。也就是说，您需要注入一个代理对象，该对象公开与范围对象相同的公共接口，但也可以从相关范围(例如 HTTP 请求)中检索实际目标对象，并将方法调用委托给该真实对象。</p> <h6 id=选择要创建的代理类型><a class=headerlink href=#选择要创建的代理类型 title=选择要创建的代理类型></a>选择要创建的代理类型</h6><p>默认情况下，当Spring容器为使用<code>&LTaop:scoped-proxy/></code>元素标记的bean创建代理时，将创建基于CGLIB的类代理。</p> <blockquote><p>CGLIB代理仅拦截公共方法调用！不要在此类代理上调用非公共方法。它们没有被委派给实际的作用域目标对象。</blockquote> <p>另外，您可以通过将<code>&LTaop:scoped-proxy/></code>元素的<code>proxy-target-class</code>属性的值指定为<code>false</code>来配置 Spring 容器为此类作用域的 bean 创建基于标准 JDK 接口的代理。使用基于 JDK 接口的代理意味着您不需要应用程序 Classpath 中的其他库即可影响此类代理。但是，这也意味着作用域 bean 的类必须实现至少一个接口，并且作用域 bean 注入到其中的所有协作者都必须通过其接口之一引用该 bean。</p> <p>以下示例显示了基于接口的代理：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- DefaultUserPreferences implements the UserPreferences interface --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"userPreferences"</span> <span class=attr>class</span>=<span class=string>"com.stuff.DefaultUserPreferences"</span> <span class=attr>scope</span>=<span class=string>"session"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:scoped-proxy</span> <span class=attr>proxy-target-class</span>=<span class=string>"false"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"userManager"</span> <span class=attr>class</span>=<span class=string>"com.stuff.UserManager"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"userPreferences"</span> <span class=attr>ref</span>=<span class=string>"userPreferences"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <h4 id=2-1-5-5、自定义范围><a class=headerlink href=#2-1-5-5、自定义范围 title=2.1.5.5、自定义范围></a>2.1.5.5、自定义范围</h4><p>Bean作用域机制是可扩展的。您可以定义自己的作用域，甚至重新定义现有作用域，尽管后者被认为是不好的做法，您不能覆盖内置作用域<code>singleton</code>和<code>prototype</code>作用域。</p> <h5 id=创建自定义范围><a class=headerlink href=#创建自定义范围 title=创建自定义范围></a>创建自定义范围</h5><p>要将自定义范围集成到Spring容器中，您需要实现<code>org.springframework.beans.factory.config.Scope</code>接口。</p> <p>该<code>Scope</code>接口有四种方法可以从作用域中获取对象，将它们从作用域中删除，然后将其销毁。</p> <p>以下方法从基础范围返回对象：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>Object <span class="title function_">get</span><span class=params>(String name, ObjectFactory&LT?> objectFactory)</span>;</span><br></pre></table></figure> <p>以下方法从基础范围中删除该对象：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>Object <span class="title function_">remove</span><span class=params>(String name)</span>;</span><br></pre></table></figure> <p>以下方法注册一个回调，当销毁作用域或销毁作用域中的指定对象时，作用域应调用该回调：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> <span class="title function_">registerDestructionCallback</span><span class=params>(String name, Runnable destructionCallback)</span>;</span><br></pre></table></figure> <p>以下方法获取基础范围的会话标识符：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>String <span class="title function_">getConversationId</span><span class=params>()</span>;</span><br></pre></table></figure> <p>每个范围的标识符都不相同。对于会话范围的实现，此标识符可以是会话标识符。</p> <h5 id=使用自定义范围><a class=headerlink href=#使用自定义范围 title=使用自定义范围></a>使用自定义范围</h5><p>以下方法是在 Spring 容器中注册新的<code>Scope</code>的中心方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> <span class="title function_">registerScope</span><span class=params>(String scopeName, Scope scope)</span>;</span><br></pre></table></figure> <p>此方法在<code>ConfigurableBeanFactory</code>接口上声明，该接口可通过 Spring 附带的大多数具体<code>ApplicationContext</code>实现上的<code>BeanFactory</code>属性使用。</p> <p><code>registerScope(..)</code>方法的第一个参数是与范围关联的唯一名称。 Spring 容器本身中的此类名称示例为<code>singleton</code>和<code>prototype</code>。 <code>registerScope(..)</code>方法的第二个参数是您希望注册和使用的自定义<code>Scope</code>实现的实际实例。</p> <p>假设您编写了自定义<code>Scope</code>实现，然后注册它，如下面的示例所示。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>Scope</span> <span class=variable>threadScope</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SimpleThreadScope</span>();</span><br><span class=line>beanFactory.registerScope(<span class=string>"thread"</span>, threadScope);</span><br></pre></table></figure> <p>然后，您可以创建符合自定义<code>Scope</code>范围规则的 bean 定义，如下所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"..."</span> <span class=attr>class</span>=<span class=string>"..."</span> <span class=attr>scope</span>=<span class=string>"thread"</span>></span></span><br></pre></table></figure> <p>使用自定义<code>Scope</code>实现，您不仅可以通过程序注册该范围。您还可以通过使用<code>CustomScopeConfigurer</code>类以声明方式进行<code>Scope</code>注册，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:aop</span>=<span class=string>"http://www.springframework.org/schema/aop"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/aop</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/aop/spring-aop.xsd"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.config.CustomScopeConfigurer"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"scopes"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>map</span>></span></span><br><span class=line>                <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"thread"</span>></span></span><br><span class=line>                    <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.context.support.SimpleThreadScope"</span>/></span></span><br><span class=line>                <span class=tag>&LT/<span class=name>entry</span>></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>map</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"thing2"</span> <span class=attr>class</span>=<span class=string>"x.y.Thing2"</span> <span class=attr>scope</span>=<span class=string>"thread"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"Rick"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>aop:scoped-proxy</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"thing1"</span> <span class=attr>class</span>=<span class=string>"x.y.Thing1"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"thing2"</span> <span class=attr>ref</span>=<span class=string>"thing2"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h3 id=2-1-6、自定义Bean性质><a class=headerlink href=#2-1-6、自定义Bean性质 title=2.1.6、自定义Bean性质></a>2.1.6、自定义Bean性质</h3><h4 id=2-1-6-1、生命周期回调><a class=headerlink href=#2-1-6-1、生命周期回调 title=2.1.6.1、生命周期回调></a>2.1.6.1、生命周期回调</h4><p>为了与容器对bean生命周期的管理进行交互，可以实现Spring<code>InitializingBean</code>和<code>DisposableBean</code>接口。容器对前者调用<code>afterPropertiesSet()</code>，对后者调用<code>destroy()</code>，使 Bean 在初始化和销毁时执行某些操作。</p> <p>除了初始化和销毁回调外，Spring托管的对象还可以实现<code>Lifecycle</code>接口，以便这些对象可以在容器自身生命周期的驱动下参与启动和关闭过程。</p> <h5 id=初始化回调><a class=headerlink href=#初始化回调 title=初始化回调></a>初始化回调</h5><p><code>org.springframework.beans.factory.InitializingBean</code>接口允许容器在容器上设置了所有必需的属性后，bean 可以执行初始化工作。 <code>InitializingBean</code>接口指定一个方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> <span class="title function_">afterPropertiesSet</span><span class=params>()</span> <span class=keyword>throws</span> Exception;</span><br></pre></table></figure> <p>我们建议您不要使用<code>InitializingBean</code>接口，因为它不必要地将代码耦合到Spring。另外，我们建议使用<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-postconstruct-and-predestroy-annotations rel=noopener target=_blank><code>@PostConstruct</code></a>注释或指定POJO初始化方法。对于基于XML的配置元数据，可以使用<code>init-method</code>属性指定具有无效无参数签名的方法的名称。通过Java配置，您可以使用的<code>initMethod</code>属性 <code>@Bean</code>。考虑以下示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleInitBean"</span> <span class=attr>class</span>=<span class=string>"examples.ExampleBean"</span> <span class=attr>init-method</span>=<span class=string>"init"</span>/></span></span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleBean</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">init</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// do some initialization work</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>前面的示例与下面的示例（包含两个清单）几乎具有完全相同的效果：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleInitBean"</span> <span class=attr>class</span>=<span class=string>"examples.AnotherExampleBean"</span>/></span></span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AnotherExampleBean</span> <span class=keyword>implements</span> <span class="title class_">InitializingBean</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">afterPropertiesSet</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// do some initialization work</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>但是，前面两个示例中的第一个示例并未将代码耦合到 Spring。</p> <h5 id=销毁回调><a class=headerlink href=#销毁回调 title=销毁回调></a>销毁回调</h5><p>实现<code>org.springframework.beans.factory.DisposableBean</code>接口后，当包含 bean 的容器被销毁时，bean 可以获取回调。 <code>DisposableBean</code>接口指定一个方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> <span class="title function_">destroy</span><span class=params>()</span> <span class=keyword>throws</span> Exception;</span><br></pre></table></figure> <p>我们建议您不要使用<code>DisposableBean</code>回调接口，因为它不必要地将代码耦合到 Spring。另外，我们建议使用<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-postconstruct-and-predestroy-annotations rel=noopener target=_blank>@PreDestroy</a>注解或指定 bean 定义支持的通用方法。使用基于 XML 的配置元数据时，可以在<code>&LTbean/></code>上使用<code>destroy-method</code>属性。通过 Java 配置，可以使用<code>@Bean</code>的<code>destroy-method</code>属性。考虑以下定义：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleInitBean"</span> <span class=attr>class</span>=<span class=string>"examples.ExampleBean"</span> <span class=attr>destroy-method</span>=<span class=string>"cleanup"</span>/></span></span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleBean</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">cleanup</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// do some destruction work (like releasing pooled connections)</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>前面的定义与下面的定义几乎具有完全相同的效果：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleInitBean"</span> <span class=attr>class</span>=<span class=string>"examples.AnotherExampleBean"</span>/></span></span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AnotherExampleBean</span> <span class=keyword>implements</span> <span class="title class_">DisposableBean</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">destroy</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// do some destruction work (like releasing pooled connections)</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>但是，前面两个定义中的第一个没有将代码耦合到 Spring。</p> <h5 id=默认初始化和销毁方法><a class=headerlink href=#默认初始化和销毁方法 title=默认初始化和销毁方法></a>默认初始化和销毁方法</h5><p>您可以将Spring容器配置为“寻找”命名的初始化，并销毁每个bean上的回调方法名称。</p> <p>假设您的初始化回调方法命名为<code>init()</code>，而 destroy 回调方法命名为<code>destroy()</code>。然后，您的类类似于以下示例中的类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DefaultBlogService</span> <span class=keyword>implements</span> <span class="title class_">BlogService</span> {</span><br><span class=line>    <span class=keyword>private</span> BlogDao blogDao;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setBlogDao</span><span class=params>(BlogDao blogDao)</span> {</span><br><span class=line>        <span class=built_in>this</span>.blogDao = blogDao;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// this is (unsurprisingly) the initialization callback method</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">init</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>this</span>.blogDao == <span class=literal>null</span>) {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalStateException</span>(<span class=string>"The [blogDao] property must be set."</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>然后，您可以在类似于以下内容的Bean中使用该类：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>default-init-method</span>=<span class=string>"init"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"blogService"</span> <span class=attr>class</span>=<span class=string>"com.something.DefaultBlogService"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"blogDao"</span> <span class=attr>ref</span>=<span class=string>"blogDao"</span> /></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>顶层<code>&LTbeans/></code>元素属性上<code>default-init-method</code>属性的存在会导致 Spring IoC 容器将 Bean 类上称为<code>init</code>的方法识别为初始化方法回调。创建和组装 bean 时，如果 bean 类具有此类方法，则会在适当的时间调用它。</p> <p>您可以通过使用顶级<code>&LTbeans/></code>元素上的<code>default-destroy-method</code>属性类似地(在 XML 中)配置 destroy 方法回调。</p> <p>Spring 容器保证在为 bean 提供所有依赖项后立即调用配置的初始化回调。因此，在原始 bean 引用上调用了初始化回调，这意味着 AOP 拦截器等尚未应用于 bean。首先完全创建目标 bean，然后应用带有其拦截器链的 AOP 代理(例如)。如果目标 Bean 和代理分别定义，则您的代码甚至可以绕过代理与原始目标 Bean 进行交互。因此，将拦截器应用于<code>init</code>方法将是不一致的，因为这样做会将目标 Bean 的生命周期耦合到其代理或拦截器，并在代码直接与原始目标 Bean 交互时留下奇怪的语义。</p> <h5 id=组合生命周期机制><a class=headerlink href=#组合生命周期机制 title=组合生命周期机制></a>组合生命周期机制</h5><p>从Spring 2.5开始，您可以使用三个选项来控制Bean生命周期行为：</p> <ul><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean rel=noopener target=_blank><code>InitializingBean</code></a>和 <a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-disposablebean rel=noopener target=_blank><code>DisposableBean</code></a>回调接口。<li>自定义 init()<code>和</code>destroy()`方法<li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-postconstruct-and-predestroy-annotations rel=noopener target=_blank><code>@PostConstruct</code>和<code>@PreDestroy</code> 注解</a>。您可以结合使用这些机制来控制给定的bean。</ul> <p>为同一个bean配置的具有不同初始化方法的多种生命周期机制如下：</p> <ol><li>用<code>@PostConstruct</code>注解 的方法<li><code>InitializingBean</code>回调接口定义的<code>afterPropertiesSet()</code><li>自定义配置的<code>init()</code>方法</ol> <p>销毁方法的调用顺序相同：</p> <ol><li>用<code>@PreDestroy</code>注解 的方法<li><code>DisposableBean</code>回调接口定义的<code>destroy()</code><li>自定义配置的<code>destroy()</code>方法</ol> <h5 id=启动和关闭回调><a class=headerlink href=#启动和关闭回调 title=启动和关闭回调></a>启动和关闭回调</h5><p><code>Lifecycle</code>接口为具有自己的生命周期要求(例如启动和停止某些后台进程)的任何对象定义基本方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Lifecycle</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">start</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">stop</span><span class=params>()</span>;</span><br><span class=line>    <span class=type>boolean</span> <span class="title function_">isRunning</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>任何Spring管理的对象都可以实现该<code>Lifecycle</code>接口。然后，当 <code>ApplicationContext</code>自身接收到启动和停止信号时（例如，对于运行时的停止/重新启动场景），它将把这些调用级联到在该上下文中定义的所有<code>Lifecycle</code>实现。它通过委托<code>LifecycleProcessor</code>来完成此任务，如以下清单所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">LifecycleProcessor</span> <span class=keyword>extends</span> <span class="title class_">Lifecycle</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">onRefresh</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">onClose</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>请注意，<code>LifecycleProcessor</code>本身是<code>Lifecycle</code> 接口的扩展。它还添加了两种其他方法来对刷新和关闭的上下文做出反应。</p> <p>启动和关闭调用的顺序可能很重要。如果任何两个对象之间存在“依赖”关系，则依赖方在其依赖之后开始，而在依赖之前停止。但是，有时直接依赖项是未知的。您可能只知道某种类型的对象应该先于另一种类型的对象开始。在这些情况下，<code>SmartLifecycle</code>接口定义了另一个选项，即在超级接口<code>Phased</code>上定义的<code>getPhase()</code>方法。以下清单显示了<code>Phased</code>接口的定义：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Phased</span> {</span><br><span class=line>    <span class=type>int</span> <span class="title function_">getPhase</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>以下清单显示了<code>SmartLifecycle</code>接口的定义：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">SmartLifecycle</span> <span class=keyword>extends</span> <span class="title class_">Lifecycle</span>, Phased {</span><br><span class=line>    <span class=type>boolean</span> <span class="title function_">isAutoStartup</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">stop</span><span class=params>(Runnable callback)</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>启动时，相位最低的对象首先启动。停止时，遵循相反的 Sequences。因此，实现<code>SmartLifecycle</code>且其<code>getPhase()</code>方法返回<code>Integer.MIN_VALUE</code>的对象将是第一个启动且最后一个停止的对象。在频谱的另一端，相位值<code>Integer.MAX_VALUE</code>表示该对象应最后启动并首先停止(可能是因为它取决于正在运行的其他进程)。考虑相位值时，重要的是要知道，任何未实现<code>SmartLifecycle</code>的“正常” <code>Lifecycle</code>对象的默认相位是<code>0</code>。因此，任何负相位值都表明对象应在这些标准组件之前开始(并在它们之后停止)。对于任何正相位值，反之亦然。</p> <h5 id=非Web应用中正常关闭Spring-IOC容器><a title="非Web应用中正常关闭Spring IOC容器" class=headerlink href=#非Web应用中正常关闭Spring-IOC容器></a>非Web应用中正常关闭Spring IOC容器</h5><p>要注册关闭钩子，请调用在<code>ConfigurableApplicationContext</code>接口上声明的<code>registerShutdownHook()</code>方法，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>class</span> <span class="title class_">Boot</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(<span class=keyword>final</span> String[] args)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>ConfigurableApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class=string>"beans.xml"</span>);</span><br><span class=line>        <span class=comment>// add a shutdown hook for the above context...</span></span><br><span class=line>        ctx.registerShutdownHook();</span><br><span class=line>        <span class=comment>// app runs here...</span></span><br><span class=line>        <span class=comment>// main method exits, hook is called prior to the app shutting down...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=2-1-6-2、ApplicationContextAware和BeanNameAware><a class=headerlink href=#2-1-6-2、ApplicationContextAware和BeanNameAware title=2.1.6.2、ApplicationContextAware和BeanNameAware></a>2.1.6.2、ApplicationContextAware和BeanNameAware</h4><p>当<code>ApplicationContext</code>创建实现<code>org.springframework.context.ApplicationContextAware</code>接口的对象实例时，该实例将获得对该<code>ApplicationContext</code>的引用。以下清单显示了<code>ApplicationContextAware</code>接口的定义：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">ApplicationContextAware</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">setApplicationContext</span><span class=params>(ApplicationContext applicationContext)</span> <span class=keyword>throws</span> BeansException;</span><br><span class=line>}</span><br></pre></table></figure> <p>因此，bean 可以通过<code>ApplicationContext</code>接口或通过将引用转换为该接口的已知子类(例如<code>ConfigurableApplicationContext</code>，以公开其他功能)来以编程方式操纵创建它们的<code>ApplicationContext</code>。一种用途是通过编程方式检索其他 bean。有时，此功能很有用。但是，通常应避免使用它，因为它将代码耦合到 Spring，并且不遵循控制反转样式，在该样式中，将协作者作为属性提供给 bean。 <code>ApplicationContext</code>的其他方法提供对文件资源的访问，发布应用程序事件以及对<code>MessageSource</code>的访问。这些附加功能在<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#context-introduction rel=noopener target=_blank>ApplicationContext 的其他功能</a>中描述。</p> <p>当<code>ApplicationContext</code>创建一个实现该 <code>org.springframework.beans.factory.BeanNameAware</code>接口的类时，该类将获得对在其关联的对象定义中定义的名称的引用。以下清单显示了BeanNameAware接口的定义：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">BeanNameAware</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">setBeanName</span><span class=params>(String name)</span> <span class=keyword>throws</span> BeansException;</span><br><span class=line>}</span><br></pre></table></figure> <p>在填充常规 bean 属性之后但在初始化回调(例如<code>InitializingBean</code>，<code>afterPropertiesSet</code>或自定义 init-method)之前调用该回调。</p> <h4 id=2-1-6-3、其它Aware接口><a class=headerlink href=#2-1-6-3、其它Aware接口 title=2.1.6.3、其它Aware接口></a>2.1.6.3、其它Aware接口</h4><p>除了<code>ApplicationContextAware</code>和<code>BeanNameAware</code>（前面<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware rel=noopener target=_blank>已经</a>讨论<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware rel=noopener target=_blank>过</a>），Spring还提供了其它各种各样的<code>Aware</code>回调接口，这些接口使bean可以向容器指示它们需要某种基础结构依赖性。通常，名称表示依赖项类型。下表总结了最重要的<code>Aware</code>接口：</p> <table><thead><tr><th align=left>名称<th align=left>注入依赖<th align=left>在…中解释<tbody><tr><td align=left><code>ApplicationContextAware</code><td align=left>宣告<code>ApplicationContext</code>。<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware rel=noopener target=_blank><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a><tr><td align=left><code>ApplicationEventPublisherAware</code><td align=left>附件的事件发布者<code>ApplicationContext</code>。<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-introduction rel=noopener target=_blank>的其他功能 <code>ApplicationContext</code></a><tr><td align=left><code>BeanClassLoaderAware</code><td align=left>类加载器，用于加载Bean类。<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-class rel=noopener target=_blank>Instantiating Beans</a><tr><td align=left><code>BeanFactoryAware</code><td align=left>宣告<code>BeanFactory</code>。<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware rel=noopener target=_blank><code>ApplicationContextAware</code> 和 <code>BeanNameAware</code></a><tr><td align=left><code>BeanNameAware</code><td align=left>声明bean的名称。<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware rel=noopener target=_blank><code>ApplicationContextAware</code> 和 <code>BeanNameAware</code></a><tr><td align=left><code>LoadTimeWeaverAware</code><td align=left>定义的编织器，用于在加载时处理类定义。<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-aj-ltw rel=noopener target=_blank>在Spring Framework中使用AspectJ进行加载时编织</a><tr><td align=left><code>MessageSourceAware</code><td align=left>Configured strategy for resolving messages (with support for parametrization and internationalization).<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-introduction rel=noopener target=_blank>的其他功能 <code>ApplicationContext</code></a><tr><td align=left><code>NotificationPublisherAware</code><td align=left>Spring JMX通知发布者。<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#jmx-notifications rel=noopener target=_blank>通知事项</a><tr><td align=left><code>ResourceLoaderAware</code><td align=left>配置的加载程序，用于对资源的低级访问。<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources rel=noopener target=_blank>资源资源</a><tr><td align=left><code>ServletConfigAware</code><td align=left>当前<code>ServletConfig</code>容器在其中运行。仅在可感知网络的Spring中有效 <code>ApplicationContext</code>。<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc rel=noopener target=_blank>春季MVC</a><tr><td align=left><code>ServletContextAware</code><td align=left>当前<code>ServletContext</code>容器在其中运行。仅在可感知网络的Spring中有效 <code>ApplicationContext</code>。<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc rel=noopener target=_blank>春季MVC</a></table> <p>再次注意，使用这些接口会将您的代码与 Spring API 绑定在一起，并且不遵循“控制反转”样式。因此，我们建议将它们用于需要以编程方式访问容器的基础结构 Bean。</p> <h3 id=2-1-7、Bean定义继承><a class=headerlink href=#2-1-7、Bean定义继承 title=2.1.7、Bean定义继承></a>2.1.7、Bean定义继承</h3><p>Bean定义可以包含许多配置信息，包括构造函数参数，属性值和特定于容器的信息，例如初始化方法，静态工厂方法名称等。子bean定义从父定义继承配置数据。子定义可以覆盖某些值或根据需要添加其他值。使用父bean和子bean定义可以节省很多输入。实际上，这是一种模板形式。</p> <p>如果您以编程方式使用<code>ApplicationContext</code>接口，则子 Bean 定义由<code>ChildBeanDefinition</code>类表示。大多数用户不在此级别上与他们合作。相反，它们在<code>ClassPathXmlApplicationContext</code>之类的类中声明性地配置 bean 定义。使用基于 XML 的配置元数据时，可以通过使用<code>parent</code>属性(将父 bean 指定为该属性的值)来指示子 bean 定义。以下示例显示了如何执行此操作：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"inheritedTestBean"</span> <span class=attr>abstract</span>=<span class=string>"true"</span></span></span><br><span class=line><span class=tag>        <span class=attr>class</span>=<span class=string>"org.springframework.beans.TestBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"parent"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"age"</span> <span class=attr>value</span>=<span class=string>"1"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"inheritsWithDifferentClass"</span></span></span><br><span class=line><span class=tag>        <span class=attr>class</span>=<span class=string>"org.springframework.beans.DerivedTestBean"</span></span></span><br><span class=line><span class=tag>        <span class=attr>parent</span>=<span class=string>"inheritedTestBean"</span> <span class=attr>init-method</span>=<span class=string>"initialize"</span>></span>  </span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"override"</span>/></span></span><br><span class=line>    <span class=comment>&LT!-- the age property value of 1 will be inherited from parent --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>如果未指定子bean定义，则使用父定义中的bean类，但也可以覆盖它。在后一种情况下，子bean类必须与父类兼容（也就是说，它必须接受父类的属性值）。</p> <p>子 bean 定义从父对象继承范围，构造函数参数值，属性值和方法替代，并可以选择添加新值。您指定的任何范围，初始化方法，destroy 方法或<code>static</code>工厂方法设置都会覆盖相应的父设置。</p> <p>其余设置始终从子定义中获取：依赖项，自动装配模式，依赖项检查，单例和惰性初始化。</p> <p>前面的示例通过使用<code>abstract</code>属性将父 bean 定义显式标记为抽象。如果父定义未指定类，则需要将父 bean 定义显式标记为<code>abstract</code>，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"inheritedTestBeanWithoutClass"</span> <span class=attr>abstract</span>=<span class=string>"true"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"parent"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"age"</span> <span class=attr>value</span>=<span class=string>"1"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"inheritsWithClass"</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.DerivedTestBean"</span></span></span><br><span class=line><span class=tag>        <span class=attr>parent</span>=<span class=string>"inheritedTestBeanWithoutClass"</span> <span class=attr>init-method</span>=<span class=string>"initialize"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"override"</span>/></span></span><br><span class=line>    <span class=comment>&LT!-- age will inherit the value of 1 from the parent bean definition--></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>父 bean 不能单独实例化，因为它是不完整的，并且还被明确标记为<code>abstract</code>。当定义为<code>abstract</code>时，它只能用作纯模板 bean 定义，用作子定义的父定义。尝试单独使用此类<code>abstract</code>父 Bean(将其称为另一个 bean 的 ref 属性)或使用父 Bean ID 进行显式<code>getBean()</code>调用会返回错误。同样，容器的内部<code>preInstantiateSingletons()</code>方法将忽略定义为抽象的 bean 定义。</p> <blockquote><p><code>ApplicationContext</code>默认情况下预先实例化所有单例。因此，重要的是(至少对于单例 bean)，如果您有一个(父)bean 定义仅打算用作模板，并且此定义指定了一个类，则必须确保设置* abstract <em>属性为</em> true *，否则应用程序上下文将实际(尝试)预先实例化<code>abstract</code> bean。</blockquote> <h3 id=2-1-8、容器延伸><a class=headerlink href=#2-1-8、容器延伸 title=2.1.8、容器延伸></a>2.1.8、容器延伸</h3><h4 id=2-1-8-1、使用BeanPostProcessor定义Bean><a class=headerlink href=#2-1-8-1、使用BeanPostProcessor定义Bean title=2.1.8.1、使用BeanPostProcessor定义Bean></a>2.1.8.1、使用BeanPostProcessor定义Bean</h4><p><code>BeanPostProcessor</code>接口定义了回调方法，您可以实现这些回调方法，以提供自己的(或覆盖容器的默认值)实例化逻辑，依赖项解析逻辑等。如果您想在 Spring 容器完成实例化，配置和初始化 bean 之后实现一些自定义逻辑，则可以插入一个或多个<code>BeanPostProcessor</code>实现。</p> <p>您可以配置多个<code>BeanPostProcessor</code>实例，并且可以通过设置<code>order</code>属性来控制这些<code>BeanPostProcessor</code>实例的执行 Sequences。仅当<code>BeanPostProcessor</code>实现<code>Ordered</code>接口时，才可以设置此属性。如果您编写自己的<code>BeanPostProcessor</code>，则也应该考虑实现<code>Ordered</code>接口。有关更多详细信息，请参见<a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html rel=noopener target=_blank>BeanPostProcessor</a>和<a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/Ordered.html rel=noopener target=_blank>Ordered</a>接口的 javadoc。另请参见<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-programmatically-registering-beanpostprocessors rel=noopener target=_blank>BeanPostProcessor 实例的编程注册</a>上的 注解。</p> <p><code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口恰好由两个回调方法组成。当此类被注册为容器的后处理器时，对于容器创建的每个 bean 实例，后处理器都会在容器初始化方法(例如<code>InitializingBean.afterPropertiesSet()</code>，任何已声明的<code>init</code>之后)之前从容器获取回调。方法)，并在任何 bean 初始化回调之后调用。后处理器可以对 bean 实例执行任何操作，包括完全忽略回调。 Bean 后处理器通常检查回调接口，或者可以用代理包装 Bean。一些 Spring AOP 基础结构类被实现为 bean 后处理器，以提供代理包装逻辑。</p> <p><code>ApplicationContext</code>自动检测实现<code>BeanPostProcessor</code>接口的配置元数据中定义的所有 bean。 <code>ApplicationContext</code>将这些 bean 注册为后处理器，以便以后在 bean 创建时可以调用它们。 Bean 后处理器可以以与其他任何 Bean 相同的方式部署在容器中。</p> <p>请注意，在配置类上使用<code>@Bean</code>工厂方法声明<code>BeanPostProcessor</code>时，工厂方法的返回类型应该是实现类本身或至少是<code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口，从而清楚地表明该 bean 的后处理器性质。否则，<code>ApplicationContext</code>无法在完全创建之前按类型自动检测它。由于<code>BeanPostProcessor</code>需要提早实例化以便应用于上下文中其他 bean 的初始化，因此这种提早类型检测至关重要。</p> <blockquote><ul><li>以编程方式注册<code>BeanPostProcessor</code>实例</ul><p>虽然推荐的<code>BeanPostProcessor</code>注册方法是通过 <code>ApplicationContext</code>自动检测（如前所述），但是您可以<code>ConfigurableBeanFactory</code>使用<code>addBeanPostProcessor</code> 方法通过编程方式将它们注册。当您需要在注册之前评估条件逻辑，甚至需要跨层次结构的上下文复制Bean后处理器时，这将非常有用。但是请注意，以<code>BeanPostProcessor</code>编程方式添加的实例不遵守该<code>Ordered</code>接口。在这里，注册的顺序决定了执行的顺序。还要注意，以<code>BeanPostProcessor</code>编程方式注册的实例总是在通过自动检测注册的实例之前进行处理，而不考虑任何明确的顺序。<ul><li><p><code>BeanPostProcessor</code> 实例和AOP自动代理</p> <p>如果您<code>BeanPostProcessor</code>使用自动装配或<code>@Resource</code>（可能会退回到自动装配）将bean连接到您的 bean ，Spring在搜索类型匹配的依赖项候选对象时可能会访问意外的bean，因此使它们不符合自动代理或其他类型的bean的要求。处理。例如，如果您有一个依赖项，其注释<code>@Resource</code>的字段或设置器名称不直接与bean的声明名称相对应，并且不使用name属性，那么Spring将访问其他bean以按类型匹配它们。</p></ul></blockquote> <h5 id=示例：Hello-world，BeanPostProcessor><a title="示例：Hello world，BeanPostProcessor" class=headerlink href=#示例：Hello-world，BeanPostProcessor></a>示例：Hello world，BeanPostProcessor</h5><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> scripting;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">InstantiationTracingBeanPostProcessor</span> <span class=keyword>implements</span> <span class="title class_">BeanPostProcessor</span> {</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class=params>(Object bean, String beanName)</span> {</span><br><span class=line>        <span class=keyword>return</span> bean;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class=params>(Object bean, String beanName)</span> {</span><br><span class=line>        System.out.println(<span class=string>"Bean '"</span> + beanName + <span class=string>"' created : "</span> + bean.toString());</span><br><span class=line>        <span class=keyword>return</span> bean;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>以下<code>beans</code>元素使用<code>InstantiationTracingBeanPostProcessor</code>：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:lang</span>=<span class=string>"http://www.springframework.org/schema/lang"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/lang</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/lang/spring-lang.xsd"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>lang:groovy</span> <span class=attr>id</span>=<span class=string>"messenger"</span> <span class=attr>script-source</span>=<span class=string>"classpath:org/springframework/scripting/groovy/Messenger.groovy"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>lang:property</span> <span class=attr>name</span>=<span class=string>"message"</span> <span class=attr>value</span>=<span class=string>"Fiona Apple Is Just So Dreamy."</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>lang:groovy</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"scripting.InstantiationTracingBeanPostProcessor"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>注意<code>InstantiationTracingBeanPostProcessor</code>是如何定义的。它甚至没有名称，并且因为它是 Bean，所以可以像注入其他任何 Bean 一样对其进行依赖注入。</p> <p>以下Java应用程序运行上述代码和配置：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.context.ApplicationContext;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class=line><span class=keyword>import</span> org.springframework.scripting.Messenger;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>class</span> <span class="title class_">Boot</span> {</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(<span class=keyword>final</span> String[] args)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>ApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class=string>"scripting/beans.xml"</span>);</span><br><span class=line>        <span class=type>Messenger</span> <span class=variable>messenger</span> <span class=operator>=</span> ctx.getBean(<span class=string>"messenger"</span>, Messenger.class);</span><br><span class=line>        System.out.println(messenger);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure> <p>前面的应用程序的输出类似于以下内容：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>Bean 'messenger' created : org.springframework.scripting.groovy.GroovyMessenger@272961</span><br><span class=line>org.springframework.scripting.groovy.GroovyMessenger@272961</span><br></pre></table></figure> <h5 id=示例：-RequiredAnnotationBeanPostProcessor><a title="示例： RequiredAnnotationBeanPostProcessor" class=headerlink href=#示例：-RequiredAnnotationBeanPostProcessor></a>示例： RequiredAnnotationBeanPostProcessor</h5><p>将回调接口或注释与自定义<code>BeanPostProcessor</code>实现结合使用 是扩展Spring IoC容器的常用方法。一个例子是Spring的<code>RequiredAnnotationBeanPostProcessor</code> -一个<code>BeanPostProcessor</code>Spring发行版附带的 实现，它确保标记了（任意）批注的bean上的JavaBean属性实际上（配置为）依赖注入了一个值。</p> <h4 id=2-1-8-2、使用BeanFactoryPostProcessor自定义配置元数据><a class=headerlink href=#2-1-8-2、使用BeanFactoryPostProcessor自定义配置元数据 title=2.1.8.2、使用BeanFactoryPostProcessor自定义配置元数据></a>2.1.8.2、使用BeanFactoryPostProcessor自定义配置元数据</h4><h5 id=示例：类名替换-PropertySourcesPlaceholderConfigurer><a title="示例：类名替换 PropertySourcesPlaceholderConfigurer" class=headerlink href=#示例：类名替换-PropertySourcesPlaceholderConfigurer></a>示例：类名替换 PropertySourcesPlaceholderConfigurer</h5><p>考虑以下基于 XML 的配置元数据片段，其中定义了带有占位符值的<code>DataSource</code>：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.context.support.PropertySourcesPlaceholderConfigurer"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"locations"</span> <span class=attr>value</span>=<span class=string>"classpath:com/something/jdbc.properties"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"dataSource"</span> <span class=attr>destroy-method</span>=<span class=string>"close"</span> <span class=attr>class</span>=<span class=string>"org.apache.commons.dbcp.BasicDataSource"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"driverClassName"</span> <span class=attr>value</span>=<span class=string>"${jdbc.driverClassName}"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"url"</span> <span class=attr>value</span>=<span class=string>"${jdbc.url}"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"username"</span> <span class=attr>value</span>=<span class=string>"${jdbc.username}"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"password"</span> <span class=attr>value</span>=<span class=string>"${jdbc.password}"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>该示例显示了从外部<code>Properties</code>文件配置的属性。在运行时，将<code>PropertyPlaceholderConfigurer</code>应用于替换数据源的某些属性的元数据。将要替换的值指定为<code>${property-name}</code>形式的占位符，该形式遵循 Ant 和 log4j 和 JSP EL 样式。</p> <p>实际值来自标准Java<code>Properties</code>格式的另一个文件：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>jdbc.driverClassName = org.hsqldb.jdbcDriver</span><br><span class=line>jdbc.url = jdbc：hsqldb：hsql：// production：9002</span><br><span class=line>jdbc.username = sa</span><br><span class=line>jdbc.password =根</span><br></pre></table></figure> <p>因此，在运行时将<code>${jdbc.username}</code>字符串替换为值“ sa”，并且其他与属性文件中的键匹配的占位符值也是如此。 <code>PropertyPlaceholderConfigurer</code>检查 bean 定义的大多数属性和属性中的占位符。此外，您可以自定义占位符前缀和后缀。</p> <p>使用 Spring 2.5 中引入的<code>context</code>名称空间，您可以使用专用配置元素配置属性占位符。您可以在<code>location</code>属性中以逗号分隔列表的形式提供一个或多个位置，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>context:property-placeholder</span> <span class=attr>location</span>=<span class=string>"classpath:com/something/jdbc.properties"</span>/></span></span><br></pre></table></figure> <p><code>PropertyPlaceholderConfigurer</code>不仅在您指定的<code>Properties</code>文件中查找属性。默认情况下，如果无法在指定的属性文件中找到属性，则还会检查 Java <code>System</code>属性。您可以通过使用以下三个受支持的整数值之一设置配置程序的<code>systemPropertiesMode</code>属性来自定义此行为：</p> <ul><li><code>never</code>(0)：从不检查系统属性。<li><code>fallback</code>(1)：检查系统属性是否在指定的属性文件中不可解析。这是默认值。<li><code>override</code>(2)：在尝试指定的属性文件之前，请先检查系统属性。这使系统属性可以覆盖任何其他属性源。</ul> <h5 id=示例：-PropertyOverrideConfigurer><a title="示例： PropertyOverrideConfigurer" class=headerlink href=#示例：-PropertyOverrideConfigurer></a>示例： PropertyOverrideConfigurer</h5><p><code>PropertyOverrideConfigurer</code>是另一个 Bean 工厂后处理程序，类似于<code>PropertyPlaceholderConfigurer</code>，但是与后者不同，原始定义对于 Bean 属性可以具有默认值或完全没有值。如果覆盖的<code>Properties</code>文件没有某个 bean 属性的条目，则使用默认的上下文定义。</p> <p>bean定义不知道会被覆盖，因此从XML定义文件中不能立即看出正在使用覆盖配置器。如果有多个<code>PropertyOverrideConfigurer</code>实例为同一个bean属性定义了不同的值，则由于覆盖机制，最后一个实例将获胜。</p> <p>属性文件配置行采用以下格式：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>beanName.property =值</span><br></pre></table></figure> <p>下面的清单显示了格式的示例：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>dataSource.driverClassName = com.mysql.jdbc.Driver</span><br><span class=line>dataSource.url = jdbc：mysql：mydb</span><br></pre></table></figure> <p>此示例文件可与包含定义为<code>dataSource</code>具有<code>driver</code>和<code>url</code>属性的bean的容器定义一起使用 。</p> <p>使用<code>context</code>Spring 2.5中引入的名称空间，可以使用专用的配置元素配置属性覆盖，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>context:property-override</span> <span class=attr>location</span>=<span class=string>"classpath:override.properties"</span>/></span></span><br></pre></table></figure> <h4 id=2-1-8-3、使用FactoryBean自定义实例化><a class=headerlink href=#2-1-8-3、使用FactoryBean自定义实例化 title=2.1.8.3、使用FactoryBean自定义实例化></a>2.1.8.3、使用FactoryBean自定义实例化</h4><p>您可以为本身就是工厂的对象实现<code>org.springframework.beans.factory.FactoryBean</code>接口。</p> <p>该<code>FactoryBean</code>界面提供了三种方法：</p> <ul><li><code>Object getObject()</code>：返回此工厂创建的对象的实例。实例可以共享，具体取决于该工厂是否返回单例或原型。<li><code>boolean isSingleton()</code>：如果此<code>FactoryBean</code>返回单例，则返回<code>true</code>，否则返回<code>false</code>。<li><code>Class getObjectType()</code>：返回由<code>getObject()</code>方法或<code>null</code>返回的对象类型(如果事先未知)。</ul> <p><code>FactoryBean</code>概念和界面在 Spring Framework 中的许多地方都使用过。 Spring 本身附带了<code>FactoryBean</code>接口的 50 多种实现。</p> <p>当您需要向容器请求一个实际的<code>FactoryBean</code>实例本身而不是它生成的 bean 时，请在调用<code>ApplicationContext</code>的<code>getBean()</code>方法时在 bean 的<code>id</code>前面加上一个＆符号(<code>&</code>)。因此，对于给定的<code>id</code> <code>myBean</code>的<code>FactoryBean</code>，在容器上调用<code>getBean("myBean")</code>返回<code>FactoryBean</code>的乘积，而调用<code>getBean("&myBean")</code>则返回<code>FactoryBean</code>实例本身。</p> <h3 id=2-1-9、基于注释的容器配置><a class=headerlink href=#2-1-9、基于注释的容器配置 title=2.1.9、基于注释的容器配置></a>2.1.9、基于注释的容器配置</h3><p>基于注解的配置提供了 XML 设置的替代方法，该配置依赖字节码元数据来连接组件，而不是尖括号声明。通过使用相关类，方法或字段声明上的 注解，开发人员无需使用 XML 来描述 bean 的连接，而是将配置移入组件类本身。</p> <h4 id=2-1-9-1、-Required><a class=headerlink href=#2-1-9-1、-Required title=2.1.9.1、@Required></a>2.1.9.1、@Required</h4><p>该注解适用于bean属性setter方法，如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=meta>@Required</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <blockquote><p><code>@Required</code>从Spring Framework 5.1开始，正式弃用了该批注，以支持对必需的设置（或<code>InitializingBean.afterPropertiesSet()</code>Bean属性setter方法的自定义实现）使用构造函数注入 。</blockquote> <h4 id=2-1-9-2、使用-Autowired><a class=headerlink href=#2-1-9-2、使用-Autowired title=2.1.9.2、使用@Autowired></a>2.1.9.2、使用@Autowired</h4><p>您可以将<code>@Autowired</code>注释应用于构造函数，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MovieRecommender</span><span class=params>(CustomerPreferenceDao customerPreferenceDao)</span> {</span><br><span class=line>        <span class=built_in>this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <blockquote><p>从 Spring Framework 4.3 开始，如果目标 bean 仅定义一个构造函数作为开始，则不再需要在此类构造函数上使用<code>@Autowired</code>注解。但是，如果有几个构造函数可用，则必须至少注解一个，以告诉容器使用哪个构造函数。</blockquote> <p>您还可以将<code>@Autowired</code>注释应用于<em>传统的</em>setter方法，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>您还可以将注释应用于具有任意名称和多个参数的方法，如下示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieCatalog movieCatalog;</span><br><span class=line>    <span class=keyword>private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">prepare</span><span class=params>(MovieCatalog movieCatalog,</span></span><br><span class=line><span class=params>            CustomerPreferenceDao customerPreferenceDao)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieCatalog = movieCatalog;</span><br><span class=line>        <span class=built_in>this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>您也可以将<code>@Autowired</code>应用于字段，甚至将其与构造函数混合使用，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> MovieCatalog movieCatalog;</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MovieRecommender</span><span class=params>(CustomerPreferenceDao customerPreferenceDao)</span> {</span><br><span class=line>        <span class=built_in>this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <h4 id=2-1-9-3、使用-Primary><a class=headerlink href=#2-1-9-3、使用-Primary title=2.1.9.3、使用@Primary></a>2.1.9.3、使用@Primary</h4><p><code>@Primary</code>表示当多个 bean 可以自动连接到单值依赖项的候选对象时，应优先考虑特定的 bean。如果候选中恰好存在一个主 bean，则它将成为自动装配的值。</p> <p>考虑以下将<code>firstMovieCatalog</code>定义为主<code>MovieCatalog</code>的配置：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieConfiguration</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=meta>@Primary</span></span><br><span class=line>    <span class=keyword>public</span> MovieCatalog <span class="title function_">firstMovieCatalog</span><span class=params>()</span> { ... }</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> MovieCatalog <span class="title function_">secondMovieCatalog</span><span class=params>()</span> { ... }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>使用前面的配置，下面的<code>MovieRecommender</code>与<code>firstMovieCatalog</code>自动连接：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> MovieCatalog movieCatalog;</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>相应的bean定义如下：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:context</span>=<span class=string>"http://www.springframework.org/schema/context"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/context</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/context/spring-context.xsd"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>context:annotation-config</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"example.SimpleMovieCatalog"</span> <span class=attr>primary</span>=<span class=string>"true"</span>></span></span><br><span class=line>        <span class=comment>&LT!-- inject any dependencies required by this bean --></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"example.SimpleMovieCatalog"</span>></span></span><br><span class=line>        <span class=comment>&LT!-- inject any dependencies required by this bean --></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"movieRecommender"</span> <span class=attr>class</span>=<span class=string>"example.MovieRecommender"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h4 id=2-1-9-4、使用限定符><a class=headerlink href=#2-1-9-4、使用限定符 title=2.1.9.4、使用限定符></a>2.1.9.4、使用限定符</h4><p>当可以确定一个主要候选对象时，<code>@Primary</code>是在几种情况下按类型使用自动装配的有效方法。当您需要对选择过程进行更多控制时，可以使用 Spring 的<code>@Qualifier</code>注解。您可以将限定符值与特定的参数相关联，从而缩小类型匹配的范围，以便为每个参数选择特定的 bean。在最简单的情况下，这可以是简单的描述性值，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=meta>@Qualifier("main")</span></span><br><span class=line>    <span class=keyword>private</span> MovieCatalog movieCatalog;</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>您还可以在各个构造函数参数或方法参数上指定<code>@Qualifier</code>注解，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieCatalog movieCatalog;</span><br><span class=line>    <span class=keyword>private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">prepare</span><span class=params>(<span class=meta>@Qualifier("main")</span> MovieCatalog movieCatalog,</span></span><br><span class=line><span class=params>            CustomerPreferenceDao customerPreferenceDao)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieCatalog = movieCatalog;</span><br><span class=line>        <span class=built_in>this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>以下示例显示了相应的bean定义。</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:context</span>=<span class=string>"http://www.springframework.org/schema/context"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/context</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/context/spring-context.xsd"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>context:annotation-config</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"example.SimpleMovieCatalog"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>qualifier</span> <span class=attr>value</span>=<span class=string>"main"</span>/></span> </span><br><span class=line>        <span class=comment>&LT!-- inject any dependencies required by this bean --></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"example.SimpleMovieCatalog"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>qualifier</span> <span class=attr>value</span>=<span class=string>"action"</span>/></span> </span><br><span class=line>        <span class=comment>&LT!-- inject any dependencies required by this bean --></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"movieRecommender"</span> <span class=attr>class</span>=<span class=string>"example.MovieRecommender"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <ol><li>具有<code>main</code>限定符值的Bean与限定有相同值的构造函数参数连接。<li>具有<code>action</code>限定符值的Bean与限定有相同值的构造函数参数连接。</ol> <h4 id=2-1-9-5、将泛型用作自动装配限定符><a class=headerlink href=#2-1-9-5、将泛型用作自动装配限定符 title=2.1.9.5、将泛型用作自动装配限定符></a>2.1.9.5、将泛型用作自动装配限定符</h4><p>除了<code>@Qualifier</code>注释之外，您还可以将Java泛型类型用作资格的隐式形式。例如，假设您具有以下配置：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyConfiguration</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> StringStore <span class="title function_">stringStore</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">StringStore</span>();</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> IntegerStore <span class="title function_">integerStore</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">IntegerStore</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>假设前面的 bean 实现了通用接口(即<code>Store&LTString></code>和<code>Store&LTInteger></code>)，则可以<code>@Autowire</code> <code>Store</code>接口，并且通用接口用作限定符，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Autowired</span></span><br><span class=line><span class=keyword>private</span> Store&LTString> s1; <span class=comment>// &LTString> qualifier, injects the stringStore bean</span></span><br><span class=line><span class=meta>@Autowired</span></span><br><span class=line><span class=keyword>private</span> Store&LTInteger> s2; <span class=comment>// &LTInteger> qualifier, injects the integerStore bean</span></span><br></pre></table></figure> <p>当自动装配列表，<code>Map</code>实例和数组时，通用限定符也适用。下面的示例自动连接泛型<code>List</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>// Inject all Store beans as long as they have an &LTInteger> generic</span></span><br><span class=line><span class=comment>// Store&LTString> beans will not appear in this list</span></span><br><span class=line><span class=meta>@Autowired</span></span><br><span class=line><span class=keyword>private</span> List&LTStore&LTInteger>> s;</span><br></pre></table></figure> <h4 id=2-1-9-6、使用CustomAutowireConfigurer><a class=headerlink href=#2-1-9-6、使用CustomAutowireConfigurer title=2.1.9.6、使用CustomAutowireConfigurer></a>2.1.9.6、使用CustomAutowireConfigurer</h4><p><a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html rel=noopener target=_blank>CustomAutowireConfigurer</a>是<code>BeanFactoryPostProcessor</code>，即使您没有使用 Spring 的<code>@Qualifier</code>注解 对您自己的自定义限定符注解类型进行注册，您也可以使用它们。以下示例显示了如何使用<code>CustomAutowireConfigurer</code>：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"customAutowireConfigurer"</span></span></span><br><span class=line><span class=tag>  <span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.annotation.CustomAutowireConfigurer"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"customQualifierTypes"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>set</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>example.CustomQualifier<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>set</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p><code>AutowireCandidateResolver</code>通过以下方式确定自动装配的候选对象：</p> <ul><li>每个 bean 定义的<code>autowire-candidate</code>值。<li><code>&LTbeans/></code>元素上可用的任何<code>default-autowire-candidates</code>模式。<li><code>@Qualifier</code>注解 和在<code>CustomAutowireConfigurer</code>中注册的所有自定义注解的存在。</ul> <p>当多个 bean 可以作为自动装配候选者时，确定“主要”的步骤如下：如果候选者中恰好有一个 bean 定义具有<code>primary</code>属性设置为<code>true</code>，则将其选中。</p> <h4 id=2-1-9-7、使用-Resource注入><a class=headerlink href=#2-1-9-7、使用-Resource注入 title=2.1.9.7、使用@Resource注入></a>2.1.9.7、使用@Resource注入</h4><p>Spring 还通过在字段或 bean 属性设置器方法上使用 JSR-250 <code>@Resource</code>注解 来支持注入。这是 Java EE 5 和 6 中的常见模式(例如，在 JSF 1.2 托管 Bean 或 JAX-WS 2.0 端点中)。 Spring 也为 SpringManagement 的对象支持此模式。</p> <p><code>@Resource</code>具有名称属性。默认情况下，Spring将该值解释为要注入的Bean名称。换句话说，它遵循名称语义，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=meta>@Resource(name="myMovieFinder")</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>下面的示例将名为bean<code>movieFinder</code>的setter方法注入：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=meta>@Resource</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure> <p>在未使用<code>@Resource</code>且未指定显式名称且与<code>@Autowired</code>类似的特殊情况下，<code>@Resource</code>查找主类型匹配而不是特定的命名 bean，并解析众所周知的可解决依赖项：<code>BeanFactory</code>，<code>ApplicationContext</code>，<code>ResourceLoader</code>，<code>ApplicationEventPublisher</code>和<code>MessageSource</code>接口。</p> <p>在下面的示例中，<code>customerPreferenceDao</code>字段首先查找名为 customerPreferenceDao 的 bean，然后回退到类型<code>CustomerPreferenceDao</code>的主类型匹配：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=meta>@Resource</span></span><br><span class=line>    <span class=keyword>private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class=line>    <span class=meta>@Resource</span></span><br><span class=line>    <span class=keyword>private</span> ApplicationContext context; </span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MovieRecommender</span><span class=params>()</span> {</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <h4 id=2-1-9-8、使用-Value><a class=headerlink href=#2-1-9-8、使用-Value title=2.1.9.8、使用@Value></a>2.1.9.8、使用@Value</h4><p><code>@Value</code> 通常用于注入外部属性：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> String catalog;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MovieRecommender</span><span class=params>(<span class=meta>@Value("${catalog.name}")</span> String catalog)</span> {</span><br><span class=line>        <span class=built_in>this</span>.catalog = catalog;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>使用以下配置：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@PropertySource("classpath:application.properties")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> { }</span><br></pre></table></figure> <p>和以下<code>application.properties</code>文件：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>catalog.name=MovieCatalog</span><br></pre></table></figure> <p>在这种情况下，<code>catalog</code>参数和字段将等于<code>MovieCatalog</code>值。</p> <p>Spring提供了一个默认的宽松内嵌值解析器。它将尝试解析属性值，如果无法解析，<code>${catalog.name}</code>则将注入属性名称（例如）作为值。如果要严格控制不存在的值，则应声明一个<code>PropertySourcesPlaceholderConfigurer</code>bean，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>     <span class=meta>@Bean</span></span><br><span class=line>     <span class=keyword>public</span> <span class=keyword>static</span> PropertySourcesPlaceholderConfigurer <span class="title function_">propertyPlaceholderConfigurer</span><span class=params>()</span> {</span><br><span class=line>           <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">PropertySourcesPlaceholderConfigurer</span>();</span><br><span class=line>     }</span><br><span class=line>}</span><br></pre></table></figure> <blockquote><p>当配置<code>PropertySourcesPlaceholderConfigurer</code>使用JavaConfig，该 <code>@Bean</code>方法必须是<code>static</code>。</blockquote> <p>如果<code>${}</code> 无法解析任何占位符，则使用上述配置可确保Spring初始化失败。也可以使用<code>setPlaceholderPrefix</code>、<code>setPlaceholderSuffix</code>、<code>setValueSeparator</code>之类的方法自定义占位符。</p> <blockquote><p>默认情况下，Spring Boot配置一个<code>PropertySourcesPlaceholderConfigurer</code>Bean，它将从<code>application.properties</code>和<code>application.yml</code>文件中获取属性。</blockquote> <p>当<code>@Value</code>包含<code>Spring EL</code>表达式时该值将在运行时动态计算，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> String catalog;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MovieRecommender</span><span class=params>(<span class=meta>@Value("#{systemProperties['user.catalog'] + 'Catalog' }")</span> String catalog)</span> {</span><br><span class=line>        <span class=built_in>this</span>.catalog = catalog;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>Spring EL还支持使用更复杂的数据结构：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> Map&LTString, Integer> countOfMoviesPerCatalog;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MovieRecommender</span><span class=params>(</span></span><br><span class=line><span class=params>            <span class=meta>@Value("#{{'Thriller': 100, 'Comedy': 300}}")</span> Map&LTString, Integer> countOfMoviesPerCatalog)</span> {</span><br><span class=line>        <span class=built_in>this</span>.countOfMoviesPerCatalog = countOfMoviesPerCatalog;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=2-1-9-9、使用-PostConstruct和-PreDestroy><a class=headerlink href=#2-1-9-9、使用-PostConstruct和-PreDestroy title=2.1.9.9、使用@PostConstruct和@PreDestroy></a>2.1.9.9、使用@PostConstruct和@PreDestroy</h4><p><code>CommonAnnotationBeanPostProcessor</code>不仅可以识别<code>@Resource</code>注解，还可以识别 JSR-250 生命周期 注解。在 Spring 2.5 中引入了对这些注解的支持，为<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean rel=noopener target=_blank>initialization callbacks</a>和<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-disposablebean rel=noopener target=_blank>destruction callbacks</a>中描述的注解提供了另一种选择。假设<code>CommonAnnotationBeanPostProcessor</code>已在 Spring <code>ApplicationContext</code>中注册，则在生命周期的同一点与相应的 Spring 生命周期接口方法或显式声明的回调方法一起调用带有这些注解之一的方法。</p> <p>在以下示例中，缓存在初始化时预先填充，并在销毁时清除：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CachingMovieLister</span> {</span><br><span class=line>    <span class=meta>@PostConstruct</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">populateMovieCache</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// populates the movie cache upon initialization...</span></span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@PreDestroy</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">clearMovieCache</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// clears the movie cache upon destruction...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <blockquote><p>和<code>@Resource</code>一样，<code>@PostConstruct</code>和<code>@PreDestroy</code>注释类型是JDK 6到8的标准Java库的一部分。但是，整个<code>javax.annotation</code> 包都与JDK 9中的核心Java模块分开，并最终在JDK 11中删除。如果需要，需要将<code>javax.annotation-api</code>工件现在可以通过Maven Central获得，只需像其他任何库一样将其添加到应用程序的类路径中即可。</blockquote> <h3 id=2-1-10、类路径扫描和托管组件><a class=headerlink href=#2-1-10、类路径扫描和托管组件 title=2.1.10、类路径扫描和托管组件></a>2.1.10、类路径扫描和托管组件</h3><h4 id=2-1-10-1、-Component和其它注解><a class=headerlink href=#2-1-10-1、-Component和其它注解 title=2.1.10.1、@Component和其它注解></a>2.1.10.1、@Component和其它注解</h4><p>Spring提供进一步典型化注解：<code>@Component</code>，<code>@Service</code>，和 <code>@Controller</code>。<code>@Component</code>是任何Spring托管组件的通用构造型。 <code>@Repository</code>，<code>@Service</code>和<code>@Controller</code>分别是<code>@Component</code>针对特定用例的专业化（分别在持久性，服务和表示层）。</p> <p><code>@Repository</code>，<code>@Service</code>和<code>@Controller</code>在 Spring 框架的 Future 发行版中还可包含其他语义。因此，如果在服务层使用<code>@Component</code>或<code>@Service</code>之间进行选择，则<code>@Service</code>显然是更好的选择。同样，如前所述，<code>@Repository</code>已被支持作为持久层中自动异常转换的标记。</p> <h4 id=2-1-10-2、使用元注释和组合注释><a class=headerlink href=#2-1-10-2、使用元注释和组合注释 title=2.1.10.2、使用元注释和组合注释></a>2.1.10.2、使用元注释和组合注释</h4><p>Spring提供的许多注释都可以在您自己的代码中用作元注释。元注释是可以应用于另一个注释的注释。如下面的示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Target(ElementType.TYPE)</span></span><br><span class=line><span class=meta>@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=line><span class=meta>@Documented</span></span><br><span class=line><span class=meta>@Component</span> </span><br><span class=line><span class=keyword>public</span> <span class=meta>@interface</span> Service {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p><code>Component</code>导致<code>@Service</code>的处理方式与<code>@Component</code>相同。</p> <p>您还可以结合使用元注解来创建“组合 注解”。例如，Spring MVC 的<code>@RestController</code>注解 由<code>@Controller</code>和<code>@ResponseBody</code>组成。</p> <p>此外，组合注释可以选择从元注释中重新声明属性，以允许自定义。以下清单显示了<code>SessionScope</code>注释的定义 ：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>@Target({ElementType.TYPE, ElementType.METHOD})</span></span><br><span class=line><span class=meta>@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=line><span class=meta>@Documented</span></span><br><span class=line><span class=meta>@Scope(WebApplicationContext.SCOPE_SESSION)</span></span><br><span class=line><span class=keyword>public</span> <span class=meta>@interface</span> SessionScope {</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * Alias for {<span class=doctag>@link</span> Scope#proxyMode}.</span></span><br><span class=line><span class=comment>     * &LTp>Defaults to {<span class=doctag>@link</span> ScopedProxyMode#TARGET_CLASS}.</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=meta>@AliasFor(annotation = Scope.class)</span></span><br><span class=line>    ScopedProxyMode <span class="title function_">proxyMode</span><span class=params>()</span> <span class=keyword>default</span> ScopedProxyMode.TARGET_CLASS;</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure> <p>然后，您可以使用<code>@SessionScope</code>而不用声明<code>proxyMode</code>，如下所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=meta>@SessionScope</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SessionScopedService</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>您还可以覆盖<code>proxyMode</code>的值，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=meta>@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SessionScopedUserService</span> <span class=keyword>implements</span> <span class="title class_">UserService</span> {</span><br><span class=line>    <span class=comment>// ..</span></span><br><span class=line>}</span><br></pre></table></figure> <h4 id=2-1-10-3、自动检测类并注册Bean定义><a class=headerlink href=#2-1-10-3、自动检测类并注册Bean定义 title=2.1.10.3、自动检测类并注册Bean定义></a>2.1.10.3、自动检测类并注册Bean定义</h4><p>Spring 可以自动检测构造型类，并向<code>ApplicationContext</code>注册相应的<code>BeanDefinition</code>实例。例如，以下两个类别有资格进行这种自动检测：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">SimpleMovieLister</span><span class=params>(MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Repository</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">JpaMovieFinder</span> <span class=keyword>implements</span> <span class="title class_">MovieFinder</span> {</span><br><span class=line>    <span class=comment>// implementation elided for clarity</span></span><br><span class=line>}</span><br></pre></table></figure> <p>要自动检测这些类并注册相应的bean，您需要添加 <code>@ComponentScan</code>到<code>@Configuration</code>类中，其中<code>basePackages</code>属性是两个类的公共父包。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@ComponentScan(basePackages = "org.example")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span>  {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>以下替代方法使用XML：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:context</span>=<span class=string>"http://www.springframework.org/schema/context"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/context</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/context/spring-context.xsd"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>context:component-scan</span> <span class=attr>base-package</span>=<span class=string>"org.example"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>此外，当您使用component-scan元素时，<code>AutowiredAnnotationBeanPostProcessor</code>和 <code>CommonAnnotationBeanPostProcessor</code>都隐式包括在内。这意味着将自动检测这两个组件并将它们连接在一起，而这一切都不需要XML中提供的任何bean配置元数据。</p> <blockquote><p>您可以通过包含注解<code>annotation-config</code>设置属性<code>false</code>来禁用<code>AutowiredAnnotationBeanPostProcessor</code>和<code>CommonAnnotationBeanPostProcessor</code>的注册。</blockquote> <h4 id=2-1-10-4、使用过滤器自定义扫描><a class=headerlink href=#2-1-10-4、使用过滤器自定义扫描 title=2.1.10.4、使用过滤器自定义扫描></a>2.1.10.4、使用过滤器自定义扫描</h4><p>默认情况下，唯一检测到的候选组件是用<code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code>注解 的类或本身用<code>@Component</code>注解 的定制 注解。但是，您可以通过应用自定义过滤器来修改和扩展此行为。将它们添加为<code>@ComponentScan</code>注解的<code>includeFilters</code>或<code>excludeFilters</code>参数(或<code>component-scan</code>元素的<code>include-filter</code>或<code>exclude-filter</code>子元素)。每个过滤器元素都需要<code>type</code>和<code>expression</code>属性。下表描述了过滤选项：</p> <table><thead><tr><th align=left>过滤器类型<th align=left>范例表达<th align=left>描述<tbody><tr><td align=left>annotation（default）<td align=left><code>org.example.SomeAnnotation</code><td align=left>在目标组件中的类型级别上要<em>存在</em>或<em>元存在</em>的注释。<tr><td align=left>assignable<td align=left><code>org.example.SomeClass</code><td align=left>目标组件可分配给（扩展或实现）的类（或接口）。<tr><td align=left>aspectj<td align=left><code>org.example..*Service+</code><td align=left>目标组件要匹配的AspectJ类型表达式。<tr><td align=left>regex<td align=left><code>org\.example\.Default.*</code><td align=left>要与目标组件的类名匹配的正则表达式。<tr><td align=left>custom<td align=left><code>org.example.MyTypeFilter</code><td align=left><code>org.springframework.core.type.TypeFilter</code>接口的自定义实现。</table> <p>以下示例显示了忽略所有<code>@Repository</code>注释并改为使用“存根”存储库的配置：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@ComponentScan(basePackages = "org.example",</span></span><br><span class=line><span class=meta>        includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"),</span></span><br><span class=line><span class=meta>        excludeFilters = @Filter(Repository.class))</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    ...</span><br><span class=line>}</span><br></pre></table></figure> <p>以下清单显示了等效的XML：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>context:component-scan</span> <span class=attr>base-package</span>=<span class=string>"org.example"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>context:include-filter</span> <span class=attr>type</span>=<span class=string>"regex"</span></span></span><br><span class=line><span class=tag>                <span class=attr>expression</span>=<span class=string>".*Stub.*Repository"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>context:exclude-filter</span> <span class=attr>type</span>=<span class=string>"annotation"</span></span></span><br><span class=line><span class=tag>                <span class=attr>expression</span>=<span class=string>"org.springframework.stereotype.Repository"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>context:component-scan</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <blockquote><p>您还可以通过在注解上设置<code>useDefaultFilters=false</code>或通过提供<code>use-default-filters="false"</code>作为<code>&LTcomponent-scan/></code>元素的属性来禁用默认过滤器。实际上，这将禁用对带有<code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code>或<code>@Configuration</code>注解 的类的自动检测。</blockquote> <h4 id=2-1-10-5、在组件中定义Bean元数据><a class=headerlink href=#2-1-10-5、在组件中定义Bean元数据 title=2.1.10.5、在组件中定义Bean元数据></a>2.1.10.5、在组件中定义Bean元数据</h4><p>Spring 组件还可以将 bean 定义元数据贡献给容器。您可以使用与<code>@Configuration</code>带注解的类中定义 Bean 元数据相同的<code>@Bean</code>注解 来执行此操作。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>Component</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">FactoryMethodComponent</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=meta>@Qualifier("public")</span></span><br><span class=line>    <span class=keyword>public</span> TestBean <span class="title function_">publicInstance</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">TestBean</span>(<span class=string>"publicInstance"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doWork</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// Component method implementation omitted</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>上一类是Spring组件，其<code>doWork()</code>方法中具有特定于应用程序的代码 。但是，它也提供了具有工厂方法的bean定义，该方法引用了方法 <code>publicInstance()</code>。该<code>@Bean</code>注释标识工厂方法和其它bean定义特性，例如通过<code>@Qualifier</code>注解 的限定符值。可以指定的其他方法级别注解是<code>@Scope</code>，<code>@Lazy</code>和自定义限定符 注解。</p> <h4 id=2-1-10-6、命名自动检测的组件><a class=headerlink href=#2-1-10-6、命名自动检测的组件 title=2.1.10.6、命名自动检测的组件></a>2.1.10.6、命名自动检测的组件</h4><p>在扫描过程中自动检测到某个组件时，其 bean 名称由该扫描器已知的<code>BeanNameGenerator</code>策略生成。默认情况下，任何包含名称<code>value</code>的 Spring 构造型 注解(<code>@Component</code>，<code>@Repository</code>，<code>@Service</code>和<code>@Controller</code>)都会将该名称提供给相应的 bean 定义。</p> <p>如果这样的注解不包含名称<code>value</code>或任何其他检测到的组件(例如，由自定义过滤器发现的组件)，则缺省 bean 名称生成器将返回不使用大写字母的非限定类名称。例如，如果检测到以下组件类，则名称将为<code>myMovieLister</code>和<code>movieFinderImpl</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service("myMovieLister")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Repository</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieFinderImpl</span> <span class=keyword>implements</span> <span class="title class_">MovieFinder</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>如果不想依赖默认的Bean命名策略，则可以提供自定义Bean命名策略。首先，实现 <a href=https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html rel=noopener target=_blank><code>BeanNameGenerator</code></a> 接口，并确保包括默认的no-arg构造函数。然后，在配置扫描程序时提供完全限定的类名，如以下示例注释和Bean定义所示。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@ComponentScan(basePackages = "org.example", nameGenerator = MyNameGenerator.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>context:component-scan</span> <span class=attr>base-package</span>=<span class=string>"org.example"</span></span></span><br><span class=line><span class=tag>        <span class=attr>name-generator</span>=<span class=string>"org.example.MyNameGenerator"</span> /></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>通常，请考虑在其他组件可能对其进行显式引用时，使用注解指定名称。另一方面，只要容器负责接线，自动生成的名称就足够了。</p> <h4 id=2-1-10-7、提供自动检测组件的范围><a class=headerlink href=#2-1-10-7、提供自动检测组件的范围 title=2.1.10.7、提供自动检测组件的范围></a>2.1.10.7、提供自动检测组件的范围</h4><p>一般而言，与Spring管理的组件一样，自动检测到的组件的默认范围也是最常见的范围是<code>singleton</code>。但是，有时您需要由<code>@Scope</code>注释指定其他范围。您可以在批注中提供范围的名称，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Scope("prototype")</span></span><br><span class=line><span class=meta>@Repository</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieFinderImpl</span> <span class=keyword>implements</span> <span class="title class_">MovieFinder</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <blockquote><p><code>@Scope</code>注解 仅在具体的 bean 类(对于带注解的组件)或工厂方法(对于<code>@Bean</code>方法)上进行内省。与 XML bean 定义相反，没有 bean 定义继承的概念，并且在类级别的继承层次结构与元数据目的无关。</blockquote> <p>使用某些非单作用域时，可能有必要为作用域对象生成代理。在<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-other-injection rel=noopener target=_blank>范围Bean中将</a>推理描述<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-other-injection rel=noopener target=_blank>为依赖项</a>。为此，在component-scan元素上可以使用scoped-proxy属性。三个可能的值是：<code>no</code>，<code>interfaces</code>，和<code>targetClass</code>。例如，以下配置产生标准的JDK动态代理：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@ComponentScan(basePackages = "org.example", scopedProxy = ScopedProxyMode.INTERFACES)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>context:component-scan</span> <span class=attr>base-package</span>=<span class=string>"org.example"</span> <span class=attr>scoped-proxy</span>=<span class=string>"interfaces"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h4 id=2-1-10-8、提供带注释的限定符元数据><a class=headerlink href=#2-1-10-8、提供带注释的限定符元数据 title=2.1.10.8、提供带注释的限定符元数据></a>2.1.10.8、提供带注释的限定符元数据</h4><p>当依靠类路径扫描来自动检测组件时，可以在候选类上为限定符元数据提供类型级别的注释。下面的三个示例演示了此技术：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Qualifier("Action")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ActionMovieCatalog</span> <span class=keyword>implements</span> <span class="title class_">MovieCatalog</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Genre("Action")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ActionMovieCatalog</span> <span class=keyword>implements</span> <span class="title class_">MovieCatalog</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Offline</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CachingMovieCatalog</span> <span class=keyword>implements</span> <span class="title class_">MovieCatalog</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <h4 id=2-1-10-9、生成候选组件的索引><a class=headerlink href=#2-1-10-9、生成候选组件的索引 title=2.1.10.9、生成候选组件的索引></a>2.1.10.9、生成候选组件的索引</h4><p>尽管类路径扫描非常快，但可以通过在编译时创建静态候选列表来提高大型应用程序的启动性能。在这种模式下，作为组件扫描目标的所有模块都必须使用此机制，因为当<code>ApplicationContext</code>检测到这样的索引时，它将自动使用它而不是扫描 Classpath。</p> <p>要生成索引，请向每个包含组件的模块添加附加依赖关系，这些组件是组件扫描指令的目标。以下示例显示了如何使用Maven进行操作：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>    <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>        <span class=tag><<span class=name>groupId</span>></span>org.springframework<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>artifactId</span>></span>spring-context-indexer<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>version</span>></span>5.3.2<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>        <span class=tag><<span class=name>optional</span>></span>true<span class=tag>&LT/<span class=name>optional</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencies</span>></span></span><br></pre></table></figure> <blockquote><p>在IDE中使用此模式时，<code>spring-context-indexer</code>必须将其注册为注释处理器，以确保在更新候选组件时索引是最新的。<p><code>META-INF/spring.components</code>在类路径上找到 a时，索引将自动启用。如果某个索引对于某些库（或用例）部分可用，但无法为整个应用程序构建，则可以通过将设置<code>spring.index.ignore</code>为 <code>true</code>，来回退到常规的类路径安排（好像根本没有索引）属性或<code>spring.properties</code>类路径根目录下的文件中。</blockquote> <h3 id=2-1-11、使用-JSR330-标准注释><a title="2.1.11、使用 JSR330 标准注释" class=headerlink href=#2-1-11、使用-JSR330-标准注释></a>2.1.11、使用 JSR330 标准注释</h3><p>从Spring 3.0开始，Spring提供对JSR-330标准注释（依赖注入）的支持。这些注释的扫描方式与Spring注释的扫描方式相同。要使用它们，您需要在类路径中有相关的jar。</p> <p>如果使用Maven，您可以将以下依赖项添加到文件pom.xml中：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>javax.inject<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>javax.inject<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>1<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure> <h4 id=2-1-11-1、-Inject和-Named的依赖注入><a class=headerlink href=#2-1-11-1、-Inject和-Named的依赖注入 title=2.1.11.1、@Inject和@Named的依赖注入></a>2.1.11.1、@Inject和@Named的依赖注入</h4><p>除了<code>@Autowired</code>，您可以使用<code>@javax.inject.Inject</code>代替<code>@Autowired</code>，如下所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> javax.inject.Inject;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=meta>@Inject</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">listMovies</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder.findMovies(...);</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>与一样<code>@Autowired</code>，您可以在字段级别，方法级别和构造函数参数级别使用<code>@Inject</code>。此外，您可以将注入点声明为<code>Provider</code>，以允许按需访问范围较小的 bean，或者通过<code>Provider.get()</code>调用来懒惰地访问其他 bean。以下示例提供了前面示例的变体：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> javax.inject.Inject;</span><br><span class=line><span class=keyword>import</span> javax.inject.Provider;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> Provider&LTMovieFinder> movieFinder;</span><br><span class=line>    <span class=meta>@Inject</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(Provider&LTMovieFinder> movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">listMovies</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder.get().findMovies(...);</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>如果要为应该注入的依赖项使用限定名称，则应使用<code>@Named</code>批注，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> javax.inject.Inject;</span><br><span class=line><span class=keyword>import</span> javax.inject.Named;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=meta>@Inject</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(<span class=meta>@Named("main")</span> MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>与一样<code>@Autowired</code>，<code>@Inject</code>也可以与<code>java.util.Optional</code>或 @Nullable<code>一起使用</code>。这在这里更为适用，因为<code>@Inject</code>没有<code>required</code>属性。以下示例展示了如何使用<code>@Inject</code>和 <code>@Nullable</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=meta>@Inject</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(Optional&LTMovieFinder> movieFinder)</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=meta>@Inject</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(<span class=meta>@Nullable</span> MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=2-1-11-2、-Named和-ManagedBean：-Component注释的标准等效项><a class=headerlink href=#2-1-11-2、-Named和-ManagedBean：-Component注释的标准等效项 title=2.1.11.2、@Named和@ManagedBean：@Component注释的标准等效项></a>2.1.11.2、<code>@Named</code>和<code>@ManagedBean</code>：<code>@Component</code>注释的标准等效项</h4><p>代替<code>@Component</code>，您可以使用<code>@javax.inject.Named</code>或<code>javax.annotation.ManagedBean</code>，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> javax.inject.Inject;</span><br><span class=line><span class=keyword>import</span> javax.inject.Named;</span><br><span class=line></span><br><span class=line><span class=meta>@Named("movieListener")</span>  <span class=comment>// @ManagedBean("movieListener") could be used as well</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=meta>@Inject</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>在不指定组件名称的情况下使用<code>@Component</code>是很常见的。 <code>@Named</code>可以类似的方式使用，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> javax.inject.Inject;</span><br><span class=line><span class=keyword>import</span> javax.inject.Named;</span><br><span class=line></span><br><span class=line><span class=meta>@Named</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=meta>@Inject</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>使用<code>@Named</code>或<code>@ManagedBean</code>时，可以使用与使用 Spring注解 完全相同的方式来使用组件扫描，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@ComponentScan(basePackages = "org.example")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span>  {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <blockquote><p>与<code>@Component</code>相反，JSR-330 <code>@Named</code>和 JSR-250 <code>ManagedBean</code>注解 是不可组合的。您应该使用 Spring 的构造型模型来构建自定义组件 注解。</blockquote> <h4 id=2-1-11-3、JSR-330标准注释的局限性><a class=headerlink href=#2-1-11-3、JSR-330标准注释的局限性 title=2.1.11.3、JSR-330标准注释的局限性></a>2.1.11.3、JSR-330标准注释的局限性</h4><p>当使用标准注释时，您应该知道某些重要功能不可用，如下表所示：</p> <table><thead><tr><th align=left>Spring<th align=left>javax.inject。*<th align=left>javax.inject限制/注释<tbody><tr><td align=left>@Autowired<td align=left>@inject<td align=left><code>@Inject</code>没有“必填”属性。可以与Java 8一起使用<code>Optional</code>。<tr><td align=left>@Component<td align=left>@Named / @ManagedBean<td align=left>JSR-330不提供可组合的模型，仅提供一种识别命名组件的方法。<tr><td align=left>@Scope（“ singleton”）<td align=left>@Singleton<td align=left>JSR-330的默认范围类似于Spring的<code>prototype</code>。但是，为了使其与Spring的默认默认值保持一致，默认情况下，在Spring容器中声明的JSR-330 bean是a <code>singleton</code>。为了使用之外的范围<code>singleton</code>，您应该使用Spring的<code>@Scope</code>注释。<code>javax.inject</code>还提供了 <a href=https://download.oracle.com/javaee/6/api/javax/inject/Scope.html rel=noopener target=_blank>@Scope</a>批注。不过，此仅用于创建自己的注释。<tr><td align=left>@Qualifier<td align=left>@Qualifier / @Named<td align=left><code>javax.inject.Qualifier</code>只是用于构建自定义限定符的元注释。具体<code>String</code>限定词（例如<code>@Qualifier</code>带有值的Spring的限定词）可以通过关联<code>javax.inject.Named</code>。<tr><td align=left>@Value<td align=left>–<td align=left>没有等效<tr><td align=left>@Required<td align=left>–<td align=left>没有等效<tr><td align=left>@Lazy<td align=left>–<td align=left>没有等效<tr><td align=left>ObjectFactory<td align=left>Provider<td align=left><code>javax.inject.Provider</code>是Spring的直接替代方法<code>ObjectFactory</code>，只是<code>get()</code>方法名称较短。它也可以与Spring<code>@Autowired</code>或非注释构造函数和setter方法结合使用。</table> <h3 id=2-1-12、基于Java的容器配置><a class=headerlink href=#2-1-12、基于Java的容器配置 title=2.1.12、基于Java的容器配置></a>2.1.12、基于Java的容器配置</h3><p>本节介绍如何在Java代码中使用注释来配置Spring容器。它包括以下主题：</p> <ul><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-basic-concepts rel=noopener target=_blank>基本概念：<code>@Bean</code>和<code>@Configuration</code></a><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-instantiating-container rel=noopener target=_blank>使用实例化Spring容器 <code>AnnotationConfigApplicationContext</code></a><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-bean-annotation rel=noopener target=_blank>使用<code>@Bean</code>注释</a><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-configuration-annotation rel=noopener target=_blank>使用<code>@Configuration</code>注释</a><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-composing-configuration-classes rel=noopener target=_blank>组成基于Java的配置</a><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-definition-profiles rel=noopener target=_blank>Bean定义配置文件</a><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-property-source-abstraction rel=noopener target=_blank><code>PropertySource</code> 抽象化</a><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-using-propertysource rel=noopener target=_blank>使用 <code>@PropertySource</code></a><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-placeholder-resolution-in-statements rel=noopener target=_blank>声明中的占位符解析</a></ul> <h4 id=2-1-12-1、基本概念：-Bean和-Configuration><a class=headerlink href=#2-1-12-1、基本概念：-Bean和-Configuration title=2.1.12.1、基本概念：@Bean和@Configuration></a>2.1.12.1、基本概念：@Bean和@Configuration</h4><p>Spring的新Java配置支持中的主要工件是 <code>@Configuration</code>注释的类和<code>@Bean</code>注释的方法。</p> <p><code>@Configuration</code>注解 类表示该类的主要目的是作为 Bean 定义的来源。此外，<code>@Configuration</code>类通过调用同一类中的其他<code>@Bean</code>方法来定义 Bean 间的依赖关系。最简单的<code>@Configuration</code>类的内容如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> MyService <span class="title function_">myService</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">MyServiceImpl</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>上一<code>AppConfig</code>类等效于以下XML：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"myService"</span> <span class=attr>class</span>=<span class=string>"com.acme.services.MyServiceImpl"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h4 id=2-1-12-2、使用AnnotationConfigApplicationContext实例化Spring容器><a class=headerlink href=#2-1-12-2、使用AnnotationConfigApplicationContext实例化Spring容器 title=2.1.12.2、使用AnnotationConfigApplicationContext实例化Spring容器></a>2.1.12.2、使用AnnotationConfigApplicationContext实例化Spring容器</h4><h5 id=Simple-Construction><a title="Simple Construction" class=headerlink href=#Simple-Construction></a>Simple Construction</h5><p>与实例化<code>ClassPathXmlApplicationContext</code>时将 Spring XML 文件用作 Importing 的方式几乎相同，实例化<code>AnnotationConfigApplicationContext</code>时可以将<code>@Configuration</code>类用作 Importing。</p> <p>如下面的示例所示，这允许完全不使用XML来使用Spring容器：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=type>ApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class=line>    <span class=type>MyService</span> <span class=variable>myService</span> <span class=operator>=</span> ctx.getBean(MyService.class);</span><br><span class=line>    myService.doStuff();</span><br><span class=line>}</span><br></pre></table></figure> <p>如前所述，<code>AnnotationConfigApplicationContext</code>不仅限于仅使用<code>@Configuration</code>类。``可以将任何@Component或带有JSR-330注释的类作为 输入 提供给构造函数，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=type>ApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyServiceImpl.class, Dependency1.class, Dependency2.class);</span><br><span class=line>    <span class=type>MyService</span> <span class=variable>myService</span> <span class=operator>=</span> ctx.getBean(MyService.class);</span><br><span class=line>    myService.doStuff();</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=通过使用register-Class…-以编程方式构建容器><a title="通过使用register(Class<?>…)以编程方式构建容器" class=headerlink href=#通过使用register-Class…-以编程方式构建容器></a>通过使用register(Class&LT?>…)以编程方式构建容器</h5><p>您可以使用 no-arg 构造函数实例化<code>AnnotationConfigApplicationContext</code>，然后使用<code>register()</code>方法对其进行配置。以编程方式构建<code>AnnotationConfigApplicationContext</code>时，此方法特别有用。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=type>AnnotationConfigApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class=line>    ctx.register(AppConfig.class, OtherConfig.class);</span><br><span class=line>    ctx.register(AdditionalConfig.class);</span><br><span class=line>    ctx.refresh();</span><br><span class=line>    <span class=type>MyService</span> <span class=variable>myService</span> <span class=operator>=</span> ctx.getBean(MyService.class);</span><br><span class=line>    myService.doStuff();</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=使用scan-String…-启用组件扫描><a class=headerlink href=#使用scan-String…-启用组件扫描 title=使用scan(String…)启用组件扫描></a>使用scan(String…)启用组件扫描</h5><p>要启用组件扫描，您可以按如下方式注释您的<code>@Configuration</code>类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@ComponentScan(basePackages = "com.acme")</span> </span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span>  {</span><br><span class=line>    ...</span><br><span class=line>}</span><br></pre></table></figure> <p><code>AnnotationConfigApplicationContext</code>公开此 <code>scan(String…)</code>方法以允许相同的组件扫描功能，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=type>AnnotationConfigApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class=line>    ctx.scan(<span class=string>"com.acme"</span>);</span><br><span class=line>    ctx.refresh();</span><br><span class=line>    <span class=type>MyService</span> <span class=variable>myService</span> <span class=operator>=</span> ctx.getBean(MyService.class);</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=通过AnnotationConfigWebApplicationContext支持Web应用程序><a class=headerlink href=#通过AnnotationConfigWebApplicationContext支持Web应用程序 title=通过AnnotationConfigWebApplicationContext支持Web应用程序></a>通过AnnotationConfigWebApplicationContext支持Web应用程序</h5><p><code>AnnotationConfigWebApplicationContext</code>可提供<code>AnnotationConfigApplicationContext</code>的<code>WebApplicationContext</code>变体。在配置 Spring <code>ContextLoaderListener</code> servlet 侦听器，Spring MVC <code>DispatcherServlet</code>等时，可以使用此实现。以下<code>web.xml</code>片段配置了典型的 Spring MVC Web 应用程序(请注意<code>contextClass</code> context-param 和 init-param 的使用)：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>web-app</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>context-param</span>></span></span><br><span class=line>        <span class=tag><<span class=name>param-name</span>></span>contextClass<span class=tag>&LT/<span class=name>param-name</span>></span></span><br><span class=line>        <span class=tag><<span class=name>param-value</span>></span> org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class=line>        <span class=tag>&LT/<span class=name>param-value</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>context-param</span>></span></span><br><span class=line>    </span><br><span class=line>    <span class=tag><<span class=name>context-param</span>></span></span><br><span class=line>        <span class=tag><<span class=name>param-name</span>></span>contextConfigLocation<span class=tag>&LT/<span class=name>param-name</span>></span></span><br><span class=line>        <span class=tag><<span class=name>param-value</span>></span>com.acme.AppConfig<span class=tag>&LT/<span class=name>param-value</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>context-param</span>></span></span><br><span class=line>    </span><br><span class=line>    <span class=tag><<span class=name>listener</span>></span></span><br><span class=line>        <span class=tag><<span class=name>listener-class</span>></span>org.springframework.web.context.ContextLoaderListener<span class=tag>&LT/<span class=name>listener-class</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>listener</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- Declare a Spring MVC DispatcherServlet as usual --></span></span><br><span class=line>    <span class=tag><<span class=name>servlet</span>></span></span><br><span class=line>        <span class=tag><<span class=name>servlet-name</span>></span>dispatcher<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>        <span class=tag><<span class=name>servlet-class</span>></span>org.springframework.web.servlet.DispatcherServlet<span class=tag>&LT/<span class=name>servlet-class</span>></span></span><br><span class=line>        <span class=tag><<span class=name>init-param</span>></span></span><br><span class=line>            <span class=tag><<span class=name>param-name</span>></span>contextClass<span class=tag>&LT/<span class=name>param-name</span>></span></span><br><span class=line>            <span class=tag><<span class=name>param-value</span>></span>       org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class=line>            <span class=tag>&LT/<span class=name>param-value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>init-param</span>></span></span><br><span class=line>        <span class=tag><<span class=name>init-param</span>></span></span><br><span class=line>            <span class=tag><<span class=name>param-name</span>></span>contextConfigLocation<span class=tag>&LT/<span class=name>param-name</span>></span></span><br><span class=line>            <span class=tag><<span class=name>param-value</span>></span>com.acme.web.MvcConfig<span class=tag>&LT/<span class=name>param-value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>init-param</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>servlet</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>servlet-mapping</span>></span></span><br><span class=line>        <span class=tag><<span class=name>servlet-name</span>></span>dispatcher<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>        <span class=tag><<span class=name>url-pattern</span>></span>/app/*<span class=tag>&LT/<span class=name>url-pattern</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>servlet-mapping</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>web-app</span>></span></span><br></pre></table></figure> <h4 id=2-1-12-3、使用-Bean注释><a class=headerlink href=#2-1-12-3、使用-Bean注释 title=2.1.12.3、使用@Bean注释></a>2.1.12.3、使用@Bean注释</h4><p><code>@Bean</code>是方法级别的注释，是XML<code>&LTbean/></code>元素的直接类似物。注解 支持<code>&LTbean/></code>提供的某些属性，例如：* <a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean rel=noopener target=_blank>init-method</a> * <a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-disposablebean rel=noopener target=_blank>destroy-method</a> * <a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-autowire rel=noopener target=_blank>autowiring</a> * <code>name</code>。</p> <h5 id=声明一个Bean><a class=headerlink href=#声明一个Bean title=声明一个Bean></a>声明一个Bean</h5><p>要声明 bean，可以使用<code>@Bean</code>注解 对方法进行 注解。您可以使用此方法在指定为该方法的返回值的类型的<code>ApplicationContext</code>内注册 bean 定义。默认情况下，Bean 名称与方法名称相同。以下示例显示了<code>@Bean</code>方法声明：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> TransferServiceImpl <span class="title function_">transferService</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">TransferServiceImpl</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>前面的配置与下面的Spring XML完全等效：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"transferService"</span> <span class=attr>class</span>=<span class=string>"com.acme.TransferServiceImpl"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>这两个声明使一个名为<code>transferService</code>的 bean 在<code>ApplicationContext</code>中可用，并绑定到<code>TransferServiceImpl</code>类型的对象实例，如以下文本图像所示：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>transferService-> com.acme.TransferServiceImpl</span><br></pre></table></figure> <p>您还可以使用接口(或 Base Class)返回类型声明<code>@Bean</code>方法，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> TransferService <span class="title function_">transferService</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">TransferServiceImpl</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>但是，这将提前类型预测的可见性限制为指定的接口类型(<code>TransferService</code>)。然后，使用只对容器知道一次的完整类型(<code>TransferServiceImpl</code>)，实例化受影响的单例 bean。非惰性单例 bean 根据其声明 Sequences 实例化，因此您可能会看到不同的类型匹配结果，具体取决于另一个组件何时尝试通过未声明的类型进行匹配(例如<code>@Autowired TransferServiceImpl</code>，该实例仅在实例化<code>transferService</code> bean 时才解析.)。</p> <h5 id=Bean依赖><a class=headerlink href=#Bean依赖 title=Bean依赖></a>Bean依赖</h5><p>带<code>@Bean</code>注释的方法可以具有任意数量的参数，这些参数描述了构建该bean所需的依赖关系。例如，如果我们<code>TransferService</code> 需要一个<code>AccountRepository</code>，我们可以使用方法参数来实现该依赖关系，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> TransferService <span class="title function_">transferService</span><span class=params>(AccountRepository accountRepository)</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">TransferServiceImpl</span>(accountRepository);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>解析机制与基于构造函数的依赖注入几乎相同。</p> <h5 id=接收生命周期回调><a class=headerlink href=#接收生命周期回调 title=接收生命周期回调></a>接收生命周期回调</h5><p>使用<code>@Bean</code>注释定义的任何类都支持常规的生命周期回调，并且可以使用JSR-250中的<code>@PostConstruct</code>和<code>@PreDestroy</code>注释。</p> <p>该<code>@Bean</code>注释支持指定任意初始化和销毁回调方法，就像Spring XML中<code>bean</code>元素的<code>init-method</code>和<code>destroy-method</code>属性一样，如下面的示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BeanOne</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">init</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// initialization logic</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BeanTwo</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">cleanup</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// destruction logic</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean(initMethod = "init")</span></span><br><span class=line>    <span class=keyword>public</span> BeanOne <span class="title function_">beanOne</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">BeanOne</span>();</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Bean(destroyMethod = "cleanup")</span></span><br><span class=line>    <span class=keyword>public</span> BeanTwo <span class="title function_">beanTwo</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">BeanTwo</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>对于<code>BeanOne</code>前面注释中的示例，在构造期间直接调用<code>init()</code> 方法同样有效，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> BeanOne <span class="title function_">beanOne</span><span class=params>()</span> {</span><br><span class=line>        <span class=type>BeanOne</span> <span class=variable>beanOne</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">BeanOne</span>();</span><br><span class=line>        beanOne.init();</span><br><span class=line>        <span class=keyword>return</span> beanOne;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <h5 id=指定Bean范围><a class=headerlink href=#指定Bean范围 title=指定Bean范围></a>指定Bean范围</h5><p>Spring包含<code>@Scope</code>注释，以便您可以指定bean的范围。</p> <h6 id=使用-Scope注释><a class=headerlink href=#使用-Scope注释 title=使用@Scope注释></a>使用@Scope注释</h6><p>默认范围是<code>singleton</code>，但是您可以使用<code>@Scope</code>注释覆盖它，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyConfiguration</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=meta>@Scope("prototype")</span></span><br><span class=line>    <span class=keyword>public</span> Encryptor <span class="title function_">encryptor</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h6 id=Scope和-scoped-proxy><a title="@Scope和 scoped-proxy" class=headerlink href=#Scope和-scoped-proxy></a>@Scope和 scoped-proxy</h6><p>Spring提供了一种通过<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-other-injection rel=noopener target=_blank>作用域代理</a>处理作用域依赖性的便捷方法 。使用XML配置时创建此类代理的最简单方法是<code>&LTaop:scoped-proxy/></code>元素。使用<code>@Scope</code>注释在Java中配置bean可以为该<code>proxyMode</code>属性提供同等的支持。默认值为no proxy（<code>ScopedProxyMode.NO</code>），但是您可以指定<code>ScopedProxyMode.TARGET_CLASS</code>或<code>ScopedProxyMode.INTERFACES</code>。</p> <p>如果使用 Java 从 XML 参考文档(请参阅<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-other-injection rel=noopener target=_blank>scoped proxies</a>)将作用域代理示例移植到我们的<code>@Bean</code>，则它类似于以下内容：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=comment>// an HTTP Session-scoped bean exposed as a proxy</span></span><br><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=meta>@SessionScope</span></span><br><span class=line><span class=keyword>public</span> UserPreferences <span class="title function_">userPreferences</span><span class=params>()</span> {</span><br><span class=line>    <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">UserPreferences</span>();</span><br><span class=line>}</span><br><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> Service <span class="title function_">userService</span><span class=params>()</span> {</span><br><span class=line>    <span class=type>UserService</span> <span class=variable>service</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SimpleUserService</span>();</span><br><span class=line>    <span class=comment>// a reference to the proxied userPreferences bean</span></span><br><span class=line>    service.setUserPreferences(userPreferences());</span><br><span class=line>    <span class=keyword>return</span> service;</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=自定义Bean命名><a class=headerlink href=#自定义Bean命名 title=自定义Bean命名></a>自定义Bean命名</h5><p>默认情况下，配置类使用<code>@Bean</code>方法的名称作为结果bean的名称。但是，可以使用<code>name</code>属性覆盖此功能，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean(name = "myThing")</span></span><br><span class=line>    <span class=keyword>public</span> Thing <span class="title function_">thing</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">Thing</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=Bean别名><a class=headerlink href=#Bean别名 title=Bean别名></a>Bean别名</h5><p>如<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beanname rel=noopener target=_blank>Naming Beans中</a>讨论的，有时希望为单个Bean提供多个名称，否则称为Bean别名。 为此<code>name</code>，<code>@Bean</code>注释的属性接受String数组。以下示例显示了如何为bean设置多个别名：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean({"dataSource", "subsystemA-dataSource", "subsystemB-dataSource"})</span></span><br><span class=line>    <span class=keyword>public</span> DataSource <span class="title function_">dataSource</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// instantiate, configure and return DataSource bean...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=Bean描述><a class=headerlink href=#Bean描述 title=Bean描述></a>Bean描述</h5><p>有时，提供有关 bean 的更详细的文本描述会很有帮助。当出于监视目的而暴露(可能通过 JMX)bean 时，这尤其有用。</p> <p>要将说明添加到<code>@Bean</code>，可以使用 <a href=https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/context/annotation/Description.html rel=noopener target=_blank><code>@Description</code></a> 批注，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=meta>@Description("Provides a basic example of a bean")</span></span><br><span class=line>    <span class=keyword>public</span> Thing <span class="title function_">thing</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">Thing</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=2-1-12-4、使用-Configuration注释><a class=headerlink href=#2-1-12-4、使用-Configuration注释 title=2.1.12.4、使用@Configuration注释></a>2.1.12.4、使用<code>@Configuration</code>注释</h4><p><code>@Configuration</code>是类级别的注释，指示对象是Bean定义的源。<code>@Configuration</code>类通过公共<code>@Bean</code>注释方法声明bean 。对<code>@Configuration</code>类的<code>@Bean</code>方法的调用也可以用于定义Bean之间的依赖关系。</p> <h5 id=注入bean间的依赖关系><a class=headerlink href=#注入bean间的依赖关系 title=注入bean间的依赖关系></a>注入bean间的依赖关系</h5><p>当bean彼此依赖时，表达这种依赖就像让一个bean方法调用另一个一样简单，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> BeanOne <span class="title function_">beanOne</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">BeanOne</span>(beanTwo());</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> BeanTwo <span class="title function_">beanTwo</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">BeanTwo</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>在前面的示例中，<code>beanOne</code>通过构造函数注入接收对<code>beanTwo</code>的引用。</p> <blockquote><p>仅当在<code>@Configuration</code>类中声明<code>@Bean</code>方法时，此声明 bean 间依赖性的方法才有效。您不能通过使用普通<code>@Component</code>类来声明 Bean 间的依赖关系。</blockquote> <h5 id=查找方法注入-1><a class=headerlink href=#查找方法注入-1 title=查找方法注入></a>查找方法注入</h5><p><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-method-injection rel=noopener target=_blank>查找方法注入</a>是一项高级功能，您应该很少使用。在单例作用域的bean依赖于原型作用域的bean的情况下，这很有用。将Java用于这种类型的配置为实现此模式提供了自然的方法。下面的示例演示如何使用查找方法注入：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">CommandManager</span> {</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">process</span><span class=params>(Object commandState)</span> {</span><br><span class=line>        <span class=comment>// grab a new instance of the appropriate Command interface</span></span><br><span class=line>        <span class=type>Command</span> <span class=variable>command</span> <span class=operator>=</span> createCommand();</span><br><span class=line>        <span class=comment>// set the state on the (hopefully brand new) Command instance</span></span><br><span class=line>        command.setState(commandState);</span><br><span class=line>        <span class=keyword>return</span> command.execute();</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// okay... but where is the implementation of this method?</span></span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>abstract</span> Command <span class="title function_">createCommand</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>通过使用 Java 配置，您可以创建<code>CommandManager</code>的子类，在该子类中，抽象<code>createCommand()</code>方法被覆盖，从而可以查找新的(原型)命令对象。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=meta>@Scope("prototype")</span></span><br><span class=line><span class=keyword>public</span> AsyncCommand <span class="title function_">asyncCommand</span><span class=params>()</span> {</span><br><span class=line>    <span class=type>AsyncCommand</span> <span class=variable>command</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AsyncCommand</span>();</span><br><span class=line>    <span class=comment>// inject dependencies here as required</span></span><br><span class=line>    <span class=keyword>return</span> command;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> CommandManager <span class="title function_">commandManager</span><span class=params>()</span> {</span><br><span class=line>    <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">CommandManager</span>() {</span><br><span class=line>        <span class=keyword>protected</span> Command <span class="title function_">createCommand</span><span class=params>()</span> {</span><br><span class=line>            <span class=keyword>return</span> asyncCommand();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=有关基于Java的配置如何在内部工作的更多信息><a class=headerlink href=#有关基于Java的配置如何在内部工作的更多信息 title=有关基于Java的配置如何在内部工作的更多信息></a>有关基于Java的配置如何在内部工作的更多信息</h5><p>该示例显示了一个带<code>@Bean</code>注释的方法被调用两次：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> ClientService <span class="title function_">clientService1</span><span class=params>()</span> {</span><br><span class=line>        <span class=type>ClientServiceImpl</span> <span class=variable>clientService</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class=line>        clientService.setClientDao(clientDao());</span><br><span class=line>        <span class=keyword>return</span> clientService;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> ClientService <span class="title function_">clientService2</span><span class=params>()</span> {</span><br><span class=line>        <span class=type>ClientServiceImpl</span> <span class=variable>clientService</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class=line>        clientService.setClientDao(clientDao());</span><br><span class=line>        <span class=keyword>return</span> clientService;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> ClientDao <span class="title function_">clientDao</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">ClientDaoImpl</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p><code>clientDao()</code>在<code>clientService1()</code>中被调用过一次，在<code>clientService2()</code>中被调用过一次。由于此方法创建了<code>ClientDaoImpl</code>的新实例并返回它，因此通常希望有两个实例(每个服务一个)。那绝对是有问题的：在 Spring 中，实例化的 bean 默认具有<code>singleton</code>范围。这就是神奇的地方：所有<code>@Configuration</code>类在启动时都使用<code>CGLIB</code>子类化。在子类中，子方法在调用父方法并创建新实例之前，首先检查容器中是否有任何缓存(作用域)的 bean。</p> <h4 id=2-1-12-5、组成基于Java的配置><a class=headerlink href=#2-1-12-5、组成基于Java的配置 title=2.1.12.5、组成基于Java的配置></a>2.1.12.5、组成基于Java的配置</h4><h5 id=使用-Import注释><a class=headerlink href=#使用-Import注释 title=使用@Import注释></a>使用<code>@Import</code>注释</h5><p>就像 Spring XML 文件中使用<code>&LTimport/></code>元素来帮助模块化配置一样，<code>@Import</code>注解 允许从另一个配置类中加载<code>@Bean</code>定义，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ConfigA</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> A <span class="title function_">a</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">A</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@Import(ConfigA.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ConfigB</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> B <span class="title function_">b</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">B</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>现在，无需在实例化上下文时同时指定<code>ConfigA.class</code>和<code>ConfigB.class</code>，只需显式提供<code>ConfigB</code>，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=type>ApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ConfigB.class);</span><br><span class=line>    <span class=comment>// now both beans A and B will be available...</span></span><br><span class=line>    <span class=type>A</span> <span class=variable>a</span> <span class=operator>=</span> ctx.getBean(A.class);</span><br><span class=line>    <span class=type>B</span> <span class=variable>b</span> <span class=operator>=</span> ctx.getBean(B.class);</span><br><span class=line>}</span><br></pre></table></figure> <p>这种方法简化了容器的实例化，因为只需要处理一个类，而不是要求您在构造过程中记住大量的<code>@Configuration</code>类。</p> <blockquote><p>从Spring Framework 4.2开始，<code>@Import</code>还支持对常规组件类的引用，类似于该<code>AnnotationConfigApplicationContext.register</code>方法。如果要通过使用一些配置类作为入口点来显式定义所有组件，从而避免组件扫描，则此功能特别有用。</blockquote> <h6 id=注入对导入-Bean定义的依赖><a class=headerlink href=#注入对导入-Bean定义的依赖 title=注入对导入@Bean定义的依赖></a>注入对导入<code>@Bean</code>定义的依赖</h6><p>考虑以下具有多个<code>@Configuration</code> 类的更真实的场景，每个类都取决于其他类中声明的bean：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ServiceConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> TransferService <span class="title function_">transferService</span><span class=params>(AccountRepository accountRepository)</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">TransferServiceImpl</span>(accountRepository);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RepositoryConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> AccountRepository <span class="title function_">accountRepository</span><span class=params>(DataSource dataSource)</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">JdbcAccountRepository</span>(dataSource);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@Import({ServiceConfig.class, RepositoryConfig.class})</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SystemTestConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> DataSource <span class="title function_">dataSource</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// return new DataSource</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=type>ApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SystemTestConfig.class);</span><br><span class=line>    <span class=comment>// everything wires up across configuration classes...</span></span><br><span class=line>    <span class=type>TransferService</span> <span class=variable>transferService</span> <span class=operator>=</span> ctx.getBean(TransferService.class);</span><br><span class=line>    transferService.transfer(<span class=number>100.00</span>, <span class=string>"A123"</span>, <span class=string>"C456"</span>);</span><br><span class=line>}</span><br></pre></table></figure> <p>还有另一种方法可以达到相同的结果。请记住，<code>@Configuration</code>类最终仅是容器中的另一个 bean：这意味着它们可以利用<code>@Autowired</code>和<code>@Value</code>注入以及与任何其他 bean 相同的其他功能。</p> <p>以下示例说明如何将一个bean自动连接到另一个bean：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ServiceConfig</span> {</span><br><span class=line></span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> AccountRepository accountRepository;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> TransferService <span class="title function_">transferService</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">TransferServiceImpl</span>(accountRepository);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RepositoryConfig</span> {</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> DataSource dataSource;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RepositoryConfig</span><span class=params>(DataSource dataSource)</span> {</span><br><span class=line>        <span class=built_in>this</span>.dataSource = dataSource;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> AccountRepository <span class="title function_">accountRepository</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">JdbcAccountRepository</span>(dataSource);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@Import({ServiceConfig.class, RepositoryConfig.class})</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SystemTestConfig</span> {</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> DataSource <span class="title function_">dataSource</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// return new DataSource</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=type>ApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SystemTestConfig.class);</span><br><span class=line>    <span class=comment>// everything wires up across configuration classes...</span></span><br><span class=line>    <span class=type>TransferService</span> <span class=variable>transferService</span> <span class=operator>=</span> ctx.getBean(TransferService.class);</span><br><span class=line>    transferService.transfer(<span class=number>100.00</span>, <span class=string>"A123"</span>, <span class=string>"C456"</span>);</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=有条件地包含-Configuration类或-Bean方法><a class=headerlink href=#有条件地包含-Configuration类或-Bean方法 title=有条件地包含@Configuration类或@Bean方法></a>有条件地包含@Configuration类或@Bean方法</h5><p>基于某些任意系统状态，有条件地启用或禁用完整的<code>@Configuration</code>类甚至单个<code>@Bean</code>方法通常很有用。一个常见的示例是仅在 Spring <code>Environment</code>中启用了特定概要文件时才使用<code>@Profile</code>注解 来激活 bean(有关详细信息，请参见<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-definition-profiles rel=noopener target=_blank>Bean 定义配置文件</a>)。</p> <p><code>Condition</code>接口的实现提供了一个<code>matches(…)</code>方法，该方法返回<code>true</code>或<code>false</code>。例如，以下清单显示了用于<code>@Profile</code>的实际<code>Condition</code>实现：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">matches</span><span class=params>(ConditionContext context, AnnotatedTypeMetadata metadata)</span> {</span><br><span class=line>    <span class=comment>// Read the @Profile annotation attributes</span></span><br><span class=line>    MultiValueMap&LTString, Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());</span><br><span class=line>    <span class=keyword>if</span> (attrs != <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>for</span> (Object value : attrs.get(<span class=string>"value"</span>)) {</span><br><span class=line>            <span class=keyword>if</span> (context.getEnvironment().acceptsProfiles(((String[]) value))) {</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=结合Java和XML配置><a class=headerlink href=#结合Java和XML配置 title=结合Java和XML配置></a>结合Java和XML配置</h5><p>pring的<code>@Configuration</code>类支持并不旨在100％完全替代Spring XML。某些工具（例如Spring XML名称空间）仍然是配置容器的理想方法。在使用XML方便或必要的情况下，您可以选择：通过使用<code>ClassPathXmlApplicationContext</code>以“以 XML 为中心”的方式实例化容器，或通过使用<code>AnnotationConfigApplicationContext</code>和以“以 Java 为中心”的方式实例化容器。 <code>@ImportResource</code>注解 以根据需要导入 XML。</p> <h6 id=以XML为中心的-Configuration类使用><a class=headerlink href=#以XML为中心的-Configuration类使用 title=以XML为中心的@Configuration类使用></a>以XML为中心的<code>@Configuration</code>类使用</h6><ul><li><p>将<code>@Configuration</code>类声明为纯Spring<code>&LTbean/></code>元素</p> <p>请记住，<code>@Configuration</code>类最终是容器中的 bean 定义。在本系列示例中，我们创建一个名为<code>AppConfig</code>的<code>@Configuration</code>类，并将其作为<code>&LTbean/></code>定义包含在<code>system-test-config.xml</code>中。由于<code>&LTcontext:annotation-config/></code>已打开，因此容器会识别<code>@Configuration</code>注解并正确处理<code>AppConfig</code>中声明的<code>@Bean</code>方法。</p> <p>以下示例显示了Java中的普通配置类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> DataSource dataSource;</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> AccountRepository <span class="title function_">accountRepository</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">JdbcAccountRepository</span>(dataSource);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> TransferService <span class="title function_">transferService</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">TransferService</span>(accountRepository());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>以下示例显示了示例<code>system-test-config.xml</code>文件的一部分：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=comment>&LT!-- enable processing of annotations such as @Autowired and @Configuration --></span></span><br><span class=line>    <span class=tag><<span class=name>context:annotation-config</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>context:property-placeholder</span> <span class=attr>location</span>=<span class=string>"classpath:/com/acme/jdbc.properties"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"com.acme.AppConfig"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"url"</span> <span class=attr>value</span>=<span class=string>"${jdbc.url}"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"username"</span> <span class=attr>value</span>=<span class=string>"${jdbc.username}"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"password"</span> <span class=attr>value</span>=<span class=string>"${jdbc.password}"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>以下示例显示了一个可能的<code>jdbc.properties</code>文件：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>jdbc.url = jdbc：hsqldb：hsql：// localhost / xdb </span><br><span class=line>jdbc.username = sa </span><br><span class=line>jdbc.password =</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=type>ApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class=string>"classpath:/com/acme/system-test-config.xml"</span>);</span><br><span class=line>    <span class=type>TransferService</span> <span class=variable>transferService</span> <span class=operator>=</span> ctx.getBean(TransferService.class);</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><li><p>使用&LTcontext：component-scan />拾取<code>@Configuration</code>类</p> <p>因为<code>@Configuration</code>使用<code>@Component</code>进行元 注解，所以<code>@Configuration</code>注解 的类自动成为组件扫描的候选对象。使用与上一个示例中描述的场景相同的场景，我们可以重新定义<code>system-test-config.xml</code>以利用组件扫描的优势。请注意，在这种情况下，我们无需显式声明<code>&LTcontext:annotation-config/></code>，因为<code>&LTcontext:component-scan/></code>启用相同的功能。</p> <p>以下示例显示了修改后的<code>system-test-config.xml</code>文件：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=comment>&LT!-- picks up and registers AppConfig as a bean definition --></span></span><br><span class=line>    <span class=tag><<span class=name>context:component-scan</span> <span class=attr>base-package</span>=<span class=string>"com.acme"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>context:property-placeholder</span> <span class=attr>location</span>=<span class=string>"classpath:/com/acme/jdbc.properties"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"url"</span> <span class=attr>value</span>=<span class=string>"${jdbc.url}"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"username"</span> <span class=attr>value</span>=<span class=string>"${jdbc.username}"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"password"</span> <span class=attr>value</span>=<span class=string>"${jdbc.password}"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure><li><p>@Configuration 以类为中心的XML与使用 @ImportResource</p> <p>在<code>@Configuration</code>类是配置容器的主要机制的应用程序中，仍然有必要至少使用一些XML。在这些情况下，您可以使用<code>@ImportResource</code>并仅定义所需的 XML。这样做实现了“以 Java 为中心”的方法来配置容器，并将 XML 保持在最低限度。以下示例(包括配置类，定义 Bean 的 XML 文件，属性文件和<code>main</code>类)显示了如何使用<code>@ImportResource</code>注解 来实现按需使用 XML 的“以 Java 为中心”的配置：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@ImportResource("classpath:/com/acme/properties-config.xml")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Value("${jdbc.url}")</span></span><br><span class=line>    <span class=keyword>private</span> String url;</span><br><span class=line>    <span class=meta>@Value("${jdbc.username}")</span></span><br><span class=line>    <span class=keyword>private</span> String username;</span><br><span class=line>    <span class=meta>@Value("${jdbc.password}")</span></span><br><span class=line>    <span class=keyword>private</span> String password;</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> DataSource <span class="title function_">dataSource</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">DriverManagerDataSource</span>(url, username, password);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>----properties-config.xml----</span><br><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>context:property-placeholder</span> <span class=attr>location</span>=<span class=string>"classpath:/com/acme/jdbc.properties"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=attr>----jdbc.properties----</span></span><br><span class=line><span class=attr>jdbc.url</span> = <span class=string>jdbc：hsqldb：hsql：// localhost / xdb </span></span><br><span class=line><span class=attr>jdbc.username</span> = <span class=string>sa </span></span><br><span class=line><span class=attr>jdbc.password</span> =<span class=string></span></span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=type>ApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class=line>    <span class=type>TransferService</span> <span class=variable>transferService</span> <span class=operator>=</span> ctx.getBean(TransferService.class);</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure></ul> <h3 id=2-1-13、抽象环境><a class=headerlink href=#2-1-13、抽象环境 title=2.1.13、抽象环境></a>2.1.13、抽象环境</h3><p><a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/env/Environment.html rel=noopener target=_blank>Environment</a>接口是集成在容器中的抽象，用于对应用程序环境的两个关键方面进行建模：<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-definition-profiles rel=noopener target=_blank>profiles</a>和<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-property-source-abstraction rel=noopener target=_blank>properties</a>。</p> <h4 id=2-1-13-1、Bean定义配置文件><a class=headerlink href=#2-1-13-1、Bean定义配置文件 title=2.1.13.1、Bean定义配置文件></a>2.1.13.1、Bean定义配置文件</h4><p>Bean定义配置文件在核心容器中提供了一种机制，该机制允许在不同环境中注册不同的Bean。“环境”一词对不同的用户而言可能意味着不同的含义，并且此功能可以在许多用例中提供帮助，包括：</p> <ul><li>在开发中针对内存中的数据源进行工作，而不是在进行QA或生产时从JNDI查找相同的数据源。<li>仅在将应用程序部署到性能环境中时注册监视基础结构。<li>为客户A和客户B部署注册bean的自定义实现。</ul> <p>考虑实际应用中需要<code>DataSource</code>的第一个用例。在测试环境中，配置可能类似于以下内容：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> DataSource <span class="title function_">dataSource</span><span class=params>()</span> {</span><br><span class=line>    <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">EmbeddedDatabaseBuilder</span>()</span><br><span class=line>        .setType(EmbeddedDatabaseType.HSQL)</span><br><span class=line>        .addScript(<span class=string>"my-schema.sql"</span>)</span><br><span class=line>        .addScript(<span class=string>"my-test-data.sql"</span>)</span><br><span class=line>        .build();</span><br><span class=line>}</span><br></pre></table></figure> <p>现在，假设该应用程序的数据源已在生产应用程序服务器的JNDI目录中注册，请考虑如何将该应用程序部署到QA或生产环境中。现在，我们的<code>dataSource</code> bean 看起来像下面的清单：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean(destroyMethod="")</span></span><br><span class=line><span class=keyword>public</span> DataSource <span class="title function_">dataSource</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>    <span class=type>Context</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">InitialContext</span>();</span><br><span class=line>    <span class=keyword>return</span> (DataSource) ctx.lookup(<span class=string>"java:comp/env/jdbc/datasource"</span>);</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=使用-Profile><a title="使用 @Profile" class=headerlink href=#使用-Profile></a>使用 @Profile</h5><p><a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/annotation/Profile.html rel=noopener target=_blank>@Profile</a>注解 使您可以指示一个或多个指定配置文件处于活动状态时有资格注册的组件。使用前面的示例，我们可以如下重写<code>dataSource</code>配置：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>@Configuration</span><br><span class=line>@Profile("development")</span><br><span class=line>public class StandaloneDataConfig {</span><br><span class=line>    @Bean</span><br><span class=line>    public DataSource dataSource() {</span><br><span class=line>        return new EmbeddedDatabaseBuilder()</span><br><span class=line>            .setType(EmbeddedDatabaseType.HSQL)</span><br><span class=line>            .addScript("classpath:com/bank/config/sql/schema.sql")</span><br><span class=line>            .addScript("classpath:com/bank/config/sql/test-data.sql")</span><br><span class=line>            .build();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@Profile("production")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">JndiDataConfig</span> {</span><br><span class=line>    <span class=meta>@Bean(destroyMethod="")</span></span><br><span class=line>    <span class=keyword>public</span> DataSource <span class="title function_">dataSource</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>Context</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">InitialContext</span>();</span><br><span class=line>        <span class=keyword>return</span> (DataSource) ctx.lookup(<span class=string>"java:comp/env/jdbc/datasource"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>配置文件字符串可以包含简单的配置文件名称（例如<code>production</code>）或配置文件表达式。配置文件表达式允许表达更复杂的配置文件逻辑（例如<code>production & us-east</code>）。概要文件表达式中支持以下运算符：</p> <ul><li><code>!</code>：配置文件的逻辑“非”<li><code>&</code>：配置文件的逻辑“与”<li><code>|</code>：配置文件的逻辑“或”</ul> <p>您可以将其<code>@Profile</code>用作<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-meta-annotations rel=noopener target=_blank>元注释</a>，以创建自定义的组合注释。以下示例定义了一个自定义 <code>@Production</code>批注，您可以将其用作 <code>@Profile("production")</code>的替代品：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Target(ElementType.TYPE)</span></span><br><span class=line><span class=meta>@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=line><span class=meta>@Profile("production")</span></span><br><span class=line><span class=keyword>public</span> <span class=meta>@interface</span> Production {</span><br><span class=line>}</span><br></pre></table></figure> <p><code>@Profile</code> 也可以在方法级别声明为仅包含配置类的一个特定Bean（例如，特定Bean的替代变体），如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean("dataSource")</span></span><br><span class=line>    <span class=meta>@Profile("development")</span> </span><br><span class=line>    <span class=keyword>public</span> DataSource <span class="title function_">standaloneDataSource</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">EmbeddedDatabaseBuilder</span>()</span><br><span class=line>            .setType(EmbeddedDatabaseType.HSQL)</span><br><span class=line>            .addScript(<span class=string>"classpath:com/bank/config/sql/schema.sql"</span>)</span><br><span class=line>            .addScript(<span class=string>"classpath:com/bank/config/sql/test-data.sql"</span>)</span><br><span class=line>            .build();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean("dataSource")</span></span><br><span class=line>    <span class=meta>@Profile("production")</span> </span><br><span class=line>    <span class=keyword>public</span> DataSource <span class="title function_">jndiDataSource</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>Context</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">InitialContext</span>();</span><br><span class=line>        <span class=keyword>return</span> (DataSource) ctx.lookup(<span class=string>"java:comp/env/jdbc/datasource"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <ul><li><strong>(1)</strong> <code>standaloneDataSource</code>方法仅在<code>development</code>Profile 中可用。<li><strong>(2)</strong> <code>jndiDataSource</code>方法仅在<code>production</code>Profile 中可用。</ul> <h5 id=XML-Bean定义配置文件><a title="XML Bean定义配置文件" class=headerlink href=#XML-Bean定义配置文件></a>XML Bean定义配置文件</h5><p>XML 对应项是<code>&LTbeans></code>元素的<code>profile</code>属性。我们前面的示例配置可以用两个 XML 文件重写，如下所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>profile</span>=<span class=string>"development"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:jdbc</span>=<span class=string>"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"..."</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>jdbc:embedded-database</span> <span class=attr>id</span>=<span class=string>"dataSource"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>jdbc:script</span> <span class=attr>location</span>=<span class=string>"classpath:com/bank/config/sql/schema.sql"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>jdbc:script</span> <span class=attr>location</span>=<span class=string>"classpath:com/bank/config/sql/test-data.sql"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>jdbc:embedded-database</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>profile</span>=<span class=string>"production"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:jee</span>=<span class=string>"http://www.springframework.org/schema/jee"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"..."</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>jee:jndi-lookup</span> <span class=attr>id</span>=<span class=string>"dataSource"</span> <span class=attr>jndi-name</span>=<span class=string>"java:comp/env/jdbc/datasource"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>也可以避免在同一文件中拆分和嵌套<code>&LTbeans/></code>元素，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:jdbc</span>=<span class=string>"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:jee</span>=<span class=string>"http://www.springframework.org/schema/jee"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"..."</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- other bean definitions --></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>beans</span> <span class=attr>profile</span>=<span class=string>"development"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>jdbc:embedded-database</span> <span class=attr>id</span>=<span class=string>"dataSource"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>jdbc:script</span> <span class=attr>location</span>=<span class=string>"classpath:com/bank/config/sql/schema.sql"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>jdbc:script</span> <span class=attr>location</span>=<span class=string>"classpath:com/bank/config/sql/test-data.sql"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>jdbc:embedded-database</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>beans</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>beans</span> <span class=attr>profile</span>=<span class=string>"production"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>jee:jndi-lookup</span> <span class=attr>id</span>=<span class=string>"dataSource"</span> <span class=attr>jndi-name</span>=<span class=string>"java:comp/env/jdbc/datasource"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>beans</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p><code>spring-bean.xsd</code>已被限制为仅允许这些元素作为文件中的最后一个元素。这应该有助于提供灵 Active，而不会引起 XML 文件混乱。</p> <h5 id=激活Profile><a class=headerlink href=#激活Profile title=激活Profile></a>激活Profile</h5><p>可以通过多种方式来激活配置文件，但是最直接的方法是针对通过<code>ApplicationContext</code>可用的<code>Environment</code> API 以编程方式进行配置。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=type>AnnotationConfigApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class=line>ctx.getEnvironment().setActiveProfiles(<span class=string>"development"</span>);</span><br><span class=line>ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);</span><br><span class=line>ctx.refresh();</span><br></pre></table></figure> <p>此外，您还可以通过<code>spring.profiles.active</code>属性以声明方式激活概要文件，该属性可以通过系统环境变量，JVM 系统属性，<code>web.xml</code>中的 servlet 上下文参数来指定，甚至可以作为 JNDI 中的条目来指定(请参阅<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-property-source-abstraction rel=noopener target=_blank>PropertySource Abstraction</a>)。在集成测试中，可以使用<code>spring-test</code>模块中的<code>@ActiveProfiles</code>注解来声明活动配置文件(请参阅<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/testing.html#testcontext-ctx-management-env-profiles rel=noopener target=_blank>使用环境配置文件进行上下文配置</a>)。</p> <p>请注意，配置文件不是“非此即彼”的命题。您可以一次激活多个配置文件。您可以通过编程方式为<code>setActiveProfiles()</code>方法提供多个配置文件名称，该方法接受<code>String…</code> varargs。以下示例激活多个配置文件：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>ctx.getEnvironment().setActiveProfiles(<span class=string>"profile1"</span>, <span class=string>"profile2"</span>);</span><br></pre></table></figure> <p>以声明方式，<code>spring.profiles.active</code>可以接受以逗号分隔的配置文件名称列表，如以下示例所示：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-Dspring.profiles.active=<span class=string>"profile1,profile2"</span></span><br></pre></table></figure> <h5 id=默认配置文件><a class=headerlink href=#默认配置文件 title=默认配置文件></a>默认配置文件</h5><p>默认配置文件表示默认情况下启用的配置文件。考虑以下示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@Profile("default")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DefaultDataConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> DataSource <span class="title function_">dataSource</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">EmbeddedDatabaseBuilder</span>()</span><br><span class=line>            .setType(EmbeddedDatabaseType.HSQL)</span><br><span class=line>            .addScript(<span class=string>"classpath:com/bank/config/sql/schema.sql"</span>)</span><br><span class=line>            .build();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>如果没有配置文件处于活动状态，则将<code>dataSource</code>创建。您可以看到这是为一个或多个bean提供默认定义的一种方法。如果启用了任何配置文件，则默认配置文件不适用。</p> <p>您可以通过在<code>Environment</code>上使用<code>setDefaultProfiles()</code>或pass 语句<code>spring.profiles.default</code>属性来更改默认配置文件的名称。</p> <h4 id=2-1-13-2、PropertySource抽象><a class=headerlink href=#2-1-13-2、PropertySource抽象 title=2.1.13.2、PropertySource抽象></a>2.1.13.2、<code>PropertySource</code>抽象</h4><p>Spring的<code>Environment</code>抽象提供了可配置属性源层次结构上的搜索操作。考虑以下清单：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=type>ApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class=line><span class=type>Environment</span> <span class=variable>env</span> <span class=operator>=</span> ctx.getEnvironment();</span><br><span class=line><span class=type>boolean</span> <span class=variable>containsMyProperty</span> <span class=operator>=</span> env.containsProperty(<span class=string>"my-property"</span>);</span><br><span class=line>System.out.println(<span class=string>"Does my environment contain the 'my-property' property? "</span> + containsMyProperty);</span><br></pre></table></figure> <p>在前面的代码片段中，我们看到了一种询问 Spring 是否为当前环境定义<code>my-property</code>属性的高级方法。为了回答这个问题，<code>Environment</code>对象对一组<a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html rel=noopener target=_blank>PropertySource</a>对象执行搜索。 <code>PropertySource</code>是对任何键-值对源的简单抽象，而 Spring 的<a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/env/StandardEnvironment.html rel=noopener target=_blank>StandardEnvironment</a>配置了两个 PropertySource 对象-一个代表 JVM 系统属性集(<code>System.getProperties()</code>)和一个代表系统环境变量集(<code>System.getenv()</code>)。</p> <p>具体来说，当您使用<code>StandardEnvironment</code>时，如果在运行时存在<code>my-property</code>系统属性或<code>my-propertyi</code>环境变量，则对<code>env.containsProperty("my-property")</code>的调用将返回 true。</p> <h4 id=2-1-13-3。使用-PropertySource><a class=headerlink href=#2-1-13-3。使用-PropertySource title=2.1.13.3。使用@PropertySource></a>2.1.13.3。使用<code>@PropertySource</code></h4><p><a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html rel=noopener target=_blank>@PropertySource</a>注解 为将<code>PropertySource</code>添加到 Spring 的<code>Environment</code>提供了一种方便的声明性机制。</p> <p>给定名为<code>app.properties</code>的文件，其中包含键值对<code>testbean.name=myTestBean</code>，以下<code>@Configuration</code>类使用<code>@PropertySource</code>，从而对<code>testBean.getName()</code>的调用返回<code>myTestBean</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@PropertySource("classpath:/com/myco/app.properties")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    Environment env;</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> TestBean <span class="title function_">testBean</span><span class=params>()</span> {</span><br><span class=line>        <span class=type>TestBean</span> <span class=variable>testBean</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TestBean</span>();</span><br><span class=line>        testBean.setName(env.getProperty(<span class=string>"testbean.name"</span>));</span><br><span class=line>        <span class=keyword>return</span> testBean;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>资源位置中<code>${…}</code>存在的所有占位符<code>@PropertySource</code>都是根据已经针对环境注册的一组属性源来解析的，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@PropertySource("classpath:/com/${my.placeholder:default/path}/app.properties")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    Environment env;</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> TestBean <span class="title function_">testBean</span><span class=params>()</span> {</span><br><span class=line>        <span class=type>TestBean</span> <span class=variable>testBean</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TestBean</span>();</span><br><span class=line>        testBean.setName(env.getProperty(<span class=string>"testbean.name"</span>));</span><br><span class=line>        <span class=keyword>return</span> testBean;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>假定<code>my.placeholder</code>存在于已注册的属性源之一（例如，系统属性或环境变量）中，则占位符将解析为相应的值。如果不是，则<code>default/path</code>用作默认值。如果未指定默认值并且无法解析属性， 则会引发<code>IllegalArgumentException</code>。</p> <h4 id=2-1-13-4。声明中的占位符解析><a class=headerlink href=#2-1-13-4。声明中的占位符解析 title=2.1.13.4。声明中的占位符解析></a>2.1.13.4。声明中的占位符解析</h4><p>从历史上看，元素中占位符的值只能根据 JVM 系统属性或环境变量来解析。这已不再是这种情况。由于<code>Environment</code>抽象集成在整个容器中，因此很容易通过它路由占位符的解析。这意味着您可以按照自己喜欢的任何方式配置解析过程。您可以更改搜索系统属性和环境变量的优先级，也可以完全删除它们。您还可以根据需要将自己的属性源添加到组合中。</p> <p>具体来说，只要在<code>Environment</code>中可用，以下语句无论在<code>customer</code>属性的定义位置如何都有效：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>import</span> <span class=attr>resource</span>=<span class=string>"com/bank/service/${customer}-config.xml"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h3 id=2-1-14、注册一个LoadTimeWeaver><a class=headerlink href=#2-1-14、注册一个LoadTimeWeaver title=2.1.14、注册一个LoadTimeWeaver></a>2.1.14、注册一个LoadTimeWeaver</h3><p><code>LoadTimeWeaver</code>被 Spring 使用，以在将类加载到 Java 虚拟机(JVM)中时对其进行动态转换。</p> <p>要启用加载时编织，可以将<code>@EnableLoadTimeWeaving</code>添加到<code>@Configuration</code>类之一，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableLoadTimeWeaving</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>}</span><br></pre></table></figure> <p>另外，对于XML配置，可以使用<code>context:load-time-weaver</code>元素：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>context:load-time-weaver</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>一旦为<code>ApplicationContext</code>配置，该<code>ApplicationContext</code>内的任何 bean 都可以实现<code>LoadTimeWeaverAware</code>，从而接收到对加载时编织器实例的引用。</p> <h3 id=2-1-15、ApplicationContext的其它功能><a class=headerlink href=#2-1-15、ApplicationContext的其它功能 title=2.1.15、ApplicationContext的其它功能></a>2.1.15、ApplicationContext的其它功能</h3><ul><li>为了以更面向框架的方式增强<code>BeanFactory</code>功能，上下文包还提供以下功能：<ul><li>通过<code>MessageSource</code>界面访问 i18n 样式的消息。<li>通过<code>ResourceLoader</code>界面访问资源，例如 URL 和文件。<li>事件发布，即通过使用<code>ApplicationEventPublisher</code>接口发布给实现<code>ApplicationListener</code>接口的 bean。<li>加载多个(分层)上下文，使每个上下文都通过<code>HierarchicalBeanFactory</code>接口集中在一个特定的层上，例如应用程序的 Web 层。</ul></ul> <h4 id=2-1-15-1、使用MessageSource进行国际化><a class=headerlink href=#2-1-15-1、使用MessageSource进行国际化 title=2.1.15.1、使用MessageSource进行国际化></a>2.1.15.1、使用MessageSource进行国际化</h4><p><code>plicationContext</code>接口扩展了名为<code>MessageSource</code>的接口，因此提供了国际化(“ i18n”)功能。 Spring 还提供了<code>HierarchicalMessageSource</code>接口，该接口可以分层解析消息。这些接口一起提供了 Spring 影响消息解析的基础。这些接口上定义的方法包括：</p> <ul><li><code>String getMessage(String code, Object[] args, String default, Locale loc)</code>：用于从<code>MessageSource</code>检索消息的基本方法。如果找不到针对指定语言环境的消息，则使用默认消息。使用标准库提供的<code>MessageFormat</code>功能，传入的所有参数都将成为替换值。<li><code>String getMessage(String code, Object[] args, Locale loc)</code>：与以前的方法基本相同，但有一个区别：不能指定默认消息。如果找不到该消息，则抛出<code>NoSuchMessageException</code>。<li><code>String getMessage(MessageSourceResolvable resolvable, Locale locale)</code>：前面方法中使用的所有属性也都包装在名为<code>MessageSourceResolvable</code>的类中，您可以将其与该方法一起使用。</ul> <p>Spring提供了两种<code>MessageSource</code>实现，<code>ResourceBundleMessageSource</code>和 <code>StaticMessageSource</code>。两者都实现<code>HierarchicalMessageSource</code>以便进行嵌套消息传递。 <code>StaticMessageSource</code>很少使用，但提供了将消息添加到源中的编程方式。以下示例显示<code>ResourceBundleMessageSource</code>：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"messageSource"</span> <span class=attr>class</span>=<span class=string>"org.springframework.context.support.ResourceBundleMessageSource"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"basenames"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>list</span>></span></span><br><span class=line>                <span class=tag><<span class=name>value</span>></span>format<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>                <span class=tag><<span class=name>value</span>></span>exceptions<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>                <span class=tag><<span class=name>value</span>></span>windows<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>list</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>该示例假定您在 Classpath 中定义了三个名为<code>format</code>，<code>exceptions</code>和<code>windows</code>的资源包。任何解析消息的请求都通过 JDK 标准的<code>ResourceBundle</code>对象解析消息来处理。就本示例而言，假定上述两个资源束文件的内容如下：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line># in format.properties</span><br><span class=line>message=Alligators rock!</span><br><span class=line></span><br><span class=line># in exceptions.properties</span><br><span class=line>argument.required=The {0} argument is required.</span><br></pre></table></figure> <p>下一个示例显示了执行<code>MessageSource</code>功能的程序。请记住，所有<code>ApplicationContext</code>实现也是<code>MessageSource</code>实现，因此可以转换为<code>MessageSource</code>接口。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=type>MessageSource</span> <span class=variable>resources</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class=string>"beans.xml"</span>);</span><br><span class=line>    <span class=type>String</span> <span class=variable>message</span> <span class=operator>=</span> resources.getMessage(<span class=string>"message"</span>, <span class=literal>null</span>, <span class=string>"Default"</span>, <span class=literal>null</span>);</span><br><span class=line>    System.out.println(message);</span><br><span class=line>}</span><br></pre></table></figure> <p>下一个示例显示了传递给消息查找的参数。这些参数将转换为<code>String</code>对象，并插入到查找消息中的占位符中。</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=comment>&LT!-- this MessageSource is being used in a web application --></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"messageSource"</span> <span class=attr>class</span>=<span class=string>"org.springframework.context.support.ResourceBundleMessageSource"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"basename"</span> <span class=attr>value</span>=<span class=string>"exceptions"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=comment>&LT!-- lets inject the above MessageSource into this POJO --></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"example"</span> <span class=attr>class</span>=<span class=string>"com.something.Example"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"messages"</span> <span class=attr>ref</span>=<span class=string>"messageSource"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>在以下示例中，手动指定了针对其解析（英国）消息的语言环境：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>＃在exceptions_en_GB.properties </span><br><span class=line>parameter.required = Ebagum lad中，“ {0}”自变量是必需的，我说是必需的。</span><br></pre></table></figure> <p>您还可以使用<code>MessageSourceAware</code>界面获取对已定义的任何<code>MessageSource</code>的引用。创建和配置 Bean 时，在实现<code>MessageSourceAware</code>接口的<code>ApplicationContext</code>中定义的任何 Bean 都会被注入应用程序上下文的<code>MessageSource</code>。</p> <h4 id=2-1-15-2、标准和自定义事件><a class=headerlink href=#2-1-15-2、标准和自定义事件 title=2.1.15.2、标准和自定义事件></a>2.1.15.2、标准和自定义事件</h4><p><code>ApplicationContext</code>中的事件处理是通过<code>ApplicationEvent</code>类和<code>ApplicationListener</code>接口提供的。如果将实现<code>ApplicationListener</code>接口的 bean 部署到上下文中，则每次将<code>ApplicationEvent</code>发布到<code>ApplicationContext</code>时，都会通知该 bean。本质上，这是标准的 Observer 设计模式。</p> <p>下表描述了Spring提供的标准事件：</p> <table><thead><tr><th align=left>事件<th align=left>说明<tbody><tr><td align=left><code>ContextRefreshedEvent</code><td align=left>在<code>ApplicationContext</code>初始化或刷新时发布（例如，通过使用接口<code>refresh()</code>上的方法<code>ConfigurableApplicationContext</code>）。在这里，“已初始化”表示已加载所有bean，检测到并激活了后处理器bean，预先实例化了单例，并且<code>ApplicationContext</code>可以使用该对象。只要尚未关闭上下文，就可以多次触发刷新，前提是所选对象<code>ApplicationContext</code>实际上支持这种“热”刷新。例如，<code>XmlWebApplicationContext</code>支持热刷新，但<code>GenericApplicationContext</code>不支持 。<tr><td align=left><code>ContextStartedEvent</code><td align=left><code>ApplicationContext</code>使用界面<code>start()</code>上的方法 启动时发布<code>ConfigurableApplicationContext</code>。在这里，“启动”意味着所有<code>Lifecycle</code> bean都收到一个明确的启动信号。通常，此信号用于在显式停止后重新启动Bean，但也可以用于启动尚未配置为自动启动的组件（例如，尚未在初始化时启动的组件）。<tr><td align=left><code>ContextStoppedEvent</code><td align=left><code>ApplicationContext</code>使用界面<code>stop()</code>上的方法 停止时发布<code>ConfigurableApplicationContext</code>。此处，“已停止”表示所有<code>Lifecycle</code> bean均收到明确的停止信号。停止的上下文可以通过<code>start()</code>调用重新启动 。<tr><td align=left><code>ContextClosedEvent</code><td align=left>当发布时间<code>ApplicationContext</code>是由使用封闭<code>close()</code>方法的上<code>ConfigurableApplicationContext</code>接口或经由JVM关闭挂钩。在这里，“封闭”意味着所有单例豆将被销毁。关闭上下文后，它将达到使用寿命，无法刷新或重新启动。<tr><td align=left><code>RequestHandledEvent</code><td align=left>一个特定于Web的事件，告诉所有Bean HTTP请求已得到服务。请求完成后，将发布此事件。此事件仅适用于使用Spring的Web应用程序<code>DispatcherServlet</code>。<tr><td align=left><code>ServletRequestHandledEvent</code><td align=left>它的子类<code>RequestHandledEvent</code>添加了特定于Servlet的上下文信息。</table> <p>您还可以创建和发布自己的自定义事件。下面的示例显示了一个简单的类，该类扩展了Spring的<code>ApplicationEvent</code>基类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BlockedListEvent</span> <span class=keyword>extends</span> <span class="title class_">ApplicationEvent</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> String address;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> String content;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">BlockedListEvent</span><span class=params>(Object source, String address, String content)</span>{</span><br><span class=line>        <span class=built_in>super</span>(source);</span><br><span class=line>        <span class=built_in>this</span>.address = address;</span><br><span class=line>        <span class=built_in>this</span>.content = content;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// accessor and other methods...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>要发布自定义<code>ApplicationEvent</code>，请在<code>ApplicationEventPublisher</code>上调用<code>publishEvent()</code>方法。通常，这是通过创建一个实现<code>ApplicationEventPublisherAware</code>的类并将其注册为 Spring bean 来完成的。以下示例显示了此类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">EmailService</span> <span class=keyword>implements</span> <span class="title class_">ApplicationEventPublisherAware</span> {</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> List&LTString> blockedList;</span><br><span class=line>    <span class=keyword>private</span> ApplicationEventPublisher publisher;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setBlockedList</span><span class=params>(List&LTString> blockedList)</span> {</span><br><span class=line>        <span class=built_in>this</span>.blockedList = blockedList;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setApplicationEventPublisher</span><span class=params>(ApplicationEventPublisher publisher)</span> {</span><br><span class=line>        <span class=built_in>this</span>.publisher = publisher;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">sendEmail</span><span class=params>(String address, String content)</span> {</span><br><span class=line>        <span class=keyword>if</span> (blockedList.contains(address)) {</span><br><span class=line>            publisher.publishEvent(<span class=keyword>new</span> <span class="title class_">BlockedListEvent</span>(<span class=built_in>this</span>, address, content));</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// send email...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>在配置时，Spring容器检测到该<code>EmailService</code>实现 <code>ApplicationEventPublisherAware</code>并自动调用 <code>setApplicationEventPublisher()</code>。实际上，传入的参数是Spring容器本身。您正在通过其<code>ApplicationEventPublisher</code>界面与应用程序上下文进行 交互。</p> <p>要接收自定义<code>ApplicationEvent</code>，您可以创建一个实现 <code>ApplicationListener</code>并注册为Spring bean的类。以下示例显示了此类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BlockedListNotifier</span> <span class=keyword>implements</span> <span class="title class_">ApplicationListener</span>&LTBlockedListEvent> {</span><br><span class=line>    <span class=keyword>private</span> String notificationAddress;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setNotificationAddress</span><span class=params>(String notificationAddress)</span> {</span><br><span class=line>        <span class=built_in>this</span>.notificationAddress = notificationAddress;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">onApplicationEvent</span><span class=params>(BlockedListEvent event)</span> {</span><br><span class=line>        <span class=comment>// notify appropriate parties via notificationAddress...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>注意，<code>ApplicationListener</code>通常用您的自定义事件的类型(上一示例中的<code>BlackListEvent</code>)进行参数化。这意味着<code>onApplicationEvent()</code>方法可以保持类型安全，从而避免了向下转换的任何需要。您可以根据需要注册任意数量的事件侦听器，但是请注意，默认情况下，事件侦听器会同步接收事件。这意味着<code>publishEvent()</code>方法将阻塞，直到所有侦听器都已完成对事件的处理为止。这种同步和单线程方法的一个优点是，当侦听器收到事件时，如果有可用的事务上下文，它将在发布者的事务上下文内部进行操作。</p> <p>以下示例显示了用于注册和配置上述每个类的Bean定义：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"emailService"</span> <span class=attr>class</span>=<span class=string>"example.EmailService"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"blockedList"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>list</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>known.spammer@example.org<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>known.hacker@example.org<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>john.doe@example.org<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>list</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"blockedListNotifier"</span> <span class=attr>class</span>=<span class=string>"example.BlockedListNotifier"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"notificationAddress"</span> <span class=attr>value</span>=<span class=string>"blockedlist@example.org"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>将所有内容放在一起，当调用<code>emailService</code> bean 的<code>sendEmail()</code>方法时，如果有任何电子邮件消息应列入黑名单，则会发布<code>BlackListEvent</code>类型的自定义事件。 <code>blackListNotifier</code> bean 注册为<code>ApplicationListener</code>并接收<code>BlackListEvent</code>，此时它可以通知适当的参与者。</p> <h5 id=基于注释的事件侦听器><a class=headerlink href=#基于注释的事件侦听器 title=基于注释的事件侦听器></a>基于注释的事件侦听器</h5><p>从Spring 4.2开始，您可以使用<code>@EventListener</code>注释在托管Bean的任何公共方法上注册事件侦听器。该<code>BlockedListNotifier</code>可改写如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BlockedListNotifier</span> {</span><br><span class=line>    <span class=keyword>private</span> String notificationAddress;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setNotificationAddress</span><span class=params>(String notificationAddress)</span> {</span><br><span class=line>        <span class=built_in>this</span>.notificationAddress = notificationAddress;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@EventListener</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">processBlockedListEvent</span><span class=params>(BlockedListEvent event)</span> {</span><br><span class=line>        <span class=comment>// notify appropriate parties via notificationAddress...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>方法签名再次声明其侦听的事件类型，但是这次使用灵活的名称并且没有实现特定的侦听器接口。只要实际事件类型在其实现层次结构中解析您的通用参数，也可以通过通用类型来缩小事件类型。</p> <p>如果您的方法应该侦听多个事件，或者您要完全不使用任何参数来定义它，则事件类型也可以在注解本身上指定。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">handleContextStart</span><span class=params>()</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>也可以通过使用定义<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions rel=noopener target=_blank>SpEL expression</a>的注解的<code>condition</code>属性来添加其他运行时过滤，该属性应匹配以针对特定事件实际调用该方法。</p> <p>以下示例显示了仅当事件的<code>content</code>属性等于<code>my-event</code>时，才可以重写我们的通知程序以进行调用：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@EventListener(condition = "#blEvent.content == 'my-event'")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">processBlockedListEvent</span><span class=params>(BlockedListEvent blockedListEvent)</span> {</span><br><span class=line>    <span class=comment>// notify appropriate parties via notificationAddress...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>每个<code>SpEL</code>表达式针对专用上下文进行评估。下表列出了可用于上下文的项目，以便您可以将它们用于条件事件处理：</p> <table><thead><tr><th align=left>名称<th align=left>位置<th align=left>描述<th align=left>例<tbody><tr><td align=left>Event<td align=left>root object<td align=left>实际的<code>ApplicationEvent</code>。<td align=left><code>#root.event</code> 要么 <code>event</code><tr><td align=left>Arguments array<td align=left>root object<td align=left>用于调用方法的参数（作为对象数组）。<td align=left><code>#root.args</code>或<code>args</code>; <code>args[0]</code>访问第一个参数，等等。<tr><td align=left>Argument name<td align=left>evaluation context<td align=left>任何方法参数的名称。如果由于某种原因这些名称不可用（例如，由于在编译的字节码中没有调试信息），则还可以使用<code>#a<#arg></code>其中<code><#arg></code>参数代表参数索引（从0开始）的语法提供各个参数。<td align=left><code>#blEvent</code>或<code>#a0</code>（您也可以使用<code>#p0</code>或<code>#p<#arg></code>参数符号作为别名）</table> <p>请注意，即使您的方法签名实际上引用了已发布的任意对象，<code>#root.event</code>也使您可以访问基础事件。</p> <p>如果由于处理另一个事件而需要发布一个事件，则可以更改方法签名以返回应发布的事件，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@EventListener</span></span><br><span class=line><span class=keyword>public</span> ListUpdateEvent <span class="title function_">handleBlockedListEvent</span><span class=params>(BlockedListEvent event)</span> {</span><br><span class=line>    <span class=comment>// notify appropriate parties via notificationAddress and</span></span><br><span class=line>    <span class=comment>// then publish a ListUpdateEvent...</span></span><br><span class=line>}</span><br></pre></table></figure> <blockquote><p><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-functionality-events-async rel=noopener target=_blank>异步侦听</a> 器不支持此功能 。</blockquote> <h5 id=异步侦听器><a class=headerlink href=#异步侦听器 title=异步侦听器></a>异步侦听器</h5><p>果希望特定的侦听器异步处理事件，则可以重用<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#scheduling-annotation-support-async rel=noopener target=_blank>常规@Async 支持</a>。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@EventListener</span></span><br><span class=line><span class=meta>@Async</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">processBlockedListEvent</span><span class=params>(BlockedListEvent event)</span> {</span><br><span class=line>    <span class=comment>// BlockedListEvent is processed in a separate thread</span></span><br><span class=line>}</span><br></pre></table></figure> <p>使用异步事件时，请注意以下限制：</p> <ul><li>如果事件监听器抛出<code>Exception</code>，则它不会传播到调用者。有关更多详细信息，请参见<code>AsyncUncaughtExceptionHandler</code>。<li>此类事件侦听器无法发送答复。如果您需要发送另一个事件作为处理结果，请注入<a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.html rel=noopener target=_blank>ApplicationEventPublisher</a>以手动发送事件。</ul> <h5 id=一般事件><a class=headerlink href=#一般事件 title=一般事件></a>一般事件</h5><p>您还可以使用泛型来进一步定义事件的结构。考虑使用 <code>EntityCreatedEvent&LTT></code>where<code>T</code>是创建的实际实体的类型。例如，您可以创建以下侦听器定义只接收<code>EntityCreatedEvent</code>了 <code>Person</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@EventListener</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">onPersonCreated</span><span class=params>(EntityCreatedEvent&LTPerson> event)</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>由于类型擦除，只有在触发的事件解析了事件侦听器所依据的通用参数(即诸如<code>class PersonCreatedEvent extends EntityCreatedEvent&LTPerson> { … }</code>)时，此方法才起作用。</p> <p>在某些情况下，如果所有事件都遵循相同的结构，这可能会变得很乏味(就像前面示例中的事件一样)。在这种情况下，您可以实现<code>ResolvableTypeProvider</code>以指导框架超出运行时环境提供的范围。以下事件显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">EntityCreatedEvent</span>&LTT> <span class=keyword>extends</span> <span class="title class_">ApplicationEvent</span> <span class=keyword>implements</span> <span class="title class_">ResolvableTypeProvider</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">EntityCreatedEvent</span><span class=params>(T entity)</span> {</span><br><span class=line>        <span class=built_in>super</span>(entity);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> ResolvableType <span class="title function_">getResolvableType</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource()));</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=2-1-15-3、方便地访问资源><a class=headerlink href=#2-1-15-3、方便地访问资源 title=2.1.15.3、方便地访问资源></a>2.1.15.3、方便地访问资源</h4><p>应用程序上下文是<code>ResourceLoader</code>，可用于加载<code>Resource</code>个对象。 <code>Resource</code>本质上是 JDK <code>java.net.URL</code>类的功能更丰富的版本。实际上，<code>Resource</code>的实现在适当的地方包装了<code>java.net.URL</code>的实例。 <code>Resource</code>可以从几乎任何位置以透明方式获取低级资源，包括从 Classpath，文件系统位置，可使用标准 URL 描述的任何位置以及其他一些变体。如果资源位置字符串是没有任何特殊前缀的简单路径，则这些资源的来源是特定的，并且适合于实际的应用程序上下文类型。</p> <h4 id=2-1-15-4、应用程序启动跟踪><a class=headerlink href=#2-1-15-4、应用程序启动跟踪 title=2.1.15.4、应用程序启动跟踪></a>2.1.15.4、应用程序启动跟踪</h4><p>该<code>ApplicationContext</code>管理器管理Spring应用程序的生命周期，并围绕组件提供丰富的编程模型。结果，复杂的应用程序可能具有同样复杂的组件图和启动阶段。</p> <p>使用特定的指标跟踪应用程序的启动步骤可以帮助您了解启动阶段所花的时间，但是它也可以用作更好地了解整个上下文生命周期的一种方式。</p> <p>的<code>AbstractApplicationContext</code>（及其子类）的仪表用 <code>ApplicationStartup</code>，它收集<code>StartupStep</code>有关各种启动阶段数据：</p> <ul><li>应用程序上下文生命周期（基本软件包扫描，配置类管理）<li>bean生命周期（实例化，智能初始化，后处理）<li>应用程序事件处理</ul> <p>这是在中的检测示例<code>AnnotationConfigApplicationContext</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment>// create a startup step and start recording</span></span><br><span class=line><span class=type>StartupStep</span> <span class=variable>scanPackages</span> <span class=operator>=</span> <span class=built_in>this</span>.getApplicationStartup().start(<span class=string>"spring.context.base-packages.scan"</span>);</span><br><span class=line><span class=comment>// add tagging information to the current step</span></span><br><span class=line>scanPackages.tag(<span class=string>"packages"</span>, () -> Arrays.toString(basePackages));</span><br><span class=line><span class=comment>// perform the actual phase we're instrumenting</span></span><br><span class=line><span class=built_in>this</span>.scanner.scan(basePackages);</span><br><span class=line><span class=comment>// end the current step</span></span><br><span class=line>scanPackages.end();</span><br></pre></table></figure> <p>应用程序上下文已通过多个步骤进行了检测。记录后，可以使用特定工具收集，显示和分析这些启动步骤。</p> <p>默认<code>ApplicationStartup</code>实现是无操作变体，以减少开销。这意味着默认情况下在应用程序启动期间不会收集任何指标。Spring Framework附带了一个用于使用Java Flight Recorder跟踪启动步骤的实现： <code>FlightRecorderApplicationStartup</code>。要使用此变体，必须<code>ApplicationContext</code>在创建后立即将其实例配置为。</p> <p>如果开发人员<code>ApplicationStartup</code>提供了自己的<code>AbstractApplicationContext</code>子类，或者希望收集更精确的数据，则也可以使用基础结构 。</p> <h4 id=2-1-15-5、Web应用程序的便捷><a class=headerlink href=#2-1-15-5、Web应用程序的便捷 title=2.1.15.5、Web应用程序的便捷></a>2.1.15.5、Web应用程序的便捷</h4><p>您可以使用<code>ContextLoader</code>声明性地创建<code>ApplicationContext</code>实例。当然，您也可以使用<code>ApplicationContext</code>实现之一以编程方式创建<code>ApplicationContext</code>实例。</p> <p>您可以使用<code>ContextLoaderListener</code>注册<code>ApplicationContext</code>，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>context-param</span>></span></span><br><span class=line>    <span class=tag><<span class=name>param-name</span>></span>contextConfigLocation<span class=tag>&LT/<span class=name>param-name</span>></span></span><br><span class=line>    <span class=tag><<span class=name>param-value</span>></span>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml<span class=tag>&LT/<span class=name>param-value</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>context-param</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>listener</span>></span></span><br><span class=line>    <span class=tag><<span class=name>listener-class</span>></span>org.springframework.web.context.ContextLoaderListener<span class=tag>&LT/<span class=name>listener-class</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>listener</span>></span></span><br></pre></table></figure> <p>侦听器检查<code>contextConfigLocation</code>参数。如果参数不存在，那么侦听器将使用<code>/WEB-INF/applicationContext.xml</code>作为默认值。当参数确实存在时，侦听器将使用 sched 义的定界符(逗号，分号和空格)来分隔<code>String</code>，并将这些值用作搜索应用程序上下文的位置。还支持 Ant 风格的路径模式。示例为<code>/WEB-INF/*Context.xml</code>(对于名称以<code>Context.xml</code>结尾并且位于<code>WEB-INF</code>目录中的所有文件)和<code>/WEB-INF/**/*Context.xml</code>(对于<code>WEB-INF</code>的任何子目录中的所有此类文件)。</p> <h4 id=2-1-15-6、将SpringApplicationContext部署为Java-EE-RAR文件><a title="2.1.15.6、将SpringApplicationContext部署为Java EE RAR文件" class=headerlink href=#2-1-15-6、将SpringApplicationContext部署为Java-EE-RAR文件></a>2.1.15.6、将SpringApplicationContext部署为Java EE RAR文件</h4><p>可以将 Spring <code>ApplicationContext</code>部署为 RAR 文件，并将上下文及其所有必需的 Bean 类和库 JAR 封装在 Java EE RAR 部署单元中。这等效于引导独立的<code>ApplicationContext</code>(仅托管在 Java EE 环境中)能够访问 Java EE 服务器功能。对于部署无头 WAR 文件的情况，RAR 部署是一种更自然的选择-实际上，这种 WAR 文件没有任何 HTTP 入口点，仅用于在 Java EE 环境中引导 Spring <code>ApplicationContext</code>。</p> <p>对于将 Spring ApplicationContext 作为 Java EE RAR 文件的简单部署：</p> <ol><li>将所有应用程序类打包到 RAR 文件(这是具有不同文件 extensions 的标准 JAR 文件)中。将所有必需的库 JAR 添加到 RAR 归档文件的根目录中。添加一个<code>META-INF/ra.xml</code>部署 Descriptors(如<a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html rel=noopener target=_blank>SpringContextResourceAdapter 的 javadoc</a>所示)和相应的 Spring XML bean 定义文件(通常为 META-INF/applicationContext.xml)。<li>将生成的 RAR 文件拖放到应用程序服务器的部署目录中。</ol> <h3 id=2-1-16、BeanFactory><a class=headerlink href=#2-1-16、BeanFactory title=2.1.16、BeanFactory></a>2.1.16、BeanFactory</h3><p><code>BeanFactory</code> API 为 Spring 的 IoC 功能提供了基础。它的特定 Contract 主要用于与 Spring 的其他部分以及相关的第三方框架集成，并且其<code>DefaultListableBeanFactory</code>实现是更高级别<code>GenericApplicationContext</code>容器中的关键委托。</p> <p>注意，核心<code>BeanFactory</code> API 级别及其<code>DefaultListableBeanFactory</code>实现不对配置格式或要使用的任何组件注解进行假设。所有这些风味都是通过 extensions(例如<code>XmlBeanDefinitionReader</code>和<code>AutowiredAnnotationBeanPostProcessor</code>)引入的，并以共享的<code>BeanDefinition</code>对象作为核心元数据表示形式进行操作。这就是使 Spring 的容器如此灵活和可扩展的本质。</p> <h4 id=2-1-16-1、BeanFactory还是ApplicationContext><a class=headerlink href=#2-1-16-1、BeanFactory还是ApplicationContext title=2.1.16.1、BeanFactory还是ApplicationContext></a>2.1.16.1、BeanFactory还是ApplicationContext</h4><p>除非有充分的理由，否则应使用<code>ApplicationContext</code>，除非<code>GenericApplicationContext</code>及其子类<code>AnnotationConfigApplicationContext</code>作为自定义引导的常见实现，否则应使用它们。对于所有常见目的，这些都是 Spring 核心容器的主要入口点：加载配置文件，触发 Classpath 扫描，以编程方式注册 Bean 定义和带注解的类，以及(从 5.0 版本开始)注册功能性 Bean 定义。</p> <p>因为<code>ApplicationContext</code>包含<code>BeanFactory</code>的所有功能，所以通常建议在纯<code>BeanFactory</code>上使用，除非需要完全控制 Bean 处理的情况。在<code>ApplicationContext</code>(例如<code>GenericApplicationContext</code>实现)内，按惯例(即，按 Bean 名称或 Bean 类型(尤其是后处理器))检测到几种 Bean，而普通的<code>DefaultListableBeanFactory</code>则与任何特殊的 Bean 无关。</p> <p>对于许多扩展的容器功能(例如注解处理和 AOP 代理)，<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-extension-bpp rel=noopener target=_blank>BeanPostProcessor 扩展点</a>是必不可少的。如果仅使用普通<code>DefaultListableBeanFactory</code>，则默认情况下不会检测到此类后处理器并将其激活。这种情况可能令人困惑，因为您的 bean 配置实际上并没有错。而是在这种情况下，需要通过其他设置完全引导容器。</p> <p>下表列出了<code>BeanFactory</code>and <code>ApplicationContext</code>接口和实现所提供的功能。</p> <table><thead><tr><th align=left>特征<th align=left><code>BeanFactory</code><th align=left><code>ApplicationContext</code><tbody><tr><td align=left>Bean实例化/接线<td align=left>是<td align=left>是<tr><td align=left>集成生命周期管理<td align=left>没有<td align=left>是<tr><td align=left>自动<code>BeanPostProcessor</code>注册<td align=left>没有<td align=left>是<tr><td align=left>自动<code>BeanFactoryPostProcessor</code>注册<td align=left>没有<td align=left>是<tr><td align=left>便捷<code>MessageSource</code>访问（用于内部化）<td align=left>没有<td align=left>是<tr><td align=left>内置<code>ApplicationEvent</code>发布机制<td align=left>没有<td align=left>是</table> <p>要使用<code>DefaultListableBeanFactory</code>显式注册 bean 后处理器，您需要以编程方式调用<code>addBeanPostProcessor</code>，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>DefaultListableBeanFactory</span> <span class=variable>factory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class=line>factory.addBeanPostProcessor(<span class=keyword>new</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span>());</span><br><span class=line>factory.addBeanPostProcessor(<span class=keyword>new</span> <span class="title class_">MyBeanPostProcessor</span>());</span><br></pre></table></figure> <p>要将<code>BeanFactoryPostProcessor</code>应用于普通<code>DefaultListableBeanFactory</code>，需要调用其<code>postProcessBeanFactory</code>方法，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=type>DefaultListableBeanFactory</span> <span class=variable>factory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class=line><span class=type>XmlBeanDefinitionReader</span> <span class=variable>reader</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">XmlBeanDefinitionReader</span>(factory);</span><br><span class=line>reader.loadBeanDefinitions(<span class=keyword>new</span> <span class="title class_">FileSystemResource</span>(<span class=string>"beans.xml"</span>));</span><br><span class=line></span><br><span class=line><span class=type>PropertySourcesPlaceholderConfigurer</span> <span class=variable>cfg</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">PropertySourcesPlaceholderConfigurer</span>();</span><br><span class=line>cfg.setLocation(<span class=keyword>new</span> <span class="title class_">FileSystemResource</span>(<span class=string>"jdbc.properties"</span>));</span><br><span class=line></span><br><span class=line>cfg.postProcessBeanFactory(factory);</span><br></pre></table></figure> <p>在这两种情况下，显式的注册步骤都是不方便的，这就是为什么在 Spring 支持的应用程序中，各种<code>ApplicationContext</code>变体优于普通<code>DefaultListableBeanFactory</code>的原因，尤其是在典型企业设置中依靠<code>BeanFactoryPostProcessor</code>和<code>BeanPostProcessor</code>实例扩展容器功能时。</p> <blockquote><p><code>AnnotationConfigApplicationContext</code>已注册了所有通用注解后处理器，并且可以通过诸如<code>@EnableTransactionManagement</code>之类的配置注解在幕后引入其他处理器。在 Spring 基于注解的配置模型的抽象级别上，bean 后处理器的概念仅是内部容器详细信息。</blockquote> <h2 id=2-2、AOP-API><a title="2.2、AOP API" class=headerlink href=#2-2、AOP-API></a>2.2、AOP API</h2><h3 id=2-2-1、Spring中的Pointcut-API><a title="2.2.1、Spring中的Pointcut API" class=headerlink href=#2-2-1、Spring中的Pointcut-API></a>2.2.1、Spring中的Pointcut API</h3><h4 id=2-2-1-1、概念><a class=headerlink href=#2-2-1-1、概念 title=2.2.1.1、概念></a>2.2.1.1、概念</h4><p>Spring的切入点模型使切入点重用不受通知类型的影响。您可以使用相同的切入点来定位不同的建议。</p> <p>该<code>org.springframework.aop.Pointcut</code>接口是中央接口，用于将建议定向到特定的类和方法。完整的界面如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Pointcut</span> {</span><br><span class=line>    ClassFilter <span class="title function_">getClassFilter</span><span class=params>()</span>;</span><br><span class=line>    MethodMatcher <span class="title function_">getMethodMatcher</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>将<code>Pointcut</code>接口分为两部分，可以重用类和方法匹配的部分以及细粒度的合成操作（例如与另一个方法匹配器执行“联合”）。</p> <p>该<code>ClassFilter</code>接口用于将切入点限制为给定的一组目标类。如果该<code>matches()</code>方法始终返回true，则匹配所有目标类。以下清单显示了<code>ClassFilter</code>接口定义：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">ClassFilter</span> {</span><br><span class=line>    <span class=type>boolean</span> <span class="title function_">matches</span><span class=params>(Class clazz)</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>该<code>MethodMatcher</code>接口通常更重要。完整的界面如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">MethodMatcher</span> {</span><br><span class=line>    <span class=type>boolean</span> <span class="title function_">matches</span><span class=params>(Method m, Class targetClass)</span>;</span><br><span class=line>    <span class=type>boolean</span> <span class="title function_">isRuntime</span><span class=params>()</span>;</span><br><span class=line>    <span class=type>boolean</span> <span class="title function_">matches</span><span class=params>(Method m, Class targetClass, Object[] args)</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>该<code>matches(Method, Class)</code>方法用于测试此切入点是否与目标类上的给定方法匹配。创建AOP代理时可以执行此评估，以避免需要对每个方法调用进行测试。如果针对一个给定<code>matches</code>方法返回了两个参数的方法<code>true</code>，并且<code>isRuntime()</code> 返回了MethodMatcher的<code>true</code>方法，则每次调用方法时都会调用三个参数的match方法。这使切入点可以在目标建议开始之前立即查看传递给方法调用的参数。</p> <p>大多数<code>MethodMatcher</code>实现都是静态的，这意味着它们的<code>isRuntime()</code>方法将返回<code>false</code>。在这种情况下，<code>matches</code>永远不会调用三参数方法。</p> <blockquote><p>如果可能，请尝试使切入点成为静态，从而允许AOP框架在创建AOP代理时缓存切入点评估的结果。</blockquote> <h4 id=2-2-1-2、切入点操作><a class=headerlink href=#2-2-1-2、切入点操作 title=2.2.1.2、切入点操作></a>2.2.1.2、切入点操作</h4><p>spring支持切入点上的操作（特别是联合和相交）。</p> <p>联合表示两个切入点都匹配的方法。交集是指两个切入点都匹配的方法。联合通常更有用。您可以通过使用类中的静态方法<code>org.springframework.aop.support.Pointcuts</code>或使用<code>ComposablePointcut</code>同一包中的类 来编写切入点 。但是，使用AspectJ切入点表达式通常是一种更简单的方法。</p> <h4 id=2-2-1-3、AspectJ切入点表达式><a class=headerlink href=#2-2-1-3、AspectJ切入点表达式 title=2.2.1.3、AspectJ切入点表达式></a>2.2.1.3、AspectJ切入点表达式</h4><p>从2.0开始，Spring使用的最重要的切入点类型是 <code>org.springframework.aop.aspectj.AspectJExpressionPointcut</code>。这是一个切入点，该切入点使用AspectJ提供的库来解析AspectJ切入点表达式字符串。</p> <h4 id=2-2-1-4、便捷切入点实现><a class=headerlink href=#2-2-1-4、便捷切入点实现 title=2.2.1.4、便捷切入点实现></a>2.2.1.4、便捷切入点实现</h4><p>Spring提供了几种方便的切入点实现。您可以直接使用其中一些。其他的则打算在特定于应用程序的切入点中子类化。</p> <h5 id=静态切入点><a class=headerlink href=#静态切入点 title=静态切入点></a>静态切入点</h5><p>静态切入点基于方法和目标类，并且不能考虑方法的参数。静态切入点对于大多数用途来说是足够的，也是最好的。首次调用方法时，Spring只能评估一次静态切入点。之后，无需在每次方法调用时再次评估切入点。</p> <h6 id=正则表达式切入点><a class=headerlink href=#正则表达式切入点 title=正则表达式切入点></a>正则表达式切入点</h6><p>指定静态切入点的一种明显方法是正则表达式。除了Spring之外，还有几个AOP框架使之成为可能。 <code>org.springframework.aop.support.JdkRegexpMethodPointcut</code>是通用的正则表达式切入点，它使用JDK中的正则表达式支持。</p> <p>通过<code>JdkRegexpMethodPointcut</code>该类，您可以提供模式字符串的列表。如果其中任何一个匹配，则切入点的计算结果为<code>true</code>。（因此，结果切入点实际上是指定模式的并集。）</p> <p>以下示例显示如何使用<code>JdkRegexpMethodPointcut</code>：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"settersAndAbsquatulatePointcut"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.support.JdkRegexpMethodPointcut"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"patterns"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>list</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>.*set.*<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>.*absquatulate<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>list</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>Spring提供了一个名为<code>RegexpMethodPointcutAdvisor</code>的便捷类，它使我们也可以引用<code>Advice</code>。如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"settersAndAbsquatulateAdvisor"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.support.RegexpMethodPointcutAdvisor"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"advice"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>ref</span> <span class=attr>bean</span>=<span class=string>"beanNameOfAopAllianceInterceptor"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"patterns"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>list</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>.*set.*<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>.*absquatulate<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>list</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>您可以使用<code>RegexpMethodPointcutAdvisor</code>任何<code>Advice</code>类型。</p> <h6 id=属性驱动切入点><a class=headerlink href=#属性驱动切入点 title=属性驱动切入点></a>属性驱动切入点</h6><p>静态切入点的一种重要类型是元数据驱动的切入点。这将使用元数据属性的值（通常是源级别的元数据）。</p> <h5 id=动态切入点><a class=headerlink href=#动态切入点 title=动态切入点></a>动态切入点</h5><p>动态切入点比静态切入点更昂贵。它们考虑了方法参数以及静态信息。这意味着必须在每次方法调用时对它们进行评估，并且由于参数会有所不同，因此无法缓存结果。</p> <p>主要示例是<code>control flow</code>切入点。</p> <h6 id=控制流切入点><a class=headerlink href=#控制流切入点 title=控制流切入点></a>控制流切入点</h6><p>弹簧控制流切入点在概念上类似于AspectJ<code>cflow</code>切入点，尽管功能不那么强大。（当前无法指定切入点在与另一个切入点匹配的连接点下运行。）控制流切入点与当前调用堆栈匹配。例如，如果连接点是由<code>com.mycompany.web</code>包中的方法或由<code>SomeCaller</code>类调用的，则可能会触发。使用<code>org.springframework.aop.support.ControlFlowPointcut</code>类指定控制流切入点。</p> <blockquote><p>与其他动态切入点相比，控制流切入点在运行时进行评估要昂贵得多。在Java 1.4中，成本大约是其他动态切入点的五倍。</blockquote> <h4 id=2-2-1-5、切入点超类><a class=headerlink href=#2-2-1-5、切入点超类 title=2.2.1.5、切入点超类></a>2.2.1.5、切入点超类</h4><p>Spring提供了有用的切入点超类，以帮助您实现自己的切入点。</p> <p>因为静态切入点最有用，所以你可以继承 <code>StaticMethodMatcherPointcut</code>来实现。这仅需要实现一个抽象方法（尽管您可以覆盖其他方法以自定义行为）。以下示例显示了如何继承<code>StaticMethodMatcherPointcut</code>来实现静态切入点：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">TestStaticPointcut</span> <span class=keyword>extends</span> <span class="title class_">StaticMethodMatcherPointcut</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">matches</span><span class=params>(Method m, Class targetClass)</span> {</span><br><span class=line>        <span class=comment>// return true if custom criteria match</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>还有动态切入点的超类。您可以将自定义切入点与任何通知类型一起使用。</p> <h4 id=2-2-1-6、自定义切入点><a class=headerlink href=#2-2-1-6、自定义切入点 title=2.2.1.6、自定义切入点></a>2.2.1.6、自定义切入点</h4><p>由于Spring AOP中的切入点是Java类，因此可以声明自定义切入点，无论是静态还是动态。Spring中的自定义切入点可以很复杂。但是，建议使用AspectJ切入点。</p> <blockquote><p>更高版本的Spring可能提供对JAC提供的“语义切入点”的支持，例如，“更改目标对象中实例变量的所有方法”。</blockquote> <h3 id=2-2-2、Spring-Advice-API><a title="2.2.2、Spring Advice API" class=headerlink href=#2-2-2、Spring-Advice-API></a>2.2.2、Spring Advice API</h3><h4 id=2-2-2-1、Advice生命周期><a class=headerlink href=#2-2-2-1、Advice生命周期 title=2.2.2.1、Advice生命周期></a>2.2.2.1、Advice生命周期</h4><p>每个通知都是一个Spring bean。通知实例可以在所有通知对象之间共享，或者对于每个通知对象都是唯一的。这对应于每个class或每个实例的通知。</p> <p>每个class通知最常用。适用于一般通知，例如交易顾问。这些不依赖于代理对象的状态或添加新状态。它们仅作用于方法和参数。</p> <p>每个实例的通知都适合引入，以支持混合。在这种情况下，建议将状态添加到代理对象。</p> <p>您可以在同一AOP代理中混合使用共享和基于实例的建议。</p> <h4 id=2-2-2-2、Advice类型><a class=headerlink href=#2-2-2-2、Advice类型 title=2.2.2.2、Advice类型></a>2.2.2.2、Advice类型</h4><p>spring提供了几种通知类型，并且可以扩展以支持任意通知类型。</p> <h5 id=拦截环绕通知><a class=headerlink href=#拦截环绕通知 title=拦截环绕通知></a>拦截环绕通知</h5><p>Spring中最基本的通知类型是环绕通知。</p> <p><code>Alliance</code>对于使用方法拦截的建议，Spring符合AOP接口。实现<code>MethodInterceptor</code>和环绕通知实施的类还应该实现以下接口：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">MethodInterceptor</span> <span class=keyword>extends</span> <span class="title class_">Interceptor</span> {</span><br><span class=line>    Object <span class="title function_">invoke</span><span class=params>(MethodInvocation invocation)</span> <span class=keyword>throws</span> Throwable;</span><br><span class=line>}</span><br></pre></table></figure> <p>方法<code>invoke()</code>的参数<code>MethodInvocation</code>公开了要调用的方法，目标连接点，AOP代理以及方法的参数。该 <code>invoke()</code>方法应返回调用的结果：连接点的返回值。</p> <p>以下示例显示了一个简单的<code>MethodInterceptor</code>实现：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DebugInterceptor</span> <span class=keyword>implements</span> <span class="title class_">MethodInterceptor</span> {</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">invoke</span><span class=params>(MethodInvocation invocation)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        System.out.println(<span class=string>"Before: invocation=["</span> + invocation + <span class=string>"]"</span>);</span><br><span class=line>        <span class=type>Object</span> <span class=variable>rval</span> <span class=operator>=</span> invocation.proceed();</span><br><span class=line>        System.out.println(<span class=string>"Invocation returned"</span>);</span><br><span class=line>        <span class=keyword>return</span> rval;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>请注意对<code>MethodInvocation</code>的<code>proceed()</code>方法的调用。这沿着拦截器链向下到达连接点。大多数拦截器调用此方法并返回其返回值。但是，a<code>MethodInterceptor</code>像任何环绕通知一样，可以返回不同的值或引发异常，而不是调用proceed方法。但是，您没有充分的理由就不要这样做。</p> <h5 id=前置通知><a class=headerlink href=#前置通知 title=前置通知></a>前置通知</h5><p>一种更简单的通知类型是前置通知。这不需要<code>MethodInvocation</code> 对象，因为它仅在进入方法之前被调用。</p> <p>前置通知的主要优点在于，无需调用该<code>proceed()</code> 方法，因此，不会无意中导致无法沿拦截器链继续进行下去。</p> <p>以下清单显示了该<code>MethodBeforeAdvice</code>接口：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">MethodBeforeAdvice</span> <span class=keyword>extends</span> <span class="title class_">BeforeAdvice</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">before</span><span class=params>(Method m, Object[] args, Object target)</span> <span class=keyword>throws</span> Throwable;</span><br><span class=line>}</span><br></pre></table></figure> <p>（尽管通常的对象适用于字段拦截，并且Spring不太可能实现它，但Spring的API设计允许先于字段咨询。）</p> <p>请注意，返回类型为<code>void</code>。通知可以在联接点运行之前插入自定义行为，但不能更改返回值。如果前置通知引发异常，它将停止进一步执行拦截器链。异常会传播回拦截器链。如果未显式捕获它或抛出它，则会将其直接传递给客户端。否则，它将由AOP代理包装在未经检查的异常中。</p> <p>以下示例显示了Spring中的前置通知，该通知计算所有方法调用：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CountingBeforeAdvice</span> <span class=keyword>implements</span> <span class="title class_">MethodBeforeAdvice</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> count;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">before</span><span class=params>(Method m, Object[] args, Object target)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        ++count;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">getCount</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> count;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=异常通知><a class=headerlink href=#异常通知 title=异常通知></a>异常通知</h5><p>如果联接点引发异常，则在联接点返回之后调用引发通知。Spring提供类型化的抛出建议。请注意，这意味着该 <code>org.springframework.aop.ThrowsAdvice</code>接口不包含任何方法。它是一个标签接口，用于标识给定对象实现了一个或多个类型化的throws通知方法。这些应采用以下形式：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>afterThrowing([Method, args, target], subclassOfThrowable)</span><br></pre></table></figure> <p>仅最后一个参数是必需的。方法签名可以具有一个或四个参数，具体取决于建议方法是否对该方法和参数感兴趣。接下来的两个清单显示了类，它们是引发建议的示例。</p> <p>如果<code>RemoteException</code>抛出a（包括从子类），则调用以下建议：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoteThrowsAdvice</span> <span class=keyword>implements</span> <span class="title class_">ThrowsAdvice</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">afterThrowing</span><span class=params>(RemoteException ex)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        <span class=comment>// Do something with remote exception</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>与前面的通知不同，下一个示例声明了四个参数，以便可以访问被调用的方法，方法参数和目标对象。如果<code>ServletException</code>抛出a，则调用以下建议：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ServletThrowsAdviceWithArguments</span> <span class=keyword>implements</span> <span class="title class_">ThrowsAdvice</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">afterThrowing</span><span class=params>(Method m, Object[] args, Object target, ServletException ex)</span> {</span><br><span class=line>        <span class=comment>// Do something with all arguments</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>最后一个示例说明了如何在处理<code>RemoteException</code>和的单个类中使用这两种方法<code>ServletException</code>。可以将任意数量的异常通知方法组合到一个类中。以下清单显示了最后一个示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">CombinedThrowsAdvice</span> <span class=keyword>implements</span> <span class="title class_">ThrowsAdvice</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">afterThrowing</span><span class=params>(RemoteException ex)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        <span class=comment>// Do something with remote exception</span></span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">afterThrowing</span><span class=params>(Method m, Object[] args, Object target, ServletException ex)</span> {</span><br><span class=line>        <span class=comment>// Do something with all arguments</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <blockquote><p>如果throws-advice方法本身引发异常，则它将覆盖原始异常（也就是说，它将更改引发给用户的异常）。重写异常通常是RuntimeException，它与任何方法签名都兼容。但是，如果throws-advice方法抛出一个检查异常，则它必须与目标方法的已声明异常匹配，因此在某种程度上与特定的目标方法签名耦合。<em>不要抛出与目标方法签名不兼容的未声明检查异常！</em></blockquote> <h5 id=返回后通知><a class=headerlink href=#返回后通知 title=返回后通知></a>返回后通知</h5><p>在Spring中返回一个After通知后，必须实现该<code>org.springframework.aop.AfterReturningAdvice</code>接口，以下清单显示了该 接口：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">AfterReturningAdvice</span> <span class=keyword>extends</span> <span class="title class_">Advice</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">afterReturning</span><span class=params>(Object returnValue, Method m, Object[] args, Object target)</span> <span class=keyword>throws</span> Throwable;</span><br><span class=line>}</span><br></pre></table></figure> <p>后置通知可以访问返回值（它不能修改），调用的方法，方法的参数和目标。</p> <p>返回建议后的以下内容将计数所有未引发异常的成功方法调用：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CountingAfterReturningAdvice</span> <span class=keyword>implements</span> <span class="title class_">AfterReturningAdvice</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> count;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">afterReturning</span><span class=params>(Object returnValue, Method m, Object[] args, Object target)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        ++count;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">getCount</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> count;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>该建议不会更改执行路径。如果抛出异常，则会将其抛出拦截器链，而不是返回值。</p> <h5 id=引入通知><a class=headerlink href=#引入通知 title=引入通知></a>引入通知</h5><p>Spring将介绍建议视为一种特殊的拦截建议。</p> <p>简介需要<code>IntroductionAdvisor</code>and<code>IntroductionInterceptor</code>来实现以下接口：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">IntroductionInterceptor</span> <span class=keyword>extends</span> <span class="title class_">MethodInterceptor</span> {</span><br><span class=line>    <span class=type>boolean</span> <span class="title function_">implementsInterface</span><span class=params>(Class intf)</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p><code>invoke()</code>从AOP Alliance<code>MethodInterceptor</code>接口继承的方法必须实现介绍。也就是说，如果被调用的方法在引入的接口上，则引入拦截器负责处理方法调用-它不能调用<code>proceed()</code>。</p> <p>简介建议不能与任何切入点一起使用，因为它仅适用于类，而不适用于方法级别。您只能将引入建议与一起使用<code>IntroductionAdvisor</code>，该建议具有 以下方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">IntroductionAdvisor</span> <span class=keyword>extends</span> <span class="title class_">Advisor</span>, IntroductionInfo {</span><br><span class=line>    ClassFilter <span class="title function_">getClassFilter</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">validateInterfaces</span><span class=params>()</span> <span class=keyword>throws</span> IllegalArgumentException;</span><br><span class=line>}</span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">IntroductionInfo</span> {</span><br><span class=line>    Class&LT?>[] getInterfaces();</span><br><span class=line>}</span><br></pre></table></figure> <p>没有<code>MethodMatcher</code>任何<code>Pointcut</code>介绍建议，因此也没有。只有类过滤是合乎逻辑的。</p> <p>该<code>getInterfaces()</code>方法返回此顾问程序引入的接口。</p> <p>该<code>validateInterfaces()</code>方法在内部使用，以查看引入的接口是否可以由configure的接口实现<code>IntroductionInterceptor</code>。</p> <p>假设我们想为一个或多个对象引入以下接口：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Lockable</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">lock</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">unlock</span><span class=params>()</span>;</span><br><span class=line>    <span class=type>boolean</span> <span class="title function_">locked</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>这说明了混合。我们希望能够将建议对象强制转换为<code>Lockable</code>，无论它们的类型是什么，并调用锁定和解锁方法。如果调用该<code>lock()</code>方法，则希望所有的setter方法都抛出一个<code>LockedException</code>。因此，我们可以添加一个方面，使对象在不了解对象的情况下不可变：AOP的一个很好的例子。</p> <p>首先，我们需要一个<code>IntroductionInterceptor</code>繁重的工作。在这种情况下，我们扩展了<code>org.springframework.aop.support.DelegatingIntroductionInterceptor</code> 便利类。我们可以<code>IntroductionInterceptor</code>直接实现，但是<code>DelegatingIntroductionInterceptor</code>在大多数情况下使用 是最好的。</p> <p>该<code>DelegatingIntroductionInterceptor</code>设计将导入委托到真正实现导入接口，隐藏拦截的使用来做到这一点。您可以使用构造函数参数将委托设置为任何对象。默认委托（使用无参数构造函数时）为<code>this</code>。因此，在下一个示例中，委托是的<code>LockMixin</code>子类<code>DelegatingIntroductionInterceptor</code>。给定一个委托（默认情况下为本身），<code>DelegatingIntroductionInterceptor</code>实例将查找由委托实现的所有接口（除外 <code>IntroductionInterceptor</code>），并支持针对其中任何一个的介绍。诸如的子类<code>LockMixin</code>可以调用该<code>suppressInterface(Class intf)</code> 方法来抑制不应公开的接口。但是，无论<code>IntroductionInterceptor</code>准备支持多少个接口， <code>IntroductionAdvisor</code>用于控制实际公开哪些接口。引入的接口隐藏了目标对同一接口的任何实现。</p> <p>因此，<code>LockMixin</code>扩展<code>DelegatingIntroductionInterceptor</code>并实现<code>Lockable</code> 自己。超类会自动选择<code>Lockable</code>可以支持引入的超类，因此我们不需要指定它。我们可以通过这种方式引入任意数量的接口。</p> <p>注意<code>locked</code>实例变量的使用。这有效地将附加状态添加到目标对象中保存的状态。</p> <p>以下示例显示了示例<code>LockMixin</code>类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">LockMixin</span> <span class=keyword>extends</span> <span class="title class_">DelegatingIntroductionInterceptor</span> <span class=keyword>implements</span> <span class="title class_">Lockable</span> {</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=type>boolean</span> locked;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">lock</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>this</span>.locked = <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">unlock</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>this</span>.locked = <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">locked</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.locked;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">invoke</span><span class=params>(MethodInvocation invocation)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        <span class=keyword>if</span> (locked() && invocation.getMethod().getName().indexOf(<span class=string>"set"</span>) == <span class=number>0</span>) {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">LockedException</span>();</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>super</span>.invoke(invocation);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure> <p>通常，您无需重写该<code>invoke()</code>方法。的 <code>DelegatingIntroductionInterceptor</code>实现（它调用<code>delegate</code>如果引入的方法的方法，否则进行指向连接点），通常就足够了。在当前情况下，我们需要添加一个检查：如果处于锁定模式，则不能调用任何setter方法。</p> <p>所需的简介仅需要保存一个不同的 <code>LockMixin</code>实例并指定所引入的接口（在这种情况下，仅 <code>Lockable</code>）。一个更复杂的示例可能引用了引入拦截器（将被定义为原型）。在这种情况下，没有与a相关的配置<code>LockMixin</code>，因此我们使用来创建它<code>new</code>。以下示例显示了我们的<code>LockMixinAdvisor</code>课程：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">LockMixinAdvisor</span> <span class=keyword>extends</span> <span class="title class_">DefaultIntroductionAdvisor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">LockMixinAdvisor</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>super</span>(<span class=keyword>new</span> <span class="title class_">LockMixin</span>(), Lockable.class);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>我们可以非常简单地应用此顾问程序，因为它不需要配置。（但是，如果<code>IntroductionInterceptor</code>不带 ，就无法使用<code>IntroductionAdvisor</code>。）像通常的介绍中一样，顾问程序必须是基于实例的，因为它是有状态的。对于每个建议的对象<code>LockMixinAdvisor</code>，我们需要一个实例，因此 需要一个实例<code>LockMixin</code>。顾问程序包含建议对象状态的一部分。</p> <p>我们可以<code>Advised.addAdvisor()</code>像其他任何顾问一样，通过使用XML配置中的方法或（推荐方式）以编程方式应用此顾问。下文讨论的所有代理创建选择，包括“自动代理创建器”，都可以正确处理介绍和有状态的混合。</p> <h3 id=2-2-3、Spring-Advisor-API><a title="2.2.3、Spring Advisor API" class=headerlink href=#2-2-3、Spring-Advisor-API></a>2.2.3、Spring Advisor API</h3><p>除了介绍的特殊情况外，任何顾问都可以使用任何建议。 <code>org.springframework.aop.support.DefaultPointcutAdvisor</code>是最常用的顾问类。它可以与使用<code>MethodInterceptor</code>，<code>BeforeAdvice</code>或 <code>ThrowsAdvice</code>。</p> <p>可以在同一AOP代理中的Spring中混合使用顾问和建议类型。例如，您可以在一个代理配置中使用对建议的拦截，抛出建议以及在建议之前。Spring自动创建必要的拦截器链。</p> <h3 id=2-2-4、使用ProxyFactoryBean创建AOP代理><a class=headerlink href=#2-2-4、使用ProxyFactoryBean创建AOP代理 title=2.2.4、使用ProxyFactoryBean创建AOP代理></a>2.2.4、使用<code>ProxyFactoryBean</code>创建AOP代理</h3><p>如果将Spring IoC容器（<code>ApplicationContext</code>或<code>BeanFactory</code>）用于业务对象（应该是！），则要使用Spring的AOP <code>FactoryBean</code>实现之一。（请记住，工厂bean引入了一个间接层，允许它创建不同类型的对象。）</p> <blockquote><p>Spring AOP支持还在后台使用了工厂bean。</blockquote> <p>在Spring中创建AOP代理的基本方法是使用 <code>org.springframework.aop.framework.ProxyFactoryBean</code>。这样可以完全控制切入点，任何适用的建议及其顺序。但是，如果不需要这样的控制，则有一些更简单的选项是可取的。</p> <h4 id=2-2-4-1、Base><a class=headerlink href=#2-2-4-1、Base title=2.2.4.1、Base></a>2.2.4.1、Base</h4><p><code>roxyFactoryBean</code>，像其它的<code>FactoryBean</code>实现中，引入了一个间接的水平。如果您定义一个<code>ProxyFactoryBean</code>named <code>foo</code>，则引用的对象将<code>foo</code>看不到<code>ProxyFactoryBean</code>实例本身，而是一个由实现中的<code>getObject()</code>方法创建的对象<code>ProxyFactoryBean</code>。此方法创建一个包装目标对象的AOP代理。</p> <p>使用一个<code>ProxyFactoryBean</code>或另一个IoC感知类创建AOP代理的最重要好处之一是，建议和切入点也可以由IoC管理。这是一项强大的功能，可以实现某些其他AOP框架难以实现的方法。例如，受益于依赖注入提供的所有可插入性，建议本身可以引用应用程序对象（目标之外，目标应该在任何AOP框架中可用）。</p> <h4 id=2-2-4-2、Java-Bean属性><a title="2.2.4.2、Java Bean属性" class=headerlink href=#2-2-4-2、Java-Bean属性></a>2.2.4.2、Java Bean属性</h4><p><code>FactoryBean</code>与Spring提供的大多数实现一样， <code>ProxyFactoryBean</code>该类本身就是JavaBean。其属性用于：</p> <ul><li>指定要代理的目标。<li>指定是否使用CGLIB（稍后介绍，另请参见<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-pfb-proxy-types rel=noopener target=_blank>基于JDK和CGLIB的代理</a>）。</ul> <p>继承了一些关键属性<code>org.springframework.aop.framework.ProxyConfig</code> （Spring中所有AOP代理工厂的超类）。这些关键属性包括：</p> <ul><li><code>proxyTargetClass</code>：<code>true</code>如果要代理目标类，而不是目标类的接口。如果将此属性值设置为<code>true</code>，则将创建CGLIB代理（另请参见<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-pfb-proxy-types rel=noopener target=_blank>基于JDK和CGLIB的代理</a>）。<li><code>optimize</code>：控制是否将积极的优化应用于通过CGLIB创建的代理。除非您完全了解相关的AOP代理如何处理优化，否则不要随意使用此设置。当前仅用于CGLIB代理。它对JDK动态代理无效。<li><code>frozen</code>：如果代理配置为<code>frozen</code>，则不再允许更改配置。这对于进行轻微的优化是有用的，对于在您不希望调用者<code>Advised</code> 在创建代理后能够通过该接口操纵代理的情况下，这是有用的。此属性的默认值为 <code>false</code>，因此允许进行更改（例如添加其他建议）。<li><code>exposeProxy</code>：确定是否应将当前代理公开在中， <code>ThreadLocal</code>以便目标可以访问它。如果目标需要获取代理并将<code>exposeProxy</code>属性设置为<code>true</code>，则目标可以使用该 <code>AopContext.currentProxy()</code>方法。</ul> <p>其他特定的属性<code>ProxyFactoryBean</code>包括：</p> <ul><li><p><code>proxyInterfaces</code>：<code>String</code>接口名称数组。如果未提供，则使用目标类的CGLIB代理（另请参见<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-pfb-proxy-types rel=noopener target=_blank>基于JDK和CGLIB的代理</a>）。</p><li><p><code>interceptorNames</code>：要套用<code>String</code>的<code>Advisor</code>，拦截器或其他建议名称的数组。顺序很重要，先到先得。也就是说，列表中的第一个拦截器是第一个能够拦截调用的拦截器。</p> <p>名称是当前工厂中的Bean名称，包括祖先工厂中的Bean名称。您不能在此提及bean引用，因为这样做会导致 <code>ProxyFactoryBean</code>忽略建议的单例设置。</p> <p>您可以在拦截器名称后加上星号（<code>*</code>）。这样做将导致应用所有顾问Bean，其名称以要应用星号的部分开头。您可以在<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-global-advisors rel=noopener target=_blank>使用“全局”顾问中</a>找到使用此功能的示例。</p><li><p>单例：无论<code>getObject()</code>调用该方法的频率如何，工厂是否应返回单个对象。几种<code>FactoryBean</code>实现提供了这种方法。默认值为<code>true</code>。如果要使用有状态的建议（例如，对于有状态的混合），请使用原型建议以及单例值 <code>false</code>。</p></ul> <h4 id=2-2-4-3、JDK和CGLIB代理><a class=headerlink href=#2-2-4-3、JDK和CGLIB代理 title=2.2.4.3、JDK和CGLIB代理></a>2.2.4.3、JDK和CGLIB代理</h4><p>本节是有关如何<code>ProxyFactoryBean</code> 选择为特定目标对象（将被代理）创建基于JDK的代理或基于CGLIB的代理的权威性文档。</p> <blockquote><p>在<code>ProxyFactoryBean</code>Spring的1.2.x版和2.0版之间，关于创建基于JDK或CGLIB的代理的行为发生了变化。在<code>ProxyFactoryBean</code>现在表现关于与上述的自动检测接口相似的语义 <code>TransactionProxyFactoryBean</code>类。</blockquote> <p>如果要代理的目标对象的类（以下简称为目标类）没有实现任何接口，则将创建基于CGLIB的代理。这是最简单的情况，因为JDK代理是基于接口的，并且没有接口意味着甚至无法进行JDK代理。您可以插入目标bean并通过设置<code>interceptorNames</code>属性来指定拦截器列表。请注意，即使的<code>proxyTargetClass</code>属性 <code>ProxyFactoryBean</code>已设置为，也会创建基于CGLIB的代理<code>false</code>。（这样做没有任何意义，最好将其从bean定义中删除，因为它充其量是多余的，并且在最糟的情况下会造成混淆。）</p> <p>如果目标类实现一个（或多个）接口，则创建的代理类型取决于的配置<code>ProxyFactoryBean</code>。</p> <p>如果的<code>proxyTargetClass</code>属性<code>ProxyFactoryBean</code>已设置为<code>true</code>，则会创建一个基于CGLIB的代理。这是有道理的，并且符合最小惊讶原则。即使的<code>proxyInterfaces</code>属性 <code>ProxyFactoryBean</code>已设置为一个或多个完全限定的接口名称，该<code>proxyTargetClass</code>属性设置为的事实也会<code>true</code>导致基于CGLIB的代理生效。</p> <p>如果的<code>proxyInterfaces</code>属性<code>ProxyFactoryBean</code>已设置为一个或多个标准接口名称，则将创建一个基于JDK的代理。创建的代理实现<code>proxyInterfaces</code> 属性中指定的所有接口。如果目标类恰好实现了比该<code>proxyInterfaces</code>属性中指定的接口更多的接口，那很好，但是返回的代理不会实现这些其他接口。</p> <p>如果尚未设置的<code>proxyInterfaces</code>属性<code>ProxyFactoryBean</code>，但是目标类确实实现了一个（或多个）接口，则 <code>ProxyFactoryBean</code>自动检测到目标类实际上确实实现了至少一个接口，并创建了基于JDK的代理。实际代理的接口是目标类实现的所有接口。实际上，这与为目标类提供该<code>proxyInterfaces</code>属性实现的每个接口的列表相同。但是，它的工作量大大减少，而且不容易出现印刷错误。</p> <h4 id=2-2-4-4、代理接口><a class=headerlink href=#2-2-4-4、代理接口 title=2.2.4.4、代理接口></a>2.2.4.4、代理接口</h4><p>考虑一个简单的实际例子<code>ProxyFactoryBean</code>。此示例涉及：</p> <ul><li>代理的目标bean。这是<code>personTarget</code>示例中的bean定义。<li>一个<code>Advisor</code>和<code>Interceptor</code>使用提供建议。<li>AOP代理bean定义，用于指定目标对象（<code>personTarget</code>bean），代理接口以及要应用的建议。</ul> <p>以下清单显示了示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"personTarget"</span> <span class=attr>class</span>=<span class=string>"com.mycompany.PersonImpl"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"Tony"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"age"</span> <span class=attr>value</span>=<span class=string>"51"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"myAdvisor"</span> <span class=attr>class</span>=<span class=string>"com.mycompany.MyAdvisor"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"someProperty"</span> <span class=attr>value</span>=<span class=string>"Custom string property value"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"debugInterceptor"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.interceptor.DebugInterceptor"</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"person"</span></span></span><br><span class=line><span class=tag>    <span class=attr>class</span>=<span class=string>"org.springframework.aop.framework.ProxyFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"proxyInterfaces"</span> <span class=attr>value</span>=<span class=string>"com.mycompany.Person"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"target"</span> <span class=attr>ref</span>=<span class=string>"personTarget"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"interceptorNames"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>list</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>myAdvisor<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>debugInterceptor<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>list</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>请注意，该<code>interceptorNames</code>属性采用的列表<code>String</code>，其中包含当前工厂中的拦截器或顾问程序的Bean名称。您可以在返回之前，之后使用顾问程序，拦截器并引发建议对象。顾问的顺序很重要。</p> <blockquote><p>您可能想知道为什么列表不包含bean引用。原因是，如果将的singleton属性<code>ProxyFactoryBean</code>设置为<code>false</code>，则它必须能够返回独立的代理实例。如果任何顾问本身就是原型，则需要返回一个独立的实例，因此必须能够从工厂获得原型的实例。保持引用是不够的。</blockquote> <p><code>person</code>可以使用前面显示的bean定义代替<code>Person</code>实现，如下所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>Person</span> <span class=variable>person</span> <span class=operator>=</span> (Person) factory.getBean(<span class=string>"person"</span>);</span><br></pre></table></figure> <p>与普通Java对象一样，在同一IoC上下文中的其他bean可以表达对此的强类型依赖性。以下示例显示了如何执行此操作：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"personUser"</span> <span class=attr>class</span>=<span class=string>"com.mycompany.PersonUser"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"person"</span>></span><span class=tag><<span class=name>ref</span> <span class=attr>bean</span>=<span class=string>"person"</span>/></span><span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p><code>PersonUser</code>本示例中的类公开了type属性<code>Person</code>。就其而言，可以透明地使用AOP代理代替“真实”人的实现。但是，其类将是动态代理类。可以将其强制转换为<code>Advised</code>接口（稍后讨论）。</p> <p>您可以使用匿名内部bean隐藏目标和代理之间的区别。只有<code>ProxyFactoryBean</code>定义不同。该建议仅出于完整性考虑。以下示例显示如何使用匿名内部Bean：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"myAdvisor"</span> <span class=attr>class</span>=<span class=string>"com.mycompany.MyAdvisor"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"someProperty"</span> <span class=attr>value</span>=<span class=string>"Custom string property value"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"debugInterceptor"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.interceptor.DebugInterceptor"</span>/></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"person"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.framework.ProxyFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"proxyInterfaces"</span> <span class=attr>value</span>=<span class=string>"com.mycompany.Person"</span>/></span></span><br><span class=line>    <span class=comment>&LT!-- Use inner bean, not local reference to target --></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"target"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"com.mycompany.PersonImpl"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"Tony"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"age"</span> <span class=attr>value</span>=<span class=string>"51"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"interceptorNames"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>list</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>myAdvisor<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>debugInterceptor<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>list</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>使用匿名内部bean的优点是只有一个类型的对象<code>Person</code>。如果我们要防止应用程序上下文的用户获取对未建议对象的引用，或者需要避免使用Spring IoC自动装配的任何歧义，这将非常有用。可以说，还有一个优点是<code>ProxyFactoryBean</code>定义是独立的。但是，有时能够从工厂获得未经建议的目标实际上可能是一个优势（例如，在某些测试方案中）。</p> <h4 id=2-2-4-5、代理Class><a class=headerlink href=#2-2-4-5、代理Class title=2.2.4.5、代理Class></a>2.2.4.5、代理Class</h4><p>如果您需要代理一类，而不是一个或多个接口，该怎么办？</p> <p>想象一下，在我们之前的示例中，没有<code>Person</code>接口。我们需要建议一个<code>Person</code>没有实现任何业务接口的类。在这种情况下，可以将Spring配置为使用CGLIB代理而不是动态代理。为此，请将前面显示的<code>proxyTargetClass</code>属性设置 <code>ProxyFactoryBean</code>为<code>true</code>。尽管最好对接口而不是对类进行编程，但是在处理遗留代码时，建议未实现接口的类的功能可能会很有用。（通常，Spring并不是强制性的。虽然可以轻松地应用良好实践，但可以避免强制采用特定方法。）</p> <p>如果需要，即使您有接口，也可以在任何情况下强制使用CGLIB。</p> <p>CGLIB代理通过在运行时生成目标类的子类来工作。Spring配置此生成的子类以将方法调用委托给原始目标。子类用于实现Decorator模式，并编织在建议中。</p> <p>CGLIB代理通常应对用户透明。但是，有一些问题要考虑：</p> <ul><li><code>Final</code> 不能建议使用方法，因为它们不能被覆盖。<li>无需将CGLIB添加到您的类路径中。从Spring 3.2开始，CGLIB被重新打包并包含在spring-core JAR中。换句话说，基于CGLIB的AOP就像JDK动态代理一样“开箱即用”。</ul> <p>CGLIB代理和动态代理之间几乎没有性能差异。在这种情况下，性能不应作为决定性的考虑因素。</p> <h4 id=2-2-4-6、使用全局通知><a class=headerlink href=#2-2-4-6、使用全局通知 title=2.2.4.6、使用全局通知></a>2.2.4.6、使用全局通知</h4><p>通过在拦截器名称后附加星号，所有具有与该星号之前的部分匹配的Bean名称的顾问程序都将添加到顾问程序链中。如果您需要添加标准的“全局”顾问程序集，这可能会派上用场。以下示例定义了两个全局顾问程序：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"proxy"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.framework.ProxyFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"target"</span> <span class=attr>ref</span>=<span class=string>"service"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"interceptorNames"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>list</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>global*<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>list</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"global_debug"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.interceptor.DebugInterceptor"</span>/></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"global_performance"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.interceptor.PerformanceMonitorInterceptor"</span>/></span></span><br></pre></table></figure> <h3 id=2-2-5、简洁代理定义><a class=headerlink href=#2-2-5、简洁代理定义 title=2.2.5、简洁代理定义></a>2.2.5、简洁代理定义</h3><p>特别是在定义事务代理时，您可能会得到许多类似的代理定义。使用父子bean定义和子bean定义以及内部bean定义可以使代理定义更加简洁明了。</p> <p>首先，我们为代理创建父模板，bean定义，如下所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"txProxyTemplate"</span> <span class=attr>abstract</span>=<span class=string>"true"</span> <span class=attr>class</span>=<span class=string>"org.springframework.transaction.interceptor.TransactionProxyFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"transactionManager"</span> <span class=attr>ref</span>=<span class=string>"transactionManager"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"transactionAttributes"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>props</span>></span></span><br><span class=line>            <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"*"</span>></span>PROPAGATION_REQUIRED<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>props</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>它本身从未实例化，因此实际上可能是不完整的。然后，每个需要创建的代理都是一个子bean定义，它将代理的目标包装为内部bean定义，因为无论如何该目标都不会单独使用。以下示例显示了这样的子bean：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"myService"</span> <span class=attr>parent</span>=<span class=string>"txProxyTemplate"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"target"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.samples.MyServiceImpl"</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>您可以从父模板覆盖属性。在以下示例中，我们将覆盖事务传播设置：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"mySpecialService"</span> <span class=attr>parent</span>=<span class=string>"txProxyTemplate"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"target"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.samples.MySpecialServiceImpl"</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"transactionAttributes"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>props</span>></span></span><br><span class=line>            <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"get*"</span>></span>PROPAGATION_REQUIRED,readOnly<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>            <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"find*"</span>></span>PROPAGATION_REQUIRED,readOnly<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>            <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"load*"</span>></span>PROPAGATION_REQUIRED,readOnly<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>            <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"store*"</span>></span>PROPAGATION_REQUIRED<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>props</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>请注意，在父bean的示例中，我们通过将<code>abstract</code>属性设置为来将父bean定义显式标记为抽象<code>true</code>， <a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-child-bean-definitions rel=noopener target=_blank>如前所述</a>，因此实际上可能不会实例化它。默认情况下，应用程序上下文（但不是简单的bean工厂）会预先实例化所有单例。因此，重要的是（至少对于单例bean而言），如果您有一个（父）bean定义仅打算用作模板，并且此定义指定了一个类，则必须确保将<code>abstract</code> 属性设置为<code>true</code>。否则，应用程序上下文实际上会尝试对其进行实例化。</p> <h3 id=2-2-6、使用ProxyFactory以编程方式实现AOP代理><a class=headerlink href=#2-2-6、使用ProxyFactory以编程方式实现AOP代理 title=2.2.6、使用ProxyFactory以编程方式实现AOP代理></a>2.2.6、使用ProxyFactory以编程方式实现AOP代理</h3><p>使用Spring以编程方式创建AOP代理很容易。这使您可以在不依赖Spring IoC的情况下使用Spring AOP。</p> <p>由目标对象实现的接口将被自动代理。以下清单显示了使用一个拦截器和一个顾问程序为目标对象创建代理的过程：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=type>ProxyFactory</span> <span class=variable>factory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ProxyFactory</span>(myBusinessInterfaceImpl);</span><br><span class=line>factory.addAdvice(myMethodInterceptor);</span><br><span class=line>factory.addAdvisor(myAdvisor);</span><br><span class=line><span class=type>MyBusinessInterface</span> <span class=variable>tb</span> <span class=operator>=</span> (MyBusinessInterface) factory.getProxy();</span><br></pre></table></figure> <p>第一步是构造类型的对象 <code>org.springframework.aop.framework.ProxyFactory</code>。您可以使用目标对象创建此对象，如前面的示例中所述，或指定要在替代构造函数中代理的接口。</p> <p>您可以添加建议（使用拦截器作为一种特殊的建议），顾问，或同时添加两者，并在的生命周期内对其进行操作<code>ProxyFactory</code>。如果添加 <code>IntroductionInterceptionAroundAdvisor</code>，则可以使代理实现其他接口。</p> <p><code>ProxyFactory</code>（继承自<code>AdvisedSupport</code>）上还有便捷的方法，可让您添加其他建议类型，例如before和throw通知。 <code>AdvisedSupport</code>既是超<code>ProxyFactory</code>和<code>ProxyFactoryBean</code>。</p> <h3 id=2-2-7、操作通知对象><a class=headerlink href=#2-2-7、操作通知对象 title=2.2.7、操作通知对象></a>2.2.7、操作通知对象</h3><p>无论创建AOP代理，都可以通过使用<code>org.springframework.aop.framework.Advised</code>接口来操作它们 。任何AOP代理都可以强制转换为该接口，无论它实现了哪个其他接口。该界面包括以下方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line>Advisor[] getAdvisors();</span><br><span class=line></span><br><span class=line><span class=keyword>void</span> <span class="title function_">addAdvice</span><span class=params>(Advice advice)</span> <span class=keyword>throws</span> AopConfigException;</span><br><span class=line></span><br><span class=line><span class=keyword>void</span> <span class="title function_">addAdvice</span><span class=params>(<span class=type>int</span> pos, Advice advice)</span> <span class=keyword>throws</span> AopConfigException;</span><br><span class=line></span><br><span class=line><span class=keyword>void</span> <span class="title function_">addAdvisor</span><span class=params>(Advisor advisor)</span> <span class=keyword>throws</span> AopConfigException;</span><br><span class=line></span><br><span class=line><span class=keyword>void</span> <span class="title function_">addAdvisor</span><span class=params>(<span class=type>int</span> pos, Advisor advisor)</span> <span class=keyword>throws</span> AopConfigException;</span><br><span class=line></span><br><span class=line><span class=type>int</span> <span class="title function_">indexOf</span><span class=params>(Advisor advisor)</span>;</span><br><span class=line></span><br><span class=line><span class=type>boolean</span> <span class="title function_">removeAdvisor</span><span class=params>(Advisor advisor)</span> <span class=keyword>throws</span> AopConfigException;</span><br><span class=line></span><br><span class=line><span class=keyword>void</span> <span class="title function_">removeAdvisor</span><span class=params>(<span class=type>int</span> index)</span> <span class=keyword>throws</span> AopConfigException;</span><br><span class=line></span><br><span class=line><span class=type>boolean</span> <span class="title function_">replaceAdvisor</span><span class=params>(Advisor a, Advisor b)</span> <span class=keyword>throws</span> AopConfigException;</span><br><span class=line></span><br><span class=line><span class=type>boolean</span> <span class="title function_">isFrozen</span><span class=params>()</span>;</span><br></pre></table></figure> <p>该<code>getAdvisors()</code>方法<code>Advisor</code>针对已添加到工厂的每个顾问程序，拦截器或其他建议类型返回一个。如果添加<code>Advisor</code>，则在此索引处返回的顾问程序就是您添加的对象。如果您添加了拦截器或其他建议类型，Spring会将其包装在带有始终返回的切入点的顾问中<code>true</code>。因此，如果您添加了<code>MethodInterceptor</code>，则为此索引返回的顾问<code>DefaultPointcutAdvisor</code>程序将返回您的， <code>MethodInterceptor</code>并且指向所有类和方法都匹配的切入点。</p> <p>该<code>addAdvisor()</code>方法可用于添加任何<code>Advisor</code>。通常，拥有切入点和建议的顾问是通用的<code>DefaultPointcutAdvisor</code>，您可以将其与任何建议或切入点一起使用（但不能用于介绍）。</p> <p>默认情况下，即使已创建代理，也可以添加或删除顾问程序或拦截器。唯一的限制是不可能添加或删除介绍顾问，因为工厂中的现有代理不会显示界面更改。（您可以从工厂获取新的代理来避免此问题。）</p> <p>以下示例显示了将AOP代理投射到<code>Advised</code>接口并检查和处理其建议：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=type>Advised</span> <span class=variable>advised</span> <span class=operator>=</span> (Advised) myObject;</span><br><span class=line>Advisor[] advisors = advised.getAdvisors();</span><br><span class=line><span class=type>int</span> <span class=variable>oldAdvisorCount</span> <span class=operator>=</span> advisors.length;</span><br><span class=line>System.out.println(oldAdvisorCount + <span class=string>" advisors"</span>);</span><br><span class=line></span><br><span class=line><span class=comment>// Add an advice like an interceptor without a pointcut</span></span><br><span class=line><span class=comment>// Will match all proxied methods</span></span><br><span class=line><span class=comment>// Can use for interceptors, before, after returning or throws advice</span></span><br><span class=line>advised.addAdvice(<span class=keyword>new</span> <span class="title class_">DebugInterceptor</span>());</span><br><span class=line></span><br><span class=line><span class=comment>// Add selective advice using a pointcut</span></span><br><span class=line>advised.addAdvisor(<span class=keyword>new</span> <span class="title class_">DefaultPointcutAdvisor</span>(mySpecialPointcut, myAdvice));</span><br><span class=line></span><br><span class=line>assertEquals(<span class=string>"Added two advisors"</span>, oldAdvisorCount + <span class=number>2</span>, advised.getAdvisors().length);</span><br></pre></table></figure> <p>根据创建代理的方式，通常可以设置一个<code>frozen</code>标志。在这种情况下，该<code>Advised</code> <code>isFrozen()</code>方法会返回<code>true</code>，并且通过添加或删除来修改建议的任何尝试都会导致<code>AopConfigException</code>。冻结建议对象状态的功能在某些情况下很有用（例如，防止调用代码删除安全拦截器）。</p> <h3 id=2-2-8、使用自动代理功能><a class=headerlink href=#2-2-8、使用自动代理功能 title=2.2.8、使用自动代理功能></a>2.2.8、使用自动代理功能</h3><p>Spring还允许我们使用“自动代理” Bean定义，该定义可以自动代理选定的Bean定义。它建立在Spring的“ bean后处理器”基础结构上，该基础结构允许在容器加载时修改任何bean定义。</p> <p>在此模型中，您在XML bean定义文件中设置了一些特殊的bean定义，以配置自动代理基础结构。这使您可以声明有资格进行自动代理的目标。您不需要使用<code>ProxyFactoryBean</code>。</p> <p>有两种方法可以做到这一点：</p> <ul><li>通过使用在当前上下文中引用特定bean的自动代理创建器。<li>自动代理创建的一种特殊情况，值得单独考虑：由源级元数据属性驱动的自动代理创建。</ul> <h4 id=2-2-8-1、自动代理Bean定义><a class=headerlink href=#2-2-8-1、自动代理Bean定义 title=2.2.8.1、自动代理Bean定义></a>2.2.8.1、自动代理Bean定义</h4><h5 id=BeanNameAutoProxyCreator><a class=headerlink href=#BeanNameAutoProxyCreator title=BeanNameAutoProxyCreator></a>BeanNameAutoProxyCreator</h5><p>该<code>BeanNameAutoProxyCreator</code>班是一个<code>BeanPostProcessor</code>能够自动创建一个用于匹配字符串或者通配符名称豆类AOP代理。以下示例显示了如何创建<code>BeanNameAutoProxyCreator</code>bean：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"beanNames"</span> <span class=attr>value</span>=<span class=string>"jdk*,onlyJdk"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"interceptorNames"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>list</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>myInterceptor<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>list</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>与一样<code>ProxyFactoryBean</code>，有一个<code>interceptorNames</code>属性而不是拦截器列表，以允许原型顾问程序具有正确的行为。名为“拦截器”的可以是顾问或任何建议类型。</p> <p>通常，与自动代理一样，使用的要点<code>BeanNameAutoProxyCreator</code>是将相同的配置一致地应用于多个对象，并且配置量最少。将声明式事务应用于多个对象是一种流行的选择。</p> <p>名称匹配的Bean定义，例如<code>jdkMyBean</code>和<code>onlyJdk</code>在前面的示例中，是带有目标类的普通旧Bean定义。会自动创建AOP代理<code>BeanNameAutoProxyCreator</code>。相同的建议适用于所有匹配的bean。注意，如果使用了顾问程序（而不是前面的示例中的拦截器），则切入点可能会不同地应用于不同的bean。</p> <h5 id=DefaultAdvisorAutoProxyCreator><a class=headerlink href=#DefaultAdvisorAutoProxyCreator title=DefaultAdvisorAutoProxyCreator></a>DefaultAdvisorAutoProxyCreator</h5><p>一个更通用，功能极其强大的自动代理创建者是 <code>DefaultAdvisorAutoProxyCreator</code>。这会自动在当前上下文中应用合格的顾问程序，而无需在自动代理顾问程序的Bean定义中包括特定的Bean名称。它具有与一致的配置和避免重复的优点<code>BeanNameAutoProxyCreator</code>。</p> <p>使用此机制涉及：</p> <ul><li>指定<code>DefaultAdvisorAutoProxyCreator</code>bean定义。<li>在相同或相关的上下文中指定任意数量的顾问。请注意，这些必须是顾问程序，而不是拦截器或其他建议。这是必要的，因为必须有一个评估的切入点，以检查每个建议是否符合候选bean定义。</ul> <p>该<code>DefaultAdvisorAutoProxyCreator</code>自动评估包括在每个advisor中的切入点，看看有什么（如果有的话）的建议，应该适用于每个业务对象（比如<code>businessObject1</code>和<code>businessObject2</code>在本例中）。</p> <p>这意味着可以将任意数量的顾问程序自动应用于每个业务对象。如果在任何顾问程序中没有切入点与业务对象中的任何方法匹配，则该对象不会被代理。当为新的业务对象添加Bean定义时，如有必要，它们会自动被代理。</p> <p>通常，自动代理的优点是使调用者或依赖项无法获得未建议的对象。调用<code>getBean("businessObject1")</code>此方法 <code>ApplicationContext</code>将返回AOP代理，而不是目标业务对象。（前面显示的“ inner bean”成语也提供了这一好处。）</p> <p>以下示例创建一个<code>DefaultAdvisorAutoProxyCreator</code>bean和本节中讨论的其他元素：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"</span>/></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"transactionInterceptor"</span> <span class=attr>ref</span>=<span class=string>"transactionInterceptor"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"customAdvisor"</span> <span class=attr>class</span>=<span class=string>"com.mycompany.MyAdvisor"</span>/></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"businessObject1"</span> <span class=attr>class</span>=<span class=string>"com.mycompany.BusinessObject1"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- Properties omitted --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"businessObject2"</span> <span class=attr>class</span>=<span class=string>"com.mycompany.BusinessObject2"</span>/></span></span><br></pre></table></figure> <p><code>DefaultAdvisorAutoProxyCreator</code>如果您希望将相同的建议一致地应用于许多业务对象，则很有用。基础结构定义到位后，您可以添加新的业务对象，而无需包括特定的代理配置。您也可以轻松地添加其他方面（例如，跟踪或性能监视方面），而对配置的更改最少。</p> <p>该<code>DefaultAdvisorAutoProxyCreator</code>支持过滤（通过使用一种命名约定，使得只有特定的顾问进行评估，其允许使用多个不同配置，在同一个工厂AdvisorAutoProxyCreators）和订货。<code>org.springframework.core.Ordered</code>如果有问题，顾问可以实现该接口以确保正确的排序。在<code>TransactionAttributeSourceAdvisor</code>前述实施例中使用具有可配置的顺序值。默认设置为无序。</p> <h3 id=2-2-9、使用TargetSource实施><a class=headerlink href=#2-2-9、使用TargetSource实施 title=2.2.9、使用TargetSource实施></a>2.2.9、使用<code>TargetSource</code>实施</h3><p>Spring提供了<code>TargetSource</code>在<code>org.springframework.aop.TargetSource</code>接口中表达 的概念。该接口负责返回实现连接点的“目标对象”。在<code>TargetSource</code> 每一个AOP代理处理一个方法调用时实现请求一个目标实例。</p> <p>使用Spring AOP的开发人员通常不需要直接与<code>TargetSource</code>实现一起工作，但这提供了一种强大的手段来支持池化，热插拔和其他复杂的目标。例如，<code>TargetSource</code>通过使用池来管理实例，池可以为每个调用返回不同的目标实例。</p> <p>如果未指定<code>TargetSource</code>，则使用默认实现包装本地对象。每次调用都会返回相同的目标（与您期望的一样）。</p> <p>本节的其余部分描述了Spring随附的标准目标源以及如何使用它们。</p> <blockquote><p>使用自定义目标源时，目标通常需要是原型而不是单例bean定义。这样，Spring可以在需要时创建一个新的目标实例。</blockquote> <h4 id=2-2-9-1、热插拔目标源><a class=headerlink href=#2-2-9-1、热插拔目标源 title=2.2.9.1、热插拔目标源></a>2.2.9.1、热插拔目标源</h4><p>的<code>org.springframework.aop.target.HotSwappableTargetSource</code>存在让一个AOP代理的目标进行切换，同时让来电者保持自己对它的引用。</p> <p>更改目标源的目标会立即生效。该 <code>HotSwappableTargetSource</code>是线程安全的。</p> <p>您可以使用<code>swap()</code>HotSwappableTargetSource上的方法更改目标，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>HotSwappableTargetSource</span> <span class=variable>swapper</span> <span class=operator>=</span> (HotSwappableTargetSource) beanFactory.getBean(<span class=string>"swapper"</span>);</span><br><span class=line><span class=type>Object</span> <span class=variable>oldTarget</span> <span class=operator>=</span> swapper.swap(newTarget);</span><br></pre></table></figure> <p>以下示例显示了必需的XML定义：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"initialTarget"</span> <span class=attr>class</span>=<span class=string>"mycompany.OldTarget"</span>/></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"swapper"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.target.HotSwappableTargetSource"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>ref</span>=<span class=string>"initialTarget"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"swappable"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.framework.ProxyFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"targetSource"</span> <span class=attr>ref</span>=<span class=string>"swapper"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>前面的<code>swap()</code>调用更改了可交换bean的目标。拥有对该bean的引用的客户端不知道更改，但立即开始达到新目标。</p> <p>尽管此示例未添加任何建议（不必添加建议以使用<code>TargetSource</code>），但任何建议<code>TargetSource</code>都可以与任意建议结合使用。</p> <h4 id=2-2-9-2、汇集目标源><a class=headerlink href=#2-2-9-2、汇集目标源 title=2.2.9.2、汇集目标源></a>2.2.9.2、汇集目标源</h4><p>使用池目标源提供了与无状态会话EJB相似的编程模型，在无状态会话EJB中，维护了相同实例的池，方法调用将释放池中的对象。</p> <p>Spring池和SLSB池之间的关键区别在于，Spring池可以应用于任何POJO。通常，与Spring一样，可以以非侵入性方式应用此服务。</p> <p>Spring提供对Commons Pool 2.2的支持，该池提供了相当有效的池实现。您需要在<code>commons-pool</code>应用程序的类路径上使用Jar才能使用此功能。您也可以子类化 <code>org.springframework.aop.target.AbstractPoolingTargetSource</code>以支持任何其他池化API。</p> <p>以下清单显示了一个示例配置：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"businessObjectTarget"</span> <span class=attr>class</span>=<span class=string>"com.mycompany.MyBusinessObject"</span></span></span><br><span class=line><span class=tag>        <span class=attr>scope</span>=<span class=string>"prototype"</span>></span></span><br><span class=line>    ... properties omitted</span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"poolTargetSource"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.target.CommonsPool2TargetSource"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"targetBeanName"</span> <span class=attr>value</span>=<span class=string>"businessObjectTarget"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"maxSize"</span> <span class=attr>value</span>=<span class=string>"25"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"businessObject"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.framework.ProxyFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"targetSource"</span> <span class=attr>ref</span>=<span class=string>"poolTargetSource"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"interceptorNames"</span> <span class=attr>value</span>=<span class=string>"myInterceptor"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>请注意，目标对象（<code>businessObjectTarget</code>在前面的示例中）必须是原型。这使<code>PoolingTargetSource</code>实现可以创建目标的新实例，以根据需要扩展池。有关其属性的信息，请参见您要使用的<a href=https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframeworkaop/target/AbstractPoolingTargetSource.html rel=noopener target=_blank>javadoc <code>AbstractPoolingTargetSource</code></a>和具体的子类。<code>maxSize</code>是最基本的，并且始终保证存在。</p> <p>在这种情况下，<code>myInterceptor</code>是需要在同一IoC上下文中定义的拦截器的名称。但是，您无需指定拦截器即可使用池。如果只希望池化而没有其他建议，则根本不要设置该 <code>interceptorNames</code>属性。</p> <p>您可以将Spring配置为能够将任何池对象强制转换为 <code>org.springframework.aop.target.PoolingConfig</code>接口，该接口通过介绍来公开有关池的配置和当前大小的信息。您需要定义类似于以下内容的顾问程序：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"poolConfigAdvisor"</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.config.MethodInvokingFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"targetObject"</span> <span class=attr>ref</span>=<span class=string>"poolTargetSource"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"targetMethod"</span> <span class=attr>value</span>=<span class=string>"getPoolingConfigMixin"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>该顾问程序是通过在<code>AbstractPoolingTargetSource</code>类上调用便捷方法而获得的 ，因此可以使用<code>MethodInvokingFactoryBean</code>。该顾问的名称（<code>poolConfigAdvisor</code>，此处）必须在<code>ProxyFactoryBean</code>公开池对象的拦截器名称列表中。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>PoolingConfig</span> <span class=variable>conf</span> <span class=operator>=</span> (PoolingConfig) beanFactory.getBean(<span class=string>"businessObject"</span>);</span><br><span class=line>System.out.println(<span class=string>"Max pool size is "</span> + conf.getMaxSize());</span><br></pre></table></figure> <p>通过使用自动代理，可以实现更简单的池化。您可以设置<code>TargetSource</code>任何自动代理创建者使用的实现。</p> <h4 id=2-2-9-3、原型目标源><a class=headerlink href=#2-2-9-3、原型目标源 title=2.2.9.3、原型目标源></a>2.2.9.3、原型目标源</h4><p>设置“原型”目标源类似于设置池<code>TargetSource</code>。在这种情况下，每次方法调用都会创建目标的新实例。尽管在现代JVM中创建新对象的成本并不高，但是连接新对象（满足其IoC依赖性）的成本可能会更高。因此，没有充分的理由就不应使用此方法。</p> <p>为此，您可以<code>poolTargetSource</code>按如下所示修改前面显示的定义（为清楚起见，我们也更改了名称）：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"prototypeTargetSource"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.target.PrototypeTargetSource"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"targetBeanName"</span> <span class=attr>ref</span>=<span class=string>"businessObjectTarget"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>唯一的属性是目标Bean的名称。在<code>TargetSource</code>实现中使用继承 以确保命名一致。与池化目标源一样，目标Bean必须是原型Bean定义。</p> <h4 id=2-2-9-4、ThreadLocal目标来源><a class=headerlink href=#2-2-9-4、ThreadLocal目标来源 title=2.2.9.4、ThreadLocal目标来源></a>2.2.9.4、ThreadLocal目标来源</h4><p><code>ThreadLocal</code>如果您需要为每个传入请求（每个线程）创建一个对象，则目标源很有用。的概念<code>ThreadLocal</code>提供了一个JDK范围的功能，可以透明地将资源与线程一起存储。设置a <code>ThreadLocalTargetSource</code>几乎与其他类型的目标源所说明的相同，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"threadlocalTargetSource"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.target.ThreadLocalTargetSource"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"targetBeanName"</span> <span class=attr>value</span>=<span class=string>"businessObjectTarget"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <blockquote><p><code>ThreadLocal</code>在多线程和多类加载器环境中错误使用实例时，实例会带来严重问题（可能导致内存泄漏）。您应该始终考虑将threadlocal包装在其他一些类中，并且切勿直接使用其<code>ThreadLocal</code>本身（包装类中除外）。另外，您应该始终记住正确设置和取消设置<code>ThreadLocal.set(null)</code>线程本地资源（在后者只是涉及到的调用 ）。在任何情况下都应进行取消设置，因为不取消设置可能会导致出现问题。Spring的 <code>ThreadLocal</code>支持为您做到了这一点，应该始终考虑使用 <code>ThreadLocal</code>不带其他适当处理代码的实例。</blockquote> <h3 id=2-2-10、定义新的建议类型><a class=headerlink href=#2-2-10、定义新的建议类型 title=2.2.10、定义新的建议类型></a>2.2.10、定义新的建议类型</h3><p>Spring AOP被设计为可扩展的。尽管目前在内部使用拦截实现策略，但是除了在建议周围，在建议之前，抛出建议和返回建议之后进行拦截之外，还可以支持任意建议类型。</p> <p>该<code>org.springframework.aop.framework.adapter</code>软件包是一个SPI软件包，可以在不更改核心框架的情况下添加对新的自定义建议类型的支持。对自定义<code>Advice</code>类型的唯一限制是它必须实现 <code>org.aopalliance.aop.Advice</code>标记接口。</p> <p>See the <a href=https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/aop/framework/adapter/package-frame.html rel=noopener target=_blank><code>org.springframework.aop.framework.adapter</code></a> javadoc for further information.</p> <h2 id=2-3、AOP><a class=headerlink href=#2-3、AOP title=2.3、AOP></a>2.3、AOP</h2><p>面向方面的编程（AOP）通过提供另一种思考程序结构的方式来补充面向对象的编程（OOP）。OOP中模块化的关键单元是类，而在AOP中模块化是方面。方面支持跨多种类型和对象的关注点（例如事务管理）的模块化。（这种关注在AOP文献中通常被称为“跨领域”关注。）</p> <p>Spring的关键组件之一是AOP框架。尽管Spring IoC容器不依赖于AOP（这意味着您不需要的话就不需要使用AOP），但是AOP对Spring IoC进行了补充，以提供功能强大的中间件解决方案。</p> <blockquote><p>具有AspectJ切入点的Spring AOP<p>Spring通过使用<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-schema rel=noopener target=_blank>基于模式的方法</a>或<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj rel=noopener target=_blank>@AspectJ批注样式，</a>提供了编写自定义方面的简单而强大的方法 。这两种样式都提供了完全类型化的建议，并使用了AspectJ切入点语言，同时仍使用Spring AOP进行编织。</blockquote> <p>AOP在Spring框架中用于：</p> <ul><li>提供声明式企业服务。最重要的服务是 <a href=https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction-declarative rel=noopener target=_blank>声明式事务管理</a>。<li>让用户实现自定义方面，以AOP补充其对OOP的使用。</ul> <h3 id=2-3-1、AOP概念><a class=headerlink href=#2-3-1、AOP概念 title=2.3.1、AOP概念></a>2.3.1、AOP概念</h3><p>首先定义一些主要的AOP概念和术语。这些术语不是特定于Spring的。不幸的是，AOP术语并不是特别直观。但是，如果使用Spring自己的术语，将会更加令人困惑。</p> <ul><li>方面：涉及多个类别的关注点的模块化。在Spring AOP中，方面是通过使用常规类（<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-schema rel=noopener target=_blank>基于模式的方法</a>）或使用注释进行<code>@Aspect</code>注释的常规类 （<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj rel=noopener target=_blank>@AspectJ样式</a>）来实现的。<li>连接点：在程序执行过程中的一点，例如方法的执行或异常的处理。在Spring AOP中，连接点始终代表方法的执行。<li>通知：方面在特定的连接点处采取的操作。<li>切入点：与连接点匹配的谓词。建议与切入点表达式关联，并在与该切入点匹配的任何连接点处运行（例如，执行具有特定名称的方法）。切入点表达式匹配的连接点的概念是AOP的核心，默认情况下，Spring使用AspectJ切入点表达语言。<li>简介：代表类型声明其他方法或字段。Spring AOP允许您向任何建议对象引入新接口（和相应的实现）。例如，您可以使用简介使Bean实现 <code>IsModified</code>接口，以简化缓存。（在AspectJ社区中，介绍被称为类型间声明。）<li>目标对象：一个或多个方面建议的对象。也称为“建议对象”。由于Spring AOP是使用运行时代理实现的，因此该对象始终是代理对象。<li>AOP代理：由AOP框架创建的一个对象，用于实现方面合同（建议方法执行等）。在Spring中，AOP代理是JDK动态代理或CGLIB代理。<li>编织：将方面与其他应用程序类型或对象链接以创建建议的对象。这可以在编译时（例如，使用AspectJ编译器），加载时或在运行时完成。像其他纯Java AOP框架一样，Spring AOP在运行时执行编织。</ul> <p>Spring AOP包括以下类型的通知：</p> <ul><li>前置通知：在连接点之前运行的建议，但是它不能阻止执行流程继续进行到连接点（除非它引发异常）。<li>返回后通知：在连接点正常完成之后要运行的建议（例如，如果方法返回而没有引发异常）。<li>异常通知：如果方法因引发异常而退出，则运行建议。<li>后置通知：无论连接点退出的方式如何（正常或特殊收益），均应执行建议。<li>环绕通知：围绕连接点的建议，例如方法调用。这是最有力的建议。环绕通知可以在方法调用之前和之后执行自定义行为。它还负责选择是返回连接点还是通过返回其自身的返回值或引发异常来捷径建议的方法执行。</ul> <p>环绕通知是最通用的通知。由于Spring AOP与AspectJ一样，提供了各种建议类型，因此我们建议您使用功能最弱的建议类型，以实现所需的行为。使用最具体的通知类型可以提供更简单的编程模型，并减少出错的可能性。</p> <p>所有通知参数都是静态的，因此您可以使用适当类型（例如，方法执行的返回值的类型）而不是<code>Object</code>数组的通知参数。</p> <p>切入点匹配的连接点的概念是AOP的关键，它与仅提供拦截功能的旧技术有所不同。切入点使通知的目标独立于面向对象的层次结构。</p> <h3 id=2-3-2、Spring-AOP能力和目标><a title="2.3.2、Spring AOP能力和目标" class=headerlink href=#2-3-2、Spring-AOP能力和目标></a>2.3.2、Spring AOP能力和目标</h3><p>Spring AOP是用纯Java实现的。不需要特殊的编译过程。Spring AOP不需要控制类加载器的层次结构，因此适合在Servlet容器或应用程序服务器中使用。</p> <p>Spring AOP当前仅支持方法执行连接点（建议在Spring Bean上执行方法）。尽管可以在不破坏核心Spring AOP API的情况下添加对字段拦截的支持，但并未实现字段拦截。如果需要通知字段访问和更新连接点，请考虑使用诸如AspectJ之类的语言。</p> <p>Spring AOP的目的是在AOP实现和Spring IoC之间提供紧密的集成，以帮助解决企业应用程序中的常见问题。</p> <p>Spring无缝地将Spring AOP和IoC与AspectJ集成在一起，以在基于Spring的一致应用程序架构中支持AOP的所有使用。</p> <h3 id=2-3-3、AOP代理><a class=headerlink href=#2-3-3、AOP代理 title=2.3.3、AOP代理></a>2.3.3、AOP代理</h3><p>Spring AOP默认将JDK动态代理用于AOP代理。</p> <p>Spring AOP也可以使用CGLIB代理。默认情况下，如果业务对象未实现接口，则使用CGLIB。由于最好是对接口而不是对类进行编程，因此业务类通常实现一个或多个业务接口。</p> <h3 id=2-3-4、-AspectJ支持><a class=headerlink href=#2-3-4、-AspectJ支持 title=2.3.4、@AspectJ支持></a>2.3.4、@AspectJ支持</h3><p>@AspectJ是一种将方面声明为带有注释的常规Java类的样式。Spring使用AspectJ提供的用于切入点解析和匹配的库来解释与AspectJ 5相同的注释。但是，AOP运行时仍然是纯Spring AOP，并且不依赖于AspectJ编译器或编织器。</p> <h4 id=2-3-4-1、启用-AspectJ支持><a class=headerlink href=#2-3-4-1、启用-AspectJ支持 title=2.3.4.1、启用@AspectJ支持></a>2.3.4.1、启用@AspectJ支持</h4><p>可以使用XML或Java样式的配置来启用@AspectJ支持。无论哪种情况，您都需要确保AspectJ的<code>aspectj-weaver.jar</code>库位于应用程序的类路径（版本1.8或更高版本）上。</p> <h5 id=通过Java配置启用-AspectJ支持><a class=headerlink href=#通过Java配置启用-AspectJ支持 title=通过Java配置启用@AspectJ支持></a>通过Java配置启用@AspectJ支持</h5><p>要使用Java<code>@Configuration</code>启用@AspectJ支持，请添加<code>@EnableAspectJAutoProxy</code> 注释，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableAspectJAutoProxy</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=通过XML配置启用-AspectJ支持><a class=headerlink href=#通过XML配置启用-AspectJ支持 title=通过XML配置启用@AspectJ支持></a>通过XML配置启用@AspectJ支持</h5><p>要使用基于XML的配置启用@AspectJ支持，请使用<code>aop:aspectj-autoproxy</code> 元素，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspectj-autoproxy</span>/></span></span><br></pre></table></figure> <h4 id=2-3-4-2、声明一个方面><a class=headerlink href=#2-3-4-2、声明一个方面 title=2.3.4.2、声明一个方面></a>2.3.4.2、声明一个方面</h4><p>启用@AspectJ支持后，<code>@Aspect</code>Spring会自动检测到在应用程序上下文中使用@AspectJ方面（具有注释）的类定义的任何bean，并用于配置Spring AOP。接下来的两个示例显示了一个不太有用的方面所需的最小定义。</p> <p>这两个示例中的第一个示例显示了应用程序上下文中的常规bean定义，该定义指向具有<code>@Aspect</code>注释的bean类：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"myAspect"</span> <span class=attr>class</span>=<span class=string>"org.xyz.NotVeryUsefulAspect"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- configure properties of the aspect here --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>这两个示例中的第二个示例显示了<code>NotVeryUsefulAspect</code>类定义，该类定义带有<code>org.aspectj.lang.annotation.Aspect</code>批注；</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> org.xyz;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">NotVeryUsefulAspect</span> {</span><br><span class=line>}</span><br></pre></table></figure> <p>方面（带有<code>@Aspect</code>注释的类）可以具有方法和字段，与任何其他类相同。它们还可以包含切入点，通知和介绍（类型间）声明。</p> <blockquote><ul><li><p>通过组件扫描自动检测方面</p> <p>您可以将方面类注册为Spring XML配置中的常规bean，也可以通过类路径扫描自动检测它们-与其他任何Spring管理的bean一样。但是，请注意，<code>@Aspect</code>注释不足以在类路径中进行自动检测。为此，您需要添加一个单独的<code>@Component</code>注释（或者，或者，按照Spring的组件扫描程序的规则，一个合格的自定义原型注释）。</p><li><p>向其他方面提供建议？</p> <p>在Spring AOP中，方面本身不能成为其他方面的建议目标。<code>@Aspect</code>类上的注释将其标记为一个方面，因此将其从自动代理中排除。</p></ul></blockquote> <h4 id=2-3-4-3、声明切入点><a class=headerlink href=#2-3-4-3、声明切入点 title=2.3.4.3、声明切入点></a>2.3.4.3、声明切入点</h4><p>切入点声明由两部分组成：一个包含名称和任何参数的签名以及一个切入点表达式，该切入点表达式精确确定我们感兴趣的方法执行。在AOP的@AspectJ批注样式中，常规方法定义提供了切入点签名，并通过使用<code>@Pointcut</code>注释指示切入点表达式（用作切入点签名的方法必须具有<code>void</code>返回类型）。</p> <p>一个示例可能有助于使切入点签名和切入点表达式之间的区别变得清晰。以下示例定义了一个名为pointpoint的切入点<code>anyOldTransfer</code>，该切入点与任何名为<code>transfer</code>d的方法的执行相匹配：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta>@Pointcut("execution(* transfer(..))")</span> <span class=comment>// the pointcut expression</span></span><br><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">anyOldTransfer</span><span class=params>()</span> {} <span class=comment>// the pointcut signature</span></span><br></pre></table></figure> <p>形成<code>@Pointcut</code>注释值的切入点表达式是一个常规的AspectJ 5切入点表达式。</p> <h5 id=支持的切入点指示符><a class=headerlink href=#支持的切入点指示符 title=支持的切入点指示符></a>支持的切入点指示符</h5><p>Spring AOP支持以下在切入点表达式中使用的AspectJ切入点指示符（PCD）：</p> <ul><li><code>execution</code>：用于匹配方法执行的连接点。这是使用Spring AOP时要使用的主要切入点指示符。<li><code>within</code>：将匹配限制为某些类型内的连接点（使用Spring AOP时，在匹配类型内声明的方法的执行）。<li><code>this</code>：将匹配限制为连接点（使用Spring AOP时方法的执行），其中bean引用（Spring AOP代理）是给定类型的实例。<li><code>target</code>：在目标对象（代理的应用程序对象）是给定类型的实例的情况下，将匹配限制为连接点（使用Spring AOP时方法的执行）。<li><code>args</code>：将匹配限制为连接点（使用Spring AOP时方法的执行），其中参数是给定类型的实例。<li><code>@target</code>：在执行对象的类具有给定类型的注释的情况下，将匹配限制为连接点（使用Spring AOP时方法的执行）。<li><code>@args</code>：限制匹配的连接点（使用Spring AOP时方法的执行），其中传递的实际参数的运行时类型具有给定类型的注释。<li><code>@within</code>：将匹配限制为具有给定注释的类型内的连接点（使用Spring AOP时，使用给定注释的类型中声明的方法的执行）。<li><code>@annotation</code>：将匹配点限制为连接点的主题（在Spring AOP中运行的方法）具有给定注释的连接点。</ul> <blockquote><p>其他切入点类型?<p>完整的AspectJ切入点语言支持未在Spring支持额外的切入点指示符：<code>call</code>，<code>get</code>，<code>set</code>，<code>preinitialization</code>， <code>staticinitialization</code>，<code>initialization</code>，<code>handler</code>，<code>adviceexecution</code>，<code>withincode</code>，<code>cflow</code>， <code>cflowbelow</code>，<code>if</code>，<code>@this</code>，和<code>@withincode</code>。在Spring AOP解释的切入点表达式中使用这些切入点指示符会导致<code>IllegalArgumentException</code>抛出异常。<p>Spring AOP支持的切入点指示符集合可能会在将来的版本中扩展，以支持更多的AspectJ切入点指示符。</blockquote> <p>因为Spring AOP将匹配限制为仅方法执行连接点，所以前面对切入点指示符的讨论所给出的定义比AspectJ编程指南中的定义要窄。除此之外，AspectJ本身具有基于类型的语义和，在执行的连接点，无论是<code>this</code>和<code>target</code>指的是相同的对象：对象执行方法。Spring AOP是基于代理的系统，可区分代理对象本身（绑定到<code>this</code>）和代理后面的目标对象（绑定到<code>target</code>）。</p> <p>Spring AOP还支持一个名为的附加PCD <code>bean</code>。使用PCD，可以将连接点的匹配限制为特定的命名Spring Bean或一组命名Spring Bean（使用通配符时）。该<code>bean</code>PCD形式如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>bean(idOrNameOfBean)</span><br></pre></table></figure> <p>该<code>idOrNameOfBean</code>令牌可以是任何Spring bean的名字。提供了使用<code>*</code>字符的有限通配符支持，因此，如果为Spring bean建立了一些命名约定，则可以编写<code>bean</code>PCD表达式来选择它们。与其他切入点指示符一样，<code>bean</code>PCD也可以与<code>&&</code>（和），<code>||</code>（或）和<code>!</code>（取反）运算符一起使用。</p> <h5 id=组合切入点表达式><a class=headerlink href=#组合切入点表达式 title=组合切入点表达式></a>组合切入点表达式</h5><p>您可以使用<code>&&,</code> <code>||</code>和组合切入点表达式<code>!</code>。您也可以按名称引用切入点表达式。以下示例显示了三个切入点表达式：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Pointcut("execution(public * *(..))")</span></span><br><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">anyPublicOperation</span><span class=params>()</span> {} </span><br><span class=line></span><br><span class=line><span class=meta>@Pointcut("within(com.xyz.myapp.trading..*)")</span></span><br><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">inTrading</span><span class=params>()</span> {} </span><br><span class=line></span><br><span class=line><span class=meta>@Pointcut("anyPublicOperation() && inTrading()")</span></span><br><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">tradingOperation</span><span class=params>()</span> {} </span><br></pre></table></figure> <ol><li><code>anyPublicOperation</code> 如果方法执行连接点表示任何公共方法的执行，则匹配。<li><code>inTrading</code> 如果交易模块中有方法执行，则匹配。<li><code>tradingOperation</code> 如果方法执行代表交易模块中的任何公共方法，则匹配。</ol> <p>最佳实践是从较小的命名组件中构建更复杂的切入点表达式，如先前所示。当按名称引用切入点时，将应用常规的Java可见性规则（您可以看到相同类型的私有切入点，层次结构中受保护的切入点，任何位置的公共切入点，等等）。可见性不影响切入点匹配。</p> <h5 id=共享通用切入点定义><a class=headerlink href=#共享通用切入点定义 title=共享通用切入点定义></a>共享通用切入点定义</h5><p>在使用企业应用程序时，开发人员通常希望从多个方面引用应用程序的模块和特定的操作集。我们建议<code>CommonPointcuts</code>为此定义一个方面，以捕获常见的切入点表达式。这样的方面通常类似于以下示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.xyz.myapp;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CommonPointcuts</span> {</span><br><span class=line>    <span class=meta>@Pointcut("within(com.xyz.myapp.web..*)")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">inWebLayer</span><span class=params>()</span> {}</span><br><span class=line></span><br><span class=line>    <span class=meta>@Pointcut("within(com.xyz.myapp.service..*)")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">inServiceLayer</span><span class=params>()</span> {}</span><br><span class=line></span><br><span class=line>    <span class=meta>@Pointcut("within(com.xyz.myapp.dao..*)")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">inDataAccessLayer</span><span class=params>()</span> {}</span><br><span class=line></span><br><span class=line>    <span class=meta>@Pointcut("execution(* com.xyz.myapp..service.*.*(..))")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">businessService</span><span class=params>()</span> {}</span><br><span class=line></span><br><span class=line>    <span class=meta>@Pointcut("execution(* com.xyz.myapp.dao.*.*(..))")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">dataAccessOperation</span><span class=params>()</span> {}</span><br><span class=line>}</span><br></pre></table></figure> <p>您可以在需要切入点表达式的任何地方引用在这样的方面中定义的切入点。例如，要使服务层具有事务性，您可以编写以下内容：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:advisor</span></span></span><br><span class=line><span class=tag>        <span class=attr>pointcut</span>=<span class=string>"com.xyz.myapp.CommonPointcuts.businessService()"</span></span></span><br><span class=line><span class=tag>        <span class=attr>advice-ref</span>=<span class=string>"tx-advice"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>tx:advice</span> <span class=attr>id</span>=<span class=string>"tx-advice"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>tx:attributes</span>></span></span><br><span class=line>        <span class=tag><<span class=name>tx:method</span> <span class=attr>name</span>=<span class=string>"*"</span> <span class=attr>propagation</span>=<span class=string>"REQUIRED"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>tx:attributes</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>tx:advice</span>></span></span><br></pre></table></figure> <p>的<code>&LTaop:config></code>和<code>&LTaop:advisor></code>元件在讨论<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-schema rel=noopener target=_blank>基于Schema的AOP支持</a>。<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction rel=noopener target=_blank>事务管理</a>中讨论了<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction rel=noopener target=_blank>事务</a>元素。</p> <h5 id=编写好的切入点><a class=headerlink href=#编写好的切入点 title=编写好的切入点></a>编写好的切入点</h5><p>现有的指示符自然会属于以下三类之一：同类，作用域和上下文：</p> <ul><li>Kinded代号选择特定类型的连接点： <code>execution</code>，<code>get</code>，<code>set</code>，<code>call</code>，和<code>handler</code>。<li>作用域指定者选择一组感兴趣的连接点（可能有多种）：<code>within</code>和<code>withincode</code><li>语境指示符基于上下文匹配（和任选的绑定）： ， <code>this</code>，<code>target</code>和<code>@annotation</code></ul> <p>编写正确的切入点至少应包括前两种类型（种类和作用域）。您可以包括上下文指示符以根据连接点上下文进行匹配，也可以绑定该上下文以在建议中使用。仅提供同类的标识符或仅提供上下文的标识符是可行的，但是由于额外的处理和分析，可能会影响编织性能（使用的时间和内存）。范围指定符的匹配非常快，使用它们的使用意味着AspectJ可以非常迅速地消除不应进一步处理的连接点组。一个好的切入点应该始终包括一个切入点。</p> <h4 id=2-3-4-4、声明通知><a class=headerlink href=#2-3-4-4、声明通知 title=2.3.4.4、声明通知></a>2.3.4.4、声明通知</h4><h5 id=before通知><a class=headerlink href=#before通知 title=before通知></a>before通知</h5><p>您可以使用<code>@Before</code>注释在方面之前声明通知：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Before;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BeforeExample</span> {</span><br><span class=line>    <span class=meta>@Before("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doAccessCheck</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>如果使用就地切入点表达式，则可以将前面的示例重写为以下示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Before;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BeforeExample</span> {</span><br><span class=line>    <span class=meta>@Before("execution(* com.xyz.myapp.dao.*.*(..))")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doAccessCheck</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=after通知><a class=headerlink href=#after通知 title=after通知></a>after通知</h5><p>当匹配的方法执行退出时，建议（最终）运行。通过使用<code>@After</code>注释声明它。之后必须准备处理正常和异常返回条件的建议。它通常用于释放资源和类似目的。以下示例显示了最终通知后的用法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.After;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AfterFinallyExample</span> {</span><br><span class=line>    <span class=meta>@After("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doReleaseLock</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <blockquote><p>请注意，<code>@After</code>AspectJ中的通知被定义为“ after finally通知”，类似于try-catch语句中的finally块。它将针对从连接点（用户声明的目标方法）抛出的任何结果，正常返回或异常（<code>@AfterReturning</code>仅适用于成功的正常返回）进行调用。</blockquote> <h5 id=返回后通知-1><a class=headerlink href=#返回后通知-1 title=返回后通知></a>返回后通知</h5><p>返回通知后，当匹配的方法执行正常返回时运行建议。您可以使用<code>@AfterReturning</code>批注进行声明：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AfterReturningExample</span> {</span><br><span class=line>    <span class=meta>@AfterReturning("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doAccessCheck</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>有时，您需要在通知正文中访问返回的实际值。您可以使用<code>@AfterReturning</code>绑定返回值的形式来获得该访问权限，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AfterReturningExample</span> {</span><br><span class=line></span><br><span class=line>    <span class=meta>@AfterReturning(</span></span><br><span class=line><span class=meta>        pointcut="com.xyz.myapp.CommonPointcuts.dataAccessOperation()",</span></span><br><span class=line><span class=meta>        returning="retVal")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doAccessCheck</span><span class=params>(Object retVal)</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p><code>returning</code>属性中使用的名称必须与advice方法中的参数名称相对应。当方法执行返回时，返回值将作为相应的参数值传递到通知方法。甲<code>returning</code>子句也限制了只能匹配到返回指定类型的值（在这种情况下，那些方法执行<code>Object</code>，它匹配任何返回值）。</p> <h5 id=异常后通知><a class=headerlink href=#异常后通知 title=异常后通知></a>异常后通知</h5><p>抛出通知后，当匹配的方法执行通过抛出异常退出时，运行通知。您可以使用<code>@AfterThrowing</code>批注进行声明，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AfterThrowingExample</span> {</span><br><span class=line>    <span class=meta>@AfterThrowing("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doRecoveryActions</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>通常，您希望通知仅在引发给定类型的异常时才运行，并且您通常还需要访问通知正文中的引发异常。您可以使用该<code>throwing</code>属性来限制匹配（如果需要-<code>Throwable</code> 否则请用作异常类型），并将抛出的异常绑定到advice参数。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AfterThrowingExample</span> {</span><br><span class=line>    <span class=meta>@AfterThrowing(</span></span><br><span class=line><span class=meta>        pointcut="com.xyz.myapp.CommonPointcuts.dataAccessOperation()",</span></span><br><span class=line><span class=meta>        throwing="ex")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doRecoveryActions</span><span class=params>(DataAccessException ex)</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p><code>throwing</code>属性中使用的名称必须与advice方法中的参数名称相对应。当通过抛出异常退出方法执行时，该异常将作为相应的参数值传递给通知方法。甲<code>throwing</code>子句也限制了只能匹配到抛出指定类型的异常（那些方法执行<code>DataAccessException</code>，在这种情况下）。</p> <h5 id=环绕通知><a class=headerlink href=#环绕通知 title=环绕通知></a>环绕通知</h5><p>环绕通知在匹配方法的执行过程中“环绕”运行。它有机会在方法运行之前和之后进行工作，并确定何时，如何以及甚至实际上该方法可以运行。如果需要以线程安全的方式（例如，启动和停止计时器）在方法执行之前和之后共享状态，则通常使用绕行通知。</p> <p>通过使用<code>@Around</code>注释来声明环绕通知。咨询方法的第一个参数必须为类型<code>ProceedingJoinPoint</code>。在通知的主体，要求<code>proceed()</code>对<code>ProceedingJoinPoint</code>导致运行基本方法。该<code>proceed</code>方法还可以传递<code>Object[]</code>。数组中的值用作方法执行时的参数。</p> <p>以下示例显示了如何使用环绕通知：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Around;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AroundExample</span> {</span><br><span class=line>    <span class=meta>@Around("com.xyz.myapp.CommonPointcuts.businessService()")</span></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">doBasicProfiling</span><span class=params>(ProceedingJoinPoint pjp)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        <span class=comment>// start stopwatch</span></span><br><span class=line>        <span class=type>Object</span> <span class=variable>retVal</span> <span class=operator>=</span> pjp.proceed();</span><br><span class=line>        <span class=comment>// stop stopwatch</span></span><br><span class=line>        <span class=keyword>return</span> retVal;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>环绕通知返回的值是该方法的调用者看到的返回值。例如，如果一个简单的缓存方面有一个值，则可以从缓存中返回一个值，如果没有则调用<code>proceed()</code>。请注意，<code>proceed</code>在周围建议的正文中可能调用一次，多次调用或根本不调用该调用。所有这些都是合法的。</p> <h5 id=通知参数><a class=headerlink href=#通知参数 title=通知参数></a>通知参数</h5><p>Spring提供了完全类型化的建议，这意味着您可以在建议签名中声明所需的参数（如我们先前在返回和抛出示例中所看到的），而不是一直使用<code>Object[]</code>数组。我们将在本节的后面部分介绍如何使参数和其他上下文值可用于建议主体。首先，我们看一下如何编写通用建议，以了解该建议当前建议的方法。</p> <h6 id=访问当前JoinPoint><a class=headerlink href=#访问当前JoinPoint title=访问当前JoinPoint></a>访问当前JoinPoint</h6><p>任何通知方法都可以将类型的参数声明为它的第一个参数 <code>org.aspectj.lang.JoinPoint</code>（请注意，在通知周围需要声明类型的第一个参数<code>ProceedingJoinPoint</code>，它是的子类<code>JoinPoint</code>。<code>JoinPoint</code>接口提供了许多有用的方法：</p> <ul><li><code>getArgs()</code>：返回方法参数。<li><code>getThis()</code>：返回代理对象。<li><code>getTarget()</code>：返回目标对象。<li><code>getSignature()</code>：返回建议使用的方法的描述。<li><code>toString()</code>：打印有关所建议方法的有用描述。</ul> <h6 id=将参数传递给通知><a class=headerlink href=#将参数传递给通知 title=将参数传递给通知></a>将参数传递给通知</h6><p>假设您要通知执行以<code>Account</code> 对象为第一个参数的DAO操作，并且需要访问通知正文中的帐户。您可以编写以下内容：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Before("com.xyz.myapp.CommonPointcuts.dataAccessOperation() && args(account,..)")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">validateAccount</span><span class=params>(Account account)</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p><code>args(account,..)</code>切入点表达式的一部分有两个目的。首先，它将匹配限制为仅方法采用至少一个参数且传递给该参数的参数为的实例的方法执行<code>Account</code>。其次，它<code>Account</code>通过<code>account</code> 参数使实际对象可用于通知。</p> <p>编写此内容的另一种方法是声明一个切入点，<code>Account</code> 当切入点与连接点匹配时“提供”对象值，然后从通知中引用命名的切入点。如下所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Pointcut("com.xyz.myapp.CommonPointcuts.dataAccessOperation() && args(account,..)")</span></span><br><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">accountDataAccessOperation</span><span class=params>(Account account)</span> {}</span><br><span class=line></span><br><span class=line><span class=meta>@Before("accountDataAccessOperation(account)")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">validateAccount</span><span class=params>(Account account)</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>代理对象（<code>this</code>），目标对象（<code>target</code>），和说明（<code>@within</code>， <code>@target</code>，<code>@annotation</code>，和<code>@args</code>）都可以以类似的方式结合。接下来的两个示例展示了如何匹配使用注释进行<code>@Auditable</code>注释的方法的执行 并提取审计代码：</p> <p>这两个示例中的第一个示例显示了<code>@Auditable</code>注释的定义：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=line><span class=meta>@Target(ElementType.METHOD)</span></span><br><span class=line><span class=keyword>public</span> <span class=meta>@interface</span> Auditable {</span><br><span class=line>    AuditCode <span class="title function_">value</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>这两个示例中的第二个示例显示了与<code>@Auditable</code>方法执行相匹配的建议：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Before("com.xyz.lib.Pointcuts.anyPublicMethod() && @annotation(auditable)")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">audit</span><span class=params>(Auditable auditable)</span> {</span><br><span class=line>    <span class=type>AuditCode</span> <span class=variable>code</span> <span class=operator>=</span> auditable.value();</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <h6 id=通知参数和泛型><a class=headerlink href=#通知参数和泛型 title=通知参数和泛型></a>通知参数和泛型</h6><p>Spring AOP可以处理类声明和方法参数中使用的泛型。假设您具有如下通用类型：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Sample</span>&LTT> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">sampleGenericMethod</span><span class=params>(T param)</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">sampleGenericCollectionMethod</span><span class=params>(Collection&LTT> param)</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>您可以通过在要拦截方法的参数类型中键入advice参数，将方法类型的侦听限制为某些参数类型：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Before("execution(* ..Sample+.sampleGenericMethod(*)) && args(param)")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">beforeSampleMethod</span><span class=params>(MyType param)</span> {</span><br><span class=line>    <span class=comment>// Advice implementation</span></span><br><span class=line>}</span><br></pre></table></figure> <p>这种方法不适用于通用集合。因此，您不能按以下方式定义切入点：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Before("execution(* ..Sample+.sampleGenericCollectionMethod(*)) && args(param)")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">beforeSampleMethod</span><span class=params>(Collection&LTMyType> param)</span> {</span><br><span class=line>    <span class=comment>// Advice implementation</span></span><br><span class=line>}</span><br></pre></table></figure> <p>为了使这项工作有效，我们将不得不检查集合中的每个元素，这是不合理的，因为我们也无法决定<code>null</code>总体上如何对待价值。要实现与此类似的功能，您必须在上键入参数<code>Collection&LT?></code>并手动检查元素的类型。</p> <h6 id=确定参数命名称><a class=headerlink href=#确定参数命名称 title=确定参数命名称></a>确定参数命名称</h6><p>通知调用中的参数绑定依赖于切入点表达式中使用的名称与通知和切入点方法签名中声明的参数名称的匹配。通过Java反射无法获得参数名称，因此Spring AOP使用以下策略来确定参数名称：</p> <ul><li>如果用户已明确指定参数名称，则使用指定的参数名称。建议和切入点注释都具有可选<code>argNames</code>属性，您可以使用该属性指定带注释方法的参数名称。这些参数名称在运行时可用。以下示例显示如何使用<code>argNames</code>属性：</ul> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)", argNames="bean,auditable")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">audit</span><span class=params>(Object bean, Auditable auditable)</span> {</span><br><span class=line>    <span class=type>AuditCode</span> <span class=variable>code</span> <span class=operator>=</span> auditable.value();</span><br><span class=line>    <span class=comment>// ... use code and bean</span></span><br><span class=line>}</span><br></pre></table></figure> <p>如果第一个参数是的<code>JoinPoint</code>，<code>ProceedingJoinPoint</code>或 <code>JoinPoint.StaticPart</code>类型，你可以从价值离开了参数的名称<code>argNames</code>属性。例如，如果您修改前面的建议以接收连接点对象，则该<code>argNames</code>属性不需要包括它：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)", argNames="bean,auditable")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">audit</span><span class=params>(JoinPoint jp, Object bean, Auditable auditable)</span> {</span><br><span class=line>    <span class=type>AuditCode</span> <span class=variable>code</span> <span class=operator>=</span> auditable.value();</span><br><span class=line>    <span class=comment>// ... use code, bean, and jp</span></span><br><span class=line>}</span><br></pre></table></figure> <p>给出的第一个参数的特殊待遇<code>JoinPoint</code>， <code>ProceedingJoinPoint</code>和<code>JoinPoint.StaticPart</code>类型是不收取任何其它连接上下文的通知情况下，特别方便。在这种情况下，您可以忽略该<code>argNames</code>属性。例如，以下建议无需声明<code>argNames</code>属性：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Before("com.xyz.lib.Pointcuts.anyPublicMethod()")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">audit</span><span class=params>(JoinPoint jp)</span> {</span><br><span class=line>    <span class=comment>// ... use jp</span></span><br><span class=line>}</span><br></pre></table></figure> <ul><li>使用该<code>'argNames'</code>属性有点笨拙，因此，如果<code>'argNames'</code>未指定该属性，Spring AOP将查看该类的调试信息，并尝试从局部变量表中确定参数名称。只要已使用调试信息编译了类（<code>'-g:vars'</code>至少），此信息就存在。启用此标志时进行编译的结果是：（1）您的代码稍微易于理解（反向工程），（2）类文件的大小非常大（通常无关紧要），（3）删除未使用的本地代码的优化变量不适用于您的编译器。换句话说，通过启用该标志，您应该不会遇到任何困难。<li>如果在没有必要调试信息的情况下编译了代码，Spring AOP会尝试推断绑定变量与参数的配对（例如，如果切入点表达式中仅绑定了一个变量，并且advice方法仅接受一个参数，则配对很明显）。如果在给定可用信息的情况下变量的绑定不明确，<code>AmbiguousBindingException</code>则会引发an 。<li>如果以上所有策略均失败，<code>IllegalArgumentException</code>则抛出。</ul> <h6 id=进行论证><a class=headerlink href=#进行论证 title=进行论证></a>进行论证</h6><p>前面我们提到过，我们将描述如何编写一个<code>proceed</code>在Spring AOP和AspectJ中始终有效的参数调用。解决方案是确保建议签名按顺序绑定每个方法参数。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Around("execution(List&LTAccount> find*(..)) && " +</span></span><br><span class=line><span class=meta>        "com.xyz.myapp.CommonPointcuts.inDataAccessLayer() && " +</span></span><br><span class=line><span class=meta>        "args(accountHolderNamePattern)")</span></span><br><span class=line><span class=keyword>public</span> Object <span class="title function_">preProcessQueryPattern</span><span class=params>(ProceedingJoinPoint pjp, String accountHolderNamePattern)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=type>String</span> <span class=variable>newPattern</span> <span class=operator>=</span> preProcess(accountHolderNamePattern);</span><br><span class=line>    <span class=keyword>return</span> pjp.proceed(<span class=keyword>new</span> <span class="title class_">Object</span>[] {newPattern});</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=订购通知><a class=headerlink href=#订购通知 title=订购通知></a>订购通知</h5><p>当多条建议都希望在同一连接点上运行时会发生什么？Spring AOP遵循与AspectJ相同的优先级规则来确定建议执行的顺序。优先级最高的建议首先“在途中”运行（因此，给定两条优先建议，则优先级最高的建议首先运行）。从连接点“出路”中，优先级最高的建议将最后运行（因此，给定两条后置通知，优先级最高的建议将第二次运行）。</p> <p>当在不同方面定义的两条建议都需要在同一连接点上运行时，除非另行指定，否则执行顺序是不确定的。您可以通过指定优先级来控制执行顺序。通过<code>org.springframework.core.Ordered</code>在方面类中实现接口或使用注释对其进行<code>@Order</code>注释，可以以正常的Spring方式完成此操作。给定两个方面，从<code>Ordered.getOrder()</code>（或注释值）返回较低值的方面具有较高的优先级。</p> <blockquote><p>特定方面的每种不同建议类型在概念上均应直接应用于连接点。因此，<code>@AfterThrowing</code>建议方法不应从随附的<code>@After</code>/<code>@AfterReturning</code>方法接收异常。由于Spring框架5.2.7的，在同一个定义的通知方法<code>@Aspect</code>的类，需要在同一连接点运行基于分配优先级上按以下顺序他们的意见类型，从最高到最低的优先级：<code>@Around</code>，<code>@Before</code>，<code>@After</code>， <code>@AfterReturning</code>，<code>@AfterThrowing</code>。但是，请注意，<code>@After</code>将遵循AspectJ的“之后最终建议”语义，在相同方面的任何<code>@AfterReturning</code>或<code>@AfterThrowing</code>建议方法之后有效地调用建议方法<code>@After</code>。当在同一类中<code>@After</code>定义的两个相同类型的建议（例如，两个建议方法）<code>@Aspect</code>都需要在同一连接点上运行时，其顺序是未定义的（因为无法通过以下方式检索源代码声明顺序） Javac编译类的反射）。请考虑将此类建议方法折叠为每个<code>@Aspect</code>类中每个连接点的一个建议方法，或将这些建议重构为单独的<code>@Aspect</code>类，您可以通过<code>Ordered</code>或在方面级别进行排序<code>@Order</code>。</blockquote> <h4 id=2-3-4-5、引言><a class=headerlink href=#2-3-4-5、引言 title=2.3.4.5、引言></a>2.3.4.5、引言</h4><p>您可以使用<code>@DeclareParents</code>注释进行介绍。此批注用于声明匹配类型具有新的父代（因此具有名称）。例如，给定名为<code>UsageTracked</code>的接口和名为的接口的实现 <code>DefaultUsageTracked</code>，以下方面声明服务接口的所有实现者也都实现该<code>UsageTracked</code>接口（例如，通过JMX进行统计）：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">UsageTracking</span> {</span><br><span class=line>    <span class=meta>@DeclareParents(value="com.xzy.myapp.service.*+", defaultImpl=DefaultUsageTracked.class)</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> UsageTracked mixin;</span><br><span class=line>    <span class=meta>@Before("com.xyz.myapp.CommonPointcuts.businessService() && this(usageTracked)")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">recordUsage</span><span class=params>(UsageTracked usageTracked)</span> {</span><br><span class=line>        usageTracked.incrementUseCount();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>要实现的接口由带注释的字段的类型确定。注释的 <code>value</code>属性<code>@DeclareParents</code>是AspectJ类型的模式。任何匹配类型的bean都该实现<code>UsageTracked</code>接口。请注意，在前面示例的通知中，服务Bean可以直接用作<code>UsageTracked</code>接口的实现。如果以编程方式访问bean，则应编写以下内容：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>UsageTracked</span> <span class=variable>usageTracked</span> <span class=operator>=</span> (UsageTracked) context.getBean(<span class=string>"myService"</span>);</span><br></pre></table></figure> <h4 id=2-3-4-6、方面实例化模型><a class=headerlink href=#2-3-4-6、方面实例化模型 title=2.3.4.6、方面实例化模型></a>2.3.4.6、方面实例化模型</h4><p>默认情况下，应用程序上下文中每个方面都有一个实例。AspectJ将此称为单例实例化模型。可以使用备用生命周期来定义方面。Spring支持AspectJ的<code>perthis</code>和<code>pertarget</code> 实例化模型; <code>percflow</code>，<code>percflowbelow</code>和<code>pertypewithin</code>，目前不受支持。</p> <p>您可以通过在<code>@Aspect</code> 注释中指定<code>perthis</code>子句来声明方面。考虑以下示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Aspect("perthis(com.xyz.myapp.CommonPointcuts.businessService())")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyAspect</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> someState;</span><br><span class=line>    <span class=meta>@Before("com.xyz.myapp.CommonPointcuts.businessService()")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">recordServiceUsage</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>在前面的示例中，<code>perthis</code>子句的作用是为每个执行业务服务的唯一服务对象（每个唯一对象绑定到<code>this</code>与切入点表达式匹配的连接点处）创建一个方面实例。方面实例是在服务对象上首次调用方法时创建的。当服务对象超出范围时，方面将超出范围。在创建方面实例之前，其中的任何建议都不会运行。创建方面实例后，在其中声明的建议将在匹配的连接点处运行，但仅当服务对象是与此方面相关联的对象时才运行。</p> <p>该<code>pertarget</code>实例化样板工程完全相同的方式<code>perthis</code>，但在匹配的连接点，每个独立目标对象创建一个切面实例。</p> <h4 id=2-3-4-7、AOP示例><a class=headerlink href=#2-3-4-7、AOP示例 title=2.3.4.7、AOP示例></a>2.3.4.7、AOP示例</h4><p>因为我们想重试该操作，所以我们需要使用周围建议，以便可以<code>proceed</code>多次调用。以下清单显示了基本方面的实现：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ConcurrentOperationExecutor</span> <span class=keyword>implements</span> <span class="title class_">Ordered</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>final</span> <span class=type>int</span> <span class=variable>DEFAULT_MAX_RETRIES</span> <span class=operator>=</span> <span class=number>2</span>;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>maxRetries</span> <span class=operator>=</span> DEFAULT_MAX_RETRIES;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>order</span> <span class=operator>=</span> <span class=number>1</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMaxRetries</span><span class=params>(<span class=type>int</span> maxRetries)</span> {</span><br><span class=line>        <span class=built_in>this</span>.maxRetries = maxRetries;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">getOrder</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.order;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setOrder</span><span class=params>(<span class=type>int</span> order)</span> {</span><br><span class=line>        <span class=built_in>this</span>.order = order;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Around("com.xyz.myapp.CommonPointcuts.businessService()")</span></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">doConcurrentOperation</span><span class=params>(ProceedingJoinPoint pjp)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        <span class=type>int</span> <span class=variable>numAttempts</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>        PessimisticLockingFailureException lockFailureException;</span><br><span class=line>        <span class=keyword>do</span> {</span><br><span class=line>            numAttempts++;</span><br><span class=line>            <span class=keyword>try</span> {</span><br><span class=line>                <span class=keyword>return</span> pjp.proceed();</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>catch</span>(PessimisticLockingFailureException ex) {</span><br><span class=line>                lockFailureException = ex;</span><br><span class=line>            }</span><br><span class=line>        } <span class=keyword>while</span>(numAttempts <= <span class=built_in>this</span>.maxRetries);</span><br><span class=line>        <span class=keyword>throw</span> lockFailureException;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>请注意，方面实现了<code>Ordered</code>接口，因此我们可以将方面的优先级设置为高于事务建议（每次重试时都希望有新的事务）。该<code>maxRetries</code>和<code>order</code>性能都Spring配置。主要动作发生在<code>doConcurrentOperation</code>周围建议中。请注意，目前，我们将重试逻辑应用于每个<code>businessService()</code>。我们尝试继续，如果失败了<code>PessimisticLockingFailureException</code>，我们将再次尝试，除非我们用尽了所有的重试尝试。</p> <p>相应的Spring配置如下：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspectj-autoproxy</span>/></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"concurrentOperationExecutor"</span> <span class=attr>class</span>=<span class=string>"com.xyz.myapp.service.impl.ConcurrentOperationExecutor"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"maxRetries"</span> <span class=attr>value</span>=<span class=string>"3"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"order"</span> <span class=attr>value</span>=<span class=string>"100"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>为了改进方面，使其仅重试幂等操作，我们可以定义以下 <code>Idempotent</code>注释：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=line><span class=keyword>public</span> <span class=meta>@interface</span> Idempotent {</span><br><span class=line>    <span class=comment>// marker annotation</span></span><br><span class=line>}</span><br></pre></table></figure> <p>然后，我们可以使用注释来注释服务操作的实现。方面更改为仅重试幂等操作涉及到修改切入点表达式，以便仅<code>@Idempotent</code>操作匹配，如下所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Around("com.xyz.myapp.CommonPointcuts.businessService() && " +</span></span><br><span class=line><span class=meta>        "@annotation(com.xyz.myapp.service.Idempotent)")</span></span><br><span class=line><span class=keyword>public</span> Object <span class="title function_">doConcurrentOperation</span><span class=params>(ProceedingJoinPoint pjp)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <h3 id=2-3-5、基于架构的AOP支持><a class=headerlink href=#2-3-5、基于架构的AOP支持 title=2.3.5、基于架构的AOP支持></a>2.3.5、基于架构的AOP支持</h3><p>如果您更喜欢基于XML的格式，Spring还提供了使用<code>aop</code>命名空间标签定义方面的支持。支持与使用@AspectJ样式时完全相同的切入点表达式和建议类型。</p> <p>要使用aop命名空间标签，您需要导入 <code>spring-aop</code>模式，如<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#xsd-schemas rel=noopener target=_blank>基于XML Schema的配置中所述</a>。</p> <p>在您的Spring配置中，所有Aspect和Advisor元素必须放置在一个<code>&LTaop:config></code>元素内（<code>&LTaop:config></code>在应用程序上下文配置中可以有多个元素）。一个<code>&LTaop:config></code>元素可以包含切入点，顾问和纵横元件（注意这些必须按照这个顺序进行声明）。</p> <h4 id=2-3-5-1、声明一个方面><a class=headerlink href=#2-3-5-1、声明一个方面 title=2.3.5.1、声明一个方面></a>2.3.5.1、声明一个方面</h4><p>使用模式支持时，方面是在Spring应用程序上下文中定义为Bean的常规Java对象。状态和行为在对象的字段和方法中捕获，切入点和建议信息在XML中捕获。</p> <p>您可以使用<code>&LTaop:aspect></code>元素声明一个方面，并使用<code>ref</code>属性来引用支持bean ，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"myAspect"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>        ...</span><br><span class=line>    <span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"aBean"</span> <span class=attr>class</span>=<span class=string>"..."</span>></span></span><br><span class=line>    ...</span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>支持方面的Bean（<code>aBean</code>在这种情况下）当然可以像配置任何其他Spring Bean一样进行配置并注入依赖项。</p> <h4 id=2-3-5-2、声明切入点><a class=headerlink href=#2-3-5-2、声明切入点 title=2.3.5.2、声明切入点></a>2.3.5.2、声明切入点</h4><p>您可以在<code>&LTaop:config></code>元素内声明命名的切入点，从而使切入点定义在多个方面和顾问程序之间共享。</p> <p>可以定义代表服务层中任何业务服务的执行的切入点：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"businessService"</span></span></span><br><span class=line><span class=tag>        <span class=attr>expression</span>=<span class=string>"execution(* com.xyz.myapp.service.*.*(..))"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br></pre></table></figure> <p>请注意，切入点表达式本身使用的是<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj rel=noopener target=_blank>@AspectJ support中</a>所述的AspectJ切入点表达式语言。如果使用基于架构的声明样式，则可以引用在切入点表达式中的类型（@Aspects）中定义的命名切入点。定义上述切入点的另一种方法如下：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"businessService"</span></span></span><br><span class=line><span class=tag>        <span class=attr>expression</span>=<span class=string>"com.xyz.myapp.CommonPointcuts.businessService()"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br></pre></table></figure> <p>假定您具有“<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-common-pointcuts rel=noopener target=_blank>共享公共切入点定义”中</a><code>CommonPointcuts</code>描述的方面。</p> <p>然后，在方面中声明切入点与声明顶级切入点非常相似，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"myAspect"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"businessService"</span> <span class=attr>expression</span>=<span class=string>"execution(* com.xyz.myapp.service.*.*(..))"</span>/></span></span><br><span class=line></span><br><span class=line>        ...</span><br><span class=line>    <span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br></pre></table></figure> <p>与@AspectJ方面几乎相同，使用基于架构的定义样式声明的切入点可以收集连接点上下文。例如，以下切入点将<code>this</code>对象收集为连接点上下文，并将其传递给建议：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"myAspect"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"businessService"</span></span></span><br><span class=line><span class=tag>            <span class=attr>expression</span>=<span class=string>"execution(* com.xyz.myapp.service.*.*(..)) <span class=symbol>&ampamp;</span><span class=symbol>&ampamp;</span> this(service)"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>aop:before</span> <span class=attr>pointcut-ref</span>=<span class=string>"businessService"</span> <span class=attr>method</span>=<span class=string>"monitor"</span>/></span></span><br><span class=line>        ...</span><br><span class=line>    <span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br></pre></table></figure> <p>必须声明通知，以通过包含匹配名称的参数来接收收集的连接点上下文，如下所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">monitor</span><span class=params>(Object service)</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>当需要连接子表达式，<code>&&</code>是一个XML文档中的尴尬，这样你就可以使用<code>and</code>，<code>or</code>以及<code>not</code>到位的关键字<code>&&</code>， <code>||</code>和<code>!</code>分别。例如，上一个切入点可以更好地编写如下：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"myAspect"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"businessService"</span></span></span><br><span class=line><span class=tag>            <span class=attr>expression</span>=<span class=string>"execution(* com.xyz.myapp.service.*.*(..)) and this(service)"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>aop:before</span> <span class=attr>pointcut-ref</span>=<span class=string>"businessService"</span> <span class=attr>method</span>=<span class=string>"monitor"</span>/></span></span><br><span class=line></span><br><span class=line>        ...</span><br><span class=line>    <span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br></pre></table></figure> <p>请注意，以这种方式定义的切入点由其XML引用，<code>id</code>不能用作命名切入点以形成复合切入点。因此，基于架构的定义样式中的命名切入点支持比@AspectJ样式所提供的更受限制。</p> <h4 id=2-3-5-3、宣告通知><a class=headerlink href=#2-3-5-3、宣告通知 title=2.3.5.3、宣告通知></a>2.3.5.3、宣告通知</h4><p>基于模式的AOP支持使用与@AspectJ样式相同的五种建议，并且它们具有完全相同的语义。</p> <h5 id=前置通知-1><a class=headerlink href=#前置通知-1 title=前置通知></a>前置通知</h5><p>在执行匹配的方法之前，先运行建议。<code>&LTaop:aspect></code>使用<code>&LTaop:before></code>元素在里面声明它 ，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"beforeExample"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:before</span> <span class=attr>pointcut-ref</span>=<span class=string>"dataAccessOperation"</span> <span class=attr>method</span>=<span class=string>"doAccessCheck"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br></pre></table></figure> <p>这<code>dataAccessOperation</code>是<code>id</code>在顶层（<code>&LTaop:config></code>）定义的切入点的。要改为内联定义切入点，请按如下所示<code>pointcut-ref</code>用<code>pointcut</code>属性替换属性：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"beforeExample"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:before</span> <span class=attr>pointcut</span>=<span class=string>"execution(* com.xyz.myapp.dao.*.*(..))"</span> <span class=attr>method</span>=<span class=string>"doAccessCheck"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br></pre></table></figure> <p>正如我们在@AspectJ样式的讨论中所指出的那样，使用命名的切入点可以显着提高代码的可读性。</p> <p>该<code>method</code>属性标识<code>doAccessCheck</code>提供建议正文的方法（）。必须为包含建议的Aspect元素所引用的bean定义此方法。在执行数据访问操作（与切入点表达式匹配的方法执行连接点）之前，将<code>doAccessCheck</code>调用Aspect Bean上的方法。</p> <h5 id=返回后通知-2><a class=headerlink href=#返回后通知-2 title=返回后通知></a>返回后通知</h5><p>返回的建议在匹配的方法执行正常完成时运行。在内部以<code>&LTaop:aspect></code>与之前建议相同的方式声明它。以下示例显示了如何声明它：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"afterReturningExample"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:after-returning</span> <span class=attr>pointcut-ref</span>=<span class=string>"dataAccessOperation"</span> <span class=attr>method</span>=<span class=string>"doAccessCheck"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br></pre></table></figure> <p>与@AspectJ样式一样，您可以在建议正文中获取返回值。为此，使用<code>returning</code>属性指定返回值应传递到的参数的名称，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"afterReturningExample"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:after-returning</span> <span class=attr>pointcut-ref</span>=<span class=string>"dataAccessOperation"</span> <span class=attr>returning</span>=<span class=string>"retVal"</span> <span class=attr>method</span>=<span class=string>"doAccessCheck"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br></pre></table></figure> <p>该<code>doAccessCheck</code>方法必须声明一个名为的参数<code>retVal</code>。该参数的类型以与所述相同的方式约束匹配<code>@AfterReturning</code>。例如，您可以按以下方式声明方法签名：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doAccessCheck</span><span class=params>(Object retVal)</span> {...}</span><br></pre></table></figure> <h5 id=异常通知-1><a class=headerlink href=#异常通知-1 title=异常通知></a>异常通知</h5><p>抛出建议后，当匹配的方法执行通过抛出异常退出时，运行建议。<code>&LTaop:aspect></code>使用<code>after-throwing</code>元素在里面声明它，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"afterThrowingExample"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:after-throwing</span></span></span><br><span class=line><span class=tag>        <span class=attr>pointcut-ref</span>=<span class=string>"dataAccessOperation"</span></span></span><br><span class=line><span class=tag>        <span class=attr>method</span>=<span class=string>"doRecoveryActions"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br></pre></table></figure> <p>与@AspectJ样式一样，您可以在通知正文中获取引发的异常。为此，使用<code>throwing</code>属性指定异常应传递到的参数的名称，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"afterThrowingExample"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:after-throwing</span></span></span><br><span class=line><span class=tag>        <span class=attr>pointcut-ref</span>=<span class=string>"dataAccessOperation"</span></span></span><br><span class=line><span class=tag>        <span class=attr>throwing</span>=<span class=string>"dataAccessEx"</span></span></span><br><span class=line><span class=tag>        <span class=attr>method</span>=<span class=string>"doRecoveryActions"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br></pre></table></figure> <p>该<code>doRecoveryActions</code>方法必须声明一个名为的参数<code>dataAccessEx</code>。该参数的类型以与所述相同的方式约束匹配 <code>@AfterThrowing</code>。例如，方法签名可以声明如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doRecoveryActions</span><span class=params>(DataAccessException dataAccessEx)</span> {...}</span><br></pre></table></figure> <h5 id=后置通知><a class=headerlink href=#后置通知 title=后置通知></a>后置通知</h5><p>无论最终如何执行匹配的方法，建议（最终）都会运行。您可以使用<code>after</code>元素声明它，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"afterFinallyExample"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:after</span></span></span><br><span class=line><span class=tag>        <span class=attr>pointcut-ref</span>=<span class=string>"dataAccessOperation"</span></span></span><br><span class=line><span class=tag>        <span class=attr>method</span>=<span class=string>"doReleaseLock"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br></pre></table></figure> <h5 id=环绕通知-1><a class=headerlink href=#环绕通知-1 title=环绕通知></a>环绕通知</h5><p>最后一种建议是围绕建议。围绕建议在匹配的方法执行过程中“围绕”运行。它有机会在方法运行之前和之后进行工作，并确定何时，如何以及什至实际上该方法可以运行。周围建议通常用于以线程安全的方式（例如，启动和停止计时器）在方法执行之前和之后共享状态。始终使用最不强大的建议形式，以满足您的要求。如果建议可以完成这项工作，请不要在建议周围使用。</p> <p>您可以使用<code>aop:around</code>元素在建议周围声明。咨询方法的第一个参数必须为类型<code>ProceedingJoinPoint</code>。在通知的主体，要求<code>proceed()</code>对<code>ProceedingJoinPoint</code>导致运行基本方法。<code>proceed</code>也可以使用调用该方法<code>Object[]</code>。数组中的值用作方法执行时的参数。见<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj-around-advice rel=noopener target=_blank>around通知</a>的注意事项调用<code>proceed</code>有<code>Object[]</code>。以下示例显示了如何在XML中围绕建议进行声明：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"aroundExample"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:around</span></span></span><br><span class=line><span class=tag>        <span class=attr>pointcut-ref</span>=<span class=string>"businessService"</span></span></span><br><span class=line><span class=tag>        <span class=attr>method</span>=<span class=string>"doBasicProfiling"</span> /></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br></pre></table></figure> <p><code>doBasicProfiling</code>建议的实现可以与@AspectJ示例完全相同（当然要减去注释），如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> Object <span class="title function_">doBasicProfiling</span><span class=params>(ProceedingJoinPoint pjp)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=comment>// start stopwatch</span></span><br><span class=line>    <span class=type>Object</span> <span class=variable>retVal</span> <span class=operator>=</span> pjp.proceed();</span><br><span class=line>    <span class=comment>// stop stopwatch</span></span><br><span class=line>    <span class=keyword>return</span> retVal;</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=通知参数-1><a class=headerlink href=#通知参数-1 title=通知参数></a>通知参数</h5><p>基于架构的声明样式以与@AspectJ支持相同的方式支持完全类型的建议，即按名称将切入点参数与建议方法参数进行匹配。有关详细信息，请参见<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj-advice-params rel=noopener target=_blank>建议参数</a>。如果您希望显式指定建议方法的参数名称（不依赖于先前描述的检测策略），则可以通过使用<code>arg-names</code> 建议元素的属性来实现，该属性的使用方式与<code>argNames</code> 建议注释中的属性相同（如<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj-advice-params-names rel=noopener target=_blank>确定参数名称中所述</a>）。以下示例显示如何在XML中指定参数名称：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:before</span></span></span><br><span class=line><span class=tag>    <span class=attr>pointcut</span>=<span class=string>"com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)"</span></span></span><br><span class=line><span class=tag>    <span class=attr>method</span>=<span class=string>"audit"</span></span></span><br><span class=line><span class=tag>    <span class=attr>arg-names</span>=<span class=string>"auditable"</span>/></span></span><br></pre></table></figure> <p>该<code>arg-names</code>属性接受以逗号分隔的参数名称列表。</p> <p>以下是基于XSD的方法中涉及程度稍高的示例，显示了一些与一些强类型参数结合使用的建议：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> x.y.service;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">PersonService</span> {</span><br><span class=line>    Person <span class="title function_">getPerson</span><span class=params>(String personName, <span class=type>int</span> age)</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DefaultPersonService</span> <span class=keyword>implements</span> <span class="title class_">PersonService</span> {</span><br><span class=line>    <span class=keyword>public</span> Person <span class="title function_">getPerson</span><span class=params>(String name, <span class=type>int</span> age)</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">Person</span>(name, age);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>接下来是方面。注意，该<code>profile(..)</code>方法接受许多强类型参数，这一事实恰好是用于进行方法调用的连接点。该参数的存在表明 <code>profile(..)</code>将使用用作<code>around</code>建议，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> x.y;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class=line><span class=keyword>import</span> org.springframework.util.StopWatch;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleProfiler</span> {</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">profile</span><span class=params>(ProceedingJoinPoint call, String name, <span class=type>int</span> age)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        <span class=type>StopWatch</span> <span class=variable>clock</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StopWatch</span>(<span class=string>"Profiling for '"</span> + name + <span class=string>"' and '"</span> + age + <span class=string>"'"</span>);</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            clock.start(call.toShortString());</span><br><span class=line>            <span class=keyword>return</span> call.proceed();</span><br><span class=line>        } <span class=keyword>finally</span> {</span><br><span class=line>            clock.stop();</span><br><span class=line>            System.out.println(clock.prettyPrint());</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>最后，以下示例XML配置影响了特定连接点的上述建议的执行：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:aop</span>=<span class=string>"http://www.springframework.org/schema/aop"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- this is the object that will be proxied by Spring's AOP infrastructure --></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"personService"</span> <span class=attr>class</span>=<span class=string>"x.y.service.DefaultPersonService"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- this is the actual advice itself --></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"profiler"</span> <span class=attr>class</span>=<span class=string>"x.y.SimpleProfiler"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>        <span class=tag><<span class=name>aop:aspect</span> <span class=attr>ref</span>=<span class=string>"profiler"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"theExecutionOfSomePersonServiceMethod"</span> <span class=attr>expression</span>=<span class=string>"execution(* x.y.service.PersonService.getPerson(String,int)) and args(name, age)"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>aop:around</span> <span class=attr>pointcut</span> <span class=attr>ref</span>=<span class=string>"theExecutionOfSomePersonServiceMethod"</span></span></span><br><span class=line><span class=tag>                <span class=attr>method</span>=<span class=string>"profile"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>aop:config</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>考虑以下驱动程序脚本：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class=line><span class=keyword>import</span> x.y.service.PersonService;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>class</span> <span class="title class_">Boot</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(<span class=keyword>final</span> String[] args)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>BeanFactory</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class=string>"x/y/plain.xml"</span>);</span><br><span class=line>        <span class=type>PersonService</span> <span class=variable>person</span> <span class=operator>=</span> (PersonService) ctx.getBean(<span class=string>"personService"</span>);</span><br><span class=line>        person.getPerson(<span class=string>"Pengo"</span>, <span class=number>12</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=订购通知-1><a class=headerlink href=#订购通知-1 title=订购通知></a>订购通知</h5><p>当需要在同一连接点（执行方法）上运行多个建议时，排序规则如“<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj-advice-ordering rel=noopener target=_blank>建议排序”中所述</a>。方面之间的优先级是通过元素中的<code>order</code>属性确定的，<code>&LTaop:aspect></code>或者是通过将<code>@Order</code>注释添加到支持方面的Bean中，或者是由Bean实现<code>Ordered</code>接口来确定的。</p> <blockquote><p>与在同一<code>@Aspect</code> 类中定义的通知方法的优先规则相反，当在同一<code>&LTaop:aspect></code>元素中定义的两条建议都需要在同一连接点上运行时，优先级由在其中声明建议元素的顺序确定。包围<code>&LTaop:aspect></code>元素，从最高优先级到最低优先级。<p>例如，给定一个<code>around</code>建议和一个<code>before</code>建议，该建议和在同一<code>&LTaop:aspect></code>元素中定义的建议 适用于同一连接点，以确保<code>around</code> 建议的优先级高于<code>before</code>建议，<code>&LTaop:around></code>必须在该<code>&LTaop:before></code>元素之前声明该元素。<p>作为一般经验法则，如果发现在同一<code>&LTaop:aspect></code>元素中定义了多个适用于同一连接点的建议，请考虑将这些建议方法折叠为每个<code>&LTaop:aspect></code>元素中每个连接点的一个建议方法，或重构这些建议方法。建议<code>&LTaop:aspect></code>，您可以在方面级别订购单独的元素。</blockquote> <h4 id=2-3-5-4、引言><a class=headerlink href=#2-3-5-4、引言 title=2.3.5.4、引言></a>2.3.5.4、引言</h4><p>简介（在AspectJ中称为类型间声明）使方面可以声明建议的对象实现给定的接口，并代表那些对象提供该接口的实现。</p> <p>您可以通过使用中的<code>aop:declare-parents</code>元素进行介绍<code>aop:aspect</code>。您可以使用<code>aop:declare-parents</code>元素声明匹配类型具有新的父对象（因此为名称）。例如，给定一个名为的接口<code>UsageTracked</code>以及该名为的接口的实现 <code>DefaultUsageTracked</code>，以下方面声明服务接口的所有实现者也都实现该<code>UsageTracked</code>接口。（例如，为了通过JMX公开统计信息。）</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"usageTrackerAspect"</span> <span class=attr>ref</span>=<span class=string>"usageTracking"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:declare-parents</span></span></span><br><span class=line><span class=tag>        <span class=attr>types-matching</span>=<span class=string>"com.xzy.myapp.service.*+"</span></span></span><br><span class=line><span class=tag>        <span class=attr>implement-interface</span>=<span class=string>"com.xyz.myapp.service.tracking.UsageTracked"</span></span></span><br><span class=line><span class=tag>        <span class=attr>default-impl</span>=<span class=string>"com.xyz.myapp.service.tracking.DefaultUsageTracked"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>aop:before</span></span></span><br><span class=line><span class=tag>        <span class=attr>pointcut</span>=<span class=string>"com.xyz.myapp.CommonPointcuts.businessService()</span></span></span><br><span class=line><span class=string><span class=tag>            and this(usageTracked)"</span></span></span><br><span class=line><span class=tag>            <span class=attr>method</span>=<span class=string>"recordUsage"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br></pre></table></figure> <p>支持<code>usageTracking</code>bean的类将包含以下方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">recordUsage</span><span class=params>(UsageTracked usageTracked)</span> {</span><br><span class=line>    usageTracked.incrementUseCount();</span><br><span class=line>}</span><br></pre></table></figure> <p>要实现的接口由<code>implement-interface</code>属性确定。该<code>types-matching</code>属性的值是AspectJ类型的模式。任何匹配类型的bean都实现该<code>UsageTracked</code>接口。请注意，在前面示例的建议中，服务Bean可以直接用作<code>UsageTracked</code>接口的实现。要以编程方式访问bean，可以编写以下代码：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>UsageTracked</span> <span class=variable>usageTracked</span> <span class=operator>=</span> (UsageTracked) context.getBean(<span class=string>"myService"</span>);</span><br></pre></table></figure> <h4 id=2-3-5-5、方面实例化模型><a class=headerlink href=#2-3-5-5、方面实例化模型 title=2.3.5.5、方面实例化模型></a>2.3.5.5、方面实例化模型</h4><p>模式定义方面唯一受支持的实例化模型是单例模型。将来的版本中可能会支持其他实例化模型。</p> <h4 id=2-3-5-6、通知><a class=headerlink href=#2-3-5-6、通知 title=2.3.5.6、通知></a>2.3.5.6、通知</h4><p>Spring支持带有<code>&LTaop:advisor></code>元素的顾问程序概念。您通常会看到它与事务建议结合使用，事务建议在Spring中也有其自己的名称空间支持。以下示例显示顾问程序：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"businessService"</span></span></span><br><span class=line><span class=tag>        <span class=attr>expression</span>=<span class=string>"execution(* com.xyz.myapp.service.*.*(..))"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>aop:advisor</span></span></span><br><span class=line><span class=tag>        <span class=attr>pointcut-ref</span>=<span class=string>"businessService"</span></span></span><br><span class=line><span class=tag>        <span class=attr>advice-ref</span>=<span class=string>"tx-advice"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>tx:advice</span> <span class=attr>id</span>=<span class=string>"tx-advice"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>tx:attributes</span>></span></span><br><span class=line>        <span class=tag><<span class=name>tx:method</span> <span class=attr>name</span>=<span class=string>"*"</span> <span class=attr>propagation</span>=<span class=string>"REQUIRED"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>tx:attributes</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>tx:advice</span>></span></span><br></pre></table></figure> <p>除了<code>pointcut-ref</code>前面的示例中使用的<code>pointcut</code>属性外，还可以使用该 属性来内联定义切入点表达式。</p> <p>要定义顾问程序的优先级，以便该建议书可以参与订购，请使用该<code>order</code>属性来定义<code>Ordered</code>顾问程序的值。</p> <h4 id=2-3-5-7、AOP模式示例><a class=headerlink href=#2-3-5-7、AOP模式示例 title=2.3.5.7、AOP模式示例></a>2.3.5.7、AOP模式示例</h4><p>以下清单显示了基本方面的实现（这是使用模式支持的常规Java类）：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ConcurrentOperationExecutor</span> <span class=keyword>implements</span> <span class="title class_">Ordered</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>final</span> <span class=type>int</span> <span class=variable>DEFAULT_MAX_RETRIES</span> <span class=operator>=</span> <span class=number>2</span>;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>maxRetries</span> <span class=operator>=</span> DEFAULT_MAX_RETRIES;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>order</span> <span class=operator>=</span> <span class=number>1</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMaxRetries</span><span class=params>(<span class=type>int</span> maxRetries)</span> {</span><br><span class=line>        <span class=built_in>this</span>.maxRetries = maxRetries;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">getOrder</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.order;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setOrder</span><span class=params>(<span class=type>int</span> order)</span> {</span><br><span class=line>        <span class=built_in>this</span>.order = order;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">doConcurrentOperation</span><span class=params>(ProceedingJoinPoint pjp)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        <span class=type>int</span> <span class=variable>numAttempts</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>        PessimisticLockingFailureException lockFailureException;</span><br><span class=line>        <span class=keyword>do</span> {</span><br><span class=line>            numAttempts++;</span><br><span class=line>            <span class=keyword>try</span> {</span><br><span class=line>                <span class=keyword>return</span> pjp.proceed();</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>catch</span>(PessimisticLockingFailureException ex) {</span><br><span class=line>                lockFailureException = ex;</span><br><span class=line>            }</span><br><span class=line>        } <span class=keyword>while</span>(numAttempts <= <span class=built_in>this</span>.maxRetries);</span><br><span class=line>        <span class=keyword>throw</span> lockFailureException;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>请注意，方面实现了<code>Ordered</code>接口，因此我们可以将方面的优先级设置为高于事务建议（每次重试时都希望有新的事务）。该<code>maxRetries</code>和<code>order</code>性能都Spring配置。主要操作发生在“<code>doConcurrentOperation</code>周围建议”方法中。我们尝试继续。如果我们失败了<code>PessimisticLockingFailureException</code>，我们将重试，除非我们用尽了所有的重试尝试。</p> <p>相应的Spring配置如下：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"concurrentOperationRetry"</span> <span class=attr>ref</span>=<span class=string>"concurrentOperationExecutor"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"idempotentOperation"</span></span></span><br><span class=line><span class=tag>            <span class=attr>expression</span>=<span class=string>"execution(* com.xyz.myapp.service.*.*(..))"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>aop:around</span></span></span><br><span class=line><span class=tag>            <span class=attr>pointcut-ref</span>=<span class=string>"idempotentOperation"</span></span></span><br><span class=line><span class=tag>            <span class=attr>method</span>=<span class=string>"doConcurrentOperation"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"concurrentOperationExecutor"</span></span></span><br><span class=line><span class=tag>    <span class=attr>class</span>=<span class=string>"com.xyz.myapp.service.impl.ConcurrentOperationExecutor"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"maxRetries"</span> <span class=attr>value</span>=<span class=string>"3"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"order"</span> <span class=attr>value</span>=<span class=string>"100"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>请注意，目前我们假设所有业务服务都是幂等的。如果不是这种情况，我们可以通过引入一个<code>Idempotent</code>注释并使用该注释来注释服务操作的实现，来改进方面，使其仅重试真正的幂等操作，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=line><span class=keyword>public</span> <span class=meta>@interface</span> Idempotent {</span><br><span class=line>    <span class=comment>// marker annotation</span></span><br><span class=line>}</span><br></pre></table></figure> <p>方面更改为仅重试幂等操作涉及到修改切入点表达式，以便仅<code>@Idempotent</code>操作匹配，如下所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"idempotentOperation"</span></span></span><br><span class=line><span class=tag>        <span class=attr>expression</span>=<span class=string>"execution(* com.xyz.myapp.service.*.*(..)) and</span></span></span><br><span class=line><span class=string><span class=tag>        @annotation(com.xyz.myapp.service.Idempotent)"</span>/></span></span><br></pre></table></figure> <h3 id=2-3-6、选择要使用的AOP声明样式><a class=headerlink href=#2-3-6、选择要使用的AOP声明样式 title=2.3.6、选择要使用的AOP声明样式></a>2.3.6、选择要使用的AOP声明样式</h3><h4 id=2-3-6-1、Spring-AOP还是-Full-AspectJ？><a title="2.3.6.1、Spring AOP还是 Full AspectJ？" class=headerlink href=#2-3-6-1、Spring-AOP还是-Full-AspectJ？></a>2.3.6.1、Spring AOP还是 Full AspectJ？</h4><p>使用最简单的方法即可。Spring AOP比使用完整的AspectJ更简单，因为不需要在开发和构建过程中引入AspectJ编译器/编织器。如果您只需要建议在Spring Bean上执行操作，则Spring AOP是正确的选择。如果您需要建议不受Spring容器管理的对象（通常是域对象），则需要使用AspectJ。如果您希望建议除简单方法执行之外的连接点（例如，字段获取或设置连接点等），则还需要使用AspectJ。</p> <p>使用AspectJ时，可以选择AspectJ语言语法（也称为“代码样式”）或@AspectJ注释样式。显然，如果您不使用Java 5+，则可以为您做出选择：使用代码样式。如果方面在您的设计中起着重要作用，并且您能够将<a href=https://www.eclipse.org/ajdt/ rel=noopener target=_blank>AspectJ开发工具（AJDT）</a>插件用于Eclipse，则AspectJ语言语法是首选。它更干净，更简单，因为该语言是专为编写方面而设计的。如果您不使用Eclipse或只有少数几个方面在您的应用程序中不起作用，那么您可能要考虑使用@AspectJ样式，在IDE中坚持常规Java编译，并向其中添加方面编织阶段您的构建脚本。</p> <h4 id=2-3-6-2、-AspectJ或Spring-AOP的XML？><a title="2.3.6.2、@AspectJ或Spring AOP的XML？" class=headerlink href=#2-3-6-2、-AspectJ或Spring-AOP的XML？></a>2.3.6.2、@AspectJ或Spring AOP的XML？</h4><p>如果选择使用Spring AOP，则可以选择@AspectJ或XML样式。有各种折衷考虑。</p> <p>XML样式可能是现有Spring用户最熟悉的，并且得到了真正的POJO的支持。将AOP用作配置企业服务的工具时，XML可能是一个不错的选择（一个很好的测试是您是否将切入点表达式视为配置的一部分，而您可能希望独立更改）。使用XML样式，可以说从您的配置中可以更清楚地了解系统中存在哪些方面。</p> <p>XML样式有两个缺点。首先，它没有完全将要解决的需求的实现封装在一个地方。DRY原则说，系统中的任何知识都应该有一个单一，明确，权威的表示形式。当使用XML样式时，关于如何实现需求的知识会在配置文件中的后备bean类的声明和XML中分散。当您使用@AspectJ样式时，此信息将封装在一个模块中：方面。其次，与@AspectJ样式相比，XML样式在表达能力上有更多限制：仅支持“单例”方面实例化模型，并且无法组合以XML声明的命名切入点。例如，使用@AspectJ样式，您可以编写如下内容：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Pointcut("execution(* get*())")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">propertyAccess</span><span class=params>()</span> {}</span><br><span class=line></span><br><span class=line><span class=meta>@Pointcut("execution(org.xyz.Account+ *(..))")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">operationReturningAnAccount</span><span class=params>()</span> {}</span><br><span class=line></span><br><span class=line><span class=meta>@Pointcut("propertyAccess() && operationReturningAnAccount()")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">accountPropertyAccess</span><span class=params>()</span> {}</span><br></pre></table></figure> <p>在XML样式中，您可以声明前两个切入点：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"propertyAccess"</span></span></span><br><span class=line><span class=tag>        <span class=attr>expression</span>=<span class=string>"execution(* get*())"</span>/></span></span><br><span class=line><span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"operationReturningAnAccount"</span></span></span><br><span class=line><span class=tag>        <span class=attr>expression</span>=<span class=string>"execution(org.xyz.Account+ *(..))"</span>/></span></span><br></pre></table></figure> <p>XML方法的缺点是您无法 <code>accountPropertyAccess</code>通过组合这些定义来定义切入点。</p> <p>@AspectJ样式支持其他实例化模型和更丰富的切入点组合。它具有将方面保持为模块化单元的优势。它还具有的优点是，Spring AOP和AspectJ都可以理解@AspectJ方面。因此，如果您以后决定需要AspectJ的功能来实现其他要求，则可以轻松地迁移到经典的AspectJ设置。总而言之，Spring团队在自定义方面更喜欢@AspectJ样式，而不是简单地配置企业服务。</p> <h3 id=2-3-7、混合通知类型><a class=headerlink href=#2-3-7、混合通知类型 title=2.3.7、混合通知类型></a>2.3.7、混合通知类型</h3><p>通过使用自动代理支持，模式定义的<code>&LTaop:aspect></code>方面，<code>&LTaop:advisor></code>声明的顾问程序，甚至是同一配置中其他样式的代理和拦截器，完全可以混合@AspectJ样式的方面。所有这些都是通过使用相同的基础支持机制实现的，并且可以毫无困难地共存。</p> <h3 id=2-3-8、代理机制><a class=headerlink href=#2-3-8、代理机制 title=2.3.8、代理机制></a>2.3.8、代理机制</h3><p>Spring AOP使用JDK动态代理或CGLIB创建给定目标对象的代理。JDK内置了JDK动态代理，而CGLIB是一个通用的开源类定义库（重新打包为<code>spring-core</code>）。</p> <p>如果要代理的目标对象实现至少一个接口，则使用JDK动态代理。代理了由目标类型实现的所有接口。如果目标对象未实现任何接口，则将创建CGLIB代理。</p> <p>如果要强制使用CGLIB代理（例如，代理为目标对象定义的每个方法，而不仅是由其接口实现的方法），都可以这样做。但是，您应该考虑以下问题：</p> <ul><li>使用CGLIB，<code>final</code>不能通知方法，因为不能在运行时生成的子类中覆盖方法。<li>从Spring 4.0开始，由于CGLIB代理实例是通过Objenesis创建的，因此不再调用代理对象的构造函数两次。仅当您的JVM不允许绕过构造函数时，您才可以从Spring的AOP支持中看到两次调用和相应的调试日志条目。</ul> <p>要强制使用CGLIB代理，请将<code>&LTaop:config></code>元素的<code>proxy-target-class</code>属性值设置为true，如下所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:config</span> <span class=attr>proxy-target-class</span>=<span class=string>"true"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- other beans defined here... --></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br></pre></table></figure> <p>要在使用@AspectJ自动代理支持时强制CGLIB代理，请将 <code>&LTaop:aspectj-autoproxy></code>元素的<code>proxy-target-class</code>属性设置为<code>true</code>，如下所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspectj-autoproxy</span> <span class=attr>proxy-target-class</span>=<span class=string>"true"</span>/></span></span><br></pre></table></figure> <blockquote><p>多个<code>&LTaop:config/></code>部分在运行时折叠到一个统一的自动代理创建器中，该创建器将应用任何部分（通常来自不同XML Bean定义文件）指定的<em>最强</em>代理设置 <code>&LTaop:config/></code>。这也适用于<code>&LTtx:annotation-driven/></code>和<code>&LTaop:aspectj-autoproxy/></code> 元素。明确地说，<code>proxy-target-class="true"</code>在<code>&LTtx:annotation-driven/></code>， <code>&LTaop:aspectj-autoproxy/></code>或<code>&LTaop:config/></code>元素上使用会强制<em>对所有三个</em>元素使用CGLIB代理。</blockquote> <h4 id=2-3-8-1、了解AOP代理><a class=headerlink href=#2-3-8-1、了解AOP代理 title=2.3.8.1、了解AOP代理></a>2.3.8.1、了解AOP代理</h4><p>Spring AOP是基于代理的。在编写自己的方面或使用Spring框架随附的任何基于Spring AOP的方面之前，掌握最后一条语句实际含义的语义至关重要。</p> <p>首先考虑您有一个普通的，未经代理的，没有什么特别的，直接的对象引用的情况，如以下代码片段所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimplePojo</span> <span class=keyword>implements</span> <span class="title class_">Pojo</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">foo</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// this next method invocation is a direct call on the 'this' reference</span></span><br><span class=line>        <span class=built_in>this</span>.bar();</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">bar</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// some logic...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>如果在对象引用上调用方法，则直接在该对象引用上调用该方法，如下图和清单所示：</p> <p><img alt=aop代理普通pojo电话 src=https://docs.spring.io/spring-framework/docs/current/reference/html/images/aop-proxy-plain-pojo-call.png></p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>Pojo</span> <span class=variable>pojo</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SimplePojo</span>();</span><br><span class=line>        <span class=comment>// this is a direct method call on the 'pojo' reference</span></span><br><span class=line>        pojo.foo();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>当客户端代码具有的引用是代理时，情况会稍有变化。考虑以下图表和代码片段：</p> <p><img alt=aop代理呼叫 src=https://docs.spring.io/spring-framework/docs/current/reference/html/images/aop-proxy-call.png></p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>ProxyFactory</span> <span class=variable>factory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ProxyFactory</span>(<span class=keyword>new</span> <span class="title class_">SimplePojo</span>());</span><br><span class=line>        factory.addInterface(Pojo.class);</span><br><span class=line>        factory.addAdvice(<span class=keyword>new</span> <span class="title class_">RetryAdvice</span>());</span><br><span class=line></span><br><span class=line>        <span class=type>Pojo</span> <span class=variable>pojo</span> <span class=operator>=</span> (Pojo) factory.getProxy();</span><br><span class=line>        <span class=comment>// this is a method call on the proxy!</span></span><br><span class=line>        pojo.foo();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>创建代理时，还需要一些其他配置，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>ProxyFactory</span> <span class=variable>factory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ProxyFactory</span>(<span class=keyword>new</span> <span class="title class_">SimplePojo</span>());</span><br><span class=line>        factory.addInterface(Pojo.class);</span><br><span class=line>        factory.addAdvice(<span class=keyword>new</span> <span class="title class_">RetryAdvice</span>());</span><br><span class=line>        factory.setExposeProxy(<span class=literal>true</span>);</span><br><span class=line></span><br><span class=line>        <span class=type>Pojo</span> <span class=variable>pojo</span> <span class=operator>=</span> (Pojo) factory.getProxy();</span><br><span class=line>        <span class=comment>// this is a method call on the proxy!</span></span><br><span class=line>        pojo.foo();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>最后，必须指出，AspectJ没有此自调用问题，因为它不是基于代理的AOP框架。</p> <h3 id=2-3-9、以编程方式创建-AspectJ代理><a class=headerlink href=#2-3-9、以编程方式创建-AspectJ代理 title=2.3.9、以编程方式创建@AspectJ代理></a>2.3.9、以编程方式创建@AspectJ代理</h3><p>除了使用<code>&LTaop:config></code> 或来声明配置中的各个方面外，<code>&LTaop:aspectj-autoproxy></code>还可以通过编程方式创建通知目标对象的代理。</p> <p>您可以使用<code>org.springframework.aop.aspectj.annotation.AspectJProxyFactory</code>为一个或多个@AspectJ方面通知的目标对象创建代理。此类的基本用法非常简单，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=type>AspectJProxyFactory</span> <span class=variable>factory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AspectJProxyFactory</span>(targetObject);</span><br><span class=line>factory.addAspect(SecurityManager.class);</span><br><span class=line>factory.addAspect(usageTracker);</span><br><span class=line><span class=type>MyInterfaceType</span> <span class=variable>proxy</span> <span class=operator>=</span> factory.getProxy();</span><br></pre></table></figure> <h3 id=2-3-10、在Spring应用程序中使用AspectJ><a class=headerlink href=#2-3-10、在Spring应用程序中使用AspectJ title=2.3.10、在Spring应用程序中使用AspectJ></a>2.3.10、在Spring应用程序中使用AspectJ</h3><p>到目前为止，本章介绍的所有内容都是纯Spring AOP。在本节中，我们将研究如果您的需求超出了Spring AOP所提供的功能，那么如何使用AspectJ编译器或weaver代替Spring AOP或除Spring AOP之外使用。</p> <p>Spring附带了一个小的AspectJ方面库，可以在您的发行版中独立使用<code>spring-aspects.jar</code>。您需要将其添加到类路径中才能使用其中的方面。</p> <h4 id=2-3-10-1、使用AspectJ通过Spring依赖注入域对象><a class=headerlink href=#2-3-10-1、使用AspectJ通过Spring依赖注入域对象 title=2.3.10.1、使用AspectJ通过Spring依赖注入域对象></a>2.3.10.1、使用AspectJ通过Spring依赖注入域对象</h4><p>Spring容器实例化定义的bean并配置在您的应用程序上下文中。给定包含要应用的配置的Bean定义的名称，也可以要求Bean工厂配置预先存在的对象。 <code>spring-aspects.jar</code>包含注释驱动的方面，该方面利用此功能允许依赖项注入任何对象。该支撑旨在用于在任何容器的控制范围之外创建的对象。域对象通常属于此类，因为它们通常是<code>new</code>通过数据库查询的结果由操作员或ORM工具以编程方式创建的 。</p> <p>该<code>@Configurable</code>注释标记一个类为通过Spring驱动的配置。在最简单的情况下，您可以将其纯粹用作标记注释，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.xyz.myapp.domain;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Configurable;</span><br><span class=line></span><br><span class=line><span class=meta>@Configurable</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Account</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>当以这种方式用作标记接口时，Spring<code>Account</code>通过使用具有与完全限定的类型名称（<code>com.xyz.myapp.domain.Account</code>）同名的bean定义（通常为原型作用域）来配置带注释类型的新实例（在本例中为）。由于Bean的默认名称是其类型的完全限定名称，因此声明原型定义的简便方法是忽略该<code>id</code>属性，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"com.xyz.myapp.domain.Account"</span> <span class=attr>scope</span>=<span class=string>"prototype"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"fundsTransferService"</span> <span class=attr>ref</span>=<span class=string>"fundsTransferService"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>如果要显式指定要使用的原型bean定义的名称，则可以直接在批注中这样做，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.xyz.myapp.domain;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Configurable;</span><br><span class=line></span><br><span class=line><span class=meta>@Configurable("account")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Account</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>现在，Spring查找一个名为的bean定义<code>account</code>，并将其用作配置新<code>Account</code>实例的定义。</p> <p>您也可以使用自动装配来避免完全指定专用的bean定义。要让Spring应用自动装配，请使用 批注的<code>autowire</code>属性<code>@Configurable</code>。您可以分别通过类型或名称指定<code>@Configurable(autowire=Autowire.BY_TYPE)</code>或 <code>@Configurable(autowire=Autowire.BY_NAME</code>用于自动布线。作为替代方案，优选的是指定明确，注解驱动依赖注入为您的<code>@Configurable</code>豆通过<code>@Autowired</code>或<code>@Inject</code> 在外地或方法级（见<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config rel=noopener target=_blank>基于注解的容器配置</a>用于进一步的详细信息）。</p> <p>最后，您可以使用<code>dependencyCheck</code>属性（例如， <code>@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)</code>）来为新创建和配置的对象中的对象引用启用Spring依赖项检查。如果将此属性设置为<code>true</code>，Spring将在配置后验证是否已设置所有属性（不是基元或集合）。</p> <p>请注意，单独使用注释不会执行任何操作。注释的存在是通过 <code>AnnotationBeanConfigurerAspect</code>in<code>spring-aspects.jar</code>起作用的。从本质上讲，方面说：“从带有<code>@Configurable</code>注释类型的新对象的初始化返回之后，根据注释的属性使用Spring配置新创建的对象”。在这种情况下，“初始化”是指新实例化的对象（例如，用<code>new</code>运算符实例化的对象）以及<code>Serializable</code>正在进行反序列化的对象（例如，通过 <a href=https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html rel=noopener target=_blank>readResolve（）</a>）。</p> <p>为此，必须将带注释的类型与AspectJ编织器编织在一起。如果使用基于Java的配置，如下所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableSpringConfigured</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>}</span><br></pre></table></figure> <p>如果您更喜欢基于XML的配置，Spring <a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#xsd-schemas-context rel=noopener target=_blank><code>context</code>名称空间</a> 定义了一个方便的<code>context:spring-configured</code>元素，您可以按如下方式使用它：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>context:spring-configured</span>/></span></span><br></pre></table></figure> <p><code>@Configurable</code>在配置方面之前创建的对象实例会导致向调试日志发出消息，并且未进行对象配置。一个示例可能是Spring配置中的一个bean，当它由Spring初始化时会创建域对象。在这种情况下，您可以使用bean属性 <code>depends-on</code>来手动指定bean取决于配置方面。以下示例显示如何使用<code>depends-on</code>属性：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"myService"</span> <span class=attr>class</span>=<span class=string>"com.xzy.myapp.service.MyService"</span> <span class=attr>depends-on</span>=<span class=string>"org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect"</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <h5 id=单元测试-Configurable对象><a class=headerlink href=#单元测试-Configurable对象 title=单元测试@Configurable对象></a>单元测试<code>@Configurable</code>对象</h5><p><code>@Configurable</code>支持的目标之一是实现域对象的独立单元测试，而不会遇到与硬编码查找相关的困难。如果<code>@Configurable</code>AspectJ尚未编织类型，则注释在单元测试期间不起作用。您可以在被测对象中设置模拟或存根属性引用，然后照常进行。如果<code>@Configurable</code>AspectJ编织了类型，您仍然可以像往常一样在容器外部进行单元测试，但是每次构造<code>@Configurable</code>对象时，都会看到一条警告消息，指示该对象尚未由Spring进行配置。</p> <h5 id=使用多个应用程序上下文><a class=headerlink href=#使用多个应用程序上下文 title=使用多个应用程序上下文></a>使用多个应用程序上下文</h5><p>的<code>AnnotationBeanConfigurerAspect</code>是，用于实现<code>@Configurable</code>支持是一个AspectJ singleton切面。单例方面的范围与<code>static</code>成员的范围相同：每个类加载器都有一个方面实例来定义类型。这意味着，如果您在同一个类加载器层次结构中定义多个应用程序上下文，则需要考虑在何处定义<code>@EnableSpringConfigured</code>Bean以及将其放置<code>spring-aspects.jar</code>在类路径上。</p> <p>考虑一个典型的Spring Web应用程序配置，该配置具有一个共享的父应用程序上下文，该上下文定义了通用的业务服务，支持那些服务所需的一切，以及每个Servlet的一个子应用程序上下文（其中包含该Servlet的特定定义）。所有这些上下文共存于相同的类加载器层次结构中，因此<code>AnnotationBeanConfigurerAspect</code>只能保留对其中一个的引用。在这种情况下，我们建议<code>@EnableSpringConfigured</code>在共享（父）应用程序上下文中定义bean。这定义了您可能想注入域对象的服务。结果是，您无法使用@Configurable机制来配置域对象，而该域对象将引用在子（特定于servlet的）上下文中定义的bean的引用（无论如何，这都不是您想做的事情）。</p> <p>在同一容器中部署多个Web应用程序时，请确保每个Web应用程序都<code>spring-aspects.jar</code>使用自己的类加载器（例如，放置<code>spring-aspects.jar</code>在中<code>'WEB-INF/lib'</code>）来加载类型。如果<code>spring-aspects.jar</code> 仅将其添加到容器范围的类路径中（并因此由共享的父类加载器加载），则所有Web应用程序共享相同的方面实例（这可能不是您想要的）。</p> <h4 id=2-3-10-2、AspectJ的其他Spring方面><a class=headerlink href=#2-3-10-2、AspectJ的其他Spring方面 title=2.3.10.2、AspectJ的其他Spring方面></a>2.3.10.2、AspectJ的其他Spring方面</h4><p>除了<code>@Configurable</code>方面，还<code>spring-aspects.jar</code>包含一个AspectJ方面，您可以使用它来驱动对带有<code>@Transactional</code>注释的类型和方法进行Spring的事务管理。这主要适用于希望在Spring容器之外使用Spring Framework的事务支持的用户。</p> <p>解释<code>@Transactional</code>注释的方面是 <code>AnnotationTransactionAspect</code>。使用此方面时，必须注释实现类（或该类中的方法或两者），而不是注释该类所实现的接口（如果有）。AspectJ遵循Java的规则，即不继承接口上的注释。</p> <p>一<code>@Transactional</code>类上注解指定任何公开操作的类执行默认事务语义。</p> <p><code>@Transactional</code>类内方法的注释会覆盖类注释（如果存在）给出的默认事务语义。可以注释任何可见性的方法，包括私有方法。直接注释非公共方法是执行此类方法而获得事务划分的唯一方法。</p> <p>对于希望使用Spring配置和事务管理支持但又不想（或不能）使用注释的AspectJ程序员，它们<code>spring-aspects.jar</code> 还包含<code>abstract</code>可以扩展以提供自己的切入点定义的方面。有关更多信息，请参见<code>AbstractBeanConfigurerAspect</code>和 <code>AbstractTransactionAspect</code>方面的资源。作为示例，以下摘录显示了如何编写方面来使用与完全限定的类名匹配的原型Bean定义来配置域模型中定义的对象的所有实例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> aspect DomainObjectConfiguration <span class=keyword>extends</span> <span class="title class_">AbstractBeanConfigurerAspect</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">DomainObjectConfiguration</span><span class=params>()</span> {</span><br><span class=line>        setBeanWiringInfoResolver(<span class=keyword>new</span> <span class="title class_">ClassNameBeanWiringInfoResolver</span>());</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// the creation of a new bean (any object in the domain model)</span></span><br><span class=line>    <span class=keyword>protected</span> pointcut <span class="title function_">beanCreation</span><span class=params>(Object beanInstance)</span> :</span><br><span class=line>        initialization(<span class=keyword>new</span>(..)) &&</span><br><span class=line>        CommonPointcuts.inDomainModel() &&</span><br><span class=line>        <span class=built_in>this</span>(beanInstance);</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=2-3-10-3、使用Spring-IoC配置AspectJ-Aspects><a title="2.3.10.3、使用Spring IoC配置AspectJ Aspects" class=headerlink href=#2-3-10-3、使用Spring-IoC配置AspectJ-Aspects></a>2.3.10.3、使用Spring IoC配置AspectJ Aspects</h4><p>当您将AspectJ方面与Spring应用程序一起使用时，既自然又希望能够使用Spring配置此类方面。AspectJ运行时本身负责方面的创建，并且通过Spring配置AspectJ创建的方面的方法取决于方面所使用的AspectJ实例化模型（<code>per-xxx</code>子句）。</p> <p>AspectJ的大多数方面都是单例方面。这些方面的配置很容易。您可以创建一个bean定义，该bean定义照常引用方面类型并包含<code>factory-method="aspectOf"</code>bean属性。这样可以确保Spring通过向AspectJ索要长宽比实例，而不是尝试自己创建实例来获取长宽比实例。以下示例显示如何使用<code>factory-method="aspectOf"</code>属性：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"profiler"</span> <span class=attr>class</span>=<span class=string>"com.xyz.profiler.Profiler"</span></span></span><br><span class=line><span class=tag>        <span class=attr>factory-method</span>=<span class=string>"aspectOf"</span>></span> </span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"profilingStrategy"</span> <span class=attr>ref</span>=<span class=string>"jamonProfilingStrategy"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>非单一方面更难配置。然而，可以通过bean原型定义和使用这样做<code>@Configurable</code>从支持 <code>spring-aspects.jar</code>配置方面情况，一旦他们由AspectJ runtime创建。</p> <p>如果您有一些要与AspectJ编织的@AspectJ方面（例如，对域模型类型使用加载时编织）以及要与Spring AOP一起使用的其他@AspectJ方面，那么这些方面都已在Spring中配置，您需要告诉Spring AOP @AspectJ自动代理支持，应使用配置中定义的@AspectJ方面的确切子集进行自动代理。您可以通过<code>&LTinclude/></code>在<code>&LTaop:aspectj-autoproxy/></code> 声明中使用一个或多个元素来执行此操作。每个<code>&LTinclude/></code>元素都指定一个名称模式，只有名称与至少一个模式匹配的bean才可用于Spring AOP自动代理配置。以下示例显示了如何使用<code>&LTinclude/></code>元素：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspectj-autoproxy</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:include</span> <span class=attr>name</span>=<span class=string>"thisBean"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>aop:include</span> <span class=attr>name</span>=<span class=string>"thatBean"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:aspectj-autoproxy</span>></span></span><br></pre></table></figure> <h4 id=2-3-10-4、在Spring-Framework中使用AspectJ进行加载时编织><a title="2.3.10.4、在Spring Framework中使用AspectJ进行加载时编织" class=headerlink href=#2-3-10-4、在Spring-Framework中使用AspectJ进行加载时编织></a>2.3.10.4、在Spring Framework中使用AspectJ进行加载时编织</h4><p>加载时编织（LTW）是指将AspectJ方面加载到应用程序的类文件中时将其编织到Java虚拟机（JVM）中的过程。本节的重点是在Spring框架的特定上下文中配置和使用LTW。本节不是LTW的一般介绍。有关LTW的详细信息以及仅使用AspectJ配置LTW（完全不涉及Spring）的详细信息，请参阅<a href=https://www.eclipse.org/aspectj/doc/released/devguide/ltw.html rel=noopener target=_blank>《 AspectJ开发环境指南》</a>的 <a href=https://www.eclipse.org/aspectj/doc/released/devguide/ltw.html rel=noopener target=_blank>LTW部分</a>。</p> <p>Spring框架为AspectJ LTW带来的价值在于能够对编织过程进行更精细的控制。“ Vanilla” AspectJ LTW是通过使用Java（5+）代理实现的，该代理在启动JVM时通过指定VM参数来打开。因此，它是JVM范围的设置，在某些情况下可能很好，但通常有点过于粗糙。启用了Spring的LTW允许您<code>ClassLoader</code>逐个打开LTW ，它的粒度更细，并且在“单个JVM-多应用程序”环境中（例如在典型的应用程序服务器环境中可以找到）更有意义。 ）。</p> <p>此外，<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-aj-ltw-environments rel=noopener target=_blank>在某些环境中</a>，此支持可实现加载时编织，而无需对添加<code>-javaagent:path/to/aspectjweaver.jar</code>或所需的应用程序服务器的启动脚本进行任何修改（如本节稍后所述）<code>-javaagent:path/to/spring-instrument.jar</code>。开发人员将应用程序上下文配置为启用加载时编织，而不是依赖通常负责部署配置（例如启动脚本）的管理员。</p> <p>现在，销售工作已经结束，让我们首先浏览一个使用Spring的AspectJ LTW的快速示例，然后详细介绍该示例中引入的元素。</p> <h5 id=第一个例子><a class=headerlink href=#第一个例子 title=第一个例子></a>第一个例子</h5><p>下面的示例显示了配置方面的信息，这并不理想。这是一个基于时间的探查器，它使用@AspectJ样式的方面声明：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> foo;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Around;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class=line><span class=keyword>import</span> org.springframework.util.StopWatch;</span><br><span class=line><span class=keyword>import</span> org.springframework.core.annotation.Order;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ProfilingAspect</span> {</span><br><span class=line>    <span class=meta>@Around("methodsToBeProfiled()")</span></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">profile</span><span class=params>(ProceedingJoinPoint pjp)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        <span class=type>StopWatch</span> <span class=variable>sw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StopWatch</span>(getClass().getSimpleName());</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            sw.start(pjp.getSignature().getName());</span><br><span class=line>            <span class=keyword>return</span> pjp.proceed();</span><br><span class=line>        } <span class=keyword>finally</span> {</span><br><span class=line>            sw.stop();</span><br><span class=line>            System.out.println(sw.prettyPrint());</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Pointcut("execution(public * foo..*.*(..))")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">methodsToBeProfiled</span><span class=params>()</span>{}</span><br><span class=line>}</span><br></pre></table></figure> <p>我们还需要创建一个<code>META-INF/aop.xml</code>文件，以通知AspectJ编织器我们要将其编织<code>ProfilingAspect</code>到类中。这个文件约定，即在Java类路径上存在一个或多个文件（称为<code>META-INF/aop.xml</code>标准AspectJ）。以下示例显示了该<code>aop.xml</code>文件：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT!DOCTYPE <span class=keyword>aspectj</span> <span class=keyword>PUBLIC</span> <span class=string>"-//AspectJ//DTD//EN"</span> <span class=string>"https://www.eclipse.org/aspectj/dtd/aspectj.dtd"</span>></span></span><br><span class=line><span class=tag><<span class=name>aspectj</span>></span></span><br><span class=line>    <span class=tag><<span class=name>weaver</span>></span></span><br><span class=line>        <span class=comment>&LT!-- only weave classes in our application-specific packages --></span></span><br><span class=line>        <span class=tag><<span class=name>include</span> <span class=attr>within</span>=<span class=string>"foo.*"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>weaver</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aspects</span>></span></span><br><span class=line>        <span class=comment>&LT!-- weave in just this aspect --></span></span><br><span class=line>        <span class=tag><<span class=name>aspect</span> <span class=attr>name</span>=<span class=string>"foo.ProfilingAspect"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>aspects</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>aspectj</span>></span></span><br></pre></table></figure> <p>现在，我们可以继续进行配置中特定于Spring的部分。我们需要配置一个<code>LoadTimeWeaver</code>（稍后说明）。该加载时织布器是必不可少的组件，负责将一个或多个<code>META-INF/aop.xml</code>文件中的方面配置编织到应用程序的类中。好处是，它不需要很多配置（您可以指定一些其他选项，但是稍后会详细介绍），如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:context</span>=<span class=string>"http://www.springframework.org/schema/context"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/context</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/context/spring-context.xsd"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- a service object; we will be profiling its methods --></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"entitlementCalculationService"</span></span></span><br><span class=line><span class=tag>            <span class=attr>class</span>=<span class=string>"foo.StubEntitlementCalculationService"</span>/></span></span><br><span class=line>    <span class=comment>&LT!-- this switches on the load-time weaving --></span></span><br><span class=line>    <span class=tag><<span class=name>context:load-time-weaver</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>现在，所有必需的工件（方面，<code>META-INF/aop.xml</code> 文件和Spring配置）都就位了，我们可以使用<code>main(..)</code>方法来演示下面的LTW来创建以下驱动程序类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> foo;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>ApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class=string>"beans.xml"</span>, Main.class);</span><br><span class=line>        <span class=type>EntitlementCalculationService</span> <span class=variable>entitlementCalculationService</span> <span class=operator>=</span></span><br><span class=line>                (EntitlementCalculationService) ctx.getBean(<span class=string>"entitlementCalculationService"</span>);</span><br><span class=line>        <span class=comment>// the profiling aspect is 'woven' around this method execution</span></span><br><span class=line>        entitlementCalculationService.calculateEntitlement();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>我们还有最后一件事要做。本节的引言确实说过，可以<code>ClassLoader</code>使用Spring选择性地打开LTW ，这是事实。但是，对于此示例，我们使用Java代理（Spring随附）打开LTW。我们使用以下命令来运行<code>Main</code>前面显示的类：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -javaagent：C：/projects/foo/lib/global/spring-instrument.jar foo.Main</span><br></pre></table></figure> <p>该<code>-javaagent</code>标志用于指定<a href=https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html rel=noopener target=_blank>代理</a>并使 <a href=https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html rel=noopener target=_blank>代理能够对在JVM上运行的程序进行检测</a>。Spring Framework附带了这样的代理，该代理<code>InstrumentationSavingAgent</code>打包在中，该 代理<code>spring-instrument.jar</code>作为<code>-javaagent</code>上一示例中的参数值提供。</p> <p><code>Main</code>程序执行的输出类似于下一个示例。（我<code>Thread.sleep(..)</code>在<code>calculateEntitlement()</code> 实现中引入了一条语句，以便探查器实际上捕获的不是0毫秒（<code>01234</code>毫秒不是AOP引入的开销）。以下清单显示了运行探查器时得到的输出：</p> <p>由于此LTW是通过使用成熟的AspectJ来实现的，因此我们不仅限于建议Spring Bean。在<code>Main</code>程序上进行以下细微改动会产生相同的结果：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> foo;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=keyword>new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class=string>"beans.xml"</span>, Main.class);</span><br><span class=line>        <span class=type>EntitlementCalculationService</span> <span class=variable>entitlementCalculationService</span> <span class=operator>=</span></span><br><span class=line>                <span class=keyword>new</span> <span class="title class_">StubEntitlementCalculationService</span>();</span><br><span class=line>        <span class=comment>// the profiling aspect will be 'woven' around this method execution</span></span><br><span class=line>        entitlementCalculationService.calculateEntitlement();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>请注意，在前面的程序中，我们如何引导Spring容器，然后创建<code>StubEntitlementCalculationService</code>完全不在Spring上下文外部的新实例。剖析建议仍会被应用。</p> <p>诚然，这个例子很简单。但是，在前面的示例中，已经介绍了Spring对LTW支持的基础，本节的其余部分详细解释了每个配置和用法背后的“原因”。</p> <h5 id=方面><a class=headerlink href=#方面 title=方面></a>方面</h5><p>您在LTW中使用的方面必须是AspectJ方面。您可以使用AspectJ语言本身来编写它们，也可以使用@AspectJ风格来编写方面。这样，您的方面就是有效的AspectJ和Spring AOP方面。此外，编译的方面类需要在类路径上可用。</p> <h5 id=META-INF-aop-xml’><a title="META-INF / aop.xml’" class=headerlink href=#META-INF-aop-xml’></a>META-INF / aop.xml’</h5><p>通过使用<code>META-INF/aop.xml</code> Java类路径上的一个或多个文件（直接或通常在jar文件中）来配置AspectJ LTW基础结构。</p> <p>该文件的结构和内容在<a href=https://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html rel=noopener target=_blank>AspectJ参考文档</a>的LTW部分中进行了详细 <a href=https://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html rel=noopener target=_blank>说明</a>。由于该<code>aop.xml</code>文件是100％AspectJ，因此在此不再赘述。</p> <h5 id=所需的库（JARS）><a class=headerlink href=#所需的库（JARS） title=所需的库（JARS）></a>所需的库（JARS）</h5><p>至少，您需要以下库来使用Spring Framework对AspectJ LTW的支持：</p> <ul><li><code>spring-aop.jar</code><li><code>aspectjweaver.jar</code></ul> <p>如果使用<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-aj-ltw-environments-generic rel=noopener target=_blank>Spring提供的代理来启用检测</a>，则还需要：</p> <ul><li><code>spring-instrument.jar</code></ul> <h5 id=弹簧配置><a class=headerlink href=#弹簧配置 title=弹簧配置></a>弹簧配置</h5><p>Spring的LTW支持中的关键组件是<code>LoadTimeWeaver</code>接口（在 <code>org.springframework.instrument.classloading</code>包装中），以及Spring发行版附带的众多实现。A<code>LoadTimeWeaver</code>负责在运行时<code>java.lang.instrument.ClassFileTransformers</code>向a<code>ClassLoader</code>中添加一个或多个，这为各种有趣的应用程序打开了大门，其中之一恰好是方面的LTW。</p> <p><code>LoadTimeWeaver</code>为一个特定的配置a<code>ApplicationContext</code>就像添加一行一样容易。（请注意，您几乎可以肯定需要使用a <code>ApplicationContext</code>作为您的Spring容器-通常，a<code>BeanFactory</code>是不够的，因为LTW支持使用<code>BeanFactoryPostProcessors</code>。）</p> <p>要启用Spring Framework的LTW支持，您需要配置<code>LoadTimeWeaver</code>，通常通过使用<code>@EnableLoadTimeWeaving</code>批注来完成，如下所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableLoadTimeWeaving</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>}</span><br></pre></table></figure> <p>另外，如果您更喜欢基于XML的配置，请使用 <code>&LTcontext:load-time-weaver/></code>元素。请注意，元素是在<code>context</code>名称空间中定义的 。以下示例显示如何使用<code>&LTcontext:load-time-weaver/></code>：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:context</span>=<span class=string>"http://www.springframework.org/schema/context"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/context</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/context/spring-context.xsd"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>context:load-time-weaver</span>/></span></span><br><span class=line></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>前面的配置会自动为您定义并注册许多LTW特定的基础结构Bean，例如a<code>LoadTimeWeaver</code>和an <code>AspectJWeavingEnabler</code>。默认<code>LoadTimeWeaver</code>值为<code>DefaultContextLoadTimeWeaver</code>class，它尝试装饰自动检测到的<code>LoadTimeWeaver</code>。<code>LoadTimeWeaver</code> “自动检测”的确切类型取决于您的运行时环境。下表总结了各种<code>LoadTimeWeaver</code>实现：</p> <table><thead><tr><th align=left>运行环境<th align=left><code>LoadTimeWeaver</code> 实作<tbody><tr><td align=left>在<a href=https://tomcat.apache.org/ rel=noopener target=_blank>Apache Tomcat中</a>运行<td align=left><code>TomcatLoadTimeWeaver</code><tr><td align=left>在<a href=https://eclipse-ee4j.github.io/glassfish/ rel=noopener target=_blank>GlassFish中</a>运行（仅限EAR部署）<td align=left><code>GlassFishLoadTimeWeaver</code><tr><td align=left>在Red Hat的<a href=https://www.jboss.org/jbossas/ rel=noopener target=_blank>JBoss AS</a>或<a href=https://www.wildfly.org/ rel=noopener target=_blank>WildFly中运行</a><td align=left><code>JBossLoadTimeWeaver</code><tr><td align=left>在IBM的<a href=https://www-01.ibm.com/software/webservers/appserv/was/ rel=noopener target=_blank>WebSphere中</a>运行<td align=left><code>WebSphereLoadTimeWeaver</code><tr><td align=left>在Oracle的<a href=https://www.oracle.com/technetwork/middleware/weblogic/overview/index-085209.html rel=noopener target=_blank>WebLogic中</a>运行<td align=left><code>WebLogicLoadTimeWeaver</code><tr><td align=left>JVM从Spring <code>InstrumentationSavingAgent</code> （<code>java -javaagent:path/to/spring-instrument.jar</code>）开始<td align=left><code>InstrumentationLoadTimeWeaver</code><tr><td align=left>回退，期望基础ClassLoader遵循通用约定（即方法<code>addTransformer</code>，可选地<code>getThrowawayClassLoader</code>）<td align=left><code>ReflectiveLoadTimeWeaver</code></table> <p>请注意，该表仅列出<code>LoadTimeWeavers</code>使用时自动检测到的<code>DefaultContextLoadTimeWeaver</code>。您可以确切指定<code>LoadTimeWeaver</code> 要使用的实现。</p> <p>要指定特定<code>LoadTimeWeaver</code>的Java配置，请实现该 <code>LoadTimeWeavingConfigurer</code>接口并覆盖该<code>getLoadTimeWeaver()</code>方法。以下示例指定一个<code>ReflectiveLoadTimeWeaver</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableLoadTimeWeaving</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> <span class=keyword>implements</span> <span class="title class_">LoadTimeWeavingConfigurer</span> {</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> LoadTimeWeaver <span class="title function_">getLoadTimeWeaver</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">ReflectiveLoadTimeWeaver</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>如果使用基于XML的配置，则可以将完全限定的类名指定为 元素<code>weaver-class</code>上属性的值<code>&LTcontext:load-time-weaver/></code>。同样，以下示例指定了<code>ReflectiveLoadTimeWeaver</code>：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:context</span>=<span class=string>"http://www.springframework.org/schema/context"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/context</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/context/spring-context.xsd"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>context:load-time-weaver</span></span></span><br><span class=line><span class=tag>            <span class=attr>weaver-class</span>=<span class=string>"org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"</span>/></span></span><br><span class=line></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>该<code>LoadTimeWeaver</code>中定义并且由配置注册可从Spring容器通过使用公知的名称以后检索<code>loadTimeWeaver</code>。请记住，<code>LoadTimeWeaver</code>存在仅作为Spring LTW基础结构添加一个或多个的机制<code>ClassFileTransformers</code>。实际 <code>ClassFileTransformer</code>执行LTW的是<code>ClassPreProcessorAgentAdapter</code>（从<code>org.aspectj.weaver.loadtime</code>包中）类。有关<code>ClassPreProcessorAgentAdapter</code>更多详细信息，请参见该类的类级javadoc ，因为实际上如何实现编织的细节不在本文档的讨论范围之内。</p> <p>剩下要讨论的配置的最后一个属性：该<code>aspectjWeaving</code> 属性（或者，<code>aspectj-weaving</code>如果您使用XML）。此属性控制是否启用LTW。它接受三个可能值之一，默认值 <code>autodetect</code>是不存在该属性的情况。下表总结了三个可能的值：</p> <table><thead><tr><th align=left>注释值<th align=left>XML值<th align=left>说明<tbody><tr><td align=left><code>ENABLED</code><td align=left><code>on</code><td align=left>AspectJ正在编织，并且在加载时适当地编织了方面。<tr><td align=left><code>DISABLED</code><td align=left><code>off</code><td align=left>LTW已关闭。加载时不会编织任何方面。<tr><td align=left><code>AUTODETECT</code><td align=left><code>autodetect</code><td align=left>如果Spring LTW基础结构可以找到至少一个<code>META-INF/aop.xml</code>文件，则AspectJ编织已开始。否则，它关闭。这是默认值。</table> <h5 id=特定于环境的配置><a class=headerlink href=#特定于环境的配置 title=特定于环境的配置></a>特定于环境的配置</h5><p>最后一部分包含在应用程序服务器和Web容器等环境中使用Spring的LTW支持时所需的所有其他设置和配置。</p> <h6 id=Tomcat，JBoss，WebSphere，WebLogic><a class=headerlink href=#Tomcat，JBoss，WebSphere，WebLogic title=Tomcat，JBoss，WebSphere，WebLogic></a>Tomcat，JBoss，WebSphere，WebLogic</h6><p>Tomcat，JBoss / WildFly，IBM WebSphere Application Server和Oracle WebLogic Server均提供了<code>ClassLoader</code>能够进行本地检测的通用应用程序。Spring的本地LTW可以利用这些ClassLoader实现来提供AspectJ编织。您可以简单地启用加载时编织，<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-using-aspectj rel=noopener target=_blank>如前所述</a>。具体而言，您无需修改JVM启动脚本即可添加 <code>-javaagent:path/to/spring-instrument.jar</code>。</p> <p>请注意，在JBoss上，您可能需要禁用应用程序服务器扫描，以防止它在应用程序实际启动之前加载类。一个快速的解决方法是将一个<code>WEB-INF/jboss-scanning.xml</code>具有以下内容的文件添加到您的工件中：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>scanning</span> <span class=attr>xmlns</span>=<span class=string>"urn:jboss:scanning:1.0"</span>/></span></span><br></pre></table></figure> <h6 id=通用Java应用程序><a class=headerlink href=#通用Java应用程序 title=通用Java应用程序></a>通用Java应用程序</h6><p>在特定<code>LoadTimeWeaver</code>实现不支持的环境中需要类检测时，JVM代理是通用解决方案。对于这种情况，Spring提供了<code>InstrumentationLoadTimeWeaver</code>一个需要Spring特定（但非常通用）的JVM代理的程序，该JVM代理<code>spring-instrument.jar</code>可以通过common<code>@EnableLoadTimeWeaving</code>和<code>&LTcontext:load-time-weaver/></code>setups自动检测。</p> <p>要使用它，必须通过提供以下JVM选项来使用Spring代理启动虚拟机：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-javaagent：/path/to/spring-instrument.jar</span><br></pre></table></figure> <p>请注意，这需要修改JVM启动脚本，这可能会阻止您在应用程序服务器环境中使用它（取决于您的服务器和您的操作策略）。也就是说，对于每个JVM一个应用程序的部署（例如独立的Spring Boot应用程序），无论如何，您通常都可以控制整个JVM的设置。</p> <h3 id=2-3-11、更多资源><a class=headerlink href=#2-3-11、更多资源 title=2.3.11、更多资源></a>2.3.11、更多资源</h3><p>可以在<a href=https://www.eclipse.org/aspectj rel=noopener target=_blank>AspectJ网站</a>上找到有关<a href=https://www.eclipse.org/aspectj rel=noopener target=_blank>AspectJ的</a>更多信息。</p> <p><em>Eclipse AspectJ</em>，作者：Adrian Colyer等。等 （Addison-Wesley，2005年）为AspectJ语言提供了全面的介绍和参考。</p> <p>强烈推荐Ramnivas Laddad撰写的<em>《 AspectJ in Action》</em>第二版（Manning，2009年）。本书的2重点是AspectJ，但在一定程度上探讨了许多通用的AOP主题。</p> <h2 id=2-4、Spring表达式语言><a class=headerlink href=#2-4、Spring表达式语言 title=2.4、Spring表达式语言></a>2.4、Spring表达式语言</h2><p>Spring 表达式语言(简称“ SpEL”)是一种功能强大的表达式语言，支持在运行时查询和操作对象图。语言语法类似于 Unified EL，但提供了其他功能，最著名的是方法调用和基本的字符串模板功能。</p> <p>虽然 SpEL 是 Spring 产品组合中表达评估的基础，但它并不直接与 Spring 绑定，可以独立使用。</p> <p>表达式语言支持以下功能：</p> <ul><li>Literal expressions<li>布尔运算符和关系运算符<li>Regular expressions<li>Class expressions<li>访问属性，数组，列表和 Map<li>Method invocation<li>Relational operators<li>Assignment<li>Calling constructors<li>Bean references<li>Array construction<li>Inline lists<li>Inline maps<li>Ternary operator<li>Variables<li>User-defined functions<li>Collection projection<li>Collection selection<li>Templated expressions</ul> <h3 id=2-4-1、Evaluation><a class=headerlink href=#2-4-1、Evaluation title=2.4.1、Evaluation></a>2.4.1、Evaluation</h3><p>以下代码介绍了 SpEL API 来评估 Literals 字符串表达式<code>Hello World</code>。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line><span class=type>Expression</span> <span class=variable>exp</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"'Hello World'"</span>); (<span class=number>1</span>)</span><br><span class=line><span class=type>String</span> <span class=variable>message</span> <span class=operator>=</span> (String) exp.getValue();</span><br></pre></table></figure> <p>您最可能使用的 SpEL 类和接口位于<code>org.springframework.expression</code>包及其子包中，例如<code>spel.support</code>。</p> <p><code>ExpressionParser</code>接口负责解析表达式字符串。在前面的示例中，表达式字符串是由周围的单引号表示的字符串 Literals。 <code>Expression</code>接口负责评估先前定义的表达式字符串。分别调用<code>parser.parseExpression</code>和<code>exp.getValue</code>时，可以引发两个异常<code>ParseException</code>和<code>EvaluationException</code>。</p> <p>pEL 支持多种功能，例如调用方法，访问属性和调用构造函数。</p> <p>在以下方法调用示例中，我们在字符串 Literals 上调用<code>concat</code>方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line><span class=type>Expression</span> <span class=variable>exp</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"'Hello World'.concat('!')"</span>); (<span class=number>1</span>)</span><br><span class=line><span class=type>String</span> <span class=variable>message</span> <span class=operator>=</span> (String) exp.getValue();</span><br></pre></table></figure> <ul><li>(1) message 的值现在是 “Hello World！”。</ul> <p>以下调用 JavaBean 属性的示例将调用<code>String</code>属性<code>Bytes</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line></span><br><span class=line><span class=comment>// invokes 'getBytes()'</span></span><br><span class=line><span class=type>Expression</span> <span class=variable>exp</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"'Hello World'.bytes"</span>); (<span class=number>1</span>)</span><br><span class=line><span class=type>byte</span>[] bytes = (<span class=type>byte</span>[]) exp.getValue();</span><br></pre></table></figure> <p>SpEL 还通过使用标准的点符号(例如<code>prop1.prop2.prop3</code>)和属性值的设置来支持嵌套属性。也可以访问公共字段。下面的示例演示如何使用点表示法获取 Literals 的长度：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line></span><br><span class=line><span class=comment>// invokes 'getBytes().length'</span></span><br><span class=line><span class=type>Expression</span> <span class=variable>exp</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"'Hello World'.bytes.length"</span>); (<span class=number>1</span>)</span><br><span class=line><span class=type>int</span> <span class=variable>length</span> <span class=operator>=</span> (Integer) exp.getValue();</span><br></pre></table></figure> <p>可以调用 String 的构造函数，而不是使用字符串 Literals，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line><span class=type>Expression</span> <span class=variable>exp</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"new String('hello world').toUpperCase()"</span>); (<span class=number>1</span>)</span><br><span class=line><span class=type>String</span> <span class=variable>message</span> <span class=operator>=</span> exp.getValue(String.class);</span><br></pre></table></figure> <p>注意使用通用方法：<code>public &LTT> T getValue(Class&LTT> desiredResultType)</code>。使用此方法无需将表达式的值强制转换为所需的结果类型。如果无法将值强制转换为<code>T</code>类型或无法使用已注册的类型转换器进行转换，则将引发<code>EvaluationException</code>。</p> <p>SpEL 的更常见用法是提供一个表达式字符串，该字符串针对特定对象实例(称为根对象)进行评估。下面的示例演示如何从<code>Inventor</code>类的实例检索<code>name</code>属性或创建布尔条件：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=type>GregorianCalendar</span> <span class=variable>c</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">GregorianCalendar</span>();</span><br><span class=line>c.set(<span class=number>1856</span>, <span class=number>7</span>, <span class=number>9</span>);</span><br><span class=line></span><br><span class=line><span class=type>Inventor</span> <span class=variable>tesla</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Inventor</span>(<span class=string>"Nikola Tesla"</span>, c.getTime(), <span class=string>"Serbian"</span>);</span><br><span class=line></span><br><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line></span><br><span class=line><span class=type>Expression</span> <span class=variable>exp</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"name"</span>); (<span class=number>1</span>)</span><br><span class=line><span class=type>String</span> <span class=variable>name</span> <span class=operator>=</span> (String) exp.getValue(tesla);</span><br><span class=line><span class=comment>// name == "Nikola Tesla"</span></span><br><span class=line></span><br><span class=line>exp = parser.parseExpression(<span class=string>"name == 'Nikola Tesla'"</span>);</span><br><span class=line><span class=type>boolean</span> <span class=variable>result</span> <span class=operator>=</span> exp.getValue(tesla, Boolean.class);</span><br><span class=line><span class=comment>// result == true</span></span><br></pre></table></figure> <ul><li>将 name 解析为表达式。</ul> <h4 id=2-4-1-1、了解评估上下文><a class=headerlink href=#2-4-1-1、了解评估上下文 title=2.4.1.1、了解评估上下文></a>2.4.1.1、了解评估上下文</h4><p>评估表达式以解析属性，方法或字段并帮助执行类型转换时，使用<code>EvaluationContext</code>接口。 Spring 提供了两种实现。</p> <ul><li><code>SimpleEvaluationContext</code>：针对不需要全部 SpEL 语言语法范围且应受到有意义限制的表达式类别，公开了 SpEL 基本语言功能和配置选项的子集。示例包括但不限于数据绑定表达式和基于属性的过滤器。<li><code>StandardEvaluationContext</code>：公开 SpEL 语言功能和配置选项的全部集合。您可以使用它来指定默认的根对象，并配置每个可用的评估相关策略。</ul> <p><code>SimpleEvaluationContext</code>设计为仅支持 SpEL 语言语法的一部分。它不包括 Java 类型引用，构造函数和 Bean 引用。它还要求您明确选择对表达式中的属性和方法的支持级别。默认情况下，<code>create()</code>静态工厂方法仅启用对属性的读取访问。您还可以获取构建器来配置所需的确切支持级别，并针对以下一种或某些组合：</p> <ul><li>仅自定义<code>PropertyAccessor</code>(无反射)<li>只读访问的数据绑定属性<li>读写的数据绑定属性</ul> <h5 id=Type-Conversion><a title="Type Conversion" class=headerlink href=#Type-Conversion></a>Type Conversion</h5><p>默认情况下，SpEL 使用 Spring core(<code>org.springframework.core.convert.ConversionService</code>)中可用的转换服务。此转换服务随附有许多用于常见转换的内置转换器，但它也是完全可扩展的，因此您可以在类型之间添加自定义转换。此外，它是泛型感知的。这意味着，当您在表达式中使用泛型类型时，SpEL 会尝试进行转换以维护遇到的任何对象的类型正确性。</p> <p>在实践中这意味着什么？假设使用<code>setValue()</code>的赋值被用来设置<code>List</code>属性。该属性的类型实际上是<code>List&LTBoolean></code>。 SpEL 意识到列表中的元素需要先转换为<code>Boolean</code>，然后才能放入其中。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">Simple</span> {</span><br><span class=line>    <span class=keyword>public</span> List&LTBoolean> booleanList = <span class=keyword>new</span> <span class="title class_">ArrayList</span>&LTBoolean>();</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=type>Simple</span> <span class=variable>simple</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Simple</span>();</span><br><span class=line>simple.booleanList.add(<span class=literal>true</span>);</span><br><span class=line></span><br><span class=line><span class=type>EvaluationContext</span> <span class=variable>context</span> <span class=operator>=</span> SimpleEvaluationContext().forReadOnlyDataBinding().build();</span><br><span class=line></span><br><span class=line><span class=comment>// false is passed in here as a string. SpEL and the conversion service</span></span><br><span class=line><span class=comment>// correctly recognize that it needs to be a Boolean and convert it</span></span><br><span class=line>parser.parseExpression(<span class=string>"booleanList[0]"</span>).setValue(context, simple, <span class=string>"false"</span>);</span><br><span class=line></span><br><span class=line><span class=comment>// b is false</span></span><br><span class=line><span class=type>Boolean</span> <span class=variable>b</span> <span class=operator>=</span> simple.booleanList.get(<span class=number>0</span>);</span><br></pre></table></figure> <h4 id=2-4-1-2、解析器配置><a class=headerlink href=#2-4-1-2、解析器配置 title=2.4.1.2、解析器配置></a>2.4.1.2、解析器配置</h4><p>可以使用解析器配置对象(<code>org.springframework.expression.spel.SpelParserConfiguration</code>)配置 SpEL 表达式解析器。配置对象控制某些表达式组件的行为。例如，如果您索引到数组或集合中并且指定索引处的元素是<code>null</code>，则可以自动创建该元素。当使用由属性引用链组成的表达式时，这很有用。如果索引到数组或列表中并指定的索引超出了数组或列表当前大小的末尾，则可以自动增长数组或列表以容纳该索引。下面的示例演示如何自动增加列表：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">Demo</span> {</span><br><span class=line>    <span class=keyword>public</span> List&LTString> list;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// Turn on:</span></span><br><span class=line><span class=comment>// - auto null reference initialization</span></span><br><span class=line><span class=comment>// - auto collection growing</span></span><br><span class=line><span class=type>SpelParserConfiguration</span> <span class=variable>config</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelParserConfiguration</span>(<span class=literal>true</span>, <span class=literal>true</span>);</span><br><span class=line></span><br><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>(config);</span><br><span class=line></span><br><span class=line><span class=type>Expression</span> <span class=variable>expression</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"list[3]"</span>);</span><br><span class=line></span><br><span class=line><span class=type>Demo</span> <span class=variable>demo</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Demo</span>();</span><br><span class=line></span><br><span class=line><span class=type>Object</span> <span class=variable>o</span> <span class=operator>=</span> expression.getValue(demo);</span><br><span class=line></span><br><span class=line><span class=comment>// demo.list will now be a real collection of 4 entries</span></span><br><span class=line><span class=comment>// Each entry is a new empty String</span></span><br></pre></table></figure> <h4 id=2-4-1-3、SpEL编译><a class=headerlink href=#2-4-1-3、SpEL编译 title=2.4.1.3、SpEL编译></a>2.4.1.3、SpEL编译</h4><p>Spring Framework 4.1 包含一个基本的表达式编译器。通常对表达式进行解释，这样可以在评估过程中提供很大的动态灵活性，但不能提供最佳性能。对于偶尔使用表达式，这很好，但是，当与其他组件(如 Spring Integration)一起使用时，性能可能非常重要，并且不需要动态性。</p> <p>SpEL 编译器旨在满足这一需求。在评估期间，编译器会生成一个真实的 Java 类，该类体现了表达式行为，并使用该类来实现更快的表达式评估。由于缺少在表达式周围 Importing 内容的信息，因此编译器在执行编译时会使用在表达式的解释求值过程中收集的信息。例如，它不仅仅从表达式中就知道属性引用的类型，而是在第一次解释求值时就知道它是什么。当然，如果各种表达式元素的类型随时间变化，则基于此信息进行编译可能会在以后引起麻烦。因此，编译最适合类型信息在重复求值时不会改变的表达式。</p> <p>考虑以下基本表达式：</p> <figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>someArray[0].someProperty.someOtherProperty < 0.1</span><br></pre></table></figure> <p>因为前面的表达式涉及数组访问，一些属性取消引用和数字运算，所以性能提升可能非常明显。在一个示例中，进行了 50000 次迭代的微基准测试，使用解释器评估需要 75 毫秒，而使用表达式的编译版本仅需要 3 毫秒。</p> <h5 id=Compiler-Configuration><a title="Compiler Configuration" class=headerlink href=#Compiler-Configuration></a>Compiler Configuration</h5><p>默认情况下不打开编译器，但是您可以通过两种不同的方式之一来打开它。当 SpEL 用法嵌入到另一个组件中时，可以使用解析器配置过程(<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-parser-configuration rel=noopener target=_blank>discussed earlier</a>)或使用系统属性来将其打开。</p> <p>编译器可以在<code>org.springframework.expression.spel.SpelCompilerMode</code>枚举中捕获的三种模式之一进行操作。模式如下：</p> <ul><li><code>OFF</code>(默认)：编译器已关闭。<li><code>IMMEDIATE</code>：在立即模式下，将尽快编译表达式。通常是在第一次解释评估之后。如果编译的表达式失败(通常是由于类型更改，如前所述)，则表达式求值的调用者将收到异常。<li><code>MIXED</code>：在混合模式下，表达式会随着时间静默在解释模式和编译模式之间切换。经过一定数量的解释运行后，它们会切换到编译形式，如果编译形式出了问题(例如，如前面所述的类型更改)，则表达式会自动再次切换回解释形式。稍后，它可能会生成另一个已编译的表单并切换到该表单。基本上，用户进入<code>IMMEDIATE</code>模式的异常是在内部处理的。</ul> <p>之所以存在<code>IMMEDIATE</code>模式，是因为<code>MIXED</code>模式可能会导致具有副作用的表达式出现问题。如果已编译的表达式在部分成功后就崩溃了，则它可能已经完成了影响系统状态的操作。如果发生这种情况，调用者可能不希望它在解释模式下静默地重新运行，因为表达式的一部分可能运行了两次。</p> <p>选择模式后，使用<code>SpelParserConfiguration</code>配置解析器。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=type>SpelParserConfiguration</span> <span class=variable>config</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelParserConfiguration</span>(SpelCompilerMode.IMMEDIATE, <span class=built_in>this</span>.getClass().getClassLoader());</span><br><span class=line></span><br><span class=line><span class=type>SpelExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>(config);</span><br><span class=line><span class=type>Expression</span> <span class=variable>expr</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"payload"</span>);</span><br><span class=line><span class=type>MyMessage</span> <span class=variable>message</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">MyMessage</span>();</span><br><span class=line><span class=type>Object</span> <span class=variable>payload</span> <span class=operator>=</span> expr.getValue(message);</span><br></pre></table></figure> <p>当指定编译器模式时，还可以指定一个类加载器(允许传递 null)。编译的表达式是在提供的任何子类加载器中定义的。重要的是要确保，如果指定了类加载器，则它可以查看表达式评估过程中涉及的所有类型。如果未指定类加载器，则使用默认的类加载器(通常是在表达式求值期间运行的线程的上下文类加载器)。</p> <p>第二种配置编译器的方法是将 SpEL 嵌入到其他组件中，并且可能无法通过配置对象进行配置。在这些情况下，可以使用系统属性。您可以将<code>spring.expression.compiler.mode</code>属性设置为<code>SpelCompilerMode</code>枚举值之一(<code>off</code>，<code>immediate</code>或<code>mixed</code>)。</p> <h5 id=Compiler-Limitations><a title="Compiler Limitations" class=headerlink href=#Compiler-Limitations></a>Compiler Limitations</h5><p>从 Spring Framework 4.1 开始，已经有了基本的编译框架。但是，该框架尚不支持编译每种表达式。最初的重点是可能在性能关键型上下文中使用的通用表达式。目前无法编译以下类型的表达式：</p> <ul><li>涉及赋值的表达<li>表达式依赖转换服务<li>使用自定义解析器或访问器的表达式<li>使用选择或投影的表达式</ul> <p>将来会编译更多类型的表达。</p> <h3 id=2-4-2、Bean定义中的表达式><a class=headerlink href=#2-4-2、Bean定义中的表达式 title=2.4.2、Bean定义中的表达式></a>2.4.2、Bean定义中的表达式</h3><p>您可以将 SpEL 表达式与基于 XML 或基于注解的配置元数据一起使用，以定义<code>BeanDefinition</code>实例。在这两种情况下，定义表达式的语法均为<code>#{ &LTexpression string> }</code>形式。</p> <h4 id=2-4-2-1、XML配置><a class=headerlink href=#2-4-2-1、XML配置 title=2.4.2.1、XML配置></a>2.4.2.1、XML配置</h4><p>可以使用表达式来设置属性或构造函数的参数值，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"numberGuess"</span> <span class=attr>class</span>=<span class=string>"org.spring.samples.NumberGuess"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"randomNumber"</span> <span class=attr>value</span>=<span class=string>"#{ T(java.lang.Math).random() * 100.0 }"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- other properties --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p><code>systemProperties</code>变量是 sched 义的，因此您可以在表达式中使用它，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"taxCalculator"</span> <span class=attr>class</span>=<span class=string>"org.spring.samples.TaxCalculator"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"defaultLocale"</span> <span class=attr>value</span>=<span class=string>"#{ systemProperties['user.region'] }"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- other properties --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>请注意，在这种情况下，您不必在 sched 义变量前加上<code>#</code>符号。</p> <p>您还可以按名称引用其他 bean 属性，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"numberGuess"</span> <span class=attr>class</span>=<span class=string>"org.spring.samples.NumberGuess"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"randomNumber"</span> <span class=attr>value</span>=<span class=string>"#{ T(java.lang.Math).random() * 100.0 }"</span>/></span></span><br><span class=line>    <span class=comment>&LT!-- other properties --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"shapeGuess"</span> <span class=attr>class</span>=<span class=string>"org.spring.samples.ShapeGuess"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"initialShapeSeed"</span> <span class=attr>value</span>=<span class=string>"#{ numberGuess.randomNumber }"</span>/></span></span><br><span class=line>    <span class=comment>&LT!-- other properties --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <h4 id=2-4-2-2、注解配置><a class=headerlink href=#2-4-2-2、注解配置 title=2.4.2.2、注解配置></a>2.4.2.2、注解配置</h4><p>若要指定默认值，可以在字段，方法以及方法或构造函数参数上放置<code>@Value</code>注解。</p> <p>下面的示例设置字段变量的默认值：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">FieldValueTestBean</span></span><br><span class=line></span><br><span class=line>    <span class=meta>@Value("#{ systemProperties['user.region'] }")</span></span><br><span class=line>    <span class=keyword>private</span> String defaultLocale;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setDefaultLocale</span><span class=params>(String defaultLocale)</span> {</span><br><span class=line>        <span class=built_in>this</span>.defaultLocale = defaultLocale;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getDefaultLocale</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.defaultLocale;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure> <p>以下示例显示了等效的但使用属性设置器方法的示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">PropertyValueTestBean</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> String defaultLocale;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Value("#{ systemProperties['user.region'] }")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setDefaultLocale</span><span class=params>(String defaultLocale)</span> {</span><br><span class=line>        <span class=built_in>this</span>.defaultLocale = defaultLocale;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getDefaultLocale</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.defaultLocale;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure> <p>自动装配的方法和构造函数也可以使用<code>@Value</code>注解，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=keyword>private</span> String defaultLocale;</span><br><span class=line>    </span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">configure</span><span class=params>(MovieFinder movieFinder, <span class=meta>@Value("#{ systemProperties['user.region'] }")</span> String defaultLocale)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>        <span class=built_in>this</span>.defaultLocale = defaultLocale;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=keyword>private</span> String defaultLocale;</span><br><span class=line>    <span class=keyword>private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MovieRecommender</span><span class=params>(CustomerPreferenceDao customerPreferenceDao, <span class=meta>@Value("#{systemProperties['user.country']}")</span> String defaultLocale)</span> {</span><br><span class=line>        <span class=built_in>this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class=line>        <span class=built_in>this</span>.defaultLocale = defaultLocale;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <h3 id=2-4-3、语言参考><a class=headerlink href=#2-4-3、语言参考 title=2.4.3、语言参考></a>2.4.3、语言参考</h3><p>本节描述了 Spring Expression Language 的工作方式。它涵盖以下主题：</p> <ul><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-ref-literal rel=noopener target=_blank>Literal Expressions</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-properties-arrays rel=noopener target=_blank>属性，数组，列表，Map 和索引器</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-inline-lists rel=noopener target=_blank>Inline Lists</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-inline-maps rel=noopener target=_blank>Inline Maps</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-array-construction rel=noopener target=_blank>Array Construction</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-methods rel=noopener target=_blank>Methods</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operators rel=noopener target=_blank>Operators</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-types rel=noopener target=_blank>Types</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-constructors rel=noopener target=_blank>Constructors</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-ref-variables rel=noopener target=_blank>Variables</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-ref-functions rel=noopener target=_blank>Functions</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-bean-references rel=noopener target=_blank>Bean References</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operator-ternary rel=noopener target=_blank>三元运算符(If-Then-Else)</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operator-elvis rel=noopener target=_blank>Elvisoperator</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operator-safe-navigation rel=noopener target=_blank>安全导航操作员</a></ul> <h4 id=2-4-3-1、Literals表达><a class=headerlink href=#2-4-3-1、Literals表达 title=2.4.3.1、Literals表达></a>2.4.3.1、Literals表达</h4><p>支持的 Literals 表达式的类型为字符串，数值(int，实数，十六进制)，布尔值和 null。字符串由单引号引起来。要将单引号本身放在字符串中，请使用两个单引号字符。</p> <p>以下清单显示了 Literals 的简单用法。通常，它们不是像这样孤立地使用，而是作为更复杂的表达式的一部分使用-例如，在逻辑比较运算符的一侧使用 Literals。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line><span class=comment>// evals to "Hello World"</span></span><br><span class=line><span class=type>String</span> <span class=variable>helloWorld</span> <span class=operator>=</span> (String) parser.parseExpression(<span class=string>"'Hello World'"</span>).getValue();</span><br><span class=line><span class=type>double</span> <span class=variable>avogadrosNumber</span> <span class=operator>=</span> (Double) parser.parseExpression(<span class=string>"6.0221415E+23"</span>).getValue();</span><br><span class=line><span class=comment>// evals to 2147483647</span></span><br><span class=line><span class=type>int</span> <span class=variable>maxValue</span> <span class=operator>=</span> (Integer) parser.parseExpression(<span class=string>"0x7FFFFFFF"</span>).getValue();</span><br><span class=line><span class=type>boolean</span> <span class=variable>trueValue</span> <span class=operator>=</span> (Boolean) parser.parseExpression(<span class=string>"true"</span>).getValue();</span><br><span class=line><span class=type>Object</span> <span class=variable>nullValue</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"null"</span>).getValue();</span><br></pre></table></figure> <p>数字支持使用负号，指数符号和小数点。默认情况下，使用 Double.parseDouble()解析实数。</p> <h4 id=2-4-3-2、属性、数组、列表、Map和索引器><a class=headerlink href=#2-4-3-2、属性、数组、列表、Map和索引器 title=2.4.3.2、属性、数组、列表、Map和索引器></a>2.4.3.2、属性、数组、列表、Map和索引器</h4><p>使用属性引用进行导航很容易。为此，请使用句点来指示嵌套的属性值。 <code>Inventor</code>类的实例<code>pupin</code>和<code>tesla</code>填充了<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-example-classes rel=noopener target=_blank>示例中使用的类</a>部分中列出的数据。要向下导航并获取特斯拉的出生年份和普平的出生城市，我们使用以下表达式：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>// evals to 1856</span></span><br><span class=line><span class=type>int</span> <span class=variable>year</span> <span class=operator>=</span> (Integer) parser.parseExpression(<span class=string>"Birthdate.Year + 1900"</span>).getValue(context);</span><br><span class=line></span><br><span class=line><span class=type>String</span> <span class=variable>city</span> <span class=operator>=</span> (String) parser.parseExpression(<span class=string>"placeOfBirth.City"</span>).getValue(context);</span><br></pre></table></figure> <p>属性名称的首字母允许不区分大小写。数组和列表的内容通过使用方括号表示法获得，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line><span class=type>EvaluationContext</span> <span class=variable>context</span> <span class=operator>=</span> SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class=line></span><br><span class=line><span class=comment>// Inventions Array</span></span><br><span class=line><span class=comment>// evaluates to "Induction motor"</span></span><br><span class=line><span class=type>String</span> <span class=variable>invention</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"inventions[3]"</span>).getValue(</span><br><span class=line>        context, tesla, String.class);</span><br><span class=line></span><br><span class=line><span class=comment>// Members List</span></span><br><span class=line><span class=comment>// evaluates to "Nikola Tesla"</span></span><br><span class=line><span class=type>String</span> <span class=variable>name</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"Members[0].Name"</span>).getValue(</span><br><span class=line>        context, ieee, String.class);</span><br><span class=line></span><br><span class=line><span class=comment>// List and Array navigation</span></span><br><span class=line><span class=comment>// evaluates to "Wireless communication"</span></span><br><span class=line><span class=type>String</span> <span class=variable>invention</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"Members[0].Inventions[6]"</span>).getValue(</span><br><span class=line>        context, ieee, String.class);</span><br></pre></table></figure> <p>通过在方括号内指定 Literals 键值可以获取 Map 的内容。在下面的示例中，由于<code>Officers</code>Map 的键是字符串，因此我们可以指定字符串 Literals：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=comment>// Officer's Dictionary</span></span><br><span class=line><span class=type>Inventor</span> <span class=variable>pupin</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"Officers['president']"</span>).getValue(</span><br><span class=line>        societyContext, Inventor.class);</span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to "Idvor"</span></span><br><span class=line><span class=type>String</span> <span class=variable>city</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"Officers['president'].PlaceOfBirth.City"</span>).getValue(</span><br><span class=line>        societyContext, String.class);</span><br><span class=line></span><br><span class=line><span class=comment>// setting values</span></span><br><span class=line>parser.parseExpression(<span class=string>"Officers['advisors'][0].PlaceOfBirth.Country"</span>).setValue(</span><br><span class=line>        societyContext, <span class=string>"Croatia"</span>);</span><br></pre></table></figure> <h4 id=2-4-3-3、内联列表><a class=headerlink href=#2-4-3-3、内联列表 title=2.4.3.3、内联列表></a>2.4.3.3、内联列表</h4><p>您可以使用<code>{}</code>表示法直接在表达式中表达列表。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>// evaluates to a Java list containing the four numbers</span></span><br><span class=line><span class=type>List</span> <span class=variable>numbers</span> <span class=operator>=</span> (List) parser.parseExpression(<span class=string>"{1,2,3,4}"</span>).getValue(context);</span><br><span class=line></span><br><span class=line><span class=type>List</span> <span class=variable>listOfLists</span> <span class=operator>=</span> (List) parser.parseExpression(<span class=string>"{{'a','b'},{'x','y'}}"</span>).getValue(context);</span><br></pre></table></figure> <p><code>{}</code>本身表示一个空列表。出于性能原因，如果列表本身完全由固定的 Literals 组成，则会创建一个常量列表来表示表达式(而不是在每次求值时都构建一个新列表)。</p> <h4 id=2-4-3-4、内联Map><a class=headerlink href=#2-4-3-4、内联Map title=2.4.3.4、内联Map></a>2.4.3.4、内联Map</h4><p>您也可以使用<code>{key:value}</code>表示法在表达式中直接表达 Map。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>// evaluates to a Java map containing the two entries</span></span><br><span class=line><span class=type>Map</span> <span class=variable>inventorInfo</span> <span class=operator>=</span> (Map) parser.parseExpression(<span class=string>"{name:'Nikola',dob:'10-July-1856'}"</span>).getValue(context);</span><br><span class=line></span><br><span class=line><span class=type>Map</span> <span class=variable>mapOfMaps</span> <span class=operator>=</span> (Map) parser.parseExpression(<span class=string>"{name:{first:'Nikola',last:'Tesla'},dob:{day:10,month:'July',year:1856}}"</span>).getValue(context);</span><br></pre></table></figure> <p><code>{:}</code>本身就是一张空的 Map。出于性能原因，如果 Map 表本身由固定的 Literals 或其他嵌套的常量结构(列表或 Map 表)组成，则会创建一个常量 Map 表来表示该表达式(而不是在每次求值时都构建一个新的 Map 表)。Map 键的引用是可选的。上面的示例不使用带引号的键。</p> <h4 id=2-4-3-5、阵列构造><a class=headerlink href=#2-4-3-5、阵列构造 title=2.4.3.5、阵列构造></a>2.4.3.5、阵列构造</h4><p>您可以使用熟悉的 Java 语法来构建数组，可以选择提供一个初始化程序以在构造时填充该数组。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>int</span>[] numbers1 = (<span class=type>int</span>[]) parser.parseExpression(<span class=string>"new int[4]"</span>).getValue(context);</span><br><span class=line></span><br><span class=line><span class=comment>// Array with initializer</span></span><br><span class=line><span class=type>int</span>[] numbers2 = (<span class=type>int</span>[]) parser.parseExpression(<span class=string>"new int[]{1,2,3}"</span>).getValue(context);</span><br><span class=line></span><br><span class=line><span class=comment>// Multi dimensional array</span></span><br><span class=line><span class=type>int</span>[][] numbers3 = (<span class=type>int</span>[][]) parser.parseExpression(<span class=string>"new int[4][5]"</span>).getValue(context);</span><br></pre></table></figure> <p>构造多维数组时，当前无法提供初始化程序。</p> <h4 id=2-4-3-6、Methods><a class=headerlink href=#2-4-3-6、Methods title=2.4.3.6、Methods></a>2.4.3.6、Methods</h4><p>您可以使用典型的 Java 编程语法来调用方法。您还可以在 Literals 上调用方法。还支持变量参数。下面的示例演示如何调用方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// string literal, evaluates to "bc"</span></span><br><span class=line><span class=type>String</span> <span class=variable>bc</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"'abc'.substring(1, 3)"</span>).getValue(String.class);</span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to true</span></span><br><span class=line><span class=type>boolean</span> <span class=variable>isMember</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"isMember('Mihajlo Pupin')"</span>).getValue(</span><br><span class=line>        societyContext, Boolean.class);</span><br></pre></table></figure> <h4 id=2-4-3-7、Operators><a class=headerlink href=#2-4-3-7、Operators title=2.4.3.7、Operators></a>2.4.3.7、Operators</h4><p>Spring Expression Language 支持以下几种运算符：</p> <ul><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operators-relational rel=noopener target=_blank>Relational Operators</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operators-logical rel=noopener target=_blank>Logical Operators</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operators-mathematical rel=noopener target=_blank>Mathematical Operators</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-assignment rel=noopener target=_blank>赋值运算符</a></ul> <h5 id=Relational-Operators><a title="Relational Operators" class=headerlink href=#Relational-Operators></a>Relational Operators</h5><p>使用标准运算符表示法支持关系运算符(等于，不等于，小于，小于或等于，大于和大于或等于)。以下清单显示了一些运算符示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment>// evaluates to true</span></span><br><span class=line><span class=type>boolean</span> <span class=variable>trueValue</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"2 == 2"</span>).getValue(Boolean.class);</span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to false</span></span><br><span class=line><span class=type>boolean</span> <span class=variable>falseValue</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"2 < -5.0"</span>).getValue(Boolean.class);</span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to true</span></span><br><span class=line><span class=type>boolean</span> <span class=variable>trueValue</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"'black' < 'block'"</span>).getValue(Boolean.class);</span><br></pre></table></figure> <blockquote><p>与<code>null</code>的大于和小于比较遵循一个简单的规则：<code>null</code>被视为无(不是零)。结果，任何其他值始终大于<code>null</code>(<code>X > null</code>始终为<code>true</code>)，并且其他任何值都不小于零(<code>X < null</code>总是<code>false</code>)。<p>如果您更喜欢数字比较，请避免基于数字的<code>null</code>比较，而反对与零的比较(例如<code>X > 0</code>或<code>X < 0</code>)。</blockquote> <p>除了标准的关系运算符外，SpEL 还支持<code>instanceof</code>和基于正则表达式的<code>matches</code>运算符。以下清单显示了两个示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=comment>// evaluates to false</span></span><br><span class=line><span class=type>boolean</span> <span class=variable>falseValue</span> <span class=operator>=</span> parser.parseExpression(</span><br><span class=line>        <span class=string>"'xyz' instanceof T(Integer)"</span>).getValue(Boolean.class);</span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to true</span></span><br><span class=line><span class=type>boolean</span> <span class=variable>trueValue</span> <span class=operator>=</span> parser.parseExpression(</span><br><span class=line>        <span class=string>"'5.00' matches '^-?\\d+(\\.\\d{2})?$'"</span>).getValue(Boolean.class);</span><br><span class=line></span><br><span class=line><span class=comment>//evaluates to false</span></span><br><span class=line><span class=type>boolean</span> <span class=variable>falseValue</span> <span class=operator>=</span> parser.parseExpression(</span><br><span class=line>        <span class=string>"'5.0067' matches '^-?\\d+(\\.\\d{2})?$'"</span>).getValue(Boolean.class);</span><br></pre></table></figure> <blockquote><p>注意：<p>请注意基本类型，因为它们会立即被包装为包装类型，因此，按预期，<code>1 instanceof T(int)</code>的值为<code>false</code>，而<code>1 instanceof T(Integer)</code>的值为<code>true</code>。</blockquote> <p>每个符号运算符也可以指定为纯字母等效项。这样可以避免使用的符号对于嵌入表达式的文档类型具有特殊含义的问题(例如在 XML 文档中)。等效的 Literals 是：</p> <ul><li><code>lt</code> ( <code><</code> )<li><code>gt</code> ( <code>></code> )<li><code>le</code> ( <code><=</code> )<li><code>ge</code> ( <code>>=</code> )<li><code>eq</code> ( <code>==</code> )<li><code>ne</code> ( <code>!=</code> )<li><code>div</code> ( <code>/</code> )<li><code>mod</code> ( <code>%</code> )<li><code>not</code> ( <code>!</code> ).</ul> <p>所有的文本运算符都不区分大小写。</p> <h5 id=Logical-Operators><a title="Logical Operators" class=headerlink href=#Logical-Operators></a>Logical Operators</h5><p>SpEL 支持以下逻辑运算符：</p> <ul><li><code>and</code><li><code>or</code><li><code>not</code></ul> <p>下面的示例显示如何使用逻辑运算符</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=comment>// -- AND --</span></span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to false</span></span><br><span class=line><span class=type>boolean</span> <span class=variable>falseValue</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"true and false"</span>).getValue(Boolean.class);</span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to true</span></span><br><span class=line><span class=type>String</span> <span class=variable>expression</span> <span class=operator>=</span> <span class=string>"isMember('Nikola Tesla') and isMember('Mihajlo Pupin')"</span>;</span><br><span class=line><span class=type>boolean</span> <span class=variable>trueValue</span> <span class=operator>=</span> parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br><span class=line></span><br><span class=line><span class=comment>// -- OR --</span></span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to true</span></span><br><span class=line><span class=type>boolean</span> <span class=variable>trueValue</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"true or false"</span>).getValue(Boolean.class);</span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to true</span></span><br><span class=line><span class=type>String</span> <span class=variable>expression</span> <span class=operator>=</span> <span class=string>"isMember('Nikola Tesla') or isMember('Albert Einstein')"</span>;</span><br><span class=line><span class=type>boolean</span> <span class=variable>trueValue</span> <span class=operator>=</span> parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br><span class=line></span><br><span class=line><span class=comment>// -- NOT --</span></span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to false</span></span><br><span class=line><span class=type>boolean</span> <span class=variable>falseValue</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"!true"</span>).getValue(Boolean.class);</span><br><span class=line></span><br><span class=line><span class=comment>// -- AND and NOT --</span></span><br><span class=line><span class=type>String</span> <span class=variable>expression</span> <span class=operator>=</span> <span class=string>"isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')"</span>;</span><br><span class=line><span class=type>boolean</span> <span class=variable>falseValue</span> <span class=operator>=</span> parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br></pre></table></figure> <h5 id=Mathematical-Operators><a title="Mathematical Operators" class=headerlink href=#Mathematical-Operators></a>Mathematical Operators</h5><p>您可以在数字和字符串上使用加法运算符。您只能对数字使用减法，乘法和除法运算符。您还可以使用模数(％)和指数幂(^)运算符。强制执行标准运算符优先级。以下示例显示了正在使用的 math 运算符：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=comment>// Addition</span></span><br><span class=line><span class=type>int</span> <span class=variable>two</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"1 + 1"</span>).getValue(Integer.class);  <span class=comment>// 2</span></span><br><span class=line></span><br><span class=line><span class=type>String</span> <span class=variable>testString</span> <span class=operator>=</span> parser.parseExpression(</span><br><span class=line>        <span class=string>"'test' + ' ' + 'string'"</span>).getValue(String.class);  <span class=comment>// 'test string'</span></span><br><span class=line></span><br><span class=line><span class=comment>// Subtraction</span></span><br><span class=line><span class=type>int</span> <span class=variable>four</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"1 - -3"</span>).getValue(Integer.class);  <span class=comment>// 4</span></span><br><span class=line></span><br><span class=line><span class=type>double</span> <span class=variable>d</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"1000.00 - 1e4"</span>).getValue(Double.class);  <span class=comment>// -9000</span></span><br><span class=line></span><br><span class=line><span class=comment>// Multiplication</span></span><br><span class=line><span class=type>int</span> <span class=variable>six</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"-2 * -3"</span>).getValue(Integer.class);  <span class=comment>// 6</span></span><br><span class=line></span><br><span class=line><span class=type>double</span> <span class=variable>twentyFour</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"2.0 * 3e0 * 4"</span>).getValue(Double.class);  <span class=comment>// 24.0</span></span><br><span class=line></span><br><span class=line><span class=comment>// Division</span></span><br><span class=line><span class=type>int</span> <span class=variable>minusTwo</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"6 / -3"</span>).getValue(Integer.class);  <span class=comment>// -2</span></span><br><span class=line></span><br><span class=line><span class=type>double</span> <span class=variable>one</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"8.0 / 4e0 / 2"</span>).getValue(Double.class);  <span class=comment>// 1.0</span></span><br><span class=line></span><br><span class=line><span class=comment>// Modulus</span></span><br><span class=line><span class=type>int</span> <span class=variable>three</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"7 % 4"</span>).getValue(Integer.class);  <span class=comment>// 3</span></span><br><span class=line></span><br><span class=line><span class=type>int</span> <span class=variable>one</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"8 / 5 % 2"</span>).getValue(Integer.class);  <span class=comment>// 1</span></span><br><span class=line></span><br><span class=line><span class=comment>// Operator precedence</span></span><br><span class=line><span class=type>int</span> <span class=variable>minusTwentyOne</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"1+2-3*8"</span>).getValue(Integer.class);  <span class=comment>// -21</span></span><br></pre></table></figure> <h5 id=赋值运算符><a class=headerlink href=#赋值运算符 title=赋值运算符></a>赋值运算符</h5><p>要设置属性，请使用赋值运算符(<code>=</code>)。这通常在对<code>setValue</code>的调用中完成，但也可以在对<code>getValue</code>的调用中完成。下面的清单显示了使用赋值运算符的两种方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>Inventor</span> <span class=variable>inventor</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Inventor</span>();</span><br><span class=line><span class=type>EvaluationContext</span> <span class=variable>context</span> <span class=operator>=</span> SimpleEvaluationContext.forReadWriteDataBinding().build();</span><br><span class=line>parser.parseExpression(<span class=string>"Name"</span>).setValue(context, inventor, <span class=string>"Aleksandar Seovic"</span>);</span><br><span class=line></span><br><span class=line><span class=comment>// alternatively</span></span><br><span class=line><span class=type>String</span> <span class=variable>aleks</span> <span class=operator>=</span> parser.parseExpression(</span><br><span class=line>        <span class=string>"Name = 'Aleksandar Seovic'"</span>).getValue(context, inventor, String.class);</span><br></pre></table></figure> <h4 id=2-4-3-8、Types><a class=headerlink href=#2-4-3-8、Types title=2.4.3.8、Types></a>2.4.3.8、Types</h4><p>您可以使用特殊的<code>T</code>运算符来指定<code>java.lang.Class</code>(类型)的实例。静态方法也可以通过使用此运算符来调用。 <code>StandardEvaluationContext</code>使用<code>TypeLocator</code>查找类型，而<code>StandardTypeLocator</code>(可以替换)是在了解<code>java.lang</code>程序包的情况下构建的。这意味着对<code>java.lang</code>中的类型的<code>T()</code>引用不需要完全限定，但所有其他类型引用都必须是完全限定的。下面的示例演示如何使用<code>T</code>运算符：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>Class</span> <span class=variable>dateClass</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"T(java.util.Date)"</span>).getValue(Class.class);</span><br><span class=line></span><br><span class=line><span class=type>Class</span> <span class=variable>stringClass</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"T(String)"</span>).getValue(Class.class);</span><br><span class=line></span><br><span class=line><span class=type>boolean</span> <span class=variable>trueValue</span> <span class=operator>=</span> parser.parseExpression(</span><br><span class=line>        <span class=string>"T(java.math.RoundingMode).CEILING < T(java.math.RoundingMode).FLOOR"</span>)</span><br><span class=line>        .getValue(Boolean.class);</span><br></pre></table></figure> <h4 id=2-4-3-9、Constructors><a class=headerlink href=#2-4-3-9、Constructors title=2.4.3.9、Constructors></a>2.4.3.9、Constructors</h4><p>您可以使用<code>new</code>运算符来调用构造函数。除了基本类型(<code>int</code>，<code>float</code>等等)和 String 之外，您都应使用完全限定的类名。下面的示例演示如何使用<code>new</code>运算符调用构造函数：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=type>Inventor</span> <span class=variable>einstein</span> <span class=operator>=</span> p.parseExpression(<span class=string>"new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')"</span>).getValue(Inventor.class);</span><br><span class=line></span><br><span class=line><span class=comment>//create new inventor instance within add method of List</span></span><br><span class=line>p.parseExpression(<span class=string>"Members.add(new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German'))"</span>).getValue(societyContext);</span><br></pre></table></figure> <h4 id=2-4-3-10、Variables><a class=headerlink href=#2-4-3-10、Variables title=2.4.3.10、Variables></a>2.4.3.10、Variables</h4><p>您可以使用<code>#variableName</code>语法在表达式中引用变量。通过在<code>EvaluationContext</code>实现上使用<code>setVariable</code>方法来设置变量。以下示例显示了如何使用变量：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>Inventor</span> <span class=variable>tesla</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Inventor</span>(<span class=string>"Nikola Tesla"</span>, <span class=string>"Serbian"</span>);</span><br><span class=line></span><br><span class=line><span class=type>EvaluationContext</span> <span class=variable>context</span> <span class=operator>=</span> SimpleEvaluationContext.forReadWriteDataBinding().build();</span><br><span class=line>context.setVariable(<span class=string>"newName"</span>, <span class=string>"Mike Tesla"</span>);</span><br><span class=line></span><br><span class=line>parser.parseExpression(<span class=string>"Name = #newName"</span>).getValue(context, tesla);</span><br><span class=line>System.out.println(tesla.getName())  <span class=comment>// "Mike Tesla"</span></span><br></pre></table></figure> <h5 id=this-和-root-变量><a title="#this 和#root 变量" class=headerlink href=#this-和-root-变量></a>#this 和#root 变量</h5><p>始终定义<code>#this</code>变量，该变量指向当前评估对象(针对不合格的引用，将对其进行解析)。始终定义<code>#root</code>变量，并引用根上下文对象。尽管<code>#this</code>可能随表达式的组成部分的求值而变化，但<code>#root</code>始终引用根。以下示例显示了如何使用<code>#this</code>和<code>#root</code>变量：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=comment>// create an array of integers</span></span><br><span class=line>List&LTInteger> primes = <span class=keyword>new</span> <span class="title class_">ArrayList</span>&LTInteger>();</span><br><span class=line>primes.addAll(Arrays.asList(<span class=number>2</span>,<span class=number>3</span>,<span class=number>5</span>,<span class=number>7</span>,<span class=number>11</span>,<span class=number>13</span>,<span class=number>17</span>));</span><br><span class=line></span><br><span class=line><span class=comment>// create parser and set variable 'primes' as the array of integers</span></span><br><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line><span class=type>EvaluationContext</span> <span class=variable>context</span> <span class=operator>=</span> SimpleEvaluationContext.forReadOnlyDataAccess();</span><br><span class=line>context.setVariable(<span class=string>"primes"</span>, primes);</span><br><span class=line></span><br><span class=line><span class=comment>// all prime numbers > 10 from the list (using selection ?{...})</span></span><br><span class=line><span class=comment>// evaluates to [11, 13, 17]</span></span><br><span class=line>List&LTInteger> primesGreaterThanTen = (List&LTInteger>) parser.parseExpression(</span><br><span class=line>        <span class=string>"#primes.?[#this>10]"</span>).getValue(context);</span><br></pre></table></figure> <h4 id=2-4-3-11、Functions><a class=headerlink href=#2-4-3-11、Functions title=2.4.3.11、Functions></a>2.4.3.11、Functions</h4><p>您可以通过注册可以在表达式字符串中调用的用户定义函数来扩展 SpEL。该功能通过<code>EvaluationContext</code>注册。下面的示例演示如何注册用户定义的函数：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>Method method = ...;</span><br><span class=line></span><br><span class=line>EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class=line>context.setVariable("myFunction", method);</span><br></pre></table></figure> <p>例如，考虑以下用于反转字符串的 Util 方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">StringUtils</span> {</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> String <span class="title function_">reverseString</span><span class=params>(String input)</span> {</span><br><span class=line>        <span class=type>StringBuilder</span> <span class=variable>backwards</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StringBuilder</span>(input.length());</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < input.length(); i++)</span><br><span class=line>            backwards.append(input.charAt(input.length() - <span class=number>1</span> - i));</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> backwards.toString();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>然后，您可以注册并使用前面的方法，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line></span><br><span class=line><span class=type>EvaluationContext</span> <span class=variable>context</span> <span class=operator>=</span> SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class=line>context.setVariable(<span class=string>"reverseString"</span>,</span><br><span class=line>        StringUtils.class.getDeclaredMethod(<span class=string>"reverseString"</span>, String.class));</span><br><span class=line></span><br><span class=line><span class=type>String</span> <span class=variable>helloWorldReversed</span> <span class=operator>=</span> parser.parseExpression(</span><br><span class=line>        <span class=string>"#reverseString('hello')"</span>).getValue(context, String.class);</span><br></pre></table></figure> <h4 id=2-4-3-12-Bean-参考><a title="2.4.3.12. Bean 参考" class=headerlink href=#2-4-3-12-Bean-参考></a>2.4.3.12. Bean 参考</h4><p>如果评估上下文已使用 bean 解析器配置，则可以使用<code>@</code>符号从表达式中查找 bean。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line><span class=type>StandardEvaluationContext</span> <span class=variable>context</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StandardEvaluationContext</span>();</span><br><span class=line>context.setBeanResolver(<span class=keyword>new</span> <span class="title class_">MyBeanResolver</span>());</span><br><span class=line></span><br><span class=line><span class=comment>// This will end up calling resolve(context,"something") on MyBeanResolver during evaluation</span></span><br><span class=line><span class=type>Object</span> <span class=variable>bean</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"@something"</span>).getValue(context);</span><br></pre></table></figure> <p>要访问工厂 bean 本身，应改为在 Bean 名称前加上<code>&</code>符号。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line><span class=type>StandardEvaluationContext</span> <span class=variable>context</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StandardEvaluationContext</span>();</span><br><span class=line>context.setBeanResolver(<span class=keyword>new</span> <span class="title class_">MyBeanResolver</span>());</span><br><span class=line></span><br><span class=line><span class=comment>// This will end up calling resolve(context,"&foo") on MyBeanResolver during evaluation</span></span><br><span class=line><span class=type>Object</span> <span class=variable>bean</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"&foo"</span>).getValue(context);</span><br></pre></table></figure> <h4 id=2-4-3-13、三元运算符（if-then-else）><a class=headerlink href=#2-4-3-13、三元运算符（if-then-else） title=2.4.3.13、三元运算符（if-then-else）></a>2.4.3.13、三元运算符（if-then-else）</h4><p>您可以使用三元运算符在表达式内部执行 if-then-else 条件逻辑。以下清单显示了一个最小的示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>String</span> <span class=variable>falseString</span> <span class=operator>=</span> parser.parseExpression(</span><br><span class=line>        <span class=string>"false ? 'trueExp' : 'falseExp'"</span>).getValue(String.class);</span><br></pre></table></figure> <p>在这种情况下，布尔值<code>false</code>导致返回字符串值<code>'falseExp'</code>。一个更现实的示例如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>parser.parseExpression(<span class=string>"Name"</span>).setValue(societyContext, <span class=string>"IEEE"</span>);</span><br><span class=line>societyContext.setVariable(<span class=string>"queryName"</span>, <span class=string>"Nikola Tesla"</span>);</span><br><span class=line></span><br><span class=line>expression = <span class=string>"isMember(#queryName)? #queryName + ' is a member of the ' "</span> +</span><br><span class=line>        <span class=string>"+ Name + ' Society' : #queryName + ' is not a member of the ' + Name + ' Society'"</span>;</span><br><span class=line></span><br><span class=line><span class=type>String</span> <span class=variable>queryResultString</span> <span class=operator>=</span> parser.parseExpression(expression)</span><br><span class=line>        .getValue(societyContext, String.class);</span><br><span class=line><span class=comment>// queryResultString = "Nikola Tesla is a member of the IEEE Society"</span></span><br></pre></table></figure> <p>有关三元运算符的更短语法，请参阅关于 Elvis 运算符的下一部分。</p> <h4 id=2-4-3-14、Elvisoperator><a class=headerlink href=#2-4-3-14、Elvisoperator title=2.4.3.14、Elvisoperator></a>2.4.3.14、Elvisoperator</h4><p>Elvis 运算符是三元运算符语法的简化，并且以<a href=http://www.groovy-lang.org/operators.html#_elvis_operator rel=noopener target=_blank>Groovy</a>语言使用。使用三元运算符语法，通常必须将变量重复两次，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>String</span> <span class=variable>name</span> <span class=operator>=</span> <span class=string>"Elvis Presley"</span>;</span><br><span class=line><span class=type>String</span> <span class=variable>displayName</span> <span class=operator>=</span> (name != <span class=literal>null</span> ? name : <span class=string>"Unknown"</span>);</span><br></pre></table></figure> <p>取而代之的是，您可以使用 Elvis 运算符(其命名类似于 Elvis 的发型)。以下示例显示了如何使用 Elvis 运算符：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line></span><br><span class=line><span class=type>String</span> <span class=variable>name</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"name?:'Unknown'"</span>).getValue(String.class);</span><br><span class=line>System.out.println(name);  <span class=comment>// 'Unknown'</span></span><br></pre></table></figure> <p>以下清单显示了一个更复杂的示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line><span class=type>EvaluationContext</span> <span class=variable>context</span> <span class=operator>=</span> SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class=line></span><br><span class=line><span class=type>Inventor</span> <span class=variable>tesla</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Inventor</span>(<span class=string>"Nikola Tesla"</span>, <span class=string>"Serbian"</span>);</span><br><span class=line><span class=type>String</span> <span class=variable>name</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"Name?:'Elvis Presley'"</span>).getValue(context, tesla, String.class);</span><br><span class=line>System.out.println(name);  <span class=comment>// Nikola Tesla</span></span><br><span class=line></span><br><span class=line>tesla.setName(<span class=literal>null</span>);</span><br><span class=line>name = parser.parseExpression(<span class=string>"Name?:'Elvis Presley'"</span>).getValue(context, tesla, String.class);</span><br><span class=line>System.out.println(name);  <span class=comment>// Elvis Presley</span></span><br></pre></table></figure> <blockquote><p>您可以使用 Elvis 运算符在表达式中应用默认值。以下示例显示了如何在<code>@Value</code>表达式中使用 Elvis 运算符：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=meta>@Value("#{systemProperties['pop3.port'] ?: 25}")</span></span><br></pre></table></figure><p>如果定义了系统属性<code>pop3.port</code>，否则将注入 25。</blockquote> <h4 id=2-4-3-15、安全导航操作员><a class=headerlink href=#2-4-3-15、安全导航操作员 title=2.4.3.15、安全导航操作员></a>2.4.3.15、安全导航操作员</h4><p>安全导航操作符用于避免<code>NullPointerException</code>，并且来自<a href=http://www.groovy-lang.org/operators.html#_safe_navigation_operator rel=noopener target=_blank>Groovy</a>语言。通常，当您引用一个对象时，可能需要在访问该对象的方法或属性之前验证其是否为 null。为了避免这种情况，安全导航运算符返回 null 而不是引发异常。下面的示例演示如何使用安全导航操作符：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line><span class=type>EvaluationContext</span> <span class=variable>context</span> <span class=operator>=</span> SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class=line></span><br><span class=line><span class=type>Inventor</span> <span class=variable>tesla</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Inventor</span>(<span class=string>"Nikola Tesla"</span>, <span class=string>"Serbian"</span>);</span><br><span class=line>tesla.setPlaceOfBirth(<span class=keyword>new</span> <span class="title class_">PlaceOfBirth</span>(<span class=string>"Smiljan"</span>));</span><br><span class=line></span><br><span class=line><span class=type>String</span> <span class=variable>city</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"PlaceOfBirth?.City"</span>).getValue(context, tesla, String.class);</span><br><span class=line>System.out.println(city);  <span class=comment>// Smiljan</span></span><br><span class=line></span><br><span class=line>tesla.setPlaceOfBirth(<span class=literal>null</span>);</span><br><span class=line>city = parser.parseExpression(<span class=string>"PlaceOfBirth?.City"</span>).getValue(context, tesla, String.class);</span><br><span class=line>System.out.println(city);  <span class=comment>// null - does not throw NullPointerException!!!</span></span><br></pre></table></figure> <h4 id=2-4-3-16、Collections选择><a class=headerlink href=#2-4-3-16、Collections选择 title=2.4.3.16、Collections选择></a>2.4.3.16、Collections选择</h4><p>选择是一种强大的表达语言功能，可让您通过从源集合中选择条目来将其转换为另一个集合。</p> <p>选择使用<code>.?[selectionExpression]</code>的语法。它过滤集合并返回一个包含原始元素子集的新集合。例如，通过选择，我们可以轻松地获得塞尔维亚发明者的列表，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>List&LTInventor> list = (List&LTInventor>) parser.parseExpression(</span><br><span class=line>        <span class=string>"Members.?[Nationality == 'Serbian']"</span>).getValue(societyContext);</span><br></pre></table></figure> <p>在列表和 Map 上都可以选择。对于列表，将针对每个单独的列表元素评估选择标准。针对 Map，针对每个 Map 条目(Java 类型<code>Map.Entry</code>的对象)评估选择标准。每个 Map 条目都有其键和值，可作为属性进行访问以供选择。</p> <p>以下表达式返回一个新 Map，该 Map 由原始 Map 中条目值小于 27 的那些元素组成：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>Map</span> <span class=variable>newMap</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"map.?[value&LT27]"</span>).getValue();</span><br></pre></table></figure> <p>除了返回所有选定的元素外，您只能检索第一个或最后一个值。要获得与选择匹配的第一个条目，语法为<code>.^[selectionExpression]</code>。要获得最后的匹配选择，语法为<code>.$[selectionExpression]</code>。</p> <h4 id=2-4-3-17、集合投影><a class=headerlink href=#2-4-3-17、集合投影 title=2.4.3.17、集合投影></a>2.4.3.17、集合投影</h4><p>投影使集合可以驱动子表达式的求值，结果是一个新的集合。投影的语法为<code>.![projectionExpression]</code>。例如，假设我们有一个发明家列表，但想要他们出生的城市的列表。实际上，我们希望为发明人列表中的每个条目评估“ placeOfBirth.city”。下面的示例使用投影来做到这一点：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>// returns ['Smiljan', 'Idvor' ]</span></span><br><span class=line><span class=type>List</span> <span class=variable>placesOfBirth</span> <span class=operator>=</span> (List)parser.parseExpression(<span class=string>"Members.![placeOfBirth.city]"</span>);</span><br></pre></table></figure> <p>您还可以使用 Map 来驱动投影，在这种情况下，将根据 Map 中的每个条目(以 Java <code>Map.Entry</code>表示)来评估投影表达式。跨 Map 的投影结果是一个列表，其中包含针对每个 Map 条目的投影表达式的评估。</p> <h4 id=2-4-3-18、表达式模板><a class=headerlink href=#2-4-3-18、表达式模板 title=2.4.3.18、表达式模板></a>2.4.3.18、表达式模板</h4><p>表达式模板允许将 Literals 文本与一个或多个评估块混合。每个评估块均以您可以定义的前缀和后缀字符分隔。常见的选择是使用<code>#{ }</code>作为分隔符，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=type>String</span> <span class=variable>randomPhrase</span> <span class=operator>=</span> parser.parseExpression(</span><br><span class=line>        <span class=string>"random number is #{T(java.lang.Math).random()}"</span>,</span><br><span class=line>        <span class=keyword>new</span> <span class="title class_">TemplateParserContext</span>()).getValue(String.class);</span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to "random number is 0.7038186818312008"</span></span><br></pre></table></figure> <p>通过将 Literals 文本<code>'random number is '</code>与计算<code>#{ }</code>定界符内的表达式的结果(在这种情况下，是调用<code>random()</code>方法的结果)进行连接来评估字符串。 <code>parseExpression()</code>方法的第二个参数的类型为<code>ParserContext</code>。 <code>ParserContext</code>接口用于影响表达式的解析方式，以支持表达式模板功能。 <code>TemplateParserContext</code>的定义如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">TemplateParserContext</span> <span class=keyword>implements</span> <span class="title class_">ParserContext</span> {</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getExpressionPrefix</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"#{"</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getExpressionSuffix</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"}"</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">isTemplate</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h3 id=2-4-4、示例中使用的类><a class=headerlink href=#2-4-4、示例中使用的类 title=2.4.4、示例中使用的类></a>2.4.4、示例中使用的类</h3><p>本节列出了本章示例中使用的类。</p> <p>例子 1. Inventor.java</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> org.spring.samples.spel.inventor;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.util.Date;</span><br><span class=line><span class=keyword>import</span> java.util.GregorianCalendar;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Inventor</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> String nationality;</span><br><span class=line>    <span class=keyword>private</span> String[] inventions;</span><br><span class=line>    <span class=keyword>private</span> Date birthdate;</span><br><span class=line>    <span class=keyword>private</span> PlaceOfBirth placeOfBirth;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Inventor</span><span class=params>(String name, String nationality)</span> {</span><br><span class=line>        GregorianCalendar c= <span class=keyword>new</span> <span class="title class_">GregorianCalendar</span>();</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>        <span class=built_in>this</span>.nationality = nationality;</span><br><span class=line>        <span class=built_in>this</span>.birthdate = c.getTime();</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Inventor</span><span class=params>(String name, Date birthdate, String nationality)</span> {</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>        <span class=built_in>this</span>.nationality = nationality;</span><br><span class=line>        <span class=built_in>this</span>.birthdate = birthdate;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Inventor</span><span class=params>()</span> {</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getName</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> name;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setName</span><span class=params>(String name)</span> {</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getNationality</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> nationality;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setNationality</span><span class=params>(String nationality)</span> {</span><br><span class=line>        <span class=built_in>this</span>.nationality = nationality;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> Date <span class="title function_">getBirthdate</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> birthdate;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setBirthdate</span><span class=params>(Date birthdate)</span> {</span><br><span class=line>        <span class=built_in>this</span>.birthdate = birthdate;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> PlaceOfBirth <span class="title function_">getPlaceOfBirth</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> placeOfBirth;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setPlaceOfBirth</span><span class=params>(PlaceOfBirth placeOfBirth)</span> {</span><br><span class=line>        <span class=built_in>this</span>.placeOfBirth = placeOfBirth;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setInventions</span><span class=params>(String[] inventions)</span> {</span><br><span class=line>        <span class=built_in>this</span>.inventions = inventions;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> String[] getInventions() {</span><br><span class=line>        <span class=keyword>return</span> inventions;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>例子 2. PlaceOfBirth.java</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> org.spring.samples.spel.inventor;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">PlaceOfBirth</span> {</span><br><span class=line>    <span class=keyword>private</span> String city;</span><br><span class=line>    <span class=keyword>private</span> String country;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">PlaceOfBirth</span><span class=params>(String city)</span> {</span><br><span class=line>        <span class=built_in>this</span>.city=city;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">PlaceOfBirth</span><span class=params>(String city, String country)</span> {</span><br><span class=line>        <span class=built_in>this</span>(city);</span><br><span class=line>        <span class=built_in>this</span>.country = country;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getCity</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> city;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setCity</span><span class=params>(String s)</span> {</span><br><span class=line>        <span class=built_in>this</span>.city = s;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getCountry</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> country;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setCountry</span><span class=params>(String country)</span> {</span><br><span class=line>        <span class=built_in>this</span>.country = country;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>例子 3. Society.java</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> org.spring.samples.spel.inventor;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.util.*;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Society</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=type>String</span> <span class=variable>Advisors</span> <span class=operator>=</span> <span class=string>"advisors"</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=type>String</span> <span class=variable>President</span> <span class=operator>=</span> <span class=string>"president"</span>;</span><br><span class=line>    <span class=keyword>private</span> List&LTInventor> members = <span class=keyword>new</span> <span class="title class_">ArrayList</span>&LTInventor>();</span><br><span class=line>    <span class=keyword>private</span> <span class=type>Map</span> <span class=variable>officers</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">HashMap</span>();</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> List <span class="title function_">getMembers</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> members;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> Map <span class="title function_">getOfficers</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> officers;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getName</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> name;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setName</span><span class=params>(String name)</span> {</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">isMember</span><span class=params>(String name)</span> {</span><br><span class=line>        <span class=keyword>for</span> (Inventor inventor : members) {</span><br><span class=line>            <span class=keyword>if</span> (inventor.getName().equals(name)) {</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h2 id=2-5、空安全><a class=headerlink href=#2-5、空安全 title=2.5、空安全></a>2.5、空安全</h2><p>尽管Java不允许您使用其类型系统来表示空安全性，但Spring Framework现在在<code>org.springframework.lang</code>包中提供了以下注释，以使您可以声明API和字段的空性：</p> <ul><li><a href=https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/lang/Nullable.html rel=noopener target=_blank><code>@Nullable</code></a>：表示特定参数，返回值或字段可以为的注释<code>null</code>。<li><a href=https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/lang/NonNull.html rel=noopener target=_blank><code>@NonNull</code></a>：表示不能指定特定参数，返回值或字段的注释<code>null</code>（分别不需要在参数/返回值和字段<code>@NonNullApi</code>以及<code>@NonNullFields</code>应用的字段上）。<li><a href=https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/lang/NonNullApi.html rel=noopener target=_blank><code>@NonNullApi</code></a>：程序包级别的注释，它声明非null为参数和返回值的默认语义。<li><a href=https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/lang/NonNullFields.html rel=noopener target=_blank><code>@NonNullFields</code></a>：程序包级别的注释，它声明非null作为字段的默认语义。</ul> <p>Spring框架本身利用了这些注释，但是它们也可以在任何基于Spring的Java项目中使用，以声明null安全的API和可选的null安全的字段。尚不支持泛型类型参数，varargs和数组元素的可空性，但应在即将发布的版本<a href=https://jira.spring.io/browse/SPR-15942 rel=noopener target=_blank>中将其</a> 支持，有关最新信息，请参见<a href=https://jira.spring.io/browse/SPR-15942 rel=noopener target=_blank>SPR-15942</a>。可空性声明有望在Spring Framework版本之间进行微调，包括次要版本。在方法主体内部使用的类型的可空性超出了此功能的范围。</p> <h3 id=2-5-1、用例><a class=headerlink href=#2-5-1、用例 title=2.5.1、用例></a>2.5.1、用例</h3><p>除了为Spring Framework API可空性提供显式声明外，IDE（例如IDEA或Eclipse）还可以使用这些注释来提供与空安全性相关的有用警告，从而避免<code>NullPointerException</code>在运行时出现警告。</p> <h3 id=2-5-2、JSR-305元注释><a class=headerlink href=#2-5-2、JSR-305元注释 title=2.5.2、JSR-305元注释></a>2.5.2、JSR-305元注释</h3><p>Spring注释使用<a href=https://jcp.org/en/jsr/detail?id=305 rel=noopener target=_blank>JSR 305</a> 注释（休眠但广泛使用的JSR）进行元注释。JSR-305元注释使工具供应商（如IDEA或Kotlin）以通用方式提供了空安全支持，而无需对Spring注释进行硬编码支持。</p> <p>既不需要也不建议向项目类路径中添加JSR-305依赖项以利用Spring空安全API。只有项目，如基于Spring的库，在他们的代码库使用空安全注解应该增加<code>com.google.code.findbugs:jsr305:3.0.2</code> 与<code>compileOnly</code>摇篮配置或Maven<code>provided</code>范围，以避免编译警告。</p> <h2 id=2-6、Appendix><a class=headerlink href=#2-6、Appendix title=2.6、Appendix></a>2.6、Appendix</h2><h3 id=2-6-1、XML模式><a class=headerlink href=#2-6-1、XML模式 title=2.6.1、XML模式></a>2.6.1、XML模式</h3><h4 id=2-6-1-1、实用模式><a class=headerlink href=#2-6-1-1、实用模式 title=2.6.1.1、实用模式></a>2.6.1.1、实用模式</h4><p>顾名思义，<code>util</code>标签处理常见的 Util 配置问题，例如配置集合，引用常量等。要在<code>util</code>模式中使用标签，您需要在 Spring XML 配置文件的顶部具有以下序言(代码段中的文本引用了正确的模式，以便您可以使用<code>util</code>名称空间中的标签)：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:util</span>=<span class=string>"http://www.springframework.org/schema/util"</span> <span class=attr>xsi:schemaLocation</span>=<span class=string>"</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd"</span>></span></span><br><span class=line></span><br><span class=line>        <span class=comment>&LT!-- bean definitions here --></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h5 id=使用util-constant><a class=headerlink href=#使用util-constant title=使用util:constant/></a>使用<a href=util:constant/>util:constant/</a></h5><p>考虑以下 bean 定义：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"..."</span> <span class=attr>class</span>=<span class=string>"..."</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"isolation"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"java.sql.Connection.TRANSACTION_SERIALIZABLE"</span></span></span><br><span class=line><span class=tag> <span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.config.FieldRetrievingFactoryBean"</span> /></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span>l</span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>前面的配置使用 Spring <code>FactoryBean</code>实现(<code>FieldRetrievingFactoryBean</code>)将 Bean 上<code>isolation</code>属性的值设置为<code>java.sql.Connection.TRANSACTION_SERIALIZABLE</code>常量的值。这一切都很好，但是很冗长，并且(不必要地)将 Spring 的内部管道暴露给最终用户。</p> <p>以下基于 XML Schema 的版本更加简洁，清楚地表达了开发人员的意图(“注入此常量值”)，并且读起来更好：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"..."</span> <span class=attr>class</span>=<span class=string>"..."</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"isolation"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>util:constant</span> <span class=attr>static-field</span>=<span class=string>"java.sql.Connection.TRANSACTION_SERIALIZABLE"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <h6 id=根据字段值设置-Bean-属性或构造函数参数><a title="根据字段值设置 Bean 属性或构造函数参数" class=headerlink href=#根据字段值设置-Bean-属性或构造函数参数></a>根据字段值设置 Bean 属性或构造函数参数</h6><p><a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html rel=noopener target=_blank>FieldRetrievingFactoryBean</a>是<code>FactoryBean</code>，它检索<code>static</code>或非静态字段值。它通常用于检索<code>public</code> <code>static</code> <code>final</code>常量，然后可用于为另一个 bean 设置属性值或构造函数参数。</p> <p>下面的示例显示如何通过使用<a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html#setStaticField(java.lang.String) rel=noopener target=_blank>staticField</a>属性来显示<code>static</code>字段：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"myField"</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.config.FieldRetrievingFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"staticField"</span> <span class=attr>lvalue</span>=<span class=string>"java.sql.Connection.TRANSACTION_SERIALIZABLE"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>还有一个便利用法表格，其中将<code>static</code>字段指定为 bean 名称，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"java.sql.Connection.TRANSACTION_SERIALIZABLE"</span></span></span><br><span class=line><span class=tag> <span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.config.FieldRetrievingFactoryBean"</span>/></span></span><br></pre></table></figure> <p>这的确意味着 Bean <code>id</code>不再是任何选择(因此，引用它的其他任何 Bean 也必须使用这个较长的名称)，但是这种形式的定义非常简洁，可以很方便地用作内部对象。 bean，因为不必为 bean 引用指定<code>id</code>，如以l下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"..."</span> <span class=attr>class</span>=<span class=string>"..."</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"isolation"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"java.sql.Connection.TRANSACTION_SERIALIZABLE"</span></span></span><br><span class=line><span class=tag><span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.config.FieldRetrievingFactoryBean"</span> /></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>您还可以访问另一个 bean 的非静态(实例)字段，如<a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html rel=noopener target=_blank>FieldRetrievingFactoryBean</a>类的 API 文档中所述。</p> <p>在 Spring 中，很容易将枚举值作为属性或构造函数参数注入到 bean 中。实际上，您不必做任何事情或不了解 Spring 内部知识(甚至不必了解诸如<code>FieldRetrievingFactoryBean</code>之类的类)。以下示例枚举显示了注入枚举值的难易程度：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> javax.persistence;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>enum</span> <span class="title class_">PersistenceContextType</span> {</span><br><span class=line>    TRANSACTION,</span><br><span class=line>    EXTENDED</span><br><span class=line>}</span><br></pre></table></figure> <p>现在考虑以下类型为<code>PersistenceContextType</code>的 setter 和相应的 bean 定义：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> example;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Client</span> {</span><br><span class=line>    <span class=keyword>private</span> PersistenceContextType persistenceContextType;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setPersistenceContextType</span><span class=params>(PersistenceContextType type)</span> {</span><br><span class=line>        <span class=built_in>this</span>.persistenceContextType = type;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"example.Client"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"persistenceContextType"</span> <span class=attr>value</span>=<span class=string>"TRANSACTION"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <h5 id=使用util-property-path><a class=headerlink href=#使用util-property-path title=使用util:property-path/></a>使用<a href=util:property-path/>util:property-path/</a></h5><p>考虑以下示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- target bean to be referenced by name --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"testBean"</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.TestBean"</span> <span class=attr>scope</span>=<span class=string>"prototype"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"age"</span> <span class=attr>value</span>=<span class=string>"10"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"spouse"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.TestBean"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"age"</span> <span class=attr>value</span>=<span class=string>"11"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=comment>&LT!-- results in 10, which is the value of property 'age' of bean 'testBean' --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"testBean.age"</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.config.PropertyPathFactoryBean"</span>/></span></span><br></pre></table></figure> <p>前面的配置使用 Spring <code>FactoryBean</code>实现(<code>PropertyPathFactoryBean</code>)创建一个名为<code>testBean.age</code>的 Bean(类型<code>int</code>)，该 Bean 的值等于<code>testBean</code> bean 的<code>age</code>属性。</p> <p>现在考虑以下示例，该示例添l加了一个<code>&LTutil:property-path/></code>元素：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- target bean to be referenced by name --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"testBean"</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.TestBean"</span> <span class=attr>scope</span>=<span class=string>"prototype"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"age"</span> <span class=attr>value</span>=<span class=string>"10"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"spouse"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.TestBean"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"age"</span> <span class=attr>value</span>=<span class=string>"11"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=comment>&LT!-- results in 10, which is the value of property 'age' of bean 'testBean' --></span></span><br><span class=line><span class=tag><<span class=name>util:property-path</span> <span class=attr>id</span>=<span class=string>"name"</span> <span class=attr>path</span>=<span class=string>"testBean.age"</span>/></span></span><br></pre></table></figure> <p><code>&LTproperty-path/></code>元素的<code>path</code>属性的值遵循<code>beanName.beanProperty</code>的形式。在这种情况下，它将获取名为<code>testBean</code>的 bean 的l<code>age</code>属性。该<code>age</code>属性的值为<code>10</code>。</p> <h5 id=使用util-properties><a class=headerlink href=#使用util-properties title=使用util:properties/></a>使用<a href=util:properties/>util:properties/</a></h5><p>考虑以下示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- creates a java.util.Properties instance with values loaded from the supplied location --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"jdbcConfiguration"</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.config.PropertiesFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"location"</span> <span class=attr>value</span>=<span class=string>"classpath:com/foo/jdbc-production.properties"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>前面的配置使用 Spring <code>FactoryBean</code>实现(<code>PropertiesFactoryBean</code>)来实例化具有从提供的<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources rel=noopener target=_blank>Resource</a>位置加载的值的<code>java.util.Properties</code>实例)。</p> <p>以下示例使用<code>util:properties</code>元素进行更简洁的表示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- creates a java.util.Properties instance with values loaded from the supplied location --></span></span><br><span class=line><span class=tag><<span class=name>util:properties</span> <span class=attr>id</span>=<span class=string>"jdbcConfiguration"</span> <span class=attr>location</span>=<span class=string>"classpath:clom/foo/jdbc-production.properties"</span>/></span></span><br></pre></table></figure> <h5 id=使用util-list><a class=headerlink href=#使用util-list title=使用util:list/></a>使用<a href=util:list/>util:list/</a></h5><p>考虑以下示例：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>&LT!-- creates a java.util.List instance with values loaded from the supplied 'sourceList' --></span><br><span class=line>&LTbean id="emails" class="org.springframework.beans.factory.config.ListFactoryBean"></span><br><span class=line>    &LTproperty name="sourceList"></span><br><span class=line>        &LTlist></span><br><span class=line>            &LTvalue>[emailprotected]&LT/value></span><br><span class=line>            &LTvalue>[emailprotected]&LT/value></span><br><span class=line>            &LTvalue>[emailprotected]&LT/value></span><br><span class=line>            &LTvalue>[emailprotected]&LT/value></span><br><span class=line>        &LT/list></span><br><span class=line>    &LT/property></span><br><span class=line>&LT/bean></span><br></pre></table></figure> <p>前面的配置使用 Spring <code>FactoryBean</code>实现(<code>ListFactoryBean</code>)创建<code>java.util.List</code>实例，并使用从提供的<code>sourceList</code>中获取的值对其进行初始化。</p> <p>以下示例使用<code>&LTutil:list/></code>元素进行更简洁的表示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- creates a java.util.List instance with the supplied values --></span></span><br><span class=line><span class=tag><<span class=name>util:list</span> <span class=attr>id</span>=<span class=string>"emails"</span>></span>l</span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>util:list</span>></span></span><br></pre></table></figure> <p>您还可以使用<code>&LTutil:list/></code>元素上的<code>list-class</code>属性来显式控制实例化和填充的<code>List</code>的确切类型。例如，如果我们确实需要实例化<code>java.util.LinkedList</code>，则可以使用以下配置：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>util:list</span> <span class=attr>id</span>=<span class=string>"emails"</span> <span class=attr>list-class</span>=<span class=string>"java.util.LinkedList"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>d'[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>util:list</span>></span></span><br></pre></table></figure> <p>如果没有提供<code>list-class</code>属性，则容器选择<code>List</code>实现。</p> <h5 id=使用util-map><a class=headerlink href=#使用util-map title=使用util:map/></a>使用<a href=util:map/>util:map/</a></h5><p>考虑以下示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- creates a java.util.Map instance with values loaded from the supplied 'sourceMap' --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"emails"</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.config.MapFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"sourceMap"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>map</span>></span></span><br><span class=line>            <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"pechorin"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"raskolnikov"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"stavrogin"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"porfiry"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>map</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>前面的配置使用 Spring <code>FactoryBean</code>实现(<code>MapFactoryBean</code>)来创建<code>java.util.Map</code>实例，该实例使用从提供的<code>'sourceMap'</code>中获取的键值对进行初始化。</p> <p>以下示例使用<code>&LTutil:map/></code>元素进行更简洁的表示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- creates a java.util.Map instance with the supplied key-value pairs --></span></span><br><span class=line><span class=tag><<span class=name>util:map</span> <span class=attr>id</span>=<span class=string>"emails"</span>></span>l</span><br><span class=line>    <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"pechorin"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"raskolnikov"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"stavrogin"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"porfiry"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>util:map</span>></span></span><br></pre></table></figure> <p>您还可以使用<code>&LTutil:map/></code>元素上的<code>'map-class'</code>属性来显式控制实例化和填充的<code>Map</code>的确切类型。例如，如果我们确实需要实例化<code>java.util.TreeMap</code>，则可以使用以下配置：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>util:map</span> <span class=attr>id</span>=<span class=string>"emails"</span> <span class=attr>map-class</span>=<span class=string>"java.util.TreeMap"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"pechorin"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"raskolnikov"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"stavrogin"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"porfiry"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>util:map</span>></span></span><br></pre></table></figure> <p>如果没有提供<code>'map-class'</code>属性，则容器选择<code>Map</code>实现。</p> <h5 id=使用util-set><a class=headerlink href=#使用util-set title=使用util:set/></a>使用<a href=util:set/>util:set/</a></h5><p>考虑以下示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- creates a java.util.Set instance with values loaded from the supplied 'sourceSet' --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"emails"</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.config.SetFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"sourceSet"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>set</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>set</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>前面的配置使用 Spring <code>FactoryBean</code>实现(<code>SetFactoryBean</code>)来创建<code>java.util.Set</code>实例，该实例使用从提供的<code>sourceSet</code>中获取的值进行初始化。</p> <p>以下示例使用<code>&LTutil:set/></code>元素进行更简洁的表示：l</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- creates a java.util.Set instance with the supplied values --></span></span><br><span class=line><span class=tag><<span class=name>util:set</span> <span class=attr>id</span>=<span class=string>"emails"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>util:set</span>></span></span><br></pre></table></figure> <p>您还可以使用<code>&LTutil:set/></code>元素上的<code>set-class</code>属性来显式控制实例化和填充的<code>Set</code>的确切类型。例如，如果我们确实需要实例化<code>java.util.TreeSet</code>，则可以使用以下配置：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>util:set</span> <span class=attr>id</span>=<span class=string>"emails"</span> <span class=attr>set-class</span>=<span class=string>"java.util.TreeSet"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span>l</span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>util:set</span>></span></span><br></pre></table></figure> <p>如果没有提供<code>set-class</code>属性，则容器选择<code>Set</code>实现。</p> <h4 id=2-6-1-2、aop模式><a class=headerlink href=#2-6-1-2、aop模式 title=2.6.1.2、aop模式></a>2.6.1.2、aop模式</h4><p>要在<code>aop</code>模式中使用标签，您需要在 Spring XML 配置文件的顶部具有以下前导(代码段中的文本引用了正确的模式，以便<code>aop</code>名称空间中的标签为提供给您)：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:aop</span>=<span class=string>"http://www.springframework.org/schema/aop"</span> <span class=attr>xsi:schemaLocation</span>=<span class=string>"</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- bean definitions here --></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h4 id=2-6-1-3、上下文模式><a class=headerlink href=#2-6-1-3、上下文模式 title=2.6.1.3、上下文模式></a>2.6.1.3、上下文模式</h4><p>以下代码段引用了正确的架构，以便您可以使用<code>context</code>名称空间中的元素：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:context</span>=<span class=string>"http://www.springframework.org/schema/context"</span> <span class=attr>xsi:schemaLocation</span>=<span class=string>"</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- bean definitions here --></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h5 id=使用><a title="使用<property-placeholder/>" class=headerlink href=#使用></a>使用<code>&LTproperty-placeholder/></code></h5><p>此元素激活<code>${…}</code>占位符的替换，这些占位符针对指定的属性文件(作为<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources rel=noopener target=_blank>Spring 资源位置</a>)解析。此元素是为您设置<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-placeholderconfigurer rel=noopener target=_blank>PropertyPlaceholderConfigurer</a>的便捷机制。如果您需要对<code>PropertyPlaceholderConfigurer</code>的更多控制，则可以自己明确定义。</p> <h5 id=使用-1><a title="使用<annotation-config/>" class=headerlink href=#使用-1></a>使用<code>&LTannotation-config/></code></h5><p>此元素激活 Spring 基础结构以检测 Bean 类中的 注解：</p> <ul><li>Spring 的<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-required-annotation rel=noopener target=_blank>@Required</a>和<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-annotation-config rel=noopener target=_blank>@Autowired</a><li>JSR 250 的<code>@PostConstruct</code>，<code>@PreDestroy</code>和<code>@Resource</code>(如果有)<li>JPA 的<code>@PersistenceContext</code>和<code>@PersistenceUnit</code>(如果有)。</ul> <p>或者，您可以选择为这些注解显式激活单独的<code>BeanPostProcessors</code>。</p> <blockquote><p>该元素不会激活对 Spring 的<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-declarative-annotations rel=noopener target=_blank>@Transactional</a>注解 的处理。您可以为此使用<a href=tx:annotation-driven/>tx:annotation-driven/</a>元素。</blockquote> <h5 id=使用-2><a title="使用<component-scan/>" class=headerlink href=#使用-2></a>使用<code>&LTcomponent-scan/></code></h5><p><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-annotation-config rel=noopener target=_blank>基于注解的容器配置</a>中对此元素进行了详细说明。</p> <h5 id=使用-3><a title="使用<load-time-weaver/>" class=headerlink href=#使用-3></a>使用<code>&LTload-time-weaver/></code></h5><p><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw rel=noopener target=_blank>在 Spring Framework 中使用 AspectJ 进行加载时编织</a>中对此元素进行了详细说明。</p> <h5 id=使用-4><a title="使用<spring-configured/>" class=headerlink href=#使用-4></a>使用<code>&LTspring-configured/></code></h5><p><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-atconfigurable rel=noopener target=_blank>使用 AspectJ 通过 Spring 依赖注入域对象</a>中对此元素进行了详细说明。</p> <h5 id=使用-5><a title="使用<mbean-export/>" class=headerlink href=#使用-5></a>使用<code>&LTmbean-export/></code></h5><p><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jmx-context-mbeanexport rel=noopener target=_blank>配置基于注解的 MBean 导出</a>中对此元素进行了详细说明。</p> <h4 id=2-6-1-4、Bean模式><a class=headerlink href=#2-6-1-4、Bean模式 title=2.6.1.4、Bean模式></a>2.6.1.4、Bean模式</h4><p>以下示例在周围的<code>&LTbean/></code>上下文中显示了<code>&LTmeta/></code>元素(请注意，由于没有任何逻辑来解释它，因此元数据实际上是毫无用处的)。</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"foo"</span> <span class=attr>class</span>=<span class=string>"x.y.Foo"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>meta</span> <span class=attr>key</span>=<span class=string>"cacheName"</span> <span class=attr>value</span>=<span class=string>"foo"</span>/></span> (1)</span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"Rick"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h3 id=2-6-2、XML模式创作><a class=headerlink href=#2-6-2、XML模式创作 title=2.6.2、XML模式创作></a>2.6.2、XML模式创作</h3><p>从 2.0 版开始，Spring 提供了一种机制，可以将基于架构的扩展添加到基本 Spring XML 格式中，以定义和配置 bean。</p> <p>为了方便使用架构感知的 XML 编辑器编写配置文件，Spring 的可扩展 XML 配置机制基于 XML Schema。如果您不熟悉标准 Spring 发行版随附的 Spring 当前的 XML 配置扩展，则应首先阅读名为[<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-config rel=noopener target=_blank>xsd-config]</a>的附录。</p> <p>要创建新的 XML 配置扩展，请执行以下操作：</p> <ul><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-custom-schema rel=noopener target=_blank>Author</a> XML 模式，用于描述您的自定义元素。<li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-custom-namespacehandler rel=noopener target=_blank>Code</a>自定义<code>NamespaceHandler</code>实现。<li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-custom-parser rel=noopener target=_blank>Code</a>个或多个<code>BeanDefinitionParser</code>个实现(这是完成实际工作的地方)。<li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-custom-registration rel=noopener target=_blank>Register</a>使用 Spring 的新工件。</ul> <p>对于一个统一的示例，我们创建一个 XML 扩展(一个自定义 XML 元素)，该扩展使我们可以配置<code>SimpleDateFormat</code>类型的对象(来自<code>java.text</code>包)。完成后，我们将能够如下定义<code>SimpleDateFormat</code>类型的 bean 定义：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>&LTmyns:dateformat id="dateFormat"</span><br><span class=line>    pattern="yyyy-MM-dd HH:mm"</span><br><span class=line>    lenient="true"/></span><br></pre></table></figure> <h4 id=2-6-2-1、编写架构><a class=headerlink href=#2-6-2-1、编写架构 title=2.6.2.1、编写架构></a>2.6.2.1、编写架构</h4><p>创建用于 Spring 的 IoC 容器的 XML 配置扩展首先要编写 XML Schema 来描述扩展。对于我们的示例，我们使用以下架构来配置<code>SimpleDateFormat</code>对象：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- myns.xsd (inside package org/springframework/samples/xml) --></span></span><br><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>xsd:schema</span> <span class=attr>xmlns</span>=<span class=string>"http://www.mycompany.com/schema/myns"</span></span></span><br><span class=line><span class=tag>        <span class=attr>xmlns:xsd</span>=<span class=string>"http://www.w3.org/2001/XMLSchema"</span></span></span><br><span class=line><span class=tag>        <span class=attr>xmlns:beans</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>        <span class=attr>targetNamespace</span>=<span class=string>"http://www.mycompany.com/schema/myns"</span></span></span><br><span class=line><span class=tag>        <span class=attr>elementFormDefault</span>=<span class=string>"qualified"</span></span></span><br><span class=line><span class=tag>        <span class=attr>attributeFormDefault</span>=<span class=string>"unqualified"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>xsd:import</span> <span class=attr>namespace</span>=<span class=string>"http://www.springframework.org/schema/beans"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>xsd:element</span> <span class=attr>name</span>=<span class=string>"dateformat"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>xsd:complexType</span>></span></span><br><span class=line>            <span class=tag><<span class=name>xsd:complexContent</span>></span></span><br><span class=line>                <span class=tag><<span class=name>xsd:extension</span> <span class=attr>base</span>=<span class=string>"beans:identifiedType"</span>></span> (1)</span><br><span class=line>                    <span class=tag><<span class=name>xsd:attribute</span> <span class=attr>name</span>=<span class=string>"lenient"</span> <span class=attr>type</span>=<span class=string>"xsd:boolean"</span>/></span></span><br><span class=line>                    <span class=tag><<span class=name>xsd:attribute</span> <span class=attr>name</span>=<span class=string>"pattern"</span> <span class=attr>type</span>=<span class=string>"xsd:string"</span> <span class=attr>use</span>=<span class=string>"required"</span>/></span></span><br><span class=line>                <span class=tag>&LT/<span class=name>xsd:extension</span>></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>xsd:complexContent</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>xsd:complexType</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>xsd:element</span>></span>l</span><br><span class=line><span class=tag>&LT/<span class=name>xsd:schema</span>></span></span><br></pre></table></figure> <ul><li><strong>(1)</strong> 所指示的行包含所有可识别标签的扩展基础(这意味着它们具有<code>id</code>属性，我们可以将其用作容器中的 bean 标识符)。我们可以使用此属性，因为我们导入了 Spring 提供的<code>beans</code>名称空间。</ul> <p>前面的架构使我们可以使用<code>&LTmyns:dateformat/></code>元素直接在 XML 应用程序上下文文件中配置<code>SimpleDateFormat</code>对象，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>myns:dateformat</span> <span class=attr>id</span>=<span class=string>"dateFormat"</span></span></span><br><span class=line><span class=tag>    <span class=attr>pattern</span>=<span class=string>"yyyy-MM-dd HH:mm"</span></span></span><br><span class=line><span class=tag>    <span class=attr>lenient</span>=<span class=string>"true"</span>/></span></span><br></pre></table></figure> <p>请注意，在创建基础结构类之后，上述 XML 片段与以下 XML 片段基本相同：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"dateFormat"</span> <span class=attr>class</span>=<span class=string>"java.text.SimpleDateFormat"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>value</span>=<span class=string>"yyyy-HH-dd HH:mm"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"lenient"</span> <span class=attr>value</span>=<span class=string>"true"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span>l</span><br></pre></table></figure> <p>前面两个片段中的第二个片段在容器中创建了一个 bean(以类型<code>SimpleDateFormat</code>的名称<code>dateFormat</code>标识)，并设置了两个属性。</p> <h4 id=2-6-2-2、编码-NamespaceHandler><a title="2.6.2.2、编码 NamespaceHandler" class=headerlink href=#2-6-2-2、编码-NamespaceHandler></a>2.6.2.2、编码 NamespaceHandler</h4><p>除了模式，我们还需要一个<code>NamespaceHandler</code>来解析 Spring 在解析配置文件时遇到的该特定名称空间的所有元素。对于此示例，<code>NamespaceHandler</code>应该负责<code>myns:dateformat</code>元素的解析。</p> <p><code>NamespaceHandler</code>界面具有三种方法：</p> <ul><li><code>init()</code>：允许<code>NamespaceHandler</code>初始化，并且在使用处理程序之前由 Spring 调用。<li><code>BeanDefinition parse(Element, ParserContext)</code>：当 Spring 遇到顶级元素(未嵌套在 bean 定义或其他命名空间中)时调用。此方法本身可以注册 Bean 定义，返回 Bean 定义或两者。<li><code>BeanDefinitionHolder decorate(Node, BeanDefinitionHolder, ParserContext)</code>：当 Spring 遇到另一个名称空间的属性或嵌套元素时调用。例如，一个或多个 bean 定义的修饰与<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes rel=noopener target=_blank>Spring 支持的范围</a>一起使用。我们首先突出显示一个简单的示例，而不使用装饰，然后在一个更高级的示例中显示装饰。</ul> <p>尽管您可以为整个名称空间编写自己的<code>NamespaceHandler</code>(并因此提供解析名称空间中每个元素的代码)，但是通常情况下，Spring XML 配置文件中的每个顶级 XML 元素都产生一个 bean 定义(例如在我们的示例中，单个<code>&LTmyns:dateformat/></code>元素导致单个<code>SimpleDateFormat</code> bean 定义)。 Spring 提供了许多支持这种情况的便利类。在下面的示例中，我们使用<code>NamespaceHandlerSupport</code>类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> org.springframework.samples.xml;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.xml.NamespaceHandlerSupport;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyNamespaceHandler</span> <span class=keyword>extends</span> <span class="title class_">NamespaceHandlerSupport</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">init</span><span class=params>()</span> {</span><br><span class=line>        registerBeanDefinitionParser(<span class=string>"dateformat"</span>, <span class=keyword>new</span> <span class="title class_">SimpleDateFormatBeanDefinitionParser</span>());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>您可能会注意到，此类中实际上没有很多解析逻辑。的确，<code>NamespaceHandlerSupport</code>类具有内置的委托概念。它支持注册任意数量的<code>BeanDefinitionParser</code>实例，当需要解析其命名空间中的元素时，可以委托该实例注册。这种清晰的关注点分离使<code>NamespaceHandler</code>处理其命名空间中所有自定义元素的解析编排，同时委派<code>BeanDefinitionParsers</code>来完成 XML 解析的繁琐工作。这意味着每个<code>BeanDefinitionParser</code>仅包含解析单个自定义元素的逻辑，正如我们在下一步中看到的那样。</p> <h4 id=2-6-2-3、使用BeanDefinitionParser><a class=headerlink href=#2-6-2-3、使用BeanDefinitionParser title=2.6.2.3、使用BeanDefinitionParser></a>2.6.2.3、使用BeanDefinitionParser</h4><p>如果<code>NamespaceHandler</code>遇到 Map 到特定 bean 定义解析器(在这种情况下为<code>dateformat</code>)的 XML 元素，则使用<code>BeanDefinitionParser</code>。换句话说，<code>BeanDefinitionParser</code>负责解析模式中定义的一个不同的顶级 XML 元素。在解析器中，我们可以访问 XML 元素(因此也可以访问其子元素)，以便我们可以解析自定义 XML 内容，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> org.springframework.samples.xml;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.support.BeanDefinitionBuilder;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;</span><br><span class=line><span class=keyword>import</span> org.springframework.util.StringUtils;</span><br><span class=line><span class=keyword>import</span> org.w3c.dom.Element;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.text.SimpleDateFormat;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleDateFormatBeanDefinitionParser</span> <span class=keyword>extends</span> <span class="title class_">AbstractSingleBeanDefinitionParser</span> { (<span class=number>1</span>)</span><br><span class=line>    <span class=keyword>protected</span> Class <span class="title function_">getBeanClass</span><span class=params>(Element element)</span> {</span><br><span class=line>        <span class=keyword>return</span> SimpleDateFormat.class; (<span class=number>2</span>)</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>void</span> <span class="title function_">doParse</span><span class=params>(Element element, BeanDefinitionBuilder bean)</span> {</span><br><span class=line>        <span class=comment>// this will never be null since the schema explicitly requires that a value be supplied</span></span><br><span class=line>        <span class=type>String</span> <span class=variable>pattern</span> <span class=operator>=</span> element.getAttribute(<span class=string>"pattern"</span>);</span><br><span class=line>        bean.addConstructorArg(pattern);</span><br><span class=line></span><br><span class=line>        <span class=comment>// this however is an optional property</span></span><br><span class=line>        <span class=type>String</span> <span class=variable>lenient</span> <span class=operator>=</span> element.getAttribute(<span class=string>"lenient"</span>);</span><br><span class=line>        <span class=keyword>if</span> (StringUtils.hasText(lenient)) {</span><br><span class=line>            bean.addPropertyValue(<span class=string>"lenient"</span>, Boolean.valueOf(lenient));</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <ul><li><strong>(1)</strong> 我们使用 Spring 提供的<code>AbstractSingleBeanDefinitionParser</code>来处理创建单个<code>BeanDefinition</code>的许多基本工作。<li><strong>(2)</strong> 我们为<code>AbstractSingleBeanDefinitionParser</code>超类提供了我们的单个<code>BeanDefinition</code>表示的类型。</ul> <p>在这种简单的情况下，这就是我们要做的全部。 <code>BeanDefinition</code>的创建由<code>AbstractSingleBeanDefinitionParser</code>超类处理，bean 定义的唯一标识符的提取和设置也是如此。</p> <h4 id=2-6-2-4、注册处理程序和架构><a class=headerlink href=#2-6-2-4、注册处理程序和架构 title=2.6.2.4、注册处理程序和架构></a>2.6.2.4、注册处理程序和架构</h4><p>编码完成。剩下要做的就是让 Spring XML 解析基础结构了解我们的自定义元素。为此，我们在两个特殊用途的属性文件中注册了自定义<code>namespaceHandler</code>和自定义 XSD 文件。这些属性文件都放置在应用程序的<code>META-INF</code>目录中，例如，可以与二进制类一起分发到 JAR 文件中。 Spring XML 解析基础结构通过使用这些特殊的属性文件来自动选择您的新扩展，以下两部分将详细介绍其格式。</p> <h5 id=Writing-META-INF-spring-handlers><a title="Writing META-INF/spring.handlers" class=headerlink href=#Writing-META-INF-spring-handlers></a>Writing META-INF/spring.handlers</h5><p>名为<code>spring.handlers</code>的属性文件包含 XML 模式 URI 到名称空间处理程序类的 Map。对于我们的示例，我们需要编写以下内容：</p> <figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>http\://www.mycompany.com/schema/myns=org.springframework.samples.xml.MyNamespaceHandler</span><br></pre></table></figure> <p>(<code>:</code>字符是 Java 属性格式的有效分隔符，因此 URI 中的<code>:</code>字符需要用反斜杠转义.)</p> <p>键值对的第一部分(键)是与您的自定义名称空间扩展关联的 URI，并且需要与您的自定义 XSD 架构中指定的<code>targetNamespace</code>属性值完全匹配。</p> <h5 id=Writing-‘META-INF-spring-schemas’><a title="Writing ‘META-INF/spring.schemas’" class=headerlink href=#Writing-‘META-INF-spring-schemas’></a>Writing ‘META-INF/spring.schemas’</h5><p>名为<code>spring.schemas</code>的属性文件包含 XML 架构位置(与架构声明一起引用，在使用该架构作为<code>xsi:schemaLocation</code>属性的一部分的 XML 文件中)到 Classpath 资源。需要该文件来防止 Spring 绝对使用默认的<code>EntityResolver</code>，该默认<code>EntityResolver</code>需要 Internet 访问才能检索架构文件。如果您在此属性文件中指定 Map，Spring 将在 Classpath 上搜索架构(在本例中为<code>org.springframework.samples.xml</code>包中的<code>myns.xsd</code>)。以下代码段显示了我们需要为自定义架构添加的行：</p> <figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>http\://www.mycompany.com/schema/myns/myns.xsd=org/springframework/samples/xml/myns.xsd</span><br></pre></table></figure> <p>(请记住，必须对<code>:</code>字符进行转义.)</p> <p>鼓励您在 Classpath 上的<code>NamespaceHandler</code>和<code>BeanDefinitionParser</code>类旁边部署 XSD 文件。</p> <h4 id=2-6-2-5、在-Spring-XML-配置中使用自定义扩展><a title="2.6.2.5、在 Spring XML 配置中使用自定义扩展" class=headerlink href=#2-6-2-5、在-Spring-XML-配置中使用自定义扩展></a>2.6.2.5、在 Spring XML 配置中使用自定义扩展</h4><p>使用您自己实现的定制扩展与使用 Spring 提供的“定制”扩展之一没有什么不同。以下示例在 Spring XML 配置文件中使用前面步骤中开发的自定义<code>&LTdateformat/></code>元素：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:myns</span>=<span class=string>"http://www.mycompany.com/schema/myns"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.mycompany.com/schema/myns http://www.mycompany.com/schema/myns/myns.xsd"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- as a top-level bean --></span></span><br><span class=line>    <span class=tag><<span class=name>myns:dateformat</span> <span class=attr>id</span>=<span class=string>"defaultDateFormat"</span> <span class=attr>pattern</span>=<span class=string>"yyyy-MM-dd HH:mm"</span> <span class=attr>lenient</span>=<span class=string>"true"</span>/></span> (1)</span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"jobDetailTemplate"</span> <span class=attr>abstract</span>=<span class=string>"true"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"dateFormat"</span>></span></span><br><span class=line>            <span class=comment>&LT!-- as an inner bean --></span></span><br><span class=line>            <span class=tag><<span class=name>myns:dateformat</span> <span class=attr>pattern</span>=<span class=string>"HH:mm MM-dd-yyyy"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h4 id=2-6-2-6、更详细的例子><a class=headerlink href=#2-6-2-6、更详细的例子 title=2.6.2.6、更详细的例子></a>2.6.2.6、更详细的例子</h4><h5 id=在自定义元素中嵌套自定义元素><a class=headerlink href=#在自定义元素中嵌套自定义元素 title=在自定义元素中嵌套自定义元素></a>在自定义元素中嵌套自定义元素</h5><p>本节中的示例显示如何编写满足以下配置目标所需的各种工件：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:foo</span>=<span class=string>"http://www.foo.com/schema/component"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.foo.com/schema/component http://www.foo.com/schema/component/component.xsd"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>foo:component</span> <span class=attr>id</span>=<span class=string>"bionic-family"</span> <span class=attr>name</span>=<span class=string>"Bionic-1"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>foo:component</span> <span class=attr>name</span>=<span class=string>"Mother-1"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>foo:component</span> <span class=attr>name</span>=<span class=string>"Karate-1"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>foo:component</span> <span class=attr>name</span>=<span class=string>"Sport-1"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>foo:component</span>></span></span><br><span class=line>        <span class=tag><<span class=name>foo:component</span> <span class=attr>name</span>=<span class=string>"Rock-1"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>foo:component</span>></span></span><br><span class=line></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>前面的配置将自定义扩展相互嵌套。 <code>&LTfoo:component/></code>元素实际配置的类是<code>Component</code>类(在下一个示例中显示)。注意<code>Component</code>类如何不公开<code>components</code>属性的 setter 方法。这使得很难(或几乎不可能)通过使用 setter 注入为<code>Component</code>类配置 bean 定义。以下清单显示了<code>Component</code>类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.foo;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.util.ArrayList;</span><br><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Component</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> List&LTComponent> components = <span class=keyword>new</span> <span class="title class_">ArrayList</span>&LTComponent> ();</span><br><span class=line></span><br><span class=line>    <span class=comment>// mmm, there is no setter method for the 'components'</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">addComponent</span><span class=params>(Component component)</span> {</span><br><span class=line>        <span class=built_in>this</span>.components.add(component);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> List&LTComponent> <span class="title function_">getComponents</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> components;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getName</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> name;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setName</span><span class=params>(String name)</span> {</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>解决此问题的典型方法是创建一个自定义<code>FactoryBean</code>，该自定义<code>FactoryBean</code>公开<code>components</code>属性的 setter 属性。以下清单显示了这样的自定义<code>FactoryBean</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.foo;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ComponentFactoryBean</span> <span class=keyword>implements</span> <span class="title class_">FactoryBean</span>&LTComponent> {</span><br><span class=line>    <span class=keyword>private</span> Component parent;</span><br><span class=line>    <span class=keyword>private</span> List&LTComponent> children;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setParent</span><span class=params>(Component parent)</span> {</span><br><span class=line>        <span class=built_in>this</span>.parent = parent;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setChildren</span><span class=params>(List&LTComponent> children)</span> {</span><br><span class=line>        <span class=built_in>this</span>.children = children;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> Component <span class="title function_">getObject</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>this</span>.children != <span class=literal>null</span> && <span class=built_in>this</span>.children.size() > <span class=number>0</span>) {</span><br><span class=line>            <span class=keyword>for</span> (Component child : children) {</span><br><span class=line>                <span class=built_in>this</span>.parent.addComponent(child);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.parent;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> Class&LTComponent> <span class="title function_">getObjectType</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> Component.class;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">isSingleton</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>这很好用，但是向最终用户暴露了很多 Spring 管道。我们要做的是编写一个自定义 extensions，以隐藏所有此 Spring 管道。如果我们坚持使用<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-custom-introduction rel=noopener target=_blank>前面描述的步骤</a>，那么我们首先创建 XSD 模式以定义自定义标记的结构，如以下清单所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span> standalone=<span class=string>"no"</span>?></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>xsd:schema</span> <span class=attr>xmlns</span>=<span class=string>"http://www.foo.com/schema/component"</span></span></span><br><span class=line><span class=tag>        <span class=attr>xmlns:xsd</span>=<span class=string>"http://www.w3.org/2001/XMLSchema"</span></span></span><br><span class=line><span class=tag>        <span class=attr>targetNamespace</span>=<span class=string>"http://www.foo.com/schema/component"</span></span></span><br><span class=line><span class=tag>        <span class=attr>elementFormDefault</span>=<span class=string>"qualified"</span></span></span><br><span class=line><span class=tag>        <span class=attr>attributeFormDefault</span>=<span class=string>"unqualified"</span>></span></span><br><span class=line>    </span><br><span class=line>    <span class=tag><<span class=name>xsd:element</span> <span class=attr>name</span>=<span class=string>"component"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>xsd:complexType</span>></span></span><br><span class=line>            <span class=tag><<span class=name>xsd:choice</span> <span class=attr>minOccurs</span>=<span class=string>"0"</span> <span class=attr>maxOccurs</span>=<span class=string>"unbounded"</span>></span></span><br><span class=line>                <span class=tag><<span class=name>xsd:element</span> <span class=attr>ref</span>=<span class=string>"component"</span>/></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>xsd:choice</span>></span></span><br><span class=line>            <span class=tag><<span class=name>xsd:attribute</span> <span class=attr>name</span>=<span class=string>"id"</span> <span class=attr>type</span>=<span class=string>"xsd:ID"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>xsd:attribute</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>use</span>=<span class=string>"required"</span> <span class=attr>type</span>=<span class=string>"xsd:string"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>xsd:complexType</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>xsd:element</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>xsd:schema</span>></span></span><br></pre></table></figure> <p>在<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-custom-introduction rel=noopener target=_blank>前面描述的过程</a>之后，我们再创建一个自定义<code>NamespaceHandler</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.foo;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.xml.NamespaceHandlerSupport;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ComponentNamespaceHandler</span> <span class=keyword>extends</span> <span class="title class_">NamespaceHandlerSupport</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">init</span><span class=params>()</span> {</span><br><span class=line>        registerBeanDefinitionParser(<span class=string>"component"</span>, <span class=keyword>new</span> <span class="title class_">ComponentBeanDefinitionParser</span>());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>接下来是自定义<code>BeanDefinitionParser</code>。请记住，我们正在创建<code>BeanDefinition</code>来描述<code>ComponentFactoryBean</code>。以下清单显示了我们的自定义<code>BeanDefinitionParser</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.foo;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.config.BeanDefinition;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.support.AbstractBeanDefinition;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.support.BeanDefinitionBuilder;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.support.ManagedList;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.xml.AbstractBeanDefinitionParser;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.xml.ParserContext;</span><br><span class=line><span class=keyword>import</span> org.springframework.util.xml.DomUtils;</span><br><span class=line><span class=keyword>import</span> org.w3c.dom.Element;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ComponentBeanDefinitionParser</span> <span class=keyword>extends</span> <span class="title class_">AbstractBeanDefinitionParser</span> {</span><br><span class=line>    <span class=keyword>protected</span> AbstractBeanDefinition <span class="title function_">parseInternal</span><span class=params>(Element element, ParserContext parserContext)</span> {</span><br><span class=line>        <span class=keyword>return</span> parseComponentElement(element);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> AbstractBeanDefinition <span class="title function_">parseComponentElement</span><span class=params>(Element element)</span> {</span><br><span class=line>        <span class=type>BeanDefinitionBuilder</span> <span class=variable>factory</span> <span class=operator>=</span> BeanDefinitionBuilder.rootBeanDefinition(ComponentFactoryBean.class);</span><br><span class=line>        factory.addPropertyValue(<span class=string>"parent"</span>, parseComponent(element));</span><br><span class=line></span><br><span class=line>        List&LTElement> childElements = DomUtils.getChildElementsByTagName(element, <span class=string>"component"</span>);</span><br><span class=line>        <span class=keyword>if</span> (childElements != <span class=literal>null</span> && childElements.size() > <span class=number>0</span>) {</span><br><span class=line>            parseChildComponents(childElements, factory);</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=keyword>return</span> factory.getBeanDefinition();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> BeanDefinition <span class="title function_">parseComponent</span><span class=params>(Element element)</span> {</span><br><span class=line>        <span class=type>BeanDefinitionBuilder</span> <span class=variable>component</span> <span class=operator>=</span> BeanDefinitionBuilder.rootBeanDefinition(Component.class);</span><br><span class=line>        component.addPropertyValue(<span class=string>"name"</span>, element.getAttribute(<span class=string>"name"</span>));</span><br><span class=line>        <span class=keyword>return</span> component.getBeanDefinition();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">parseChildComponents</span><span class=params>(List&LTElement> childElements, BeanDefinitionBuilder factory)</span> {</span><br><span class=line>        ManagedList&LTBeanDefinition> children = <span class=keyword>new</span> <span class="title class_">ManagedList</span>&LTBeanDefinition>(childElements.size());</span><br><span class=line>        <span class=keyword>for</span> (Element element : childElements) {</span><br><span class=line>            children.add(parseComponentElement(element));</span><br><span class=line>        }</span><br><span class=line>        factory.addPropertyValue(<span class=string>"children"</span>, children);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>最后，需要通过修改<code>META-INF/spring.handlers</code>和<code>META-INF/spring.schemas</code>文件，将各种工件注册到 Spring XML 基础结构中，如下所示：</p> <figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_"># </span><span class=language-bash><span class=keyword>in</span> <span class=string>'META-INF/spring.handlers'</span></span></span><br><span class=line>http\://www.foo.com/schema/component=com.foo.ComponentNamespaceHandler</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash><span class=keyword>in</span> <span class=string>'META-INF/spring.schemas'</span></span></span><br><span class=line>http\://www.foo.com/schema/component/component.xsd=com/foo/component.xsd</span><br></pre></table></figure> <h5 id=“常规”元素上的自定义属性><a class=headerlink href=#“常规”元素上的自定义属性 title=“常规”元素上的自定义属性></a>“常规”元素上的自定义属性</h5><p>编写自己的自定义解析器和关联的工件并不难。但是，有时这不是正确的选择。考虑一个需要将元数据添加到已经存在的 bean 定义的场景。在这种情况下，您当然不需要编写自己的整个自定义扩展。相反，您只想向现有的 bean 定义元素添加一个附加属性。</p> <p>作为另一个示例，假设您为访问集群<a href=https://jcp.org/en/jsr/detail?id=107 rel=noopener target=_blank>JCache</a>的服务对象(它不知道)定义了一个 bean 定义，并且您想确保在周围的集群中急切启动命名的 JCache 实例。以下清单显示了这样的定义：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"checkingAccountService"</span> <span class=attr>class</span>=<span class=string>"com.foo.DefaultCheckingAccountService"</span></span></span><br><span class=line><span class=tag>        <span class=attr>jcache:cache-name</span>=<span class=string>"checking.account"</span>></span>l</span><br><span class=line>    <span class=comment>&LT!-- other dependencies here... --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>然后，当解析<code>'jcache:cache-name'</code>属性时，我们可以创建另一个<code>BeanDefinition</code>。然后，此<code>BeanDefinition</code>为我们初始化命名的 JCache。我们还可以为<code>'checkingAccountService'</code>修改现有的<code>BeanDefinition</code>，以便它依赖于此新的 JCache 初始化<code>BeanDefinition</code>。以下清单显示了我们的<code>JCacheInitializer</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.foo;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">JCacheInitializer</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">JCacheInitializer</span><span class=params>(String name)</span> {</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">initialize</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// lots of JCache API calls to initialize the named cache...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>现在我们可以进入自定义扩展了。首先，我们需要编写描述自定义属性的 XSD 架构，如下所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span> standalone=<span class=string>"no"</span>?></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>xsd:schema</span> <span class=attr>xmlns</span>=<span class=string>"http://www.foo.com/schema/jcache"</span></span></span><br><span class=line><span class=tag>        <span class=attr>xmlns:xsd</span>=<span class=string>"http://www.w3.org/2001/XMLSchema"</span></span></span><br><span class=line><span class=tag>        <span class=attr>targetNamespace</span>=<span class=string>"http://www.foo.com/schema/jcache"</span></span></span><br><span class=line><span class=tag>        <span class=attr>elementFormDefault</span>=<span class=string>"qualified"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>xsd:attribute</span> <span class=attr>name</span>=<span class=string>"cache-name"</span> <span class=attr>type</span>=<span class=string>"xsd:string"</span>/></span></span><br><span class=line></span><br><span class=line><span class=tag>&LT/<span class=name>xsd:schema</span>></span></span><br></pre></table></figure> <p>接下来，我们需要创建关联的<code>NamespaceHandler</code>，如下所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.foo;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.xml.NamespaceHandlerSupport;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">JCacheNalmespaceHandler</span> <span class=keyword>extends</span> <span class="title class_">NamespaceHandlerSupport</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">init</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>super</span>.registerBeanDefinitionDecoratorForAttribute(<span class=string>"cache-name"</span>,</span><br><span class=line>            <span class=keyword>new</span> <span class="title class_">JCacheInitializingBeanDefinitionDecorator</span>());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>接下来，我们需要创建解析器。请注意，在这种情况下，因为我们要解析 XML 属性，所以我们编写<code>BeanDefinitionDecorator</code>而不是<code>BeanDefinitionParser</code>。以下清单显示了我们的<code>BeanDefinitionDecorator</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.foo;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.config.BeanDefinitionHolder;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.support.AbstractBeanDefinition;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.support.BeanDefinitionBuilder;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.xml.BeanDefinitionDecorator;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.xml.ParserContext;</span><br><span class=line><span class=keyword>import</span> org.w3c.dom.Attr;</span><br><span class=line><span class=keyword>import</span> org.w3c.dom.Node;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.util.ArrayList;</span><br><span class=line><span class=keyword>import</span> java.util.Arrays;</span><br><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">JCacheInitializingBeanDefinitionDecorator</span> <span class=keyword>implements</span> <span class="title class_">BeanDefinitionDecorator</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>final</span> String[] EMPTY_STRING_ARRAY = <span class=keyword>new</span> <span class="title class_">String</span>[<span class=number>0</span>];</span><br><span class=line>    </span><br><span class=line>    <span class=keyword>public</span> BeanDefinitionHolder <span class="title function_">decorate</span><span class=params>(Node source, BeanDefinitionHolder holder, ParserContext ctx)</span> {</span><br><span class=line>        <span class=type>String</span> <span class=variable>initializerBeanName</span> <span class=operator>=</span> registerJCacheInitializer(source, ctx);</span><br><span class=line>        createDependencyOnJCacheInitializer(holder, initializerBeanName);</span><br><span class=line>        <span class=keyword>return</span> holder;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">createDependencyOnJCacheInitializer</span><span class=params>(BeanDefinitionHolder holder,String initializerBeanName)</span> {</span><br><span class=line>        <span class=type>AbstractBeanDefinition</span> <span class=variable>definition</span> <span class=operator>=</span> ((AbstractBeanDefinition) holder.getBeanDefinition());</span><br><span class=line>        String[] dependsOn = definition.getDependsOn();</span><br><span class=line>        <span class=keyword>if</span> (dependsOn == <span class=literal>null</span>) {</span><br><span class=line>            dependsOn = <span class=keyword>new</span> <span class="title class_">String</span>[]{initializerBeanName};</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=type>List</span> <span class=variable>dependencies</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ArrayList</span>(Arrays.asList(dependsOn));</span><br><span class=line>            dependencies.add(initializerBeanName);</span><br><span class=line>            dependsOn = (String[]) dependencies.toArray(EMPTY_STRING_ARRAY);</span><br><span class=line>        }</span><br><span class=line>        definition.setDependsOn(dependsOn);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> String <span class="title function_">registerJCacheInitializer</span><span class=params>(Node source, ParserContext ctx)</span> {</span><br><span class=line>        <span class=type>String</span> <span class=variable>cacheName</span> <span class=operator>=</span> ((Attr) source).getValue();</span><br><span class=line>        <span class=type>String</span> <span class=variable>beanName</span> <span class=operator>=</span> cacheName + <span class=string>"-initializer"</span>;</span><br><span class=line>        <span class=keyword>if</span> (!ctx.getRegistry().containsBeanDefinition(beanName)) {</span><br><span class=line>            <span class=type>BeanDefinitionBuilder</span> <span class=variable>initializer</span> <span class=operator>=</span> BeanDefinitionBuilder.rootBeanDefinition(JCacheInitializer.class);</span><br><span class=line>            initializer.addConstructorArg(cacheName);</span><br><span class=line>            ctx.getRegistry().registerBeanDefinition(beanName, initializer.getBeanDefinition());</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> beanName;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>最后，我们需要通过修改<code>META-INF/spring.handlers</code>和<code>META-INF/spring.schemas</code>文件，在 Spring XML 基础结构中注册各种工件，如下所示：</p> <figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_"># </span><span class=language-bash><span class=keyword>in</span> <span class=string>'META-INF/spring.handlers'</span></span></span><br><span class=line>http\://www.foo.com/schema/jcache=com.foo.JCacheNamespaceHandler</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash><span class=keyword>in</span> <span class=string>'META-INF/spring.schemas'</span></span></span><br><span class=line>http\://www.foo.com/schema/jcache/jcache.xsd=com/foo/jcache.xsd</span><br></pre></table></figure> <footer class=post-footer><div class=post-tags><a href=/tags/Spring/ rel=tag># Spring</a></div><div class=post-nav><div class=post-nav-item><a href=/2024/08/21/SpringMVC/ rel=prev title=Spring系列-SpringMVC> <i class="fa fa-angle-left"></i> Spring系列-SpringMVC </a></div><div class=post-nav-item><a href=/2024/08/21/Spring%E4%BA%8B%E5%8A%A1/ rel=next title=Spring系列-Spring事务> Spring系列-Spring事务 <i class="fa fa-angle-right"></i> </a></div></div></footer> <footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer> <div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div> <div class=sidebar-dimmer></div> <div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div> <noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript> <script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script> <script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script> <script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script> <script src=/js/third-party/search/local-search.js></script> 