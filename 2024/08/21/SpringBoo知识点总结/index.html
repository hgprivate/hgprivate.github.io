<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hshz21.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="0、SpringBoot启动流程SpringBoot启动流程主要分两步，创建SpringApplication对象流程 和 执行其run方法流程。 0.1、创建SpringApplication对象流程 初始化资源加载器，默认为null。 断言判断参数是否不为空。 初始化参数源。（封装参数为LinkedHashSet） 初始化当前应用类型（非Web类型、Servlet类型、Reactive类型）" name=description><meta content=article property=og:type><meta content=SpringBoot系列-SpringBoot基础应用 property=og:title><meta content=https://hshz21.gitee.io/2024/08/21/SpringBoo%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content="0、SpringBoot启动流程SpringBoot启动流程主要分两步，创建SpringApplication对象流程 和 执行其run方法流程。 0.1、创建SpringApplication对象流程 初始化资源加载器，默认为null。 断言判断参数是否不为空。 初始化参数源。（封装参数为LinkedHashSet） 初始化当前应用类型（非Web类型、Servlet类型、Reactive类型）" property=og:description><meta content=zh_CN property=og:locale><meta content=2024-08-21T13:39:14.720Z property=article:published_time><meta content=2023-10-03T13:16:27.627Z property=article:modified_time><meta content=豪哥 property=article:author><meta content=SpringBoot property=article:tag><meta content=SpringBoot基础 property=article:tag><meta content=summary name=twitter:card><link href=https://hshz21.gitee.io/2024/08/21/SpringBoo%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hshz21.gitee.io/2024/08/21/SpringBoo%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","path":"2024/08/21/SpringBoo知识点总结/","title":"SpringBoot系列-SpringBoot基础应用"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>SpringBoot系列-SpringBoot基础应用 | 豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>豪哥博客</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#0%E3%80%81SpringBoot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B><span class=nav-number>1.</span> <span class=nav-text>0、SpringBoot启动流程</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#0-1%E3%80%81%E5%88%9B%E5%BB%BASpringApplication%E5%AF%B9%E8%B1%A1%E6%B5%81%E7%A8%8B><span class=nav-number>1.1.</span> <span class=nav-text>0.1、创建SpringApplication对象流程</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#0-2%E3%80%81%E6%89%A7%E8%A1%8CSpringApplication-run%E6%96%B9%E6%B3%95%E6%B5%81%E7%A8%8B><span class=nav-number>1.2.</span> <span class=nav-text>0.2、执行SpringApplication.run方法流程</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#1%E3%80%81%E4%BD%BF%E7%94%A8Starter><span class=nav-number>2.</span> <span class=nav-text>1、使用Starter</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81%E5%95%A5%E6%98%AFSpring-Boot><span class=nav-number>2.1.</span> <span class=nav-text>1.1、啥是Spring Boot</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-2%E3%80%81System-Requirements><span class=nav-number>2.2.</span> <span class=nav-text>1.2、System Requirements</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-1%E3%80%81Servlet%E5%AE%B9%E5%99%A8><span class=nav-number>2.2.1.</span> <span class=nav-text>1.2.1、Servlet容器</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-3%E3%80%81%E5%AE%89%E8%A3%85Spring-Boot><span class=nav-number>2.3.</span> <span class=nav-text>1.3、安装Spring Boot</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-1%E3%80%81Java%E4%BA%BA%E5%91%98%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E><span class=nav-number>2.3.1.</span> <span class=nav-text>1.3.1、Java人员安装说明</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-1-1%E3%80%81Maven%E5%AE%89%E8%A3%85><span class=nav-number>2.3.1.1.</span> <span class=nav-text>1.3.1.1、Maven安装</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-1-2%E3%80%81%E5%AE%89%E8%A3%85Gradle><span class=nav-number>2.3.1.2.</span> <span class=nav-text>1.3.1.2、安装Gradle</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-2%E3%80%81%E5%AE%89%E8%A3%85Spring-Boot-CLI><span class=nav-number>2.3.2.</span> <span class=nav-text>1.3.2、安装Spring Boot CLI</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-2-1%E3%80%81%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85><span class=nav-number>2.3.2.1.</span> <span class=nav-text>1.3.2.1、手动安装</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-2-2%E3%80%81%E4%BD%BF%E7%94%A8SDKMAN%E5%AE%89%E8%A3%85><span class=nav-number>2.3.2.2.</span> <span class=nav-text>1.3.2.2、使用SDKMAN安装</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-2-3%E3%80%81OSX-Homebrew%E5%AE%89%E8%A3%85><span class=nav-number>2.3.2.3.</span> <span class=nav-text>1.3.2.3、OSX Homebrew安装</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-2-4%E3%80%81MacPorts%E5%AE%89%E8%A3%85><span class=nav-number>2.3.2.4.</span> <span class=nav-text>1.3.2.4、MacPorts安装</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-2-5%E3%80%81%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%8C%E6%88%90><span class=nav-number>2.3.2.5.</span> <span class=nav-text>1.3.2.5、命令行完成</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-2-6%E3%80%81Windows-Scoop%E5%AE%89%E8%A3%85><span class=nav-number>2.3.2.6.</span> <span class=nav-text>1.3.2.6、Windows Scoop安装</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-2-7%E3%80%81%E5%BF%AB%E9%80%9FStarter-Spring-CLI%E7%A4%BA%E4%BE%8B><span class=nav-number>2.3.2.7.</span> <span class=nav-text>1.3.2.7、快速Starter Spring CLI示例</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-3%E3%80%81%E6%97%A9%E6%9C%9F%E7%89%88%E6%9C%AC-Spring-Boot-%E5%8D%87%E7%BA%A7><span class=nav-number>2.3.3.</span> <span class=nav-text>1.3.3、早期版本 Spring Boot 升级</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-4%E3%80%81%E7%AC%AC%E4%B8%80%E4%B8%AASpringBoot%E5%BA%94%E7%94%A8><span class=nav-number>2.4.</span> <span class=nav-text>1.4、第一个SpringBoot应用</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-1%E3%80%81%E5%88%9B%E5%BB%BAPOM><span class=nav-number>2.4.1.</span> <span class=nav-text>1.4.1、创建POM</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-2%E3%80%81%E6%B7%BB%E5%8A%A0Classpath%E4%BE%9D%E8%B5%96%E9%A1%B9><span class=nav-number>2.4.2.</span> <span class=nav-text>1.4.2、添加Classpath依赖项</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-3%E3%80%81%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81><span class=nav-number>2.4.3.</span> <span class=nav-text>1.4.3、编写代码</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-4-3-1%E3%80%81-RestController-%E5%92%8C-RequestMapping-%E6%B3%A8%E8%A7%A3><span class=nav-number>2.4.3.1.</span> <span class=nav-text>1.4.3.1、@RestController 和@RequestMapping 注解</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-4-3-2%E3%80%81-EnableAutoConfiguration-%E6%B3%A8%E8%A7%A3><span class=nav-number>2.4.3.2.</span> <span class=nav-text>1.4.3.2、@EnableAutoConfiguration 注解</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-4-3-3%E3%80%81main%E6%96%B9%E6%B3%95><span class=nav-number>2.4.3.3.</span> <span class=nav-text>1.4.3.3、main方法</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-4%E3%80%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E6%89%A7%E8%A1%8CJar><span class=nav-number>2.4.4.</span> <span class=nav-text>1.4.4、创建一个可执行Jar</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#2%E3%80%81%E4%BD%BF%E7%94%A8Spring-Boot><span class=nav-number>3.</span> <span class=nav-text>2、使用Spring Boot</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#2-1%E3%80%81Build-Systems><span class=nav-number>3.1.</span> <span class=nav-text>2.1、Build Systems</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-1%E3%80%81%E4%BE%9D%E8%B5%96%E6%80%A7Management><span class=nav-number>3.1.1.</span> <span class=nav-text>2.1.1、依赖性Management</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-2%E3%80%81Maven><span class=nav-number>3.1.2.</span> <span class=nav-text>2.1.2、Maven</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-2-1%E3%80%81%E7%BB%A7%E6%89%BFStarter-Parent><span class=nav-number>3.1.2.1.</span> <span class=nav-text>2.1.2.1、继承Starter Parent</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-2-2%E3%80%81%E5%9C%A8%E6%B2%A1%E6%9C%89%E7%88%B6-POM-%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%BF%E7%94%A8-Spring-Boot><span class=nav-number>3.1.2.2.</span> <span class=nav-text>2.1.2.2、在没有父 POM 的情况下使用 Spring Boot</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-1-2-3%E3%80%81%E4%BD%BF%E7%94%A8Spring-Boot-Maven%E6%8F%92%E4%BB%B6><span class=nav-number>3.1.2.3.</span> <span class=nav-text>2.1.2.3、使用Spring Boot Maven插件</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-3%E3%80%81Gradle><span class=nav-number>3.1.3.</span> <span class=nav-text>2.1.3、Gradle</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-4%E3%80%81Ant><span class=nav-number>3.1.4.</span> <span class=nav-text>2.1.4、Ant</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-5%E3%80%81Starters><span class=nav-number>3.1.5.</span> <span class=nav-text>2.1.5、Starters</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-2%E3%80%81%E6%9E%84%E5%BB%BA%E4%BB%A3%E7%A0%81><span class=nav-number>3.2.</span> <span class=nav-text>2.2、构建代码</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-1%E3%80%81%E4%BD%BF%E7%94%A8-default-%E8%BD%AF%E4%BB%B6%E5%8C%85><span class=nav-number>3.2.1.</span> <span class=nav-text>2.2.1、使用 default 软件包</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-2%E3%80%81%E6%9F%A5%E6%89%BE%E4%B8%BB%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB><span class=nav-number>3.2.2.</span> <span class=nav-text>2.2.2、查找主应用程序类</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-3%E3%80%81%E9%85%8D%E7%BD%AE%E7%B1%BB><span class=nav-number>3.3.</span> <span class=nav-text>2.3、配置类</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-1%E3%80%81%E5%AF%BC%E5%85%A5%E5%85%B6%E5%AE%83%E9%85%8D%E7%BD%AE%E7%B1%BB><span class=nav-number>3.3.1.</span> <span class=nav-text>2.3.1、导入其它配置类</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-2%E3%80%81%E5%AF%BC%E5%85%A5XML%E9%85%8D%E7%BD%AE><span class=nav-number>3.3.2.</span> <span class=nav-text>2.3.2、导入XML配置</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-4%E3%80%81Auto-configuration><span class=nav-number>3.4.</span> <span class=nav-text>2.4、Auto-configuration</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-1%E3%80%81%E9%80%90%E6%AD%A5%E5%8F%96%E4%BB%A3%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE><span class=nav-number>3.4.1.</span> <span class=nav-text>2.4.1、逐步取代自动配置</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-2%E3%80%81%E7%A6%81%E7%94%A8%E7%89%B9%E5%AE%9A%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%B1%BB><span class=nav-number>3.4.2.</span> <span class=nav-text>2.4.2、禁用特定的自动配置类</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-5%E3%80%81Spring-Bean%E5%92%8C%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5><span class=nav-number>3.5.</span> <span class=nav-text>2.5、Spring Bean和依赖注入</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-6%E3%80%81%E4%BD%BF%E7%94%A8-SpringBootApplication-Comments><span class=nav-number>3.6.</span> <span class=nav-text>2.6、使用@SpringBootApplication Comments</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-7%E3%80%81%E8%BF%90%E8%A1%8C%E6%82%A8%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F><span class=nav-number>3.7.</span> <span class=nav-text>2.7、运行您的应用程序</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-7-1%E3%80%81%E4%BB%8EIDE%E8%BF%90%E8%A1%8C><span class=nav-number>3.7.1.</span> <span class=nav-text>2.7.1、从IDE运行</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-7-2%E3%80%81%E4%BD%9C%E4%B8%BA%E6%89%93%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C><span class=nav-number>3.7.2.</span> <span class=nav-text>2.7.2、作为打包的应用程序运行</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-7-3%E3%80%81%E4%BD%BF%E7%94%A8Maven%E6%8F%92%E4%BB%B6><span class=nav-number>3.7.3.</span> <span class=nav-text>2.7.3、使用Maven插件</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-7-4%E3%80%81%E4%BD%BF%E7%94%A8Gradle%E6%8F%92%E4%BB%B6><span class=nav-number>3.7.3.1.</span> <span class=nav-text>2.7.4、使用Gradle插件</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-7-5%E3%80%81%E7%83%AD%E6%8F%92%E6%8B%94><span class=nav-number>3.7.4.</span> <span class=nav-text>2.7.5、热插拔</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-8%E3%80%81Developer-Tools><span class=nav-number>3.8.</span> <span class=nav-text>2.8、Developer Tools</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-8-1%E3%80%81%E5%B1%9E%E6%80%A7%E9%BB%98%E8%AE%A4%E5%80%BC><span class=nav-number>3.8.1.</span> <span class=nav-text>2.8.1、属性默认值</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-8-2%E3%80%81%E8%87%AA%E5%8A%A8%E9%87%8D%E5%90%AF><span class=nav-number>3.8.2.</span> <span class=nav-text>2.8.2、自动重启</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-8-2-1%E3%80%81%E8%AE%B0%E5%BD%95%E6%9D%A1%E4%BB%B6%E8%AF%84%E4%BC%B0%E4%B8%AD%E7%9A%84%E6%9B%B4%E6%94%B9><span class=nav-number>3.8.2.1.</span> <span class=nav-text>2.8.2.1、记录条件评估中的更改</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-8-2-2%E3%80%81%E6%8E%92%E9%99%A4%E8%B5%84%E6%BA%90><span class=nav-number>3.8.2.2.</span> <span class=nav-text>2.8.2.2、排除资源</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-8-2-3%E3%80%81%E6%B3%A8%E6%84%8F%E5%85%B6%E5%AE%83%E8%B7%AF%E5%BE%84><span class=nav-number>3.8.2.3.</span> <span class=nav-text>2.8.2.3、注意其它路径</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-8-2-4%E3%80%81%E7%A6%81%E7%94%A8%E9%87%8D%E5%90%AF><span class=nav-number>3.8.2.4.</span> <span class=nav-text>2.8.2.4、禁用重启</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-8-2-5%E3%80%81%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E6%96%87%E4%BB%B6><span class=nav-number>3.8.2.5.</span> <span class=nav-text>2.8.2.5、使用触发文件</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-8-2-6%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E9%87%8D%E5%90%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8><span class=nav-number>3.8.2.6.</span> <span class=nav-text>2.8.2.6、自定义重启类加载器</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-8-2-7%E3%80%81%E5%B7%B2%E7%9F%A5%E9%99%90%E5%88%B6><span class=nav-number>3.8.2.7.</span> <span class=nav-text>2.8.2.7、已知限制</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-8-3%E3%80%81LiveReload><span class=nav-number>3.8.3.</span> <span class=nav-text>2.8.3、LiveReload</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-8-4%E3%80%81%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE><span class=nav-number>3.8.4.</span> <span class=nav-text>2.8.4、全局设置</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-8-5%E3%80%81%E8%BF%9C%E7%A8%8B%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F><span class=nav-number>3.8.5.</span> <span class=nav-text>2.8.5、远程应用程序</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-8-5-1%E3%80%81%E8%BF%90%E8%A1%8C%E8%BF%9C%E7%A8%8BClient%E7%AB%AF%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F><span class=nav-number>3.8.5.1.</span> <span class=nav-text>2.8.5.1、运行远程Client端应用程序</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-8-5-2%E3%80%81%E8%BF%9C%E7%A8%8B%E6%9B%B4%E6%96%B0><span class=nav-number>3.8.5.2.</span> <span class=nav-text>2.8.5.2、远程更新</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-9%E3%80%81%E5%8C%85%E8%A3%85%E6%82%A8%E7%9A%84%E7%94%9F%E4%BA%A7%E7%94%B3%E8%AF%B7><span class=nav-number>3.9.</span> <span class=nav-text>2.9、包装您的生产申请</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#3%E3%80%81Spring-Boot%E5%8A%9F%E8%83%BD><span class=nav-number>4.</span> <span class=nav-text>3、Spring Boot功能</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#3-1%E3%80%81SpringApplication><span class=nav-number>4.1.</span> <span class=nav-text>3.1、SpringApplication</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-1%E3%80%81%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5><span class=nav-number>4.1.1.</span> <span class=nav-text>3.1.1、启动失败</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89banner><span class=nav-number>4.1.2.</span> <span class=nav-text>3.1.2、自定义banner</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-3%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89SpringApplication><span class=nav-number>4.1.3.</span> <span class=nav-text>3.1.3、自定义SpringApplication</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-4%E3%80%81Fluent-Builder-API><span class=nav-number>4.1.4.</span> <span class=nav-text>3.1.4、Fluent Builder API</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-5%E3%80%81%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BA%8B%E4%BB%B6%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8><span class=nav-number>4.1.5.</span> <span class=nav-text>3.1.5、应用程序事件和侦听器</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-6%E3%80%81Web%E7%8E%AF%E5%A2%83><span class=nav-number>4.1.6.</span> <span class=nav-text>3.1.6、Web环境</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-7%E3%80%81%E8%AE%BF%E9%97%AE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%82%E6%95%B0><span class=nav-number>4.1.7.</span> <span class=nav-text>3.1.7、访问应用程序参数</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-8%E3%80%81%E4%BD%BF%E7%94%A8-ApplicationRunner-%E6%88%96-CommandLineRunner><span class=nav-number>4.1.8.</span> <span class=nav-text>3.1.8、使用 ApplicationRunner 或 CommandLineRunner</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-9%E3%80%81%E7%94%B3%E8%AF%B7%E9%80%80%E5%87%BA><span class=nav-number>4.1.9.</span> <span class=nav-text>3.1.9、申请退出</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-10%E3%80%81%E7%AE%A1%E7%90%86%E5%91%98%E5%8A%9F%E8%83%BD><span class=nav-number>4.1.10.</span> <span class=nav-text>3.1.10、管理员功能</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-2%E3%80%81Externalized-Configuration><span class=nav-number>4.2.</span> <span class=nav-text>3.2、Externalized Configuration</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-2-1%E3%80%81%E9%85%8D%E7%BD%AE%E9%9A%8F%E6%9C%BA%E5%80%BC><span class=nav-number>4.2.1.</span> <span class=nav-text>3.2.1、配置随机值</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-2-2%E3%80%81%E8%AE%BF%E9%97%AE%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B1%9E%E6%80%A7><span class=nav-number>4.2.2.</span> <span class=nav-text>3.2.2、访问命令行属性</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-2-3%E3%80%81%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6><span class=nav-number>4.2.3.</span> <span class=nav-text>3.2.3、应用程序属性文件</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-2-4%E3%80%81%E7%89%B9%E5%AE%9A%E4%BA%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%B1%9E%E6%80%A7><span class=nav-number>4.2.4.</span> <span class=nav-text>3.2.4、特定于配置文件的属性</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-2-5%E3%80%81%E5%B1%9E%E6%80%A7%E4%B8%AD%E7%9A%84%E5%8D%A0%E4%BD%8D%E7%AC%A6><span class=nav-number>4.2.5.</span> <span class=nav-text>3.2.5、属性中的占位符</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-2-6%E3%80%81%E5%8A%A0%E5%AF%86%E5%B1%9E%E6%80%A7><span class=nav-number>4.2.6.</span> <span class=nav-text>3.2.6、加密属性</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-2-7%E3%80%81%E4%BD%BF%E7%94%A8YAML%E4%BB%A3%E6%9B%BF%E5%B1%9E%E6%80%A7><span class=nav-number>4.2.7.</span> <span class=nav-text>3.2.7、使用YAML代替属性</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-2-7-1%E3%80%81%E5%8A%A0%E8%BD%BDYAML><span class=nav-number>4.2.7.1.</span> <span class=nav-text>3.2.7.1、加载YAML</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-2-7-2%E3%80%81%E5%9C%A8Spring%E4%B8%AD%E5%B0%86YAML%E5%85%AC%E5%BC%80%E4%B8%BA%E5%B1%9E%E6%80%A7><span class=nav-number>4.2.7.2.</span> <span class=nav-text>3.2.7.2、在Spring中将YAML公开为属性</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-2-7-3%E3%80%81%E5%A4%9A%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6YAML%E6%96%87%E6%A1%A3><span class=nav-number>4.2.7.3.</span> <span class=nav-text>3.2.7.3、多配置文件YAML文档</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-2-7-4%E3%80%81YAML%E7%BC%BA%E7%82%B9><span class=nav-number>4.2.7.4.</span> <span class=nav-text>3.2.7.4、YAML缺点</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-2-8%E3%80%81%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7><span class=nav-number>4.2.8.</span> <span class=nav-text>3.2.8、类型安全的配置属性</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-2-8-1%E3%80%81%E7%AC%AC%E4%B8%89%E6%96%B9%E9%85%8D%E7%BD%AE><span class=nav-number>4.2.8.1.</span> <span class=nav-text>3.2.8.1、第三方配置</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-2-8-2%E3%80%81%E8%BD%BB%E6%9D%BE%E7%BB%91%E5%AE%9A><span class=nav-number>4.2.8.2.</span> <span class=nav-text>3.2.8.2、轻松绑定</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-2-8-3%E3%80%81%E5%90%88%E5%B9%B6%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B><span class=nav-number>4.2.8.3.</span> <span class=nav-text>3.2.8.3、合并复杂类型</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-2-8-4%E3%80%81%E5%B1%9E%E6%80%A7%E8%BD%AC%E6%8D%A2><span class=nav-number>4.2.8.4.</span> <span class=nav-text>3.2.8.4、属性转换</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#Converting-durations><span class=nav-number>4.2.8.4.1.</span> <span class=nav-text>Converting durations</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E8%BD%AC%E6%8D%A2%E6%95%B0%E6%8D%AE%E5%A4%A7%E5%B0%8F><span class=nav-number>4.2.8.4.2.</span> <span class=nav-text>转换数据大小</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#3-2-8-5%E3%80%81-ConfigurationProperties-%E9%AA%8C%E8%AF%81><span class=nav-number>4.2.8.5.</span> <span class=nav-text>3.2.8.5、@ConfigurationProperties 验证</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-2-8-6%E3%80%81-ConfigurationProperties-%E4%B8%8E-Value><span class=nav-number>4.2.8.6.</span> <span class=nav-text>3.2.8.6、@ConfigurationProperties 与@Value</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-3%E3%80%81Profiles><span class=nav-number>4.3.</span> <span class=nav-text>3.3、Profiles</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-3-1%E3%80%81%E6%B7%BB%E5%8A%A0-Active-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6><span class=nav-number>4.3.1.</span> <span class=nav-text>3.3.1、添加 Active 配置文件</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-3-2%E3%80%81%E4%BB%A5%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%E8%AE%BE%E7%BD%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6><span class=nav-number>4.3.2.</span> <span class=nav-text>3.3.2、以编程方式设置配置文件</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-3-3%E3%80%81%E7%89%B9%E5%AE%9A%E4%BA%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6><span class=nav-number>4.3.3.</span> <span class=nav-text>3.3.3、特定于配置文件的配置文件</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-4%E3%80%81Logging><span class=nav-number>4.4.</span> <span class=nav-text>3.4、Logging</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-4-1%E3%80%81%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F><span class=nav-number>4.4.1.</span> <span class=nav-text>3.4.1、日志格式</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-4-2%E3%80%81%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA><span class=nav-number>4.4.2.</span> <span class=nav-text>3.4.2、控制台输出</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-4-2-1%E3%80%81%E9%A2%9C%E8%89%B2%E7%BC%96%E7%A0%81%E7%9A%84%E8%BE%93%E5%87%BA><span class=nav-number>4.4.2.1.</span> <span class=nav-text>3.4.2.1、颜色编码的输出</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-4-3%E3%80%81%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA><span class=nav-number>4.4.3.</span> <span class=nav-text>3.4.3、文件输出</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-4-4%E3%80%81%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB><span class=nav-number>4.4.4.</span> <span class=nav-text>3.4.4、日志级别</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-4-5%E3%80%81%E6%97%A5%E5%BF%97%E7%BB%84><span class=nav-number>4.4.5.</span> <span class=nav-text>3.4.5、日志组</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-4-6%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE><span class=nav-number>4.4.6.</span> <span class=nav-text>3.4.6、自定义日志配置</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-4-7%E3%80%81Logback%E6%89%A9%E5%B1%95><span class=nav-number>4.4.7.</span> <span class=nav-text>3.4.7、Logback扩展</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-4-7-1%E3%80%81%E7%89%B9%E5%AE%9A%E4%BA%8E%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E9%85%8D%E7%BD%AE><span class=nav-number>4.4.7.1.</span> <span class=nav-text>3.4.7.1、特定于配置文件的配置</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-4-7-2%E3%80%81%E7%8E%AF%E5%A2%83%E5%B1%9E%E6%80%A7><span class=nav-number>4.4.7.2.</span> <span class=nav-text>3.4.7.2、环境属性</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-5%E3%80%81JSON><span class=nav-number>4.5.</span> <span class=nav-text>3.5、JSON</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-5-1%E3%80%81Jackson><span class=nav-number>4.5.1.</span> <span class=nav-text>3.5.1、Jackson</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-5-2%E3%80%81Gson><span class=nav-number>4.5.2.</span> <span class=nav-text>3.5.2、Gson</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-5-3%E3%80%81JSON-B><span class=nav-number>4.5.3.</span> <span class=nav-text>3.5.3、JSON-B</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-6%E3%80%81%E5%BC%80%E5%8F%91Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F><span class=nav-number>4.6.</span> <span class=nav-text>3.6、开发Web应用程序</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-6-1%E3%80%81%E2%80%9C-Spring-Web-MVC-%E6%A1%86%E6%9E%B6%E2%80%9D><span class=nav-number>4.6.1.</span> <span class=nav-text>3.6.1、“ Spring Web MVC 框架”</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-1-1%E3%80%81Spring-MVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE><span class=nav-number>4.6.1.1.</span> <span class=nav-text>3.6.1.1、Spring MVC自动配置</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-1-2%E3%80%81HttpMessageConverters><span class=nav-number>4.6.1.2.</span> <span class=nav-text>3.6.1.2、HttpMessageConverters</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-1-3%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89JSON%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8><span class=nav-number>4.6.1.3.</span> <span class=nav-text>3.6.1.3、自定义JSON序列化器和反序列化器</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-1-4%E3%80%81MessageCodesResolver><span class=nav-number>4.6.1.4.</span> <span class=nav-text>3.6.1.4、MessageCodesResolver</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-1-5%E3%80%81%E9%9D%99%E6%80%81%E5%86%85%E5%AE%B9><span class=nav-number>4.6.1.5.</span> <span class=nav-text>3.6.1.5、静态内容</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-1-6%E3%80%81%E6%AC%A2%E8%BF%8E%E9%A1%B5%E9%9D%A2><span class=nav-number>4.6.1.6.</span> <span class=nav-text>3.6.1.6、欢迎页面</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-1-7%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%BE%E6%A0%87><span class=nav-number>4.6.1.7.</span> <span class=nav-text>3.6.1.7、自定义图标</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-1-8%E3%80%81%E8%B7%AF%E5%BE%84%E5%8C%B9%E9%85%8D%E5%92%8C%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86><span class=nav-number>4.6.1.8.</span> <span class=nav-text>3.6.1.8、路径匹配和内容协商</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-1-9%E3%80%81ConfigurableWebBindingInitializer><span class=nav-number>4.6.1.9.</span> <span class=nav-text>3.6.1.9、ConfigurableWebBindingInitializer</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-1-10%E3%80%81%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E><span class=nav-number>4.6.1.10.</span> <span class=nav-text>3.6.1.10、模板引擎</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-1-11%E3%80%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86><span class=nav-number>4.6.1.11.</span> <span class=nav-text>3.6.1.11、错误处理</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2><span class=nav-number>4.6.1.11.1.</span> <span class=nav-text>自定义错误页面</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Map-Spring-MVC-%E4%B9%8B%E5%A4%96%E7%9A%84%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2><span class=nav-number>4.6.1.11.2.</span> <span class=nav-text>Map Spring MVC 之外的错误页面</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-1-12%E3%80%81Spring-HATEOAS><span class=nav-number>4.6.1.12.</span> <span class=nav-text>3.6.1.12、Spring HATEOAS</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-1-13%E3%80%81CORS%E6%94%AF%E6%8C%81><span class=nav-number>4.6.1.13.</span> <span class=nav-text>3.6.1.13、CORS支持</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-6-2%E3%80%81%E2%80%9C-Spring-WebFlux-%E6%A1%86%E6%9E%B6%E2%80%9D><span class=nav-number>4.6.2.</span> <span class=nav-text>3.6.2、“ Spring WebFlux 框架”</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-2-1%E3%80%81Spring-WebFlux-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE><span class=nav-number>4.6.2.1.</span> <span class=nav-text>3.6.2.1、Spring WebFlux 自动配置</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-2-2%E3%80%81%E5%B8%A6%E6%9C%89-HttpMessageReaders-%E5%92%8C-HttpMessageWriters-%E7%9A%84-HTTP-%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8><span class=nav-number>4.6.2.2.</span> <span class=nav-text>3.6.2.2、带有 HttpMessageReaders 和 HttpMessageWriters 的 HTTP 编解码器</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-2-3%E3%80%81%E9%9D%99%E6%80%81%E5%86%85%E5%AE%B9><span class=nav-number>4.6.2.3.</span> <span class=nav-text>3.6.2.3、静态内容</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-2-4%E3%80%81%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E><span class=nav-number>4.6.2.4.</span> <span class=nav-text>3.6.2.4、模板引擎</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-2-5%E3%80%81%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86><span class=nav-number>4.6.2.5.</span> <span class=nav-text>3.6.2.5、错误处理</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF%E9%A1%B5%E9%9D%A2-1><span class=nav-number>4.6.2.5.1.</span> <span class=nav-text>自定义错误页面</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-2-6%E3%80%81%E7%BD%91%E9%A1%B5%E8%BF%87%E6%BB%A4%E5%99%A8><span class=nav-number>4.6.2.6.</span> <span class=nav-text>3.6.2.6、网页过滤器</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-6-3%E3%80%81JAX-RX%E5%92%8CJersey><span class=nav-number>4.6.3.</span> <span class=nav-text>3.6.3、JAX-RX和Jersey</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-6-4%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8%E6%94%AF%E6%8C%81><span class=nav-number>4.6.4.</span> <span class=nav-text>3.6.4、嵌入式Servlet容器支持</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-4-1%E3%80%81Servlet%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8><span class=nav-number>4.6.4.1.</span> <span class=nav-text>3.6.4.1、Servlet，过滤器和侦听器</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%B0%86-Servlet%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8%E6%B3%A8%E5%86%8C%E4%B8%BA-Spring-Bean><span class=nav-number>4.6.4.1.1.</span> <span class=nav-text>将 Servlet，过滤器和侦听器注册为 Spring Bean</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-4-2%E3%80%81Servlet-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%9D%E5%A7%8B%E5%8C%96><span class=nav-number>4.6.4.2.</span> <span class=nav-text>3.6.4.2、Servlet 上下文初始化</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E6%89%AB%E6%8F%8F-Servlet%EF%BC%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8><span class=nav-number>4.6.4.2.1.</span> <span class=nav-text>扫描 Servlet，过滤器和侦听器</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-4-3%E3%80%81ServletWebServerApplicationContext><span class=nav-number>4.6.4.3.</span> <span class=nav-text>3.6.4.3、ServletWebServerApplicationContext</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-4-4%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B5%8C%E5%85%A5%E5%BC%8F-Servlet-%E5%AE%B9%E5%99%A8><span class=nav-number>4.6.4.4.</span> <span class=nav-text>3.6.4.4、自定义嵌入式 Servlet 容器</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#Programmatic-Customization><span class=nav-number>4.6.4.4.1.</span> <span class=nav-text>Programmatic Customization</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%9B%B4%E6%8E%A5%E8%87%AA%E5%AE%9A%E4%B9%89-ConfigurableServletWebServerFactory><span class=nav-number>4.6.4.4.2.</span> <span class=nav-text>直接自定义 ConfigurableServletWebServerFactory</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#3-6-4-5%E3%80%81JSP%E9%99%90%E5%88%B6><span class=nav-number>4.6.4.5.</span> <span class=nav-text>3.6.4.5、JSP限制</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-6-5%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%8F%8D%E5%BA%94%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%94%AF%E6%8C%81><span class=nav-number>4.6.5.</span> <span class=nav-text>3.6.5、嵌入式反应式服务器支持</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-6-6%E3%80%81Reactive-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE><span class=nav-number>4.6.6.</span> <span class=nav-text>3.6.6、Reactive 服务器资源配置</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-7%E3%80%81Security><span class=nav-number>4.7.</span> <span class=nav-text>3.7、Security</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-7-1%E3%80%81MVC%E5%AE%89%E5%85%A8%E6%80%A7><span class=nav-number>4.7.1.</span> <span class=nav-text>3.7.1、MVC安全性</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-7-2%E3%80%81WebFlux-%E5%AE%89%E5%85%A8%E6%80%A7><span class=nav-number>4.7.2.</span> <span class=nav-text>3.7.2、WebFlux 安全性</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-7-3%E3%80%81OAuth2><span class=nav-number>4.7.3.</span> <span class=nav-text>3.7.3、OAuth2</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-7-3-1%E3%80%81Client><span class=nav-number>4.7.3.1.</span> <span class=nav-text>3.7.3.1、Client</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E9%80%9A%E7%94%A8%E6%8F%90%E4%BE%9B%E5%95%86%E7%9A%84-OAuth2-Client-%E7%AB%AF%E6%B3%A8%E5%86%8C><span class=nav-number>4.7.3.1.1.</span> <span class=nav-text>通用提供商的 OAuth2 Client 端注册</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#3-7-3-2%E3%80%81%E8%B5%84%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8><span class=nav-number>4.7.3.2.</span> <span class=nav-text>3.7.3.2、资源服务器</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-7-3-3%E3%80%81%E6%8E%88%E6%9D%83%E6%9C%8D%E5%8A%A1%E5%99%A8><span class=nav-number>4.7.3.3.</span> <span class=nav-text>3.7.3.3、授权服务器</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-7-4%E3%80%81Actuator%E5%AE%89%E5%85%A8%E6%80%A7><span class=nav-number>4.7.4.</span> <span class=nav-text>3.7.4、Actuator安全性</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-7-4-1%E3%80%81%E8%B7%A8%E7%AB%99%E7%82%B9%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0%E4%BF%9D%E6%8A%A4><span class=nav-number>4.7.4.1.</span> <span class=nav-text>3.7.4.1、跨站点请求伪造保护</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-8%E3%80%81%E4%BD%BF%E7%94%A8SQL%E6%95%B0%E6%8D%AE%E5%BA%93><span class=nav-number>4.8.</span> <span class=nav-text>3.8、使用SQL数据库</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-8-1%E3%80%81%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E6%BA%90><span class=nav-number>4.8.1.</span> <span class=nav-text>3.8.1、配置数据源</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-8-1-1%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%AF%E6%8C%81><span class=nav-number>4.8.1.1.</span> <span class=nav-text>3.8.1.1、嵌入式数据库支持</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-8-1-2%E3%80%81%E8%BF%9E%E6%8E%A5%E5%88%B0%E7%94%9F%E4%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93><span class=nav-number>4.8.1.2.</span> <span class=nav-text>3.8.1.2、连接到生产数据库</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-8-1-3%E3%80%81><span class=nav-number>4.8.1.3.</span> <span class=nav-text>3.8.1.3、</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-8-2%E3%80%81%E4%BD%BF%E7%94%A8JdbcTemplate><span class=nav-number>4.8.2.</span> <span class=nav-text>3.8.2、使用JdbcTemplate</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-8-3%E3%80%81JPA%E5%92%8CSpring-Data-JPA><span class=nav-number>4.8.3.</span> <span class=nav-text>3.8.3、JPA和Spring Data JPA</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-8-3-1%E3%80%81%E5%AE%9E%E4%BD%93%E7%B1%BB><span class=nav-number>4.8.3.1.</span> <span class=nav-text>3.8.3.1、实体类</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-8-3-2%E3%80%81Spring-Data-JPA-%E5%AD%98%E5%82%A8%E5%BA%93><span class=nav-number>4.8.3.2.</span> <span class=nav-text>3.8.3.2、Spring Data JPA 存储库</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-8-3-3%E3%80%81%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4JPA%E6%95%B0%E6%8D%AE%E5%BA%93><span class=nav-number>4.8.3.3.</span> <span class=nav-text>3.8.3.3、创建和删除JPA数据库</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-8-3-4%E3%80%81%E5%9C%A8%E8%A7%86%E5%9B%BE%E4%B8%AD%E6%89%93%E5%BC%80EntityManager><span class=nav-number>4.8.3.4.</span> <span class=nav-text>3.8.3.4、在视图中打开EntityManager</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-8-4%E3%80%81Spring-Data-JDBC><span class=nav-number>4.8.4.</span> <span class=nav-text>3.8.4、Spring Data JDBC</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-8-5%E3%80%81%E4%BD%BF%E7%94%A8H2%E7%9A%84Web%E6%8E%A7%E5%88%B6%E5%8F%B0><span class=nav-number>4.8.5.</span> <span class=nav-text>3.8.5、使用H2的Web控制台</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-8-5-1-%E6%9B%B4%E6%94%B9-H2-%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%9A%84%E8%B7%AF%E5%BE%84><span class=nav-number>4.8.5.1.</span> <span class=nav-text>3.8.5.1 更改 H2 控制台的路径</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-8-6%E3%80%81%E4%BD%BF%E7%94%A8jOOQ><span class=nav-number>4.8.6.</span> <span class=nav-text>3.8.6、使用jOOQ</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-8-6-1%E3%80%81%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90><span class=nav-number>4.8.6.1.</span> <span class=nav-text>3.8.6.1、代码生成</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-8-6-2%E3%80%81%E4%BD%BF%E7%94%A8DSLContext><span class=nav-number>4.8.6.2.</span> <span class=nav-text>3.8.6.2、使用DSLContext</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-8-6-3%E3%80%81jOOQ-SQL-%E6%96%B9%E8%A8%80><span class=nav-number>4.8.6.3.</span> <span class=nav-text>3.8.6.3、jOOQ SQL 方言</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-8-6-4%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89jOOQ><span class=nav-number>4.8.6.4.</span> <span class=nav-text>3.8.6.4、自定义jOOQ</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-9%E3%80%81%E4%BD%BF%E7%94%A8NoSQL%E6%8A%80%E6%9C%AF><span class=nav-number>4.9.</span> <span class=nav-text>3.9、使用NoSQL技术</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-9-1%E3%80%81Redis><span class=nav-number>4.9.1.</span> <span class=nav-text>3.9.1、Redis</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-1-1%E3%80%81%E8%BF%9E%E6%8E%A5%E5%88%B0Redis><span class=nav-number>4.9.1.1.</span> <span class=nav-text>3.9.1.1、连接到Redis</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-9-2%E3%80%81MongoDB><span class=nav-number>4.9.2.</span> <span class=nav-text>3.9.2、MongoDB</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-2-1%E3%80%81%E8%BF%9E%E6%8E%A5%E5%88%B0-MongoDB-%E6%95%B0%E6%8D%AE%E5%BA%93><span class=nav-number>4.9.2.1.</span> <span class=nav-text>3.9.2.1、连接到 MongoDB 数据库</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-2-2%E3%80%81MongoTemplate><span class=nav-number>4.9.2.2.</span> <span class=nav-text>3.9.2.2、MongoTemplate</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-2-3%E3%80%81Spring-Data-MongoDB-%E5%AD%98%E5%82%A8%E5%BA%93><span class=nav-number>4.9.2.3.</span> <span class=nav-text>3.9.2.3、Spring Data MongoDB 存储库</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-2-4%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8FMongo><span class=nav-number>4.9.2.4.</span> <span class=nav-text>3.9.2.4、嵌入式Mongo</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-9-3%E3%80%81Neo4j><span class=nav-number>4.9.3.</span> <span class=nav-text>3.9.3、Neo4j</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-3-1%E3%80%81%E8%BF%9E%E6%8E%A5%E5%88%B0-Neo4j-%E6%95%B0%E6%8D%AE%E5%BA%93><span class=nav-number>4.9.3.1.</span> <span class=nav-text>3.9.3.1、连接到 Neo4j 数据库</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-3-2%E3%80%81%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%A8%A1%E5%BC%8F><span class=nav-number>4.9.3.2.</span> <span class=nav-text>3.9.3.2、使用嵌入式模式</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-3-3%E3%80%81Neo4jSession><span class=nav-number>4.9.3.3.</span> <span class=nav-text>3.9.3.3、Neo4jSession</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-3-4%E3%80%81Spring-Data-Neo4j-%E5%AD%98%E5%82%A8%E5%BA%93><span class=nav-number>4.9.3.4.</span> <span class=nav-text>3.9.3.4、Spring Data Neo4j 存储库</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-9-4%E3%80%81Gemfire><span class=nav-number>4.9.4.</span> <span class=nav-text>3.9.4、Gemfire</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-9-5%E3%80%81Solr><span class=nav-number>4.9.5.</span> <span class=nav-text>3.9.5、Solr</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-5-1%E3%80%81%E8%BF%9E%E6%8E%A5%E5%88%B0-Solr><span class=nav-number>4.9.5.1.</span> <span class=nav-text>3.9.5.1、连接到 Solr</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-5-2%E3%80%81Spring-Data-Solr-%E5%AD%98%E5%82%A8%E5%BA%93><span class=nav-number>4.9.5.2.</span> <span class=nav-text>3.9.5.2、Spring Data Solr 存储库</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-9-6%E3%80%81Elasticsearch><span class=nav-number>4.9.6.</span> <span class=nav-text>3.9.6、Elasticsearch</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-6-1%E3%80%81%E9%80%9A%E8%BF%87-REST-Client-%E7%AB%AF%E8%BF%9E%E6%8E%A5%E5%88%B0-Elasticsearch><span class=nav-number>4.9.6.1.</span> <span class=nav-text>3.9.6.1、通过 REST Client 端连接到 Elasticsearch</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-6-2%E3%80%81%E4%BD%BF%E7%94%A8-Jest-%E8%BF%9E%E6%8E%A5%E5%88%B0-Elasticsearch><span class=nav-number>4.9.6.2.</span> <span class=nav-text>3.9.6.2、使用 Jest 连接到 Elasticsearch</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-6-3%E3%80%81%E4%BD%BF%E7%94%A8-Spring-%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E5%88%B0-Elasticsearch><span class=nav-number>4.9.6.3.</span> <span class=nav-text>3.9.6.3、使用 Spring 数据连接到 Elasticsearch</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-6-4%E3%80%81Spring-Data-Elasticsearch-%E5%AD%98%E5%82%A8%E5%BA%93><span class=nav-number>4.9.6.4.</span> <span class=nav-text>3.9.6.4、Spring Data Elasticsearch 存储库</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-9-7%E3%80%81Cassandra><span class=nav-number>4.9.7.</span> <span class=nav-text>3.9.7、Cassandra</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-7-1%E3%80%81%E8%BF%9E%E6%8E%A5%E5%88%B0-Cassandra><span class=nav-number>4.9.7.1.</span> <span class=nav-text>3.9.7.1、连接到 Cassandra</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-7-2%E3%80%81Spring-Data-Cassandra-%E5%AD%98%E5%82%A8%E5%BA%93><span class=nav-number>4.9.7.2.</span> <span class=nav-text>3.9.7.2、Spring Data Cassandra 存储库</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-9-8%E3%80%81Couchbase><span class=nav-number>4.9.8.</span> <span class=nav-text>3.9.8、Couchbase</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-8-1%E3%80%81%E8%BF%9E%E6%8E%A5%E5%88%B0-Couchbase><span class=nav-number>4.9.8.1.</span> <span class=nav-text>3.9.8.1、连接到 Couchbase</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-8-2%E3%80%81Spring-Data-Couchbase-%E5%AD%98%E5%82%A8%E5%BA%93><span class=nav-number>4.9.8.2.</span> <span class=nav-text>3.9.8.2、Spring Data Couchbase 存储库</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-9-9%E3%80%81LDAP><span class=nav-number>4.9.9.</span> <span class=nav-text>3.9.9、LDAP</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-9-1%E3%80%81%E8%BF%9E%E6%8E%A5%E5%88%B0-LDAP-%E6%9C%8D%E5%8A%A1%E5%99%A8><span class=nav-number>4.9.9.1.</span> <span class=nav-text>3.9.9.1、连接到 LDAP 服务器</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-9-2%E3%80%81Spring-Data-LDAP-%E5%AD%98%E5%82%A8%E5%BA%93><span class=nav-number>4.9.9.2.</span> <span class=nav-text>3.9.9.2、Spring Data LDAP 存储库</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-9-3%E3%80%81%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%86%85%E5%AD%98-LDAP-%E6%9C%8D%E5%8A%A1%E5%99%A8><span class=nav-number>4.9.9.3.</span> <span class=nav-text>3.9.9.3、嵌入式内存 LDAP 服务器</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-9-10%E3%80%81InfluxDB><span class=nav-number>4.9.10.</span> <span class=nav-text>3.9.10、InfluxDB</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-9-10-1%E3%80%81%E8%BF%9E%E6%8E%A5%E5%88%B0-InfluxDB><span class=nav-number>4.9.10.1.</span> <span class=nav-text>3.9.10.1、连接到 InfluxDB</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-10%E3%80%81Caching><span class=nav-number>4.10.</span> <span class=nav-text>3.10、Caching</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-10-1%E3%80%81%E6%94%AF%E6%8C%81%E7%9A%84%E7%BC%93%E5%AD%98%E6%8F%90%E4%BE%9B%E7%A8%8B%E5%BA%8F><span class=nav-number>4.10.1.</span> <span class=nav-text>3.10.1、支持的缓存提供程序</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-10-1-1%E3%80%81Generic><span class=nav-number>4.10.1.1.</span> <span class=nav-text>3.10.1.1、Generic</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-10-1-2%E3%80%81JCache-JSR-107><span class=nav-number>4.10.1.2.</span> <span class=nav-text>3.10.1.2、JCache(JSR-107)</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-10-1-3%E3%80%81EhCache-2-x><span class=nav-number>4.10.1.3.</span> <span class=nav-text>3.10.1.3、EhCache 2.x</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-10-1-4%E3%80%81Hazelcast><span class=nav-number>4.10.1.4.</span> <span class=nav-text>3.10.1.4、Hazelcast</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-10-1-5%E3%80%81Infinispan><span class=nav-number>4.10.1.5.</span> <span class=nav-text>3.10.1.5、Infinispan</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-10-1-6%E3%80%81Couchbase><span class=nav-number>4.10.1.6.</span> <span class=nav-text>3.10.1.6、Couchbase</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-10-1-7%E3%80%81Redis><span class=nav-number>4.10.1.7.</span> <span class=nav-text>3.10.1.7、Redis</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-10-1-8%E3%80%81Caffeine><span class=nav-number>4.10.1.8.</span> <span class=nav-text>3.10.1.8、Caffeine</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-10-1-9%E3%80%81Simple><span class=nav-number>4.10.1.9.</span> <span class=nav-text>3.10.1.9、Simple</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-10-1-10%E3%80%81None><span class=nav-number>4.10.1.10.</span> <span class=nav-text>3.10.1.10、None</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-11%E3%80%81Messaging><span class=nav-number>4.11.</span> <span class=nav-text>3.11、Messaging</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-11-1%E3%80%81JMS><span class=nav-number>4.11.1.</span> <span class=nav-text>3.11.1、JMS</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-11-1-1%E3%80%81ActiveMQ-%E6%94%AF%E6%8C%81><span class=nav-number>4.11.1.1.</span> <span class=nav-text>3.11.1.1、ActiveMQ 支持</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-11-1-2%E3%80%81Artemis-%E6%94%AF%E6%8C%81><span class=nav-number>4.11.1.2.</span> <span class=nav-text>3.11.1.2、Artemis 支持</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-11-1-3%E3%80%81%E4%BD%BF%E7%94%A8-JNDI-ConnectionFactory><span class=nav-number>4.11.1.3.</span> <span class=nav-text>3.11.1.3、使用 JNDI ConnectionFactory</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-11-1-4%E3%80%81%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF><span class=nav-number>4.11.1.4.</span> <span class=nav-text>3.11.1.4、发送消息</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-11-1-5%E3%80%81%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF><span class=nav-number>4.11.1.5.</span> <span class=nav-text>3.11.1.5、接收消息</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-11-2%E3%80%81AMQP><span class=nav-number>4.11.2.</span> <span class=nav-text>3.11.2、AMQP</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-11-2-1%E3%80%81RabbitMQ-%E6%94%AF%E6%8C%81><span class=nav-number>4.11.2.1.</span> <span class=nav-text>3.11.2.1、RabbitMQ 支持</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-11-2-2%E3%80%81%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF><span class=nav-number>4.11.2.2.</span> <span class=nav-text>3.11.2.2、发送信息</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-11-2-3%E3%80%81%E6%8E%A5%E6%94%B6%E4%BF%A1%E6%81%AF><span class=nav-number>4.11.2.3.</span> <span class=nav-text>3.11.2.3、接收信息</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-11-3%E3%80%81Apache-Kafka-%E6%94%AF%E6%8C%81><span class=nav-number>4.11.3.</span> <span class=nav-text>3.11.3、Apache Kafka 支持</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-11-3-1%E3%80%81%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF><span class=nav-number>4.11.3.1.</span> <span class=nav-text>3.11.3.1、发送消息</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-11-3-2%E3%80%81%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF><span class=nav-number>4.11.3.2.</span> <span class=nav-text>3.11.3.2、接收消息</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-11-3-3%E3%80%81Kafka%E6%B5%81><span class=nav-number>4.11.3.3.</span> <span class=nav-text>3.11.3.3、Kafka流</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-11-3-4%E3%80%81Kafka-%E7%9A%84%E5%85%B6%E4%BB%96%E5%B1%9E%E6%80%A7><span class=nav-number>4.11.3.4.</span> <span class=nav-text>3.11.3.4、Kafka 的其他属性</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-12%E3%80%81%E4%BD%BF%E7%94%A8-RestTemplate-%E8%B0%83%E7%94%A8-REST-%E6%9C%8D%E5%8A%A1><span class=nav-number>4.12.</span> <span class=nav-text>3.12、使用 RestTemplate 调用 REST 服务</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-12-1%E3%80%81RestTemplate-%E8%87%AA%E5%AE%9A%E4%B9%89><span class=nav-number>4.12.1.</span> <span class=nav-text>3.12.1、RestTemplate 自定义</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-13%E3%80%81%E4%BD%BF%E7%94%A8-WebClient-%E8%B0%83%E7%94%A8-REST-%E6%9C%8D%E5%8A%A1><span class=nav-number>4.13.</span> <span class=nav-text>3.13、使用 WebClient 调用 REST 服务</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-13-1%E3%80%81WebClient-%E8%BF%90%E8%A1%8C%E6%97%B6><span class=nav-number>4.13.1.</span> <span class=nav-text>3.13.1、WebClient 运行时</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-13-2%E3%80%81WebClient-%E8%87%AA%E5%AE%9A%E4%B9%89><span class=nav-number>4.13.2.</span> <span class=nav-text>3.13.2、WebClient 自定义</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-14%E3%80%81Validation><span class=nav-number>4.14.</span> <span class=nav-text>3.14、Validation</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-15%E3%80%81%E5%8F%91%E9%80%81%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6><span class=nav-number>4.15.</span> <span class=nav-text>3.15、发送电子邮件</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-16%E3%80%81-JTA-%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1><span class=nav-number>4.16.</span> <span class=nav-text>3.16、 JTA 的分布式事务</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-16-1%E3%80%81%E4%BD%BF%E7%94%A8-Atomikos-Transaction-manager><span class=nav-number>4.16.1.</span> <span class=nav-text>3.16.1、使用 Atomikos Transaction manager</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-16-2%E3%80%81%E4%BD%BF%E7%94%A8-Bitronix-Transaction-manager><span class=nav-number>4.16.2.</span> <span class=nav-text>3.16.2、使用 Bitronix Transaction manager</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-16-3%E3%80%81%E4%BD%BF%E7%94%A8-Java-EE-%E6%89%98%E7%AE%A1%E4%BA%8B%E5%8A%A1-Management-%E5%99%A8><span class=nav-number>4.16.3.</span> <span class=nav-text>3.16.3、使用 Java EE 托管事务 Management 器</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-16-4%E3%80%81%E6%B7%B7%E5%90%88-XA-%E5%92%8C%E9%9D%9E-XA-JMS-%E8%BF%9E%E6%8E%A5><span class=nav-number>4.16.4.</span> <span class=nav-text>3.16.4、混合 XA 和非 XA JMS 连接</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-16-5%E3%80%81%E6%94%AF%E6%8C%81%E5%A4%87%E7%94%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E4%BA%8B%E5%8A%A1-Management-%E5%99%A8><span class=nav-number>4.16.5.</span> <span class=nav-text>3.16.5、支持备用嵌入式事务 Management 器</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-17%E3%80%81Hazelcast><span class=nav-number>4.17.</span> <span class=nav-text>3.17、Hazelcast</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-18%E3%80%81Quartz-Scheduler><span class=nav-number>4.18.</span> <span class=nav-text>3.18、Quartz Scheduler</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-19%E3%80%81%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%92%8C%E8%AE%A1%E5%88%92><span class=nav-number>4.19.</span> <span class=nav-text>3.19、任务执行和计划</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-20%E3%80%81Spring-%E6%95%B4%E5%90%88><span class=nav-number>4.20.</span> <span class=nav-text>3.20、Spring 整合</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-21%E3%80%81Spring-Session><span class=nav-number>4.21.</span> <span class=nav-text>3.21、Spring Session</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-22%E3%80%81%E9%80%9A%E8%BF%87-JMX-%E8%BF%9B%E8%A1%8C%E7%9B%91%E8%A7%86%E5%92%8C-Management><span class=nav-number>4.22.</span> <span class=nav-text>3.22、通过 JMX 进行监视和 Management</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-23%E3%80%81Testing><span class=nav-number>4.23.</span> <span class=nav-text>3.23、Testing</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-23-1%E3%80%81%E6%B5%8B%E8%AF%95%E8%8C%83%E5%9B%B4%E4%BE%9D%E8%B5%96%E6%80%A7><span class=nav-number>4.23.1.</span> <span class=nav-text>3.23.1、测试范围依赖性</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-23-2%E3%80%81%E6%B5%8B%E8%AF%95-Spring-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F><span class=nav-number>4.23.2.</span> <span class=nav-text>3.23.2、测试 Spring 应用程序</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-23-3%E3%80%81%E6%B5%8B%E8%AF%95-Spring-Boot-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F><span class=nav-number>4.23.3.</span> <span class=nav-text>3.23.3、测试 Spring Boot 应用程序</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-1%E3%80%81%E6%A3%80%E6%B5%8B-Web-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%9E%8B><span class=nav-number>4.23.3.1.</span> <span class=nav-text>3.23.3.1、检测 Web 应用程序类型</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-2%E3%80%81%E6%A3%80%E6%B5%8B%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE><span class=nav-number>4.23.3.2.</span> <span class=nav-text>3.23.3.2、检测测试配置</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-3%E3%80%81%E6%8E%92%E9%99%A4%E6%B5%8B%E8%AF%95%E9%85%8D%E7%BD%AE><span class=nav-number>4.23.3.3.</span> <span class=nav-text>3.23.3.3、排除测试配置</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-4%E3%80%81%E5%9C%A8%E6%A8%A1%E6%8B%9F%E7%8E%AF%E5%A2%83%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95><span class=nav-number>4.23.3.4.</span> <span class=nav-text>3.23.3.4、在模拟环境中进行测试</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-5%E3%80%81%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95><span class=nav-number>4.23.3.5.</span> <span class=nav-text>3.23.3.5、使用正在运行的服务器进行测试</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-6%E3%80%81%E4%BD%BF%E7%94%A8-JMX><span class=nav-number>4.23.3.6.</span> <span class=nav-text>3.23.3.6、使用 JMX</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-7%E3%80%81%E6%A8%A1%E6%8B%9F-bean-%E5%92%8C-Spybean><span class=nav-number>4.23.3.7.</span> <span class=nav-text>3.23.3.7、模拟 bean 和 Spybean</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-8%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%B5%8B%E8%AF%95><span class=nav-number>4.23.3.8.</span> <span class=nav-text>3.23.3.8、自动配置的测试</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-9%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-JSON-%E6%B5%8B%E8%AF%95><span class=nav-number>4.23.3.9.</span> <span class=nav-text>3.23.3.9、自动配置的 JSON 测试</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-10%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-Spring-MVC-%E6%B5%8B%E8%AF%95><span class=nav-number>4.23.3.10.</span> <span class=nav-text>3.23.3.10、自动配置的 Spring MVC 测试</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-11%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-Spring-WebFlux-%E6%B5%8B%E8%AF%95><span class=nav-number>4.23.3.11.</span> <span class=nav-text>3.23.3.11、自动配置的 Spring WebFlux 测试</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-12%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%95%B0%E6%8D%AE-JPA-%E6%B5%8B%E8%AF%95><span class=nav-number>4.23.3.12.</span> <span class=nav-text>3.23.3.12、自动配置的数据 JPA 测试</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-13%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-JDBC-%E6%B5%8B%E8%AF%95><span class=nav-number>4.23.3.13.</span> <span class=nav-text>3.23.3.13、自动配置的 JDBC 测试</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-14%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%95%B0%E6%8D%AE-JDBC-%E6%B5%8B%E8%AF%95><span class=nav-number>4.23.3.14.</span> <span class=nav-text>3.23.3.14、自动配置的数据 JDBC 测试</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-15%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-jOOQ-%E6%B5%8B%E8%AF%95><span class=nav-number>4.23.3.15.</span> <span class=nav-text>3.23.3.15、自动配置的 jOOQ 测试</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-16%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-Data-MongoDB-%E6%B5%8B%E8%AF%95><span class=nav-number>4.23.3.16.</span> <span class=nav-text>3.23.3.16、自动配置的 Data MongoDB 测试</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-17%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%95%B0%E6%8D%AE-Neo4j-%E6%B5%8B%E8%AF%95><span class=nav-number>4.23.3.17.</span> <span class=nav-text>3.23.3.17、自动配置的数据 Neo4j 测试</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-18%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%95%B0%E6%8D%AE-Redis-%E6%B5%8B%E8%AF%95><span class=nav-number>4.23.3.18.</span> <span class=nav-text>3.23.3.18、自动配置的数据 Redis 测试</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-19%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%95%B0%E6%8D%AE-LDAP-%E6%B5%8B%E8%AF%95><span class=nav-number>4.23.3.19.</span> <span class=nav-text>3.23.3.19、自动配置的数据 LDAP 测试</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-20%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-REST-Client-%E7%AB%AF><span class=nav-number>4.23.3.20.</span> <span class=nav-text>3.23.3.20、自动配置的 REST Client 端</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-21%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-Spring-REST-%E6%96%87%E6%A1%A3%E6%B5%8B%E8%AF%95><span class=nav-number>4.23.3.21.</span> <span class=nav-text>3.23.3.21、自动配置的 Spring REST 文档测试</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%BF%E7%94%A8-Mock-MVC-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-Spring-REST-Docs-%E6%B5%8B%E8%AF%95><span class=nav-number>4.23.3.21.1.</span> <span class=nav-text>使用 Mock MVC 自动配置的 Spring REST Docs 测试</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E5%85%B7%E6%9C%89-REST-%E4%BF%9D%E8%AF%81%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-Spring-REST-%E6%96%87%E6%A1%A3%E6%B5%8B%E8%AF%95><span class=nav-number>4.23.3.21.2.</span> <span class=nav-text>具有 REST 保证的自动配置的 Spring REST 文档测试</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-22%E3%80%81%E5%85%B6%E4%BB%96%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%92%8C%E5%88%87%E7%89%87><span class=nav-number>4.23.3.22.</span> <span class=nav-text>3.23.3.22、其他自动配置和切片</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-23%E3%80%81%E7%94%A8%E6%88%B7%E9%85%8D%E7%BD%AE%E5%92%8C%E5%88%87%E7%89%87><span class=nav-number>4.23.3.23.</span> <span class=nav-text>3.23.3.23、用户配置和切片</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-3-24%E3%80%81%E4%BD%BF%E7%94%A8-Spock-%E6%B5%8B%E8%AF%95-Spring-Boot-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F><span class=nav-number>4.23.3.24.</span> <span class=nav-text>3.23.3.24、使用 Spock 测试 Spring Boot 应用程序</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-23-4%E3%80%81%E6%B5%8B%E8%AF%95-Util><span class=nav-number>4.23.4.</span> <span class=nav-text>3.23.4、测试 Util</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-4-1%E3%80%81ConfigFileApplicationContextInitializer><span class=nav-number>4.23.4.1.</span> <span class=nav-text>3.23.4.1、ConfigFileApplicationContextInitializer</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-4-2%E3%80%81TestPropertyValues><span class=nav-number>4.23.4.2.</span> <span class=nav-text>3.23.4.2、TestPropertyValues</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-4-3%E3%80%81OutputCapture><span class=nav-number>4.23.4.3.</span> <span class=nav-text>3.23.4.3、OutputCapture</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-23-4-4%E3%80%81TestRestTemplate><span class=nav-number>4.23.4.4.</span> <span class=nav-text>3.23.4.4、TestRestTemplate</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-24%E3%80%81WebSockets><span class=nav-number>4.24.</span> <span class=nav-text>3.24、WebSockets</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-25%E3%80%81Web-Service><span class=nav-number>4.25.</span> <span class=nav-text>3.25、Web Service</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-26%E3%80%81%E4%BD%BF%E7%94%A8-WebServiceTemplate-%E8%B0%83%E7%94%A8-Web-%E6%9C%8D%E5%8A%A1><span class=nav-number>4.26.</span> <span class=nav-text>3.26、使用 WebServiceTemplate 调用 Web 服务</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-27%E3%80%81%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE><span class=nav-number>4.27.</span> <span class=nav-text>3.27、创建自己的自动配置</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-27-1%E3%80%81%E4%BA%86%E8%A7%A3%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84Bean><span class=nav-number>4.27.1.</span> <span class=nav-text>3.27.1、了解自动配置的Bean</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-27-2%E3%80%81%E6%9F%A5%E6%89%BE%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E5%80%99%E9%80%89%E4%BA%BA><span class=nav-number>4.27.2.</span> <span class=nav-text>3.27.2、查找自动配置的候选人</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-27-3%E3%80%81%E6%9D%A1%E4%BB%B6Comments><span class=nav-number>4.27.3.</span> <span class=nav-text>3.27.3、条件Comments</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-27-3-1%E3%80%81Class-%E6%9D%A1%E4%BB%B6><span class=nav-number>4.27.3.1.</span> <span class=nav-text>3.27.3.1、Class 条件</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-27-3-2%E3%80%81Bean-%E6%9D%A1%E4%BB%B6><span class=nav-number>4.27.3.2.</span> <span class=nav-text>3.27.3.2、Bean 条件</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-27-3-3%E3%80%81%E8%B4%A2%E4%BA%A7%E6%9D%A1%E4%BB%B6><span class=nav-number>4.27.3.3.</span> <span class=nav-text>3.27.3.3、财产条件</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-27-3-4%E3%80%81%E8%B5%84%E6%BA%90%E6%9D%A1%E4%BB%B6><span class=nav-number>4.27.3.4.</span> <span class=nav-text>3.27.3.4、资源条件</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-27-3-5%E3%80%81Web-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%9D%A1%E4%BB%B6><span class=nav-number>4.27.3.5.</span> <span class=nav-text>3.27.3.5、Web 应用程序条件</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-27-3-6%E3%80%81SpEL-%E8%A1%A8%E8%BE%BE%E6%9D%A1%E4%BB%B6><span class=nav-number>4.27.3.6.</span> <span class=nav-text>3.27.3.6、SpEL 表达条件</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-27-4%E3%80%81%E6%B5%8B%E8%AF%95%E6%82%A8%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE><span class=nav-number>4.27.4.</span> <span class=nav-text>3.27.4、测试您的自动配置</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-27-4-1%E3%80%81%E6%A8%A1%E6%8B%9F%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83><span class=nav-number>4.27.4.1.</span> <span class=nav-text>3.27.4.1、模拟网络环境</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-27-4-2%E3%80%81%E8%A6%86%E7%9B%96Classpath><span class=nav-number>4.27.4.2.</span> <span class=nav-text>3.27.4.2、覆盖Classpath</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-27-5%E3%80%81%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%90%AF%E5%8A%A8%E5%99%A8><span class=nav-number>4.27.5.</span> <span class=nav-text>3.27.5、创建自己的启动器</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-27-5-1%E3%80%81Naming><span class=nav-number>4.27.5.1.</span> <span class=nav-text>3.27.5.1、Naming</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-27-5-2%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9D%97><span class=nav-number>4.27.5.2.</span> <span class=nav-text>3.27.5.2、自动配置模块</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-27-5-3%E3%80%81Starter%E6%A8%A1%E5%9D%97><span class=nav-number>4.27.5.3.</span> <span class=nav-text>3.27.5.3、Starter模块</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-28%E3%80%81Kotlin-support><span class=nav-number>4.28.</span> <span class=nav-text>3.28、Kotlin support</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-28-1%E3%80%81Requirements><span class=nav-number>4.28.1.</span> <span class=nav-text>3.28.1、Requirements</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-28-2%E3%80%81Null-safety><span class=nav-number>4.28.2.</span> <span class=nav-text>3.28.2、Null-safety</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-28-3%E3%80%81Kotlin-API><span class=nav-number>4.28.3.</span> <span class=nav-text>3.28.3、Kotlin API</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-28-3-1%E3%80%81runApplication><span class=nav-number>4.28.3.1.</span> <span class=nav-text>3.28.3.1、runApplication</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-28-3-2%E3%80%81Extensions><span class=nav-number>4.28.3.2.</span> <span class=nav-text>3.28.3.2、Extensions</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-28-4%E3%80%81%E4%BE%9D%E8%B5%96%E6%80%A7-Management><span class=nav-number>4.28.4.</span> <span class=nav-text>3.28.4、依赖性 Management</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-28-5%E3%80%81-ConfigurationProperties><span class=nav-number>4.28.5.</span> <span class=nav-text>3.28.5、@ConfigurationProperties</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-28-6%E3%80%81Testing><span class=nav-number>4.28.6.</span> <span class=nav-text>3.28.6、Testing</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-28-7%E3%80%81Resources><span class=nav-number>4.28.7.</span> <span class=nav-text>3.28.7、Resources</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-28-7-1%E3%80%81%E8%BF%9B%E4%B8%80%E6%AD%A5%E9%98%85%E8%AF%BB><span class=nav-number>4.28.7.1.</span> <span class=nav-text>3.28.7.1、进一步阅读</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-28-7-2%E3%80%81Examples><span class=nav-number>4.28.7.2.</span> <span class=nav-text>3.28.7.2、Examples</span></a></ol></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#4%E3%80%81Spring-Boot-Actuator><span class=nav-number>5.</span> <span class=nav-text>4、Spring Boot Actuator</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#4-1%E3%80%81%E5%90%AF%E7%94%A8%E7%94%9F%E4%BA%A7%E5%B0%B1%E7%BB%AA%E5%8A%9F%E8%83%BD><span class=nav-number>5.1.</span> <span class=nav-text>4.1、启用生产就绪功能</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#4-2%E3%80%81Endpoints><span class=nav-number>5.2.</span> <span class=nav-text>4.2、Endpoints</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-2-1%E3%80%81%E5%90%AF%E7%94%A8%E7%AB%AF%E7%82%B9><span class=nav-number>5.2.1.</span> <span class=nav-text>4.2.1、启用端点</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-2-2%E3%80%81%E5%85%AC%E5%BC%80%E7%AB%AF%E7%82%B9><span class=nav-number>5.2.2.</span> <span class=nav-text>4.2.2、公开端点</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-2-3%E3%80%81%E4%BF%9D%E6%8A%A4HTTP%E7%AB%AF%E7%82%B9><span class=nav-number>5.2.3.</span> <span class=nav-text>4.2.3、保护HTTP端点</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-2-4%E3%80%81%E9%85%8D%E7%BD%AE%E7%AB%AF%E7%82%B9><span class=nav-number>5.2.4.</span> <span class=nav-text>4.2.4、配置端点</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-2-5%E3%80%81%E7%94%A8%E4%BA%8E-Actuator-Web-%E7%AB%AF%E7%82%B9%E7%9A%84%E8%B6%85%E5%AA%92%E4%BD%93><span class=nav-number>5.2.5.</span> <span class=nav-text>4.2.5、用于 Actuator Web 端点的超媒体</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-2-6%E3%80%81CORS-%E6%94%AF%E6%8C%81><span class=nav-number>5.2.6.</span> <span class=nav-text>4.2.6、CORS 支持</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-2-7%E3%80%81%E5%AE%9E%E6%96%BD%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AB%AF%E7%82%B9><span class=nav-number>5.2.7.</span> <span class=nav-text>4.2.7、实施自定义端点</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#4-2-7-1%E3%80%81%E6%8E%A5%E6%94%B6-Importing><span class=nav-number>5.2.7.1.</span> <span class=nav-text>4.2.7.1、接收 Importing</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#Importing-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2><span class=nav-number>5.2.7.1.1.</span> <span class=nav-text>Importing 类型转换</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#4-2-7-2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89-Web-%E7%AB%AF%E7%82%B9><span class=nav-number>5.2.7.2.</span> <span class=nav-text>4.2.7.2、自定义 Web 端点</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#Web-%E7%AB%AF%E7%82%B9%E8%AF%B7%E6%B1%82%E8%B0%93%E8%AF%8D><span class=nav-number>5.2.7.2.1.</span> <span class=nav-text>Web 端点请求谓词</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Path><span class=nav-number>5.2.7.2.2.</span> <span class=nav-text>Path</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#HTTP-method><span class=nav-number>5.2.7.2.3.</span> <span class=nav-text>HTTP method</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Consumes><span class=nav-number>5.2.7.2.4.</span> <span class=nav-text>Consumes</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Produces><span class=nav-number>5.2.7.2.5.</span> <span class=nav-text>Produces</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Web-%E7%AB%AF%E7%82%B9%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81><span class=nav-number>5.2.7.2.6.</span> <span class=nav-text>Web 端点响应状态</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Web-%E7%AB%AF%E7%82%B9%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82><span class=nav-number>5.2.7.2.7.</span> <span class=nav-text>Web 端点范围请求</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#Web-%E7%AB%AF%E7%82%B9%E5%AE%89%E5%85%A8><span class=nav-number>5.2.7.2.8.</span> <span class=nav-text>Web 端点安全</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#4-2-7-3%E3%80%81Servlet-%E7%AB%AF%E7%82%B9><span class=nav-number>5.2.7.3.</span> <span class=nav-text>4.2.7.3、Servlet 端点</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-2-7-4%E3%80%81%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AB%AF%E7%82%B9><span class=nav-number>5.2.7.4.</span> <span class=nav-text>4.2.7.4、控制器端点</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#4-2-8%E3%80%81%E5%81%A5%E5%BA%B7%E4%BF%A1%E6%81%AF><span class=nav-number>5.2.8.</span> <span class=nav-text>4.2.8、健康信息</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#4-2-8-1%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E5%81%A5%E5%BA%B7-Metrics><span class=nav-number>5.2.8.1.</span> <span class=nav-text>4.2.8.1、自动配置的健康 Metrics</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-2-8-2%E3%80%81%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E5%81%A5%E5%BA%B7-Metrics><span class=nav-number>5.2.8.2.</span> <span class=nav-text>4.2.8.2、编写自定义健康 Metrics</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-2-8-3%E3%80%81Reactive-%E5%81%A5%E5%BA%B7-Metrics><span class=nav-number>5.2.8.3.</span> <span class=nav-text>4.2.8.3、Reactive 健康 Metrics</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-2-8-4%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84-ReactiveHealthIndicators><span class=nav-number>5.2.8.4.</span> <span class=nav-text>4.2.8.4、自动配置的 ReactiveHealthIndicators</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#4-2-9%E3%80%81%E7%94%B3%E8%AF%B7%E4%BF%A1%E6%81%AF><span class=nav-number>5.2.9.</span> <span class=nav-text>4.2.9、申请信息</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#4-2-9-1%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E4%BF%A1%E6%81%AF%E8%B4%A1%E7%8C%AE%E8%80%85><span class=nav-number>5.2.9.1.</span> <span class=nav-text>4.2.9.1、自动配置的信息贡献者</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-2-9-2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BF%A1%E6%81%AF><span class=nav-number>5.2.9.2.</span> <span class=nav-text>4.2.9.2、自定义应用程序信息</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-2-9-3%E3%80%81Git-%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF><span class=nav-number>5.2.9.3.</span> <span class=nav-text>4.2.9.3、Git 提交信息</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-2-9-4%E3%80%81%E7%94%9F%E6%88%90%E4%BF%A1%E6%81%AF><span class=nav-number>5.2.9.4.</span> <span class=nav-text>4.2.9.4、生成信息</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-2-9-5%E3%80%81%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E6%81%AF%E6%8F%90%E4%BE%9B%E8%80%85><span class=nav-number>5.2.9.5.</span> <span class=nav-text>4.2.9.5、编写自定义信息提供者</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#4-3%E3%80%81%E9%80%9A%E8%BF%87-HTTP-%E8%BF%9B%E8%A1%8C%E7%9B%91%E8%A7%86%E5%92%8C-Management><span class=nav-number>5.3.</span> <span class=nav-text>4.3、通过 HTTP 进行监视和 Management</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-3-1%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89-Management-%E7%AB%AF%E7%82%B9%E8%B7%AF%E5%BE%84><span class=nav-number>5.3.1.</span> <span class=nav-text>4.3.1、自定义 Management 端点路径</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-3-2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89-Management-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%8F%A3><span class=nav-number>5.3.2.</span> <span class=nav-text>4.3.2、自定义 Management 服务器端口</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-3-3%E3%80%81%E9%85%8D%E7%BD%AE%E7%89%B9%E5%AE%9A%E4%BA%8E-Management-%E7%9A%84-SSL><span class=nav-number>5.3.3.</span> <span class=nav-text>4.3.3、配置特定于 Management 的 SSL</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-3-4%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89-Management-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80><span class=nav-number>5.3.4.</span> <span class=nav-text>4.3.4、自定义 Management 服务器地址</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-3-5%E3%80%81%E7%A6%81%E7%94%A8-HTTP-%E7%AB%AF%E7%82%B9><span class=nav-number>5.3.5.</span> <span class=nav-text>4.3.5、禁用 HTTP 端点</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#4-4%E3%80%81%E9%80%9A%E8%BF%87-JMX-%E8%BF%9B%E8%A1%8C%E7%9B%91%E8%A7%86%E5%92%8C-Management><span class=nav-number>5.4.</span> <span class=nav-text>4.4、通过 JMX 进行监视和 Management</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-4-1%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89-MBean-%E5%90%8D%E7%A7%B0><span class=nav-number>5.4.1.</span> <span class=nav-text>4.4.1、自定义 MBean 名称</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-4-2%E3%80%81%E7%A6%81%E7%94%A8-JMX-%E7%AB%AF%E7%82%B9><span class=nav-number>5.4.2.</span> <span class=nav-text>4.4.2、禁用 JMX 端点</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-4-3%E3%80%81%E9%80%9A%E8%BF%87-HTTP-%E5%B0%86-Jolokia-%E7%94%A8%E4%BA%8E-JMX><span class=nav-number>5.4.3.</span> <span class=nav-text>4.4.3、通过 HTTP 将 Jolokia 用于 JMX</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#4-4-3-1%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89-Jolokia><span class=nav-number>5.4.3.1.</span> <span class=nav-text>4.4.3.1、自定义 Jolokia</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-4-3-2%E3%80%81%E7%A6%81%E7%94%A8-Jolokia><span class=nav-number>5.4.3.2.</span> <span class=nav-text>4.4.3.2、禁用 Jolokia</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#4-5%E3%80%81Loggers><span class=nav-number>5.5.</span> <span class=nav-text>4.5、Loggers</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-5-1%E3%80%81%E9%85%8D%E7%BD%AELogger><span class=nav-number>5.5.1.</span> <span class=nav-text>4.5.1、配置Logger</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#4-6%E3%80%81Metrics><span class=nav-number>5.6.</span> <span class=nav-text>4.6、Metrics</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-6-1%E3%80%81%E4%BD%BF%E7%94%A8-Starter><span class=nav-number>5.6.1.</span> <span class=nav-text>4.6.1、使用 Starter</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-6-2%E3%80%81%E6%94%AF%E6%8C%81%E7%9A%84%E7%9B%91%E8%A7%86%E7%B3%BB%E7%BB%9F><span class=nav-number>5.6.2.</span> <span class=nav-text>4.6.2、支持的监视系统</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-2-1%E3%80%81AppOptics><span class=nav-number>5.6.2.1.</span> <span class=nav-text>4.6.2.1、AppOptics</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-2-2%E3%80%81Atlas><span class=nav-number>5.6.2.2.</span> <span class=nav-text>4.6.2.2、Atlas</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-2-3%E3%80%81Datadog><span class=nav-number>5.6.2.3.</span> <span class=nav-text>4.6.2.3、Datadog</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-2-4%E3%80%81Dynatrace><span class=nav-number>5.6.2.4.</span> <span class=nav-text>4.6.2.4、Dynatrace</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-2-5%E3%80%81Elastic><span class=nav-number>5.6.2.5.</span> <span class=nav-text>4.6.2.5、Elastic</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-2-6%E3%80%81Ganglia><span class=nav-number>5.6.2.6.</span> <span class=nav-text>4.6.2.6、Ganglia</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-2-7%E3%80%81Graphite><span class=nav-number>5.6.2.7.</span> <span class=nav-text>4.6.2.7、Graphite</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-2-8%E3%80%81Humio><span class=nav-number>5.6.2.8.</span> <span class=nav-text>4.6.2.8、Humio</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-2-9%E3%80%81Influx><span class=nav-number>5.6.2.9.</span> <span class=nav-text>4.6.2.9、Influx</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-2-10%E3%80%81JMX><span class=nav-number>5.6.2.10.</span> <span class=nav-text>4.6.2.10、JMX</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-2-11%E3%80%81KairosDB><span class=nav-number>5.6.2.11.</span> <span class=nav-text>4.6.2.11、KairosDB</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-2-12%E3%80%81New-Relic><span class=nav-number>5.6.2.12.</span> <span class=nav-text>4.6.2.12、New Relic</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-2-13%E3%80%81Prometheus><span class=nav-number>5.6.2.13.</span> <span class=nav-text>4.6.2.13、Prometheus</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-2-14%E3%80%81SignalFx><span class=nav-number>5.6.2.14.</span> <span class=nav-text>4.6.2.14、SignalFx</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-2-15%E3%80%81Simple><span class=nav-number>5.6.2.15.</span> <span class=nav-text>4.6.2.15、Simple</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-2-16%E3%80%81StatsD><span class=nav-number>5.6.2.16.</span> <span class=nav-text>4.6.2.16、StatsD</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-2-17%E3%80%81Wavefront><span class=nav-number>5.6.2.17.</span> <span class=nav-text>4.6.2.17、Wavefront</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#4-6-3%E3%80%81%E6%94%AF%E6%8C%81%E7%9A%84-Metrics><span class=nav-number>5.6.3.</span> <span class=nav-text>4.6.3、支持的 Metrics</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-3-1%E3%80%81Spring-MVC-Metrics><span class=nav-number>5.6.3.1.</span> <span class=nav-text>4.6.3.1、Spring MVC Metrics</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-3-2%E3%80%81Spring-WebFlux-Metrics><span class=nav-number>5.6.3.2.</span> <span class=nav-text>4.6.3.2、Spring WebFlux Metrics</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-3-3%E3%80%81Jersey-%E6%9C%8D%E5%8A%A1%E5%99%A8-Metrics><span class=nav-number>5.6.3.3.</span> <span class=nav-text>4.6.3.3、Jersey 服务器 Metrics</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-3-4%E3%80%81HTTP-Client-%E7%AB%AF-Metrics><span class=nav-number>5.6.3.4.</span> <span class=nav-text>4.6.3.4、HTTP Client 端 Metrics</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-3-5%E3%80%81%E7%BC%93%E5%AD%98-Metrics><span class=nav-number>5.6.3.5.</span> <span class=nav-text>4.6.3.5、缓存 Metrics</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-3-6%E3%80%81%E6%95%B0%E6%8D%AE%E6%BA%90-Metrics><span class=nav-number>5.6.3.6.</span> <span class=nav-text>4.6.3.6、数据源 Metrics</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-3-7%E3%80%81HibernateMetrics><span class=nav-number>5.6.3.7.</span> <span class=nav-text>4.6.3.7、HibernateMetrics</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-3-8%E3%80%81RabbitMQ-Metrics><span class=nav-number>5.6.3.8.</span> <span class=nav-text>4.6.3.8、RabbitMQ Metrics</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#4-6-4%E3%80%81%E6%B3%A8%E5%86%8C%E8%87%AA%E5%AE%9A%E4%B9%89-Metrics><span class=nav-number>5.6.4.</span> <span class=nav-text>4.6.4、注册自定义 Metrics</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-6-5%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%95%E4%B8%AA-Metrics><span class=nav-number>5.6.5.</span> <span class=nav-text>4.6.5、自定义单个 Metrics</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-5-1%E3%80%81%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE><span class=nav-number>5.6.5.1.</span> <span class=nav-text>4.6.5.1、常用标签</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#4-6-5-2%E3%80%81%E6%AF%8F%E7%B1%B3%E5%B1%9E%E6%80%A7><span class=nav-number>5.6.5.2.</span> <span class=nav-text>4.6.5.2、每米属性</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#4-6-6%E3%80%81Metrics-%E7%BB%88%E7%BB%93%E7%82%B9><span class=nav-number>5.6.6.</span> <span class=nav-text>4.6.6、Metrics 终结点</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#4-7%E3%80%81Auditing><span class=nav-number>5.7.</span> <span class=nav-text>4.7、Auditing</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#4-8%E3%80%81HTTP-%E8%B7%9F%E8%B8%AA><span class=nav-number>5.8.</span> <span class=nav-text>4.8、HTTP 跟踪</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-8-1-%E8%87%AA%E5%AE%9A%E4%B9%89-HTTP-%E8%B7%9F%E8%B8%AA><span class=nav-number>5.8.1.</span> <span class=nav-text>4.8.1 自定义 HTTP 跟踪</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#4-9%E3%80%81Process-Monitoring><span class=nav-number>5.9.</span> <span class=nav-text>4.9、Process Monitoring</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-9-1%E3%80%81%E6%89%A9%E5%B1%95%E9%85%8D%E7%BD%AE><span class=nav-number>5.9.1.</span> <span class=nav-text>4.9.1、扩展配置</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-9-2%E3%80%81Programmatically><span class=nav-number>5.9.2.</span> <span class=nav-text>4.9.2、Programmatically</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#4-10%E3%80%81Cloud-Foundry-%E6%94%AF%E6%8C%81><span class=nav-number>5.10.</span> <span class=nav-text>4.10、Cloud Foundry 支持</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-10-1%E3%80%81%E7%A6%81%E7%94%A8%E6%89%A9%E5%B1%95%E7%9A%84-Cloud-Foundry-Actuator-%E6%94%AF%E6%8C%81><span class=nav-number>5.10.1.</span> <span class=nav-text>4.10.1、禁用扩展的 Cloud Foundry Actuator 支持</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-10-2%E3%80%81Cloud-Foundry-%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6><span class=nav-number>5.10.2.</span> <span class=nav-text>4.10.2、Cloud Foundry 自签名证书</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-10-3%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8A%E4%B8%8B%E6%96%87%E8%B7%AF%E5%BE%84><span class=nav-number>5.10.3.</span> <span class=nav-text>4.10.3、自定义上下文路径</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#5%E3%80%81%E9%83%A8%E7%BD%B2-SpringBoot-%E5%BA%94%E7%94%A8><span class=nav-number>6.</span> <span class=nav-text>5、部署 SpringBoot 应用</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#5-1%E3%80%81%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E7%AB%AF><span class=nav-number>6.1.</span> <span class=nav-text>5.1、部署到云端</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#5-1-1%E3%80%81Cloud-Foundry><span class=nav-number>6.1.1.</span> <span class=nav-text>5.1.1、Cloud Foundry</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#5-1-1-1%E3%80%81%E7%BB%91%E5%AE%9A%E5%88%B0%E6%9C%8D%E5%8A%A1><span class=nav-number>6.1.1.1.</span> <span class=nav-text>5.1.1.1、绑定到服务</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#5-1-2%E3%80%81Heroku><span class=nav-number>6.1.2.</span> <span class=nav-text>5.1.2、Heroku</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#5-1-3%E3%80%81OpenShift><span class=nav-number>6.1.3.</span> <span class=nav-text>5.1.3、OpenShift</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#5-1-4%E3%80%81Amazon-Web-Services-AWS><span class=nav-number>6.1.4.</span> <span class=nav-text>5.1.4、Amazon Web Services(AWS)</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#5-1-4-1%E3%80%81AWS-Elastic-Beanstalk><span class=nav-number>6.1.4.1.</span> <span class=nav-text>5.1.4.1、AWS Elastic Beanstalk</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%BF%E7%94%A8-Tomcat-%E5%B9%B3%E5%8F%B0><span class=nav-number>6.1.4.1.1.</span> <span class=nav-text>使用 Tomcat 平台</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BD%BF%E7%94%A8-Java-SE-%E5%B9%B3%E5%8F%B0><span class=nav-number>6.1.4.1.2.</span> <span class=nav-text>使用 Java SE 平台</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#5-1-4-2%E3%80%81Summary><span class=nav-number>6.1.4.2.</span> <span class=nav-text>5.1.4.2、Summary</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#5-1-5%E3%80%81Boxfuse-%E5%92%8C-Amazon-Web-Services><span class=nav-number>6.1.5.</span> <span class=nav-text>5.1.5、Boxfuse 和 Amazon Web Services</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#5-1-6%E3%80%81Google-Cloud><span class=nav-number>6.1.6.</span> <span class=nav-text>5.1.6、Google Cloud</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#5-2%E3%80%81%E5%AE%89%E8%A3%85-Spring-Boot-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F><span class=nav-number>6.2.</span> <span class=nav-text>5.2、安装 Spring Boot 应用程序</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#5-2-1%E3%80%81%E6%94%AF%E6%8C%81%E7%9A%84-os><span class=nav-number>6.2.1.</span> <span class=nav-text>5.2.1、支持的 os</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#5-2-2%E3%80%81Unix-Linux-%E6%9C%8D%E5%8A%A1><span class=nav-number>6.2.2.</span> <span class=nav-text>5.2.2、Unix/Linux 服务</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#5-2-2-1%E3%80%81%E4%BD%9C%E4%B8%BA-init-d-%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85-%E7%B3%BB%E7%BB%9F-V><span class=nav-number>6.2.2.1.</span> <span class=nav-text>5.2.2.1、作为 init.d 服务安装(系统 V)</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E4%BF%9D%E6%8A%A4-init-d-%E6%9C%8D%E5%8A%A1><span class=nav-number>6.2.2.1.1.</span> <span class=nav-text>保护 init.d 服务</span></a></ol><li class="nav-item nav-level-4"><a class=nav-link href=#5-2-2-2%E3%80%81%E4%BD%9C%E4%B8%BA%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%AE%89%E8%A3%85><span class=nav-number>6.2.2.2.</span> <span class=nav-text>5.2.2.2、作为系统服务安装</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#5-2-2-3%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC><span class=nav-number>6.2.2.3.</span> <span class=nav-text>5.2.2.3、自定义启动脚本</span></a><ol class=nav-child><li class="nav-item nav-level-5"><a class=nav-link href=#%E7%BC%96%E5%86%99%E5%90%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC><span class=nav-number>6.2.2.3.1.</span> <span class=nav-text>编写后自定义启动脚本</span></a><li class="nav-item nav-level-5"><a class=nav-link href=#%E8%BF%90%E8%A1%8C%E6%97%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E8%84%9A%E6%9C%AC><span class=nav-number>6.2.2.3.2.</span> <span class=nav-text>运行时自定义脚本</span></a></ol></ol><li class="nav-item nav-level-3"><a class=nav-link href=#5-2-3%E3%80%81Microsoft-Windows-%E6%9C%8D%E5%8A%A1><span class=nav-number>6.2.3.</span> <span class=nav-text>5.2.3、Microsoft Windows 服务</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#6%E3%80%81Spring-Boot-CLI><span class=nav-number>7.</span> <span class=nav-text>6、Spring Boot CLI</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#6-1%E3%80%81%E5%AE%89%E8%A3%85CLI><span class=nav-number>7.1.</span> <span class=nav-text>6.1、安装CLI</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#6-2%E3%80%81%E4%BD%BF%E7%94%A8CLI><span class=nav-number>7.2.</span> <span class=nav-text>6.2、使用CLI</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#6-2-1%E3%80%81%E4%BD%BF%E7%94%A8-CLI-%E8%BF%90%E8%A1%8C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F><span class=nav-number>7.2.1.</span> <span class=nav-text>6.2.1、使用 CLI 运行应用程序</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#6-2-1-1%E3%80%81%E6%8E%A8%E8%AE%BA%E2%80%9Dgrab%E2%80%9D%E4%BE%9D%E8%B5%96%E6%80%A7><span class=nav-number>7.2.1.1.</span> <span class=nav-text>6.2.1.1、推论”grab”依赖性</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#6-2-1-2%E3%80%81%E6%8E%A8%E5%AF%BC%E2%80%9Dgrab%E2%80%9D%E5%9D%90%E6%A0%87><span class=nav-number>7.2.1.2.</span> <span class=nav-text>6.2.1.2、推导”grab”坐标</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#6-2-1-3%E3%80%81%E9%BB%98%E8%AE%A4%E5%AF%BC%E5%85%A5%E8%AF%AD%E5%8F%A5><span class=nav-number>7.2.1.3.</span> <span class=nav-text>6.2.1.3、默认导入语句</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#6-2-1-4%E3%80%81%E8%87%AA%E5%8A%A8-main-%E6%96%B9%E6%B3%95><span class=nav-number>7.2.1.4.</span> <span class=nav-text>6.2.1.4、自动 main 方法</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#6-2-1-5%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BE%9D%E8%B5%96%E9%A1%B9-Management><span class=nav-number>7.2.1.5.</span> <span class=nav-text>6.2.1.5、自定义依赖项 Management</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#6-2-2%E3%80%81%E5%85%B7%E6%9C%89%E5%A4%9A%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F><span class=nav-number>7.2.2.</span> <span class=nav-text>6.2.2、具有多个源文件的应用程序</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#6-2-3%E3%80%81%E6%89%93%E5%8C%85%E6%82%A8%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F><span class=nav-number>7.2.3.</span> <span class=nav-text>6.2.3、打包您的应用程序</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#6-2-4%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B0%E9%A1%B9%E7%9B%AE><span class=nav-number>7.2.4.</span> <span class=nav-text>6.2.4、初始化新项目</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#6-2-5%E3%80%81%E4%BD%BF%E7%94%A8%E5%B5%8C%E5%85%A5%E5%BC%8F-Shell><span class=nav-number>7.2.5.</span> <span class=nav-text>6.2.5、使用嵌入式 Shell</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#6-2-6%E3%80%81%E5%B0%86%E6%89%A9%E5%B1%95%E6%B7%BB%E5%8A%A0%E5%88%B0-CLI><span class=nav-number>7.2.6.</span> <span class=nav-text>6.2.6、将扩展添加到 CLI</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#6-3%E3%80%81%E4%BD%BF%E7%94%A8-Groovy-Bean-DSL-%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F><span class=nav-number>7.3.</span> <span class=nav-text>6.3、使用 Groovy Bean DSL 开发应用程序</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#6-4%E3%80%81%E4%BD%BF%E7%94%A8-settings-xml-%E9%85%8D%E7%BD%AE-CLI><span class=nav-number>7.4.</span> <span class=nav-text>6.4、使用 settings.xml 配置 CLI</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#6-5%E3%80%81%E6%8E%A5%E4%B8%8B%E6%9D%A5%E8%AF%BB%E4%BB%80%E4%B9%88><span class=nav-number>7.5.</span> <span class=nav-text>6.5、接下来读什么</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#7%E3%80%81%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E6%8F%92%E4%BB%B6><span class=nav-number>8.</span> <span class=nav-text>7、构建工具插件</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#7-1%E3%80%81Spring-Boot-Maven-%E6%8F%92%E4%BB%B6><span class=nav-number>8.1.</span> <span class=nav-text>7.1、Spring Boot Maven 插件</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#7-1-1%E3%80%81%E5%8C%85%E5%90%AB%E6%8F%92%E4%BB%B6><span class=nav-number>8.1.1.</span> <span class=nav-text>7.1.1、包含插件</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#7-1-2%E3%80%81%E5%8C%85%E8%A3%85%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%9A%84-Jar-%E5%92%8C-War-%E6%96%87%E4%BB%B6><span class=nav-number>8.1.2.</span> <span class=nav-text>7.1.2、包装可执行的 Jar 和 War 文件</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#7-2%E3%80%81Spring-Boot-Gradle-%E6%8F%92%E4%BB%B6><span class=nav-number>8.2.</span> <span class=nav-text>7.2、Spring Boot Gradle 插件</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#7-3%E3%80%81Spring-Boot-AntLib-%E6%A8%A1%E5%9D%97><span class=nav-number>8.3.</span> <span class=nav-text>7.3、Spring Boot AntLib 模块</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#7-3-1%E3%80%81Spring-Boot-Ant-%E4%BB%BB%E5%8A%A1><span class=nav-number>8.3.1.</span> <span class=nav-text>7.3.1、Spring Boot Ant 任务</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#7-3-1-1%E3%80%81spring-boot-exejar><span class=nav-number>8.3.1.1.</span> <span class=nav-text>7.3.1.1、spring-boot:exejar</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#7-3-1-2%E3%80%81Examples><span class=nav-number>8.3.1.2.</span> <span class=nav-text>7.3.1.2、Examples</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#7-3-2%E3%80%81spring-boot-findmainclass><span class=nav-number>8.3.2.</span> <span class=nav-text>7.3.2、spring-boot:findmainclass</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#7-3-2-1%E3%80%81Examples><span class=nav-number>8.3.2.1.</span> <span class=nav-text>7.3.2.1、Examples</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#7-4%E3%80%81%E6%94%AF%E6%8C%81%E5%85%B6%E4%BB%96%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F><span class=nav-number>8.4.</span> <span class=nav-text>7.4、支持其他构建系统</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#7-4-1%E3%80%81%E9%87%8D%E6%96%B0%E6%89%93%E5%8C%85-Files><span class=nav-number>8.4.1.</span> <span class=nav-text>7.4.1、重新打包 Files</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#7-4-2%E3%80%81%E5%B5%8C%E5%A5%97%E5%BA%93><span class=nav-number>8.4.2.</span> <span class=nav-text>7.4.2、嵌套库</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#7-4-3%E3%80%81%E6%9F%A5%E6%89%BE%E4%B8%BB%E8%A6%81%E7%B1%BB><span class=nav-number>8.4.3.</span> <span class=nav-text>7.4.3、查找主要类</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#7-4-4%E3%80%81%E9%87%8D%E6%96%B0%E6%89%93%E5%8C%85%E5%AE%9E%E6%96%BD%E7%A4%BA%E4%BE%8B><span class=nav-number>8.4.4.</span> <span class=nav-text>7.4.4、重新打包实施示例</span></a></ol></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>116</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>36</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>129</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://hshz21.gitee.io/2024/08/21/SpringBoo%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="SpringBoot系列-SpringBoot基础应用 | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>SpringBoot系列-SpringBoot基础应用</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-03 21:16:27" datetime=2023-10-03T21:16:27+08:00 itemprop=dateModified>2023-10-03</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/SpringBoot/ itemprop=url rel=index><span itemprop=name>SpringBoot</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=0、SpringBoot启动流程><a class=headerlink href=#0、SpringBoot启动流程 title=0、SpringBoot启动流程></a>0、SpringBoot启动流程</h1><p>SpringBoot启动流程主要分两步，创建SpringApplication对象流程 和 执行其run方法流程。<h2 id=0-1、创建SpringApplication对象流程><a class=headerlink href=#0-1、创建SpringApplication对象流程 title=0.1、创建SpringApplication对象流程></a>0.1、创建SpringApplication对象流程</h2><ol><li>初始化资源加载器，默认为null。<li>断言判断参数是否不为空。<li>初始化参数源。（封装参数为LinkedHashSet）<li>初始化当前应用类型（非Web类型、Servlet类型、Reactive类型）<li>获取系统配置引导信息。<li>获取ApplicationContextInitializer.class对应的实例。<li>初始化监听器，对初始化过程及运行过程进行干预。<li>初始化了引导类类名信息，备用。</ol><h2 id=0-2、执行SpringApplication-run方法流程><a class=headerlink href=#0-2、执行SpringApplication-run方法流程 title=0.2、执行SpringApplication.run方法流程></a>0.2、执行SpringApplication.run方法流程</h2><ol><li>设置计时器，并开始计时。<li>创建系统引导上下文对象。<ol><li>获取所有之前的bootstrappers，并逐个执行。initialization()完成对引导启动器上下文环境设置。</ol><li>模拟输入输出信号，避免出现因缺少外设导致的信号传输失败，进而引发错误（模拟显示器，键盘，鼠标…）<br>java.awt.headless=true。<li>获取当前注册的所有监听器，并开启监听。<li>获取参数并结合前期所读取的参数组合成一个环境对象，来描述环境信息。<li>配置系统环境参数spring.beaninfo.ignore信息。<li>初始化并打印logo（Banner）信息。<li>创建容器对象，并设置启动模式。<li>准备容器环境，参数来源于前期的设定。<li>刷新容器环境，并做刷新后处理。<li>计时结束。<li>创建启动信息日志对象，输出日志信息，包含启动时间。<li>监听器启动。<li>调用接口ApplicationRunner和接口CommandLineRunner的实现。<li>监听器运行。<li>如果以上有异常，调用监听器的failed方法。<li>返回context对象。</ol><h1 id=1、使用Starter><a class=headerlink href=#1、使用Starter title=1、使用Starter></a>1、使用Starter</h1><h2 id=1-1、啥是Spring-Boot><a title="1.1、啥是Spring Boot" class=headerlink href=#1-1、啥是Spring-Boot></a>1.1、啥是Spring Boot</h2><p>Spring Boot 使创建可运行的独立，基于生产级的基于 Spring 的应用程序变得容易。我们对 Spring 平台和第三方库持固执己见的观点，这样您就可以以最小的麻烦开始使用。大多数 Spring Boot 应用程序只需要很少的 Spring 配置。<p>您可以使用 Spring Boot 创建 Java 应用程序，可以使用<code>java -jar</code>或更传统的 War 部署来启动这些 Java 应用程序。我们还提供了一个运行“ spring 脚本”的命令行工具。<p>主要目标是：<ul><li>为所有 Spring 开发提供根本上更快且可广泛访问的 Starter 经验。<li>开箱即用，但由于需求开始与默认值有所出入，因此很快就会摆脱困境。<li>提供一系列大型项目通用的非功能性功能(例如嵌入式服务器，安全性，Metrics，运行状况检查和外部化配置)。<li>完全没有代码生成，也不需要 XML 配置。</ul><h2 id=1-2、System-Requirements><a title="1.2、System Requirements" class=headerlink href=#1-2、System-Requirements></a>1.2、System Requirements</h2><p>Spring Boot 2.1.1.RELEASE 需要<a href=https://www.java.com/ rel=noopener target=_blank>Java 8</a>，并且与 Java 11(包括)兼容。也必须<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/ rel=noopener target=_blank>Spring Framework 5.1.3. 发布</a>或更高。<p>为以下构建工具提供了明确的构建支持：<table><thead><tr><th>Build Tool<th>Version<tbody><tr><td>Maven<td>3.3+<tr><td>Gradle<td>4.4+</table><h3 id=1-2-1、Servlet容器><a class=headerlink href=#1-2-1、Servlet容器 title=1.2.1、Servlet容器></a>1.2.1、Servlet容器</h3><p>Spring Boot 支持以下嵌入式 servlet 容器：<table><thead><tr><th>Name<th>Servlet Version<tbody><tr><td>Tomcat 9.0<td>4.0<tr><td>Jetty 9.4<td>3.1<tr><td>Undertow 2.0<td>4.0</table><p>您还可以将 Spring Boot 应用程序部署到任何 Servlet 3.1 兼容容器中。<h2 id=1-3、安装Spring-Boot><a title="1.3、安装Spring Boot" class=headerlink href=#1-3、安装Spring-Boot></a>1.3、安装Spring Boot</h2><p>Spring Boot 可以与“经典” Java 开发工具一起使用，也可以作为命令行工具安装。无论哪种方式，您都需要<a href=https://www.java.com/ rel=noopener target=_blank>Java SDK v1.8</a>或更高。在开始之前，您应该使用以下命令检查当前的 Java 安装：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -version</span></span><br></pre></table></figure><p>如果您不熟悉 Java 开发，或者想尝试使用 Spring Boot，则可能要先尝试<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/getting-started-installing-spring-boot.html#getting-started-installing-the-cli rel=noopener target=_blank>Spring Boot CLI</a>(命令行界面)。否则，请 continue 阅读“经典”安装说明。<h3 id=1-3-1、Java人员安装说明><a class=headerlink href=#1-3-1、Java人员安装说明 title=1.3.1、Java人员安装说明></a>1.3.1、Java人员安装说明</h3><p>您可以像使用任何标准 Java 库一样使用 Spring Boot。为此，请在 Classpath 中包含适当的<code>spring-boot-*.jar</code>文件。 Spring Boot 不需要任何特殊的工具集成，因此您可以使用任何 IDE 或文本编辑器。另外，Spring Boot 应用程序没有什么特别的，因此您可以像运行其他 Java 程序一样运行和调试 Spring Boot 应用程序。<p>尽管您可以复制 Spring Boot jar，但是我们通常建议您使用支持依赖项 Management 的构建工具(例如 Maven 或 Gradle)。<h4 id=1-3-1-1、Maven安装><a class=headerlink href=#1-3-1-1、Maven安装 title=1.3.1.1、Maven安装></a>1.3.1.1、Maven安装</h4><p>Spring Boot 依赖项使用<code>org.springframework.boot</code> <code>groupId</code>。通常，您的 Maven POM 文件从<code>spring-boot-starter-parent</code>项目继承，并声明对一个或多个<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#using-boot-starter rel=noopener target=_blank>“Starters”</a>的依赖关系。 Spring Boot 还提供了一个可选的<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/build-tool-plugins-maven-plugin.html rel=noopener target=_blank>Maven plugin</a>来创建可执行 jar。<p>以下 Lists 显示了一个典型的<code>pom.xml</code>文件：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>project</span> <span class=attr>xmlns</span>=<span class=string>"http://maven.apache.org/POM/4.0.0"</span> <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>	<span class=attr>xsi:schemaLocation</span>=<span class=string>"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>></span></span><br><span class=line>	<span class=tag><<span class=name>modelVersion</span>></span>4.0.0<span class=tag>&LT/<span class=name>modelVersion</span>></span></span><br><span class=line></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>com.example<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>myproject<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>version</span>></span>0.0.1-SNAPSHOT<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line></span><br><span class=line>	<span class=comment>&LT!-- Inherit defaults from Spring Boot --></span></span><br><span class=line>	<span class=tag><<span class=name>parent</span>></span></span><br><span class=line>		<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>		<span class=tag><<span class=name>artifactId</span>></span>spring-boot-starter-parent<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>		<span class=tag><<span class=name>version</span>></span>2.1.1.RELEASE<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>parent</span>></span></span><br><span class=line></span><br><span class=line>	<span class=comment>&LT!-- Add typical dependencies for a web application --></span></span><br><span class=line>	<span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>		<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>			<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>artifactId</span>></span>spring-boot-starter-web<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>dependencies</span>></span></span><br><span class=line></span><br><span class=line>	<span class=comment>&LT!-- Package as an executable jar --></span></span><br><span class=line>	<span class=tag><<span class=name>build</span>></span></span><br><span class=line>		<span class=tag><<span class=name>plugins</span>></span></span><br><span class=line>			<span class=tag><<span class=name>plugin</span>></span></span><br><span class=line>				<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>				<span class=tag><<span class=name>artifactId</span>></span>spring-boot-maven-plugin<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>			<span class=tag>&LT/<span class=name>plugin</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>plugins</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>build</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>project</span>></span></span><br></pre></table></figure><h4 id=1-3-1-2、安装Gradle><a class=headerlink href=#1-3-1-2、安装Gradle title=1.3.1.2、安装Gradle></a>1.3.1.2、安装Gradle</h4><p>Spring Boot 与 Gradle 4.4 及更高版本兼容。如果尚未安装 Gradle，则可以按照<a href=https://gradle.org/ rel=noopener target=_blank>gradle.org</a>上的说明进行操作。<p>可以使用<code>org.springframework.boot</code> <code>group</code>声明 Spring Boot 依赖项。通常，您的项目声明对一个或多个<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#using-boot-starter rel=noopener target=_blank>“Starters”</a>的依赖关系。 Spring Boot 提供了一个有用的<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/build-tool-plugins-gradle-plugin.html rel=noopener target=_blank>Gradle plugin</a>，可用于简化依赖项声明并创建可执行 jar。<blockquote><p>当您需要构建项目时，Gradle 包装器提供了一种“获取” Gradle 的好方法。这是一个小的脚本和库，您随代码一起提交以引导构建过程。有关详情，请参见<a href=https://docs.gradle.org/4.2.1/userguide/gradle_wrapper.html rel=noopener target=_blank>docs.gradle.org/4.2.1/userguide/gradle_wrapper.html</a>。</blockquote><p>有关 Spring Boot 和 Gradle Starter 的更多详细信息，可以在 Gradle 插件参考指南的<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/gradle-plugin/reference/html/#getting-started rel=noopener target=_blank>Starter 部分</a>中找到。<h3 id=1-3-2、安装Spring-Boot-CLI><a title="1.3.2、安装Spring Boot CLI" class=headerlink href=#1-3-2、安装Spring-Boot-CLI></a>1.3.2、安装Spring Boot CLI</h3><p>Spring Boot CLI(命令行界面)是一个命令行工具，可用于快速使用 Spring 进行原型设计。它使您可以运行<a href=http://groovy-lang.org/ rel=noopener target=_blank>Groovy</a>脚本，这意味着您具有类似 Java 的熟悉语法，而没有太多样板代码。<p>您无需使用 CLI 即可与 Spring Boot 配合使用，但这绝对是使 Spring 应用程序启动的最快方法。<h4 id=1-3-2-1、手动安装><a class=headerlink href=#1-3-2-1、手动安装 title=1.3.2.1、手动安装></a>1.3.2.1、手动安装</h4><p>您可以从 Spring 软件存储库下载 Spring CLI 发行版：<ul><li><a href=https://repo.spring.io/release/org/springframework/boot/spring-boot-cli/2.1.1.RELEASE/spring-boot-cli-2.1.1.RELEASE-bin.zip rel=noopener target=_blank>spring-boot-cli-2.1.1.RELEASE-bin.zip</a><li><a href=https://repo.spring.io/release/org/springframework/boot/spring-boot-cli/2.1.1.RELEASE/spring-boot-cli-2.1.1.RELEASE-bin.tar.gz rel=noopener target=_blank>spring-boot-cli-2.1.1.RELEASE-bin.tar.gz</a></ul><p>最先进的<a href=https://repo.spring.io/snapshot/org/springframework/boot/spring-boot-cli/ rel=noopener target=_blank>snapshot distributions</a>也可用。<p>下载完成后，请按照解压后的存档中的<a href=https://raw.github.com/spring-projects/spring-boot/v2.1.1.RELEASE/spring-boot-project/spring-boot-cli/src/main/content/INSTALL.txt rel=noopener target=_blank>INSTALL.txt</a>说明进行操作。总之，在<code>.zip</code>文件的<code>bin/</code>目录中有一个<code>spring</code>脚本(对于 Windows 是<code>spring.bat</code>)。或者，您可以将<code>java -jar</code>与<code>.jar</code>文件一起使用(脚本可帮助您确保正确设置了 Classpath)。<h4 id=1-3-2-2、使用SDKMAN安装><a class=headerlink href=#1-3-2-2、使用SDKMAN安装 title=1.3.2.2、使用SDKMAN安装></a>1.3.2.2、使用SDKMAN安装</h4><p>SDKMAN！ (软件开发工具包 Management 器)可用于 Management 各种二进制 SDK 的多个版本，包括 Groovy 和 Spring Boot CLI。获取 SDKMAN！从<a href=http://sdkman.io/ rel=noopener target=_blank>sdkman.io</a>开始，并使用以下命令安装 Spring Boot：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>sdk install springboot</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring --version</span></span><br><span class=line>Spring Boot v2.1.1.RELEASE</span><br></pre></table></figure><p>如果您为 CLI 开发功能并希望轻松访问所构建的版本，请使用以下命令：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>sdk install springboot dev /path/to/spring-boot/spring-boot-cli/target/spring-boot-cli-2.1.1.RELEASE-bin/spring-2.1.1.RELEASE/</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>sdk default springboot dev</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring --version</span></span><br><span class=line>Spring CLI v2.1.1.RELEASE</span><br></pre></table></figure><p>前面的说明将安装称为<code>dev</code>实例的<code>spring</code>本地实例。它指向您的目标构建位置，因此，每次重建 Spring Boot 时，<code>spring</code>都是最新的。<p>您可以通过运行以下命令来查看它：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>sdk <span class=built_in>ls</span> springboot</span></span><br><span class=line></span><br><span class=line>================================================================================</span><br><span class=line>Available Springboot Versions</span><br><span class=line>================================================================================</span><br><span class=line><span class="meta prompt_">> </span><span class=language-bash>+ dev</span></span><br><span class=line>* 2.1.1.RELEASE</span><br><span class=line></span><br><span class=line>================================================================================</span><br><span class=line>+ - local version</span><br><span class=line>* - installed</span><br><span class=line><span class="meta prompt_">> </span><span class=language-bash>- currently <span class=keyword>in</span> use</span></span><br><span class=line>================================================================================</span><br></pre></table></figure><h4 id=1-3-2-3、OSX-Homebrew安装><a title="1.3.2.3、OSX Homebrew安装" class=headerlink href=#1-3-2-3、OSX-Homebrew安装></a>1.3.2.3、OSX Homebrew安装</h4><p>如果您使用的是 Mac 并使用<a href=https://brew.sh/ rel=noopener target=_blank>Homebrew</a>，则可以使用以下命令安装 Spring Boot CLI：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>brew tap pivotal/tap</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>brew install springboot</span></span><br></pre></table></figure><p>自制软件将<code>spring</code>安装到<code>/usr/local/bin</code>。<h4 id=1-3-2-4、MacPorts安装><a class=headerlink href=#1-3-2-4、MacPorts安装 title=1.3.2.4、MacPorts安装></a>1.3.2.4、MacPorts安装</h4><p>如果您使用的是 Mac 并使用<a href=https://www.macports.org/ rel=noopener target=_blank>MacPorts</a>，则可以使用以下命令安装 Spring Boot CLI：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>sudo</span> port install spring-boot-cli</span></span><br></pre></table></figure><h4 id=1-3-2-5、命令行完成><a class=headerlink href=#1-3-2-5、命令行完成 title=1.3.2.5、命令行完成></a>1.3.2.5、命令行完成</h4><p>Spring Boot CLI 包括为<a href=https://en.wikipedia.org/wiki/Bash_(Unix_shell) rel=noopener target=_blank>BASH</a>和<a href=https://en.wikipedia.org/wiki/Z_shell rel=noopener target=_blank>zsh</a> Shell 提供命令完成的脚本。您可以在任何 shell 中<code>source</code>脚本(也称为<code>spring</code>)或将其放入个人或系统范围的 bash 完成初始化中。在 Debian 系统上，系统级脚本位于<code>/shell-completion/bash</code>中，并且在启动新 Shell 时将执行该目录中的所有脚本。例如，如果您是使用 SDKMAN！安装的，则要手动运行脚本，请使用以下命令：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>. ~/.sdkman/candidates/springboot/current/shell-completion/bash/spring</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring &LTHIT TAB HERE></span></span><br><span class=line>  grab  help  jar  run  test  version</span><br></pre></table></figure><blockquote><p>如果您使用 Homebrew 或 MacPorts 安装 Spring Boot CLI，则命令行完成脚本会自动注册到您的 Shell 中。</blockquote><h4 id=1-3-2-6、Windows-Scoop安装><a title="1.3.2.6、Windows Scoop安装" class=headerlink href=#1-3-2-6、Windows-Scoop安装></a>1.3.2.6、Windows Scoop安装</h4><p>如果您使用的是 Windows 并使用<a href=http://scoop.sh/ rel=noopener target=_blank>Scoop</a>，则可以使用以下命令安装 Spring Boot CLI：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">> </span><span class=language-bash>scoop bucket add extras</span></span><br><span class=line><span class="meta prompt_">> </span><span class=language-bash>scoop install springboot</span></span><br></pre></table></figure><p>Scoop 将<code>spring</code>安装到<code>~/scoop/apps/springboot/current/bin</code>。<blockquote><p>如果您没有看到应用 Lists，则可能是因为瓢的安装已过期。在这种情况下，请运行<code>scoop update</code>，然后重试。</blockquote><h4 id=1-3-2-7、快速Starter-Spring-CLI示例><a title="1.3.2.7、快速Starter Spring CLI示例" class=headerlink href=#1-3-2-7、快速Starter-Spring-CLI示例></a>1.3.2.7、快速Starter Spring CLI示例</h4><p>您可以使用以下 Web 应用程序来测试安装。首先，创建一个名为<code>app.groovy</code>的文件，如下所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>@RestController</span><br><span class=line>class ThisWillActuallyRun {</span><br><span class=line></span><br><span class=line>	@RequestMapping("/")</span><br><span class=line>	String home() {</span><br><span class=line>		"Hello World!"</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><p>然后从 Shell 运行它，如下所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring run app.groovy</span></span><br></pre></table></figure><p>在您喜欢的网络浏览器中打开<code>localhost:8080</code>。您应该看到以下输出：<figure class="highlight text"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>Hello World!</span><br></pre></table></figure><h3 id=1-3-3、早期版本-Spring-Boot-升级><a title="1.3.3、早期版本 Spring Boot 升级" class=headerlink href=#1-3-3、早期版本-Spring-Boot-升级></a>1.3.3、早期版本 Spring Boot 升级</h3><p>如果您要从较早版本的 Spring Boot 升级，请检查<a href=https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide rel=noopener target=_blank>项目 Wiki 上的“迁移指南”</a>，其中提供了详细的升级说明。还要在<a href=https://github.com/spring-projects/spring-boot/wiki rel=noopener target=_blank>“release notes”</a>上查看每个版本的“新功能和值得注意的”功能列表。<p>升级到新功能版本时，某些属性可能已被重命名或删除。 Spring Boot 提供了一种在启动时分析应用程序环境并打印诊断的方法，而且还可以在运行时为您临时迁移属性。要启用该功能，请将以下依赖项添加到您的项目中：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>spring-boot-properties-migrator<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>scope</span>></span>runtime<span class=tag>&LT/<span class=name>scope</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><blockquote><p>注意：较晚添加到环境的属性(例如使用<code>@PropertySource</code>时)将不被考虑。<p>迁移完成后，请确保从项目的依赖项中删除此模块。</blockquote><p>要升级现有的 CLI 安装，请使用适当的程序包 Management 器命令(例如<code>brew upgrade</code>)，或者，如果手动安装了 CLI，请遵循<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/getting-started-installing-spring-boot.html#getting-started-manual-cli-installation rel=noopener target=_blank>standard instructions</a>，记住要更新<code>PATH</code>环境变量以删除任何较旧的引用。<h2 id=1-4、第一个SpringBoot应用><a class=headerlink href=#1-4、第一个SpringBoot应用 title=1.4、第一个SpringBoot应用></a>1.4、第一个SpringBoot应用</h2><p>在开始之前，请打开终端并运行以下命令，以确保安装了有效的 Java 和 Maven 版本：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -version</span></span><br><span class=line>java version "1.8.0_102"</span><br><span class=line>Java(TM) SE Runtime Environment (build 1.8.0_102-b14)</span><br><span class=line>Java HotSpot(TM) 64-Bit Server VM (build 25.102-b14, mixed mode)</span><br></pre></table></figure><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>mvn -v</span></span><br><span class=line>Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-17T14:33:14-04:00)</span><br><span class=line>Maven home: /usr/local/Cellar/maven/3.3.9/libexec</span><br><span class=line>Java version: 1.8.0_102, vendor: Oracle Corporation</span><br></pre></table></figure><h3 id=1-4-1、创建POM><a class=headerlink href=#1-4-1、创建POM title=1.4.1、创建POM></a>1.4.1、创建POM</h3><p>我们需要先创建一个 Maven <code>pom.xml</code>文件。 <code>pom.xml</code>是用于构建项目的配方。打开您喜欢的文本编辑器并添加以下内容：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line>&LT?xml version="1.0" encoding="UTF-8"?></span><br><span class=line>&LTproject xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class=line>	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"></span><br><span class=line>	&LTmodelVersion>4.0.0&LT/modelVersion></span><br><span class=line></span><br><span class=line>	&LTgroupId>com.example&LT/groupId></span><br><span class=line>	&LTartifactId>myproject&LT/artifactId></span><br><span class=line>	&LTversion>0.0.1-SNAPSHOT&LT/version></span><br><span class=line></span><br><span class=line>	&LTparent></span><br><span class=line>		&LTgroupId>org.springframework.boot&LT/groupId></span><br><span class=line>		&LTartifactId>spring-boot-starter-parent&LT/artifactId></span><br><span class=line>		&LTversion>2.1.1.RELEASE&LT/version></span><br><span class=line>	&LT/parent></span><br><span class=line></span><br><span class=line>	&LT!-- Additional lines to be added here... --></span><br><span class=line></span><br><span class=line>&LT/project></span><br></pre></table></figure><p>上面的 Lists 应为您提供有效的构建。您可以通过运行<code>mvn package</code>进行测试(目前，您可以忽略“ jar 将为空-没有内容被标记为包含！”警告)。<h3 id=1-4-2、添加Classpath依赖项><a class=headerlink href=#1-4-2、添加Classpath依赖项 title=1.4.2、添加Classpath依赖项></a>1.4.2、添加Classpath依赖项</h3><p>Spring Boot 提供了许多“启动器”，使您可以将 jar 添加到 Classpath 中。我们的示例应用程序已经在 POM 的<code>parent</code>部分中使用了<code>spring-boot-starter-parent</code>。 <code>spring-boot-starter-parent</code>是一个特殊的启动器，提供有用的 Maven 默认值。它还提供了一个<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#using-boot-dependency-management rel=noopener target=_blank>dependency-management</a>部分，以便您可以省略<code>version</code>标签来表示“受祝福的”依赖关系。<p>其他“Starter”提供了开发特定类型的应用程序时可能需要的依赖项。由于我们正在开发 Web 应用程序，因此我们添加了<code>spring-boot-starter-web</code>依赖项。在此之前，我们可以通过运行以下命令来查看当前的状态：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>mvn dependency:tree</span></span><br><span class=line></span><br><span class=line>[INFO] com.example:myproject:jar:0.0.1-SNAPSHOT</span><br></pre></table></figure><p><code>mvn dependency:tree</code>命令显示项目依赖项的树形表示。您可以看到<code>spring-boot-starter-parent</code>本身不提供任何依赖关系。要添加必要的依赖性，请编辑<code>pom.xml</code>并将<code>spring-boot-starter-web</code>依赖性添加在<code>parent</code>部分的正下方：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>	<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>		<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>		<span class=tag><<span class=name>artifactId</span>></span>spring-boot-starter-web<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencies</span>></span></span><br></pre></table></figure><p>如果再次运行<code>mvn dependency:tree</code>，则会看到现在还有许多其他依赖项，包括 Tomcat Web 服务器和 Spring Boot 本身。<h3 id=1-4-3、编写代码><a class=headerlink href=#1-4-3、编写代码 title=1.4.3、编写代码></a>1.4.3、编写代码</h3><p>要完成我们的应用程序，我们需要创建一个 Java 文件。默认情况下，Maven 从<code>src/main/java</code>编译源代码，因此您需要创建该文件夹结构，然后添加名为<code>src/main/java/Example.java</code>的文件以包含以下代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.boot.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.autoconfigure.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.web.bind.annotation.*;</span><br><span class=line></span><br><span class=line><span class=meta>@RestController</span></span><br><span class=line><span class=meta>@EnableAutoConfiguration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Example</span> {</span><br><span class=line>	<span class=meta>@RequestMapping("/")</span></span><br><span class=line>	String <span class="title function_">home</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=string>"Hello World!"</span>;</span><br><span class=line>	}</span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		SpringApplication.run(Example.class, args);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>尽管这里没有太多代码，但正在进行很多工作。我们将在接下来的几节中逐步介绍重要部分。<h4 id=1-4-3-1、-RestController-和-RequestMapping-注解><a title="1.4.3.1、@RestController 和@RequestMapping 注解" class=headerlink href=#1-4-3-1、-RestController-和-RequestMapping-注解></a>1.4.3.1、@RestController 和@RequestMapping 注解</h4><p>我们的<code>Example</code>类的第一个 Comments 是<code>@RestController</code>。这称为“定型”Comments。它为阅读代码的人和 Spring 提供了提示，提示该类起特定作用。在这种情况下，我们的类是一个 Web <code>@Controller</code>，因此 Spring 在处理传入的 Web 请求时会考虑使用它。<p><code>@RequestMapping</code>注解提供“路由”信息。它告诉 Spring，任何带有<code>/</code>路径的 HTTP 请求都应 Map 到<code>home</code>方法。 <code>@RestController</code>Comments 告诉 Spring 将结果字符串直接渲染回调用方。<blockquote><p><code>@RestController</code>和<code>@RequestMapping</code>Comments 是 Spring MVC Comments。 (它们并非特定于 Spring Boot.)有关更多详细信息，请参见 Spring 参考文档中的<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc rel=noopener target=_blank>MVC section</a>。</blockquote><h4 id=1-4-3-2、-EnableAutoConfiguration-注解><a title="1.4.3.2、@EnableAutoConfiguration 注解" class=headerlink href=#1-4-3-2、-EnableAutoConfiguration-注解></a>1.4.3.2、@EnableAutoConfiguration 注解</h4><p>第二个类级别的 Comments 是<code>@EnableAutoConfiguration</code>。这个 Comments 告诉 Spring Boot 根据所添加的 jar 依赖关系“猜测”您如何配置 Spring。由于<code>spring-boot-starter-web</code>添加了 Tomcat 和 Spring MVC，因此自动配置假定您正在开发 Web 应用程序并相应地设置 Spring。<blockquote><p>自动配置旨在与“启动器”配合使用，但是这两个概念并不直接相关。您可以自由选择启动器之外的 jar 依赖项。 Spring Boot 仍会尽其所能自动配置您的应用程序。</blockquote><h4 id=1-4-3-3、main方法><a class=headerlink href=#1-4-3-3、main方法 title=1.4.3.3、main方法></a>1.4.3.3、main方法</h4><p>我们应用程序的最后一部分是<code>main</code>方法。这只是遵循 Java 约定的应用程序入口点的标准方法。我们的 main 方法通过调用<code>run</code>委托给 Spring Boot 的<code>SpringApplication</code>类。 <code>SpringApplication</code>引导我们的应用程序，启动 Spring，该应用程序反过来又启动自动配置的 Tomcat Web 服务器。我们需要将<code>Example.class</code>作为参数传递给<code>run</code>方法，以告诉<code>SpringApplication</code>是主要的 Spring 组件。还将传递<code>args</code>数组以公开任何命令行参数。<h3 id=1-4-4、创建一个可执行Jar><a class=headerlink href=#1-4-4、创建一个可执行Jar title=1.4.4、创建一个可执行Jar></a>1.4.4、创建一个可执行Jar</h3><p>通过创建一个可以在生产环境中运行的完全独立的可执行 jar 文件来结束示例。可执行 jar(有时称为“胖 jar”)是包含您的已编译类以及代码需要运行的所有 jar 依赖项的归档文件。<p>要创建可执行 jar，我们需要将<code>spring-boot-maven-plugin</code>添加到<code>pom.xml</code>。为此，请在<code>dependencies</code>部分的下面插入以下行：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>build</span>></span></span><br><span class=line>	<span class=tag><<span class=name>plugins</span>></span></span><br><span class=line>		<span class=tag><<span class=name>plugin</span>></span></span><br><span class=line>			<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>artifactId</span>></span>spring-boot-maven-plugin<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>plugin</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>plugins</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>build</span>></span></span><br></pre></table></figure><blockquote><p><code>spring-boot-starter-parent</code> POM 包含<code>&LTexecutions></code>配置以绑定<code>repackage</code>目标。如果不使用父 POM，则需要自己声明此配置。有关详情，请参见<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/maven-plugin/usage.html rel=noopener target=_blank>plugin documentation</a>。</blockquote><p>保存您的<code>pom.xml</code>并从命令行运行<code>mvn package</code>，如下所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>mvn package</span></span><br><span class=line></span><br><span class=line>[INFO] Scanning for projects...</span><br><span class=line>[INFO]</span><br><span class=line>[INFO] ------------------------------------------------------------------------</span><br><span class=line>[INFO] Building myproject 0.0.1-SNAPSHOT</span><br><span class=line>[INFO] ------------------------------------------------------------------------</span><br><span class=line>[INFO] .... ..</span><br><span class=line>[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject ---</span><br><span class=line>[INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar</span><br><span class=line>[INFO]</span><br><span class=line>[INFO] --- spring-boot-maven-plugin:2.1.1.RELEASE:repackage (default) @ myproject ---</span><br><span class=line>[INFO] ------------------------------------------------------------------------</span><br><span class=line>[INFO] BUILD SUCCESS</span><br><span class=line>[INFO] ------------------------------------------------------------------------</span><br></pre></table></figure><p>如果查看<code>target</code>目录，应该会看到<code>myproject-0.0.1-SNAPSHOT.jar</code>。该文件的大小应为 10 MB 左右。如果您想窥视内部，可以使用<code>jar tvf</code>，如下所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>jar tvf target/myproject-0.0.1-SNAPSHOT.jar</span></span><br></pre></table></figure><p>您还应该在<code>target</code>目录中看到一个名为<code>myproject-0.0.1-SNAPSHOT.jar.original</code>的小得多的文件。这是 Maven 在 Spring Boot 重新打包之前创建的原始 jar 文件。<p>要运行该应用程序，请使用<code>java -jar</code>命令，如下所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -jar target/myproject-0.0.1-SNAPSHOT.jar</span></span><br><span class=line></span><br><span class=line>  .   ____          _            __ _ _</span><br><span class=line> /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class=line>( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \</span><br><span class=line> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class=line>  '  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class=line> =========|_|==============|___/=/_/_/_/</span><br><span class=line> :: Spring Boot ::  (v2.1.1.RELEASE)</span><br><span class=line>....... . . .</span><br><span class=line>....... . . . (log output here)</span><br><span class=line>....... . . .</span><br><span class=line>........ Started Example in 2.536 seconds (JVM running for 2.864)</span><br></pre></table></figure><p>和以前一样，要退出该应用程序，请按<code>ctrl-c</code>。<h1 id=2、使用Spring-Boot><a title="2、使用Spring Boot" class=headerlink href=#2、使用Spring-Boot></a>2、使用Spring Boot</h1><h2 id=2-1、Build-Systems><a title="2.1、Build Systems" class=headerlink href=#2-1、Build-Systems></a>2.1、Build Systems</h2><p>强烈建议您选择一个支持<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#using-boot-dependency-management rel=noopener target=_blank>dependency management</a>并且可以使用发布到“ Maven Central”存储库的工件的构建系统。我们建议您选择 Maven 或 Gradle。<h3 id=2-1-1、依赖性Management><a class=headerlink href=#2-1-1、依赖性Management title=2.1.1、依赖性Management></a>2.1.1、依赖性Management</h3><p>每个 Spring Boot 版本都提供了它支持的精选依赖列表。实际上，您不需要为构建配置中的所有这些依赖项提供版本，因为 Spring Boot 会为您 Management 版本。当您升级 Spring Boot 本身时，这些依赖项也会以一致的方式升级。<p>精选列表包含可与 Spring Boot 一起使用的所有 spring 模块以及精炼的第三方库列表。该列表作为标准<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#using-boot-maven-without-a-parent rel=noopener target=_blank>物料 Lists(Spring 引导相关性)</a>可用，可以与<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#using-boot-maven-parent-pom rel=noopener target=_blank>Maven</a>和<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#using-boot-gradle rel=noopener target=_blank>Gradle</a>一起使用。<blockquote><p>每个 Spring Boot 版本都与 Spring Framework 的基本版本相关联。我们强烈建议您不要指定其版本。</blockquote><h3 id=2-1-2、Maven><a class=headerlink href=#2-1-2、Maven title=2.1.2、Maven></a>2.1.2、Maven</h3><p>Maven 用户可以从<code>spring-boot-starter-parent</code>项目继承来获取合理的默认值。父项目提供以下功能：<ul><li>Java 1.8 是默认的编译器级别。<li>UTF-8 源编码。<li>继承自 spring-boot-dependencies pom 的<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#using-boot-dependency-management rel=noopener target=_blank>依赖性 Management 部分</a>，用于 Management 常见依赖项的版本。当在您自己的 pom 中使用这些依赖关系时，可以为这些依赖关系省略标记。<li>带有<code>repackage</code>执行 ID 的<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/maven-plugin/repackage-mojo.html rel=noopener target=_blank>repackage goal</a>的执行。<li>Sensible <a href=https://maven.apache.org/plugins/maven-resources-plugin/examples/filter.html rel=noopener target=_blank>resource filtering</a>.<li>合理的插件配置(<a href=https://www.mojohaus.org/exec-maven-plugin/ rel=noopener target=_blank>exec plugin</a>，<a href=https://github.com/ktoso/maven-git-commit-id-plugin rel=noopener target=_blank>Git 提交 ID</a>和<a href=https://maven.apache.org/plugins/maven-shade-plugin/ rel=noopener target=_blank>shade</a>)。<li><code>application.properties</code>和<code>application.yml</code>的敏感资源过滤，包括特定于配置文件的文件(例如<code>application-dev.properties</code>和<code>application-dev.yml</code>)</ul><p>请注意，由于<code>application.properties</code>和<code>application.yml</code>文件接受 Spring 样式占位符(<code>${…}</code>)，因此 Maven 过滤已更改为使用<code>@[email protected]</code>占位符。 (您可以通过设置名为<code>resource.delimiter</code>的 Maven 属性来覆盖它.)<h4 id=2-1-2-1、继承Starter-Parent><a title="2.1.2.1、继承Starter Parent" class=headerlink href=#2-1-2-1、继承Starter-Parent></a>2.1.2.1、继承Starter Parent</h4><p>要将项目配置为从<code>spring-boot-starter-parent</code>继承，请设置<code>parent</code>，如下所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- Inherit defaults from Spring Boot --></span></span><br><span class=line><span class=tag><<span class=name>parent</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>spring-boot-starter-parent<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>version</span>></span>2.1.1.RELEASE<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>parent</span>></span></span><br></pre></table></figure><blockquote><p>您只需要为此依赖项指定 Spring Boot 版本号。如果导入其他启动器，则可以安全地省略版本号。</blockquote><p>使用该设置，您还可以通过覆盖自己项目中的属性来覆盖各个依赖项。例如，要升级到另一个 Spring Data 发布系列，可以将以下内容添加到<code>pom.xml</code>：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>properties</span>></span></span><br><span class=line>	<span class=tag><<span class=name>spring-data-releasetrain.version</span>></span>Fowler-SR2<span class=tag>&LT/<span class=name>spring-data-releasetrain.version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>properties</span>></span></span><br></pre></table></figure><h4 id=2-1-2-2、在没有父-POM-的情况下使用-Spring-Boot><a title="2.1.2.2、在没有父 POM 的情况下使用 Spring Boot" class=headerlink href=#2-1-2-2、在没有父-POM-的情况下使用-Spring-Boot></a>2.1.2.2、在没有父 POM 的情况下使用 Spring Boot</h4><p>并非每个人都喜欢从<code>spring-boot-starter-parent</code> POM 继承。您可能需要使用自己的公司标准父级，或者可能希望显式声明所有 Maven 配置。<p>如果您不想使用<code>spring-boot-starter-parent</code>，仍然可以通过使用<code>scope=import</code>依赖项来保留依赖项 Management(而不是插件 Management)的好处，如下所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependencyManagement</span>></span></span><br><span class=line>	<span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>		<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>			<span class=comment>&LT!-- Import dependency management from Spring Boot --></span></span><br><span class=line>			<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>artifactId</span>></span>spring-boot-dependencies<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>version</span>></span>2.1.1.RELEASE<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>			<span class=tag><<span class=name>type</span>></span>pom<span class=tag>&LT/<span class=name>type</span>></span></span><br><span class=line>			<span class=tag><<span class=name>scope</span>></span>import<span class=tag>&LT/<span class=name>scope</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>dependencies</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencyManagement</span>></span></span><br></pre></table></figure><p>如上所述，前面的示例设置不允许您使用属性来覆盖各个依赖项。为了获得相同的结果，您需要在项目的<code>dependencyManagement</code> <strong>之前</strong> 在<code>spring-boot-dependencies</code>条目之前添加一个条目。例如，要升级到另一个 Spring Data 发布系列，可以将以下元素添加到<code>pom.xml</code>：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependencyManagement</span>></span></span><br><span class=line>	<span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>		<span class=comment>&LT!-- Override Spring Data release train provided by Spring Boot --></span></span><br><span class=line>		<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>			<span class=tag><<span class=name>groupId</span>></span>org.springframework.data<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>artifactId</span>></span>spring-data-releasetrain<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>version</span>></span>Fowler-SR2<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>			<span class=tag><<span class=name>type</span>></span>pom<span class=tag>&LT/<span class=name>type</span>></span></span><br><span class=line>			<span class=tag><<span class=name>scope</span>></span>import<span class=tag>&LT/<span class=name>scope</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>		<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>			<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>artifactId</span>></span>spring-boot-dependencies<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>version</span>></span>2.1.1.RELEASE<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>			<span class=tag><<span class=name>type</span>></span>pom<span class=tag>&LT/<span class=name>type</span>></span></span><br><span class=line>			<span class=tag><<span class=name>scope</span>></span>import<span class=tag>&LT/<span class=name>scope</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>dependencies</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencyManagement</span>></span></span><br></pre></table></figure><h4 id=2-1-2-3、使用Spring-Boot-Maven插件><a title="2.1.2.3、使用Spring Boot Maven插件" class=headerlink href=#2-1-2-3、使用Spring-Boot-Maven插件></a>2.1.2.3、使用Spring Boot Maven插件</h4><p>Spring Boot 包含一个<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/build-tool-plugins-maven-plugin.html rel=noopener target=_blank>Maven plugin</a>，可以将项目打包为可执行 jar。如果要使用插件，请将其添加到<code>&LTplugins></code>部分，如以下示例所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>build</span>></span></span><br><span class=line>	<span class=tag><<span class=name>plugins</span>></span></span><br><span class=line>		<span class=tag><<span class=name>plugin</span>></span></span><br><span class=line>			<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>artifactId</span>></span>spring-boot-maven-plugin<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>plugin</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>plugins</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>build</span>></span></span><br></pre></table></figure><blockquote><p>如果您使用 Spring Boot 启动器的父 pom，则只需添加插件。除非您要更改父级中定义的设置，否则无需对其进行配置。</blockquote><h3 id=2-1-3、Gradle><a class=headerlink href=#2-1-3、Gradle title=2.1.3、Gradle></a>2.1.3、Gradle</h3><p>要了解有关将 Spring Boot 与 Gradle 结合使用的信息，请参阅 Spring Boot 的 Gradle 插件的文档：<ul><li>参考(<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/gradle-plugin/reference/html rel=noopener target=_blank>HTML</a>和<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/gradle-plugin/reference/pdf/spring-boot-gradle-plugin-reference.pdf rel=noopener target=_blank>PDF</a>)<li><a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/gradle-plugin/api rel=noopener target=_blank>API</a></ul><h3 id=2-1-4、Ant><a class=headerlink href=#2-1-4、Ant title=2.1.4、Ant></a>2.1.4、Ant</h3><p>可以使用 Apache Ant Ivy 构建 Spring Boot 项目。 <code>spring-boot-antlib</code>“ AntLib”模块也可用于帮助 Ant 创建可执行 jar。<p>要声明依赖关系，典型的<code>ivy.xml</code>文件看起来类似于以下示例：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>&LTivy-module version="2.0"></span><br><span class=line>	&LTinfo organisation="org.springframework.boot" module="spring-boot-sample-ant" /></span><br><span class=line>	&LTconfigurations></span><br><span class=line>		&LTconf name="compile" description="everything needed to compile this module" /></span><br><span class=line>		&LTconf name="runtime" extends="compile" description="everything needed to run this module" /></span><br><span class=line>	&LT/configurations></span><br><span class=line>	&LTdependencies></span><br><span class=line>		&LTdependency org="org.springframework.boot" name="spring-boot-starter"</span><br><span class=line>			rev="${spring-boot.version}" conf="compile" /></span><br><span class=line>	&LT/dependencies></span><br><span class=line>&LT/ivy-module></span><br></pre></table></figure><p>典型的<code>build.xml</code>类似于以下示例：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br></pre><td class=code><pre><span class=line>&LTproject</span><br><span class=line>	xmlns:ivy="antlib:org.apache.ivy.ant"</span><br><span class=line>	xmlns:spring-boot="antlib:org.springframework.boot.ant"</span><br><span class=line>	name="myapp" default="build"></span><br><span class=line></span><br><span class=line>	&LTproperty name="spring-boot.version" value="2.1.1.RELEASE" /></span><br><span class=line></span><br><span class=line>	&LTtarget name="resolve" description="--> retrieve dependencies with ivy"></span><br><span class=line>		&LTivy:retrieve pattern="lib/[conf]/[artifact]-[type]-[revision].[ext]" /></span><br><span class=line>	&LT/target></span><br><span class=line></span><br><span class=line>	&LTtarget name="classpaths" depends="resolve"></span><br><span class=line>		&LTpath id="compile.classpath"></span><br><span class=line>			&LTfileset dir="lib/compile" includes="*.jar" /></span><br><span class=line>		&LT/path></span><br><span class=line>	&LT/target></span><br><span class=line></span><br><span class=line>	&LTtarget name="init" depends="classpaths"></span><br><span class=line>		&LTmkdir dir="build/classes" /></span><br><span class=line>	&LT/target></span><br><span class=line></span><br><span class=line>	&LTtarget name="compile" depends="init" description="compile"></span><br><span class=line>		&LTjavac srcdir="src/main/java" destdir="build/classes" classpathref="compile.classpath" /></span><br><span class=line>	&LT/target></span><br><span class=line></span><br><span class=line>	&LTtarget name="build" depends="compile"></span><br><span class=line>		&LTspring-boot:exejar destfile="build/myapp.jar" classes="build/classes"></span><br><span class=line>			&LTspring-boot:lib></span><br><span class=line>				&LTfileset dir="lib/runtime" /></span><br><span class=line>			&LT/spring-boot:lib></span><br><span class=line>		&LT/spring-boot:exejar></span><br><span class=line>	&LT/target></span><br><span class=line>&LT/project></span><br></pre></table></figure><h3 id=2-1-5、Starters><a class=headerlink href=#2-1-5、Starters title=2.1.5、Starters></a>2.1.5、Starters</h3><p>Starter 程序是一组方便的依赖项 Descriptors，您可以在应用程序中包括它们。您可以一站式购买所需的所有 Spring 和相关技术，而不必遍历示例代码和依赖 Descriptors 的复制粘贴负载。例如，如果要开始使用 Spring 和 JPA 进行数据库访问，请在项目中包括<code>spring-boot-starter-data-jpa</code>依赖项。<p>Starter 程序包含许多启动项目并快速运行所需的依赖项，并且具有一组受支持的受管传递性依赖项。<blockquote><p>所有“官方”Starter 者都遵循类似的命名方式； <code>spring-boot-starter-*</code>，其中<code>*</code>是特定类型的应用程序。这种命名结构旨在在您需要寻找 Starter 者时提供帮助。许多 IDE 中的 Maven 集成使您可以按名称搜索依赖项。例如，在安装了适当的 Eclipse 或 STS 插件的情况下，您可以在 POM 编辑器中按<code>ctrl-space</code>并键入“ spring-boot-starter”以获取完整列表。<p>如“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-auto-configuration.html#boot-features-custom-starter rel=noopener target=_blank>创建自己的 Starter</a>”部分中所述，第三方启动程序不应以<code>spring-boot</code>开头，因为它是为官方 Spring Boot 工件保留的。而是，第三方启动程序通常以项目名称开头。例如，一个名为<code>thirdpartyproject</code>的第三方启动程序项目通常会被命名为<code>thirdpartyproject-spring-boot-starter</code>。</blockquote><p>Spring Boot 在<code>org.springframework.boot</code>组下提供了以下应用程序启动器：<p><strong>表 13.1. Spring Boot 应用程序启动器</strong><table><thead><tr><th>Name<th>Description<th>Pom<tbody><tr><td><code>spring-boot-starter</code><td>核心 Starter 工具，包括自动配置支持，日志记录和 YAML<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-activemq</code><td>使用 Apache ActiveMQ 的 JMS 消息传递 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-activemq/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-amqp</code><td>使用 Spring AMQP 和 Rabbit MQ 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-amqp/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-aop</code><td>使用 Spring AOP 和 AspectJ 进行面向方面编程的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-aop/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-artemis</code><td>使用 Apache Artemis 的 JMS 消息传递 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-artemis/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-batch</code><td>使用 Spring Batch 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-batch/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-cache</code><td>使用 Spring Framework 的缓存支持的 Starter 者<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-cache/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-cloud-connectors</code><td>使用 Spring Cloud Connectors 的 Starter 程序，可简化与 Cloud Foundry 和 Heroku 等云平台中服务的连接<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-cloud-connectors/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-cassandra</code><td>使用 Cassandra 分布式数据库和 Spring Data Cassandra 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-cassandra/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-cassandra-reactive</code><td>使用 Cassandra 分布式数据库和 Spring Data Cassandra Reactive 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-cassandra-reactive/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-couchbase</code><td>使用 Couchbase 面向文档的数据库和 Spring Data Couchbase 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-couchbase/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-couchbase-reactive</code><td>使用 Couchbase 面向文档的数据库和 Spring Data Couchbase Reactive 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-couchbase-reactive/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-elasticsearch</code><td>使用 Elasticsearch 搜索和分析引擎以及 Spring Data Elasticsearch 的 Starter 者<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-elasticsearch/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-jdbc</code><td>使用 Spring Data JDBC 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-jdbc/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-jpa</code><td>将 Spring Data JPA 与 Hibernate 结合使用的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-jpa/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-ldap</code><td>使用 Spring Data LDAP 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-ldap/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-mongodb</code><td>使用 MongoDB 面向文档的数据库和 Spring Data MongoDB 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-mongodb/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-mongodb-reactive</code><td>使用 MongoDB 面向文档的数据库和 Spring Data MongoDB Reactive 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-mongodb-reactive/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-neo4j</code><td>使用 Neo4j 图形数据库和 Spring Data Neo4j 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-neo4j/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-redis</code><td>使用 Redis 键值数据存储与 Spring Data Redis 和 Lettuce Client 端的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-redis/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-redis-reactive</code><td>将 Redis 键值数据存储与 Spring Data Redis Reacting 和 Lettuce Client 端一起使用的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-redis-reactive/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-rest</code><td>使用 Spring Data REST 在 REST 上公开 Spring Data 存储库的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-rest/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-solr</code><td>结合使用 Apache Solr 搜索平台和 Spring Data Solr 的 Starter 者<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-solr/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-freemarker</code><td>使用 FreeMarker 视图构建 MVC Web 应用程序的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-freemarker/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-groovy-templates</code><td>使用 Groovy 模板视图构建 MVC Web 应用程序的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-groovy-templates/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-hateoas</code><td>使用 Spring MVC 和 Spring HATEOAS 构建基于超媒体的 RESTful Web 应用程序的 Starter 者<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-hateoas/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-integration</code><td>使用 Spring Integration 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-integration/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-jdbc</code><td>结合使用 JDBC 和 HikariCP 连接池的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jdbc/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-jersey</code><td>使用 JAX-RS 和 Jersey 构建 RESTful Web 应用程序的 Starter。 <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#spring-boot-starter-web rel=noopener target=_blank>spring-boot-starter-web</a>的替代品<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jersey/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-jooq</code><td>使用 jOOQ 访问 SQL 数据库的 Starter。替代<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#spring-boot-starter-data-jpa rel=noopener target=_blank>spring-boot-starter-data-jpa</a>或<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#spring-boot-starter-jdbc rel=noopener target=_blank>spring-boot-starter-jdbc</a><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jooq/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-json</code><td>读写 JSON Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-json/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-jta-atomikos</code><td>使用 Atomikos 的 JTATransactionStarter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jta-atomikos/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-jta-bitronix</code><td>使用 Bitronix 的 JTATransactionStarter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jta-bitronix/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-mail</code><td>开始使用 Java Mail 和 Spring Framework 的电子邮件发送支持<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-mail/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-mustache</code><td>使用 Mustache 视图构建 Web 应用程序的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-mustache/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-oauth2-client</code><td>使用 Spring Security 的 OAuth2/OpenID Connect Client 端功能的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-oauth2-client/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-oauth2-resource-server</code><td>使用 Spring Security 的 OAuth2 资源服务器功能的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-oauth2-resource-server/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-quartz</code><td>Starter 使用 Quartz Scheduler<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-quartz/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-security</code><td>使用 Spring Security 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-security/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-test</code><td>用于使用包括 JUnit，Hamcrest 和 Mockito 在内的库测试 Spring Boot 应用程序的 Starter 程序<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-test/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-thymeleaf</code><td>使用 Thymeleaf 视图构建 MVC Web 应用程序的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-thymeleaf/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-validation</code><td>通过 Hibernate Validator 使用 Java Bean 验证的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-validation/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-web</code><td>使用 Spring MVC 构建 Web(包括 RESTful)应用程序的 Starter 者。使用 Tomcat 作为默认的嵌入式容器<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-web/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-web-services</code><td>使用 Spring Web Services 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-web-services/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-webflux</code><td>使用 Spring Framework 的反应式 Web 支持构建 WebFlux 应用程序的 Starter 者<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-webflux/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-websocket</code><td>使用 Spring Framework 的 WebSocket 支持构建 WebSocket 应用程序的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-websocket/pom.xml rel=noopener target=_blank>Pom</a></table><p>除应用程序启动程序外，以下启动程序还可用于添加* <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready.html rel=noopener target=_blank>production ready</a> *功能：<p><strong>表 13.2 Spring Boot 生产启动器</strong><table><thead><tr><th>Name<th>Description<th>Pom<tbody><tr><td><code>spring-boot-starter-actuator</code><td>使用 Spring Boot 的 Actuator 的 Starter 程序，它提供了生产就绪功能，可帮助您监视和 Management 应用程序<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-actuator/pom.xml rel=noopener target=_blank>Pom</a></table><p>最后，Spring Boot 还包括以下启动程序，如果您想排除或交换特定的技术方面，可以使用这些启动程序：<p><strong>表 13.3 Spring Boot 技术 Starter</strong><table><thead><tr><th>Name<th>Description<th>Pom<tbody><tr><td><code>spring-boot-starter-jetty</code><td>使用 Jetty 作为嵌入式 servlet 容器的 Starter 者。 <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#spring-boot-starter-tomcat rel=noopener target=_blank>spring-boot-starter-tomcat</a>的替代品<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jetty/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-log4j2</code><td>使用 Log4j2 进行日志记录的启动器。 <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#spring-boot-starter-logging rel=noopener target=_blank>spring-boot-starter-logging</a>的替代品<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-log4j2/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-logging</code><td>使用 Logback 进行日志记录的启动器。默认记录启动器<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-logging/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-reactor-netty</code><td>使用 Reactor Netty 作为嵌入式反应式 HTTP 服务器的 Starter 者。<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-reactor-netty/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-tomcat</code><td>使用 Tomcat 作为嵌入式 servlet 容器的 Starter。 <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#spring-boot-starter-web rel=noopener target=_blank>spring-boot-starter-web</a>使用的默认 servlet 容器启动器<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-tomcat/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-undertow</code><td>使用 Undertow 作为嵌入式 servlet 容器的 Starter。 <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#spring-boot-starter-tomcat rel=noopener target=_blank>spring-boot-starter-tomcat</a>的替代品<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-undertow/pom.xml rel=noopener target=_blank>Pom</a></table><h2 id=2-2、构建代码><a class=headerlink href=#2-2、构建代码 title=2.2、构建代码></a>2.2、构建代码</h2><p>Spring Boot 不需要任何特定的代码布局即可工作。但是，有一些最佳实践可以帮助您。<h3 id=2-2-1、使用-default-软件包><a title="2.2.1、使用 default 软件包" class=headerlink href=#2-2-1、使用-default-软件包></a>2.2.1、使用 default 软件包</h3><p>当一个类不包含<code>package</code>声明时，它将被视为在“默认包”中。通常不建议使用“默认程序包”，应避免使用。对于使用<code>@ComponentScan</code>，<code>@EntityScan</code>或<code>@SpringBootApplication</code>注解的 Spring Boot 应用程序，这可能会导致特定的问题，因为每个 jar 中的每个类都会被读取。<blockquote><p>我们建议您遵循 Java 建议的程序包命名约定，并使用反向域名(例如<code>com.example.project</code>)。</blockquote><h3 id=2-2-2、查找主应用程序类><a class=headerlink href=#2-2-2、查找主应用程序类 title=2.2.2、查找主应用程序类></a>2.2.2、查找主应用程序类</h3><p>我们通常建议您将主应用程序类放在其他类之上的根包中。 <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-using-springbootapplication-annotation.html rel=noopener target=_blank>@SpringBootApplication annotation</a>通常放在您的主类上，它隐式定义某些项目的基本“搜索包”。例如，如果您正在编写 JPA 应用程序，则使用<code>@SpringBootApplication</code>注解的类的包来搜索<code>@Entity</code>项。使用根软件包还允许组件扫描仅应用于您的项目。<p>以下 Lists 显示了典型的布局：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line>com</span><br><span class=line> +- example</span><br><span class=line>     +- myapplication</span><br><span class=line>         +- Application.java</span><br><span class=line>         |</span><br><span class=line>         +- customer</span><br><span class=line>         |   +- Customer.java</span><br><span class=line>         |   +- CustomerController.java</span><br><span class=line>         |   +- CustomerService.java</span><br><span class=line>         |   +- CustomerRepository.java</span><br><span class=line>         |</span><br><span class=line>         +- order</span><br><span class=line>             +- Order.java</span><br><span class=line>             +- OrderController.java</span><br><span class=line>             +- OrderService.java</span><br><span class=line>             +- OrderRepository.java</span><br></pre></table></figure><p><code>Application.java</code>文件将声明<code>main</code>方法以及基本的<code>@SpringBootApplication</code>，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.example.myapplication;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.boot.SpringApplication;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=line></span><br><span class=line><span class=meta>@SpringBootApplication</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Application</span> {</span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>		SpringApplication.run(Application.class, args);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h2 id=2-3、配置类><a class=headerlink href=#2-3、配置类 title=2.3、配置类></a>2.3、配置类</h2><p>Spring Boot 支持基于 Java 的配置。尽管可以将<code>SpringApplication</code>与 XML 源一起使用，但是我们通常建议您的主要源为单个<code>@Configuration</code>类。通常，定义<code>main</code>方法的类是主要<code>@Configuration</code>的不错的选择。<h3 id=2-3-1、导入其它配置类><a class=headerlink href=#2-3-1、导入其它配置类 title=2.3.1、导入其它配置类></a>2.3.1、导入其它配置类</h3><p>您无需将所有<code>@Configuration</code>都放在一个类中。 <code>@Import</code>注解可用于导入其他配置类。另外，您可以使用<code>@ComponentScan</code>自动拾取所有 Spring 组件，包括<code>@Configuration</code>类。<h3 id=2-3-2、导入XML配置><a class=headerlink href=#2-3-2、导入XML配置 title=2.3.2、导入XML配置></a>2.3.2、导入XML配置</h3><p>如果绝对必须使用基于 XML 的配置，我们建议您仍然从<code>@Configuration</code>类开始。然后，您可以使用<code>@ImportResource</code>注解来加载 XML 配置文件。<h2 id=2-4、Auto-configuration><a class=headerlink href=#2-4、Auto-configuration title=2.4、Auto-configuration></a>2.4、Auto-configuration</h2><p>Spring Boot 自动配置会尝试根据添加的 jar 依赖项自动配置 Spring 应用程序。例如，如果<code>HSQLDB</code>在 Classpath 上，并且您尚未手动配置任何数据库连接 bean，那么 Spring Boot 会自动配置内存数据库。<p>您需要通过向<code>@Configuration</code>类之一添加<code>@EnableAutoConfiguration</code>或<code>@SpringBootApplication</code>Comments 来选择自动配置。<blockquote><p>您只能添加一个<code>@SpringBootApplication</code>或<code>@EnableAutoConfiguration</code>Comments。通常，我们建议您仅将一个或另一个添加到主要的<code>@Configuration</code>类中。</blockquote><h3 id=2-4-1、逐步取代自动配置><a class=headerlink href=#2-4-1、逐步取代自动配置 title=2.4.1、逐步取代自动配置></a>2.4.1、逐步取代自动配置</h3><p>自动配置是非侵入性的。在任何时候，您都可以开始定义自己的配置，以替换自动配置的特定部分。例如，如果您添加自己的<code>DataSource</code> bean，则默认的嵌入式数据库支持将退出。<p>如果您需要找出当前正在应用的自动配置以及原因，请使用<code>--debug</code>开关启动您的应用程序。这样做可以启用调试日志以供选择核心 Logger，并将条件报告记录到控制台。<h3 id=2-4-2、禁用特定的自动配置类><a class=headerlink href=#2-4-2、禁用特定的自动配置类 title=2.4.2、禁用特定的自动配置类></a>2.4.2、禁用特定的自动配置类</h3><p>如果发现正在应用不需要的特定自动配置类，则可以使用<code>@EnableAutoConfiguration</code>的 exclude 属性禁用它们，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.boot.autoconfigure.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.autoconfigure.jdbc.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.*;</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyConfiguration</span> {</span><br><span class=line>}</span><br></pre></table></figure><p>如果该类不在 Classpath 中，则可以使用 Comments 的<code>excludeName</code>属性，并指定完全限定的名称。最后，您还可以使用<code>spring.autoconfigure.exclude</code>属性来控制要排除的自动配置类的列表。<h2 id=2-5、Spring-Bean和依赖注入><a title="2.5、Spring Bean和依赖注入" class=headerlink href=#2-5、Spring-Bean和依赖注入></a>2.5、Spring Bean和依赖注入</h2><p>您可以自由使用任何标准的 Spring Framework 技术来定义 bean 及其注入的依赖项。为简单起见，我们经常发现使用<code>@ComponentScan</code>(查找您的 bean)和使用<code>@Autowired</code>(进行构造函数注入)效果很好。<p>如果按照上面的建议构造代码(将应用程序类放在根包中)，则可以添加<code>@ComponentScan</code>而没有任何参数。您的所有应用程序组件(<code>@Component</code>，<code>@Service</code>，<code>@Repository</code>，<code>@Controller</code>等)都会自动注册为 Spring Bean。<p>以下示例显示了一个<code>@Service</code> Bean，它使用构造函数注入来获取所需的<code>RiskAssessor</code> bean：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.example.service;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Service;</span><br><span class=line></span><br><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DatabaseAccountService</span> <span class=keyword>implements</span> <span class="title class_">AccountService</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> RiskAssessor riskAssessor;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">DatabaseAccountService</span><span class=params>(RiskAssessor riskAssessor)</span> {</span><br><span class=line>		<span class=built_in>this</span>.riskAssessor = riskAssessor;</span><br><span class=line>	}</span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>如果 bean 具有一个构造函数，则可以省略<code>@Autowired</code>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DatabaseAccountService</span> <span class=keyword>implements</span> <span class="title class_">AccountService</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> RiskAssessor riskAssessor;</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">DatabaseAccountService</span><span class=params>(RiskAssessor riskAssessor)</span> {</span><br><span class=line>		<span class=built_in>this</span>.riskAssessor = riskAssessor;</span><br><span class=line>	}</span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><h2 id=2-6、使用-SpringBootApplication-Comments><a title="2.6、使用@SpringBootApplication Comments" class=headerlink href=#2-6、使用-SpringBootApplication-Comments></a>2.6、使用@SpringBootApplication Comments</h2><p>许多 Spring Boot 开发人员喜欢他们的应用程序使用自动配置，组件扫描，并能够在其“应用程序类”上定义额外的配置。单个<code>@SpringBootApplication</code>Comments 可用于启用这三个功能，即：<ul><li><code>@EnableAutoConfiguration</code>：启用<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-auto-configuration.html rel=noopener target=_blank>Spring Boot 的自动配置机制</a><li><code>@ComponentScan</code>：对应用程序所在的软件包启用<code>@Component</code>扫描(请参见<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-structuring-your-code.html rel=noopener target=_blank>最佳做法</a>)<li><code>@Configuration</code>：允许在上下文中注册额外的 bean 或导入其他配置类</ul><p><code>@SpringBootApplication</code>Comments 等效于将<code>@Configuration</code>，<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>及其默认属性一起使用，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.example.myapplication;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.boot.SpringApplication;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=line></span><br><span class=line><span class=meta>@SpringBootApplication</span> <span class=comment>// same as @Configuration @EnableAutoConfiguration @ComponentScan</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Application</span> {</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>		SpringApplication.run(Application.class, args);</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p><code>@SpringBootApplication</code>还提供别名以自定义<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>的属性。<p>这些功能都不是强制性的，您可以选择用它启用的任何功能替换此单个 Comments。例如，您可能不想在应用程序中使用组件扫描：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.example.myapplication;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.boot.SpringApplication;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.ComponentScan</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Configuration;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Import;</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableAutoConfiguration</span></span><br><span class=line><span class=meta>@Import({ MyConfig.class, MyAnotherConfig.class })</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Application</span> {</span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>			SpringApplication.run(Application.class, args);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>在此示例中，<code>Application</code>就像其他任何 Spring Boot 应用程序一样，除了不会自动检测到<code>@Component</code>Comments 的类并且显式导入用户定义的 Bean(请参阅<code>@Import</code>)。</blockquote><h2 id=2-7、运行您的应用程序><a class=headerlink href=#2-7、运行您的应用程序 title=2.7、运行您的应用程序></a>2.7、运行您的应用程序</h2><h3 id=2-7-1、从IDE运行><a class=headerlink href=#2-7-1、从IDE运行 title=2.7.1、从IDE运行></a>2.7.1、从IDE运行</h3><p>您可以将 IDE 中的 Spring Boot 应用程序作为简单的 Java 应用程序运行。但是，您首先需要导入您的项目。导入步骤因您的 IDE 和构建系统而异。大多数 IDE 可以直接导入 Maven 项目。例如，Eclipse 用户可以从<code>File</code>菜单中选择<code>Import…</code>→<code>Existing Maven Projects</code>。<p>如果您不能直接将项目导入到 IDE 中，则可以使用构建插件来生成 IDE 元数据。 Maven 包括<a href=https://maven.apache.org/plugins/maven-eclipse-plugin/ rel=noopener target=_blank>Eclipse</a>和<a href=https://maven.apache.org/plugins/maven-idea-plugin/ rel=noopener target=_blank>IDEA</a>的插件。 Gradle 提供了<a href=https://docs.gradle.org/4.2.1/userguide/userguide.html rel=noopener target=_blank>various IDEs</a>的插件。<blockquote><p>如果不小心两次运行 Web 应用程序，则会看到“端口已在使用中”错误。 STS 用户可以使用<code>Relaunch</code>按钮而不是<code>Run</code>按钮来确保关闭任何现有实例。</blockquote><h3 id=2-7-2、作为打包的应用程序运行><a class=headerlink href=#2-7-2、作为打包的应用程序运行 title=2.7.2、作为打包的应用程序运行></a>2.7.2、作为打包的应用程序运行</h3><p>如果使用 Spring Boot Maven 或 Gradle 插件创建可执行 jar，则可以使用<code>java -jar</code>运行应用程序，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -jar target/myapplication-0.0.1-SNAPSHOT.jar</span></span><br></pre></table></figure><p>也可以在启用了远程调试支持的情况下运行打包的应用程序。这样做使您可以将调试器附加到打包的应用程序，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,<span class=built_in>suspend</span>=n \</span></span><br><span class=line><span class=language-bash>       -jar target/myapplication-0.0.1-SNAPSHOT.jar</span></span><br></pre></table></figure><h3 id=2-7-3、使用Maven插件><a class=headerlink href=#2-7-3、使用Maven插件 title=2.7.3、使用Maven插件></a>2.7.3、使用Maven插件</h3><p>Spring Boot Maven 插件包含一个<code>run</code>目标，可用于快速编译和运行您的应用程序。应用程序以爆炸形式运行，就像在 IDE 中一样。以下示例显示了运行 Spring Boot 应用程序的典型 Maven 命令：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>mvn spring-boot:run</span></span><br></pre></table></figure><p>您可能还想使用<code>MAVEN_OPTS</code>os 环境变量，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>export</span> MAVEN_OPTS=-Xmx1024m</span></span><br></pre></table></figure><h4 id=2-7-4、使用Gradle插件><a class=headerlink href=#2-7-4、使用Gradle插件 title=2.7.4、使用Gradle插件></a>2.7.4、使用Gradle插件</h4><p>Spring Boot Gradle 插件还包括一个<code>bootRun</code>任务，可用于以爆炸形式运行您的应用程序。每当您应用<code>org.springframework.boot</code>和<code>java</code>插件时，便会添加<code>bootRun</code>任务，并在以下示例中显示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>gradle bootRun</span></span><br></pre></table></figure><p>您可能还想使用<code>JAVA_OPTS</code>os 环境变量，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>export</span> JAVA_OPTS=-Xmx1024m</span></span><br></pre></table></figure><h3 id=2-7-5、热插拔><a class=headerlink href=#2-7-5、热插拔 title=2.7.5、热插拔></a>2.7.5、热插拔</h3><p>由于 Spring Boot 应用程序只是普通的 Java 应用程序，因此 JVM 热交换应该可以立即使用。 JVM 热插拔在一定程度上受到它可以替换的字节码的限制。要获得更完整的解决方案，可以使用<a href=https://zeroturnaround.com/software/jrebel/ rel=noopener target=_blank>JRebel</a>。<p><code>spring-boot-devtools</code>模块还包括对应用程序快速重启的支持。有关详细信息，请参见本文档相关部分。<h2 id=2-8、Developer-Tools><a title="2.8、Developer Tools" class=headerlink href=#2-8、Developer-Tools></a>2.8、Developer Tools</h2><p>Spring Boot 包括一组额外的工具，这些工具可以使应用程序开发体验更加愉快。 <code>spring-boot-devtools</code>模块可以包含在任何项目中，以提供其他开发时功能。要包括 devtools 支持，请将模块依赖项添加到您的构建中，如以下 Maven 和 Gradle Lists 所示：<p><strong>Maven.</strong><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>	<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>		<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>		<span class=tag><<span class=name>artifactId</span>></span>spring-boot-devtools<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>		<span class=tag><<span class=name>optional</span>></span>true<span class=tag>&LT/<span class=name>optional</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencies</span>></span></span><br></pre></table></figure><p><strong>Gradle.</strong><figure class="highlight groovy"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>configurations {</span><br><span class=line>	developmentOnly</span><br><span class=line>	runtimeClasspath {</span><br><span class=line>		extendsFrom developmentOnly</span><br><span class=line>	}</span><br><span class=line>}</span><br><span class=line>dependencies {</span><br><span class=line>	developmentOnly(<span class=string>"org.springframework.boot:spring-boot-devtools"</span>)</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>运行完全打包的应用程序时，将自动禁用开发人员工具。如果您的应用程序是从<code>java -jar</code>启动的，或者是从特殊的类加载器启动的，则将其视为“生产应用程序”。在 Maven 中将依赖项标记为可选，或在 Gradle 中使用自定义的“ developmentOnly”配置(如上所示)是一种最佳实践，它可以防止将 devtools 过渡地应用到使用项目的其他模块。<p>重新打包的存档默认情况下不包含 devtools。如果要使用<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-boot-devtools-remote rel=noopener target=_blank>某些远程 devtools 功能</a>，则需要禁用<code>excludeDevtools</code> build 属性以包括它。 Maven 和 Gradle 插件均支持该属性。</blockquote><h3 id=2-8-1、属性默认值><a class=headerlink href=#2-8-1、属性默认值 title=2.8.1、属性默认值></a>2.8.1、属性默认值</h3><p>Spring Boot 支持的一些库使用缓存来提高性能。例如，<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-spring-mvc-template-engines rel=noopener target=_blank>template engines</a>缓存已编译的模板，以避免重复分析模板文件。而且，Spring MVC 可以在提供静态资源时向响应添加 HTTP 缓存 Headers。<p>虽然缓存在 Producing 非常有益，但在开发过程中可能适得其反，从而使您无法看到刚刚在应用程序中所做的更改。因此，默认情况下，spring-boot-devtools 禁用缓存选项。<p>缓存选项通常由<code>application.properties</code>文件中的设置配置。例如，Thymeleaf 提供了<code>spring.thymeleaf.cache</code>属性。无需手动设置这些属性，<code>spring-boot-devtools</code>模块会自动应用合理的开发时配置。<p>由于在开发 Spring MVC 和 Spring WebFlux 应用程序时需要有关 Web 请求的更多信息，因此开发人员工具将为<code>web</code>日志记录组启用<code>DEBUG</code>日志记录。这将为您提供有关传入请求，正在处理的处理程序，响应结果等的信息。如果您希望记录所有请求详细信息(包括潜在的敏感信息)，则可以打开<code>spring.http.log-request-details</code>配置属性。<blockquote><p>如果您不希望应用属性默认值，则可以在<code>application.properties</code>中将<code>spring.devtools.add-properties</code>设置为<code>false</code>。<p>有关 devtools 应用的属性的完整列表，请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/env/DevToolsPropertyDefaultsPostProcessor.java rel=noopener target=_blank>DevToolsPropertyDefaultsPostProcessor</a>。</blockquote><h3 id=2-8-2、自动重启><a class=headerlink href=#2-8-2、自动重启 title=2.8.2、自动重启></a>2.8.2、自动重启</h3><p>每当 Classpath 上的文件更改时，使用<code>spring-boot-devtools</code>的应用程序都会自动重新启动。当在 IDE 中工作时，这可能是一个有用的功能，因为它为代码更改提供了非常快速的反馈循环。默认情况下，将监视 Classpath 上指向文件夹的任何条目的更改。请注意，某些资源，例如静态资产和视图模板<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-boot-devtools-restart-exclude rel=noopener target=_blank>不需要重新启动应用程序</a>。<blockquote><p>当 DevTools 监视 Classpath 资源时，触发重启的唯一方法是更新 Classpath。导致 Classpath 更新的方式取决于您使用的 IDE。在 Eclipse 中，保存修改后的文件将导致 Classpath 被更新并触发重新启动。在 IntelliJ IDEA 中，构建项目(<code>Build -> Build Project</code>)具有相同的效果。<p>只要启用了分叉，您还可以使用受支持的构建插件(Maven 和 Gradle)来启动应用程序，因为 DevTools 需要隔离的应用程序类加载器才能正常运行。默认情况下，Gradle 和 Maven 在 Classpath 上检测到 DevTools 时会这样做。<p>与 LiveReload 一起使用时，自动重新启动效果很好。 <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-boot-devtools-livereload rel=noopener target=_blank>请参阅“ LiveReload”部分</a>了解详情。如果使用 JRebel，则禁用自动重新启动，而有利于动态类重新加载。仍可以使用其他 devtools 功能(例如 LiveReload 和属性替代)。<p>DevTools 依靠应用程序上下文的关闭钩子在重新启动期间将其关闭。如果禁用了关机钩子(<code>SpringApplication.setRegisterShutdownHook(false)</code>)，它将无法正常工作。<p>在确定 Classpath 上的条目是否应在更改后触发重新启动时，DevTools 会自动忽略名为<code>spring-boot</code>，<code>spring-boot-devtools</code>，<code>spring-boot-autoconfigure</code>，<code>spring-boot-actuator</code>和<code>spring-boot-starter</code>的项目。<p>DevTools 需要自定义<code>ApplicationContext</code>使用的<code>ResourceLoader</code>。如果您的应用程序已经提供了，它将被包装。不支持在<code>ApplicationContext</code>上直接覆盖<code>getResource</code>方法。<p>Spring Boot 提供的重启技术通过使用两个类加载器来工作。不变的类(例如，来自第三方 jar 的类)将被加载到* base <em>类加载器中。您正在积极开发的类将加载到</em> restart <em>类加载器中。重新启动应用程序后，将丢弃</em> restart <em>类加载器，并创建一个新的类加载器。这种方法意味着应用程序的重启通常比“冷启动”要快得多，因为</em> base *类加载器已经可用并已填充。<p>如果您发现重新启动对于应用程序而言不够快，或者遇到类加载问题，则可以考虑从 ZeroTurnaround 重新加载诸如<a href=https://zeroturnaround.com/software/jrebel/ rel=noopener target=_blank>JRebel</a>之类的技术。这些方法通过在加载类时重写类来使其更易于重新加载。</blockquote><h4 id=2-8-2-1、记录条件评估中的更改><a class=headerlink href=#2-8-2-1、记录条件评估中的更改 title=2.8.2.1、记录条件评估中的更改></a>2.8.2.1、记录条件评估中的更改</h4><p>默认情况下，每次应用程序重新启动时，都会记录一个报告，其中显示了条件评估增量。该报告显示了在进行更改(例如添加或删除 bean 以及设置配置属性)时对应用程序自动配置的更改。<p>要禁用报告的日志记录，请设置以下属性：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.devtools.restart.log-condition-evaluation-delta=false</span><br></pre></table></figure><h4 id=2-8-2-2、排除资源><a class=headerlink href=#2-8-2-2、排除资源 title=2.8.2.2、排除资源></a>2.8.2.2、排除资源</h4><p>某些资源在更改时不一定需要触发重新启动。例如，Thymeleaf 模板可以就地编辑。默认情况下，更改<code>/META-INF/maven</code>，<code>/META-INF/resources</code>，<code>/resources</code>，<code>/static</code>，<code>/public</code>或<code>/templates</code>中的资源不会触发重新启动，但会触发<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-boot-devtools-livereload rel=noopener target=_blank>live reload</a>。如果要自定义这些排除项，则可以使用<code>spring.devtools.restart.exclude</code>属性。例如，要仅排除<code>/static</code>和<code>/public</code>，则可以设置以下属性：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.devtools.restart.exclude=static/**,public/**</span><br></pre></table></figure><blockquote><p>如果要保留这些默认值并“添加”其他排除项，请改用<code>spring.devtools.restart.additional-exclude</code>属性。</blockquote><h4 id=2-8-2-3、注意其它路径><a class=headerlink href=#2-8-2-3、注意其它路径 title=2.8.2.3、注意其它路径></a>2.8.2.3、注意其它路径</h4><p>当您对不在 Classpath 上的文件进行更改时，您可能希望重新启动或重新加载应用程序。为此，使用<code>spring.devtools.restart.additional-paths</code>属性配置其他路径以监视更改。您可以使用<code>spring.devtools.restart.exclude</code>属性<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-boot-devtools-restart-exclude rel=noopener target=_blank>described earlier</a>来控制其他路径下的更改是触发完全重启还是<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-boot-devtools-livereload rel=noopener target=_blank>live reload</a>。<h4 id=2-8-2-4、禁用重启><a class=headerlink href=#2-8-2-4、禁用重启 title=2.8.2.4、禁用重启></a>2.8.2.4、禁用重启</h4><p>如果您不想使用重新启动功能，则可以使用<code>spring.devtools.restart.enabled</code>属性将其禁用。在大多数情况下，您可以在<code>application.properties</code>中设置此属性(这样做仍会初始化重新启动类加载器，但它不会监视文件更改)。<p>如果您需要<em>完全</em>禁用重启支持(例如，因为它不适用于特定的库)，则需要在调用<code>SpringApplication.run(…)</code>之前将<code>spring.devtools.restart.enabled</code> <code>System</code>属性设置为<code>false</code>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>	System.setProperty(<span class=string>"spring.devtools.restart.enabled"</span>, <span class=string>"false"</span>);</span><br><span class=line>	SpringApplication.run(MyApp.class, args);</span><br><span class=line>}</span><br></pre></table></figure><h4 id=2-8-2-5、使用触发文件><a class=headerlink href=#2-8-2-5、使用触发文件 title=2.8.2.5、使用触发文件></a>2.8.2.5、使用触发文件</h4><p>如果使用持续编译更改文件的 IDE，则可能更喜欢仅在特定时间触发重新启动。为此，可以使用“触发文件”，这是一个特殊文件，当您要实际触发重新启动检查时必须对其进行修改。更改文件只会触发检查，并且仅在 Devtools 检测到必须执行某些操作时才会重新启动。可以手动或使用 IDE 插件来更新触发文件。<p>要使用触发文件，请将<code>spring.devtools.restart.trigger-file</code>属性设置为触发文件的路径。<blockquote><p>您可能希望将<code>spring.devtools.restart.trigger-file</code>设置为<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-boot-devtools-globalsettings rel=noopener target=_blank>global setting</a>，以便所有项目的行为都相同。</blockquote><h4 id=2-8-2-6、自定义重启类加载器><a class=headerlink href=#2-8-2-6、自定义重启类加载器 title=2.8.2.6、自定义重启类加载器></a>2.8.2.6、自定义重启类加载器</h4><p>如前面的<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-spring-boot-restart-vs-reload rel=noopener target=_blank>重新启动与重新加载</a>部分所述，重新启动功能是通过使用两个类加载器实现的。对于大多数应用程序，此方法效果很好。但是，有时可能会导致类加载问题。<p>默认情况下，IDE 中的任何打开的项目都将使用“重新启动”类加载器加载，而任何常规的<code>.jar</code>文件都将使用“基本”类加载器加载。如果您在多模块项目上工作，并且并非每个模块都导入到 IDE 中，则可能需要自定义内容。为此，您可以创建一个<code>META-INF/spring-devtools.properties</code>文件。<p><code>spring-devtools.properties</code>文件可以包含以<code>restart.exclude</code>和<code>restart.include</code>为前缀的属性。 <code>include</code>元素是应上拉到“重新启动”类加载器中的项目，而<code>exclude</code>元素是应下推到“基本”类加载器中的项目。该属性的值是一个应用于 Classpath 的正则表达式模式，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>restart.exclude.companycommonlibs=/mycorp-common-[\\w-]+\.jar</span><br><span class=line>restart.include.projectcommon=/mycorp-myproj-[\\w-]+\.jar</span><br></pre></table></figure><blockquote><p>所有属性键都必须是唯一的。只要属性以<code>restart.include.</code>或<code>restart.exclude.</code>开头，它就会被考虑。<p>Classpath 中的所有<code>META-INF/spring-devtools.properties</code>都已加载。您可以将文件打包在项目内部或项目使用的库中。</blockquote><h4 id=2-8-2-7、已知限制><a class=headerlink href=#2-8-2-7、已知限制 title=2.8.2.7、已知限制></a>2.8.2.7、已知限制</h4><p>重新启动功能不适用于使用标准<code>ObjectInputStream</code>反序列化的对象。如果需要反序列化数据，则可能需要结合使用 Spring 的<code>ConfigurableObjectInputStream</code>和<code>Thread.currentThread().getContextClassLoader()</code>。<p>不幸的是，一些第三方库在不考虑上下文类加载器的情况下反序列化。如果发现这样的问题，则需要向原始作者请求修复。<h3 id=2-8-3、LiveReload><a class=headerlink href=#2-8-3、LiveReload title=2.8.3、LiveReload></a>2.8.3、LiveReload</h3><p><code>spring-boot-devtools</code>模块包括一个嵌入式 LiveReload 服务器，该服务器可用于在更改资源时触发浏览器刷新。可从<a href=http://livereload.com/extensions/ rel=noopener target=_blank>livereload.com</a>免费为 Chrome，Firefox 和 Safari 使用 LiveReload 浏览器扩展。<p>如果您不想在应用程序运行时启动 LiveReload 服务器，则可以将<code>spring.devtools.livereload.enabled</code>属性设置为<code>false</code>。<blockquote><p>一次只能运行一台 LiveReload 服务器。在启动应用程序之前，请确保没有其他 LiveReload 服务器正在运行。如果从 IDE 启动多个应用程序，则只有第一个具有 LiveReload 支持。</blockquote><h3 id=2-8-4、全局设置><a class=headerlink href=#2-8-4、全局设置 title=2.8.4、全局设置></a>2.8.4、全局设置</h3><p>您可以通过将名为<code>.spring-boot-devtools.properties</code>的文件添加到<code>$HOME</code>文件夹中来配置全局 devtools 设置(请注意，文件名以“.”开头)。添加到该文件的所有属性都适用于您机器上所有使用 devtools 的 Spring Boot 应用程序。例如，要将重新启动配置为始终使用<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-boot-devtools-restart-triggerfile rel=noopener target=_blank>trigger file</a>，则应添加以下属性：<p><strong>~/.spring-boot-devtools.properties.</strong><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.devtools.reload.trigger-file=.reloadtrigger</span><br></pre></table></figure><blockquote><p>在<code>.spring-boot-devtools.properties</code>中激活的配置文件不会影响<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-external-config.html#boot-features-external-config-profile-specific-properties rel=noopener target=_blank>特定于配置文件的配置文件</a>的加载。</blockquote><h3 id=2-8-5、远程应用程序><a class=headerlink href=#2-8-5、远程应用程序 title=2.8.5、远程应用程序></a>2.8.5、远程应用程序</h3><p>Spring Boot 开发人员工具不仅限于本地开发。远程运行应用程序时，您还可以使用多种功能。选择加入远程支持。要启用它，您需要确保重新打包的 Files 中包含<code>devtools</code>，如以下 Lists 所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>build</span>></span></span><br><span class=line>	<span class=tag><<span class=name>plugins</span>></span></span><br><span class=line>		<span class=tag><<span class=name>plugin</span>></span></span><br><span class=line>			<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>artifactId</span>></span>spring-boot-maven-plugin<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>configuration</span>></span></span><br><span class=line>				<span class=tag><<span class=name>excludeDevtools</span>></span>false<span class=tag>&LT/<span class=name>excludeDevtools</span>></span></span><br><span class=line>			<span class=tag>&LT/<span class=name>configuration</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>plugin</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>plugins</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>build</span>></span></span><br></pre></table></figure><p>然后，您需要设置一个<code>spring.devtools.remote.secret</code>属性，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.devtools.remote.secret=mysecret</span><br></pre></table></figure><blockquote><p>在远程应用程序上启用<code>spring-boot-devtools</code>是安全隐患。您永远不应在生产部署上启用支持。</blockquote><p>远程 devtools 支持分为两部分：接受连接的服务器端端点和在 IDE 中运行的 Client 端应用程序。设置<code>spring.devtools.remote.secret</code>属性后，将自动启用服务器组件。Client 端组件必须手动启动。<h4 id=2-8-5-1、运行远程Client端应用程序><a class=headerlink href=#2-8-5-1、运行远程Client端应用程序 title=2.8.5.1、运行远程Client端应用程序></a>2.8.5.1、运行远程Client端应用程序</h4><p>远程 Client 端应用程序旨在在您的 IDE 中运行。您需要使用与您连接到的远程项目相同的 Classpath 来运行<code>org.springframework.boot.devtools.RemoteSpringApplication</code>。应用程序的单个必需参数是它连接到的远程 URL。<p>例如，如果您使用的是 Eclipse 或 STS，并且您有一个名为<code>my-app</code>的项目已部署到 Cloud Foundry，则可以执行以下操作：<ul><li>从<code>Run</code>菜单中选择<code>Run Configurations…</code>。<li>创建一个新的<code>Java Application</code>“启动配置”。<li>浏览<code>my-app</code>项目。<li>使用<code>org.springframework.boot.devtools.RemoteSpringApplication</code>作为主要类。<li>将<code>https://myapp.cfapps.io</code>添加到<code>Program arguments</code>(或任何远程 URL)。</ul><p>正在运行的远程 Client 端可能类似于以下 Lists：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line>.   ____          _                                              __ _ _</span><br><span class=line> /\\ / ___'_ __ _ _(_)_ __  __ _          ___               _      \ \ \ \</span><br><span class=line>( ( )\___ | '_ | '_| | '_ \/ _` |        | _ \___ _ __  ___| |_ ___ \ \ \ \</span><br><span class=line> \\/  ___)| |_)| | | | | || (_| []::::::[]   / -_) '  \/ _ \  _/ -_) ) ) ) )</span><br><span class=line>  '  |____| .__|_| |_|_| |_\__, |        |_|_\___|_|_|_\___/\__\___|/ / / /</span><br><span class=line> =========|_|==============|___/===================================/_/_/_/</span><br><span class=line> :: Spring Boot Remote :: 2.1.1.RELEASE</span><br><span class=line></span><br><span class=line>2015-06-10 18:25:06.632  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Starting RemoteSpringApplication on pwmbp with PID 14938 (/Users/pwebb/projects/spring-boot/code/spring-boot-devtools/target/classes started by pwebb in /Users/pwebb/projects/spring-boot/code/spring-boot-samples/spring-boot-sample-devtools)</span><br><span class=line>2015-06-10 18:25:06.671  INFO 14938 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.spring[emailprotected]2a17b7b6: startup date [Wed Jun 10 18:25:06 PDT 2015]; root of context hierarchy</span><br><span class=line>2015-06-10 18:25:07.043  WARN 14938 --- [           main] o.s.b.d.r.c.RemoteClientConfiguration    : The connection to http://localhost:8080 is insecure. You should use a URL starting with 'https://'.</span><br><span class=line>2015-06-10 18:25:07.074  INFO 14938 --- [           main] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729</span><br><span class=line>2015-06-10 18:25:07.130  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Started RemoteSpringApplication in 0.74 seconds (JVM running for 1.105)</span><br></pre></table></figure><blockquote><p>因为远程 Client 端使用与真实应用程序相同的 Classpath，所以它可以直接读取应用程序属性。这就是读取<code>spring.devtools.remote.secret</code>属性并将其传递给服务器进行身份验证的方式。<p>始终建议使用<code>https://</code>作为连接协议，以便对通信进行加密并且不能截获密码。<p>如果需要使用代理来访问远程应用程序，请配置<code>spring.devtools.remote.proxy.host</code>和<code>spring.devtools.remote.proxy.port</code>属性。</blockquote><h4 id=2-8-5-2、远程更新><a class=headerlink href=#2-8-5-2、远程更新 title=2.8.5.2、远程更新></a>2.8.5.2、远程更新</h4><p>远程 Client 端以与<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-boot-devtools-restart rel=noopener target=_blank>local restart</a>相同的方式监视应用程序 Classpath 中的更改。任何更新的资源都被推送到远程应用程序，并且(<em>如果需要</em>)触发重新启动。如果您迭代使用本地没有的云服务的功能，这将很有帮助。通常，远程更新和重新启动比完整的重建和部署周期要快得多。<blockquote><p>仅在远程 Client 端正在运行时监视文件。如果在启动远程 Client 端之前更改文件，则不会将其推送到远程服务器。</blockquote><h2 id=2-9、包装您的生产申请><a class=headerlink href=#2-9、包装您的生产申请 title=2.9、包装您的生产申请></a>2.9、包装您的生产申请</h2><p>可执行 jar 可以用于生产部署。由于它们是独立的，因此它们也非常适合基于云的部署。<p>对于其他“生产准备就绪”功能，例如运行状况，审核和度量 REST 或 JMX 端点，请考虑添加<code>spring-boot-actuator</code>。有关详细信息，请参见* <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready.html rel=noopener target=_blank>“ Spring Boot Actuator：可用于生产的功能”</a> *。<h1 id=3、Spring-Boot功能><a title="3、Spring Boot功能" class=headerlink href=#3、Spring-Boot功能></a>3、Spring Boot功能</h1><h2 id=3-1、SpringApplication><a class=headerlink href=#3-1、SpringApplication title=3.1、SpringApplication></a>3.1、SpringApplication</h2><p><code>SpringApplication</code>类提供了一种方便的方法来引导从<code>main()</code>方法启动的 Spring 应用程序。在许多情况下，您可以委派给静态<code>SpringApplication.run</code>方法，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>public static void main(String[] args) {</span><br><span class=line>	SpringApplication.run(MySpringConfiguration.class, args);</span><br><span class=line>}</span><br></pre></table></figure><p>当您的应用程序启动时，您应该看到类似于以下输出的内容：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>.   ____          _            __ _ _</span><br><span class=line> /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class=line>( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \</span><br><span class=line> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class=line>  '  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class=line> =========|_|==============|___/=/_/_/_/</span><br><span class=line> :: Spring Boot ::   v2.1.1.RELEASE</span><br><span class=line></span><br><span class=line>2013-07-31 00:08:16.117  INFO 56603 --- [           main] o.s.b.s.app.SampleApplication            : Starting SampleApplication v0.1.0 on mycomputer with PID 56603 (/apps/myapp.jar started by pwebb)</span><br><span class=line>2013-07-31 00:08:16.166  INFO 56603 --- [           main] ationConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.ser[emailprotected]6e5a8246: startup date [Wed Jul 31 00:08:16 PDT 2013]; root of context hierarchy</span><br><span class=line>2014-03-04 13:09:54.912  INFO 41370 --- [           main] .t.TomcatServletWebServerFactory : Server initialized with port: 8080</span><br><span class=line>2014-03-04 13:09:56.501  INFO 41370 --- [           main] o.s.b.s.app.SampleApplication            : Started SampleApplication in 2.992 seconds (JVM running for 3.658)</span><br></pre></table></figure><p>默认情况下，显示<code>INFO</code>条日志记录消息，包括一些相关的启动详细信息，例如启动该应用程序的用户。如果您需要<code>INFO</code>以外的其他日志级别，则可以按照<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-logging.html#boot-features-custom-log-levels rel=noopener target=_blank>第 26.4 节“日志级别”</a>中的说明进行设置。<h3 id=3-1-1、启动失败><a class=headerlink href=#3-1-1、启动失败 title=3.1.1、启动失败></a>3.1.1、启动失败</h3><p>如果您的应用程序无法启动，则已注册的<code>FailureAnalyzers</code>有机会提供专用的错误消息和解决该问题的具体措施。例如，如果您在端口<code>8080</code>上启动 Web 应用程序，并且该端口已在使用中，则应该看到类似于以下消息的内容：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>***************************</span><br><span class=line>APPLICATION FAILED TO START</span><br><span class=line>***************************</span><br><span class=line></span><br><span class=line>Description:</span><br><span class=line></span><br><span class=line>Embedded servlet container failed to start. Port 8080 was already in use.</span><br><span class=line></span><br><span class=line>Action:</span><br><span class=line></span><br><span class=line>Identify and stop the process that's listening on port 8080 or configure this application to listen on another</span><br></pre></table></figure><blockquote><p>Spring Boot 提供了众多的<code>FailureAnalyzer</code>实现，您可以<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/howto-spring-boot-application.html#howto-failure-analyzer rel=noopener target=_blank>添加自己的</a>。</blockquote><p>如果没有故障分析器能够处理该异常，您仍然可以显示完整情况报告，以更好地了解出了什么问题。为此，您需要<code>org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</code> <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-external-config.html rel=noopener target=_blank>启用调试属性</a>或<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-logging.html#boot-features-custom-log-levels rel=noopener target=_blank>启用调试日志记录</a>。<p>例如，如果您使用<code>java -jar</code>运行应用程序，则可以启用<code>debug</code>属性，如下所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -jar myproject-0.0.1-SNAPSHOT.jar --debug</span></span><br></pre></table></figure><h3 id=3-1-2、自定义banner><a class=headerlink href=#3-1-2、自定义banner title=3.1.2、自定义banner></a>3.1.2、自定义banner</h3><p>可以通过将<code>banner.txt</code>文件添加到 Classpath 或将<code>spring.banner.location</code>属性设置为此类文件的位置来更改启动时打印的 banner。如果文件的编码不是 UTF-8，则可以设置<code>spring.banner.charset</code>。除了文本文件之外，您还可以将<code>banner.gif</code>，<code>banner.jpg</code>或<code>banner.png</code>图像文件添加到 Classpath 或设置<code>spring.banner.image.location</code>属性。图像将转换为 ASCII 艺术作品并打印在任何文本 banner 上方。<p>在<code>banner.txt</code>文件中，您可以使用以下任何占位符：<p><strong>表 23.1 标语变量</strong><table><thead><tr><th>Variable<th>Description<tbody><tr><td><code>${application.version}</code><td><code>MANIFEST.MF</code>中声明的应用程序的版本号。例如，<code>Implementation-Version: 1.0</code>被打印为<code>1.0</code>。<tr><td><code>${application.formatted-version}</code><td>您的应用程序的版本号，以<code>MANIFEST.MF</code>声明，并设置为显示格式(用方括号括起来并以<code>v</code>作为前缀)。例如<code>(v1.0)</code>。<tr><td><code>${spring-boot.version}</code><td>您正在使用的 Spring Boot 版本。例如<code>2.1.1.RELEASE</code>。<tr><td><code>${spring-boot.formatted-version}</code><td>您正在使用的 Spring Boot 版本，已格式化以用于显示(用方括号括起来，并以<code>v</code>作为前缀)。例如<code>(v2.1.1.RELEASE)</code>。<tr><td><code>${Ansi.NAME}</code>(或<code>${AnsiColor.NAME}</code>，<code>${AnsiBackground.NAME}</code>，<code>${AnsiStyle.NAME}</code>)<td>其中<code>NAME</code>是 ANSI 转义代码的名称。有关详情，请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/ansi/AnsiPropertySource.java rel=noopener target=_blank>AnsiPropertySource</a>。<tr><td><code>${application.title}</code><td><code>MANIFEST.MF</code>中声明的应用程序标题。例如<code>Implementation-Title: MyApp</code>被打印为<code>MyApp</code>。</table><blockquote><p>如果要以编程方式生成 banner，则可以使用<code>SpringApplication.setBanner(…)</code>方法。使用<code>org.springframework.boot.Banner</code>接口并实现自己的<code>printBanner()</code>方法。</blockquote><p>您还可以使用<code>spring.main.banner-mode</code>属性来确定 banner 是否必须打印在<code>System.out</code>(<code>console</code>)上，发送到配置的 Logger(<code>log</code>)或根本不打印(<code>off</code>)。<p>打印的 banner 以以下名称注册为单例 bean：<code>springBootBanner</code>。<blockquote><p>YAML 将<code>off</code>Map 到<code>false</code>，因此，如果要在应用程序中禁用 banner，请确保添加引号，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>spring:</span><br><span class=line>	main:</span><br><span class=line>		banner-mode: "off"</span><br></pre></table></figure></blockquote><h3 id=3-1-3、自定义SpringApplication><a class=headerlink href=#3-1-3、自定义SpringApplication title=3.1.3、自定义SpringApplication></a>3.1.3、自定义SpringApplication</h3><p>如果您不喜欢默认的<code>SpringApplication</code>，则可以创建一个本地实例并对其进行自定义。例如，要关闭 banner，您可以编写：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>public static void main(String[] args) {</span><br><span class=line>	SpringApplication app = new SpringApplication(MySpringConfiguration.class);</span><br><span class=line>	app.setBannerMode(Banner.Mode.OFF);</span><br><span class=line>	app.run(args);</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>传递给<code>SpringApplication</code>的构造函数参数是 Spring bean 的配置源。在大多数情况下，这些是对<code>@Configuration</code>类的引用，但它们也可以是对 XML 配置或应扫描的程序包的引用。</blockquote><p>也可以通过使用<code>application.properties</code>文件来配置<code>SpringApplication</code>。<h3 id=3-1-4、Fluent-Builder-API><a title="3.1.4、Fluent Builder API" class=headerlink href=#3-1-4、Fluent-Builder-API></a>3.1.4、Fluent Builder API</h3><p>如果您需要构建<code>ApplicationContext</code>层次结构(具有父/子关系的多个上下文)，或者您更喜欢使用“Fluent 的”构建器 API，则可以使用<code>SpringApplicationBuilder</code>。<p><code>SpringApplicationBuilder</code>使您可以将多个方法调用链接在一起，并包括<code>parent</code>和<code>child</code>方法，这些方法使您可以创建层次结构，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>new</span> <span class="title class_">SpringApplicationBuilder</span>()</span><br><span class=line>		.sources(Parent.class)</span><br><span class=line>		.child(Application.class)</span><br><span class=line>		.bannerMode(Banner.Mode.OFF)</span><br><span class=line>		.run(args);</span><br></pre></table></figure><blockquote><p>创建<code>ApplicationContext</code>层次结构时有一些限制。例如，Web 组件 <strong>必须</strong> 包含在子上下文中，并且相同的<code>Environment</code>用于父上下文和子上下文。有关详细信息，请参见<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/builder/SpringApplicationBuilder.html rel=noopener target=_blank>SpringApplicationBuilder Javadoc</a>。</blockquote><h3 id=3-1-5、应用程序事件和侦听器><a class=headerlink href=#3-1-5、应用程序事件和侦听器 title=3.1.5、应用程序事件和侦听器></a>3.1.5、应用程序事件和侦听器</h3><p>除了通常的 Spring Framework 事件(例如<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/event/ContextRefreshedEvent.html rel=noopener target=_blank>ContextRefreshedEvent</a>)之外，<code>SpringApplication</code>还发送一些其他应用程序事件。<blockquote><p>有些事件实际上是在创建<code>ApplicationContext</code>之前触发的，因此您不能将这些事件注册为<code>@Bean</code>。您可以使用<code>SpringApplication.addListeners(…)</code>方法或<code>SpringApplicationBuilder.listeners(…)</code>方法注册它们。<p>如果希望这些监听器自动注册，而不管创建应用程序的方式如何，都可以将<code>META-INF/spring.factories</code>文件添加到项目中，并使用<code>org.springframework.context.ApplicationListener</code>键引用您的监听器，如以下示例所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>org.springframework.context.ApplicationListener=com.example.project.MyListener</span><br></pre></table></figure></blockquote><p>应用程序事件在您的应用程序运行时按以下 顺序 发送：<ul><li><code>ApplicationStartingEvent</code>在运行开始时但在进行任何处理之前(侦听器和初始化器的注册除外)发送。<li>当知道要在上下文中使用的<code>Environment</code>时但在创建上下文之前发送<code>ApplicationEnvironmentPreparedEvent</code>。<li>在刷新开始之前但在加载 bean 定义之后发送<code>ApplicationPreparedEvent</code>。<li>在刷新上下文之后但在调用任何应用程序和命令行运行程序之前发送<code>ApplicationStartedEvent</code>。<li>调用任何应用程序和命令行运行程序后，将发送<code>ApplicationReadyEvent</code>。它指示应用程序已准备就绪，可以处理请求。<li>如果启动时出现异常，则会发送<code>ApplicationFailedEvent</code>。</ul><blockquote><p>您通常不需要使用应用程序事件，但是很容易知道它们的存在。在内部，Spring Boot 使用事件来处理各种任务。</blockquote><p>应用程序事件是通过使用 Spring Framework 的事件发布机制发送的。此机制的一部分确保在子级上下文中发布给侦听器的事件也可以在任何祖先上下文中发布给侦听器。结果，如果您的应用程序使用<code>SpringApplication</code>实例的层次结构，则侦听器可能会收到同一类型的应用程序事件的多个实例。<p>为了使您的侦听器能够区分其上下文的事件和后代上下文的事件，它应请求注入其应用程序上下文，然后将注入的上下文与事件的上下文进行比较。可以通过实现<code>ApplicationContextAware</code>来注入上下文，或者如果侦听器是 bean，则可以通过使用<code>@Autowired</code>来注入上下文。<h3 id=3-1-6、Web环境><a class=headerlink href=#3-1-6、Web环境 title=3.1.6、Web环境></a>3.1.6、Web环境</h3><p><code>SpringApplication</code>尝试代表您创建正确的<code>ApplicationContext</code>类型。确定<code>WebApplicationType</code>的算法非常简单：<ul><li>如果存在 Spring MVC，则使用<code>AnnotationConfigServletWebServerApplicationContext</code><li>如果不存在 Spring MVC 且存在 Spring WebFlux，则使用<code>AnnotationConfigReactiveWebServerApplicationContext</code><li>否则，使用<code>AnnotationConfigApplicationContext</code></ul><p>这意味着，如果您在同一应用程序中使用 Spring MVC 和 Spring WebFlux 的新<code>WebClient</code>，则默认使用 Spring MVC。您可以通过调用<code>setWebApplicationType(WebApplicationType)</code>轻松覆盖它。<p>也可以完全控制通过调用<code>setApplicationContextClass(…)</code>所使用的<code>ApplicationContext</code>类型。<blockquote><p>在 JUnit 测试中使用<code>SpringApplication</code>时，通常希望调用<code>setWebApplicationType(WebApplicationType.NONE)</code>。</blockquote><h3 id=3-1-7、访问应用程序参数><a class=headerlink href=#3-1-7、访问应用程序参数 title=3.1.7、访问应用程序参数></a>3.1.7、访问应用程序参数</h3><p>如果您需要访问传递给<code>SpringApplication.run(…)</code>的应用程序参数，则可以注入<code>org.springframework.boot.ApplicationArguments</code> bean。 <code>ApplicationArguments</code>接口提供对原始<code>String[]</code>参数以及已解析的<code>option</code>和<code>non-option</code>参数的访问，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.boot.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.*;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(ApplicationArguments args)</span> {</span><br><span class=line>		<span class=type>boolean</span> <span class=variable>debug</span> <span class=operator>=</span> args.containsOption(<span class=string>"debug"</span>);</span><br><span class=line>		List&LTString> files = args.getNonOptionArgs();</span><br><span class=line>		<span class=comment>// if run with "--debug logfile.txt" debug=true, files=["logfile.txt"]</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>Spring Boot 还向 Spring <code>Environment</code>注册了一个<code>CommandLinePropertySource</code>。这样，您还可以使用<code>@Value</code>Comments 注入单个应用程序参数。</blockquote><h3 id=3-1-8、使用-ApplicationRunner-或-CommandLineRunner><a title="3.1.8、使用 ApplicationRunner 或 CommandLineRunner" class=headerlink href=#3-1-8、使用-ApplicationRunner-或-CommandLineRunner></a>3.1.8、使用 ApplicationRunner 或 CommandLineRunner</h3><p>如果在<code>SpringApplication</code>启动后需要运行一些特定的代码，则可以实现<code>ApplicationRunner</code>或<code>CommandLineRunner</code>接口。两个接口以相同的方式工作，并提供一个<code>run</code>方法，该方法在<code>SpringApplication.run(…)</code>完成之前被调用。<p><code>CommandLineRunner</code>接口以简单的字符串数组提供对应用程序参数的访问，而<code>ApplicationRunner</code>使用前面讨论的<code>ApplicationArguments</code>接口。以下示例显示使用<code>run</code>方法的<code>CommandLineRunner</code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.boot.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.*;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> <span class=keyword>implements</span> <span class="title class_">CommandLineRunner</span> {</span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">run</span><span class=params>(String... args)</span> {</span><br><span class=line>		<span class=comment>// Do something...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>如果定义了几个必须按特定 Sequences 调用的<code>CommandLineRunner</code>或<code>ApplicationRunner</code> bean，则可以另外实现<code>org.springframework.core.Ordered</code>接口或使用<code>org.springframework.core.annotation.Order</code>Comments。<h3 id=3-1-9、申请退出><a class=headerlink href=#3-1-9、申请退出 title=3.1.9、申请退出></a>3.1.9、申请退出</h3><p>每个<code>SpringApplication</code>向 JVM 注册一个关闭钩子，以确保<code>ApplicationContext</code>在退出时正常关闭。可以使用所有标准的 Spring 生命周期回调(例如<code>DisposableBean</code>接口或<code>@PreDestroy</code>注解)。<p>另外，如果 bean 希望在调用<code>SpringApplication.exit()</code>时返回特定的退出代码，则可以实现<code>org.springframework.boot.ExitCodeGenerator</code>接口。然后可以将此退出代码传递给<code>System.exit()</code>，以将其作为状态代码返回，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>@SpringBootApplication</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExitCodeApplication</span> {</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> ExitCodeGenerator <span class="title function_">exitCodeGenerator</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> () -> <span class=number>42</span>;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>System.exit(SpringApplication.exit(SpringApplication.run(ExitCodeApplication.class, args)));</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>此外，<code>ExitCodeGenerator</code>接口可能会通过异常实现。遇到此类异常时，Spring Boot 将返回已实现的<code>getExitCode()</code>方法提供的退出代码。<h3 id=3-1-10、管理员功能><a class=headerlink href=#3-1-10、管理员功能 title=3.1.10、管理员功能></a>3.1.10、管理员功能</h3><p>通过指定<code>spring.application.admin.enabled</code>属性，可以为应用程序启用与 Management 员相关的功能。这将在平台<code>MBeanServer</code>上公开<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/admin/SpringApplicationAdminMXBean.java rel=noopener target=_blank>SpringApplicationAdminMXBean</a>。您可以使用此功能来远程 Management Spring Boot 应用程序。对于任何服务包装器实现，此功能也可能很有用。<blockquote><p>如果您想知道应用程序在哪个 HTTP 端口上运行，请使用<code>local.server.port</code>键获取属性。<p>启用此功能时要小心，因为 MBean 公开了一种关闭应用程序的方法。</blockquote><h2 id=3-2、Externalized-Configuration><a title="3.2、Externalized Configuration" class=headerlink href=#3-2、Externalized-Configuration></a>3.2、Externalized Configuration</h2><p>Spring Boot 使您可以外部化配置，以便可以在不同环境中使用相同的应用程序代码。您可以使用属性文件，YAML 文件，环境变量和命令行参数来外部化配置。属性值可以使用<code>@Value</code>注解直接注入到您的 bean 中，可以通过 Spring 的<code>Environment</code>抽象访问，也可以是<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-external-config.html#boot-features-external-config-typesafe-configuration-properties rel=noopener target=_blank>绑定到结构化对象</a>到<code>@ConfigurationProperties</code>。<p>Spring Boot 使用一个非常特殊的<code>PropertySource</code>Sequences，该 Sequences 被设计为允许明智地覆盖值。按以下 Sequences 考虑属性：<ul><li>您的主目录上的<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-boot-devtools-globalsettings rel=noopener target=_blank>Devtools 全局设置属性</a>(在 devtools 处于 Active 状态时为<code>~/.spring-boot-devtools.properties</code>)。<li><a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/TestPropertySource.html rel=noopener target=_blank>@TestPropertySource</a>您的测试 Comments。<li>测试中的<code>properties</code>属性。在<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/test/context/SpringBootTest.html rel=noopener target=_blank>@SpringBootTest</a>和<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests rel=noopener target=_blank>测试 Comments 以测试应用程序的特定部分</a>上可用。<li>命令行参数。<li><code>SPRING_APPLICATION_JSON</code>中的属性(嵌入在环境变量或系统属性中的内联 JSON)。<li><code>ServletConfig</code>个初始化参数。<li><code>ServletContext</code>个初始化参数。<li>来自<code>java:comp/env</code>的 JNDI 属性。<li>Java 系统属性(<code>System.getProperties()</code>)。<li>os 环境变量。<li>仅在<code>random.*</code>中具有属性的<code>RandomValuePropertySource</code>。<li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-external-config.html#boot-features-external-config-profile-specific-properties rel=noopener target=_blank>特定于配置文件的应用程序属性</a>在打包的 jar 之外(<code>application-{profile}.properties</code>和 YAML 变体)。<li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-external-config.html#boot-features-external-config-profile-specific-properties rel=noopener target=_blank>特定于配置文件的应用程序属性</a>包装在 jar 中(<code>application-{profile}.properties</code>和 YAML 变体)。<li>打包的 jar 之外的应用程序属性(<code>application.properties</code>和 YAML 变体)。<li>打包在 jar 中的应用程序属性(<code>application.properties</code>和 YAML 变体)。<li><code>@Configuration</code>个类上的<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html rel=noopener target=_blank>@PropertySource</a>条 Comments。<li>默认属性(通过设置<code>SpringApplication.setDefaultProperties</code>指定)。</ul><p>为了提供一个具体的示例，假设您开发一个使用<code>name</code>属性的<code>@Component</code>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.stereotype.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.*;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>    <span class=meta>@Value("${name}")</span></span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>在您的应用程序 Classpath 上(例如，在 jar 内)，您可以拥有一个<code>application.properties</code>文件，该文件为<code>name</code>提供了合理的默认属性值。在新环境中运行时，可以在 jar 外部提供<code>application.properties</code>文件，该文件将覆盖<code>name</code>。对于一次性测试，可以使用特定的命令行开关(例如<code>java -jar app.jar --name="Spring"</code>)启动。<blockquote><p><code>SPRING_APPLICATION_JSON</code>属性可以在命令行中提供环境变量。例如，您可以在 UN * X shell 中使用以下行：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>SPRING_APPLICATION_JSON=<span class=string>'{"acme":{"name":"test"}}'</span> java -jar myapp.jar</span></span><br></pre></table></figure><p>在前面的示例中，您在 Spring<code>Environment</code>中以<code>acme.name=test</code>结尾。您还可以在 System 属性中以<code>spring.application.json</code>的形式提供 JSON，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -Dspring.application.json=<span class=string>'{"name":"test"}'</span> -jar myapp.jar</span></span><br></pre></table></figure><p>您还可以使用命令行参数来提供 JSON，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -jar myapp.jar --spring.application.json=<span class=string>'{"name":"test"}'</span></span></span><br></pre></table></figure><p>您还可以将 JSON 作为 JNDI 变量提供，如下所示：<code>java:comp/env/spring.application.json</code>。</blockquote><h3 id=3-2-1、配置随机值><a class=headerlink href=#3-2-1、配置随机值 title=3.2.1、配置随机值></a>3.2.1、配置随机值</h3><p><code>RandomValuePropertySource</code>可用于注入随机值(例如，Importing 到机密或测试用例中)。它可以产生整数，longs，uuid 或字符串，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>my.secret=${random.value}</span><br><span class=line>my.number=${random.int}</span><br><span class=line>my.bignumber=${random.long}</span><br><span class=line>my.uuid=${random.uuid}</span><br><span class=line>my.number.less.than.ten=${random.int(10)}</span><br><span class=line>my.number.in.range=${random.int[1024,65536]}</span><br></pre></table></figure><p><code>random.int*</code>语法为<code>OPEN value (,max) CLOSE</code>，其中<code>OPEN,CLOSE</code>是任何字符，而<code>value,max</code>是整数。如果提供<code>max</code>，则<code>value</code>是最小值，而<code>max</code>是最大值(不包括)。<h3 id=3-2-2、访问命令行属性><a class=headerlink href=#3-2-2、访问命令行属性 title=3.2.2、访问命令行属性></a>3.2.2、访问命令行属性</h3><p>默认情况下，<code>SpringApplication</code>将任何命令行选项参数(即以<code>--</code>开头的参数，例如<code>--server.port=9000</code>)转换为<code>property</code>并将其添加到 Spring <code>Environment</code>。如前所述，命令行属性始终优先于其他属性源。<p>如果您不想将命令行属性添加到<code>Environment</code>，则可以使用<code>SpringApplication.setAddCommandLineProperties(false)</code>禁用它们。<h3 id=3-2-3、应用程序属性文件><a class=headerlink href=#3-2-3、应用程序属性文件 title=3.2.3、应用程序属性文件></a>3.2.3、应用程序属性文件</h3><p><code>SpringApplication</code>从以下位置的<code>application.properties</code>文件中加载属性，并将它们添加到 Spring <code>Environment</code>中：<ul><li>当前目录的<code>/config</code>子目录<li>当前目录<li>Classpath<code>/config</code>包<li>Classpath 根</ul><p>该列表按优先级排序(在列表较高位置定义的属性会覆盖在较低位置定义的属性)。<blockquote><p>您也可以<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-external-config.html#boot-features-external-config-yaml rel=noopener target=_blank>使用 YAML(‘.yml’)文件</a>替代“ .properties”。</blockquote><p>如果您不喜欢<code>application.properties</code>作为配置文件名，则可以通过指定<code>spring.config.name</code>环境属性来切换到另一个文件名。您还可以使用<code>spring.config.location</code>环境属性(这是目录位置或文件路径的逗号分隔列表)来引用显式位置。下面的示例演示如何指定其他文件名：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -jar myproject.jar --spring.config.name=myproject</span></span><br></pre></table></figure><p>下面的示例演示如何指定两个位置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.propertie</span></span><br></pre></table></figure><blockquote><p><code>spring.config.name</code>和<code>spring.config.location</code>很早就用于确定必须加载哪些文件，因此必须将它们定义为环境属性(通常是 OS 环境变量，系统属性或命令行参数)。</blockquote><p>如果<code>spring.config.location</code>包含目录(而不是文件)，则它们应以<code>/</code>结尾(并且在运行时，应在加载之前附加从<code>spring.config.name</code>生成的名称，包括特定于配置文件的文件名)。 <code>spring.config.location</code>中指定的文件按原样使用，不支持特定于配置文件的变体，并且被任何特定于配置文件的属性覆盖。<p>配置位置以相反的 Sequences 搜索。默认情况下，配置的位置是<code>classpath:/,classpath:/config/,file:./,file:./config/</code>。结果搜索 Sequences 如下：<ul><li><code>file:./config/</code><li><code>file:./</code><li><code>classpath:/config/</code><li><code>classpath:/</code></ul><p>使用<code>spring.config.location</code>配置自定义配置位置后，它们将替换默认位置。例如，如果将<code>spring.config.location</code>配置为值<code>classpath:/custom-config/,file:./custom-config/</code>，则搜索 Sequences 如下：<ul><li><code>file:./custom-config/</code><li><code>classpath:custom-config/</code></ul><p>或者，当使用<code>spring.config.additional-location</code>配置自定义配置位置时，除默认位置外还使用它们。在默认位置之前搜索其他位置。例如，如果配置了<code>classpath:/custom-config/,file:./custom-config/</code>的其他位置，则搜索 Sequences 如下：<ul><li><code>file:./custom-config/</code><li><code>classpath:custom-config/</code><li><code>file:./config/</code><li><code>file:./</code><li><code>classpath:/config/</code><li><code>classpath:/</code></ul><p>通过此搜索 Sequences，您可以在一个配置文件中指定默认值，然后在另一个配置文件中有选择地覆盖这些值。您可以在默认位置之一的<code>application.properties</code>(或使用<code>spring.config.name</code>选择的其他任何基本名称)中为应用程序提供默认值。然后，可以在运行时使用自定义位置之一中的其他文件覆盖这些默认值。<blockquote><p>如果使用环境变量而不是系统属性，则大多数 os 都不允许使用句点分隔的键名，但可以使用下划线代替(例如，<code>SPRING_CONFIG_NAME</code>代替<code>spring.config.name</code>)。<p>如果您的应用程序在容器中运行，则可以使用 JNDI 属性(在<code>java:comp/env</code>中)或 servlet 上下文初始化参数来代替环境变量或系统属性，也可以使用它们。</blockquote><h3 id=3-2-4、特定于配置文件的属性><a class=headerlink href=#3-2-4、特定于配置文件的属性 title=3.2.4、特定于配置文件的属性></a>3.2.4、特定于配置文件的属性</h3><p>除了<code>application.properties</code>个文件之外，还可以使用以下命名约定来定义特定于配置文件的属性：<code>application-{profile}.properties</code>。 <code>Environment</code>具有一组默认配置文件(默认情况下为<code>[default]</code>)，如果未设置任何 Active 配置文件，则使用这些配置文件。换句话说，如果未显式激活任何配置文件，则将加载<code>application-default.properties</code>中的属性。<p>特定于配置文件的属性是从与标准<code>application.properties</code>相同的位置加载的，特定于配置文件的文件总是会覆盖非特定文件，无论特定于配置文件的文件是在打包 jar 的内部还是外部。<p>如果指定了多个配置文件，则采用后赢策略。例如，由<code>spring.profiles.active</code>属性指定的配置文件将添加到通过<code>SpringApplication</code> API 配置的配置文件之后，因此具有优先权。<blockquote><p>如果您在<code>spring.config.location</code>中指定了任何文件，则不会考虑这些文件的特定于配置文件的变体。如果您还想使用特定于配置文件的属性，请使用<code>spring.config.location</code>中的目录。</blockquote><h3 id=3-2-5、属性中的占位符><a class=headerlink href=#3-2-5、属性中的占位符 title=3.2.5、属性中的占位符></a>3.2.5、属性中的占位符</h3><p><code>application.properties</code>中的值在使用时会通过现有的<code>Environment</code>进行过滤，因此您可以参考以前定义的值(例如，从“系统”属性中)。<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>app.name</span>=<span class=string>MyApp</span></span><br><span class=line><span class=attr>app.description</span>=<span class=string>${app.name} is a Spring Boot application</span></span><br></pre></table></figure><blockquote><p>您还可以使用此技术来创建现有 Spring Boot 属性的“简短”变体。</blockquote><h3 id=3-2-6、加密属性><a class=headerlink href=#3-2-6、加密属性 title=3.2.6、加密属性></a>3.2.6、加密属性</h3><p>Spring Boot 不提供对加密属性值的任何内置支持，但是，它确实提供了修改 Spring <code>Environment</code>中包含的值所必需的钩子点。 <code>EnvironmentPostProcessor</code>界面允许您在应用程序启动之前操纵<code>Environment</code>。<p>如果您正在寻找一种安全的方式来存储凭据和密码，则<a href=https://cloud.spring.io/spring-cloud-vault/ rel=noopener target=_blank>Spring Cloud Vault</a>项目提供了对将外部化配置存储在<a href=https://www.vaultproject.io/ rel=noopener target=_blank>HashiCorp Vault</a>中的支持。<h3 id=3-2-7、使用YAML代替属性><a class=headerlink href=#3-2-7、使用YAML代替属性 title=3.2.7、使用YAML代替属性></a>3.2.7、使用YAML代替属性</h3><p><a href=http://yaml.org/ rel=noopener target=_blank>YAML</a>是 JSON 的超集，因此是一种用于指定层次结构配置数据的便捷格式。只要在 Classpath 上具有<a href=http://www.snakeyaml.org/ rel=noopener target=_blank>SnakeYAML</a>库，<code>SpringApplication</code>类就会自动支持 YAML 作为属性的替代方法。<blockquote><p>如果您使用“Starter”，则<code>spring-boot-starter</code>自动提供 SnakeYAML。</blockquote><h4 id=3-2-7-1、加载YAML><a class=headerlink href=#3-2-7-1、加载YAML title=3.2.7.1、加载YAML></a>3.2.7.1、加载YAML</h4><p>Spring Framework 提供了两个方便的类，可用于加载 YAML 文档。 <code>YamlPropertiesFactoryBean</code>将 YAML 加载为<code>Properties</code>，而<code>YamlMapFactoryBean</code>将 YAML 加载为<code>Map</code>。<p>例如，考虑以下 YAML 文档：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=attr>environments:</span></span><br><span class=line>	<span class=attr>dev:</span></span><br><span class=line>		<span class=attr>url:</span> <span class=string>http://dev.example.com</span></span><br><span class=line>		<span class=attr>name:</span> <span class=string>Developer</span> <span class=string>Setup</span></span><br><span class=line>	<span class=attr>prod:</span></span><br><span class=line>		<span class=attr>url:</span> <span class=string>http://another.example.com</span></span><br><span class=line>		<span class=attr>name:</span> <span class=string>My</span> <span class=string>Cool</span> <span class=string>App</span></span><br></pre></table></figure><p>前面的示例将转换为以下属性：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=attr>environments.dev.url</span>=<span class=string>http://dev.example.com</span></span><br><span class=line><span class=attr>environments.dev.name</span>=<span class=string>Developer Setup</span></span><br><span class=line><span class=attr>environments.prod.url</span>=<span class=string>http://another.example.com</span></span><br><span class=line><span class=attr>environments.prod.name</span>=<span class=string>My Cool App</span></span><br></pre></table></figure><p>YAML 列表表示为带有<code>[index]</code>解引用器的属性键。例如，考虑以下 YAML：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=attr>my:</span></span><br><span class=line>    <span class=attr>servers:</span></span><br><span class=line>        <span class=bullet>-</span> <span class=string>dev.example.com</span></span><br><span class=line>        <span class=bullet>-</span> <span class=string>another.example.com</span></span><br></pre></table></figure><p>前面的示例将转换为以下属性：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>my.servers[0]</span>=<span class=string>dev.example.com</span></span><br><span class=line><span class=attr>my.servers[1]</span>=<span class=string>another.example.com</span></span><br></pre></table></figure><p>要使用 Spring Boot 的<code>Binder</code>Util(即<code>@ConfigurationProperties</code>所做的)绑定到类似的属性，您需要在<code>java.util.List</code>(或<code>Set</code>)类型的目标 bean 中具有一个属性，并且需要提供 setter 或使用 a 初始化它。可变值。例如，以下示例绑定到前面显示的属性：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@ConfigurationProperties(prefix="my")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Config</span> {</span><br><span class=line>	<span class=keyword>private</span> List&LTString> servers = <span class=keyword>new</span> <span class="title class_">ArrayList</span>&LTString>();</span><br><span class=line>	<span class=keyword>public</span> List&LTString> <span class="title function_">getServers</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.servers;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-2-7-2、在Spring中将YAML公开为属性><a class=headerlink href=#3-2-7-2、在Spring中将YAML公开为属性 title=3.2.7.2、在Spring中将YAML公开为属性></a>3.2.7.2、在Spring中将YAML公开为属性</h4><p><code>YamlPropertySourceLoader</code>类可用于在 Spring <code>Environment</code>中将 YAML 公开为<code>PropertySource</code>。这样做使您可以将<code>@Value</code>Comments 与占位符语法一起使用以访问 YAML 属性。<h4 id=3-2-7-3、多配置文件YAML文档><a class=headerlink href=#3-2-7-3、多配置文件YAML文档 title=3.2.7.3、多配置文件YAML文档></a>3.2.7.3、多配置文件YAML文档</h4><p>您可以使用<code>spring.profiles</code>键在一个文件中指定多个特定于配置文件的 YAML 文档，以指示何时应用该文档，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>server:</span><br><span class=line>	address: 192.168.1.100</span><br><span class=line>---</span><br><span class=line>spring:</span><br><span class=line>	profiles: development</span><br><span class=line>server:</span><br><span class=line>	address: 127.0.0.1</span><br><span class=line>---</span><br><span class=line>spring:</span><br><span class=line>	profiles: production & eu-central</span><br><span class=line>server:</span><br><span class=line>	address: 192.168.1.120</span><br></pre></table></figure><p>在前面的示例中，如果<code>development</code>配置文件处于 Active 状态，则<code>server.address</code>属性为<code>127.0.0.1</code>。同样，如果<code>production</code>和<code>eu-central</code>配置文件处于 Active 状态，则<code>server.address</code>属性为<code>192.168.1.120</code>。如果<code>development</code>，<code>production</code>和<code>eu-central</code>配置文件未启用，则该属性的值为<code>192.168.1.100</code>。<blockquote><p>因此<code>spring.profiles</code>可以包含一个简单的配置文件名称(例如<code>production</code>)或一个配置文件表达式。配置文件表达式允许表达更复杂的配置文件逻辑，例如<code>production & (eu-central | eu-west)</code>。查看<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/core.html#beans-definition-profiles-java rel=noopener target=_blank>reference guide</a>以获取更多详细信息。</blockquote><p>如果在启动应用程序上下文时未明确激活任何 Active，则会激活默认配置文件。因此，在以下 YAML 中，我们为<code>spring.security.user.password</code>设置了一个值，该值在”default”配置文件中仅**可用：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=attr>server:</span></span><br><span class=line>  <span class=attr>port:</span> <span class=number>8000</span></span><br><span class=line><span class=meta>---</span></span><br><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>profiles:</span> <span class=string>default</span></span><br><span class=line>  <span class=attr>security:</span></span><br><span class=line>    <span class=attr>user:</span></span><br><span class=line>      <span class=attr>password:</span> <span class=string>weak</span></span><br></pre></table></figure><p>而在以下示例中，始终设置密码是因为该密码未附加到任何配置文件，并且必须根据需要在所有其他配置文件中将其显式重置：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=attr>server:</span></span><br><span class=line>  <span class=attr>port:</span> <span class=number>8000</span></span><br><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>security:</span></span><br><span class=line>    <span class=attr>user:</span></span><br><span class=line>      <span class=attr>password:</span> <span class=string>weak</span></span><br></pre></table></figure><p>通过使用<code>spring.profiles</code>元素指定的 Spring 轮廓可以选择通过使用<code>!</code>字符来否定。如果为单个文档同时指定了否定的配置文件和否定的配置文件，则至少一个非否定的配置文件必须匹配，并且否定的配置文件不能匹配。<h4 id=3-2-7-4、YAML缺点><a class=headerlink href=#3-2-7-4、YAML缺点 title=3.2.7.4、YAML缺点></a>3.2.7.4、YAML缺点</h4><p>无法使用<code>@PropertySource</code>Comments 加载 YAML 文件。因此，在需要以这种方式加载值的情况下，需要使用属性文件。<h3 id=3-2-8、类型安全的配置属性><a class=headerlink href=#3-2-8、类型安全的配置属性 title=3.2.8、类型安全的配置属性></a>3.2.8、类型安全的配置属性</h3><p>使用<code>@Value("${property}")</code>注解注入配置属性有时会很麻烦，尤其是当您使用多个属性或数据本质上是分层的时。 Spring Boot 提供了一种使用属性的替代方法，该方法使强类型的 Bean 可以 Management 和验证应用程序的配置，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.example;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.net.InetAddress;</span><br><span class=line><span class=keyword>import</span> java.util.ArrayList;</span><br><span class=line><span class=keyword>import</span> java.util.Collections;</span><br><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=line></span><br><span class=line><span class=meta>@ConfigurationProperties("acme")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AcmeProperties</span> {</span><br><span class=line></span><br><span class=line>	<span class=keyword>private</span> <span class=type>boolean</span> enabled;</span><br><span class=line></span><br><span class=line>	<span class=keyword>private</span> InetAddress remoteAddress;</span><br><span class=line></span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> <span class=type>Security</span> <span class=variable>security</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Security</span>();</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">isEnabled</span><span class=params>()</span> { ... }</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setEnabled</span><span class=params>(<span class=type>boolean</span> enabled)</span> { ... }</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> InetAddress <span class="title function_">getRemoteAddress</span><span class=params>()</span> { ... }</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setRemoteAddress</span><span class=params>(InetAddress remoteAddress)</span> { ... }</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> Security <span class="title function_">getSecurity</span><span class=params>()</span> { ... }</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">Security</span> {</span><br><span class=line></span><br><span class=line>		<span class=keyword>private</span> String username;</span><br><span class=line></span><br><span class=line>		<span class=keyword>private</span> String password;</span><br><span class=line></span><br><span class=line>		<span class=keyword>private</span> List&LTString> roles = <span class=keyword>new</span> <span class="title class_">ArrayList</span><>(Collections.singleton(<span class=string>"USER"</span>));</span><br><span class=line></span><br><span class=line>		<span class=keyword>public</span> String <span class="title function_">getUsername</span><span class=params>()</span> { ... }</span><br><span class=line></span><br><span class=line>		<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setUsername</span><span class=params>(String username)</span> { ... }</span><br><span class=line></span><br><span class=line>		<span class=keyword>public</span> String <span class="title function_">getPassword</span><span class=params>()</span> { ... }</span><br><span class=line></span><br><span class=line>		<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setPassword</span><span class=params>(String password)</span> { ... }</span><br><span class=line></span><br><span class=line>		<span class=keyword>public</span> List&LTString> <span class="title function_">getRoles</span><span class=params>()</span> { ... }</span><br><span class=line></span><br><span class=line>		<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setRoles</span><span class=params>(List&LTString> roles)</span> { ... }</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>前面的 POJO 定义了以下属性：<ul><li><code>acme.enabled</code>，默认值为<code>false</code>。<li><code>acme.remote-address</code>，其类型可以从<code>String</code>强制转换。<li><code>acme.security.username</code>，带有嵌套的“安全”对象，其名称由属性名称确定。特别是，返回类型在那里根本不使用，可能是<code>SecurityProperties</code>。<li><code>acme.security.password</code> .<li><code>acme.security.roles</code>，集合为<code>String</code>。</ul><blockquote><p>Getter 和 Setter 通常是强制性的，因为绑定是通过标准 Java Beans 属性 Descriptors 进行的，就像在 Spring MVC 中一样。在以下情况下，可以忽略二传手：<ul><li>只要将 Map 初始化，它们就需要使用吸气剂，但不一定需要使用 setter，因为它们可以被 Binder 改变。<li>可以通过索引(通常使用 YAML)或使用单个逗号分隔的值(属性)来访问集合和数组。在后一种情况下，必须使用二传手。我们建议始终为此类类型添加设置器。如果初始化集合，请确保它不是不可变的(如上例所示)。<li>如果初始化嵌套的 POJO 属性(如上例中的<code>Security</code>字段)，则不需要设置器。如果希望 Binder 通过使用其默认构造函数动态创建实例，则需要一个 setter。</ul><p>有些人使用 Lombok 项目自动添加获取器和设置器。确保 Lombok 不会为这种类型生成任何特定的构造函数，因为容器会自动使用它来实例化该对象。<p>最后，仅考虑标准 Java Bean 属性，不支持对静态属性的绑定。<p>另请参见<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-external-config.html#boot-features-external-config-vs-value rel=noopener target=_blank>@Value 和@ConfigurationProperties 之间的区别</a>。</blockquote><p>您还需要列出要在<code>@EnableConfigurationProperties</code>注解中注册的属性类，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableConfigurationProperties(AcmeProperties.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyConfiguration</span> {</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>以这种方式注册<code>@ConfigurationProperties</code> bean 时，该 bean 具有常规名称：<code>&LTprefix>-&LTfqn></code>，其中<code>&LTprefix></code>是<code>@ConfigurationProperties</code>注解中指定的环境密钥前缀，而<code>&LTfqn></code>是 bean 的全限定名。如果 Comments 不提供任何前缀，则仅使用 Bean 的完全限定名称。<p>上例中的 bean 名称是<code>acme-com.example.AcmeProperties</code>。</blockquote><p>即使前面的配置为<code>AcmeProperties</code>创建了一个常规 bean，我们也建议<code>@ConfigurationProperties</code>只处理环境，尤其不要从上下文中注入其他 bean。话虽如此，<code>@EnableConfigurationProperties</code>注解也会自动应用到您的项目中，从而可以从<code>Environment</code>配置任何以<code>@ConfigurationProperties</code>注解的现有 bean。您可以通过确保<code>AcmeProperties</code>已经是 Bean 来快捷方式<code>MyConfiguration</code>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@ConfigurationProperties(prefix="acme")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AcmeProperties</span> {</span><br><span class=line></span><br><span class=line>	<span class=comment>// ... see the preceding example</span></span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><p>这种配置风格特别适用于<code>SpringApplication</code>外部 YAML 配置，如以下示例所示：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=comment># application.yml</span></span><br><span class=line></span><br><span class=line><span class=attr>acme:</span></span><br><span class=line>	<span class=attr>remote-address:</span> <span class=number>192.168</span><span class=number>.1</span><span class=number>.1</span></span><br><span class=line>	<span class=attr>security:</span></span><br><span class=line>		<span class=attr>username:</span> <span class=string>admin</span></span><br><span class=line>		<span class=attr>roles:</span></span><br><span class=line>		  <span class=bullet>-</span> <span class=string>USER</span></span><br><span class=line>		  <span class=bullet>-</span> <span class=string>ADMIN</span></span><br><span class=line></span><br><span class=line><span class=comment># additional configuration as required</span></span><br></pre></table></figure><p>要使用<code>@ConfigurationProperties</code> bean，可以像使用其他任何 bean 一样注入它们，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyService</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> AcmeProperties properties;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyService</span><span class=params>(AcmeProperties properties)</span> {</span><br><span class=line>	    <span class=built_in>this</span>.properties = properties;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line> 	<span class=comment>//...</span></span><br><span class=line></span><br><span class=line>	<span class=meta>@PostConstruct</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">openConnection</span><span class=params>()</span> {</span><br><span class=line>		<span class=type>Server</span> <span class=variable>server</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Server</span>(<span class=built_in>this</span>.properties.getRemoteAddress());</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-2-8-1、第三方配置><a class=headerlink href=#3-2-8-1、第三方配置 title=3.2.8.1、第三方配置></a>3.2.8.1、第三方配置</h4><p>除了使用<code>@ConfigurationProperties</code>Comments 类，您还可以在公共<code>@Bean</code>方法上使用它。当您要将属性绑定到控件之外的第三方组件时，这样做特别有用。<p>要通过<code>Environment</code>属性配置 bean，请将<code>@ConfigurationProperties</code>添加到其 bean 注册中，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>@ConfigurationProperties(prefix = "another")</span><br><span class=line>@Bean</span><br><span class=line>public AnotherComponent anotherComponent() {</span><br><span class=line>	...</span><br><span class=line>}</span><br></pre></table></figure><p>用<code>another</code>前缀定义的任何属性都以类似于前面<code>AcmeProperties</code>示例的方式 Map 到该<code>AnotherComponent</code> bean。<h4 id=3-2-8-2、轻松绑定><a class=headerlink href=#3-2-8-2、轻松绑定 title=3.2.8.2、轻松绑定></a>3.2.8.2、轻松绑定</h4><p>Spring Boot 使用一些宽松的规则将<code>Environment</code>属性绑定到<code>@ConfigurationProperties</code> bean，因此<code>Environment</code>属性名称和 bean 属性名称之间不需要完全匹配。有用的常见示例包括破折号分隔的环境属性(例如<code>context-path</code>绑定到<code>contextPath</code>)和大写的环境属性(例如<code>PORT</code>绑定到<code>port</code>)。<p>例如，考虑以下<code>@ConfigurationProperties</code>类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>@ConfigurationProperties(prefix="acme.my-project.person")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">OwnerProperties</span> {</span><br><span class=line>	<span class=keyword>private</span> String firstName;</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> String <span class="title function_">getFirstName</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.firstName;</span><br><span class=line>	}</span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setFirstName</span><span class=params>(String firstName)</span> {</span><br><span class=line>		<span class=built_in>this</span>.firstName = firstName;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>在前面的示例中，可以全部使用以下属性名称：<p><strong>表 24.1. 轻松绑定</strong><table><thead><tr><th>Property<th>Note<tbody><tr><td><code>acme.my-project.person.first-name</code><td>Kebab 情况，建议在<code>.properties</code>和<code>.yml</code>文件中使用。<tr><td><code>acme.myProject.person.firstName</code><td>标准驼峰式语法。<tr><td><code>acme.my_project.person.first_name</code><td>下划线表示法，是在<code>.properties</code>和<code>.yml</code>文件中使用的另一种格式。<tr><td><code>ACME_MYPROJECT_PERSON_FIRSTNAME</code><td>大写格式，使用系统环境变量时建议使用。</table><blockquote><p>Comments*的<code>prefix</code>值必须为 kebab(小写并由<code>-</code>分隔，例如<code>acme.my-project.person</code>)。</blockquote><p><strong>表 24.2. 每个资源来源的宽松绑定规则</strong><table><thead><tr><th>Property Source<th>Simple<th>List<tbody><tr><td>Properties Files<td>骆驼案，烤肉串案或下划线<td>使用<code>[ ]</code>或逗号分隔值的标准列表语法<tr><td>YAML Files<td>骆驼案，烤肉串案或下划线<td>标准 YAML 列表语法或逗号分隔的值<tr><td>Environment Variables<td>以下划线作为定界符的大写格式。 <code>_</code>不应在属性名称中使用<td>带有下划线的数字值，例如<code>MY_ACME_1_OTHER = my.acme[1].other</code><tr><td>System properties<td>骆驼案，烤肉串案或下划线<td>使用<code>[ ]</code>或逗号分隔值的标准列表语法</table><blockquote><p>我们建议，如果可能的话，属性以小写的 kebab 格式存储，例如<code>my.property-name=acme</code>。</blockquote><p>绑定到<code>Map</code>属性时，如果<code>key</code>包含小写字母数字字符或<code>-</code>以外的任何内容，则需要使用方括号表示法，以便保留原始值。如果键没有被<code>[]</code>包围，则所有非字母数字或<code>-</code>的字符都将被删除。例如，考虑将以下属性绑定到<code>Map</code>：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>acme:</span><br><span class=line>  map:</span><br><span class=line>    "[/key1]": value1</span><br><span class=line>    "[/key2]": value2</span><br><span class=line>    /key3: value3</span><br></pre></table></figure><p>上面的属性将绑定到<code>Map</code>，其中<code>/key1</code>，<code>/key2</code>和<code>key3</code>作为 Map 中的键。<h4 id=3-2-8-3、合并复杂类型><a class=headerlink href=#3-2-8-3、合并复杂类型 title=3.2.8.3、合并复杂类型></a>3.2.8.3、合并复杂类型</h4><p>如果在多个位置配置了列表，则通过替换整个列表来进行覆盖。<p>例如，假设一个<code>MyPojo</code>对象的<code>name</code>和<code>description</code>属性默认为<code>null</code>。以下示例公开了<code>AcmeProperties</code>中的<code>MyPojo</code>个对象的列表：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@ConfigurationProperties("acme")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AcmeProperties</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> List&LTMyPojo> list = <span class=keyword>new</span> <span class="title class_">ArrayList</span><>();</span><br><span class=line>	<span class=keyword>public</span> List&LTMyPojo> <span class="title function_">getList</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.list;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>考虑以下配置：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=attr>acme:</span></span><br><span class=line>  <span class=attr>list:</span></span><br><span class=line>    <span class=bullet>-</span> <span class=attr>name:</span> <span class=string>my</span> <span class=string>name</span></span><br><span class=line>      <span class=attr>description:</span> <span class=string>my</span> <span class=string>description</span></span><br><span class=line><span class=meta>---</span></span><br><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>profiles:</span> <span class=string>dev</span></span><br><span class=line><span class=attr>acme:</span></span><br><span class=line>  <span class=attr>list:</span></span><br><span class=line>    <span class=bullet>-</span> <span class=attr>name:</span> <span class=string>my</span> <span class=string>another</span> <span class=string>name</span></span><br></pre></table></figure><p>如果<code>dev</code>配置文件无效，则<code>AcmeProperties.list</code>包含一个<code>MyPojo</code>条目，如先前所定义。但是，如果启用了<code>dev</code>配置文件，则<code>list</code> <em>仍然</em>仅包含一个条目(名称为<code>my another name</code>和描述为<code>null</code>)。此配置<em>不会</em>将第二个<code>MyPojo</code>实例添加到列表中，并且不会合并项目。<p>在多个配置文件中指定<code>List</code>时，将使用优先级最高的(并且只有该优先级)。考虑以下示例：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=attr>acme:</span></span><br><span class=line>  <span class=attr>list:</span></span><br><span class=line>    <span class=bullet>-</span> <span class=attr>name:</span> <span class=string>my</span> <span class=string>name</span></span><br><span class=line>      <span class=attr>description:</span> <span class=string>my</span> <span class=string>description</span></span><br><span class=line>    <span class=bullet>-</span> <span class=attr>name:</span> <span class=string>another</span> <span class=string>name</span></span><br><span class=line>      <span class=attr>description:</span> <span class=string>another</span> <span class=string>description</span></span><br><span class=line><span class=meta>---</span></span><br><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>profiles:</span> <span class=string>dev</span></span><br><span class=line><span class=attr>acme:</span></span><br><span class=line>  <span class=attr>list:</span></span><br><span class=line>    <span class=bullet>-</span> <span class=attr>name:</span> <span class=string>my</span> <span class=string>another</span> <span class=string>name</span></span><br></pre></table></figure><p>在前面的示例中，如果<code>dev</code>配置文件处于 Active 状态，则<code>AcmeProperties.list</code>包含* one * <code>MyPojo</code>条目(名称为<code>my another name</code>且描述为<code>null</code>)。对于 YAML，可以使用逗号分隔的列表和 YAML 列表来完全覆盖列表的内容。<p>对于<code>Map</code>属性，您可以绑定从多个来源获取的属性值。但是，对于多个源中的同一属性，将使用优先级最高的属性。以下示例从<code>AcmeProperties</code>公开<code>Map&LTString, MyPojo></code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@ConfigurationProperties("acme")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AcmeProperties</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> Map&LTString, MyPojo> map = <span class=keyword>new</span> <span class="title class_">HashMap</span><>();</span><br><span class=line>	<span class=keyword>public</span> Map&LTString, MyPojo> <span class="title function_">getMap</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.map;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>考虑以下配置：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=attr>acme:</span></span><br><span class=line>  <span class=attr>map:</span></span><br><span class=line>    <span class=attr>key1:</span></span><br><span class=line>      <span class=attr>name:</span> <span class=string>my</span> <span class=string>name</span> <span class=number>1</span></span><br><span class=line>      <span class=attr>description:</span> <span class=string>my</span> <span class=string>description</span> <span class=number>1</span></span><br><span class=line><span class=meta>---</span></span><br><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>profiles:</span> <span class=string>dev</span></span><br><span class=line><span class=attr>acme:</span></span><br><span class=line>  <span class=attr>map:</span></span><br><span class=line>    <span class=attr>key1:</span></span><br><span class=line>      <span class=attr>name:</span> <span class=string>dev</span> <span class=string>name</span> <span class=number>1</span></span><br><span class=line>    <span class=attr>key2:</span></span><br><span class=line>      <span class=attr>name:</span> <span class=string>dev</span> <span class=string>name</span> <span class=number>2</span></span><br><span class=line>      <span class=attr>description:</span> <span class=string>dev</span> <span class=string>description</span> <span class=number>2</span></span><br></pre></table></figure><p>如果<code>dev</code>配置文件未激活，则<code>AcmeProperties.map</code>包含一个键为<code>key1</code>的条目(名称为<code>my name 1</code>和描述为<code>my description 1</code>)。但是，如果启用了<code>dev</code>配置文件，则<code>map</code>包含两个条目，其中包含键<code>key1</code>(名称为<code>dev name 1</code>和<code>my description 1</code>的描述)和<code>key2</code>(名称为<code>dev name 2</code>和<code>dev description 2</code>的描述)。<blockquote><p>前述合并规则不仅适用于 YAML 文件，而且适用于所有属性源中的属性。</blockquote><h4 id=3-2-8-4、属性转换><a class=headerlink href=#3-2-8-4、属性转换 title=3.2.8.4、属性转换></a>3.2.8.4、属性转换</h4><p>当 Spring Boot 绑定到<code>@ConfigurationProperties</code> bean 时，它尝试将外部应用程序属性强制为正确的类型。如果需要自定义类型转换，则可以提供<code>ConversionService</code> bean(使用名为<code>conversionService</code>的 bean)或自定义属性编辑器(通过<code>CustomEditorConfigurer</code> bean)或自定义<code>Converters</code>(将 bean 定义标注为<code>@ConfigurationPropertiesBinding</code>)。<blockquote><p>由于在应用程序生命周期中非常早就请求了此 bean，因此请确保限制您的<code>ConversionService</code>使用的依赖项。通常，您需要的任何依赖项可能在创建时未完全初始化。如果配置键强制不需要自定义<code>ConversionService</code>，而只依赖于具有<code>@ConfigurationPropertiesBinding</code>限定的自定义转换器，则可能要重命名。</blockquote><h5 id=Converting-durations><a title="Converting durations" class=headerlink href=#Converting-durations></a>Converting durations</h5><p>Spring Boot 为表达持续时间提供了专门的支持。如果公开<code>java.time.Duration</code>属性，则应用程序属性中的以下格式可用：<ul><li>常规<code>long</code>表示形式(使用毫秒作为默认单位，除非已指定<code>@DurationUnit</code>)<li>标准 ISO-8601 格式<a href=https://docs.oracle.com/javase/8/docs/api//java/time/Duration.html#parse-java.lang.CharSequence- rel=noopener target=_blank>由 java.util.Duration 使用</a><li>值和单位相结合的更易读的格式(例如<code>10s</code>表示 10 秒)</ul><p>考虑以下示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=meta>@ConfigurationProperties("app.system")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppSystemProperties</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@DurationUnit(ChronoUnit.SECONDS)</span></span><br><span class=line>	<span class=keyword>private</span> <span class=type>Duration</span> <span class=variable>sessionTimeout</span> <span class=operator>=</span> Duration.ofSeconds(<span class=number>30</span>);</span><br><span class=line></span><br><span class=line>	<span class=keyword>private</span> <span class=type>Duration</span> <span class=variable>readTimeout</span> <span class=operator>=</span> Duration.ofMillis(<span class=number>1000</span>);</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> Duration <span class="title function_">getSessionTimeout</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.sessionTimeout;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setSessionTimeout</span><span class=params>(Duration sessionTimeout)</span> {</span><br><span class=line>		<span class=built_in>this</span>.sessionTimeout = sessionTimeout;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> Duration <span class="title function_">getReadTimeout</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.readTimeout;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setReadTimeout</span><span class=params>(Duration readTimeout)</span> {</span><br><span class=line>		<span class=built_in>this</span>.readTimeout = readTimeout;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>要指定 30 秒的会话超时，<code>30</code>，<code>PT30S</code>和<code>30s</code>都是等效的。可以采用以下任何形式指定 500ms 的读取超时：<code>500</code>，<code>PT0.5S</code>和<code>500ms</code>。<p>您也可以使用任何受支持的单位。这些是：<ul><li><code>ns</code>纳秒<li><code>us</code>微秒<li><code>ms</code>毫秒<li><code>s</code>秒<li><code>m</code>分钟<li><code>h</code>小时<li><code>d</code>天</ul><p>默认单位是毫秒，可以使用<code>@DurationUnit</code>覆盖，如上面的示例所示。<h5 id=转换数据大小><a class=headerlink href=#转换数据大小 title=转换数据大小></a>转换数据大小</h5><p>Spring Framework 的<code>DataSize</code>值类型允许以字节表示大小。如果公开<code>DataSize</code>属性，则应用程序属性中的以下格式可用：<ul><li>常规的<code>long</code>表示形式(除非已指定<code>@DataSizeUnit</code>，否则使用字节作为默认单位)<li>值和单位耦合在一起的更具可读性的格式(例如<code>10MB</code>表示 10 兆字节)</ul><p>考虑以下示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=meta>@ConfigurationProperties("app.io")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppIoProperties</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@DataSizeUnit(DataUnit.MEGABYTES)</span></span><br><span class=line>	<span class=keyword>private</span> <span class=type>DataSize</span> <span class=variable>bufferSize</span> <span class=operator>=</span> DataSize.ofMegabytes(<span class=number>2</span>);</span><br><span class=line></span><br><span class=line>	<span class=keyword>private</span> <span class=type>DataSize</span> <span class=variable>sizeThreshold</span> <span class=operator>=</span> DataSize.ofBytes(<span class=number>512</span>);</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> DataSize <span class="title function_">getBufferSize</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.bufferSize;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setBufferSize</span><span class=params>(DataSize bufferSize)</span> {</span><br><span class=line>		<span class=built_in>this</span>.bufferSize = bufferSize;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> DataSize <span class="title function_">getSizeThreshold</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.sizeThreshold;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setSizeThreshold</span><span class=params>(DataSize sizeThreshold)</span> {</span><br><span class=line>		<span class=built_in>this</span>.sizeThreshold = sizeThreshold;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>要指定 10 MB 的缓冲区大小，<code>10</code>和<code>10MB</code>是等效的。可以将 256 个字节的大小阈值指定为<code>256</code>或<code>256B</code>。<p>您也可以使用任何受支持的单位。这些是：<ul><li><code>B</code>个字节<li><code>KB</code>千字节<li><code>MB</code>代表兆字节<li><code>GB</code>代表千兆字节<li><code>TB</code>代表兆兆字节</ul><p>默认单位是字节，可以使用<code>@DataSizeUnit</code>覆盖，如上面的示例所示。<h4 id=3-2-8-5、-ConfigurationProperties-验证><a title="3.2.8.5、@ConfigurationProperties 验证" class=headerlink href=#3-2-8-5、-ConfigurationProperties-验证></a>3.2.8.5、@ConfigurationProperties 验证</h4><p>每当使用 Spring 的<code>@Validated</code>Comments 进行 Comments 时，Spring Boot 就会尝试验证<code>@ConfigurationProperties</code>类。您可以在配置类上直接使用 JSR-303 <code>javax.validation</code>约束 Comments。为此，请确保在 Classpath 上有兼容的 JSR-303 实现，然后将约束 Comments 添加到字段中，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@ConfigurationProperties(prefix="acme")</span></span><br><span class=line><span class=meta>@Validated</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AcmeProperties</span> {</span><br><span class=line>	<span class=meta>@NotNull</span></span><br><span class=line>	<span class=keyword>private</span> InetAddress remoteAddress;</span><br><span class=line></span><br><span class=line>	<span class=comment>// ... getters and setters</span></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>您还可以通过使用<code>@Validated</code>Comments 创建配置属性的<code>@Bean</code>方法来触发验证。</blockquote><p>尽管嵌套属性在绑定时也会被验证，但是最好将关联的字段 Comments 为<code>@Valid</code>。这样可以确保即使没有嵌套属性也可以触发验证。以下示例基于前面的<code>AcmeProperties</code>示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>@ConfigurationProperties(prefix="acme")</span></span><br><span class=line><span class=meta>@Validated</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AcmeProperties</span> {</span><br><span class=line>	<span class=meta>@NotNull</span></span><br><span class=line>	<span class=keyword>private</span> InetAddress remoteAddress;</span><br><span class=line>	<span class=meta>@Valid</span></span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> <span class=type>Security</span> <span class=variable>security</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Security</span>();</span><br><span class=line></span><br><span class=line>	<span class=comment>// ... getters and setters</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">Security</span> {</span><br><span class=line>		<span class=meta>@NotEmpty</span></span><br><span class=line>		<span class=keyword>public</span> String username;</span><br><span class=line>		<span class=comment>// ... getters and setters</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>您还可以通过创建名为<code>configurationPropertiesValidator</code>的 bean 定义来添加自定义 Spring <code>Validator</code>。 <code>@Bean</code>方法应声明为<code>static</code>。配置属性验证器是在应用程序生命周期的早期创建的，并且将<code>@Bean</code>方法声明为静态方法可以使 Bean 得以创建而不必实例化<code>@Configuration</code>类。这样做可以避免因早期实例化而引起的任何问题。有一个<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-samples/spring-boot-sample-property-validation rel=noopener target=_blank>属性验证 samples</a>显示了如何进行设置。<blockquote><p><code>spring-boot-actuator</code>模块包含一个公开所有<code>@ConfigurationProperties</code> bean 的端点。将您的 Web 浏览器指向<code>/actuator/configprops</code>或使用等效的 JMX 端点。</blockquote><h4 id=3-2-8-6、-ConfigurationProperties-与-Value><a title="3.2.8.6、@ConfigurationProperties 与@Value" class=headerlink href=#3-2-8-6、-ConfigurationProperties-与-Value></a>3.2.8.6、@ConfigurationProperties 与@Value</h4><p><code>@Value</code>注解是核心容器功能，它没有提供与类型安全的配置属性相同的功能。下表总结了<code>@ConfigurationProperties</code>和<code>@Value</code>支持的功能：<table><thead><tr><th>Feature<th><code>@ConfigurationProperties</code><th><code>@Value</code><tbody><tr><td><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-external-config.html#boot-features-external-config-relaxed-binding rel=noopener target=_blank>Relaxed binding</a><td>Yes<td>No<tr><td><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/configuration-metadata.html rel=noopener target=_blank>Meta-data support</a><td>Yes<td>No<tr><td><code>SpEL</code>评估<td>No<td>Yes</table><p>如果您为自己的组件定义了一组配置键，我们建议您将它们组合在以<code>@ConfigurationProperties</code>Comments 的 POJO 中。您还应该意识到，由于<code>@Value</code>不支持宽松的绑定，因此如果您需要使用环境变量来提供值，则它不是很好的选择。<p>最后，尽管您可以在<code>@Value</code>中编写<code>SpEL</code>表达式，但不会从<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-external-config.html#boot-features-external-config-application-property-files rel=noopener target=_blank>应用程序属性文件</a>处理此类表达式。<h2 id=3-3、Profiles><a class=headerlink href=#3-3、Profiles title=3.3、Profiles></a>3.3、Profiles</h2><p>Spring Profiles 提供了一种隔离应用程序配置的各部分并使之仅在某些环境中可用的方法。可以用<code>@Profile</code>标记任何<code>@Component</code>或<code>@Configuration</code>以限制其加载时间，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@Profile("production")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ProductionConfiguration</span> {</span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>您可以使用<code>spring.profiles.active</code> <code>Environment</code>属性来指定哪些配置文件处于 Active 状态。您可以通过本章前面介绍的任何方式指定属性。例如，您可以将其包含在<code>application.properties</code>中，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.profiles.active=dev,hsqldb</span><br></pre></table></figure><p>您还可以使用以下开关在命令行上指定它：<code>--spring.profiles.active=dev,hsqldb</code>。<h3 id=3-3-1、添加-Active-配置文件><a title="3.3.1、添加 Active 配置文件" class=headerlink href=#3-3-1、添加-Active-配置文件></a>3.3.1、添加 Active 配置文件</h3><p><code>spring.profiles.active</code>属性遵循与其他属性相同的排序规则：最高<code>PropertySource</code>获胜。这意味着您可以在<code>application.properties</code>中指定 Active 配置文件，然后使用命令行开关“替换”它们。<p>有时，将特定于配置文件的属性“添加”到 Active 配置文件而不是替换它们很有用。 <code>spring.profiles.include</code>属性可用于无条件添加 Active 配置文件。 <code>SpringApplication</code>入口点还具有 Java API，用于设置其他配置文件(即，在<code>spring.profiles.active</code>属性激活的配置文件之上)。请参见<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/SpringApplication.html rel=noopener target=_blank>SpringApplication</a>中的<code>setAdditionalProfiles()</code>方法。<p>例如，当使用开关<code>--spring.profiles.active=prod</code>运行具有以下属性的应用程序时，还将激活<code>proddb</code>和<code>prodmq</code>配置文件：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>---</span></span><br><span class=line><span class=attr>my.property:</span> <span class=string>fromyamlfile</span></span><br><span class=line><span class=meta>---</span></span><br><span class=line><span class=attr>spring.profiles:</span> <span class=string>prod</span></span><br><span class=line><span class=attr>spring.profiles.include:</span></span><br><span class=line>  <span class=bullet>-</span> <span class=string>proddb</span></span><br><span class=line>  <span class=bullet>-</span> <span class=string>prodmq</span></span><br></pre></table></figure><blockquote><p>请记住，可以在 YAML 文档中定义<code>spring.profiles</code>属性，以确定何时将该特定文档包括在配置中。</blockquote><h3 id=3-3-2、以编程方式设置配置文件><a class=headerlink href=#3-3-2、以编程方式设置配置文件 title=3.3.2、以编程方式设置配置文件></a>3.3.2、以编程方式设置配置文件</h3><p>您可以在应用程序运行之前通过调用<code>SpringApplication.setAdditionalProfiles(…)</code>以编程方式设置 Active 配置文件。也可以使用 Spring 的<code>ConfigurableEnvironment</code>界面激活配置文件。<h3 id=3-3-3、特定于配置文件的配置文件><a class=headerlink href=#3-3-3、特定于配置文件的配置文件 title=3.3.3、特定于配置文件的配置文件></a>3.3.3、特定于配置文件的配置文件</h3><p><code>application.properties</code>(或<code>application.yml</code>)和通过<code>@ConfigurationProperties</code>引用的文件的特定于配置文件的变体都被视为文件并已加载。<h2 id=3-4、Logging><a class=headerlink href=#3-4、Logging title=3.4、Logging></a>3.4、Logging</h2><p>Spring Boot 使用<a href=https://commons.apache.org/logging rel=noopener target=_blank>Commons Logging</a>进行所有内部日志记录，但是使底层日志实现保持打开状态。为<a href=https://docs.oracle.com/javase/8/docs/api//java/util/logging/package-summary.html rel=noopener target=_blank>Java Util 记录</a>，<a href=https://logging.apache.org/log4j/2.x/ rel=noopener target=_blank>Log4J2</a>和<a href=http://logback.qos.ch/ rel=noopener target=_blank>Logback</a>提供了默认配置。在每种情况下，Logger 都已预先配置为使用控制台输出，同时还提供可选文件输出。<p>默认情况下，如果使用“启动器”，则使用 Logback 进行日志记录。还包括适当的 Logback 路由，以确保使用 Java Util Logging，Commons Logging，Log4J 或 SLF4J 的从属库均能正常工作。<blockquote><p>有许多可用于 Java 的日志记录框架。如果上面的列表看起来令人困惑，请不要担心。通常，您不需要更改日志记录依赖项，并且 Spring Boot 默认值可以正常工作。</blockquote><h3 id=3-4-1、日志格式><a class=headerlink href=#3-4-1、日志格式 title=3.4.1、日志格式></a>3.4.1、日志格式</h3><p>Spring Boot 的默认日志输出类似于以下示例：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>2014-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52</span><br><span class=line>2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class=line>2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms</span><br><span class=line>2014-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]</span><br><span class=line>2014-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]</span><br></pre></table></figure><p>输出以下项目：<ul><li>日期和时间：毫秒精度，易于排序。<li>日志级别：<code>ERROR</code>，<code>WARN</code>，<code>INFO</code>，<code>DEBUG</code>或<code>TRACE</code>。<li>Process ID.<li><code>---</code>分隔符用于区分实际日志消息的开始。<li>线程名称：用方括号括起来(对于控制台输出可能会被截断)。<li>Logger 名称：这通常是源类名称(通常缩写)。<li>日志消息。</ul><blockquote><p>Logback 没有<code>FATAL</code>级别。它 Map 到<code>ERROR</code>。</blockquote><h3 id=3-4-2、控制台输出><a class=headerlink href=#3-4-2、控制台输出 title=3.4.2、控制台输出></a>3.4.2、控制台输出</h3><p>缺省日志配置在写入消息时将消息回显到控制台。默认情况下，将记录<code>ERROR</code>级，<code>WARN</code>级和<code>INFO</code>级消息。您还可以通过使用<code>--debug</code>标志启动应用程序来启用“调试”模式。<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -jar myapp.jar --debug</span></span><br></pre></table></figure><blockquote><p>您也可以在<code>application.properties</code>中指定<code>debug=true</code>。</blockquote><p>启用调试模式后，将配置一些核心 Logger(嵌入式容器，Hibernate 和 Spring Boot)以输出更多信息。启用调试模式不会<em>不</em>将您的应用程序配置为记录所有具有<code>DEBUG</code>级的消息。<p>另外，您可以通过使用<code>--trace</code>标志(或<code>application.properties</code>中的<code>trace=true</code>)启动应用程序来启用“跟踪”模式。这样做可以为某些核心 Logger(嵌入式容器，Hibernate 模式生成以及整个 Spring 产品组合)启用跟踪记录。<h4 id=3-4-2-1、颜色编码的输出><a class=headerlink href=#3-4-2-1、颜色编码的输出 title=3.4.2.1、颜色编码的输出></a>3.4.2.1、颜色编码的输出</h4><p>如果您的终端支持 ANSI，则使用彩色输出来提高可读性。您可以将<code>spring.output.ansi.enabled</code>设置为<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/ansi/AnsiOutput.Enabled.html rel=noopener target=_blank>supported value</a>以覆盖自动检测。<p>通过使用<code>%clr</code>转换字来配置颜色编码。转换器以最简单的形式根据对数级别为输出着色，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">%</span><span class=language-bash>clr(%5p)</span></span><br></pre></table></figure><p>下表描述了日志级别到颜色的 Map：<table><thead><tr><th>Level<th>Color<tbody><tr><td><code>FATAL</code><td>Red<tr><td><code>ERROR</code><td>Red<tr><td><code>WARN</code><td>Yellow<tr><td><code>INFO</code><td>Green<tr><td><code>DEBUG</code><td>Green<tr><td><code>TRACE</code><td>Green</table><p>另外，您可以通过将其提供为转换的选项来指定应使用的颜色或样式。例如，要使文本变黄，请使用以下设置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">%</span><span class=language-bash>clr(%d{yyyy-MM-<span class=built_in>dd</span> HH:mm:ss.SSS}){yellow}</span></span><br></pre></table></figure><p>支持以下颜色和样式：<ul><li><code>blue</code><li><code>cyan</code><li><code>faint</code><li><code>green</code><li><code>magenta</code><li><code>red</code><li><code>yellow</code></ul><h3 id=3-4-3、文件输出><a class=headerlink href=#3-4-3、文件输出 title=3.4.3、文件输出></a>3.4.3、文件输出</h3><p>默认情况下，Spring Boot 仅记录到控制台，不写日志文件。如果除了控制台输出外还想写入日志文件，则需要设置<code>logging.file</code>或<code>logging.path</code>属性(例如，在<code>application.properties</code>中)。<p>下表显示了如何一起使用<code>logging.*</code>属性：<p><strong>表 26.1 记录属性</strong><table><thead><tr><th><code>logging.file</code><th><code>logging.path</code><th>Example<th>Description<tbody><tr><td><em>(none)</em><td><em>(none)</em><td><td>仅控制台记录。<tr><td>Specific file<td><em>(none)</em><td><code>my.log</code><td>写入指定的日志文件。名称可以是确切的位置，也可以相对于当前目录。<tr><td><em>(none)</em><td>Specific directory<td><code>/var/log</code><td>将<code>spring.log</code>写入指定的目录。名称可以是确切的位置，也可以相对于当前目录。</table><p>日志文件达到 10 MB 时会旋转，并且与控制台输出一样，默认记录<code>ERROR</code> -level，<code>WARN</code> -level 和<code>INFO</code> -level 消息。大小限制可以使用<code>logging.file.max-size</code>属性更改。除非已设置<code>logging.file.max-history</code>属性，否则以前旋转的文件将无限期存档。<blockquote><p>日志记录系统在应用程序生命周期的早期进行了初始化。因此，在通过<code>@PropertySource</code>Comments 加载的属性文件中找不到日志记录属性。<p>日志记录属性与实际的日志记录基础结构无关。结果，Spring Boot 不会 Management 特定的配置密钥(例如 Log 的<code>logback.configurationFile</code>)。</blockquote><h3 id=3-4-4、日志级别><a class=headerlink href=#3-4-4、日志级别 title=3.4.4、日志级别></a>3.4.4、日志级别</h3><p>所有支持的日志记录系统都可以使用<code>logging.level.&LTlogger-name>=&LTlevel></code>在 Spring <code>Environment</code>(例如，在<code>application.properties</code>)中设置 Logger 级别，其中<code>level</code>是 TRACE，DEBUG，INFO，WARN，ERROR，FATAL 或 OFF 之一。可以使用<code>logging.level.root</code>来配置<code>root</code>Logger。<p>以下示例显示了<code>application.properties</code>中的潜在日志记录设置：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>logging.level.root</span>=<span class=string>WARN</span></span><br><span class=line><span class=attr>logging.level.org.springframework.web</span>=<span class=string>DEBUG</span></span><br><span class=line><span class=attr>logging.level.org.hibernate</span>=<span class=string>ERROR</span></span><br></pre></table></figure><h3 id=3-4-5、日志组><a class=headerlink href=#3-4-5、日志组 title=3.4.5、日志组></a>3.4.5、日志组</h3><p>能够将相关 Logger 组合在一起通常很有用，以便可以同时配置它们。例如，您可能通常会更改与 Tomcat 相关的所有 Logger 的日志记录级别，但是您不容易记住顶级软件包。<p>为了解决这个问题，Spring Boot 允许您在 Spring <code>Environment</code>中定义日志记录组。例如，这是通过将“ tomcat”组添加到<code>application.properties</code>来定义它的方法：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>logging.group.tomcat=org.apache.catalina, org.apache.coyote, org.apache.tomcat</span><br></pre></table></figure><p>定义后，您可以使用一行更改该组中所有 Logger 的级别：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>logging.level.tomcat=TRACE</span><br></pre></table></figure><p>Spring Boot 包含以下 sched 义的日志记录组，它们可以直接使用：<table><thead><tr><th>Name<th>Loggers<tbody><tr><td>web<td><code>org.springframework.core.codec</code> , <code>org.springframework.http</code> , <code>org.springframework.web</code><tr><td>sql<td><code>org.springframework.jdbc.core</code> , <code>org.hibernate.SQL</code></table><h3 id=3-4-6、自定义日志配置><a class=headerlink href=#3-4-6、自定义日志配置 title=3.4.6、自定义日志配置></a>3.4.6、自定义日志配置</h3><p>可以通过在 Classpath 中包括适当的库来激活各种日志记录系统，并可以通过在 Classpath 的根目录中或在以下 Spring <code>Environment</code>属性：<code>logging.config</code>指定的位置中提供适当的配置文件来进一步自定义各种日志记录系统。<p>您可以通过使用<code>org.springframework.boot.logging.LoggingSystem</code> system 属性来强制 Spring Boot 使用特定的日志记录系统。该值应该是<code>LoggingSystem</code>实现的完全限定的类名。您还可以使用<code>none</code>值完全禁用 Spring Boot 的日志记录配置。<blockquote><p>由于日志记录是在创建<code>ApplicationContext</code>之前**初始化的，因此无法从 Spring <code>@Configuration</code>文件中的<code>@PropertySources</code>控制日志记录。更改日志记录系统或完全禁用它的唯一方法是通过系统属性。</blockquote><p>根据您的日志系统，将加载以下文件：<table><thead><tr><th>Logging System<th>Customization<tbody><tr><td>Logback<td><code>logback-spring.xml</code>，<code>logback-spring.groovy</code>，<code>logback.xml</code>或<code>logback.groovy</code><tr><td>Log4j2<td><code>log4j2-spring.xml</code>或<code>log4j2.xml</code><tr><td>JDK(Java Util 日志记录)<td><code>logging.properties</code></table><blockquote><p>如果可能，我们建议您将<code>-spring</code>变体用于日志记录配置(例如<code>logback-spring.xml</code>而不是<code>logback.xml</code>)。如果使用标准配置位置，Spring 将无法完全控制日志初始化。<p>从“可执行 jar”运行时，Java Util Logging 存在一些已知的类加载问题，这些问题会引起问题。我们建议您尽可能从“可执行 jar”运行时避免使用它。</blockquote><p>为了帮助进行自定义，如下表所述，一些其他属性从 Spring <code>Environment</code>转移到 System 属性：<table><thead><tr><th>Spring Environment<th>System Property<th>Comments<tbody><tr><td><code>logging.exception-conversion-word</code><td><code>LOG_EXCEPTION_CONVERSION_WORD</code><td>记录异常时使用的转换字。<tr><td><code>logging.file</code><td><code>LOG_FILE</code><td>如果定义，它将在默认日志配置中使用。<tr><td><code>logging.file.max-size</code><td><code>LOG_FILE_MAX_SIZE</code><td>最大日志文件大小(如果启用了 LOG_FILE)。 (仅默认登录设置支持.)<tr><td><code>logging.file.max-history</code><td><code>LOG_FILE_MAX_HISTORY</code><td>要保留的最大归档日志文件数(如果启用了 LOG_FILE)。 (仅默认登录设置支持.)<tr><td><code>logging.path</code><td><code>LOG_PATH</code><td>如果定义，它将在默认日志配置中使用。<tr><td><code>logging.pattern.console</code><td><code>CONSOLE_LOG_PATTERN</code><td>在控制台上使用的日志模式(stdout)。 (仅默认登录设置支持.)<tr><td><code>logging.pattern.dateformat</code><td><code>LOG_DATEFORMAT_PATTERN</code><td>记录日期格式的附加模式。 (仅默认登录设置支持.)<tr><td><code>logging.pattern.file</code><td><code>FILE_LOG_PATTERN</code><td>文件中使用的日志模式(如果启用了<code>LOG_FILE</code>)。 (仅默认登录设置支持.)<tr><td><code>logging.pattern.level</code><td><code>LOG_LEVEL_PATTERN</code><td>渲染日志级别时使用的格式(默认为<code>%5p</code>)。 (仅默认登录设置支持.)<tr><td><code>PID</code><td><code>PID</code><td>当前进程 ID(如果可能，并且尚未将其定义为 OS 环境变量时发现)。</table><p>所有受支持的日志记录系统在解析其配置文件时都可以查阅系统属性。有关示例，请参见<code>spring-boot.jar</code>中的默认配置：<ul><li><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/logback/defaults.xml rel=noopener target=_blank>Logback</a><li><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/log4j2/log4j2.xml rel=noopener target=_blank>Log4j 2</a><li><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/java/logging-file.properties rel=noopener target=_blank>Java Util 日志记录</a></ul><blockquote><p>如果要在日志记录属性中使用占位符，则应使用<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-external-config.html#boot-features-external-config-placeholders-in-properties rel=noopener target=_blank>Spring Boot 的语法</a>而不是基础框架的语法。值得注意的是，如果使用 Logback，则应使用<code>:</code>作为属性名称与其默认值之间的分隔符，而不应使用<code>:-</code>。<p>您可以通过仅覆盖<code>LOG_LEVEL_PATTERN</code>(或使用 Logback 覆盖<code>logging.pattern.level</code>)将 MDC 和其他临时内容添加到日志行。例如，如果使用<code>logging.pattern.level=user:%X{user} %5p</code>，则默认日志格式包含“ user”的 MDC 条目(如果存在)，如以下示例所示。<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>2015-09-30 12:30:04.031 user:someone INFO 22174 --- [  nio-8080-exec-0] demo.Controller</span><br><span class=line>Handling authenticated request</span><br></pre></table></figure></blockquote><h3 id=3-4-7、Logback扩展><a class=headerlink href=#3-4-7、Logback扩展 title=3.4.7、Logback扩展></a>3.4.7、Logback扩展</h3><p>Spring Boot 包含许多 Logback 扩展，可以帮助进行高级配置。您可以在<code>logback-spring.xml</code>配置文件中使用这些 extensions。<blockquote><p>由于标准<code>logback.xml</code>配置文件加载时间过早，因此无法在其中使用 extensions。您需要使用<code>logback-spring.xml</code>或定义<code>logging.config</code>属性。<p>这些扩展不能与 Logback 的<a href=http://logback.qos.ch/manual/configuration.html#autoScan rel=noopener target=_blank>configuration scanning</a>一起使用。如果尝试这样做，则对配置文件进行更改将导致类似于以下记录之一的错误记录：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>ERROR in [emailprotected]:71 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]]</span><br><span class=line>ERROR in [emailprotected]:71 - no applicable action for [springProfile], current ElementPath is [[configuration][springProfile]]</span><br></pre></table></figure></blockquote><h4 id=3-4-7-1、特定于配置文件的配置><a class=headerlink href=#3-4-7-1、特定于配置文件的配置 title=3.4.7.1、特定于配置文件的配置></a>3.4.7.1、特定于配置文件的配置</h4><p><code>&LTspringProfile></code>标签可让您根据有效的 Spring 配置文件有选择地包括或排除配置部分。 <code>&LTconfiguration></code>元素中任何位置都支持概要文件部分。使用<code>name</code>属性指定哪个配置文件接受配置。 <code>&LTspringProfile></code>标记可以包含一个简单的配置文件名称(例如<code>staging</code>)或一个配置文件表达式。配置文件表达式允许表达更复杂的配置文件逻辑，例如<code>production & (eu-central | eu-west)</code>。查看<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/core.html#beans-definition-profiles-java rel=noopener target=_blank>reference guide</a>以获取更多详细信息。以下 Lists 显示了三个 samples 概要文件：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>&LTspringProfile name="staging"></span><br><span class=line>	&LT!-- configuration to be enabled when the "staging" profile is active --></span><br><span class=line>&LT/springProfile></span><br><span class=line></span><br><span class=line>&LTspringProfile name="dev | staging"></span><br><span class=line>	&LT!-- configuration to be enabled when the "dev" or "staging" profiles are active --></span><br><span class=line>&LT/springProfile></span><br><span class=line></span><br><span class=line>&LTspringProfile name="!production"></span><br><span class=line>	&LT!-- configuration to be enabled when the "production" profile is not active --></span><br><span class=line>&LT/springProfile></span><br></pre></table></figure><h4 id=3-4-7-2、环境属性><a class=headerlink href=#3-4-7-2、环境属性 title=3.4.7.2、环境属性></a>3.4.7.2、环境属性</h4><p><code>&LTspringProperty></code>标签可让您公开 Spring <code>Environment</code>中的属性，以供在 Logback 中使用。如果要从 Logback 配置中访问<code>application.properties</code>文件中的值，则这样做很有用。该标记的工作方式类似于 Logback 的标准<code>&LTproperty></code>标记。但是，不是指定直接的<code>value</code>，而是指定属性的<code>source</code>(来自<code>Environment</code>)。如果需要将属性存储在<code>local</code>范围以外的其他位置，则可以使用<code>scope</code>属性。如果需要回退值(如果未在<code>Environment</code>中设置该属性)，则可以使用<code>defaultValue</code>属性。以下示例显示如何公开用于 Logback 的属性：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>&LTspringProperty scope="context" name="fluentHost" source="myapp.fluentd.host"</span><br><span class=line>		defaultValue="localhost"/></span><br><span class=line>&LTappender name="FLUENT" class="ch.qos.logback.more.appenders.DataFluentAppender"></span><br><span class=line>	&LTremoteHost>${fluentHost}&LT/remoteHost></span><br><span class=line>	...</span><br><span class=line>&LT/appender></span><br></pre></table></figure><blockquote><p><code>source</code>必须在烤肉串情况下指定(例如<code>my.property-name</code>)。但是，可以使用宽松规则将属性添加到<code>Environment</code>。</blockquote><h2 id=3-5、JSON><a class=headerlink href=#3-5、JSON title=3.5、JSON></a>3.5、JSON</h2><p>Spring Boot 提供了与三个 JSON Map 库的集成：<ul><li>Gson<li>Jackson<li>JSON-B</ul><p>Jackson 是首选的默认库。<h3 id=3-5-1、Jackson><a class=headerlink href=#3-5-1、Jackson title=3.5.1、Jackson></a>3.5.1、Jackson</h3><p>提供了 Jackson 的自动配置功能，并且 Jackson 是<code>spring-boot-starter-json</code>的一部分。当 Jackson 放在 Classpath 上时，会自动配置<code>ObjectMapper</code> bean。为<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/howto-spring-mvc.html#howto-customize-the-jackson-objectmapper rel=noopener target=_blank>定制 ObjectMapper 的配置</a>提供了几个配置属性。<h3 id=3-5-2、Gson><a class=headerlink href=#3-5-2、Gson title=3.5.2、Gson></a>3.5.2、Gson</h3><p>提供了 Gson 的自动配置。当 Gson 在 Classpath 上时，会自动配置<code>Gson</code> bean。提供了几个<code>spring.gson.*</code>配置属性用于自定义配置。为了获得更多控制权，可以使用一个或多个<code>GsonBuilderCustomizer</code> bean。<h3 id=3-5-3、JSON-B><a class=headerlink href=#3-5-3、JSON-B title=3.5.3、JSON-B></a>3.5.3、JSON-B</h3><p>提供了 JSON-B 的自动配置。当 JSON-B API 和实现位于 Classpath 上时，将自动配置<code>Jsonb</code> bean。首选的 JSON-B 实现是提供依赖 Management 的 Apache Johnzon。<h2 id=3-6、开发Web应用程序><a class=headerlink href=#3-6、开发Web应用程序 title=3.6、开发Web应用程序></a>3.6、开发Web应用程序</h2><p>Spring Boot 非常适合 Web 应用程序开发。您可以使用嵌入式 Tomcat，Jetty，Undertow 或 Netty 创建独立的 HTTP 服务器。大多数 Web 应用程序都使用<code>spring-boot-starter-web</code>模块来快速启动和运行。您还可以选择使用<code>spring-boot-starter-webflux</code>模块来构建响应式 Web 应用程序。<p>如果尚未开发 Spring Boot Web 应用程序，则可以遵循“ Hello World！”。 * <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/getting-started-first-application.html rel=noopener target=_blank>Getting started</a> *部分中的示例。<h3 id=3-6-1、“-Spring-Web-MVC-框架”><a title="3.6.1、“ Spring Web MVC 框架”" class=headerlink href=#3-6-1、“-Spring-Web-MVC-框架”></a>3.6.1、“ Spring Web MVC 框架”</h3><p><a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc rel=noopener target=_blank>Spring Web MVC 框架</a>(通常简称为“ Spring MVC”)是一个丰富的“模型视图控制器” Web 框架。 Spring MVC 使您可以创建特殊的<code>@Controller</code>或<code>@RestController</code> bean 来处理传入的 HTTP 请求。控制器中的方法通过使用<code>@RequestMapping</code>CommentsMap 到 HTTP。<p>以下代码显示了提供 JSON 数据的典型<code>@RestController</code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=meta>@RestController</span></span><br><span class=line><span class=meta>@RequestMapping(value="/users")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyRestController</span> {</span><br><span class=line>	<span class=meta>@RequestMapping(value="/{user}", method=RequestMethod.GET)</span></span><br><span class=line>	<span class=keyword>public</span> User <span class="title function_">getUser</span><span class=params>(<span class=meta>@PathVariable</span> Long user)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=meta>@RequestMapping(value="/{user}/customers", method=RequestMethod.GET)</span></span><br><span class=line>	List&LTCustomer> <span class="title function_">getUserCustomers</span><span class=params>(<span class=meta>@PathVariable</span> Long user)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=meta>@RequestMapping(value="/{user}", method=RequestMethod.DELETE)</span></span><br><span class=line>	<span class=keyword>public</span> User <span class="title function_">deleteUser</span><span class=params>(<span class=meta>@PathVariable</span> Long user)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>Spring MVC 是核心 Spring Framework 的一部分，有关详细信息，请参见<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc rel=noopener target=_blank>reference documentation</a>。 <a href=https://spring.io/guides rel=noopener target=_blank>spring.io/guides</a>提供了一些涵盖 Spring MVC 的指南。<h4 id=3-6-1-1、Spring-MVC自动配置><a title="3.6.1.1、Spring MVC自动配置" class=headerlink href=#3-6-1-1、Spring-MVC自动配置></a>3.6.1.1、Spring MVC自动配置</h4><p>Spring Boot 为 Spring MVC 提供了自动配置，可与大多数应用程序完美配合。<p>自动配置在 Spring 的默认值之上添加了以下功能：<ul><li>包括<code>ContentNegotiatingViewResolver</code>和<code>BeanNameViewResolver</code>bean。<li>支持提供静态资源，包括对 WebJars 的支持(覆盖<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-spring-mvc-static-content rel=noopener target=_blank>本文档后面</a>)。<li>自动注册<code>Converter</code>，<code>GenericConverter</code>和<code>Formatter</code> bean。<li>支持<code>HttpMessageConverters</code>(包含<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-spring-mvc-message-converters rel=noopener target=_blank>本文档后面</a>)。<li>自动注册<code>MessageCodesResolver</code>(已发现<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-spring-message-codes rel=noopener target=_blank>本文档后面</a>)。<li>静态<code>index.html</code>支持。<li>自定义<code>Favicon</code>支持(包含<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-spring-mvc-favicon rel=noopener target=_blank>本文档后面</a>)。<li>自动使用<code>ConfigurableWebBindingInitializer</code> bean(包含<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-spring-mvc-web-binding-initializer rel=noopener target=_blank>本文档后面</a>)。</ul><p>如果您想保留 Spring Boot MVC 功能，并且想要添加其他<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc rel=noopener target=_blank>MVC configuration</a>(拦截器，格式化程序，视图控制器和其他功能)，则可以添加自己的<code>@Configuration</code>类，类型为<code>WebMvcConfigurer</code>，但是 <strong>没有</strong> <code>@EnableWebMvc</code>。如果希望提供<code>RequestMappingHandlerMapping</code>，<code>RequestMappingHandlerAdapter</code>或<code>ExceptionHandlerExceptionResolver</code>的自定义实例，则可以声明<code>WebMvcRegistrationsAdapter</code>实例以提供此类组件。<p>如果要完全控制 Spring MVC，则可以添加自己的<code>@Configuration</code>并以<code>@EnableWebMvc</code>Comments。<h4 id=3-6-1-2、HttpMessageConverters><a class=headerlink href=#3-6-1-2、HttpMessageConverters title=3.6.1.2、HttpMessageConverters></a>3.6.1.2、HttpMessageConverters</h4><p>Spring MVC 使用<code>HttpMessageConverter</code>接口转换 HTTP 请求和响应。开箱即用中包含明智的默认设置。例如，可以将对象自动转换为 JSON(通过使用 Jackson 库)或 XML(通过使用 Jackson XML 扩展(如果可用)或通过使用 JAXB(如果 Jackson XML 扩展不可用))。默认情况下，字符串以<code>UTF-8</code>编码。<p>如果需要添加或定制转换器，则可以使用 Spring Boot 的<code>HttpMessageConverters</code>类，如以下 Lists 所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.boot.autoconfigure.web.HttpMessageConverters;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.http.converter.*;</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyConfiguration</span> {</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> HttpMessageConverters <span class="title function_">customConverters</span><span class=params>()</span> {</span><br><span class=line>		HttpMessageConverter&LT?> additional = ...</span><br><span class=line>		HttpMessageConverter&LT?> another = ...</span><br><span class=line>		<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">HttpMessageConverters</span>(additional, another);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>上下文中存在的任何<code>HttpMessageConverter</code> bean 都将添加到转换器列表中。您也可以用相同的方法覆盖默认转换器。<h4 id=3-6-1-3、自定义JSON序列化器和反序列化器><a class=headerlink href=#3-6-1-3、自定义JSON序列化器和反序列化器 title=3.6.1.3、自定义JSON序列化器和反序列化器></a>3.6.1.3、自定义JSON序列化器和反序列化器</h4><p>如果使用 Jackson 来序列化和反序列化 JSON 数据，则可能要编写自己的<code>JsonSerializer</code>和<code>JsonDeserializer</code>类。自定义序列化器通常是<a href=https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers rel=noopener target=_blank>通过模块在 Jackson 注册</a>，但是 Spring Boot 提供了<code>@JsonComponent</code>Comments，这使得直接注册 Spring Bean 更加容易。<p>您可以直接在<code>JsonSerializer</code>或<code>JsonDeserializer</code>实现中使用<code>@JsonComponent</code>Comments。您还可以在包含序列化器/反序列化器作为内部类的类上使用它，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.io.*;</span><br><span class=line><span class=keyword>import</span> com.fasterxml.jackson.core.*;</span><br><span class=line><span class=keyword>import</span> com.fasterxml.jackson.databind.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.jackson.*;</span><br><span class=line></span><br><span class=line><span class=meta>@JsonComponent</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Example</span> {</span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">Serializer</span> <span class=keyword>extends</span> <span class="title class_">JsonSerializer</span>&LTSomeObject> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">Deserializer</span> <span class=keyword>extends</span> <span class="title class_">JsonDeserializer</span>&LTSomeObject> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p><code>ApplicationContext</code>中的所有<code>@JsonComponent</code> bean 都会自动向 Jackson 进行注册。因为<code>@JsonComponent</code>是用<code>@Component</code>进行元 Comments 的，所以通常的组件扫描规则适用。<p>Spring Boot 还提供了<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectSerializer.java rel=noopener target=_blank>JsonObjectSerializer</a>和<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectDeserializer.java rel=noopener target=_blank>JsonObjectDeserializer</a>Base Class，这些 Base Class 在序列化对象时为标准 Jackson 版本提供了有用的替代方法。有关详细信息，请参见 Javadoc 中的<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/jackson/JsonObjectSerializer.html rel=noopener target=_blank>JsonObjectSerializer</a>和<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/jackson/JsonObjectDeserializer.html rel=noopener target=_blank>JsonObjectDeserializer</a>。<h4 id=3-6-1-4、MessageCodesResolver><a class=headerlink href=#3-6-1-4、MessageCodesResolver title=3.6.1.4、MessageCodesResolver></a>3.6.1.4、MessageCodesResolver</h4><p>Spring MVC 有一种生成错误代码的策略，该错误代码用于从绑定错误<code>MessageCodesResolver</code>渲染错误消息。如果设置<code>spring.mvc.message-codes-resolver.format</code>属性<code>PREFIX_ERROR_CODE</code>或<code>POSTFIX_ERROR_CODE</code>，Spring Boot 会为您创建一个(请参见<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.Format.html rel=noopener target=_blank>DefaultMessageCodesResolver.Format</a>中的枚举)。<h4 id=3-6-1-5、静态内容><a class=headerlink href=#3-6-1-5、静态内容 title=3.6.1.5、静态内容></a>3.6.1.5、静态内容</h4><p>默认情况下，Spring Boot 从 Classpath 中名为<code>/static</code>(或<code>/public</code>或<code>/resources</code>或<code>/META-INF/resources</code>)的目录或<code>ServletContext</code>的根目录中提供静态内容。它使用 Spring MVC 中的<code>ResourceHttpRequestHandler</code>，因此您可以通过添加自己的<code>WebMvcConfigurer</code>并覆盖<code>addResourceHandlers</code>方法来修改该行为。<p>在独立的 Web 应用程序中，还启用了容器中的默认 servlet，并将其用作后备，如果 Spring 决定不处理<code>ServletContext</code>的根，则从<code>ServletContext</code>的根开始提供内容。在大多数情况下，这不会发生(除非您修改默认的 MVC 配置)，因为 Spring 始终可以通过<code>DispatcherServlet</code>处理请求。<p>默认情况下，资源 Map 在<code>/**</code>上，但是您可以使用<code>spring.mvc.static-path-pattern</code>属性对其进行调整。例如，将所有资源重定位到<code>/resources/**</code>可以实现如下：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.mvc.static-path-pattern=/resources/**</span><br></pre></table></figure><p>您还可以使用<code>spring.resources.static-locations</code>属性来自定义静态资源位置(用目录位置列表替换默认值)。根 Servlet 上下文路径<code>"/"</code>也会自动添加为位置。<p>除了前面提到的“标准”静态资源位置以外，还对<a href=https://www.webjars.org/ rel=noopener target=_blank>Webjars content</a>进行了特殊处理。如果 jar 文件以 Webjars 格式打包，则从 jar 文件提供带有<code>/webjars/**</code>路径的任何资源。<blockquote><p>如果您的应用程序打包为 jar，则不要使用<code>src/main/webapp</code>目录。尽管此目录是一个通用标准，但它仅在 war 打包中有效，并且在生成 jar 时，大多数构建工具都将其忽略。</blockquote><p>Spring Boot 还支持 Spring MVC 提供的高级资源处理功能，允许使用案例，例如缓存清除静态资源或对 Webjars 使用版本无关的 URL。<p>要对 Webjar 使用版本无关的 URL，请添加<code>webjars-locator-core</code>依赖项。然后声明您的 Webjar。以 jQuery 为例，在<code>"/webjars/jquery/x.y.z/jquery.min.js"</code>中添加<code>"/webjars/jquery/jquery.min.js"</code>结果。其中<code>x.y.z</code>是 Webjar 版本。<blockquote><p>如果使用 JBoss，则需要声明<code>webjars-locator-jboss-vfs</code>依赖性而不是<code>webjars-locator-core</code>。否则，所有 Webjar 都解析为<code>404</code>。</blockquote><p>要使用缓存清除，以下配置为所有静态资源配置了缓存清除解决方案，从而有效地在 URL 中添加了内容哈希，例如<code>&LTlink href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/></code>：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>spring.resources.chain.strategy.content.enabled=true</span><br><span class=line>spring.resources.chain.strategy.content.paths=/**</span><br></pre></table></figure><blockquote><p>得益于为 Thymeleaf 和 FreeMarker 自动配置的<code>ResourceUrlEncodingFilter</code>，在运行时将资源链接重写为模板。使用 JSP 时，您应该手动声明此过滤器。当前不自动支持其他模板引擎，但可以与自定义模板宏/帮助器一起使用，并可以使用<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/resource/ResourceUrlProvider.html rel=noopener target=_blank>ResourceUrlProvider</a>。</blockquote><p>例如，当使用 JavaScript 模块加载器动态加载资源时，不能重命名文件。这就是为什么其他策略也受支持并且可以组合的原因。 “固定”策略在 URL 中添加静态版本字符串，而不会更改文件名，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>spring.resources.chain.strategy.content.enabled=true</span><br><span class=line>spring.resources.chain.strategy.content.paths=/**</span><br><span class=line>spring.resources.chain.strategy.fixed.enabled=true</span><br><span class=line>spring.resources.chain.strategy.fixed.paths=/js/lib/</span><br><span class=line>spring.resources.chain.strategy.fixed.version=v12</span><br></pre></table></figure><p>通过这种配置，位于<code>"/js/lib/"</code>下的 JavaScript 模块使用固定的版本控制策略(<code>"/v12/js/lib/mymodule.js"</code>)，而其他资源仍使用内容版本(<code>&LTlink href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/></code>)。<p>有关更多受支持的选项，请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ResourceProperties.java rel=noopener target=_blank>ResourceProperties</a>。<h4 id=3-6-1-6、欢迎页面><a class=headerlink href=#3-6-1-6、欢迎页面 title=3.6.1.6、欢迎页面></a>3.6.1.6、欢迎页面</h4><p>Spring Boot 支持静态和模板欢迎页面。它首先在配置的静态内容位置中查找<code>index.html</code>文件。如果未找到，则它将寻找<code>index</code>模板。如果找到任何一个，它将自动用作应用程序的欢迎页面。<h4 id=3-6-1-7、自定义图标><a class=headerlink href=#3-6-1-7、自定义图标 title=3.6.1.7、自定义图标></a>3.6.1.7、自定义图标</h4><p>Spring Boot 在配置的静态内容位置和 Classpath 的根目录(按此 Sequences)中查找<code>favicon.ico</code>。如果存在这样的文件，它将自动用作应用程序的收藏夹图标。<h4 id=3-6-1-8、路径匹配和内容协商><a class=headerlink href=#3-6-1-8、路径匹配和内容协商 title=3.6.1.8、路径匹配和内容协商></a>3.6.1.8、路径匹配和内容协商</h4><p>Spring MVC 可以通过查看请求路径并将其匹配到应用程序中定义的 Map(例如 Controller 方法上的<code>@GetMapping</code>Comments)，将传入的 HTTP 请求 Map 到处理程序。<p>Spring Boot 默认选择禁用后缀模式匹配，这意味着诸如<code>"GET /projects/spring-boot.json"</code>之类的请求将不会与<code>@GetMapping("/projects/spring-boot")</code>Map 相匹配。这被视为<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-suffix-pattern-match rel=noopener target=_blank>Spring MVC 应用程序的最佳实践</a>。过去，此功能主要用于未发送正确的“ Accept”请求 Headers 的 HTTP Client 端。我们需要确保将正确的 Content Type 发送给 Client 端。如今，内容协商已变得更加可靠。<p>还有其他处理 HTTP Client 端的方法，这些方法不能始终发送正确的“ Accept”请求 Headers。除了使用后缀匹配，我们还可以使用查询参数来确保将<code>"GET /projects/spring-boot?format=json"</code>之类的请求 Map 到<code>@GetMapping("/projects/spring-boot")</code>：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>spring.mvc.contentnegotiation.favor-parameter=true</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>We can change the parameter name, <span class=built_in>which</span> is <span class=string>"format"</span> by default:</span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>spring.mvc.contentnegotiation.parameter-name=myparam</span></span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>We can also register additional file extensions/media types with:</span></span><br><span class=line>spring.mvc.contentnegotiation.media-types.markdown=text/markdown</span><br></pre></table></figure><p>如果您了解了注意事项，但仍希望您的应用程序使用后缀模式匹配，则需要以下配置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>spring.mvc.contentnegotiation.favor-path-extension=true</span><br><span class=line>spring.mvc.pathmatch.use-suffix-pattern=true</span><br></pre></table></figure><p>另外，与其打开所有后缀模式，不如只支持注册的后缀模式，这是更安全的：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>spring.mvc.contentnegotiation.favor-path-extension=true</span><br><span class=line>spring.mvc.pathmatch.use-registered-suffix-pattern=true</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>You can also register additional file extensions/media types with:</span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>spring.mvc.contentnegotiation.media-types.adoc=text/asciidoc</span></span><br></pre></table></figure><h4 id=3-6-1-9、ConfigurableWebBindingInitializer><a class=headerlink href=#3-6-1-9、ConfigurableWebBindingInitializer title=3.6.1.9、ConfigurableWebBindingInitializer></a>3.6.1.9、ConfigurableWebBindingInitializer</h4><p>Spring MVC 使用<code>WebBindingInitializer</code>来为特定请求初始化<code>WebDataBinder</code>。如果创建自己的<code>ConfigurableWebBindingInitializer</code> <code>@Bean</code>，Spring Boot 会自动将 Spring MVC 配置为使用它。<h4 id=3-6-1-10、模板引擎><a class=headerlink href=#3-6-1-10、模板引擎 title=3.6.1.10、模板引擎></a>3.6.1.10、模板引擎</h4><p>除了 REST Web 服务之外，您还可以使用 Spring MVC 来提供动态 HTML 内容。 Spring MVC 支持各种模板技术，包括 Thymeleaf，FreeMarker 和 JSP。同样，许多其他模板引擎包括他们自己的 Spring MVC 集成。<p>Spring Boot 包括对以下模板引擎的自动配置支持：<ul><li><a href=https://freemarker.apache.org/docs/ rel=noopener target=_blank>FreeMarker</a><li><a href=http://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine rel=noopener target=_blank>Groovy</a><li><a href=http://www.thymeleaf.org/ rel=noopener target=_blank>Thymeleaf</a><li><a href=https://mustache.github.io/ rel=noopener target=_blank>Mustache</a></ul><blockquote><p>如果可能，应避免使用 JSP。与嵌入式 servlet 容器一起使用时，有多个<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-jsp-limitations rel=noopener target=_blank>known limitations</a>。</blockquote><p>当您使用默认配置的这些模板引擎之一时，将从<code>src/main/resources/templates</code>自动拾取模板。<blockquote><p>根据您运行应用程序的方式，IntelliJ IDEA 对 Classpath 的排序方式不同。与使用 Maven 或 Gradle 或从打包的 jar 运行应用程序时，从 IDE 的 Main 方法运行应用程序的 Sequences 会有所不同。这可能会导致 Spring Boot 无法在 Classpath 上找到模板。如果遇到此问题，则可以在 IDE 中重新排序 Classpath，以首先放置模块的类和资源。另外，您可以配置模板前缀以搜索 Classpath 上的每个<code>templates</code>目录，如下所示：<code>classpath*:/templates/</code>。</blockquote><h4 id=3-6-1-11、错误处理><a class=headerlink href=#3-6-1-11、错误处理 title=3.6.1.11、错误处理></a>3.6.1.11、错误处理</h4><p>默认情况下，Spring Boot 提供了一个<code>/error</code>Map，可以明智地处理所有错误，并且已在 servlet 容器中注册为“全局”错误页面。对于机器 Client 端，它将生成 JSON 响应，其中包含错误，HTTP 状态和异常消息的详细信息。对于浏览器 Client 端，存在一个“ whitelabel”错误视图，该视图以 HTML 格式渲染相同的数据(要对其进行自定义，请添加解析为<code>error</code>的<code>View</code>)。要完全替换默认行为，可以实现<code>ErrorController</code>并注册该类型的 Bean 定义，或添加<code>ErrorAttributes</code>类型的 Bean 以使用现有机制但替换其内容。<blockquote><p><code>BasicErrorController</code>可用作自定义<code>ErrorController</code>的 Base Class。如果要为新的 Content Type 添加处理程序(默认是专门处理<code>text/html</code>并为其他所有内容提供后备功能)，则此功能特别有用。为此，扩展<code>BasicErrorController</code>，添加具有<code>produces</code>属性的<code>@RequestMapping</code>的公共方法，并创建新类型的 bean。</blockquote><p>您还可以定义带有<code>@ControllerAdvice</code>Comments 的类，以自定义 JSON 文档以针对特定的控制器和/或异常类型返回，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line>@ControllerAdvice(basePackageClasses = AcmeController.class)</span><br><span class=line>public class AcmeControllerAdvice extends ResponseEntityExceptionHandler {</span><br><span class=line></span><br><span class=line>	@ExceptionHandler(YourException.class)</span><br><span class=line>	@ResponseBody</span><br><span class=line>	ResponseEntity&LT?> handleControllerException(HttpServletRequest request, Throwable ex) {</span><br><span class=line>		HttpStatus status = getStatus(request);</span><br><span class=line>		return new ResponseEntity<>(new CustomErrorType(status.value(), ex.getMessage()), status);</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	private HttpStatus getStatus(HttpServletRequest request) {</span><br><span class=line>		Integer statusCode = (Integer) request.getAttribute("javax.servlet.error.status_code");</span><br><span class=line>		if (statusCode == null) {</span><br><span class=line>			return HttpStatus.INTERNAL_SERVER_ERROR;</span><br><span class=line>		}</span><br><span class=line>		return HttpStatus.valueOf(statusCode);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>在前面的示例中，如果在与<code>AcmeController</code>相同的程序包中定义的控制器抛出<code>YourException</code>，则使用<code>CustomErrorType</code> POJO 的 JSON 表示代替<code>ErrorAttributes</code>表示。<h5 id=自定义错误页面><a class=headerlink href=#自定义错误页面 title=自定义错误页面></a>自定义错误页面</h5><p>如果要显示给定状态代码的自定义 HTML 错误页面，可以将文件添加到<code>/error</code>文件夹。错误页面可以是静态 HTML(即添加到任何静态资源文件夹下)，也可以使用模板来构建。文件名应为确切的状态代码或系列掩码。<p>例如，要将<code>404</code>Map 到静态 HTML 文件，您的文件夹结构如下：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=string>src/</span></span><br><span class=line> <span class=string>+-</span> <span class=string>main/</span></span><br><span class=line>     <span class=string>+-</span> <span class=string>java/</span></span><br><span class=line>     <span class=string>|</span>   <span class=string>+</span> <span class=string>&LTsource</span> <span class=string>code></span></span><br><span class=line>     <span class=string>+-</span> <span class=string>resources/</span></span><br><span class=line>         <span class=string>+-</span> <span class=string>public/</span></span><br><span class=line>             <span class=string>+-</span> <span class=string>error/</span></span><br><span class=line>             <span class=string>|</span>   <span class=string>+-</span> <span class=number>404.</span><span class=string>html</span></span><br><span class=line>             <span class=string>+-</span> <span class=string>&LTother</span> <span class=string>public</span> <span class=string>assets></span></span><br></pre></table></figure><p>要使用 FreeMarker 模板 Map 所有<code>5xx</code>错误，您的文件夹结构如下：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>src/</span><br><span class=line> +- main/</span><br><span class=line>     +- java/</span><br><span class=line>     |   + &LTsource code></span><br><span class=line>     +- resources/</span><br><span class=line>         +- templates/</span><br><span class=line>             +- error/</span><br><span class=line>             |   +- 5xx.ftl</span><br><span class=line>             +- &LTother templates></span><br></pre></table></figure><p>对于更复杂的 Map，还可以添加实现<code>ErrorViewResolver</code>接口的 bean，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyErrorViewResolver</span> <span class=keyword>implements</span> <span class="title class_">ErrorViewResolver</span> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> ModelAndView <span class="title function_">resolveErrorView</span><span class=params>(HttpServletRequest request,</span></span><br><span class=line><span class=params>			HttpStatus status, Map&LTString, Object> model)</span> {</span><br><span class=line>		<span class=comment>// Use the request or status to optionally return a ModelAndView</span></span><br><span class=line>		<span class=keyword>return</span> ...</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>您还可以使用常规的 Spring MVC 功能，例如<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc-exceptionhandlers rel=noopener target=_blank>@ExceptionHandler methods</a>和<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc-ann-controller-advice rel=noopener target=_blank>@ControllerAdvice</a>。 <code>ErrorController</code>然后接收任何未处理的异常。<h5 id=Map-Spring-MVC-之外的错误页面><a title="Map Spring MVC 之外的错误页面" class=headerlink href=#Map-Spring-MVC-之外的错误页面></a>Map Spring MVC 之外的错误页面</h5><p>对于不使用 Spring MVC 的应用程序，可以使用<code>ErrorPageRegistrar</code>接口直接注册<code>ErrorPages</code>。此抽象直接与基础嵌入式 servlet 容器一起使用，即使您没有 Spring MVC <code>DispatcherServlet</code>，也可以使用。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> ErrorPageRegistrar <span class="title function_">errorPageRegistrar</span><span class=params>()</span>{</span><br><span class=line>	<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">MyErrorPageRegistrar</span>();</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// ...</span></span><br><span class=line></span><br><span class=line><span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">MyErrorPageRegistrar</span> <span class=keyword>implements</span> <span class="title class_">ErrorPageRegistrar</span> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">registerErrorPages</span><span class=params>(ErrorPageRegistry registry)</span> {</span><br><span class=line>		registry.addErrorPages(<span class=keyword>new</span> <span class="title class_">ErrorPage</span>(HttpStatus.BAD_REQUEST, <span class=string>"/400"</span>));</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>如果您注册的<code>ErrorPage</code>的路径最终由<code>Filter</code>处理(这在某些非 Spring Web 框架(如 Jersey 和 Wicket)中很常见)，则必须将<code>Filter</code>明确注册为<code>ERROR</code>调度程序，如图所示。下面的例子：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> FilterRegistrationBean <span class="title function_">myFilter</span><span class=params>()</span> {</span><br><span class=line>	<span class=type>FilterRegistrationBean</span> <span class=variable>registration</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">FilterRegistrationBean</span>();</span><br><span class=line>	registration.setFilter(<span class=keyword>new</span> <span class="title class_">MyFilter</span>());</span><br><span class=line>	...</span><br><span class=line>	registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));</span><br><span class=line>	<span class=keyword>return</span> registration;</span><br><span class=line>}</span><br></pre></table></figure></blockquote><p>请注意，默认的<code>FilterRegistrationBean</code>不包括<code>ERROR</code>调度程序类型。<p>注意：Spring Boot 部署到 servlet 容器时，将使用其错误页面过滤器将具有错误状态的请求转发到相应的错误页面。如果尚未提交响应，则只能将请求转发到正确的错误页面。缺省情况下，WebSphere Application Server 8.0 和更高版本在成功完成 servlet 的服务方法后提交响应。您应该通过将<code>com.ibm.ws.webcontainer.invokeFlushAfterService</code>设置为<code>false</code>来禁用此行为。<h4 id=3-6-1-12、Spring-HATEOAS><a title="3.6.1.12、Spring HATEOAS" class=headerlink href=#3-6-1-12、Spring-HATEOAS></a>3.6.1.12、Spring HATEOAS</h4><p>如果您开发使用超媒体的 RESTful API，Spring Boot 将为 Spring HATEOAS 提供自动配置，该配置可与大多数应用程序很好地配合使用。自动配置取代了使用<code>@EnableHypermediaSupport</code>的需要，并注册了许多 Bean 以简化基于超媒体的应用程序的构建，包括<code>LinkDiscoverers</code>(用于 Client 端支持)和<code>ObjectMapper</code>，这些<code>ObjectMapper</code>被配置为将响应正确地编组为所需的表示形式。 <code>ObjectMapper</code>是通过设置各种<code>spring.jackson.*</code>属性来定制的，或者通过设置<code>Jackson2ObjectMapperBuilder</code> bean 来定制(如果存在)。<p>您可以使用<code>@EnableHypermediaSupport</code>来控制 Spring HATEOAS 的配置。请注意，这样做会禁用前面介绍的<code>ObjectMapper</code>自定义。<h4 id=3-6-1-13、CORS支持><a class=headerlink href=#3-6-1-13、CORS支持 title=3.6.1.13、CORS支持></a>3.6.1.13、CORS支持</h4><p><a href=https://en.wikipedia.org/wiki/Cross-origin_resource_sharing rel=noopener target=_blank>跨域资源共享</a>(CORS)是由<a href=https://caniuse.com/#feat=cors rel=noopener target=_blank>most browsers</a>实现的<a href=https://www.w3.org/TR/cors/ rel=noopener target=_blank>W3C specification</a>，可让您灵活地指定授权哪种类型的跨域请求，而不是使用一些安全性和功能不强的方法(例如 IFRAME 或 JSONP)。<p>从 4.2 版本开始，Spring MVC <a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#cors rel=noopener target=_blank>supports CORS</a>。在 Spring Boot 应用程序中使用<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#controller-method-cors-configuration rel=noopener target=_blank>控制器方法 CORS 配置</a>和<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html rel=noopener target=_blank>@CrossOrigin</a>注解不需要任何特定的配置。可以通过使用自定义的<code>addCorsMappings(CorsRegistry)</code>方法注册<code>WebMvcConfigurer</code> bean 来定义<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#global-cors-configuration rel=noopener target=_blank>全局 CORS 配置</a>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyConfiguration</span> {</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> WebMvcConfigurer <span class="title function_">corsConfigurer</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">WebMvcConfigurer</span>() {</span><br><span class=line>			<span class=meta>@Override</span></span><br><span class=line>			<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">addCorsMappings</span><span class=params>(CorsRegistry registry)</span> {</span><br><span class=line>				registry.addMapping(<span class=string>"/api/**"</span>);</span><br><span class=line>			}</span><br><span class=line>		};</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-6-2、“-Spring-WebFlux-框架”><a title="3.6.2、“ Spring WebFlux 框架”" class=headerlink href=#3-6-2、“-Spring-WebFlux-框架”></a>3.6.2、“ Spring WebFlux 框架”</h3><p>Spring WebFlux 是 Spring Framework 5.0 中引入的新的响应式 Web 框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步和非阻塞的，并通过<a href=https://projectreactor.io/ rel=noopener target=_blank>反应堆项目</a>实现<a href=http://www.reactive-streams.org/ rel=noopener target=_blank>Reactive Streams</a>规范。<p>Spring WebFlux 有两种形式：功能性的和基于 Comments 的。基于 Comments 的模型非常类似于 Spring MVC 模型，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=meta>@RestController</span></span><br><span class=line><span class=meta>@RequestMapping("/users")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyRestController</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@GetMapping("/{user}")</span></span><br><span class=line>	<span class=keyword>public</span> Mono&LTUser> <span class="title function_">getUser</span><span class=params>(<span class=meta>@PathVariable</span> Long user)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=meta>@GetMapping("/{user}/customers")</span></span><br><span class=line>	<span class=keyword>public</span> Flux&LTCustomer> <span class="title function_">getUserCustomers</span><span class=params>(<span class=meta>@PathVariable</span> Long user)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=meta>@DeleteMapping("/{user}")</span></span><br><span class=line>	<span class=keyword>public</span> Mono&LTUser> <span class="title function_">deleteUser</span><span class=params>(<span class=meta>@PathVariable</span> Long user)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>功能变体“ WebFlux.fn”将路由配置与请求的实际处理分开，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RoutingConfiguration</span> {</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> RouterFunction&LTServerResponse> <span class="title function_">monoRouterFunction</span><span class=params>(UserHandler userHandler)</span> {</span><br><span class=line>		<span class=keyword>return</span> route(GET(<span class=string>"/{user}"</span>).and(accept(APPLICATION_JSON)), userHandler::getUser)</span><br><span class=line>				.andRoute(GET(<span class=string>"/{user}/customers"</span>).and(accept(APPLICATION_JSON)), userHandler::getUserCustomers)</span><br><span class=line>				.andRoute(DELETE(<span class=string>"/{user}"</span>).and(accept(APPLICATION_JSON)), userHandler::deleteUser);</span><br><span class=line>	}</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">UserHandler</span> {</span><br><span class=line>	<span class=keyword>public</span> Mono&LTServerResponse> <span class="title function_">getUser</span><span class=params>(ServerRequest request)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> Mono&LTServerResponse> <span class="title function_">getUserCustomers</span><span class=params>(ServerRequest request)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> Mono&LTServerResponse> <span class="title function_">deleteUser</span><span class=params>(ServerRequest request)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>WebFlux 是 Spring Framework 的一部分，其<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web-reactive.html#webflux-fn rel=noopener target=_blank>reference documentation</a>中提供了详细信息。<blockquote><p>您可以根据需要定义尽可能多的<code>RouterFunction</code> bean，以对 Router 的定义进行模块化。如果需要应用优先级，可以 Order Bean。</blockquote><p>首先，将<code>spring-boot-starter-webflux</code>模块添加到您的应用程序中。<blockquote><p>在应用程序中同时添加<code>spring-boot-starter-web</code>和<code>spring-boot-starter-webflux</code>模块会导致 Spring Boot 自动配置 Spring MVC，而不是 WebFlux。之所以选择这种行为，是因为许多 Spring 开发人员将<code>spring-boot-starter-webflux</code>添加到他们的 Spring MVC 应用程序中以使用 Reactive<code>WebClient</code>。您仍然可以通过将选定的应用程序类型设置为<code>SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)</code>来强制执行选择。</blockquote><h4 id=3-6-2-1、Spring-WebFlux-自动配置><a title="3.6.2.1、Spring WebFlux 自动配置" class=headerlink href=#3-6-2-1、Spring-WebFlux-自动配置></a>3.6.2.1、Spring WebFlux 自动配置</h4><p>Spring Boot 为 Spring WebFlux 提供了自动配置，可与大多数应用程序完美配合。<p>自动配置在 Spring 的默认值之上添加了以下功能：<ul><li>为<code>HttpMessageReader</code>和<code>HttpMessageWriter</code>实例(说明<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-webflux-httpcodecs rel=noopener target=_blank>本文档后面</a>)配置编解码器。<li>支持服务静态资源，包括对 WebJars 的支持(描述为<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-spring-mvc-static-content rel=noopener target=_blank>本文档后面</a>)。</ul><p>如果您想保留 Spring Boot WebFlux 功能，并且想要添加其他<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#web-reactive rel=noopener target=_blank>WebFlux configuration</a>，则可以添加自己的<code>@Configuration</code>类，类型为<code>WebFluxConfigurer</code>，但 <strong>没有</strong> <code>@EnableWebFlux</code>。<p>如果要完全控制 Spring WebFlux，则可以添加带有<code>@EnableWebFlux</code>Comments 的自己的<code>@Configuration</code>。<h4 id=3-6-2-2、带有-HttpMessageReaders-和-HttpMessageWriters-的-HTTP-编解码器><a title="3.6.2.2、带有 HttpMessageReaders 和 HttpMessageWriters 的 HTTP 编解码器" class=headerlink href=#3-6-2-2、带有-HttpMessageReaders-和-HttpMessageWriters-的-HTTP-编解码器></a>3.6.2.2、带有 HttpMessageReaders 和 HttpMessageWriters 的 HTTP 编解码器</h4><p>Spring WebFlux 使用<code>HttpMessageReader</code>和<code>HttpMessageWriter</code>接口转换 HTTP 请求和响应。通过查看 Classpath 中可用的库，将它们配置为<code>CodecConfigurer</code>以具有合理的默认值。<p>Spring Boot 通过使用<code>CodecCustomizer</code>实例应用进一步的自定义。例如，将<code>spring.jackson.*</code>个配置密钥应用于 Jackson 编解码器。<p>如果需要添加或自定义编解码器，则可以创建自定义<code>CodecCustomizer</code>组件，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.boot.web.codec.CodecCustomizer;</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyConfiguration</span> {</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> CodecCustomizer <span class="title function_">myCodecCustomizer</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> codecConfigurer -> {</span><br><span class=line>			<span class=comment>// ...</span></span><br><span class=line>		}</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>您还可以使用<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-json-components rel=noopener target=_blank>Boot 的自定义 JSON 序列化器和反序列化器</a>。<h4 id=3-6-2-3、静态内容><a class=headerlink href=#3-6-2-3、静态内容 title=3.6.2.3、静态内容></a>3.6.2.3、静态内容</h4><p>默认情况下，Spring Boot 从 Classpath 中名为<code>/static</code>(或<code>/public</code>或<code>/resources</code>或<code>/META-INF/resources</code>)的目录中提供静态内容。它使用 Spring WebFlux 中的<code>ResourceWebHandler</code>，以便您可以通过添加自己的<code>WebFluxConfigurer</code>并覆盖<code>addResourceHandlers</code>方法来修改该行为。<p>默认情况下，资源 Map 在<code>/**</code>上，但是您可以通过设置<code>spring.webflux.static-path-pattern</code>属性对其进行调整。例如，将所有资源重定位到<code>/resources/**</code>可以实现如下：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.webflux.static-path-pattern=/resources/**</span><br></pre></table></figure><p>您还可以使用<code>spring.resources.static-locations</code>自定义静态资源位置。这样做会将默认值替换为目录位置列表。如果这样做，默认的欢迎页面检测将切换到您的自定义位置。因此，如果启动时您的任何位置都存在<code>index.html</code>，则它是应用程序的主页。<p>除了前面列出的“标准”静态资源位置之外，<a href=https://www.webjars.org/ rel=noopener target=_blank>Webjars content</a>也是一种特殊情况。如果 jar 文件以 Webjars 格式打包，则从 jar 文件提供带有<code>/webjars/**</code>路径的任何资源。<blockquote><p>Spring WebFlux 应用程序不严格依赖 Servlet API，因此不能将它们部署为 war 文件，也不使用<code>src/main/webapp</code>目录。</blockquote><h4 id=3-6-2-4、模板引擎><a class=headerlink href=#3-6-2-4、模板引擎 title=3.6.2.4、模板引擎></a>3.6.2.4、模板引擎</h4><p>除了 REST Web 服务之外，您还可以使用 Spring WebFlux 来提供动态 HTML 内容。 Spring WebFlux 支持多种模板技术，包括 Thymeleaf，FreeMarker 和 Mustache。<p>Spring Boot 包括对以下模板引擎的自动配置支持：<ul><li><a href=https://freemarker.apache.org/docs/ rel=noopener target=_blank>FreeMarker</a><li><a href=http://www.thymeleaf.org/ rel=noopener target=_blank>Thymeleaf</a><li><a href=https://mustache.github.io/ rel=noopener target=_blank>Mustache</a></ul><p>当您使用默认配置的这些模板引擎之一时，将从<code>src/main/resources/templates</code>自动拾取模板。<h4 id=3-6-2-5、错误处理><a class=headerlink href=#3-6-2-5、错误处理 title=3.6.2.5、错误处理></a>3.6.2.5、错误处理</h4><p>Spring Boot 提供了一个<code>WebExceptionHandler</code>，可以明智地处理所有错误。它在处理 Sequences 中的位置紧靠 WebFlux 提供的处理程序之前，该处理程序被认为是最后一个。对于机器 Client 端，它将生成 JSON 响应，其中包含错误，HTTP 状态和异常消息的详细信息。对于浏览器 Client 端，有一个“ whitelabel”错误处理程序，以 HTML 格式渲染相同的数据。您还可以提供自己的 HTML 模板来显示错误(请参见<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-webflux-error-handling-custom-error-pages rel=noopener target=_blank>next section</a>)。<p>定制此功能的第一步通常涉及使用现有机制，但替换或增加错误内容。为此，您可以添加<code>ErrorAttributes</code>类型的 bean。<p>要更改错误处理行为，可以实现<code>ErrorWebExceptionHandler</code>并注册该类型的 bean 定义。由于<code>WebExceptionHandler</code>的级别很低，因此 Spring Boot 还提供了一个方便的<code>AbstractErrorWebExceptionHandler</code>，让您以 WebFlux 功能方式处理错误，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CustomErrorWebExceptionHandler</span> <span class=keyword>extends</span> <span class="title class_">AbstractErrorWebExceptionHandler</span> {</span><br><span class=line>	<span class=comment>// Define constructor here</span></span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>protected</span> RouterFunction&LTServerResponse> <span class="title function_">getRoutingFunction</span><span class=params>(ErrorAttributes errorAttributes)</span> {</span><br><span class=line></span><br><span class=line>		<span class=keyword>return</span> RouterFunctions</span><br><span class=line>				.route(aPredicate, aHandler)</span><br><span class=line>				.andRoute(anotherPredicate, anotherHandler);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>要获得更完整的图片，您还可以直接继承<code>DefaultErrorWebExceptionHandler</code>并重写特定方法。<h5 id=自定义错误页面-1><a class=headerlink href=#自定义错误页面-1 title=自定义错误页面></a>自定义错误页面</h5><p>如果要显示给定状态代码的自定义 HTML 错误页面，可以将文件添加到<code>/error</code>文件夹。错误页面可以是静态 HTML(即添加到任何静态资源文件夹下)，也可以使用模板构建。文件名应为确切的状态代码或系列掩码。<p>例如，要将<code>404</code>Map 到静态 HTML 文件，您的文件夹结构如下：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>src/</span><br><span class=line> +- main/</span><br><span class=line>     +- java/</span><br><span class=line>     |   + &LTsource code></span><br><span class=line>     +- resources/</span><br><span class=line>         +- public/</span><br><span class=line>             +- error/</span><br><span class=line>             |   +- 404.html</span><br><span class=line>             +- &LTother public assets></span><br></pre></table></figure><p>要使用 Mustache 模板 Map 所有<code>5xx</code>错误，您的文件夹结构如下：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>src/</span><br><span class=line> +- main/</span><br><span class=line>     +- java/</span><br><span class=line>     |   + &LTsource code></span><br><span class=line>     +- resources/</span><br><span class=line>         +- templates/</span><br><span class=line>             +- error/</span><br><span class=line>             |   +- 5xx.mustache</span><br><span class=line>             +- &LTother templates></span><br></pre></table></figure><h4 id=3-6-2-6、网页过滤器><a class=headerlink href=#3-6-2-6、网页过滤器 title=3.6.2.6、网页过滤器></a>3.6.2.6、网页过滤器</h4><p>Spring WebFlux 提供了一个<code>WebFilter</code>接口，可以实现该接口来过滤 HTTP 请求-响应交换。在应用程序上下文中找到的<code>WebFilter</code> bean 将自动用于过滤每次交换。<p>在过滤器 Sequences 很重要的地方，它们可以实现<code>Ordered</code>或用<code>@Order</code>Comments。 Spring Boot 自动配置可能会为您配置 Web 过滤器。这样做时，将使用下表中显示的 Sequences：<table><thead><tr><th>Web Filter<th>Order<tbody><tr><td><code>MetricsWebFilter</code><td><code>Ordered.HIGHEST_PRECEDENCE + 1</code><tr><td><code>WebFilterChainProxy</code>(Spring Security 性)<td><code>-100</code><tr><td><code>HttpTraceWebFilter</code><td><code>Ordered.LOWEST_PRECEDENCE - 10</code></table><h3 id=3-6-3、JAX-RX和Jersey><a class=headerlink href=#3-6-3、JAX-RX和Jersey title=3.6.3、JAX-RX和Jersey></a>3.6.3、JAX-RX和Jersey</h3><p>如果您更喜欢 REST 端点的 JAX-RS 编程模型，则可以使用可用的实现之一来代替 Spring MVC。 <a href=https://jersey.github.io/ rel=noopener target=_blank>Jersey</a>和<a href=https://cxf.apache.org/ rel=noopener target=_blank>Apache CXF</a>开箱即用。 CXF 要求您在应用程序上下文中将其<code>Servlet</code>或<code>Filter</code>注册为<code>@Bean</code>。Jersey(Jersey)有一些本机 Spring 支持，因此我们在 Spring Boot 中还与启动程序一起为其提供了自动配置支持。<p>要开始使用 Jersey，请将<code>spring-boot-starter-jersey</code>作为依赖项，然后需要一个<code>ResourceConfig</code>类型的<code>@Bean</code>，在其中注册所有端点，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">JerseyConfig</span> <span class=keyword>extends</span> <span class="title class_">ResourceConfig</span> {</span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">JerseyConfig</span><span class=params>()</span> {</span><br><span class=line>		register(Endpoint.class);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>Jersey 对扫描可执行归档文件的支持非常有限。例如，在运行可执行的 war 文件时，它无法扫描在<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/deployment-install.html rel=noopener target=_blank>完全可执行的 jar 文件</a>或<code>WEB-INF/classes</code>中找到的程序包中的端点。为避免此限制，不应使用<code>packages</code>方法，并且应使用<code>register</code>方法分别注册端点，如前面的示例所示。</blockquote><p>对于更高级的定制，您还可以注册实现<code>ResourceConfigCustomizer</code>的任意数量的 bean。<p>所有注册的端点都应为<code>@Components</code>，并带有 HTTP 资源 Comments(<code>@GET</code>和其他 Comments)，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Path("/hello")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Endpoint</span> {</span><br><span class=line>	<span class=meta>@GET</span></span><br><span class=line>	<span class=keyword>public</span> String <span class="title function_">message</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=string>"Hello"</span>;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>由于<code>Endpoint</code>是 Spring <code>@Component</code>，其生命周期由 Spring Management，因此您可以使用<code>@Autowired</code>注解注入依赖项，并使用<code>@Value</code>注解注入外部配置。默认情况下，Jersey servlet 已注册并 Map 到<code>/*</code>。您可以通过将<code>@ApplicationPath</code>添加到<code>ResourceConfig</code>来更改 Map。<p>默认情况下，Jersey 在名为<code>jerseyServletRegistration</code>的<code>ServletRegistrationBean</code>类型的<code>@Bean</code>中设置为 Servlet。默认情况下，该 Servlet 延迟初始化，但是您可以通过设置<code>spring.jersey.servlet.load-on-startup</code>来自定义该行为。您可以通过使用相同的名称创建自己的一个来禁用或覆盖该 bean。您还可以通过设置<code>spring.jersey.type=filter</code>(在这种情况下，要替换或覆盖的<code>@Bean</code>是<code>jerseyFilterRegistration</code>)来使用过滤器而不是 Servlet。过滤器具有<code>@Order</code>，您可以使用<code>spring.jersey.filter.order</code>进行设置。可以使用<code>spring.jersey.init.*</code>指定属性 Map，从而为 servlet 和过滤器注册都赋予 init 参数。<p>有一个<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-samples/spring-boot-sample-jersey rel=noopener target=_blank>Jersey sample</a>，以便您可以了解如何进行设置。<h3 id=3-6-4、嵌入式Servlet容器支持><a class=headerlink href=#3-6-4、嵌入式Servlet容器支持 title=3.6.4、嵌入式Servlet容器支持></a>3.6.4、嵌入式Servlet容器支持</h3><p>Spring Boot 包含对嵌入式<a href=https://tomcat.apache.org/ rel=noopener target=_blank>Tomcat</a>，<a href=https://www.eclipse.org/jetty/ rel=noopener target=_blank>Jetty</a>和<a href=http://undertow.io/ rel=noopener target=_blank>Undertow</a>服务器的支持。大多数开发人员使用适当的“启动器”来获取完全配置的实例。默认情况下，嵌入式服务器在端口<code>8080</code>上侦听 HTTP 请求。<blockquote><p>如果选择在<a href=https://www.centos.org/ rel=noopener target=_blank>CentOS</a>上使用 Tomcat，请注意，默认情况下，将使用一个临时目录来存储编译的 JSP，文件上载等等。您的应用程序运行时，此目录可能被<code>tmpwatch</code>删除，从而导致失败。为避免这种情况，您可能需要自定义<code>tmpwatch</code>配置，以使<code>tomcat.*</code>目录不会被删除，或配置<code>server.tomcat.basedir</code>，以使嵌入式 Tomcat 使用其他位置。</blockquote><h4 id=3-6-4-1、Servlet，过滤器和侦听器><a class=headerlink href=#3-6-4-1、Servlet，过滤器和侦听器 title=3.6.4.1、Servlet，过滤器和侦听器></a>3.6.4.1、Servlet，过滤器和侦听器</h4><p>使用嵌入式 Servlet 容器时，可以通过使用 Spring bean 或扫描 Servlet 组件来注册 Servlet 规范中的 Servlet，过滤器和所有侦听器(例如<code>HttpSessionListener</code>)。<h5 id=将-Servlet，过滤器和侦听器注册为-Spring-Bean><a title="将 Servlet，过滤器和侦听器注册为 Spring Bean" class=headerlink href=#将-Servlet，过滤器和侦听器注册为-Spring-Bean></a>将 Servlet，过滤器和侦听器注册为 Spring Bean</h5><p>任何作为 Spring bean 的<code>Servlet</code>，<code>Filter</code>或 servlet <code>*Listener</code>实例都向嵌入式容器注册。如果要在配置过程中引用<code>application.properties</code>中的值，这可能特别方便。<p>默认情况下，如果上下文仅包含单个 Servlet，则将其 Map 到<code>/</code>。对于多个 servlet bean，bean 名称用作路径前缀。过滤器 Map 到<code>/*</code>。<p>如果基于约定的 Map 不够灵活，则可以使用<code>ServletRegistrationBean</code>，<code>FilterRegistrationBean</code>和<code>ServletListenerRegistrationBean</code>类进行完全控制。<p>Spring Boot 附带了许多可能定义 Filter bean 的自动配置。以下是过滤器及其各自 Sequences 的一些示例(较低的 Sequences 值表示较高的优先级)：<table><thead><tr><th>Servlet Filter<th>Order<tbody><tr><td><code>OrderedCharacterEncodingFilter</code><td><code>Ordered.HIGHEST_PRECEDENCE</code><tr><td><code>WebMvcMetricsFilter</code><td><code>Ordered.HIGHEST_PRECEDENCE + 1</code><tr><td><code>ErrorPageFilter</code><td><code>Ordered.HIGHEST_PRECEDENCE + 1</code><tr><td><code>HttpTraceFilter</code><td><code>Ordered.LOWEST_PRECEDENCE - 10</code></table><p>通常可以使无序滤 bean 处于无序状态。<p>如果需要特定的 Sequences，则应避免配置一个在<code>Ordered.HIGHEST_PRECEDENCE</code>读取请求正文的过滤器，因为它可能与应用程序的字符编码配置不符。如果 Servlet 过滤器包装了请求，则应以小于或等于<code>OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER</code>的 Sequences 对其进行配置。<h4 id=3-6-4-2、Servlet-上下文初始化><a title="3.6.4.2、Servlet 上下文初始化" class=headerlink href=#3-6-4-2、Servlet-上下文初始化></a>3.6.4.2、Servlet 上下文初始化</h4><p>嵌入式 Servlet 容器不会直接执行 Servlet 3.0 <code>javax.servlet.ServletContainerInitializer</code>接口或 Spring 的<code>org.springframework.web.WebApplicationInitializer</code>接口。这是一个有意设计的决定，目的是减少旨在在 War 中运行的第三方库可能破坏 Spring Boot 应用程序的风险。<p>如果需要在 Spring Boot 应用程序中执行 servlet 上下文初始化，则应该注册一个实现<code>org.springframework.boot.web.servlet.ServletContextInitializer</code>接口的 bean。单个<code>onStartup</code>方法提供对<code>ServletContext</code>的访问，并且在必要时可以轻松地用作现有<code>WebApplicationInitializer</code>的适配器。<h5 id=扫描-Servlet，过滤器和侦听器><a title="扫描 Servlet，过滤器和侦听器" class=headerlink href=#扫描-Servlet，过滤器和侦听器></a>扫描 Servlet，过滤器和侦听器</h5><p>使用嵌入式容器时，可以通过使用<code>@ServletComponentScan</code>来启用自动注册带有<code>@WebServlet</code>，<code>@WebFilter</code>和<code>@WebListener</code>Comments 的类。<blockquote><p><code>@ServletComponentScan</code>在独立容器中无效，而是使用该容器的内置发现机制。</blockquote><h4 id=3-6-4-3、ServletWebServerApplicationContext><a class=headerlink href=#3-6-4-3、ServletWebServerApplicationContext title=3.6.4.3、ServletWebServerApplicationContext></a>3.6.4.3、ServletWebServerApplicationContext</h4><p>在后台，Spring Boot 使用另一种类型的<code>ApplicationContext</code>来支持嵌入式 servlet 容器。 <code>ServletWebServerApplicationContext</code>是<code>WebApplicationContext</code>的一种特殊类型，它通过搜索单个<code>ServletWebServerFactory</code> bean 来进行自我引导。通常<code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>或<code>UndertowServletWebServerFactory</code>已被自动配置。<blockquote><p>通常，您不需要了解这些实现类。大多数应用程序都是自动配置的，并且代表您创建了相应的<code>ApplicationContext</code>和<code>ServletWebServerFactory</code>。</blockquote><h4 id=3-6-4-4、自定义嵌入式-Servlet-容器><a title="3.6.4.4、自定义嵌入式 Servlet 容器" class=headerlink href=#3-6-4-4、自定义嵌入式-Servlet-容器></a>3.6.4.4、自定义嵌入式 Servlet 容器</h4><p>可以使用 Spring <code>Environment</code>属性来配置常见的 servlet 容器设置。通常，您将在<code>application.properties</code>文件中定义属性。<p>常用服务器设置包括：<ul><li>网络设置：侦听传入 HTTP 请求的端口(<code>server.port</code>)，绑定到<code>server.address</code>的接口地址，等等。<li>会话设置：会话是否持久(<code>server.servlet.session.persistence</code>)，会话超时(<code>server.servlet.session.timeout</code>)，会话数据的位置(<code>server.servlet.session.store-dir</code>)和会话 cookie 配置(<code>server.servlet.session.cookie.*</code>)。<li>错误 Management：错误页面的位置(<code>server.error.path</code>)，依此类推。<li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/howto-embedded-web-servers.html#howto-configure-ssl rel=noopener target=_blank>SSL</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/howto-embedded-web-servers.html#how-to-enable-http-response-compression rel=noopener target=_blank>HTTP compression</a></ul><p>Spring Boot 尝试尽可能多地公开通用设置，但这并不总是可能的。在这种情况下，专用名称空间提供服务器特定的自定义项(请参见<code>server.tomcat</code>和<code>server.undertow</code>)。例如，<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/howto-embedded-web-servers.html#howto-configure-accesslogs rel=noopener target=_blank>access logs</a>可以配置有嵌入式 Servlet 容器的特定功能。<h5 id=Programmatic-Customization><a title="Programmatic Customization" class=headerlink href=#Programmatic-Customization></a>Programmatic Customization</h5><p>如果需要以编程方式配置嵌入式 servlet 容器，则可以注册一个实现<code>WebServerFactoryCustomizer</code>接口的 Spring bean。 <code>WebServerFactoryCustomizer</code>提供对<code>ConfigurableServletWebServerFactory</code>的访问，其中包括许多自定义设置方法。以下示例显示以编程方式设置端口：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.boot.web.server.WebServerFactoryCustomizer;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CustomizationBean</span> <span class=keyword>implements</span> <span class="title class_">WebServerFactoryCustomizer</span>&LTConfigurableServletWebServerFactory> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">customize</span><span class=params>(ConfigurableServletWebServerFactory server)</span> {</span><br><span class=line>		server.setPort(<span class=number>9000</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p><code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>和<code>UndertowServletWebServerFactory</code>是<code>ConfigurableServletWebServerFactory</code>的专用变体，分别具有针对 Tomcat，Jetty 和 Undertow 的其他自定义设置方法。</blockquote><h5 id=直接自定义-ConfigurableServletWebServerFactory><a title="直接自定义 ConfigurableServletWebServerFactory" class=headerlink href=#直接自定义-ConfigurableServletWebServerFactory></a>直接自定义 ConfigurableServletWebServerFactory</h5><p>如果上述定制技术太有限，则可以自己注册<code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>或<code>UndertowServletWebServerFactory</code> bean。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> ConfigurableServletWebServerFactory <span class="title function_">webServerFactory</span><span class=params>()</span> {</span><br><span class=line>	<span class=type>TomcatServletWebServerFactory</span> <span class=variable>factory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class=line>	factory.setPort(<span class=number>9000</span>);</span><br><span class=line>	factory.setSessionTimeout(<span class=number>10</span>, TimeUnit.MINUTES);</span><br><span class=line>	factory.addErrorPages(<span class=keyword>new</span> <span class="title class_">ErrorPage</span>(HttpStatus.NOT_FOUND, <span class=string>"/notfound.html"</span>));</span><br><span class=line>	<span class=keyword>return</span> factory;</span><br><span class=line>}</span><br></pre></table></figure><p>提供了许多配置选项的设置器。如果您需要做一些更奇特的操作，还提供了几种受保护的方法“钩子”。有关详情，请参见<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/web/servlet/server/ConfigurableServletWebServerFactory.html rel=noopener target=_blank>源代码文档</a>。<h4 id=3-6-4-5、JSP限制><a class=headerlink href=#3-6-4-5、JSP限制 title=3.6.4.5、JSP限制></a>3.6.4.5、JSP限制</h4><p>当运行使用嵌入式 servlet 容器(并打包为可执行归档文件)的 Spring Boot 应用程序时，JSP 支持存在一些限制。<ul><li>对于 Jetty 和 Tomcat，如果使用 War 包装，它应该可以工作。与<code>java -jar</code>一起启动时，可执行的 War 将起作用，并且也可部署到任何标准容器中。使用可执行 jar 时，不支持 JSP。<li>Undertow 不支持 JSP。<li>创建自定义<code>error.jsp</code>页面不会覆盖<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-error-handling rel=noopener target=_blank>error handling</a>的默认视图。应该改用<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-error-handling-custom-error-pages rel=noopener target=_blank>自定义错误页面</a>。</ul><p>有一个<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-samples/spring-boot-sample-web-jsp rel=noopener target=_blank>JSP sample</a>，以便您可以了解如何进行设置。<h3 id=3-6-5、嵌入式反应式服务器支持><a class=headerlink href=#3-6-5、嵌入式反应式服务器支持 title=3.6.5、嵌入式反应式服务器支持></a>3.6.5、嵌入式反应式服务器支持</h3><p>Spring Boot 包含对以下嵌入式反应式 Web 服务器的支持：Reactor Netty，Tomcat，Jetty 和 Undertow。大多数开发人员使用适当的“启动器”来获取完全配置的实例。默认情况下，嵌入式服务器在端口 8080 上侦听 HTTP 请求。<h3 id=3-6-6、Reactive-服务器资源配置><a title="3.6.6、Reactive 服务器资源配置" class=headerlink href=#3-6-6、Reactive-服务器资源配置></a>3.6.6、Reactive 服务器资源配置</h3><p>当自动配置 Reactor Netty 或 Jetty 服务器时，Spring Boot 将创建特定的 bean，这些 bean 将为服务器实例提供 HTTP 资源：<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code>。<p>默认情况下，在以下情况下，这些资源还将与 Reactor Netty 和 Jetty Client 端共享，以实现最佳性能：<ul><li>服务器和 Client 端使用相同的技术<li>Client 端实例是使用 Spring Boot 自动配置的<code>WebClient.Builder</code> bean 构建的</ul><p>通过提供自定义的<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code> bean，开发人员可以覆盖 Jetty 和 Reactor Netty 的资源配置-这将同时应用于 Client 端和服务器。<p>您可以在<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-webclient.html#boot-features-webclient-runtime rel=noopener target=_blank>WebClient 运行时部分</a>中了解有关 Client 端资源配置的更多信息。<h2 id=3-7、Security><a class=headerlink href=#3-7、Security title=3.7、Security></a>3.7、Security</h2><p>如果<a href=https://projects.spring.io/spring-security/ rel=noopener target=_blank>Spring Security</a>在 Classpath 上，则默认情况下将保护 Web 应用程序的安全。 Spring Boot 依靠 Spring Security 的内容协商策略来确定使用<code>httpBasic</code>还是<code>formLogin</code>。要将方法级安全性添加到 Web 应用程序，您还可以使用所需的设置添加<code>@EnableGlobalMethodSecurity</code>。其他信息可以在<a href=https://docs.spring.io/spring-security/site/docs/5.1.2.RELEASE/reference/htmlsingle#jc-method rel=noopener target=_blank>Spring Security 参考指南</a>中找到。<p>默认的<code>UserDetailsService</code>有一个用户。用户名为<code>user</code>，密码为随机密码，并在应用程序启动时以 INFO 级别显示，如下例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>Using generated security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35</span><br></pre></table></figure><blockquote><p>如果您微调日志记录配置，请确保将<code>org.springframework.boot.autoconfigure.security</code>类别设置为记录<code>INFO</code>级消息。否则，不会打印默认密码。</blockquote><p>您可以通过提供<code>spring.security.user.name</code>和<code>spring.security.user.password</code>来更改用户名和密码。<p>默认情况下，您在 Web 应用程序中获得的基本功能是：<ul><li>具有内存存储的<code>UserDetailsService</code>(或 WebFlux 应用程序为<code>ReactiveUserDetailsService</code>)bean 和具有生成的密码的单个用户(有关用户的属性，请参见<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/autoconfigure/security/SecurityProperties.User.html rel=noopener target=_blank>SecurityProperties.User</a>)。<li>整个应用程序的基于表单的登录或 HTTP 基本安全性(取决于 Content-Type)(如果 Actuator 位于 Classpath 上，则包括 Actuator 端点)。<li><code>DefaultAuthenticationEventPublisher</code>用于发布身份验证事件。</ul><p>您可以通过添加一个 Bean 来提供另一个<code>AuthenticationEventPublisher</code>。<h3 id=3-7-1、MVC安全性><a class=headerlink href=#3-7-1、MVC安全性 title=3.7.1、MVC安全性></a>3.7.1、MVC安全性</h3><p>默认的安全配置在<code>SecurityAutoConfiguration</code>和<code>UserDetailsServiceAutoConfiguration</code>中实现。 <code>SecurityAutoConfiguration</code>导入<code>SpringBootWebSecurityConfiguration</code>以获得 Web 安全性，并且<code>UserDetailsServiceAutoConfiguration</code>配置身份验证，这也与非 Web 应用程序相关。要完全关闭默认的 Web 应用程序安全性配置，可以添加类型为<code>WebSecurityConfigurerAdapter</code>的 bean(这样做不会禁用<code>UserDetailsService</code>配置或 Actuator 的安全性)。<p>要也关闭<code>UserDetailsService</code>配置，可以添加<code>UserDetailsService</code>，<code>AuthenticationProvider</code>或<code>AuthenticationManager</code>类型的 Bean。 <a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-samples/ rel=noopener target=_blank>Spring Bootsample</a>中有几个安全的应用程序，可帮助您开始使用常见的用例。<p>通过添加自定义<code>WebSecurityConfigurerAdapter</code>可以覆盖访问规则。 Spring Boot 提供了便利的方法，可用于覆盖 Actuator 端点和静态资源的访问规则。 <code>EndpointRequest</code>可用于创建基于<code>management.endpoints.web.base-path</code>属性的<code>RequestMatcher</code>。 <code>PathRequest</code>可用于为常用位置的资源创建<code>RequestMatcher</code>。<h3 id=3-7-2、WebFlux-安全性><a title="3.7.2、WebFlux 安全性" class=headerlink href=#3-7-2、WebFlux-安全性></a>3.7.2、WebFlux 安全性</h3><p>与 Spring MVC 应用程序类似，您可以通过添加<code>spring-boot-starter-security</code>依赖项来保护 WebFlux 应用程序。默认的安全配置在<code>ReactiveSecurityAutoConfiguration</code>和<code>UserDetailsServiceAutoConfiguration</code>中实现。 <code>ReactiveSecurityAutoConfiguration</code>导入<code>WebFluxSecurityConfiguration</code>以获得 Web 安全性，并且<code>UserDetailsServiceAutoConfiguration</code>配置身份验证，这也与非 Web 应用程序相关。要完全关闭默认的 Web 应用程序安全性配置，可以添加类型为<code>WebFilterChainProxy</code>的 bean(这样做不会禁用<code>UserDetailsService</code>配置或 Actuator 的安全性)。<p>要也关闭<code>UserDetailsService</code>配置，可以添加<code>ReactiveUserDetailsService</code>或<code>ReactiveAuthenticationManager</code>类型的 Bean。<p>可以通过添加自定义<code>SecurityWebFilterChain</code>来配置访问规则。 Spring Boot 提供了便利的方法，可用于覆盖 Actuator 端点和静态资源的访问规则。 <code>EndpointRequest</code>可用于创建基于<code>management.endpoints.web.base-path</code>属性的<code>ServerWebExchangeMatcher</code>。<p><code>PathRequest</code>可用于为常用位置的资源创建<code>ServerWebExchangeMatcher</code>。<p>例如，您可以通过添加以下内容来自定义安全配置：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> SecurityWebFilterChain <span class="title function_">springSecurityFilterChain</span><span class=params>(ServerHttpSecurity http)</span> {</span><br><span class=line>	<span class=keyword>return</span> http</span><br><span class=line>		.authorizeExchange()</span><br><span class=line>.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll()</span><br><span class=line>			.pathMatchers(<span class=string>"/foo"</span>, <span class=string>"/bar"</span>)</span><br><span class=line>				.authenticated().and()</span><br><span class=line>			.formLogin().and()</span><br><span class=line>		.build();</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-7-3、OAuth2><a class=headerlink href=#3-7-3、OAuth2 title=3.7.3、OAuth2></a>3.7.3、OAuth2</h3><p><a href=https://oauth.net/2/ rel=noopener target=_blank>OAuth2</a>是 Spring 支持的广泛使用的授权框架。<h4 id=3-7-3-1、Client><a class=headerlink href=#3-7-3-1、Client title=3.7.3.1、Client></a>3.7.3.1、Client</h4><p>如果您的 Classpath 上有<code>spring-security-oauth2-client</code>，则可以利用一些自动配置功能来轻松设置 OAuth2/Open ID Connect Client 端。此配置使用<code>OAuth2ClientProperties</code>下的属性。相同的属性适用于 servlet 和反应式应用程序。<p>您可以使用<code>spring.security.oauth2.client</code>前缀注册多个 OAuth2 Client 端和提供者，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line>spring.security.oauth2.client.registration.my-client-1.client-id=abcd</span><br><span class=line>spring.security.oauth2.client.registration.my-client-1.client-secret=password</span><br><span class=line>spring.security.oauth2.client.registration.my-client-1.client-name=Client for user scope</span><br><span class=line>spring.security.oauth2.client.registration.my-client-1.provider=my-oauth-provider</span><br><span class=line>spring.security.oauth2.client.registration.my-client-1.scope=user</span><br><span class=line>spring.security.oauth2.client.registration.my-client-1.redirect-uri-template=http://my-redirect-uri.com</span><br><span class=line>spring.security.oauth2.client.registration.my-client-1.client-authentication-method=basic</span><br><span class=line>spring.security.oauth2.client.registration.my-client-1.authorization-grant-type=authorization_code</span><br><span class=line></span><br><span class=line>spring.security.oauth2.client.registration.my-client-2.client-id=abcd</span><br><span class=line>spring.security.oauth2.client.registration.my-client-2.client-secret=password</span><br><span class=line>spring.security.oauth2.client.registration.my-client-2.client-name=Client for email scope</span><br><span class=line>spring.security.oauth2.client.registration.my-client-2.provider=my-oauth-provider</span><br><span class=line>spring.security.oauth2.client.registration.my-client-2.scope=email</span><br><span class=line>spring.security.oauth2.client.registration.my-client-2.redirect-uri-template=http://my-redirect-uri.com</span><br><span class=line>spring.security.oauth2.client.registration.my-client-2.client-authentication-method=basic</span><br><span class=line>spring.security.oauth2.client.registration.my-client-2.authorization-grant-type=authorization_code</span><br><span class=line></span><br><span class=line>spring.security.oauth2.client.provider.my-oauth-provider.authorization-uri=http://my-auth-server/oauth/authorize</span><br><span class=line>spring.security.oauth2.client.provider.my-oauth-provider.token-uri=http://my-auth-server/oauth/token</span><br><span class=line>spring.security.oauth2.client.provider.my-oauth-provider.user-info-uri=http://my-auth-server/userinfo</span><br><span class=line>spring.security.oauth2.client.provider.my-oauth-provider.user-info-authentication-method=header</span><br><span class=line>spring.security.oauth2.client.provider.my-oauth-provider.jwk-set-uri=http://my-auth-server/token_keys</span><br><span class=line>spring.security.oauth2.client.provider.my-oauth-provider.user-name-attribute=name</span><br></pre></table></figure><p>对于支持<a href=https://openid.net/specs/openid-connect-discovery-1_0.html rel=noopener target=_blank>OpenID Connect 发现</a>的 OpenID Connect 提供程序，可以进一步简化配置。提供者需要配置一个<code>issuer-uri</code>，这是它声明为其发布者标识符的 URI。例如，如果提供的<code>issuer-uri</code>是“ <a href=https://example.com”,则将对“/ rel=noopener target=_blank>https://example.com”，则将对“</a> <a href=https://example.com/.well-known/openid-configuration%E2%80%9D%E8%AE%BE%E7%BD%AE%60OpenID rel=noopener target=_blank>https://example.com/.well-known/openid-configuration”设置`OpenID</a> Provider Configuration Request<code>。结果预期为</code>OpenID Provider Configuration Response<code>。以下示例显示了如何使用</code>issuer-uri`配置 OpenID Connect 提供程序：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.security.oauth2.client.provider.oidc-provider.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/</span><br></pre></table></figure><p>默认情况下，Spring Security 的<code>OAuth2LoginAuthenticationFilter</code>只处理与<code>/login/oauth2/code/*</code>匹配的 URL。如果要定制<code>redirect-uri</code>以使用其他模式，则需要提供配置以处理该定制模式。例如，对于 servlet 应用程序，您可以添加自己的<code>WebSecurityConfigurerAdapter</code>，其类似于以下内容：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">OAuth2LoginSecurityConfig</span> <span class=keyword>extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>protected</span> <span class=keyword>void</span> <span class="title function_">configure</span><span class=params>(HttpSecurity http)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		http</span><br><span class=line>			.authorizeRequests()</span><br><span class=line>				.anyRequest().authenticated()</span><br><span class=line>				.and()</span><br><span class=line>			.oauth2Login()</span><br><span class=line>				.redirectionEndpoint()</span><br><span class=line>					.baseUri(<span class=string>"/custom-callback"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h5 id=通用提供商的-OAuth2-Client-端注册><a title="通用提供商的 OAuth2 Client 端注册" class=headerlink href=#通用提供商的-OAuth2-Client-端注册></a>通用提供商的 OAuth2 Client 端注册</h5><p>对于常见的 OAuth2 和 OpenID 提供程序，包括 Google，Github，Facebook 和 Okta，我们提供了一组提供程序默认值(分别为<code>google</code>，<code>github</code>，<code>facebook</code>和<code>okta</code>)。<p>如果不需要自定义这些提供程序，则可以将<code>provider</code>属性设置为您需要为其推断默认值的属性。另外，如果用于 Client 端注册的密钥与默认支持的提供程序匹配，则 Spring Boot 也会进行推断。<p>换句话说，以下示例中的两种配置都使用 Google 提供程序：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>spring.security.oauth2.client.registration.my-client.client-id=abcd</span><br><span class=line>spring.security.oauth2.client.registration.my-client.client-secret=password</span><br><span class=line>spring.security.oauth2.client.registration.my-client.provider=google</span><br><span class=line></span><br><span class=line>spring.security.oauth2.client.registration.google.client-id=abcd</span><br><span class=line>spring.security.oauth2.client.registration.google.client-secret=password</span><br></pre></table></figure><h4 id=3-7-3-2、资源服务器><a class=headerlink href=#3-7-3-2、资源服务器 title=3.7.3.2、资源服务器></a>3.7.3.2、资源服务器</h4><p>如果您的 Classpath 上有<code>spring-security-oauth2-resource-server</code>，则只要指定了 JWK Set URI 或 OIDC Issuer URI，Spring Boot 就可以设置 OAuth2 资源服务器，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://example.com/oauth2/default/v1/keys</span><br><span class=line>spring.security.oauth2.resourceserver.jwt.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/</span><br></pre></table></figure><p>相同的属性适用于 servlet 和反应式应用程序。<p>另外，您可以为 Servlet 应用程序定义自己的<code>JwtDecoder</code> bean 或为 Reactive 应用程序定义<code>ReactiveJwtDecoder</code>。<h4 id=3-7-3-3、授权服务器><a class=headerlink href=#3-7-3-3、授权服务器 title=3.7.3.3、授权服务器></a>3.7.3.3、授权服务器</h4><p>当前，Spring Security 不提供对实现 OAuth 2.0 授权服务器的支持。但是，此功能可从<a href=https://projects.spring.io/spring-security-oauth/ rel=noopener target=_blank>Spring Security OAuth</a>项目获得，最终将被 Spring Security 完全取代。在此之前，您可以使用<code>spring-security-oauth2-autoconfigure</code>模块轻松设置 OAuth 2.0 授权服务器；有关说明，请参见其<a href=https://docs.spring.io/spring-security-oauth2-boot rel=noopener target=_blank>documentation</a>。<h3 id=3-7-4、Actuator安全性><a class=headerlink href=#3-7-4、Actuator安全性 title=3.7.4、Actuator安全性></a>3.7.4、Actuator安全性</h3><p>为了安全起见，默认禁用除<code>/health</code>和<code>/info</code>以外的所有 Actuator。 <code>management.endpoints.web.exposure.include</code>属性可用于启用 Actuator。<p>如果 Spring Security 位于 Classpath 上，并且不存在其他 WebSecurityConfigurerAdapter，则通过 Spring Boot 自动配置来保护<code>/health</code>和<code>/info</code>以外的所有 Actuator。如果您定义一个自定义<code>WebSecurityConfigurerAdapter</code>，Spring Boot 自动配置将退出，您将完全控制 Actuator 访问规则。<blockquote><p>在设置<code>management.endpoints.web.exposure.include</code>之前，请确保裸露的 Actuator 不包含敏感信息和/或通过将它们放置在防火墙后面或通过诸如 Spring Security 之类的东西进行保护。</blockquote><h4 id=3-7-4-1、跨站点请求伪造保护><a class=headerlink href=#3-7-4-1、跨站点请求伪造保护 title=3.7.4.1、跨站点请求伪造保护></a>3.7.4.1、跨站点请求伪造保护</h4><p>由于 Spring Boot 依赖于 Spring Security 的默认值，因此默认情况下 CSRF 保护是打开的。这意味着在使用默认安全性配置时，需要<code>POST</code>的 Actuator 端点(关机和 Logger 端点)，<code>PUT</code>或<code>DELETE</code>将收到 403 禁止错误。<blockquote><p>我们建议仅在创建非浏览器 Client 端使用的服务时完全禁用 CSRF 保护。</blockquote><h2 id=3-8、使用SQL数据库><a class=headerlink href=#3-8、使用SQL数据库 title=3.8、使用SQL数据库></a>3.8、使用SQL数据库</h2><p><a href=https://projects.spring.io/spring-framework/ rel=noopener target=_blank>Spring Framework</a>为使用 SQL 数据库提供了广泛的支持，从使用<code>JdbcTemplate</code>的直接 JDBC 访问到完整的“对象关系 Map”技术(例如 Hibernate)。 <a href=https://projects.spring.io/spring-data/ rel=noopener target=_blank>Spring Data</a>提供了更高级别的功能：直接从接口创建<code>Repository</code>实现，并使用约定从您的方法名称生成查询。<h3 id=3-8-1、配置数据源><a class=headerlink href=#3-8-1、配置数据源 title=3.8.1、配置数据源></a>3.8.1、配置数据源</h3><p>Java 的<code>javax.sql.DataSource</code>接口提供了使用数据库连接的标准方法。传统上，“数据源”使用<code>URL</code>以及一些凭据来构建数据库连接。<h4 id=3-8-1-1、嵌入式数据库支持><a class=headerlink href=#3-8-1-1、嵌入式数据库支持 title=3.8.1.1、嵌入式数据库支持></a>3.8.1.1、嵌入式数据库支持</h4><p>通过使用内存嵌入式数据库来开发应用程序通常很方便。显然，内存数据库不提供持久存储。您需要在应用程序启动时填充数据库，并准备在应用程序结束时丢弃数据。<p>Spring Boot 可以自动配置嵌入式<a href=http://www.h2database.com/ rel=noopener target=_blank>H2</a>，<a href=http://hsqldb.org/ rel=noopener target=_blank>HSQL</a>和<a href=https://db.apache.org/derby/ rel=noopener target=_blank>Derby</a>数据库。您无需提供任何连接 URL。您只需要包含要使用的嵌入式数据库的构建依赖项即可。<blockquote><p>如果在测试中使用此功能，则可能会注意到，整个测试套件将重用同一数据库，而不管您使用的应用程序上下文的数量如何。如果要确保每个上下文都有一个单独的嵌入式数据库，则应将<code>spring.datasource.generate-unique-name</code>设置为<code>true</code>。</blockquote><p>例如，典型的 POM 依赖关系如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>spring-boot-starter-data-jpa<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>org.hsqldb<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>hsqldb<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>scope</span>></span>runtime<span class=tag>&LT/<span class=name>scope</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><blockquote><p>您需要依赖<code>spring-jdbc</code>才能自动配置嵌入式数据库。在此示例中，它通过<code>spring-boot-starter-data-jpa</code>暂时拉入。<p>如果出于某种原因确实为嵌入式数据库配置了连接 URL，请确保确保禁用了数据库的自动关闭功能。如果使用 H2，则应使用<code>DB_CLOSE_ON_EXIT=FALSE</code>。如果使用 HSQLDB，则应确保不使用<code>shutdown=true</code>。通过禁用数据库的自动关闭功能，Spring Boot 可以控制何时关闭数据库，从而确保一旦不再需要访问数据库时就可以执行该操作。</blockquote><h4 id=3-8-1-2、连接到生产数据库><a class=headerlink href=#3-8-1-2、连接到生产数据库 title=3.8.1.2、连接到生产数据库></a>3.8.1.2、连接到生产数据库</h4><p>生产数据库连接也可以使用池<code>DataSource</code>进行自动配置。 Spring Boot 使用以下算法来选择特定的实现：<ul><li>我们更喜欢<a href=https://github.com/brettwooldridge/HikariCP rel=noopener target=_blank>HikariCP</a>的性能和并发性。如果 HikariCP 可用，我们总是选择它。<li>否则，如果 Tomcat 池<code>DataSource</code>可用，我们将使用它。<li>如果 HikariCP 和 Tomcat 池数据源都不可用，并且<a href=https://commons.apache.org/proper/commons-dbcp/ rel=noopener target=_blank>Commons DBCP2</a>可用，我们将使用它。</ul><p>如果使用<code>spring-boot-starter-jdbc</code>或<code>spring-boot-starter-data-jpa</code>“启动器”，则会自动获得<code>HikariCP</code>的依赖项。<blockquote><p>您可以完全绕过该算法，并通过设置<code>spring.datasource.type</code>属性来指定要使用的连接池。如果您在 Tomcat 容器中运行应用程序，这一点尤其重要，因为默认情况下提供<code>tomcat-jdbc</code>。<p>其他连接池始终可以手动配置。如果定义自己的<code>DataSource</code> bean，则不会进行自动配置。</blockquote><p>数据源配置由<code>spring.datasource.*</code>中的外部配置属性控制。例如，您可以在<code>application.properties</code>中声明以下部分：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.datasource.url</span>=<span class=string>jdbc:mysql://localhost/test</span></span><br><span class=line><span class=attr>spring.datasource.username</span>=<span class=string>dbuser</span></span><br><span class=line><span class=attr>spring.datasource.password</span>=<span class=string>dbpass</span></span><br><span class=line><span class=attr>spring.datasource.driver-class-name</span>=<span class=string>com.mysql.jdbc.Driver</span></span><br></pre></table></figure><blockquote><p>您至少应通过设置<code>spring.datasource.url</code>属性来指定 URL。否则，Spring Boot 会尝试自动配置嵌入式数据库。<p>您通常不需要指定<code>driver-class-name</code>，因为 Spring Boot 可以从<code>url</code>推导大多数数据库。<p>对于要创建的池<code>DataSource</code>，我们需要能够验证一个有效的<code>Driver</code>类是否可用，因此我们在进行任何操作之前都要进行检查。换句话说，如果设置<code>spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code>，则该类必须是可加载的。</blockquote><p>有关更多受支持的选项，请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceProperties.java rel=noopener target=_blank>DataSourceProperties</a>。这些是与实际实现无关的标准选项。也可以使用它们各自的前缀(<code>spring.datasource.hikari.*</code>，<code>spring.datasource.tomcat.*</code>和<code>spring.datasource.dbcp2.*</code>)微调实现特定的设置。有关更多详细信息，请参考所用连接池实现的文档。<p>例如，如果您使用<a href=https://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html#Common_Attributes rel=noopener target=_blank>Tomcat 连接池</a>，则可以自定义许多其他设置，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_"># </span><span class=language-bash>Number of ms to <span class=built_in>wait</span> before throwing an exception <span class=keyword>if</span> no connection is available.</span></span><br><span class=line>spring.datasource.tomcat.max-wait=10000</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>Maximum number of active connections that can be allocated from this pool at the same time.</span></span><br><span class=line>spring.datasource.tomcat.max-active=50</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>Validate the connection before borrowing it from the pool.</span></span><br><span class=line>spring.datasource.tomcat.test-on-borrow=true</span><br></pre></table></figure><h4 id=3-8-1-3、><a class=headerlink href=#3-8-1-3、 title=3.8.1.3、></a>3.8.1.3、</h4><p>如果您将 Spring Boot 应用程序部署到 Application Server，则可能需要使用 Application Server 的内置功能来配置和 Management DataSource，并使用 JNDI 对其进行访问。<p><code>spring.datasource.jndi-name</code>属性可以替代<code>spring.datasource.url</code>，<code>spring.datasource.username</code>和<code>spring.datasource.password</code>属性，以从特定的 JNDI 位置访问<code>DataSource</code>。例如，<code>application.properties</code>中的以下部分显示了如何访问 JBoss AS 定义的<code>DataSource</code>：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.datasource.jndi-name</span>=<span class=string>java:jboss/datasources/customers</span></span><br></pre></table></figure><h3 id=3-8-2、使用JdbcTemplate><a class=headerlink href=#3-8-2、使用JdbcTemplate title=3.8.2、使用JdbcTemplate></a>3.8.2、使用JdbcTemplate</h3><p>Spring 的<code>JdbcTemplate</code>和<code>NamedParameterJdbcTemplate</code>类是自动配置的，您可以<code>@Autowire</code>直接将它们<code>@Autowire</code>放入自己的 bean 中，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> JdbcTemplate jdbcTemplate;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(JdbcTemplate jdbcTemplate)</span> {</span><br><span class=line>		<span class=built_in>this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>您可以使用<code>spring.jdbc.template.*</code>属性来自定义模板的某些属性，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.jdbc.template.max-rows=500</span><br></pre></table></figure><blockquote><p><code>NamedParameterJdbcTemplate</code>在后台重复使用相同的<code>JdbcTemplate</code>实例。如果定义了多个<code>JdbcTemplate</code>并且不存在主要候选对象，则不会自动配置<code>NamedParameterJdbcTemplate</code>。</blockquote><h3 id=3-8-3、JPA和Spring-Data-JPA><a title="3.8.3、JPA和Spring Data JPA" class=headerlink href=#3-8-3、JPA和Spring-Data-JPA></a>3.8.3、JPA和Spring Data JPA</h3><p>Java Persistence API 是一种标准技术，可让您将对象“Map”到关系数据库。 <code>spring-boot-starter-data-jpa</code> POM 提供了一种快速的 Starter 方法。它提供以下关键依赖性：<ul><li>Hibernate：最流行的 JPA 实现之一。<li>Spring Data JPA：使基于 JPA 的存储库的实现变得容易。<li>Spring ORM：Spring Framework 提供的核心 ORM 支持。</ul><h4 id=3-8-3-1、实体类><a class=headerlink href=#3-8-3-1、实体类 title=3.8.3.1、实体类></a>3.8.3.1、实体类</h4><p>传统上，JPA“实体”类是在<code>persistence.xml</code>文件中指定的。对于 Spring Boot，此文件不是必需的，而是使用“实体扫描”。默认情况下，将搜索主配置类(用<code>@EnableAutoConfiguration</code>或<code>@SpringBootApplication</code>Comments 的软件包)下的所有软件包。<p>任何带有<code>@Entity</code>，<code>@Embeddable</code>或<code>@MappedSuperclass</code>Comments 的类。典型的实体类类似于以下示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.example.myapp.domain;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.io.Serializable;</span><br><span class=line><span class=keyword>import</span> javax.persistence.*;</span><br><span class=line></span><br><span class=line><span class=meta>@Entity</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">City</span> <span class=keyword>implements</span> <span class="title class_">Serializable</span> {</span><br><span class=line>	<span class=meta>@Id</span></span><br><span class=line>	<span class=meta>@GeneratedValue</span></span><br><span class=line>	<span class=keyword>private</span> Long id;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Column(nullable = false)</span></span><br><span class=line>	<span class=keyword>private</span> String name;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Column(nullable = false)</span></span><br><span class=line>	<span class=keyword>private</span> String state;</span><br><span class=line></span><br><span class=line>	<span class=comment>// ... additional members, often include @OneToMany mappings</span></span><br><span class=line></span><br><span class=line>	<span class=keyword>protected</span> <span class="title function_">City</span><span class=params>()</span> {</span><br><span class=line>		<span class=comment>// no-args constructor required by JPA spec</span></span><br><span class=line>		<span class=comment>// this one is protected since it shouldn't be used directly</span></span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">City</span><span class=params>(String name, String state)</span> {</span><br><span class=line>		<span class=built_in>this</span>.name = name;</span><br><span class=line>		<span class=built_in>this</span>.state = state;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> String <span class="title function_">getName</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.name;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> String <span class="title function_">getState</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.state;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=comment>// ... etc</span></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>您可以使用<code>@EntityScan</code>Comments 来自定义实体扫描位置。</blockquote><h4 id=3-8-3-2、Spring-Data-JPA-存储库><a title="3.8.3.2、Spring Data JPA 存储库" class=headerlink href=#3-8-3-2、Spring-Data-JPA-存储库></a>3.8.3.2、Spring Data JPA 存储库</h4><p><a href=https://projects.spring.io/spring-data-jpa/ rel=noopener target=_blank>Spring Data JPA</a>存储库是您可以定义以访问数据的接口。 JPA 查询是根据您的方法名称自动创建的。例如，一个<code>CityRepository</code>接口可能声明<code>findAllByState(String state)</code>方法来查找给定 State 的所有城市。<p>对于更复杂的查询，您可以使用 Spring Data 的<a href=https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/Query.html rel=noopener target=_blank>Query</a>Comments 对方法进行 Comments。<p>Spring Data 存储库通常从<a href=https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/Repository.html rel=noopener target=_blank>Repository</a>或<a href=https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html rel=noopener target=_blank>CrudRepository</a>接口扩展。如果使用自动配置，则会从包含主配置类(用<code>@EnableAutoConfiguration</code>或<code>@SpringBootApplication</code>Comments 的主配置类)的包中搜索存储库。<p>以下示例显示了典型的 Spring Data 存储库接口定义：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.example.myapp.domain;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.data.domain.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.data.repository.*;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">CityRepository</span> <span class=keyword>extends</span> <span class="title class_">Repository</span>&LTCity, Long> {</span><br><span class=line>	Page&LTCity> <span class="title function_">findAll</span><span class=params>(Pageable pageable)</span>;</span><br><span class=line>	City <span class="title function_">findByNameAndStateAllIgnoringCase</span><span class=params>(String name, String state)</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>Spring Data JPA 存储库支持三种不同的引导模式：默认，延迟和延迟。要启用延迟引导或延迟引导，请将<code>spring.data.jpa.repositories.bootstrap-mode</code>分别设置为<code>deferred</code>或<code>lazy</code>。当使用延迟或延迟启动时，自动配置的<code>EntityManagerFactoryBuilder</code>将使用上下文的异步任务 Actuator(如果有)作为引导 Actuator。<h4 id=3-8-3-3、创建和删除JPA数据库><a class=headerlink href=#3-8-3-3、创建和删除JPA数据库 title=3.8.3.3、创建和删除JPA数据库></a>3.8.3.3、创建和删除JPA数据库</h4><p>默认情况下，如果您使用嵌入式数据库(H2，HSQL 或 Derby)，则仅“ **”自动创建 JPA 数据库。您可以使用<code>spring.jpa.*</code>属性来显式配置 JPA 设置。例如，要创建和删除表，可以将以下行添加到<code>application.properties</code>：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.jpa.hibernate.ddl-auto=create-drop</span><br></pre></table></figure><blockquote><p>Hibernate 自己的内部属性名称是<code>hibernate.hbm2ddl.auto</code>(如果您记得更好的话)。您可以使用<code>spring.jpa.properties.*</code>来设置它以及其他 Hibernate 本机属性(将前缀添加到实体 Management 器之前，前缀会被删除)。下面的行显示了为 Hibernate 设置 JPA 属性的示例：</blockquote><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.jpa.properties.hibernate.globally_quoted_identifiers</span>=<span class=string>true</span></span><br></pre></table></figure><p>前面示例中的行将<code>hibernate.globally_quoted_identifiers</code>属性的值<code>true</code>传递给 Hibernate 实体 Management 器。<p>默认情况下，DDL 执行(或验证)被推迟到<code>ApplicationContext</code>开始。还有一个<code>spring.jpa.generate-ddl</code>标志，但是如果 Hibernate 自动配置处于 Active 状态，则不使用它，因为<code>ddl-auto</code>设置更细粒度。<h4 id=3-8-3-4、在视图中打开EntityManager><a class=headerlink href=#3-8-3-4、在视图中打开EntityManager title=3.8.3.4、在视图中打开EntityManager></a>3.8.3.4、在视图中打开EntityManager</h4><p>如果您正在运行 Web 应用程序，则默认情况下，Spring Boot 注册<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/orm/jpa/support/OpenEntityManagerInViewInterceptor.html rel=noopener target=_blank>OpenEntityManagerInViewInterceptor</a>以应用“在视图中打开 EntityManager”模式，以允许在 Web 视图中进行延迟加载。如果您不希望出现这种情况，则应在<code>application.properties</code>中将<code>spring.jpa.open-in-view</code>设置为<code>false</code>。<h3 id=3-8-4、Spring-Data-JDBC><a title="3.8.4、Spring Data JDBC" class=headerlink href=#3-8-4、Spring-Data-JDBC></a>3.8.4、Spring Data JDBC</h3><p>Spring Data 包括对 JDBC 的存储库支持，并将自动为<code>CrudRepository</code>上的方法生成 SQL。对于更高级的查询，提供了<code>@Query</code>Comments。<p>当必要的依赖项位于 Classpath 上时，Spring Boot 将自动配置 Spring Data 的 JDBC 存储库。只需依赖<code>spring-boot-starter-data-jdbc</code>即可将它们添加到您的项目中。如有必要，您可以通过向应用程序中添加<code>@EnableJdbcRepositories</code>注解或<code>JdbcConfiguration</code>子类来控制 Spring Data JDBC 的配置。<h3 id=3-8-5、使用H2的Web控制台><a class=headerlink href=#3-8-5、使用H2的Web控制台 title=3.8.5、使用H2的Web控制台></a>3.8.5、使用H2的Web控制台</h3><p><a href=http://www.h2database.com/ rel=noopener target=_blank>H2 database</a>提供了<a href=http://www.h2database.com/html/quickstart.html#h2_console rel=noopener target=_blank>browser-based console</a>，Spring Boot 可以为您自动配置<a href=http://www.h2database.com/html/quickstart.html#jooq-in-7-steps-step3 rel=noopener target=_blank>browser-based console</a>。满足以下条件时，将自动配置控制台：<ul><li>您正在开发基于 servlet 的 Web 应用程序。<li><code>com.h2database:h2</code>在 Classpath 上。<li>您正在使用<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html rel=noopener target=_blank>Spring Boot 的开发人员工具</a>。</ul><blockquote><p>如果您不使用 Spring Boot 的开发人员工具，但仍想使用 H2 的控制台，则可以将<code>spring.h2.console.enabled</code>属性配置为<code>true</code>。<p>H2 控制台仅在开发期间使用，因此您应确保在 Producing 不要将<code>spring.h2.console.enabled</code>设置为<code>true</code>。</blockquote><h4 id=3-8-5-1-更改-H2-控制台的路径><a title="3.8.5.1 更改 H2 控制台的路径" class=headerlink href=#3-8-5-1-更改-H2-控制台的路径></a>3.8.5.1 更改 H2 控制台的路径</h4><p>默认情况下，控制台位于<code>/h2-console</code>。您可以使用<code>spring.h2.console.path</code>属性来自定义控制台的路径。<h3 id=3-8-6、使用jOOQ><a class=headerlink href=#3-8-6、使用jOOQ title=3.8.6、使用jOOQ></a>3.8.6、使用jOOQ</h3><p>面向 Java 对象的查询(<a href=http://www.jooq.org/ rel=noopener target=_blank>jOOQ</a>)是<a href=http://www.datageekery.com/ rel=noopener target=_blank>Data Geekery</a>的流行产品，它可以从数据库中生成 Java 代码，并允许您通过其流畅的 API 构建类型安全的 SQL 查询。商业版和开源版都可以与 Spring Boot 一起使用。<h4 id=3-8-6-1、代码生成><a class=headerlink href=#3-8-6-1、代码生成 title=3.8.6.1、代码生成></a>3.8.6.1、代码生成</h4><p>为了使用 jOOQ 类型安全查询，您需要从数据库架构中生成 Java 类。您可以按照<a href=https://www.jooq.org/doc/3.11.7/manual-single-page/#+5+ rel=noopener target=_blank>jOOQ 用户手册</a>中的说明进行操作。如果您使用<code>jooq-codegen-maven</code>插件，并且还使用<code>spring-boot-starter-parent</code>“父 POM”，则可以安全地忽略该插件的<code>&LTversion></code>标签。您还可以使用 Spring Boot 定义的版本变量(例如<code>h2.version</code>)来声明插件的数据库依赖关系。以下 Lists 显示了一个示例：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>plugin</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>org.jooq<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>jooq-codegen-maven<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>executions</span>></span></span><br><span class=line>		...</span><br><span class=line>	<span class=tag>&LT/<span class=name>executions</span>></span></span><br><span class=line>	<span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>		<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>			<span class=tag><<span class=name>groupId</span>></span>com.h2database<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>artifactId</span>></span>h2<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>version</span>></span>${h2.version}<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>dependencies</span>></span></span><br><span class=line>	<span class=tag><<span class=name>configuration</span>></span></span><br><span class=line>		<span class=tag><<span class=name>jdbc</span>></span></span><br><span class=line>			<span class=tag><<span class=name>driver</span>></span>org.h2.Driver<span class=tag>&LT/<span class=name>driver</span>></span></span><br><span class=line>			<span class=tag><<span class=name>url</span>></span>jdbc:h2:~/yourdatabase<span class=tag>&LT/<span class=name>url</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>jdbc</span>></span></span><br><span class=line>		<span class=tag><<span class=name>generator</span>></span></span><br><span class=line>			...</span><br><span class=line>		<span class=tag>&LT/<span class=name>generator</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>configuration</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>plugin</span>></span></span><br></pre></table></figure><h4 id=3-8-6-2、使用DSLContext><a class=headerlink href=#3-8-6-2、使用DSLContext title=3.8.6.2、使用DSLContext></a>3.8.6.2、使用DSLContext</h4><p>jOOQ 提供的流畅的 API 是通过<code>org.jooq.DSLContext</code>接口启动的。 Spring Boot 将<code>DSLContext</code>自动配置为 Spring Bean，并将其连接到应用程序<code>DataSource</code>。要使用<code>DSLContext</code>，您可以<code>@Autowire</code>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">JooqExample</span> <span class=keyword>implements</span> <span class="title class_">CommandLineRunner</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> DSLContext create;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">JooqExample</span><span class=params>(DSLContext dslContext)</span> {</span><br><span class=line>		<span class=built_in>this</span>.create = dslContext;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>jOOQ 手册倾向于使用名为<code>create</code>的变量来保存<code>DSLContext</code>。</blockquote><p>然后，您可以使用<code>DSLContext</code>构造查询，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> List&LTGregorianCalendar> <span class="title function_">authorsBornAfter1980</span><span class=params>()</span> {</span><br><span class=line>	<span class=keyword>return</span> <span class=built_in>this</span>.create.selectFrom(AUTHOR)</span><br><span class=line>		.where(AUTHOR.DATE_OF_BIRTH.greaterThan(<span class=keyword>new</span> <span class="title class_">GregorianCalendar</span>(<span class=number>1980</span>, <span class=number>0</span>, <span class=number>1</span>)))</span><br><span class=line>		.fetch(AUTHOR.DATE_OF_BIRTH);</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-8-6-3、jOOQ-SQL-方言><a title="3.8.6.3、jOOQ SQL 方言" class=headerlink href=#3-8-6-3、jOOQ-SQL-方言></a>3.8.6.3、jOOQ SQL 方言</h4><p>除非已配置<code>spring.jooq.sql-dialect</code>属性，否则 Spring Boot 会确定要用于数据源的 SQL 方言。如果 Spring Boot 无法检测到方言，则使用<code>DEFAULT</code>。<blockquote><p>Spring Boot 只能自动配置开源版本的 jOOQ 支持的方言。</blockquote><h4 id=3-8-6-4、自定义jOOQ><a class=headerlink href=#3-8-6-4、自定义jOOQ title=3.8.6.4、自定义jOOQ></a>3.8.6.4、自定义jOOQ</h4><p>通过定义自己的<code>@Bean</code>定义(可以在创建 jOOQ <code>Configuration</code>时使用)可以实现更高级的自定义。您可以为以下 jOOQ 类型定义 bean：<ul><li><code>ConnectionProvider</code><li><code>ExecutorProvider</code><li><code>TransactionProvider</code><li><code>RecordMapperProvider</code><li><code>RecordUnmapperProvider</code><li><code>RecordListenerProvider</code><li><code>ExecuteListenerProvider</code><li><code>VisitListenerProvider</code><li><code>TransactionListenerProvider</code></ul><p>如果要完全控制 jOOQ 配置，也可以创建自己的<code>org.jooq.Configuration</code> <code>@Bean</code>。<h2 id=3-9、使用NoSQL技术><a class=headerlink href=#3-9、使用NoSQL技术 title=3.9、使用NoSQL技术></a>3.9、使用NoSQL技术</h2><p>Spring Data 提供了其他项目，可帮助您访问各种 NoSQL 技术，包括：<a href=https://projects.spring.io/spring-data-mongodb/ rel=noopener target=_blank>MongoDB</a>，<a href=https://projects.spring.io/spring-data-neo4j/ rel=noopener target=_blank>Neo4J</a>，<a href=https://github.com/spring-projects/spring-data-elasticsearch/ rel=noopener target=_blank>Elasticsearch</a>，<a href=https://projects.spring.io/spring-data-solr/ rel=noopener target=_blank>Solr</a>，<a href=https://projects.spring.io/spring-data-redis/ rel=noopener target=_blank>Redis</a>，<a href=https://projects.spring.io/spring-data-gemfire/ rel=noopener target=_blank>Gemfire</a>，<a href=https://projects.spring.io/spring-data-cassandra/ rel=noopener target=_blank>Cassandra</a>，<a href=https://projects.spring.io/spring-data-couchbase/ rel=noopener target=_blank>Couchbase</a>和<a href=https://projects.spring.io/spring-data-ldap/ rel=noopener target=_blank>LDAP</a>。 Spring Boot 为 Redis，MongoDB，Neo4j，Elasticsearch，Solr Cassandra，Couchbase 和 LDAP 提供自动配置。您可以使用其他项目，但是必须自己配置它们。请参考<a href=https://projects.spring.io/spring-data rel=noopener target=_blank>projects.spring.io/spring-data</a>的相应参考文档。<h3 id=3-9-1、Redis><a class=headerlink href=#3-9-1、Redis title=3.9.1、Redis></a>3.9.1、Redis</h3><p><a href=http://redis.io/ rel=noopener target=_blank>Redis</a>是缓存，消息代理和功能丰富的键值存储。 Spring Boot 为<a href=https://github.com/lettuce-io/lettuce-core/ rel=noopener target=_blank>Lettuce</a>和<a href=https://github.com/xetorthio/jedis/ rel=noopener target=_blank>Jedis</a>Client 端库提供了基本的自动配置，以及<a href=https://github.com/spring-projects/spring-data-redis rel=noopener target=_blank>Spring Data Redis</a>提供的对它们的抽象。<p>有一个<code>spring-boot-starter-data-redis</code>“启动程序”，以方便的方式收集依赖项。默认情况下，它使用<a href=https://github.com/lettuce-io/lettuce-core/ rel=noopener target=_blank>Lettuce</a>。该启动程序可以处理传统应用程序和响应式应用程序。<blockquote><p>我们还提供<code>spring-boot-starter-data-redis-reactive</code>“Starter”，以与其他具有 Reactive 支持的 Store 保持一致。</blockquote><h4 id=3-9-1-1、连接到Redis><a class=headerlink href=#3-9-1-1、连接到Redis title=3.9.1.1、连接到Redis></a>3.9.1.1、连接到Redis</h4><p>您可以像注入其他任何 Spring Bean 一样注入自动配置的<code>RedisConnectionFactory</code>，<code>StringRedisTemplate</code>或香草<code>RedisTemplate</code>实例。默认情况下，该实例尝试连接到<code>localhost:6379</code>的 Redis 服务器。下面的 Lists 显示了这种 Bean 的示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> StringRedisTemplate template;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(StringRedisTemplate template)</span> {</span><br><span class=line>		<span class=built_in>this</span>.template = template;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>您还可以注册任意数量的实现<code>LettuceClientConfigurationBuilderCustomizer</code>的 bean，以进行更高级的自定义。如果您使用 Jedis，则<code>JedisClientConfigurationBuilderCustomizer</code>也可用。</blockquote><p>如果添加自己的任何自动配置类型的<code>@Bean</code>，它将替换默认值(除非<code>RedisTemplate</code>，但排除基于 Bean 名称<code>redisTemplate</code>而不是其类型，则除外)。默认情况下，如果<code>commons-pool2</code>在 Classpath 上，则将得到一个池化连接工厂。<h3 id=3-9-2、MongoDB><a class=headerlink href=#3-9-2、MongoDB title=3.9.2、MongoDB></a>3.9.2、MongoDB</h3><p><a href=https://www.mongodb.com/ rel=noopener target=_blank>MongoDB</a>是一个开源 NoSQL 文档数据库，它使用类似 JSON 的架构而不是传统的基于表的关系数据。 Spring Boot 为使用 MongoDB 提供了许多便利，包括<code>spring-boot-starter-data-mongodb</code>和<code>spring-boot-starter-data-mongodb-reactive</code>“启动器”。<h4 id=3-9-2-1、连接到-MongoDB-数据库><a title="3.9.2.1、连接到 MongoDB 数据库" class=headerlink href=#3-9-2-1、连接到-MongoDB-数据库></a>3.9.2.1、连接到 MongoDB 数据库</h4><p>要访问 Mongo 数据库，您可以注入自动配置的<code>org.springframework.data.mongodb.MongoDbFactory</code>。默认情况下，该实例尝试连接到<code>mongodb://localhost/test</code>的 MongoDB 服务器。以下示例显示如何连接到 MongoDB 数据库：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.data.mongodb.MongoDbFactory;</span><br><span class=line><span class=keyword>import</span> com.mongodb.DB;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line></span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> MongoDbFactory mongo;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(MongoDbFactory mongo)</span> {</span><br><span class=line>		<span class=built_in>this</span>.mongo = mongo;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">example</span><span class=params>()</span> {</span><br><span class=line>		<span class=type>DB</span> <span class=variable>db</span> <span class=operator>=</span> mongo.getDb();</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>您可以设置<code>spring.data.mongodb.uri</code>属性来更改 URL 并配置其他设置，例如* replica set *，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.data.mongodb.uri</span>=<span class=string>mongodb://user:[emailprotected]:12345,mongo2.example.com:23456/test</span></span><br></pre></table></figure><p>另外，只要您使用 Mongo 2.x，就可以指定<code>host</code>/<code>port</code>。例如，您可以在<code>application.properties</code>中声明以下设置：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.data.mongodb.host</span>=<span class=string>mongoserver</span></span><br><span class=line><span class=attr>spring.data.mongodb.port</span>=<span class=string>27017</span></span><br></pre></table></figure><p>如果您定义了自己的<code>MongoClient</code>，它将用于自动配置合适的<code>MongoDbFactory</code>。 <code>com.mongodb.MongoClient</code>和<code>com.mongodb.client.MongoClient</code>均受支持。<blockquote><p>如果使用 Mongo 3.0 Java 驱动程序，则不支持<code>spring.data.mongodb.host</code>和<code>spring.data.mongodb.port</code>。在这种情况下，应使用<code>spring.data.mongodb.uri</code>提供所有配置。<p>如果未指定<code>spring.data.mongodb.port</code>，则使用默认值<code>27017</code>。您可以从前面显示的示例中删除此行。<p>如果您不使用 Spring Data Mongo，则可以注入<code>com.mongodb.MongoClient</code> bean 而不是<code>MongoDbFactory</code>。如果要完全控制构建 MongoDB 连接的方式，则还可以声明自己的<code>MongoDbFactory</code>或<code>MongoClient</code> bean。<p>如果使用 Reactive 驱动程序，则 SSL 需要 Netty。如果 Netty 可用并且尚未自定义要使用的工厂，则自动配置会自动配置该工厂。</blockquote><h4 id=3-9-2-2、MongoTemplate><a class=headerlink href=#3-9-2-2、MongoTemplate title=3.9.2.2、MongoTemplate></a>3.9.2.2、MongoTemplate</h4><p><a href=https://projects.spring.io/spring-data-mongodb/ rel=noopener target=_blank>Spring Data MongoDB</a>提供的<a href=https://docs.spring.io/spring-data/mongodb/docs/current/api/org/springframework/data/mongodb/core/MongoTemplate.html rel=noopener target=_blank>MongoTemplate</a>类的设计与 Spring 的<code>JdbcTemplate</code>非常相似。与<code>JdbcTemplate</code>一样，Spring Boot 为您自动配置一个 Bean 来注入模板，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.data.mongodb.core.MongoTemplate;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> MongoTemplate mongoTemplate;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(MongoTemplate mongoTemplate)</span> {</span><br><span class=line>		<span class=built_in>this</span>.mongoTemplate = mongoTemplate;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>有关完整的详细信息，请参见<a href=https://docs.spring.io/spring-data/mongodb/docs/current/api/org/springframework/data/mongodb/core/MongoOperations.html rel=noopener target=_blank>MongoOperations Javadoc</a>。<h4 id=3-9-2-3、Spring-Data-MongoDB-存储库><a title="3.9.2.3、Spring Data MongoDB 存储库" class=headerlink href=#3-9-2-3、Spring-Data-MongoDB-存储库></a>3.9.2.3、Spring Data MongoDB 存储库</h4><p>Spring Data 包括对 MongoDB 的存储库支持。与前面讨论的 JPA 存储库一样，基本原理是根据方法名称自动构造查询。<p>实际上，Spring Data JPA 和 Spring Data MongoDB 共享相同的通用基础架构。您可以从前面的 JPA 示例开始，并假设<code>City</code>现在是 Mongo 数据类而不是 JPA <code>@Entity</code>，它的工作方式相同，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.example.myapp.domain;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.data.domain.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.data.repository.*;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">CityRepository</span> <span class=keyword>extends</span> <span class="title class_">Repository</span>&LTCity, Long> {</span><br><span class=line>	Page&LTCity> <span class="title function_">findAll</span><span class=params>(Pageable pageable)</span>;</span><br><span class=line>	City <span class="title function_">findByNameAndStateAllIgnoringCase</span><span class=params>(String name, String state)</span>;</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>您可以使用<code>@EntityScan</code>Comments 来自定义文档扫描位置。</blockquote><h4 id=3-9-2-4、嵌入式Mongo><a class=headerlink href=#3-9-2-4、嵌入式Mongo title=3.9.2.4、嵌入式Mongo></a>3.9.2.4、嵌入式Mongo</h4><p>Spring Boot 为<a href=https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo rel=noopener target=_blank>Embedded Mongo</a>提供自动配置。要在您的 Spring Boot 应用程序中使用它，请在<code>de.flapdoodle.embed:de.flapdoodle.embed.mongo</code>上添加一个依赖项。<p>可以通过设置<code>spring.data.mongodb.port</code>属性来配置 Mongo 侦听的端口。要使用随机分配的空闲端口，请使用 0 值。由<code>MongoAutoConfiguration</code>创建的<code>MongoClient</code>自动配置为使用随机分配的端口。<blockquote><p>如果未配置自定义端口，则默认情况下，嵌入式支持使用随机端口(而不是 27017)。</blockquote><p>如果 Classpath 上有 SLF4J，则 Mongo 产生的输出将自动路由到名为<code>org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongo</code>的 Logger。<p>您可以声明自己的<code>IMongodConfig</code>和<code>IRuntimeConfig</code> bean 来控制 Mongo 实例的配置和日志记录路由。<h3 id=3-9-3、Neo4j><a class=headerlink href=#3-9-3、Neo4j title=3.9.3、Neo4j></a>3.9.3、Neo4j</h3><p><a href=http://neo4j.com/ rel=noopener target=_blank>Neo4j</a>是一个开源 NoSQL 图形数据库，它使用通过一级关系连接的节点的丰富数据模型，比传统的 RDBMS 方法更适合于连接的大数据。 Spring Boot 为 Neo4j 的使用提供了许多便利，包括<code>spring-boot-starter-data-neo4j</code>“ Starter”。<h4 id=3-9-3-1、连接到-Neo4j-数据库><a title="3.9.3.1、连接到 Neo4j 数据库" class=headerlink href=#3-9-3-1、连接到-Neo4j-数据库></a>3.9.3.1、连接到 Neo4j 数据库</h4><p>要访问 Neo4j 服务器，您可以注入自动配置的<code>org.neo4j.ogm.session.Session</code>。默认情况下，该实例尝试使用 Bolt 协议连接到<code>localhost:7687</code>处的 Neo4j 服务器。以下示例显示如何注入 Neo4j <code>Session</code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> Session session;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(Session session)</span> {</span><br><span class=line>		<span class=built_in>this</span>.session = session;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>您可以通过设置<code>spring.data.neo4j.*</code>属性来配置要使用的 uri 和凭据，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.data.neo4j.uri</span>=<span class=string>bolt://my-server:7687</span></span><br><span class=line><span class=attr>spring.data.neo4j.username</span>=<span class=string>neo4j</span></span><br><span class=line><span class=attr>spring.data.neo4j.password</span>=<span class=string>secret</span></span><br></pre></table></figure><p>您可以通过添加<code>org.neo4j.ogm.config.Configuration</code> <code>@Bean</code>来完全控制会话的创建。另外，添加类型为<code>SessionFactory</code>的<code>@Bean</code>会禁用自动配置，并提供完全控制权。<h4 id=3-9-3-2、使用嵌入式模式><a class=headerlink href=#3-9-3-2、使用嵌入式模式 title=3.9.3.2、使用嵌入式模式></a>3.9.3.2、使用嵌入式模式</h4><p>如果您将<code>org.neo4j:neo4j-ogm-embedded-driver</code>添加到应用程序的依赖项中，则 Spring Boot 将自动配置 Neo4j 的进程内嵌入式实例，该实例在应用程序关闭时不会保留任何数据。<blockquote><p>由于嵌入式 Neo4j OGM 驱动程序本身不提供 Neo4j 内核，因此您必须自己声明<code>org.neo4j:neo4j</code>作为依赖项。有关兼容版本的列表，请参考<a href=https://neo4j.com/docs/ogm-manual/current/reference/#reference:getting-started rel=noopener target=_blank>Neo4j OGM 文档</a>。</blockquote><p>当 Classpath 上有多个驱动程序时，嵌入式驱动程序优先于其他驱动程序。您可以通过设置<code>spring.data.neo4j.embedded.enabled=false</code>显式禁用嵌入式模式。<p>如上所述，如果嵌入式驱动程序和 Neo4j 内核位于 Classpath 中，则<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-neo4j-test rel=noopener target=_blank>数据 Neo4j 测试</a>自动使用嵌入式 Neo4j 实例。<blockquote><p>您可以通过在配置中提供数据库文件的路径来启用嵌入式模式的持久性。 <code>spring.data.neo4j.uri=file://var/tmp/graph.db</code>。</blockquote><h4 id=3-9-3-3、Neo4jSession><a class=headerlink href=#3-9-3-3、Neo4jSession title=3.9.3.3、Neo4jSession></a>3.9.3.3、Neo4jSession</h4><p>默认情况下，如果您正在运行 Web 应用程序，则会话将绑定到线程以进行请求的整个处理(即，它使用“在视图中打开会话”模式)。如果您不希望出现这种情况，请将以下行添加到您的<code>application.properties</code>文件中：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.data.neo4j.open-in-view</span>=<span class=string>false</span></span><br></pre></table></figure><h4 id=3-9-3-4、Spring-Data-Neo4j-存储库><a title="3.9.3.4、Spring Data Neo4j 存储库" class=headerlink href=#3-9-3-4、Spring-Data-Neo4j-存储库></a>3.9.3.4、Spring Data Neo4j 存储库</h4><p>Spring Data 包括对 Neo4j 的存储库支持。<p>Spring Data Neo4j 与许多其他 Spring Data 模块一样，与 Spring Data JPA 共享公共基础结构。您可以使用前面的 JPA 示例，并将<code>City</code>定义为 Neo4j OGM <code>@NodeEntity</code>而不是 JPA <code>@Entity</code>，并且存储库抽象以相同的方式工作，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.example.myapp.domain;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.util.Optional;</span><br><span class=line><span class=keyword>import</span> org.springframework.data.neo4j.repository.*;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">CityRepository</span> <span class=keyword>extends</span> <span class="title class_">Neo4jRepository</span>&LTCity, Long> {</span><br><span class=line>	Optional&LTCity> <span class="title function_">findOneByNameAndState</span><span class=params>(String name, String state)</span>;</span><br><span class=line>}</span><br></pre></table></figure><p><code>spring-boot-starter-data-neo4j</code>“启动器”启用存储库支持以及事务 Management。您可以通过分别在<code>@Configuration</code> -bean 上使用<code>@EnableNeo4jRepositories</code>和<code>@EntityScan</code>来定制位置以查找存储库和实体。<h3 id=3-9-4、Gemfire><a class=headerlink href=#3-9-4、Gemfire title=3.9.4、Gemfire></a>3.9.4、Gemfire</h3><p><a href=https://github.com/spring-projects/spring-data-gemfire rel=noopener target=_blank>Spring Data Gemfire</a>提供了方便使用 Spring 的便捷工具，用于访问<a href=https://pivotal.io/big-data/pivotal-gemfire#details rel=noopener target=_blank>Pivotal Gemfire</a>数据 Management 平台。有一个<code>spring-boot-starter-data-gemfire</code>“启动器”，用于以方便的方式收集依赖项。 Gemfire 当前没有自动配置支持，但是您可以使用<a href=https://github.com/spring-projects/spring-data-gemfire/blob/master/src/main/java/org/springframework/data/gemfire/repository/config/EnableGemfireRepositories.java rel=noopener target=_blank>单个 Comments：@EnableGemfireRepositories</a>启用 Spring Data Repositories。<h3 id=3-9-5、Solr><a class=headerlink href=#3-9-5、Solr title=3.9.5、Solr></a>3.9.5、Solr</h3><p><a href=https://lucene.apache.org/solr/ rel=noopener target=_blank>Apache Solr</a>是搜索引擎。 Spring Boot 为 Solr 5 Client 端库提供了基本的自动配置，并由<a href=https://github.com/spring-projects/spring-data-solr rel=noopener target=_blank>Spring Data Solr</a>提供了对它的抽象。有一个<code>spring-boot-starter-data-solr</code>“启动程序”，用于以方便的方式收集依赖项。<h4 id=3-9-5-1、连接到-Solr><a title="3.9.5.1、连接到 Solr" class=headerlink href=#3-9-5-1、连接到-Solr></a>3.9.5.1、连接到 Solr</h4><p>您可以像注入其他任何 Spring bean 一样注入自动配置的<code>SolrClient</code>实例。默认情况下，该实例尝试连接到<code>localhost:8983/solr</code>处的服务器。下面的示例显示如何注入 Solr bean：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> SolrClient solr;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(SolrClient solr)</span> {</span><br><span class=line>		<span class=built_in>this</span>.solr = solr;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>如果添加自己的<code>SolrClient</code>类型的<code>@Bean</code>，它将替换默认值。<h4 id=3-9-5-2、Spring-Data-Solr-存储库><a title="3.9.5.2、Spring Data Solr 存储库" class=headerlink href=#3-9-5-2、Spring-Data-Solr-存储库></a>3.9.5.2、Spring Data Solr 存储库</h4><p>Spring Data 包括对 Apache Solr 的存储库支持。与前面讨论的 JPA 存储库一样，基本原理是根据方法名称自动为\构造查询。<p>实际上，Spring Data JPA 和 Spring Data Solr 共享相同的通用基础结构。您可以从以前的 JPA 示例开始，并假设<code>City</code>现在是<code>@SolrDocument</code>类而不是 JPA <code>@Entity</code>，它的工作方式相同。<h3 id=3-9-6、Elasticsearch><a class=headerlink href=#3-9-6、Elasticsearch title=3.9.6、Elasticsearch></a>3.9.6、Elasticsearch</h3><p><a href=https://www.elastic.co/products/elasticsearch rel=noopener target=_blank>Elasticsearch</a>是开源，分布式，RESTful 搜索和分析引擎。 Spring Boot 为 Elasticsearch 提供了基本的自动配置。<p>Spring Boot 支持多个 HTTP Client 端：<ul><li>官方 Java“低级”和“高级” REST Client 端<li><a href=https://github.com/searchbox-io/Jest rel=noopener target=_blank>Jest</a></ul><p><a href=https://github.com/spring-projects/spring-data-elasticsearch rel=noopener target=_blank>Spring Data Elasticsearch</a>仍在使用传输 Client 端，您可以从<code>spring-boot-starter-data-elasticsearch</code>“ Starter”开始使用。<h4 id=3-9-6-1、通过-REST-Client-端连接到-Elasticsearch><a title="3.9.6.1、通过 REST Client 端连接到 Elasticsearch" class=headerlink href=#3-9-6-1、通过-REST-Client-端连接到-Elasticsearch></a>3.9.6.1、通过 REST Client 端连接到 Elasticsearch</h4><p>Elasticsearch 附带了<a href=https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html rel=noopener target=_blank>两个不同的 REST Client 端</a>，可用于查询集群：“低级”Client 端和“高级”Client 端。<p>如果您对 Classpath 具有<code>org.elasticsearch.client:elasticsearch-rest-client</code>依赖关系，Spring Boot 将自动配置并注册一个<code>RestClient</code> bean，默认情况下它针对<code>localhost:9200</code>。您可以进一步调整<code>RestClient</code>的配置方式，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.elasticsearch.rest.uris</span>=<span class=string>http://search.example.com:9200</span></span><br><span class=line><span class=attr>spring.elasticsearch.rest.username</span>=<span class=string>user</span></span><br><span class=line><span class=attr>spring.elasticsearch.rest.password</span>=<span class=string>secret</span></span><br></pre></table></figure><p>您还可以注册任意数量的实现<code>RestClientBuilderCustomizer</code>的 bean，以进行更高级的自定义。要完全控制注册，请定义一个<code>RestClient</code> bean。<p>如果您对 Classpath 具有<code>org.elasticsearch.client:elasticsearch-rest-high-level-client</code>依赖性，则 Spring Boot 将自动配置<code>RestHighLevelClient</code>，该_包装任何现有的<code>RestClient</code> bean，并重新使用其 HTTP 配置。<h4 id=3-9-6-2、使用-Jest-连接到-Elasticsearch><a title="3.9.6.2、使用 Jest 连接到 Elasticsearch" class=headerlink href=#3-9-6-2、使用-Jest-连接到-Elasticsearch></a>3.9.6.2、使用 Jest 连接到 Elasticsearch</h4><p>如果您在 Classpath 上有<code>Jest</code>，则可以注入自动配置的<code>JestClient</code>，默认情况下以<code>localhost:9200</code>为目标。您可以进一步调整 Client 端的配置方式，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.elasticsearch.jest.uris</span>=<span class=string>http://search.example.com:9200</span></span><br><span class=line><span class=attr>spring.elasticsearch.jest.read-timeout</span>=<span class=string>10000</span></span><br><span class=line><span class=attr>spring.elasticsearch.jest.username</span>=<span class=string>user</span></span><br><span class=line><span class=attr>spring.elasticsearch.jest.password</span>=<span class=string>secret</span></span><br></pre></table></figure><p>您还可以注册任意数量的实现<code>HttpClientConfigBuilderCustomizer</code>的 bean，以进行更高级的自定义。以下示例调整其他 HTTP 设置：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">HttpSettingsCustomizer</span> <span class=keyword>implements</span> <span class="title class_">HttpClientConfigBuilderCustomizer</span> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">customize</span><span class=params>(HttpClientConfig.Builder builder)</span> {</span><br><span class=line>	builder.maxTotalConnection(<span class=number>100</span>).defaultMaxTotalConnectionPerRoute(<span class=number>5</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>要完全控制注册，请定义一个<code>JestClient</code> bean。<h4 id=3-9-6-3、使用-Spring-数据连接到-Elasticsearch><a title="3.9.6.3、使用 Spring 数据连接到 Elasticsearch" class=headerlink href=#3-9-6-3、使用-Spring-数据连接到-Elasticsearch></a>3.9.6.3、使用 Spring 数据连接到 Elasticsearch</h4><p>要连接到 Elasticsearch，您必须提供一个或多个集群节点的地址。可以通过将<code>spring.data.elasticsearch.cluster-nodes</code>属性设置为逗号分隔的<code>host:port</code>列表来指定地址。有了此配置后，就可以像其他任何 Spring bean 一样注入<code>ElasticsearchTemplate</code>或<code>TransportClient</code>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>spring.data.elasticsearch.cluster-nodes=localhost:<span class=number>9300</span></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> ElasticsearchTemplate template;</span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(ElasticsearchTemplate template)</span> {</span><br><span class=line>		<span class=built_in>this</span>.template = template;</span><br><span class=line>	}</span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>如果添加自己的<code>ElasticsearchTemplate</code>或<code>TransportClient</code> <code>@Bean</code>，它将替换默认值。<h4 id=3-9-6-4、Spring-Data-Elasticsearch-存储库><a title="3.9.6.4、Spring Data Elasticsearch 存储库" class=headerlink href=#3-9-6-4、Spring-Data-Elasticsearch-存储库></a>3.9.6.4、Spring Data Elasticsearch 存储库</h4><p>Spring Data 包括对 Elasticsearch 的存储库支持。与前面讨论的 JPA 存储库一样，基本原理是根据方法名称自动为您构造查询。<p>实际上，Spring Data JPA 和 Spring Data Elasticsearch 共享相同的通用基础架构。您可以从前面的 JPA 示例开始，并假设<code>City</code>现在是 Elasticsearch <code>@Document</code>类而不是 JPA <code>@Entity</code>，它的工作方式相同。<h3 id=3-9-7、Cassandra><a class=headerlink href=#3-9-7、Cassandra title=3.9.7、Cassandra></a>3.9.7、Cassandra</h3><p><a href=https://cassandra.apache.org/ rel=noopener target=_blank>Cassandra</a>是一个开放源代码的分布式数据库 Management 系统，旨在处理许多商品服务器上的大量数据。 Spring Boot 为 Cassandra 提供自动配置，并由<a href=https://github.com/spring-projects/spring-data-cassandra rel=noopener target=_blank>Spring Data Cassandra</a>提供最高级的抽象。有一个<code>spring-boot-starter-data-cassandra</code>“启动程序”，用于以方便的方式收集依赖项。<h4 id=3-9-7-1、连接到-Cassandra><a title="3.9.7.1、连接到 Cassandra" class=headerlink href=#3-9-7-1、连接到-Cassandra></a>3.9.7.1、连接到 Cassandra</h4><p>您可以像使用其他任何 Spring Bean 一样注入自动配置的<code>CassandraTemplate</code>或 Cassandra <code>Session</code>实例。 <code>spring.data.cassandra.*</code>属性可用于自定义连接。通常，您提供<code>keyspace-name</code>和<code>contact-points</code>属性，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.data.cassandra.keyspace-name</span>=<span class=string>mykeyspace</span></span><br><span class=line><span class=attr>spring.data.cassandra.contact-points</span>=<span class=string>cassandrahost1,cassandrahost2</span></span><br></pre></table></figure><p>您还可以注册任意数量的实现<code>ClusterBuilderCustomizer</code>的 bean，以进行更高级的自定义。<p>以下代码 Lists 显示了如何注入 Cassandra bean：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> CassandraTemplate template;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(CassandraTemplate template)</span> {</span><br><span class=line>		<span class=built_in>this</span>.template = template;</span><br><span class=line>	}</span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>如果添加自己的<code>CassandraTemplate</code>类型的<code>@Bean</code>，它将替换默认值。<h4 id=3-9-7-2、Spring-Data-Cassandra-存储库><a title="3.9.7.2、Spring Data Cassandra 存储库" class=headerlink href=#3-9-7-2、Spring-Data-Cassandra-存储库></a>3.9.7.2、Spring Data Cassandra 存储库</h4><p>Spring Data 包括对 Cassandra 的基本存储库支持。当前，这比前面讨论的 JPA 存储库受到更多限制，并且需要使用<code>@Query</code>Comments finder 方法。<h3 id=3-9-8、Couchbase><a class=headerlink href=#3-9-8、Couchbase title=3.9.8、Couchbase></a>3.9.8、Couchbase</h3><p><a href=https://www.couchbase.com/ rel=noopener target=_blank>Couchbase</a>是开放源代码，分布式，多模型的 NoSQL 面向文档的数据库，已针对交互式应用程序进行了优化。 Spring Boot 为 Couchbase 提供自动配置，并由<a href=https://github.com/spring-projects/spring-data-couchbase rel=noopener target=_blank>Spring Data Couchbase</a>提供最高级的抽象。有<code>spring-boot-starter-data-couchbase</code>和<code>spring-boot-starter-data-couchbase-reactive</code>个“启动程序”，以方便的方式收集依赖项。<h4 id=3-9-8-1、连接到-Couchbase><a title="3.9.8.1、连接到 Couchbase" class=headerlink href=#3-9-8-1、连接到-Couchbase></a>3.9.8.1、连接到 Couchbase</h4><p>您可以通过添加 Couchbase SDK 和一些配置来获得<code>Bucket</code>和<code>Cluster</code>。 <code>spring.couchbase.*</code>属性可用于自定义连接。通常，您提供引导主机，存储桶名称和密码，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.couchbase.bootstrap-hosts</span>=<span class=string>my-host-1,192.168.1.123</span></span><br><span class=line><span class=attr>spring.couchbase.bucket.name</span>=<span class=string>my-bucket</span></span><br><span class=line><span class=attr>spring.couchbase.bucket.password</span>=<span class=string>secret</span></span><br></pre></table></figure><blockquote><p>您至少需要提供*引导主机，在这种情况下，存储区名称为<code>default</code>，密码为空字符串。另外，您可以定义自己的<code>org.springframework.data.couchbase.config.CouchbaseConfigurer</code> <code>@Bean</code>来控制整个配置。</blockquote><p>还可以自定义某些<code>CouchbaseEnvironment</code>设置。例如，以下配置更改了用于打开新的<code>Bucket</code>的超时并启用了 SSL 支持：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.couchbase.env.timeouts.connect</span>=<span class=string>3000</span></span><br><span class=line><span class=attr>spring.couchbase.env.ssl.key-store</span>=<span class=string>/location/of/keystore.jks</span></span><br><span class=line><span class=attr>spring.couchbase.env.ssl.key-store-password</span>=<span class=string>secret</span></span><br></pre></table></figure><p>查看<code>spring.couchbase.env.*</code>属性以获取更多详细信息。<h4 id=3-9-8-2、Spring-Data-Couchbase-存储库><a title="3.9.8.2、Spring Data Couchbase 存储库" class=headerlink href=#3-9-8-2、Spring-Data-Couchbase-存储库></a>3.9.8.2、Spring Data Couchbase 存储库</h4><p>Spring Data 包括对 Couchbase 的存储库支持。有关 Spring Data Couchbase 的完整详细信息，请参阅<a href=https://docs.spring.io/spring-data/couchbase/docs/current/reference/html/ rel=noopener target=_blank>reference documentation</a>。<p>您可以像使用任何其他 Spring Bean 一样注入自动配置的<code>CouchbaseTemplate</code>实例，前提是* default * <code>CouchbaseConfigurer</code>可用(如前所述，启用 Couchbase 支持时会发生这种情况)。<p>以下示例显示了如何注入 Couchbase bean：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> CouchbaseTemplate template;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(CouchbaseTemplate template)</span> {</span><br><span class=line>		<span class=built_in>this</span>.template = template;</span><br><span class=line>	}</span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>您可以在自己的配置中定义一些 Bean，以覆盖自动配置提供的那些：<ul><li>名称为<code>couchbaseTemplate</code>的<code>CouchbaseTemplate</code> <code>@Bean</code>。<li>名为<code>couchbaseIndexManager</code>的<code>IndexManager</code> <code>@Bean</code>。<li>名称为<code>couchbaseCustomConversions</code>的<code>CustomConversions</code> <code>@Bean</code>。</ul><p>为了避免在您自己的配置中对这些名称进行硬编码，您可以重复使用 Spring Data Couchbase 提供的<code>BeanNames</code>。例如，您可以自定义要使用的转换器，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SomeConfiguration</span> {</span><br><span class=line>	<span class=meta>@Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)</span></span><br><span class=line>	<span class=keyword>public</span> CustomConversions <span class="title function_">myCustomConversions</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">CustomConversions</span>(...);</span><br><span class=line>	}</span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>如果您想完全绕过 Spring Data Couchbase 的自动配置，请提供自己的<code>org.springframework.data.couchbase.config.AbstractCouchbaseDataConfiguration</code>实现。</blockquote><h3 id=3-9-9、LDAP><a class=headerlink href=#3-9-9、LDAP title=3.9.9、LDAP></a>3.9.9、LDAP</h3><p><a href=https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol rel=noopener target=_blank>LDAP</a>(轻型目录访问协议)是一种开放的，与供应商无关的行业标准应用程序协议，用于通过 IP 网络访问和维护分布式目录信息服务。 Spring Boot 为任何兼容的 LDAP 服务器提供自动配置，并从<a href=https://www.ldap.com/unboundid-ldap-sdk-for-java rel=noopener target=_blank>UnboundID</a>支持嵌入式内存 LDAP 服务器。<p><a href=https://github.com/spring-projects/spring-data-ldap rel=noopener target=_blank>Spring Data LDAP</a>提供 LDAP 抽象。有一个<code>spring-boot-starter-data-ldap</code>“启动程序”，以方便的方式收集依赖项。<h4 id=3-9-9-1、连接到-LDAP-服务器><a title="3.9.9.1、连接到 LDAP 服务器" class=headerlink href=#3-9-9-1、连接到-LDAP-服务器></a>3.9.9.1、连接到 LDAP 服务器</h4><p>要连接到 LDAP 服务器，请确保声明对<code>spring-boot-starter-data-ldap</code>“ Starter”或<code>spring-ldap-core</code>的依赖关系，然后在 application.properties 中声明服务器的 URL，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.ldap.urls</span>=<span class=string>ldap://myserver:1235</span></span><br><span class=line><span class=attr>spring.ldap.username</span>=<span class=string>admin</span></span><br><span class=line><span class=attr>spring.ldap.password</span>=<span class=string>secret</span></span><br></pre></table></figure><p>如果需要自定义连接设置，则可以使用<code>spring.ldap.base</code>和<code>spring.ldap.base-environment</code>属性。<p><code>LdapContextSource</code>是根据这些设置自动配置的。如果您需要对其进行自定义(例如使用<code>PooledContextSource</code>)，则仍可以注入自动配置的<code>LdapContextSource</code>。确保将自定义的<code>ContextSource</code>标记为<code>@Primary</code>，以便自动配置的<code>LdapTemplate</code>使用它。<h4 id=3-9-9-2、Spring-Data-LDAP-存储库><a title="3.9.9.2、Spring Data LDAP 存储库" class=headerlink href=#3-9-9-2、Spring-Data-LDAP-存储库></a>3.9.9.2、Spring Data LDAP 存储库</h4><p>Spring Data 包括对 LDAP 的存储库支持。有关 Spring Data LDAP 的完整详细信息，请参阅<a href=https://docs.spring.io/spring-data/ldap/docs/1.0.x/reference/html/ rel=noopener target=_blank>reference documentation</a>。<p>您还可以像使用其他任何 Spring Bean 一样注入自动配置的<code>LdapTemplate</code>实例，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> LdapTemplate template;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(LdapTemplate template)</span> {</span><br><span class=line>		<span class=built_in>this</span>.template = template;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-9-9-3、嵌入式内存-LDAP-服务器><a title="3.9.9.3、嵌入式内存 LDAP 服务器" class=headerlink href=#3-9-9-3、嵌入式内存-LDAP-服务器></a>3.9.9.3、嵌入式内存 LDAP 服务器</h4><p>出于测试目的，Spring Boot 支持从<a href=https://www.ldap.com/unboundid-ldap-sdk-for-java rel=noopener target=_blank>UnboundID</a>自动配置内存中的 LDAP 服务器。要配置服务器，请将依赖项添加到<code>com.unboundid:unboundid-ldapsdk</code>并声明<code>base-dn</code>属性，如下所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.ldap.embedded.base-dn</span>=<span class=string>dc=spring,dc=io</span></span><br></pre></table></figure><blockquote><p>可以定义多个 base-dn 值，但是，由于可分辨的名称通常包含逗号，因此必须使用正确的符号来定义它们。<p>在 yaml 文件中，您可以使用 yaml 列表符号：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>spring.ldap.embedded.base-dn:</span><br><span class=line>- dc=spring,dc=io</span><br><span class=line>- dc=pivotal,dc=io</span><br></pre></table></figure><p>在属性文件中，必须将索引包括在属性名称中：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.ldap.embedded.base-dn[0]</span>=<span class=string>dc=spring,dc=io</span></span><br><span class=line><span class=attr>spring.ldap.embedded.base-dn[1]</span>=<span class=string>dc=pivotal,dc=io</span></span><br></pre></table></figure></blockquote><p>默认情况下，服务器在随机端口上启动并触发常规 LDAP 支持。无需指定<code>spring.ldap.urls</code>属性。<p>如果您的 Classpath 上有一个<code>schema.ldif</code>文件，它将用于初始化服务器。如果要从其他资源加载初始化脚本，则也可以使用<code>spring.ldap.embedded.ldif</code>属性。<p>默认情况下，使用标准架构来验证<code>LDIF</code>个文件。您可以通过设置<code>spring.ldap.embedded.validation.enabled</code>属性完全关闭验证。如果您具有自定义属性，则可以使用<code>spring.ldap.embedded.validation.schema</code>定义您的自定义属性类型或对象类。<h3 id=3-9-10、InfluxDB><a class=headerlink href=#3-9-10、InfluxDB title=3.9.10、InfluxDB></a>3.9.10、InfluxDB</h3><p><a href=https://www.influxdata.com/ rel=noopener target=_blank>InfluxDB</a>是开放源代码的时间序列数据库，已优化用于在操作监视，应用程序度量，物联网传感器数据和实时分析等领域中快速，高可用性地存储和检索时间序列数据。<h4 id=3-9-10-1、连接到-InfluxDB><a title="3.9.10.1、连接到 InfluxDB" class=headerlink href=#3-9-10-1、连接到-InfluxDB></a>3.9.10.1、连接到 InfluxDB</h4><p>只要<code>influxdb-java</code>Client 端位于 Classpath 上并且设置了数据库的 URL，Spring Boot 就会自动配置<code>InfluxDB</code>实例，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.influx.url</span>=<span class=string>http://172.0.0.1:8086</span></span><br></pre></table></figure><p>如果与 InfluxDB 的连接需要用户和密码，则可以相应地设置<code>spring.influx.user</code>和<code>spring.influx.password</code>属性。<p>InfluxDB 依赖 OkHttp。如果需要在后台调整 http Client 端<code>InfluxDB</code>的使用，则可以注册<code>InfluxDbOkHttpClientBuilderProvider</code> bean。<h2 id=3-10、Caching><a class=headerlink href=#3-10、Caching title=3.10、Caching></a>3.10、Caching</h2><p>Spring 框架提供了对向应用程序透明添加缓存的支持。从本质上讲，抽象将缓存应用于方法，从而根据缓存中可用的信息减少执行次数。缓存逻辑是透明应用的，不会对调用者造成任何干扰。只要通过<code>@EnableCaching</code>Comments 启用了缓存支持，Spring Boot 就会自动配置缓存基础结构。<p>简而言之，将缓存添加到服务的操作就像将相关 Comments 添加到其方法一样容易，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MathService</span> {</span><br><span class=line>	<span class=meta>@Cacheable("piDecimals")</span></span><br><span class=line>	<span class=keyword>public</span> <span class=type>int</span> <span class="title function_">computePiDecimal</span><span class=params>(<span class=type>int</span> i)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>本示例说明了在可能耗资巨大的操作上使用缓存的方法。在调用<code>computePiDecimal</code>之前，抽象将在<code>piDecimals</code>缓存中查找与<code>i</code>参数匹配的条目。如果找到条目，则高速缓存中的内容会立即返回给调用方，并且不会调用该方法。否则，将调用该方法，并在返回值之前更新缓存。<blockquote><p>您还可以透明地使用标准 JSR-107(JCache)注解(例如<code>@CacheResult</code>)。但是，我们强烈建议您不要混合使用 Spring Cache 和 JCache 注解。</blockquote><p>如果您不添加任何特定的缓存库，Spring Boot 会自动配置一个使用内存中并发 Map 的<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-simple rel=noopener target=_blank>simple provider</a>。需要缓存时(例如上例中的<code>piDecimals</code>)，此提供程序将为您创建它。实际上，不建议将简单提供程序用于生产用途，但是它对于 Starter 并确保您了解功能非常有用。确定要使用的缓存提供程序后，请确保阅读其文档，以了解如何配置应用程序使用的缓存。几乎所有提供程序都要求您显式配置在应用程序中使用的每个缓存。有些提供了一种自定义<code>spring.cache.cache-names</code>属性定义的默认缓存的方法。<h3 id=3-10-1、支持的缓存提供程序><a class=headerlink href=#3-10-1、支持的缓存提供程序 title=3.10.1、支持的缓存提供程序></a>3.10.1、支持的缓存提供程序</h3><p>缓存抽象不提供实际的存储，而是依赖于<code>org.springframework.cache.Cache</code>和<code>org.springframework.cache.CacheManager</code>接口实现的抽象。<p>如果尚未定义类型<code>CacheManager</code>或名为<code>cacheResolver</code>的<code>CacheResolver</code>(请参见<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html rel=noopener target=_blank>CachingConfigurer</a>)，则 Spring Boot 尝试检测以下提供程序(按指示的 Sequences)：<ul><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-generic rel=noopener target=_blank>Generic</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-jcache rel=noopener target=_blank>JCache (JSR-107)</a>(EhCache 3，Hazelcast，Infinispan 等)<li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-ehcache2 rel=noopener target=_blank>EhCache 2.x</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-hazelcast rel=noopener target=_blank>Hazelcast</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-infinispan rel=noopener target=_blank>Infinispan</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-couchbase rel=noopener target=_blank>Couchbase</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-redis rel=noopener target=_blank>Redis</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-caffeine rel=noopener target=_blank>Caffeine</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-simple rel=noopener target=_blank>Simple</a></ul><blockquote><p>也可以通过设置<code>spring.cache.type</code>属性来“强制”特定的缓存提供程序。如果需要在某些环境(例如测试)中<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-none rel=noopener target=_blank>完全禁用缓存</a>，请使用此属性。<p>使用<code>spring-boot-starter-cache</code>“Starter”快速添加基本的缓存依赖项。启动器带来<code>spring-context-support</code>。如果手动添加依赖项，则必须包含<code>spring-context-support</code>才能使用 JCache，EhCache 2.x 或 Guava 支持。</blockquote><p>如果<code>CacheManager</code>是由 Spring Boot 自动配置的，则可以通过公开实现<code>CacheManagerCustomizer</code>接口的 bean，在完全初始化之前进一步调整其配置。下面的示例设置一个标志，指示应该将空值向下传递到基础 Map：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> CacheManagerCustomizer&LTConcurrentMapCacheManager> <span class="title function_">cacheManagerCustomizer</span><span class=params>()</span> {</span><br><span class=line>	<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">CacheManagerCustomizer</span>&LTConcurrentMapCacheManager>() {</span><br><span class=line>		<span class=meta>@Override</span></span><br><span class=line>		<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">customize</span><span class=params>(ConcurrentMapCacheManager cacheManager)</span> {</span><br><span class=line>			cacheManager.setAllowNullValues(<span class=literal>false</span>);</span><br><span class=line>		}</span><br><span class=line>	};</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>在前面的示例中，应使用自动配置的<code>ConcurrentMapCacheManager</code>。如果不是这种情况(您提供了自己的配置，或者自动配置了其他缓存提供程序)，则根本不会调用定制程序。您可以根据需要拥有任意数量的定制程序，也可以使用<code>@Order</code>或<code>Ordered</code>对其进行排序。</blockquote><h4 id=3-10-1-1、Generic><a class=headerlink href=#3-10-1-1、Generic title=3.10.1.1、Generic></a>3.10.1.1、Generic</h4><p>如果上下文至少定义了一个<code>org.springframework.cache.Cache</code> bean，则使用通用缓存。创建一个<code>CacheManager</code>包装该类型的所有 bean。<h4 id=3-10-1-2、JCache-JSR-107><a class=headerlink href=#3-10-1-2、JCache-JSR-107 title=3.10.1.2、JCache(JSR-107)></a>3.10.1.2、JCache(JSR-107)</h4><p><a href=https://jcp.org/en/jsr/detail?id=107 rel=noopener target=_blank>JCache</a>通过 Classpath 上存在<code>javax.cache.spi.CachingProvider</code>进行引导(即，Classpath 上存在符合 JSR-107 的缓存库)，并且<code>JCacheCacheManager</code>由<code>spring-boot-starter-cache</code>“启动程序”提供。提供了各种兼容的库，Spring Boot 为 Ehcache 3，Hazelcast 和 Infinispan 提供了依赖 Management。也可以添加任何其他兼容的库。<p>可能会出现多个提供者，在这种情况下，必须明确指定提供者。即使 JSR-107 标准没有强制采用标准化的方式来定义配置文件的位置，Spring Boot 也会尽其所能以设置具有实现细节的缓存，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_"># </span><span class=language-bash>Only necessary <span class=keyword>if</span> more than one provider is present</span></span><br><span class=line>spring.cache.jcache.provider=com.acme.MyCachingProvider</span><br><span class=line>spring.cache.jcache.config=classpath:acme.xml</span><br></pre></table></figure><blockquote><p>当缓存库同时提供本机实现和 JSR-107 支持时，Spring Boot 会首选 JSR-107 支持，因此，如果您切换到其他 JSR-107 实现，则可以使用相同的功能。<p>Spring Boot 具有<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-hazelcast.html rel=noopener target=_blank>对 Hazelcast 的常规支持</a>。如果有一个<code>HazelcastInstance</code>可用，则除非指定<code>spring.cache.jcache.config</code>属性，否则它也会自动为<code>CacheManager</code>重用。</blockquote><p>自定义基础<code>javax.cache.cacheManager</code>的方法有两种：<ul><li>可以在启动时通过设置<code>spring.cache.cache-names</code>属性来创建缓存。如果定义了自定义<code>javax.cache.configuration.Configuration</code> bean，则将其用于自定义它们。<li><code>org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer</code> bean 与<code>CacheManager</code>的引用一起调用以进行完全自定义。</ul><blockquote><p>如果定义了一个标准的<code>javax.cache.CacheManager</code> bean，它将自动包装在抽象期望的<code>org.springframework.cache.CacheManager</code>实现中。不再对其应用定制。</blockquote><h4 id=3-10-1-3、EhCache-2-x><a title="3.10.1.3、EhCache 2.x" class=headerlink href=#3-10-1-3、EhCache-2-x></a>3.10.1.3、EhCache 2.x</h4><p>如果可以在 Classpath 的根目录下找到名为<code>ehcache.xml</code>的文件，则使用<a href=http://www.ehcache.org/ rel=noopener target=_blank>EhCache</a>2.x。如果找到 EhCache 2.x，则使用<code>spring-boot-starter-cache</code>“启动程序”提供的<code>EhCacheCacheManager</code>来引导缓存 Management 器。也可以提供备用配置文件，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.cache.ehcache.config</span>=<span class=string>classpath:config/another-config.xml</span></span><br></pre></table></figure><h4 id=3-10-1-4、Hazelcast><a class=headerlink href=#3-10-1-4、Hazelcast title=3.10.1.4、Hazelcast></a>3.10.1.4、Hazelcast</h4><p>Spring Boot 具有<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-hazelcast.html rel=noopener target=_blank>对 Hazelcast 的常规支持</a>。如果已自动配置<code>HazelcastInstance</code>，则会自动将其包装在<code>CacheManager</code>中。<h4 id=3-10-1-5、Infinispan><a class=headerlink href=#3-10-1-5、Infinispan title=3.10.1.5、Infinispan></a>3.10.1.5、Infinispan</h4><p><a href=http://infinispan.org/ rel=noopener target=_blank>Infinispan</a>没有默认配置文件位置，因此必须明确指定。否则，将使用默认的引导程序。<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.cache.infinispan.config</span>=<span class=string>infinispan.xml</span></span><br></pre></table></figure><p>可以在启动时通过设置<code>spring.cache.cache-names</code>属性来创建缓存。如果定义了自定义<code>ConfigurationBuilder</code> bean，则用于自定义缓存。<blockquote><p>Spring Boot 对 Infinispan 的支持仅限于嵌入式模式，并且非常基础。如果您需要更多选择，则应该使用官方的 Infinispan Spring Boot 启动程序。</blockquote><h4 id=3-10-1-6、Couchbase><a class=headerlink href=#3-10-1-6、Couchbase title=3.10.1.6、Couchbase></a>3.10.1.6、Couchbase</h4><p>如果<a href=https://www.couchbase.com/ rel=noopener target=_blank>Couchbase</a> Java Client 端和<code>couchbase-spring-cache</code>实现可用且 Couchbase 为<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-nosql.html#boot-features-couchbase rel=noopener target=_blank>configured</a>，则将自动配置<code>CouchbaseCacheManager</code>。也可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建其他缓存。这些缓存在自动配置的<code>Bucket</code>上运行。您还可以*使用定制程序在另一个<code>Bucket</code>上创建其他缓存。假设您在“主” <code>Bucket</code>上需要两个缓存(<code>cache1</code>和<code>cache2</code>)，在(另一个)<code>Bucket</code>上需要一个缓存(<code>cache3</code>)的自定义时间为 2 秒。您可以通过配置创建前两个缓存，如下所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.cache.cache-names</span>=<span class=string>cache1,cache2</span></span><br></pre></table></figure><p>然后，您可以定义一个<code>@Configuration</code>类来配置额外的<code>Bucket</code>和<code>cache3</code>缓存，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CouchbaseCacheConfiguration</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> Cluster cluster;</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">CouchbaseCacheConfiguration</span><span class=params>(Cluster cluster)</span> {</span><br><span class=line>		<span class=built_in>this</span>.cluster = cluster;</span><br><span class=line>	}</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> Bucket <span class="title function_">anotherBucket</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.cluster.openBucket(<span class=string>"another"</span>, <span class=string>"secret"</span>);</span><br><span class=line>	}</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> CacheManagerCustomizer&LTCouchbaseCacheManager> <span class="title function_">cacheManagerCustomizer</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> c -> {</span><br><span class=line>			c.prepareCache(<span class=string>"cache3"</span>, CacheBuilder.newInstance(anotherBucket())</span><br><span class=line>					.withExpiration(<span class=number>2</span>));</span><br><span class=line>		};</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>此示例配置重复使用通过自动配置创建的<code>Cluster</code>。<h4 id=3-10-1-7、Redis><a class=headerlink href=#3-10-1-7、Redis title=3.10.1.7、Redis></a>3.10.1.7、Redis</h4><p>如果<a href=http://redis.io/ rel=noopener target=_blank>Redis</a>可用并已配置，则将自动配置<code>RedisCacheManager</code>。可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建其他缓存，并且可以使用<code>spring.cache.redis.*</code>属性配置缓存默认值。例如，以下配置创建了“生存时间”为 10 分钟的<code>cache1</code>和<code>cache2</code>缓存：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.cache.cache-names</span>=<span class=string>cache1,cache2</span></span><br><span class=line><span class=attr>spring.cache.redis.time-to-live</span>=<span class=string>600000</span></span><br></pre></table></figure><blockquote><p>默认情况下，添加密钥前缀，以便如果两个单独的缓存使用相同的密钥，则 Redis 不会有重叠的密钥，并且不能返回无效值。如果您创建自己的<code>RedisCacheManager</code>，强烈建议您启用此设置。<p>您可以添加自己的<code>RedisCacheConfiguration</code> <code>@Bean</code>，从而完全控制配置。如果您要自定义序列化策略，这将很有用。</blockquote><h4 id=3-10-1-8、Caffeine><a class=headerlink href=#3-10-1-8、Caffeine title=3.10.1.8、Caffeine></a>3.10.1.8、Caffeine</h4><p><a href=https://github.com/ben-manes/caffeine rel=noopener target=_blank>Caffeine</a>是对 Guava 缓存的 Java 8 重写，取代了对 Guava 的支持。如果存在 Caffeine，则会自动配置<code>CaffeineCacheManager</code>(由<code>spring-boot-starter-cache</code>“Starter”提供)。缓存可以在启动时通过设置<code>spring.cache.cache-names</code>属性来创建，并且可以通过以下方式之一自定义(按指示的 Sequences)：<ul><li><code>spring.cache.caffeine.spec</code>定义的缓存规范<li>定义了一个<code>com.github.benmanes.caffeine.cache.CaffeineSpec</code> bean<li>定义了一个<code>com.github.benmanes.caffeine.cache.Caffeine</code> bean</ul><p>例如，以下配置创建<code>cache1</code>和<code>cache2</code>缓存，最大大小为 500，并且<em>生存时间</em>为 10 分钟<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.cache.cache-names</span>=<span class=string>cache1,cache2</span></span><br><span class=line><span class=attr>spring.cache.caffeine.spec</span>=<span class=string>maximumSize=500,expireAfterAccess=600s</span></span><br></pre></table></figure><p>如果定义了<code>com.github.benmanes.caffeine.cache.CacheLoader</code> bean，它将自动与<code>CaffeineCacheManager</code>关联。由于<code>CacheLoader</code>将与由缓存 Management 器 Management 的* all *缓存相关联，因此必须将其定义为<code>CacheLoader&LTObject, Object></code>。自动配置将忽略任何其他通用类型。<h4 id=3-10-1-9、Simple><a class=headerlink href=#3-10-1-9、Simple title=3.10.1.9、Simple></a>3.10.1.9、Simple</h4><p>如果找不到其他提供者，则配置使用<code>ConcurrentHashMap</code>作为缓存存储区的简单实现。如果您的应用程序中不存在任何缓存库，则这是默认设置。默认情况下，将根据需要创建缓存，但是您可以通过设置<code>cache-names</code>属性来限制可用缓存的列表。例如，如果只需要<code>cache1</code>和<code>cache2</code>缓存，则按如下所示设置<code>cache-names</code>属性：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.cache.cache-names</span>=<span class=string>cache1,cache2</span></span><br></pre></table></figure><p>如果这样做，并且您的应用程序使用了未列出的缓存，那么当需要该缓存时，它将在运行时失败，但不会在启动时失败。这类似于使用未声明的缓存时“实际”缓存提供程序的行为。<h4 id=3-10-1-10、None><a class=headerlink href=#3-10-1-10、None title=3.10.1.10、None></a>3.10.1.10、None</h4><p>当您的配置中包含<code>@EnableCaching</code>时，也需要合适的缓存配置。如果需要在某些环境中完全禁用缓存，请强制将缓存类型设置为<code>none</code>以使用无操作实现，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.cache.type</span>=<span class=string>none</span></span><br></pre></table></figure><h2 id=3-11、Messaging><a class=headerlink href=#3-11、Messaging title=3.11、Messaging></a>3.11、Messaging</h2><p>Spring 框架为与消息传递系统集成提供了广泛的支持，从简化使用<code>JmsTemplate</code>的 JMS API 的使用到完整的异步接收消息的基础结构。 Spring AMQP 为高级消息队列协议提供了类似的功能集。 Spring Boot 还为<code>RabbitTemplate</code>和 RabbitMQ 提供了自动配置选项。 Spring WebSocket 本身就包含对 STOMP 消息的支持，而 Spring Boot 通过启动程序和少量的自动配置对此提供了支持。 Spring Boot 还支持 Apache Kafka。<h3 id=3-11-1、JMS><a class=headerlink href=#3-11-1、JMS title=3.11.1、JMS></a>3.11.1、JMS</h3><p><code>javax.jms.ConnectionFactory</code>接口提供了创建<code>javax.jms.Connection</code>与 JMS 代理进行交互的标准方法。尽管 Spring 需要<code>ConnectionFactory</code>才能与 JMS 一起使用，但是您通常不需要自己直接使用它，而是可以依靠更高级别的消息抽象。 (有关详细信息，请参见 Spring Framework 参考文档的<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/integration.html#jms rel=noopener target=_blank>relevant section</a>。)Spring Boot 还自动配置必要的基础结构来发送和接收消息。<h4 id=3-11-1-1、ActiveMQ-支持><a title="3.11.1.1、ActiveMQ 支持" class=headerlink href=#3-11-1-1、ActiveMQ-支持></a>3.11.1.1、ActiveMQ 支持</h4><p>当<a href=http://activemq.apache.org/ rel=noopener target=_blank>ActiveMQ</a>在 Classpath 上可用时，Spring Boot 也可以配置<code>ConnectionFactory</code>。如果存在代理，则将自动启动和配置嵌入式代理(前提是未通过配置指定代理 URL)。<blockquote><p>如果使用<code>spring-boot-starter-activemq</code>，则将提供连接或嵌入 ActiveMQ 实例所需的依赖关系，以及与 JMS 集成的 Spring 基础结构。</blockquote><p>ActiveMQ 配置由<code>spring.activemq.*</code>中的外部配置属性控制。例如，您可以在<code>application.properties</code>中声明以下部分：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.activemq.broker-url</span>=<span class=string>tcp://192.168.1.210:9876</span></span><br><span class=line><span class=attr>spring.activemq.user</span>=<span class=string>admin</span></span><br><span class=line><span class=attr>spring.activemq.password</span>=<span class=string>secret</span></span><br></pre></table></figure><p>默认情况下，<code>CachingConnectionFactory</code>使用可以由<code>spring.jms.*</code>中的外部配置属性控制的明智设置来包装本机<code>ConnectionFactory</code>：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.jms.cache.session-cache-size</span>=<span class=string>5</span></span><br></pre></table></figure><p>如果您想使用本机池，则可以通过向<code>org.messaginghub:pooled-jms</code>添加依赖项并相应地配置<code>JmsPoolConnectionFactory</code>来实现，如下例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.activemq.pool.enabled</span>=<span class=string>true</span></span><br><span class=line><span class=attr>spring.activemq.pool.max-connections</span>=<span class=string>50</span></span><br></pre></table></figure><blockquote><p>有关更多受支持的选项，请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/activemq/ActiveMQProperties.java rel=noopener target=_blank>ActiveMQProperties</a>。您还可以注册任意数量的实现<code>ActiveMQConnectionFactoryCustomizer</code>的 bean，以进行更高级的自定义。</blockquote><p>默认情况下，ActiveMQ 将创建一个目的地(如果目的地尚不存在)，以便根据其提供的名称来解析目的地。<h4 id=3-11-1-2、Artemis-支持><a title="3.11.1.2、Artemis 支持" class=headerlink href=#3-11-1-2、Artemis-支持></a>3.11.1.2、Artemis 支持</h4><p>当 Spring Boot 检测到<a href=http://activemq.apache.org/artemis/ rel=noopener target=_blank>Artemis</a>在 Classpath 中可用时，它可以自动配置<code>ConnectionFactory</code>。如果存在代理，则将自动启动和配置嵌入式代理(除非已明确设置 mode 属性)。支持的模式为<code>embedded</code>(以明确要求使用嵌入式代理，并且如果代理在 Classpath 上不可用，则会发生错误)和<code>native</code>(使用<code>netty</code>传输协议连接到代理)。配置后者后，Spring Boot 将使用默认设置配置一个<code>ConnectionFactory</code>，该<code>ConnectionFactory</code>连接到在本地计算机上运行的代理。<blockquote><p>如果使用<code>spring-boot-starter-artemis</code>，则将提供连接到现有 Artemis 实例所需的依赖关系，以及与 JMS 集成的 Spring 基础结构。将<code>org.apache.activemq:artemis-jms-server</code>添加到您的应用程序可让您使用嵌入式模式。</blockquote><p>Artemis 配置由<code>spring.artemis.*</code>中的外部配置属性控制。例如，您可以在<code>application.properties</code>中声明以下部分：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.artemis.mode</span>=<span class=string>native</span></span><br><span class=line><span class=attr>spring.artemis.host</span>=<span class=string>192.168.1.210</span></span><br><span class=line><span class=attr>spring.artemis.port</span>=<span class=string>9876</span></span><br><span class=line><span class=attr>spring.artemis.user</span>=<span class=string>admin</span></span><br><span class=line><span class=attr>spring.artemis.password</span>=<span class=string>secret</span></span><br></pre></table></figure><p>嵌入代理时，可以选择是否要启用持久性并列出应使其可用的目的地。可以将它们指定为以逗号分隔的列表，以使用默认选项创建它们，也可以为高级队列和主题配置分别定义类型<code>org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration</code>或<code>org.apache.activemq.artemis.jms.server.config.TopicConfiguration</code>的 bean。<p>默认情况下，<code>CachingConnectionFactory</code>使用可以由<code>spring.jms.*</code>中的外部配置属性控制的明智设置来包装本机<code>ConnectionFactory</code>：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.jms.cache.session-cache-size</span>=<span class=string>5</span></span><br></pre></table></figure><p>如果您想使用本机池，则可以通过向<code>org.messaginghub:pooled-jms</code>添加依赖项并相应地配置<code>JmsPoolConnectionFactory</code>来实现，如下例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.artemis.pool.enabled</span>=<span class=string>true</span></span><br><span class=line><span class=attr>spring.artemis.pool.max-connections</span>=<span class=string>50</span></span><br></pre></table></figure><p>有关更多受支持的选项，请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/artemis/ArtemisProperties.java rel=noopener target=_blank>ArtemisProperties</a>。<p>不涉及 JNDI 查找，并且使用 Artemis 配置中的<code>name</code>属性或通过配置提供的名称来根据目的地名称解析目的地。<h4 id=3-11-1-3、使用-JNDI-ConnectionFactory><a title="3.11.1.3、使用 JNDI ConnectionFactory" class=headerlink href=#3-11-1-3、使用-JNDI-ConnectionFactory></a>3.11.1.3、使用 JNDI ConnectionFactory</h4><p>如果您正在应用程序服务器中运行应用程序，则 Spring Boot 会尝试使用 JNDI 查找 JMS <code>ConnectionFactory</code>。默认情况下，选中<code>java:/JmsXA</code>和<code>java:/XAConnectionFactory</code>位置。如果需要指定替代位置，则可以使用<code>spring.jms.jndi-name</code>属性，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.jms.jndi-name</span>=<span class=string>java:/MyConnectionFactory</span></span><br></pre></table></figure><h4 id=3-11-1-4、发送消息><a class=headerlink href=#3-11-1-4、发送消息 title=3.11.1.4、发送消息></a>3.11.1.4、发送消息</h4><p>Spring 的<code>JmsTemplate</code>是自动配置的，您可以将其直接自动连接到自己的 bean 中，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> JmsTemplate jmsTemplate;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(JmsTemplate jmsTemplate)</span> {</span><br><span class=line>		<span class=built_in>this</span>.jmsTemplate = jmsTemplate;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p><a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jms/core/JmsMessagingTemplate.html rel=noopener target=_blank>JmsMessagingTemplate</a>可以类似的方式注入。如果定义了<code>DestinationResolver</code>或<code>MessageConverter</code> bean，则将其自动关联到自动配置的<code>JmsTemplate</code>。</blockquote><h4 id=3-11-1-5、接收消息><a class=headerlink href=#3-11-1-5、接收消息 title=3.11.1.5、接收消息></a>3.11.1.5、接收消息</h4><p>存在 JMS 基础结构时，可以使用<code>@JmsListener</code>Comments 任何 bean 以创建侦听器端点。如果未定义<code>JmsListenerContainerFactory</code>，则会自动配置一个默认值。如果定义了<code>DestinationResolver</code>或<code>MessageConverter</code> bean，它将自动关联到默认工厂。<p>默认情况下，默认工厂是事务性的。如果您在存在<code>JtaTransactionManager</code>的基础结构中运行，则默认情况下会将其与侦听器容器关联。如果不是，则启用<code>sessionTransacted</code>标志。在后一种情况下，可以通过在侦听器方法(或其委托)上添加<code>@Transactional</code>来将本地数据存储事务与传入消息的处理相关联。这样可以确保本地事务完成后，传入消息得到确认。这还包括发送已在同一 JMS 会话上执行的响应消息。<p>以下组件在<code>someQueue</code>目标上创建侦听器端点：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=meta>@JmsListener(destination = "someQueue")</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">processMessage</span><span class=params>(String content)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>如果您需要创建更多的<code>JmsListenerContainerFactory</code>实例，或者想覆盖默认实例，Spring Boot 提供了一个<code>DefaultJmsListenerContainerFactoryConfigurer</code>，您可以使用与自动配置的设置相同的设置来初始化<code>DefaultJmsListenerContainerFactory</code>。<p>例如，以下示例公开了另一个使用特定<code>MessageConverter</code>的工厂：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">JmsConfiguration</span> {</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> DefaultJmsListenerContainerFactory <span class="title function_">myFactory</span><span class=params>(</span></span><br><span class=line><span class=params>			DefaultJmsListenerContainerFactoryConfigurer configurer)</span> {</span><br><span class=line>		<span class=type>DefaultJmsListenerContainerFactory</span> <span class=variable>factory</span> <span class=operator>=</span></span><br><span class=line>				<span class=keyword>new</span> <span class="title class_">DefaultJmsListenerContainerFactory</span>();</span><br><span class=line>		configurer.configure(factory, connectionFactory());</span><br><span class=line>		factory.setMessageConverter(myMessageConverter());</span><br><span class=line>		<span class=keyword>return</span> factory;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>然后，您可以在任何带有<code>@JmsListener</code>Comments 的方法中使用工厂，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=meta>@JmsListener(destination = "someQueue", containerFactory="myFactory")</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">processMessage</span><span class=params>(String content)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-11-2、AMQP><a class=headerlink href=#3-11-2、AMQP title=3.11.2、AMQP></a>3.11.2、AMQP</h3><p>高级消息队列协议(AMQP)是面向消息中间件的与平台无关的有线级别协议。 Spring AMQP 项目将 Spring 的核心概念应用于基于 AMQP 的消息传递解决方案的开发。 Spring Boot 为通过 RabbitMQ 使用 AMQP 提供了许多便利，包括<code>spring-boot-starter-amqp</code>“ Starter”。<h4 id=3-11-2-1、RabbitMQ-支持><a title="3.11.2.1、RabbitMQ 支持" class=headerlink href=#3-11-2-1、RabbitMQ-支持></a>3.11.2.1、RabbitMQ 支持</h4><p><a href=https://www.rabbitmq.com/ rel=noopener target=_blank>RabbitMQ</a>是基于 AMQP 协议的轻型，可靠，可伸缩和便携式消息代理。 Spring 使用<code>RabbitMQ</code>通过 AMQP 协议进行通信。<p>RabbitMQ 配置由<code>spring.rabbitmq.*</code>中的外部配置属性控制。例如，您可以在<code>application.properties</code>中声明以下部分：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.rabbitmq.host</span>=<span class=string>localhost</span></span><br><span class=line><span class=attr>spring.rabbitmq.port</span>=<span class=string>5672</span></span><br><span class=line><span class=attr>spring.rabbitmq.username</span>=<span class=string>admin</span></span><br><span class=line><span class=attr>spring.rabbitmq.password</span>=<span class=string>secret</span></span><br></pre></table></figure><p>如果上下文中存在<code>ConnectionNameStrategy</code> bean，它将自动用于命名由自动配置的<code>ConnectionFactory</code>创建的连接。有关更多受支持的选项，请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java rel=noopener target=_blank>RabbitProperties</a>。<h4 id=3-11-2-2、发送信息><a class=headerlink href=#3-11-2-2、发送信息 title=3.11.2.2、发送信息></a>3.11.2.2、发送信息</h4><p>Spring 的<code>AmqpTemplate</code>和<code>AmqpAdmin</code>是自动配置的，您可以将它们直接自动连接到自己的 bean 中，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.amqp.core.AmqpAdmin;</span><br><span class=line><span class=keyword>import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> AmqpAdmin amqpAdmin;</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> AmqpTemplate amqpTemplate;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate)</span> {</span><br><span class=line>		<span class=built_in>this</span>.amqpAdmin = amqpAdmin;</span><br><span class=line>		<span class=built_in>this</span>.amqpTemplate = amqpTemplate;</span><br><span class=line>	}</span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p><a href=https://docs.spring.io/spring-amqp/docs/current/api/org/springframework/amqp/rabbit/core/RabbitMessagingTemplate.html rel=noopener target=_blank>RabbitMessagingTemplate</a>可以类似的方式注入。如果定义了<code>MessageConverter</code> bean，它将自动关联到自动配置的<code>AmqpTemplate</code>。</blockquote><p>如有必要，任何定义为 bean 的<code>org.springframework.amqp.core.Queue</code>都会自动用于在 RabbitMQ 实例上声明相应的队列。<p>要重试操作，可以在<code>AmqpTemplate</code>上启用重试(例如，在代理连接丢失的情况下)：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.rabbitmq.template.retry.enabled</span>=<span class=string>true</span></span><br><span class=line><span class=attr>spring.rabbitmq.template.retry.initial-interval</span>=<span class=string>2s</span></span><br></pre></table></figure><p>默认情况下，重试是禁用的。您还可以pass 语句<code>RabbitRetryTemplateCustomizer</code> bean 来以编程方式自定义<code>RetryTemplate</code>。<h4 id=3-11-2-3、接收信息><a class=headerlink href=#3-11-2-3、接收信息 title=3.11.2.3、接收信息></a>3.11.2.3、接收信息</h4><p>存在 Rabbit 基础结构时，可以使用<code>@RabbitListener</code>Comments 任何 bean 以创建侦听器端点。如果未定义<code>RabbitListenerContainerFactory</code>，则会自动配置默认的<code>SimpleRabbitListenerContainerFactory</code>，并且可以使用<code>spring.rabbitmq.listener.type</code>属性切换到直接容器。如果定义了<code>MessageConverter</code>或<code>MessageRecoverer</code> bean，它将自动与默认工厂关联。<p>以下示例组件在<code>someQueue</code>队列上创建一个侦听器端点：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=meta>@RabbitListener(queues = "someQueue")</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">processMessage</span><span class=params>(String content)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>如果您需要创建更多的<code>RabbitListenerContainerFactory</code>实例，或者想覆盖默认实例，Spring Boot 提供了<code>SimpleRabbitListenerContainerFactoryConfigurer</code>和<code>DirectRabbitListenerContainerFactoryConfigurer</code>，您可以使用它们设置与自动配置使用的工厂相同的设置来初始化<code>SimpleRabbitListenerContainerFactory</code>和<code>DirectRabbitListenerContainerFactory</code>。<blockquote><p>选择哪种容器都没有关系。这两个 bean 通过自动配置公开。</blockquote><p>例如，以下配置类公开了另一个使用特定<code>MessageConverter</code>的工厂：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">RabbitConfiguration</span> {</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> SimpleRabbitListenerContainerFactory <span class="title function_">myFactory</span><span class=params>(</span></span><br><span class=line><span class=params>			SimpleRabbitListenerContainerFactoryConfigurer configurer)</span> {</span><br><span class=line>		<span class=type>SimpleRabbitListenerContainerFactory</span> <span class=variable>factory</span> <span class=operator>=</span></span><br><span class=line>				<span class=keyword>new</span> <span class="title class_">SimpleRabbitListenerContainerFactory</span>();</span><br><span class=line>		configurer.configure(factory, connectionFactory);</span><br><span class=line>		factory.setMessageConverter(myMessageConverter());</span><br><span class=line>		<span class=keyword>return</span> factory;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>然后，您可以使用任何带有<code>@RabbitListener</code>Comments 的方法来使用工厂，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=meta>@RabbitListener(queues = "someQueue", containerFactory="myFactory")</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">processMessage</span><span class=params>(String content)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>您可以启用重试来处理侦听器引发异常的情况。默认情况下，使用<code>RejectAndDontRequeueRecoverer</code>，但是您可以定义自己的<code>MessageRecoverer</code>。重试用尽后，如果将代理配置为这样做，则消息将被拒绝并被丢弃或路由到死信交换。默认情况下，重试是禁用的。您也可以pass 语句<code>RabbitRetryTemplateCustomizer</code> bean 来以编程方式自定义<code>RetryTemplate</code>。<blockquote><p>默认情况下，如果禁用了重试，并且侦听器引发了异常，则会无限期地重试传递。您可以通过两种方式修改此行为：将<code>defaultRequeueRejected</code>属性设置为<code>false</code>，以便尝试进行零次重新传递或抛出<code>AmqpRejectAndDontRequeueException</code>来指示应拒绝该消息。后者是启用重试并达到最大传递尝试次数时使用的机制。</blockquote><h3 id=3-11-3、Apache-Kafka-支持><a title="3.11.3、Apache Kafka 支持" class=headerlink href=#3-11-3、Apache-Kafka-支持></a>3.11.3、Apache Kafka 支持</h3><p>通过提供<code>spring-kafka</code>项目的自动配置来支持<a href=https://kafka.apache.org/ rel=noopener target=_blank>Apache Kafka</a>。<p>Kafka 配置由<code>spring.kafka.*</code>中的外部配置属性控制。例如，您可以在<code>application.properties</code>中声明以下部分：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.kafka.bootstrap-servers</span>=<span class=string>localhost:9092</span></span><br><span class=line><span class=attr>spring.kafka.consumer.group-id</span>=<span class=string>myGroup</span></span><br></pre></table></figure><blockquote><p>要在启动时创建主题，请添加<code>NewTopic</code>类型的 Bean。如果该主题已经存在，则将忽略 Bean。</blockquote><h4 id=3-11-3-1、发送消息><a class=headerlink href=#3-11-3-1、发送消息 title=3.11.3.1、发送消息></a>3.11.3.1、发送消息</h4><p>Spring 的<code>KafkaTemplate</code>是自动配置的，您可以直接在自己的 bean 中自动对其进行布线，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> KafkaTemplate kafkaTemplate;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(KafkaTemplate kafkaTemplate)</span> {</span><br><span class=line>		<span class=built_in>this</span>.kafkaTemplate = kafkaTemplate;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-11-3-2、接收消息><a class=headerlink href=#3-11-3-2、接收消息 title=3.11.3.2、接收消息></a>3.11.3.2、接收消息</h4><p>存在 Apache Kafka 基础结构时，可以使用<code>@KafkaListener</code>Comments 任何 bean 以创建侦听器端点。如果未定义<code>KafkaListenerContainerFactory</code>，则会使用<code>spring.kafka.listener.*</code>中定义的键自动配置一个默认值。<p>以下组件在<code>someTopic</code>主题上创建侦听器终结点：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=meta>@KafkaListener(topics = "someTopic")</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">processMessage</span><span class=params>(String content)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>如果定义了<code>KafkaTransactionManager</code> bean，它将自动与容器工厂关联。同样，如果定义了<code>RecordMessageConverter</code>，<code>ErrorHandler</code>或<code>AfterRollbackProcessor</code> bean，它将自动与默认工厂关联。<blockquote><p>自定义<code>ChainedKafkaTransactionManager</code>必须标记为<code>@Primary</code>，因为它通常引用自动配置的<code>KafkaTransactionManager</code> bean。</blockquote><h4 id=3-11-3-3、Kafka流><a class=headerlink href=#3-11-3-3、Kafka流 title=3.11.3.3、Kafka流></a>3.11.3.3、Kafka流</h4><p>用于 Apache Kafka 的 Spring 提供了一个工厂 bean 来创建<code>StreamsBuilder</code>对象并 Management 其流的生命周期。只要<code>kafka-streams</code>在 Classpath 上并且通过<code>@EnableKafkaStreams</code>Comments 启用 Kafka Streams，Spring Boot 就会自动配置所需的<code>KafkaStreamsConfiguration</code> bean。<p>启用 Kafka Streams 意味着必须设置应用程序 ID 和引导服务器。可以使用<code>spring.kafka.streams.application-id</code>配置前者，如果未设置，则默认为<code>spring.application.name</code>。后者可以全局设置，也可以仅针对流进行覆盖。<p>使用专用属性可以使用几个附加属性。可以使用<code>spring.kafka.streams.properties</code>名称空间设置其他任意 Kafka 属性。另请参见<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-messaging.html#boot-features-kafka-extra-props rel=noopener target=_blank>第 33.3.4 节“其他 Kafka 属性”</a>。<p>要使用工厂 bean，只需将<code>StreamsBuilder</code>连接到您的<code>@Bean</code>中，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableKafkaStreams</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">KafkaStreamsExampleConfiguration</span> {</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> KStream&LTInteger, String> <span class="title function_">kStream</span><span class=params>(StreamsBuilder streamsBuilder)</span> {</span><br><span class=line>		KStream&LTInteger, String> stream = streamsBuilder.stream(<span class=string>"ks1In"</span>);</span><br><span class=line>		stream.map((k, v) -> <span class=keyword>new</span> <span class="title class_">KeyValue</span><>(k, v.toUpperCase())).to(<span class=string>"ks1Out"</span>,</span><br><span class=line>				Produced.with(Serdes.Integer(), <span class=keyword>new</span> <span class="title class_">JsonSerde</span><>()));</span><br><span class=line>		<span class=keyword>return</span> stream;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>默认情况下，由它创建的<code>StreamBuilder</code>对象 Management 的流将自动启动。您可以使用<code>spring.kafka.streams.auto-startup</code>属性来自定义此行为。<h4 id=3-11-3-4、Kafka-的其他属性><a title="3.11.3.4、Kafka 的其他属性" class=headerlink href=#3-11-3-4、Kafka-的其他属性></a>3.11.3.4、Kafka 的其他属性</h4><p>自动配置支持的属性显示在<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/common-application-properties.html rel=noopener target=_blank>附录 A，通用应用程序属性</a>中。请注意，在大多数情况下，这些属性(连字符或 camelCase)直接 Map 到 Apache Kafka 点缀属性。有关详细信息，请参阅 Apache Kafka 文档。<p>这些属性的前几个属性适用于所有组件(生产者，使用者，Management 员和流)，但如果您希望使用不同的值，则可以在组件级别上指定。 Apache Kafka 会指定重要性为 HIGH，MEDIUM 或 LOW 的属性。 Spring Boot 自动配置支持所有 HIGH 重要性属性，一些选定的 MEDIUM 和 LOW 属性以及任何没有默认值的属性。<p>Kafka 支持的属性的子集仅可通过<code>KafkaProperties</code>类直接使用。如果希望使用不直接支持的其他属性来配置生产者或使用者，请使用以下属性：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.kafka.properties.prop.one</span>=<span class=string>first</span></span><br><span class=line><span class=attr>spring.kafka.admin.properties.prop.two</span>=<span class=string>second</span></span><br><span class=line><span class=attr>spring.kafka.consumer.properties.prop.three</span>=<span class=string>third</span></span><br><span class=line><span class=attr>spring.kafka.producer.properties.prop.four</span>=<span class=string>fourth</span></span><br><span class=line><span class=attr>spring.kafka.streams.properties.prop.five</span>=<span class=string>fifth</span></span><br></pre></table></figure><p>这将公共<code>prop.one</code> Kafka 属性设置为<code>first</code>(适用于生产者，Consumer 和 Management 员)，将<code>prop.two</code> admin 属性设置为<code>second</code>，将<code>prop.three</code>Consumer 属性设置为<code>third</code>，将<code>prop.four</code>生产者属性设置为<code>fourth</code>，并将<code>prop.five</code> streams 属性设置为<code>fifth</code>。<p>您还可以如下配置 Spring Kafka <code>JsonDeserializer</code>：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.kafka.consumer.value-deserializer</span>=<span class=string>org.springframework.kafka.support.serializer.JsonDeserializer</span></span><br><span class=line><span class=attr>spring.kafka.consumer.properties.spring.json.value.default.type</span>=<span class=string>com.example.Invoice</span></span><br><span class=line><span class=attr>spring.kafka.consumer.properties.spring.json.trusted.packages</span>=<span class=string>com.example,org.acme</span></span><br></pre></table></figure><p>同样，您可以禁用在 Headers 中发送类型信息的<code>JsonSerializer</code>默认行为：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.kafka.producer.value-serializer</span>=<span class=string>org.springframework.kafka.support.serializer.JsonSerializer</span></span><br><span class=line><span class=attr>spring.kafka.producer.properties.spring.json.add.type.headers</span>=<span class=string>false</span></span><br></pre></table></figure><h2 id=3-12、使用-RestTemplate-调用-REST-服务><a title="3.12、使用 RestTemplate 调用 REST 服务" class=headerlink href=#3-12、使用-RestTemplate-调用-REST-服务></a>3.12、使用 RestTemplate 调用 REST 服务</h2><p>如果您需要从应用程序中调用远程 REST 服务，则可以使用 Spring Framework 的<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html rel=noopener target=_blank>RestTemplate</a>类。由于<code>RestTemplate</code>实例在使用前通常需要自定义，因此 Spring Boot 不提供任何单个自动配置的<code>RestTemplate</code> bean。但是，它会自动配置<code>RestTemplateBuilder</code>，可以在需要时创建<code>RestTemplate</code>实例。自动配置的<code>RestTemplateBuilder</code>确保将明智的<code>HttpMessageConverters</code>应用于<code>RestTemplate</code>实例。<p>以下代码显示了一个典型示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyService</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> RestTemplate restTemplate;</span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyService</span><span class=params>(RestTemplateBuilder restTemplateBuilder)</span> {</span><br><span class=line>		<span class=built_in>this</span>.restTemplate = restTemplateBuilder.build();</span><br><span class=line>	}</span><br><span class=line>	<span class=keyword>public</span> Details <span class="title function_">someRestCall</span><span class=params>(String name)</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.restTemplate.getForObject(<span class=string>"/{name}/details"</span>, Details.class, name);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p><code>RestTemplateBuilder</code>包含许多可用于快速配置<code>RestTemplate</code>的有用方法。例如，要添加 BASIC 身份验证支持，可以使用<code>builder.basicAuthentication("user", "password").build()</code>。</blockquote><h3 id=3-12-1、RestTemplate-自定义><a title="3.12.1、RestTemplate 自定义" class=headerlink href=#3-12-1、RestTemplate-自定义></a>3.12.1、RestTemplate 自定义</h3><p><code>RestTemplate</code>自定义有三种 Main 方法，具体取决于您希望自定义应用的范围。<p>要使所有自定义项的范围尽可能缩小，请注入自动配置的<code>RestTemplateBuilder</code>，然后根据需要调用其方法。每个方法调用都返回一个新的<code>RestTemplateBuilder</code>实例，因此自定义仅影响构建器的使用。<p>要进行应用程序范围的附加自定义，请使用<code>RestTemplateCustomizer</code> bean。所有此类 bean 都会自动注册到自动配置的<code>RestTemplateBuilder</code>中，并应用于使用它构建的任何模板。<p>以下示例显示了一个定制程序，该定制程序为除<code>192.168.0.5</code>之外的所有主机配置代理的使用：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">ProxyCustomizer</span> <span class=keyword>implements</span> <span class="title class_">RestTemplateCustomizer</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">customize</span><span class=params>(RestTemplate restTemplate)</span> {</span><br><span class=line>		<span class=type>HttpHost</span> <span class=variable>proxy</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">HttpHost</span>(<span class=string>"proxy.example.com"</span>);</span><br><span class=line>		<span class=type>HttpClient</span> <span class=variable>httpClient</span> <span class=operator>=</span> HttpClientBuilder.create()</span><br><span class=line>				.setRoutePlanner(<span class=keyword>new</span> <span class="title class_">DefaultProxyRoutePlanner</span>(proxy) {</span><br><span class=line></span><br><span class=line>					<span class=meta>@Override</span></span><br><span class=line>					<span class=keyword>public</span> HttpHost <span class="title function_">determineProxy</span><span class=params>(HttpHost target,</span></span><br><span class=line><span class=params>							HttpRequest request, HttpContext context)</span></span><br><span class=line>							<span class=keyword>throws</span> HttpException {</span><br><span class=line>						<span class=keyword>if</span> (target.getHostName().equals(<span class=string>"192.168.0.5"</span>)) {</span><br><span class=line>							<span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>						}</span><br><span class=line>						<span class=keyword>return</span> <span class=built_in>super</span>.determineProxy(target, request, context);</span><br><span class=line>					}</span><br><span class=line></span><br><span class=line>				}).build();</span><br><span class=line>		restTemplate.setRequestFactory(</span><br><span class=line>				<span class=keyword>new</span> <span class="title class_">HttpComponentsClientHttpRequestFactory</span>(httpClient));</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>最后，最极端(也是很少使用)的选项是创建自己的<code>RestTemplateBuilder</code> bean。这样做会关闭<code>RestTemplateBuilder</code>的自动配置，并防止使用任何<code>RestTemplateCustomizer</code> bean。<h2 id=3-13、使用-WebClient-调用-REST-服务><a title="3.13、使用 WebClient 调用 REST 服务" class=headerlink href=#3-13、使用-WebClient-调用-REST-服务></a>3.13、使用 WebClient 调用 REST 服务</h2><p>如果您的 Classpath 中包含 Spring WebFlux，则还可以选择使用<code>WebClient</code>来调用远程 REST 服务。与<code>RestTemplate</code>相比，此 Client 端具有更多的功能感，并且具有完全的 Reactive。您可以在专用的<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web-reactive.html#webflux-client rel=noopener target=_blank>Spring Framework 文档中的部分</a>中了解有关<code>WebClient</code>的更多信息。<p>Spring Boot 为您创建并预配置了<code>WebClient.Builder</code>；强烈建议将其注入您的组件中并使用它来创建<code>WebClient</code>实例。 Spring Boot 正在配置该构建器以共享 HTTP 资源，以与服务器相同的方式反映编解码器的设置(请参阅<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-webflux-httpcodecs rel=noopener target=_blank>WebFlux HTTP 编解码器自动配置</a>)，以及更多。<p>以下代码显示了一个典型示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyService</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> WebClient webClient;</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyService</span><span class=params>(WebClient.Builder webClientBuilder)</span> {</span><br><span class=line>		<span class=built_in>this</span>.webClient = webClientBuilder.baseUrl(<span class=string>"http://example.org"</span>).build();</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> Mono&LTDetails> <span class="title function_">someRestCall</span><span class=params>(String name)</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.webClient.get().uri(<span class=string>"/{name}/details"</span>, name)</span><br><span class=line>						.retrieve().bodyToMono(Details.class);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-13-1、WebClient-运行时><a title="3.13.1、WebClient 运行时" class=headerlink href=#3-13-1、WebClient-运行时></a>3.13.1、WebClient 运行时</h3><p>Spring Boot 将根据应用程序 Classpath 上可用的库自动检测要使用哪个<code>ClientHttpConnector</code>来驱动<code>WebClient</code>。目前，还支持 Reactor Netty 和 Jetty RS Client 端。<p>默认情况下，<code>spring-boot-starter-webflux</code>启动程序取决于<code>io.projectreactor.netty:reactor-netty</code>，这同时带来了服务器和 Client 端实现。如果选择使用 Jetty 作为反应式服务器，则应在 Jetty 反应式 HTTP Client 端库<code>org.eclipse.jetty:jetty-reactive-httpclient</code>上添加依赖项。对服务器和 Client 端使用相同的技术具有其优势，因为它将自动在 Client 端和服务器之间共享 HTTP 资源。<p>通过提供自定义的<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code> bean，开发人员可以覆盖 Jetty 和 Reactor Netty 的资源配置-这将同时应用于 Client 端和服务器。<p>如果您希望为 Client 端覆盖该选择，则可以定义自己的<code>ClientHttpConnector</code> bean 并完全控制 Client 端配置。<h3 id=3-13-2、WebClient-自定义><a title="3.13.2、WebClient 自定义" class=headerlink href=#3-13-2、WebClient-自定义></a>3.13.2、WebClient 自定义</h3><p><code>WebClient</code>自定义有三种 Main 方法，具体取决于您希望自定义应用的范围。<p>要使所有自定义项的范围尽可能缩小，请注入自动配置的<code>WebClient.Builder</code>，然后根据需要调用其方法。 <code>WebClient.Builder</code>实例是有状态的：构建器上的任何更改都会反映在随后使用它创建的所有 Client 端中。如果要使用同一构建器创建多个 Client 端，则也可以考虑使用<code>WebClient.Builder other = builder.clone();</code>克隆该构建器。<p>要对所有<code>WebClient.Builder</code>实例进行应用程序级的附加自定义，您可以声明<code>WebClientCustomizer</code> bean 并在注入点更改<code>WebClient.Builder</code>。<p>最后，您可以使用原始 API 并使用<code>WebClient.create()</code>。在这种情况下，不会应用任何自动配置或<code>WebClientCustomizer</code>。<h2 id=3-14、Validation><a class=headerlink href=#3-14、Validation title=3.14、Validation></a>3.14、Validation</h2><p>只要 JSR-303 实现(例如 Hibernate 验证器)位于 Classpath 上，就会自动启用 Bean 验证 1.1 支持的方法验证功能。这样就可以在 Bean 方法的参数和/或返回值上使用<code>javax.validation</code>约束 Comments。具有此类 Comments 方法的目标类需要在类型级别使用<code>@Validated</code>Comments 进行 Comments，以便在其方法中搜索内联约束 Comments。<p>例如，以下服务触发第一个参数的验证，确保其大小在 8 到 10 之间：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=meta>@Validated</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>public</span> Archive <span class="title function_">findByCodeAndAuthor</span><span class=params>(<span class=meta>@Size(min = 8, max = 10)</span> String code,</span></span><br><span class=line><span class=params>			Author author)</span> {</span><br><span class=line>		...</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h2 id=3-15、发送电子邮件><a class=headerlink href=#3-15、发送电子邮件 title=3.15、发送电子邮件></a>3.15、发送电子邮件</h2><p>Spring 框架提供了一种使用<code>JavaMailSender</code>接口发送电子邮件的简单抽象方法，而 Spring Boot 为它提供了自动配置以及启动程序模块。<p>如果<code>spring.mail.host</code>和相关库(由<code>spring-boot-starter-mail</code>定义)可用，则如果不存在默认库<code>JavaMailSender</code>，则将创建该库。可以通过<code>spring.mail</code>名称空间中的配置项进一步自定义发送方。有关更多详细信息，请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mail/MailProperties.java rel=noopener target=_blank>MailProperties</a>。<p>特别是，某些默认超时值是无限的，您可能需要更改该值，以避免线程被无响应的邮件服务器阻塞，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.mail.properties.mail.smtp.connectiontimeout</span>=<span class=string>5000</span></span><br><span class=line><span class=attr>spring.mail.properties.mail.smtp.timeout</span>=<span class=string>3000</span></span><br><span class=line><span class=attr>spring.mail.properties.mail.smtp.writetimeout</span>=<span class=string>5000</span></span><br></pre></table></figure><p>也可以使用 JNDI 中的现有<code>Session</code>配置<code>JavaMailSender</code>：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.mail.jndi-name</span>=<span class=string>mail/Session</span></span><br></pre></table></figure><p>设置<code>jndi-name</code>时，它优先于所有其他与会话相关的其他设置。<h2 id=3-16、-JTA-的分布式事务><a title="3.16、 JTA 的分布式事务" class=headerlink href=#3-16、-JTA-的分布式事务></a>3.16、 JTA 的分布式事务</h2><p>Spring Boot 通过使用<a href=http://www.atomikos.com/ rel=noopener target=_blank>Atomikos</a>或<a href=https://github.com/bitronix/btm rel=noopener target=_blank>Bitronix</a>嵌入式事务 Management 器，支持跨多个 XA 资源的分布式 JTA 事务。部署到合适的 Java EE 应用程序服务器时，还支持 JTA 事务。<p>当检测到 JTA 环境时，使用 Spring 的<code>JtaTransactionManager</code>来 Management 事务。自动配置的 JMS，DataSource 和 JPA Bean 已升级为支持 XA 事务。您可以使用标准的 Spring 习惯用法(例如<code>@Transactional</code>)来参与分布式事务。如果您在 JTA 环境中，并且仍要使用本地事务，则可以将<code>spring.jta.enabled</code>属性设置为<code>false</code>以禁用 JTA 自动配置。<h3 id=3-16-1、使用-Atomikos-Transaction-manager><a title="3.16.1、使用 Atomikos Transaction manager" class=headerlink href=#3-16-1、使用-Atomikos-Transaction-manager></a>3.16.1、使用 Atomikos Transaction manager</h3><p><a href=https://www.atomikos.com/ rel=noopener target=_blank>Atomikos</a>是流行的开源事务 Management 器，可以嵌入到您的 Spring Boot 应用程序中。您可以使用<code>spring-boot-starter-jta-atomikos</code> Starter 引入适当的 Atomikos 库。 Spring Boot 自动配置 Atomikos 并确保将适当的<code>depends-on</code>设置应用于您的 Spring Bean，以正确启动和关闭 Sequences。<p>默认情况下，Atomikos 事务日志将写入应用程序主目录(应用程序 jar 文件所在的目录)中的<code>transaction-logs</code>目录。您可以通过在<code>application.properties</code>文件中设置<code>spring.jta.log-dir</code>属性来自定义此目录的位置。以<code>spring.jta.atomikos.properties</code>开头的属性也可以用于自定义 Atomikos <code>UserTransactionServiceImp</code>。有关完整的详细信息，请参见<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/jta/atomikos/AtomikosProperties.html rel=noopener target=_blank>AtomikosProperties Javadoc</a>。<blockquote><p>为了确保多个事务 Management 器可以安全地协调同一资源 Management 器，必须为每个 Atomikos 实例配置一个唯一的 ID。默认情况下，此 ID 是运行 Atomikos 的计算机的 IP 地址。为了确保 Producing 的唯一性，应为应用程序的每个实例将<code>spring.jta.transaction-manager-id</code>属性配置为不同的值。</blockquote><h3 id=3-16-2、使用-Bitronix-Transaction-manager><a title="3.16.2、使用 Bitronix Transaction manager" class=headerlink href=#3-16-2、使用-Bitronix-Transaction-manager></a>3.16.2、使用 Bitronix Transaction manager</h3><p><a href=https://github.com/bitronix/btm rel=noopener target=_blank>Bitronix</a>是流行的开源 JTA 事务 Management 器实现。您可以使用<code>spring-boot-starter-jta-bitronix</code>Starter 程序将适当的 Bitronix 依赖项添加到您的项目中。与 Atomikos 一样，Spring Boot 自动配置 Bitronix 并对您的 bean 进行后处理，以确保启动和关闭 Sequences 正确。<p>默认情况下，Bitronix 事务日志文件(<code>part1.btm</code>和<code>part2.btm</code>)被写入应用程序主目录中的<code>transaction-logs</code>目录。您可以通过设置<code>spring.jta.log-dir</code>属性来自定义此目录的位置。以<code>spring.jta.bitronix.properties</code>开头的属性也绑定到<code>bitronix.tm.Configuration</code> bean，从而可以进行完全自定义。有关详情，请参见<a href=https://github.com/bitronix/btm/wiki/Transaction-manager-configuration rel=noopener target=_blank>Bitronix documentation</a>。<blockquote><p>为了确保多个事务 Management 器可以安全地协调同一资源 Management 器，必须为每个 Bitronix 实例配置唯一的 ID。默认情况下，此 ID 是运行 Bitronix 的计算机的 IP 地址。为了确保 Producing 的唯一性，应为应用程序的每个实例将<code>spring.jta.transaction-manager-id</code>属性配置为不同的值。</blockquote><h3 id=3-16-3、使用-Java-EE-托管事务-Management-器><a title="3.16.3、使用 Java EE 托管事务 Management 器" class=headerlink href=#3-16-3、使用-Java-EE-托管事务-Management-器></a>3.16.3、使用 Java EE 托管事务 Management 器</h3><p>如果将 Spring Boot 应用程序打包为<code>war</code>或<code>ear</code>文件并将其部署到 Java EE 应用程序服务器，则可以使用应用程序服务器的内置事务 Management 器。 Spring Boot 尝试通过查看常见的 JNDI 位置(<code>java:comp/UserTransaction</code>，<code>java:comp/TransactionManager</code>等)来自动配置事务 Management 器。如果使用应用程序服务器提供的事务服务，通常还需要确保所有资源都由服务器 Management 并通过 JNDI 公开。 Spring Boot 通过在 JNDI 路径(<code>java:/JmsXA</code>或<code>java:/XAConnectionFactory</code>)中查找<code>ConnectionFactory</code>来尝试自动配置 JMS，您可以使用<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-sql.html#boot-features-connecting-to-a-jndi-datasource rel=noopener target=_blank>spring.datasource.jndi-name property</a>来配置<code>DataSource</code>。<h3 id=3-16-4、混合-XA-和非-XA-JMS-连接><a title="3.16.4、混合 XA 和非 XA JMS 连接" class=headerlink href=#3-16-4、混合-XA-和非-XA-JMS-连接></a>3.16.4、混合 XA 和非 XA JMS 连接</h3><p>使用 JTA 时，主要的 JMS <code>ConnectionFactory</code> bean 支持 XA，并参与分布式事务。在某些情况下，您可能希望通过使用非 XA <code>ConnectionFactory</code>处理某些 JMS 消息。例如，您的 JMS 处理逻辑可能需要比 XA 超时更长的时间。<p>如果要使用非 XA <code>ConnectionFactory</code>，则可以注入<code>nonXaJmsConnectionFactory</code> bean 而不是<code>@Primary</code> <code>jmsConnectionFactory</code> bean。为了保持一致性，还使用 Bean 别名<code>xaJmsConnectionFactory</code>提供了<code>jmsConnectionFactory</code> bean。<p>以下示例显示了如何注入<code>ConnectionFactory</code>个实例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=comment>// Inject the primary (XA aware) ConnectionFactory</span></span><br><span class=line><span class=meta>@Autowired</span></span><br><span class=line><span class=keyword>private</span> ConnectionFactory defaultConnectionFactory;</span><br><span class=line></span><br><span class=line><span class=comment>// Inject the XA aware ConnectionFactory (uses the alias and injects the same as above)</span></span><br><span class=line><span class=meta>@Autowired</span></span><br><span class=line><span class=meta>@Qualifier("xaJmsConnectionFactory")</span></span><br><span class=line><span class=keyword>private</span> ConnectionFactory xaConnectionFactory;</span><br><span class=line></span><br><span class=line><span class=comment>// Inject the non-XA aware ConnectionFactory</span></span><br><span class=line><span class=meta>@Autowired</span></span><br><span class=line><span class=meta>@Qualifier("nonXaJmsConnectionFactory")</span></span><br><span class=line><span class=keyword>private</span> ConnectionFactory nonXaConnectionFactory;</span><br></pre></table></figure><h3 id=3-16-5、支持备用嵌入式事务-Management-器><a title="3.16.5、支持备用嵌入式事务 Management 器" class=headerlink href=#3-16-5、支持备用嵌入式事务-Management-器></a>3.16.5、支持备用嵌入式事务 Management 器</h3><p><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jms/XAConnectionFactoryWrapper.java rel=noopener target=_blank>XAConnectionFactoryWrapper</a>和<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jdbc/XADataSourceWrapper.java rel=noopener target=_blank>XADataSourceWrapper</a>接口可用于支持其他嵌入式事务 Management 器。这些接口负责包装<code>XAConnectionFactory</code>和<code>XADataSource</code> bean 并将它们作为常规<code>ConnectionFactory</code>和<code>DataSource</code> bean 公开，它们透明地注册了分布式事务。数据源和 JMS 自动配置使用 JTA 变体，前提是您拥有<code>JtaTransactionManager</code> bean 和在<code>ApplicationContext</code>中注册了适当的 XA 包装 bean。<p><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/bitronix/BitronixXAConnectionFactoryWrapper.java rel=noopener target=_blank>BitronixXAConnectionFactoryWrapper</a>和<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/bitronix/BitronixXADataSourceWrapper.java rel=noopener target=_blank>BitronixXADataSourceWrapper</a>提供了有关如何编写 XA 包装程序的良好示例。<h2 id=3-17、Hazelcast><a class=headerlink href=#3-17、Hazelcast title=3.17、Hazelcast></a>3.17、Hazelcast</h2><p>如果<a href=https://hazelcast.com/ rel=noopener target=_blank>Hazelcast</a>位于 Classpath 上，并且找到了合适的配置，则 Spring Boot 会自动配置一个<code>HazelcastInstance</code>，您可以将其插入到应用程序中。<p>如果定义一个<code>com.hazelcast.config.Config</code> bean，Spring Boot 将使用它。如果您的配置定义了一个实例名称，Spring Boot 会尝试查找一个现有实例，而不是创建一个新实例。<p>您还可以指定<code>hazelcast.xml</code>配置文件以通过配置使用，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.hazelcast.config</span>=<span class=string>classpath:config/my-hazelcast.xml</span></span><br></pre></table></figure><p>否则，Spring Boot 会尝试从默认位置：工作目录中或 Classpath 根目录中的<code>hazelcast.xml</code>查找 Hazelcast 配置。我们还检查<code>hazelcast.config</code>系统属性是否设置。有关更多详细信息，请参见<a href=http://docs.hazelcast.org/docs/latest/manual/html-single/ rel=noopener target=_blank>Hazelcast documentation</a>。<p>如果<code>hazelcast-client</code>存在于 Classpath 中，则 Spring Boot 首先尝试通过检查以下配置选项来创建 Client 端：<ul><li><code>com.hazelcast.client.config.ClientConfig</code> bean 的存在。<li><code>spring.hazelcast.config</code>属性定义的配置文件。<li><code>hazelcast.client.config</code>系统属性的存在。<li>工作目录中或 Classpath 根目录中的<code>hazelcast-client.xml</code>。</ul><blockquote><p>Spring Boot 也具有<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-hazelcast rel=noopener target=_blank>对 Hazelcast 的显式缓存支持</a>。如果启用了缓存，则<code>HazelcastInstance</code>将自动包装在<code>CacheManager</code>实现中。</blockquote><h2 id=3-18、Quartz-Scheduler><a title="3.18、Quartz Scheduler" class=headerlink href=#3-18、Quartz-Scheduler></a>3.18、Quartz Scheduler</h2><p>Spring Boot 为使用<a href=http://www.quartz-scheduler.org/ rel=noopener target=_blank>Quartz scheduler</a>提供了许多便利，其中包括<code>spring-boot-starter-quartz</code>“ Starter”。如果 Quartz 可用，则会自动配置<code>Scheduler</code>(通过<code>SchedulerFactoryBean</code>抽象)。<p>以下类型的 Bean 被自动拾取并与<code>Scheduler</code>关联：<ul><li><code>JobDetail</code>：定义特定的作业。可以使用<code>JobBuilder</code> API 构建<code>JobDetail</code>实例。<li><code>Calendar</code> .<li><code>Trigger</code>：定义何时触发特定作业。</ul><p>默认情况下，使用内存中的<code>JobStore</code>。但是，如果您的应用程序中有<code>DataSource</code> bean 可用，并且相应地配置了<code>spring.quartz.job-store-type</code>属性，则可以配置基于 JDBC 的存储，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.quartz.job-store-type</span>=<span class=string>jdbc</span></span><br></pre></table></figure><p>使用 JDBC 存储时，可以在启动时初始化模式，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.quartz.jdbc.initialize-schema</span>=<span class=string>always</span></span><br></pre></table></figure><blockquote><p>默认情况下，使用 Quartz 库随附的标准脚本检测并初始化数据库。这些脚本删除现有表，并在每次重新启动时删除所有触发器。也可以通过设置<code>spring.quartz.jdbc.schema</code>属性来提供自定义脚本。</blockquote><p>要让 Quartz 使用除应用程序主<code>DataSource</code>之外的<code>DataSource</code>，请声明<code>DataSource</code> bean，并用<code>@QuartzDataSource</code>Comments 其<code>@Bean</code>方法。这样做可确保<code>SchedulerFactoryBean</code>使用 Quartz 专用的<code>DataSource</code>并用于模式初始化。<p>默认情况下，通过配置创建的作业将不会覆盖从持久性作业存储中读取的已注册作业。要启用覆盖现有作业定义的功能，请设置<code>spring.quartz.overwrite-existing-jobs</code>属性。<p>可以使用<code>spring.quartz</code>属性和<code>SchedulerFactoryBeanCustomizer</code> bean 自定义 Quartz Scheduler 配置，从而可以通过编程方式自定义<code>SchedulerFactoryBean</code>。可以使用<code>spring.quartz.properties.*</code>定制高级 Quartz 配置属性。<blockquote><p>特别是，<code>Executor</code> bean 没有与调度程序相关联，因为 Quartz 提供了一种通过<code>spring.quartz.properties</code>配置调度程序的方法。如果您需要自定义任务 Actuator，请考虑实现<code>SchedulerFactoryBeanCustomizer</code>。</blockquote><p>作业可以定义设置器以注入数据 Map 属性。常规 bean 也可以类似的方式注入，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SampleJob</span> <span class=keyword>extends</span> <span class="title class_">QuartzJobBean</span> {</span><br><span class=line>	<span class=keyword>private</span> MyService myService;</span><br><span class=line>	<span class=keyword>private</span> String name;</span><br><span class=line></span><br><span class=line>	<span class=comment>// Inject "MyService" bean</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMyService</span><span class=params>(MyService myService)</span> { ... }</span><br><span class=line></span><br><span class=line>	<span class=comment>// Inject the "name" job data property</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setName</span><span class=params>(String name)</span> { ... }</span><br><span class=line></span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>protected</span> <span class=keyword>void</span> <span class="title function_">executeInternal</span><span class=params>(JobExecutionContext context)</span></span><br><span class=line>			<span class=keyword>throws</span> JobExecutionException {</span><br><span class=line>		...</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h2 id=3-19、任务执行和计划><a class=headerlink href=#3-19、任务执行和计划 title=3.19、任务执行和计划></a>3.19、任务执行和计划</h2><p>在上下文中没有<code>TaskExecutor</code> bean 的情况下，Spring Boot 会使用合理的默认值自动配置<code>ThreadPoolTaskExecutor</code>，这些默认值可以自动与异步任务执行(<code>@EnableAsync</code>)和 Spring MVC 异步请求处理相关联。<p>线程池使用 8 个核心线程，这些线程可以根据负载增长和收缩。可以使用<code>spring.task.execution</code>名称空间对这些默认设置进行微调，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.task.execution.pool.max-threads</span>=<span class=string>16</span></span><br><span class=line><span class=attr>spring.task.execution.pool.queue-capacity</span>=<span class=string>100</span></span><br><span class=line><span class=attr>spring.task.execution.pool.keep-alive</span>=<span class=string>10s</span></span><br></pre></table></figure><p>这会将线程池更改为使用有界队列，以便当队列已满(100 个任务)时，线程池最多增加到 16 个线程。当线程空闲 10 秒(而不是默认情况下的 60 秒)时，回收线程会使池的收缩更加激进。<p>如果需要将<code>ThreadPoolTaskScheduler</code>与计划的任务执行(<code>@EnableScheduling</code>)关联，也可以对其进行自动配置。默认情况下，线程池使用一个线程，可以使用<code>spring.task.scheduling</code>名称空间对这些设置进行微调。<p>如果需要创建自定义执行程序或调度程序，则<code>TaskExecutorBuilder</code> bean 和<code>TaskSchedulerBuilder</code> bean 在上下文中都可用。<h2 id=3-20、Spring-整合><a title="3.20、Spring 整合" class=headerlink href=#3-20、Spring-整合></a>3.20、Spring 整合</h2><p>Spring Boot 为使用<a href=https://projects.spring.io/spring-integration/ rel=noopener target=_blank>Spring Integration</a>提供了许多便利，其中包括<code>spring-boot-starter-integration</code>“ Starter”。 Spring Integration 在消息传递以及其他传输(例如 HTTP，TCP 等)上提供了抽象。如果您的 Classpath 上有 Spring Integration，则可以通过<code>@EnableIntegration</code>Comments 对其进行初始化。<p>Spring Boot 还配置了一些功能，这些功能由其他 Spring Integration 模块的存在触发。如果<code>spring-integration-jmx</code>也在 Classpath 上，则消息处理统计信息将通过 JMX 发布。如果<code>spring-integration-jdbc</code>可用，则可以在启动时创建默认数据库架构，如以下行所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.integration.jdbc.initialize-schema</span>=<span class=string>always</span></span><br></pre></table></figure><p>有关更多详细信息，请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationAutoConfiguration.java rel=noopener target=_blank>IntegrationAutoConfiguration</a>和<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationProperties.java rel=noopener target=_blank>IntegrationProperties</a>类。<p>默认情况下，如果存在 Micrometer <code>meterRegistry</code> bean，那么 Spring Integration Metrics 将由 Micrometer Management。如果您希望使用旧版 Spring Integration Metrics，请将<code>DefaultMetricsFactory</code> bean 添加到应用程序上下文中。<h2 id=3-21、Spring-Session><a title="3.21、Spring Session" class=headerlink href=#3-21、Spring-Session></a>3.21、Spring Session</h2><p>Spring Boot 为广泛的数据存储提供<a href=https://projects.spring.io/spring-session/ rel=noopener target=_blank>Spring Session</a>自动配置。构建 Servlet Web 应用程序时，可以自动配置以下存储：<ul><li>JDBC<li>Redis<li>Hazelcast<li>MongoDB</ul><p>构建反应式 Web 应用程序时，可以自动配置以下存储：<ul><li>Redis<li>MongoDB</ul><p>如果 Classpath 上只有一个 Spring Session 模块，Spring Boot 会自动使用该存储实现。如果您有多个实现，则必须选择要用于存储会话的<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/session/StoreType.java rel=noopener target=_blank>StoreType</a>。例如，要将 JDBC 用作后端存储，可以按以下方式配置应用程序：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.session.store-type</span>=<span class=string>jdbc</span></span><br></pre></table></figure><blockquote><p>您可以通过将<code>store-type</code>设置为<code>none</code>来禁用 Spring Session。</blockquote><p>每个 Store 都有特定的其他设置。例如，可以为 JDBC 存储定制表的名称，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.session.jdbc.table-name</span>=<span class=string>SESSIONS</span></span><br></pre></table></figure><p>要设置会话超时，您可以使用<code>spring.session.timeout</code>属性。如果未设置该属性，则自动配置将回退到<code>server.servlet.session.timeout</code>的值。<h2 id=3-22、通过-JMX-进行监视和-Management><a title="3.22、通过 JMX 进行监视和 Management" class=headerlink href=#3-22、通过-JMX-进行监视和-Management></a>3.22、通过 JMX 进行监视和 Management</h2><p>Java Management 扩展(JMX)提供了监视和 Management 应用程序的标准机制。默认情况下，Spring Boot 创建一个 ID 为<code>mbeanServer</code>的<code>MBeanServer</code> bean，并公开任何带有 Spring JMX Comments(<code>@ManagedResource</code>，<code>@ManagedAttribute</code>或<code>@ManagedOperation</code>)的 bean。<p>有关更多详细信息，请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jmx/JmxAutoConfiguration.java rel=noopener target=_blank>JmxAutoConfiguration</a>类。<h2 id=3-23、Testing><a class=headerlink href=#3-23、Testing title=3.23、Testing></a>3.23、Testing</h2><p>Spring Boot 提供了许多 Util 和 Comments，可以在测试应用程序时提供帮助。测试支持由两个模块提供：<code>spring-boot-test</code>包含核心项目，而<code>spring-boot-test-autoconfigure</code>支持自动配置测试。<p>大多数开发人员使用<code>spring-boot-starter-test</code>“Starter 程序”，该程序同时导入 Spring Boot 测试模块以及 JUnit，AssertJ，Hamcrest 和许多其他有用的库。<h3 id=3-23-1、测试范围依赖性><a class=headerlink href=#3-23-1、测试范围依赖性 title=3.23.1、测试范围依赖性></a>3.23.1、测试范围依赖性</h3><p><code>spring-boot-starter-test</code>“Starter”(位于<code>test</code> <code>scope</code>中)包含以下提供的库：<ul><li><a href=http://junit.org/ rel=noopener target=_blank>JUnit</a>：用于对 Java 应用程序进行单元测试的实际标准。<li><a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#integration-testing rel=noopener target=_blank>Spring Test</a>和 Spring Boot 测试：对 Spring Boot 应用程序的 Util 和集成测试支持。<li><a href=https://joel-costigliola.github.io/assertj/ rel=noopener target=_blank>AssertJ</a>：流畅的 assert 库。<li><a href=http://hamcrest.org/JavaHamcrest/ rel=noopener target=_blank>Hamcrest</a>：匹配器对象库(也称为约束或谓词)。<li><a href=http://mockito.org/ rel=noopener target=_blank>Mockito</a>：Java 模拟框架。<li><a href=https://github.com/skyscreamer/JSONassert rel=noopener target=_blank>JSONassert</a>：JSON 的 assert 库。<li><a href=https://github.com/jayway/JsonPath rel=noopener target=_blank>JsonPath</a>：JSON 的 XPath。</ul><p>通常，我们发现这些通用库在编写测试时很有用。如果这些库不满足您的需求，则可以添加自己的其他测试依赖项。<h3 id=3-23-2、测试-Spring-应用程序><a title="3.23.2、测试 Spring 应用程序" class=headerlink href=#3-23-2、测试-Spring-应用程序></a>3.23.2、测试 Spring 应用程序</h3><p>依赖注入的主要优点之一是，它应该使您的代码更易于进行单元测试。您可以使用<code>new</code>运算符实例化对象，而无需使用 Spring。您也可以使用* mock objects *代替 true 的依赖。<p>通常，您需要超越单元测试并开始集成测试(使用 Spring <code>ApplicationContext</code>)。能够进行集成测试而无需部署应用程序或连接到其他基础结构，这很有用。<p>Spring 框架包括用于此类集成测试的专用测试模块。您可以直接向<code>org.springframework:spring-test</code>声明依赖项，也可以使用<code>spring-boot-starter-test</code>“启动器”将其引入。<p>如果以前没有使用过<code>spring-test</code>模块，则应先阅读 Spring Framework 参考文档的<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#testing rel=noopener target=_blank>relevant section</a>。<h3 id=3-23-3、测试-Spring-Boot-应用程序><a title="3.23.3、测试 Spring Boot 应用程序" class=headerlink href=#3-23-3、测试-Spring-Boot-应用程序></a>3.23.3、测试 Spring Boot 应用程序</h3><p>Spring Boot 应用程序是 Spring <code>ApplicationContext</code>，因此除了用普通的 Spring 上下文进行测试之外，无需执行任何其他特殊操作即可对其进行测试。<blockquote><p>仅当您使用<code>SpringApplication</code>创建它时，Spring Boot 的外部属性，日志记录和其他功能才默认安装在上下文中。</blockquote><p>Spring Boot 提供了<code>@SpringBootTest</code>注解，可以在需要 Spring Boot 功能时用作标准<code>spring-test</code> <code>@ContextConfiguration</code>注解的替代方法。Comments 由<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-detecting-config rel=noopener target=_blank>通过 SpringApplication 创建在测试中使用的 ApplicationContext</a>起作用。除了<code>@SpringBootTest</code>之外，还为应用程序<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests rel=noopener target=_blank>测试更具体的切片</a>提供了许多其他 Comments。<blockquote><p>如果您使用的是 JUnit 4，请不要忘记也将<code>@RunWith(SpringRunner.class)</code>添加到测试中，否则 Comments 将被忽略。如果您使用的是 JUnit 5，则无需添加等效的<code>@ExtendWith(SpringExtension)</code>作为<code>@SpringBootTest</code>，并且其他<code>@…Test</code>Comments 已经对其进行了 Comments。</blockquote><p>默认情况下，<code>@SpringBootTest</code>不会启动服务器。您可以使用<code>@SpringBootTest</code>的<code>webEnvironment</code>属性来进一步优化测试的运行方式：<ul><li><code>MOCK</code>(默认)：加载 Web <code>ApplicationContext</code>并提供模拟 Web 环境。使用此 Comments 时，不会启动嵌入式服务器。如果您的 Classpath 中没有 Web 环境，则此模式将透明地退回到创建常规的非 Web <code>ApplicationContext</code>。它可以与<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-with-mock-environment rel=noopener target=_blank>@AutoConfigureMockMvc 或@AutoConfigureWebTestClient</a>结合使用，以对 Web 应用程序进行基于模拟的测试。<li><code>RANDOM_PORT</code>：加载<code>WebServerApplicationContext</code>并提供真实的 Web 环境。嵌入式服务器将启动并在随机端口上侦听。<li><code>DEFINED_PORT</code>：加载<code>WebServerApplicationContext</code>并提供真实的 Web 环境。嵌入式服务器将启动，并在已定义的端口(来自<code>application.properties</code>)或默认端口<code>8080</code>上进行侦听。<li><code>NONE</code>：使用<code>SpringApplication</code>加载<code>ApplicationContext</code>，但不提供<em>任何</em>网络环境(模拟或其他方式)。</ul><blockquote><p>如果您的测试是<code>@Transactional</code>，则默认情况下它将在每个测试方法的末尾回滚事务。但是，由于将这种安排与<code>RANDOM_PORT</code>或<code>DEFINED_PORT</code>一起使用隐式提供了 true 的 servlet 环境，因此 HTTP Client 端和服务器在单独的线程中运行，因此在单独的事务中运行。在这种情况下，服务器上启动的任何事务都不会回滚。<p>如果您的应用程序对 Management 服务器使用其他端口，则<code>@SpringBootTest</code>和<code>webEnvironment = WebEnvironment.RANDOM_PORT</code>还将在单独的随机端口上启动 Management 服务器。</blockquote><h4 id=3-23-3-1、检测-Web-应用程序类型><a title="3.23.3.1、检测 Web 应用程序类型" class=headerlink href=#3-23-3-1、检测-Web-应用程序类型></a>3.23.3.1、检测 Web 应用程序类型</h4><p>如果 Spring MVC 可用，则配置基于常规 MVC 的应用程序上下文。如果您只有 Spring WebFlux，我们将检测到该情况并配置基于 WebFlux 的应用程序上下文。<p>如果两者都存在，则 Spring MVC 优先。如果要在这种情况下测试反应式 Web 应用程序，则必须设置<code>spring.main.web-application-type</code>属性：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@SpringBootTest(properties = "spring.main.web-application-type=reactive")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyWebFluxTests</span> { ... }</span><br></pre></table></figure><h4 id=3-23-3-2、检测测试配置><a class=headerlink href=#3-23-3-2、检测测试配置 title=3.23.3.2、检测测试配置></a>3.23.3.2、检测测试配置</h4><p>如果您熟悉 Spring Test Framework，则可能会习惯使用<code>@ContextConfiguration(classes=…)</code>来指定要加载哪个 Spring <code>@Configuration</code>。另外，您可能经常在测试中使用嵌套的<code>@Configuration</code>类。<p>在测试 Spring Boot 应用程序时，通常不需要这样做。只要您没有明确定义 Spring Boot 的<code>@*Test</code>注解，它就会自动搜索您的主要配置。<p>搜索算法从包含测试的程序包开始工作，直到找到带有<code>@SpringBootApplication</code>或<code>@SpringBootConfiguration</code>Comments 的类。只要您以一种明智的方式<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-structuring-your-code.html rel=noopener target=_blank>结构化代码</a>，通常就可以找到您的主要配置。<blockquote><p>如果您使用<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests rel=noopener target=_blank>测试 Comments 以测试应用程序的更具体部分</a>，则应避免在<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-user-configuration rel=noopener target=_blank>Main 方法的应用程序类别</a>上添加特定于特定区域的配置设置。<p><code>@SpringBootApplication</code>的基础组件扫描配置定义了用于确保切片按预期工作的排除筛选器。如果在<code>@SpringBootApplication</code>Comments 的类上使用显式的<code>@ComponentScan</code>指令，请注意这些过滤器将被禁用。如果使用切片，则应重新定义它们。</blockquote><p>如果要自定义主要配置，则可以使用嵌套的<code>@TestConfiguration</code>类。与将使用嵌套的<code>@Configuration</code>类代替应用程序的主要配置不同的是，除了使用应用程序的主要配置之外，还使用嵌套的<code>@TestConfiguration</code>类。<blockquote><p>Spring 的测试框架在测试之间缓存应用程序上下文。因此，只要您的测试共享相同的配置(无论如何发现)，加载上下文的潜在耗时过程就只会发生一次。</blockquote><h4 id=3-23-3-3、排除测试配置><a class=headerlink href=#3-23-3-3、排除测试配置 title=3.23.3.3、排除测试配置></a>3.23.3.3、排除测试配置</h4><p>如果您的应用程序使用组件扫描(例如，如果使用<code>@SpringBootApplication</code>或<code>@ComponentScan</code>)，则可能会偶然发现到处都是为特定测试创建的顶级配置类。<p>正如我们<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-detecting-config rel=noopener target=_blank>早看过</a>，<code>@TestConfiguration</code>可以在测试的内部类上使用以自定义主要配置。当放在顶级类上时，<code>@TestConfiguration</code>指示<code>src/test/java</code>中的类不应通过扫描来拾取。然后，可以在需要的位置显式导入该类，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@SpringBootTest</span></span><br><span class=line><span class=meta>@Import(MyTestsConfiguration.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyTests</span> {</span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">exampleTest</span><span class=params>()</span> {</span><br><span class=line>		...</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>如果您直接使用<code>@ComponentScan</code>(即不是通过<code>@SpringBootApplication</code>)，则需要向其注册<code>TypeExcludeFilter</code>。有关详情，请参见<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/context/TypeExcludeFilter.html rel=noopener target=_blank>the Javadoc</a>。</blockquote><h4 id=3-23-3-4、在模拟环境中进行测试><a class=headerlink href=#3-23-3-4、在模拟环境中进行测试 title=3.23.3.4、在模拟环境中进行测试></a>3.23.3.4、在模拟环境中进行测试</h4><p>默认情况下，<code>@SpringBootTest</code>不会启动服务器。如果您有要在此模拟环境下进行测试的 Web 终结点，则可以另外配置<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference//testing.html#spring-mvc-test-framework rel=noopener target=_blank>MockMvc</a>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@SpringBootTest</span></span><br><span class=line><span class=meta>@AutoConfigureMockMvc</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MockMvcExampleTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> MockMvc mvc;</span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">exampleTest</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		<span class=built_in>this</span>.mvc.perform(get(<span class=string>"/"</span>)).andExpect(status().isOk())</span><br><span class=line>				.andExpect(content().string(<span class=string>"Hello World"</span>));</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>如果您只想关注 Web 层而不想开始完整的<code>ApplicationContext</code>，请考虑<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-mvc-tests rel=noopener target=_blank>使用@WebMvcTest 代替</a>。</blockquote><p>或者，您可以配置<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#webtestclient-tests rel=noopener target=_blank>WebTestClient</a>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.web.reactive.server.WebTestClient;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@SpringBootTest</span></span><br><span class=line><span class=meta>@AutoConfigureWebTestClient</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MockWebTestClientExampleTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> WebTestClient webClient;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">exampleTest</span><span class=params>()</span> {</span><br><span class=line>		<span class=built_in>this</span>.webClient.get().uri(<span class=string>"/"</span>).exchange().expectStatus().isOk()</span><br><span class=line>				.expectBody(String.class).isEqualTo(<span class=string>"Hello World"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-3-5、使用正在运行的服务器进行测试><a class=headerlink href=#3-23-3-5、使用正在运行的服务器进行测试 title=3.23.3.5、使用正在运行的服务器进行测试></a>3.23.3.5、使用正在运行的服务器进行测试</h4><p>如果需要启动完全运行的服务器，建议您使用随机端口。如果您使用<code>@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)</code>，则每次运行测试时都会随机选择一个可用端口。<p><code>@LocalServerPort</code>注解可用于<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/howto-embedded-web-servers.html#howto-discover-the-http-port-at-runtime rel=noopener target=_blank>注入实际使用的端口</a>进入您的测试。为了方便起见，需要对启动的服务器进行 REST 调用的测试可以另外<code>@Autowire</code> a <a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#webtestclient-tests rel=noopener target=_blank>WebTestClient</a>，该解析可以解析到正在运行的服务器的相对链接，并带有用于验证响应的专用 API，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.context.SpringBootTest.WebEnvironment;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.web.reactive.server.WebTestClient;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RandomPortWebTestClientExampleTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> WebTestClient webClient;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">exampleTest</span><span class=params>()</span> {</span><br><span class=line>		<span class=built_in>this</span>.webClient.get().uri(<span class=string>"/"</span>).exchange().expectStatus().isOk()</span><br><span class=line>				.expectBody(String.class).isEqualTo(<span class=string>"Hello World"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>此设置在 Classpath 上需要<code>spring-webflux</code>。如果您不能或不会添加 webflux，Spring Boot 还将提供<code>TestRestTemplate</code>功能：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.context.SpringBootTest.WebEnvironment;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.web.client.TestRestTemplate;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.assertj.core.api.Assertions.assertThat;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RandomPortTestRestTemplateExampleTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> TestRestTemplate restTemplate;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">exampleTest</span><span class=params>()</span> {</span><br><span class=line>		<span class=type>String</span> <span class=variable>body</span> <span class=operator>=</span> <span class=built_in>this</span>.restTemplate.getForObject(<span class=string>"/"</span>, String.class);</span><br><span class=line>		assertThat(body).isEqualTo(<span class=string>"Hello World"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-3-6、使用-JMX><a title="3.23.3.6、使用 JMX" class=headerlink href=#3-23-3-6、使用-JMX></a>3.23.3.6、使用 JMX</h4><p>由于测试上下文框架缓存上下文，因此默认情况下禁用 JMX 以防止相同组件在同一域上注册。如果此类测试需要访问<code>MBeanServer</code>，也请考虑将其标记为脏：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@SpringBootTest(properties = "spring.jmx.enabled=true")</span></span><br><span class=line><span class=meta>@DirtiesContext</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SampleJmxTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> MBeanServer mBeanServer;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">exampleTest</span><span class=params>()</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-3-7、模拟-bean-和-Spybean><a title="3.23.3.7、模拟 bean 和 Spybean" class=headerlink href=#3-23-3-7、模拟-bean-和-Spybean></a>3.23.3.7、模拟 bean 和 Spybean</h4><p>运行测试时，有时有必要在应用程序上下文中模拟某些组件。例如，您可能在开发期间无法使用某些远程服务的外观。当您要模拟在实际环境中可能难以触发的故障时，模拟功能也很有用。<p>Spring Boot 包含<code>@MockBean</code>注解，可用于为<code>ApplicationContext</code>中的 bean 定义 Mockito 模拟。您可以使用 Comments 添加新的 bean 或替换单个现有的 bean 定义。注解可以直接用于测试类，测试中的字段或<code>@Configuration</code>类和字段。在字段上使用时，还将注入创建的模拟的实例。每种测试方法后，模拟 bean 都会自动重置。<blockquote><p>如果您的测试使用 Spring Boot 的测试 Comments 之一(例如<code>@SpringBootTest</code>)，那么此功能将自动启用。要以其他方式使用此功能，必须显式添加侦听器，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=meta>@TestExecutionListeners(MockitoTestExecutionListener.class)</span></span><br></pre></table></figure></blockquote><p>下面的示例使用模拟实现替换现有的<code>RemoteService</code> bean：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.*;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.context.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.*;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.assertj.core.api.Assertions.*;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.mockito.BDDMockito.*;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@SpringBootTest</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyTests</span> {</span><br><span class=line>	<span class=meta>@MockBean</span></span><br><span class=line>	<span class=keyword>private</span> RemoteService remoteService;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> Reverser reverser;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">exampleTest</span><span class=params>()</span> {</span><br><span class=line>		<span class=comment>// RemoteService has been injected into the reverser bean</span></span><br><span class=line>		given(<span class=built_in>this</span>.remoteService.someCall()).willReturn(<span class=string>"mock"</span>);</span><br><span class=line>		<span class=type>String</span> <span class=variable>reverse</span> <span class=operator>=</span> reverser.reverseSomeCall();</span><br><span class=line>		assertThat(reverse).isEqualTo(<span class=string>"kcom"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>另外，您可以使用<code>@SpyBean</code>将任何现有的 bean 与 Mockito <code>spy</code>包装在一起。有关详细信息，请参见<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/test/mock/mockito/SpyBean.html rel=noopener target=_blank>Javadoc</a>。<blockquote><p>Spring 的测试框架在测试之间缓存应用程序上下文，并为共享相同配置的测试重用上下文，而<code>@MockBean</code>或<code>@SpyBean</code>的使用会影响缓存键，这很可能会增加上下文的数量。<p>如果您使用<code>@SpyBean</code>监视具有通过名称引用参数的<code>@Cacheable</code>方法的 bean，则您的应用程序必须使用<code>-parameters</code>进行编译。这样可以确保一旦侦察到 bean，就可以将参数名称用于缓存基础结构。</blockquote><h4 id=3-23-3-8、自动配置的测试><a class=headerlink href=#3-23-3-8、自动配置的测试 title=3.23.3.8、自动配置的测试></a>3.23.3.8、自动配置的测试</h4><p>Spring Boot 的自动配置系统适用于应用程序，但有时对于测试来说可能有点过多。它通常仅有助于加载测试应用程序“切片”所需的配置部分。例如，您可能想要测试 Spring MVC 控制器是否正确 Map 了 URL，并且您不想在这些测试中涉及数据库调用，或者您想要测试 JPA 实体，并且对那些 JPA 实体不感兴趣。测试运行。<p><code>spring-boot-test-autoconfigure</code>模块包含许多 Comments，可用于自动配置此类“切片”。它们中的每一个都以类似的方式工作，提供了一个<code>@…Test</code>注解，该注解加载了<code>ApplicationContext</code>和一个或多个<code>@AutoConfigure…</code>注解，这些注解可用于自定义自动配置设置。<blockquote><p>每个切片将组件扫描限制为适当的组件，并加载一组非常受限制的自动配置类。如果您需要排除其中之一，则大多数<code>@…Test</code>Comments 都提供<code>excludeAutoConfiguration</code>属性。或者，您可以使用<code>@ImportAutoConfiguration#exclude</code>。<p>不支持在一个测试中使用多个<code>@…Test</code>Comments 来包含多个“切片”。如果您需要多个“切片”，请选择<code>@…Test</code>Comments 之一，并手动添加其他“切片”的<code>@AutoConfigure…</code>Comments。<p>也可以将<code>@AutoConfigure…</code>Comments 与标准<code>@SpringBootTest</code>Comments 一起使用。如果您对“切片”应用程序不感兴趣，但需要一些自动配置的测试 bean，则可以使用此组合。</blockquote><h4 id=3-23-3-9、自动配置的-JSON-测试><a title="3.23.3.9、自动配置的 JSON 测试" class=headerlink href=#3-23-3-9、自动配置的-JSON-测试></a>3.23.3.9、自动配置的 JSON 测试</h4><p>要测试对象 JSON 序列化和反序列化是否按预期工作，可以使用<code>@JsonTest</code>注解。 <code>@JsonTest</code>自动配置可用的受支持的 JSON Map 器，该 Map 器可以是以下库之一：<ul><li>Jackson<code>ObjectMapper</code>，任何<code>@JsonComponent</code>beans 和任何 Jackson<code>Module</code> s<li><code>Gson</code><li><code>Jsonb</code></ul><blockquote><p><code>@JsonTest</code>启用的自动配置的列表可以为<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/test-auto-configuration.html rel=noopener target=_blank>见附录</a>。</blockquote><p>如果需要配置自动配置的元素，则可以使用<code>@AutoConfigureJsonTesters</code>Comments。<p>Spring Boot 包括基于 AssertJ 的助手，这些助手与 JSONAssert 和 JsonPath 库一起使用，以检查 JSON 是否按预期方式显示。 <code>JacksonTester</code>，<code>GsonTester</code>，<code>JsonbTester</code>和<code>BasicJsonTester</code>类可以分别用于 Jackson，Gson，Jsonb 和 Strings。使用<code>@JsonTest</code>时，测试类上的任何帮助程序字段都可以为<code>@Autowired</code>。以下示例显示了 Jackson 的测试类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.*;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.json.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.context.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.json.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.*;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.assertj.core.api.Assertions.*;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@JsonTest</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyJsonTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> JacksonTester&LTVehicleDetails> json;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testSerialize</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		<span class=type>VehicleDetails</span> <span class=variable>details</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">VehicleDetails</span>(<span class=string>"Honda"</span>, <span class=string>"Civic"</span>);</span><br><span class=line>		<span class=comment>// Assert against a `.json` file in the same package as the test</span></span><br><span class=line>		assertThat(<span class=built_in>this</span>.json.write(details)).isEqualToJson(<span class=string>"expected.json"</span>);</span><br><span class=line>		<span class=comment>// Or use JSON path based assertions</span></span><br><span class=line>		assertThat(<span class=built_in>this</span>.json.write(details)).hasJsonPathStringValue(<span class=string>"@.make"</span>);</span><br><span class=line>		assertThat(<span class=built_in>this</span>.json.write(details)).extractingJsonPathStringValue(<span class=string>"@.make"</span>)</span><br><span class=line>				.isEqualTo(<span class=string>"Honda"</span>);</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testDeserialize</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		<span class=type>String</span> <span class=variable>content</span> <span class=operator>=</span> <span class=string>"{\"make\":\"Ford\",\"model\":\"Focus\"}"</span>;</span><br><span class=line>		assertThat(<span class=built_in>this</span>.json.parse(content))</span><br><span class=line>				.isEqualTo(<span class=keyword>new</span> <span class="title class_">VehicleDetails</span>(<span class=string>"Ford"</span>, <span class=string>"Focus"</span>));</span><br><span class=line>		assertThat(<span class=built_in>this</span>.json.parseObject(content).getMake()).isEqualTo(<span class=string>"Ford"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>JSON 帮助程序类也可以直接在标准单元测试中使用。这样做，如果不使用<code>@JsonTest</code>，请在您的<code>@Before</code>方法中调用帮助程序的<code>initFields</code>方法。</blockquote><h4 id=3-23-3-10、自动配置的-Spring-MVC-测试><a title="3.23.3.10、自动配置的 Spring MVC 测试" class=headerlink href=#3-23-3-10、自动配置的-Spring-MVC-测试></a>3.23.3.10、自动配置的 Spring MVC 测试</h4><p>要测试 Spring MVC 控制器是否按预期工作，请使用<code>@WebMvcTest</code>注解。 <code>@WebMvcTest</code>自动配置 Spring MVC 基础结构，并将扫描的 Bean 限制为<code>@Controller</code>，<code>@ControllerAdvice</code>，<code>@JsonComponent</code>，<code>Converter</code>，<code>GenericConverter</code>，<code>Filter</code>，<code>WebMvcConfigurer</code>和<code>HandlerMethodArgumentResolver</code>。使用此 Comments 时，不扫描常规的<code>@Component</code> bean。<blockquote><p><code>@WebMvcTest</code>启用的自动配置设置的列表可以为<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/test-auto-configuration.html rel=noopener target=_blank>见附录</a>。<p>如果您需要注册其他组件，例如 Jackson <code>Module</code>，则可以在测试中使用<code>@Import</code>导入其他配置类。</blockquote><p>通常，<code>@WebMvcTest</code>限于单个控制器，并与<code>@MockBean</code>结合使用以为所需的协作者提供模拟实现。<p><code>@WebMvcTest</code>也会自动配置<code>MockMvc</code>。 Mock MVC 提供了一种强大的方法来快速测试 MVC 控制器，而无需启动完整的 HTTP 服务器。<blockquote><p>您还可以通过用<code>@AutoConfigureMockMvc</code>Comments 非<code>@WebMvcTest</code>(例如<code>@SpringBootTest</code>)来自动配置<code>MockMvc</code>。以下示例使用<code>MockMvc</code>：</blockquote><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.*;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.web.servlet.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.assertj.core.api.Assertions.*;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.mockito.BDDMockito.*;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@WebMvcTest(UserVehicleController.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyControllerTests</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> MockMvc mvc;</span><br><span class=line></span><br><span class=line>	<span class=meta>@MockBean</span></span><br><span class=line>	<span class=keyword>private</span> UserVehicleService userVehicleService;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testExample</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		given(<span class=built_in>this</span>.userVehicleService.getVehicleDetails(<span class=string>"sboot"</span>))</span><br><span class=line>				.willReturn(<span class=keyword>new</span> <span class="title class_">VehicleDetails</span>(<span class=string>"Honda"</span>, <span class=string>"Civic"</span>));</span><br><span class=line>		<span class=built_in>this</span>.mvc.perform(get(<span class=string>"/sboot/vehicle"</span>).accept(MediaType.TEXT_PLAIN))</span><br><span class=line>				.andExpect(status().isOk()).andExpect(content().string(<span class=string>"Honda Civic"</span>));</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>如果您需要配置自动配置的元素(例如，当应用 servlet 过滤器时)，则可以使用<code>@AutoConfigureMockMvc</code>注解中的属性。</blockquote><p>如果使用 HtmlUnit 或 Selenium，则自动配置还会提供 HTMLUnit <code>WebClient</code> bean 和/或<code>WebDriver</code> bean。以下示例使用 HtmlUnit：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> com.gargoylesoftware.htmlunit.*;</span><br><span class=line><span class=keyword>import</span> org.junit.*;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.web.servlet.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.assertj.core.api.Assertions.*;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.mockito.BDDMockito.*;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@WebMvcTest(UserVehicleController.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyHtmlUnitTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> WebClient webClient;</span><br><span class=line>	<span class=meta>@MockBean</span></span><br><span class=line>	<span class=keyword>private</span> UserVehicleService userVehicleService;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testExample</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		given(<span class=built_in>this</span>.userVehicleService.getVehicleDetails(<span class=string>"sboot"</span>))</span><br><span class=line>				.willReturn(<span class=keyword>new</span> <span class="title class_">VehicleDetails</span>(<span class=string>"Honda"</span>, <span class=string>"Civic"</span>));</span><br><span class=line>		<span class=type>HtmlPage</span> <span class=variable>page</span> <span class=operator>=</span> <span class=built_in>this</span>.webClient.getPage(<span class=string>"/sboot/vehicle.html"</span>);</span><br><span class=line>		assertThat(page.getBody().getTextContent()).isEqualTo(<span class=string>"Honda Civic"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>默认情况下，Spring Boot 将<code>WebDriver</code> bean 放在特殊的“作用域”中，以确保驱动程序在每次测试后退出并注入新实例。如果您不希望出现这种情况，可以将<code>@Scope("singleton")</code>添加到<code>WebDriver</code> <code>@Bean</code>定义中。<p>Spring Boot 创建的<code>webDriver</code>作用域将替换任何用户定义的同名作用域。如果定义自己的<code>webDriver</code>范围，则使用<code>@WebMvcTest</code>时可能会停止工作。</blockquote><p>如果您在 Classpath 上具有 Spring Security，则<code>@WebMvcTest</code>还将扫描<code>WebSecurityConfigurer</code> bean。您可以使用 Spring Security 的测试支持，而不是完全禁用此类测试的安全性。有关如何使用 Spring Security 的<code>MockMvc</code>支持的更多详细信息，可以在此* <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/howto-use-test-with-spring-security.html rel=noopener target=_blank>使用 Spring Security 进行测试</a> *操作方法部分中找到。<blockquote><p>有时编写 Spring MVC 测试是不够的。 Spring Boot 可以帮助您运行<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-with-running-server rel=noopener target=_blank>使用实际服务器进行完整的端到端测试</a>。</blockquote><h4 id=3-23-3-11、自动配置的-Spring-WebFlux-测试><a title="3.23.3.11、自动配置的 Spring WebFlux 测试" class=headerlink href=#3-23-3-11、自动配置的-Spring-WebFlux-测试></a>3.23.3.11、自动配置的 Spring WebFlux 测试</h4><p>要测试<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference//web-reactive.html rel=noopener target=_blank>Spring WebFlux</a>控制器是否按预期工作，可以使用<code>@WebFluxTest</code>注解。 <code>@WebFluxTest</code>自动配置 Spring WebFlux 基础结构，并将扫描的 bean 限制为<code>@Controller</code>，<code>@ControllerAdvice</code>，<code>@JsonComponent</code>，<code>Converter</code>，<code>GenericConverter</code>和<code>WebFluxConfigurer</code>。使用<code>@WebFluxTest</code>注解时，不扫描常规<code>@Component</code> bean。<blockquote><p><code>@WebFluxTest</code>启用的自动配置的列表可以为<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/test-auto-configuration.html rel=noopener target=_blank>见附录</a>。<p>如果您需要注册其他组件，例如 Jackson <code>Module</code>，则可以在测试中使用<code>@Import</code>导入其他配置类。</blockquote><p><code>@WebFluxTest</code>通常仅限于单个控制器，并与<code>@MockBean</code>注解结合使用以为所需的协作者提供模拟实现。<p><code>@WebFluxTest</code>还自动配置<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#webtestclient rel=noopener target=_blank>WebTestClient</a>，它提供了一种强大的方法来快速测试 WebFlux 控制器而无需启动完整的 HTTP 服务器。<blockquote><p>您还可以通过用<code>@AutoConfigureWebTestClient</code>Comments 非<code>@WebFluxTest</code>(例如<code>@SpringBootTest</code>)来自动配置<code>WebTestClient</code>。以下示例显示了同时使用<code>@WebFluxTest</code>和<code>WebTestClient</code>的类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.http.MediaType;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.web.reactive.server.WebTestClient;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@WebFluxTest(UserVehicleController.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyControllerTests</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> WebTestClient webClient;</span><br><span class=line></span><br><span class=line>	<span class=meta>@MockBean</span></span><br><span class=line>	<span class=keyword>private</span> UserVehicleService userVehicleService;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testExample</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		given(<span class=built_in>this</span>.userVehicleService.getVehicleDetails(<span class=string>"sboot"</span>))</span><br><span class=line>				.willReturn(<span class=keyword>new</span> <span class="title class_">VehicleDetails</span>(<span class=string>"Honda"</span>, <span class=string>"Civic"</span>));</span><br><span class=line>		<span class=built_in>this</span>.webClient.get().uri(<span class=string>"/sboot/vehicle"</span>).accept(MediaType.TEXT_PLAIN)</span><br><span class=line>				.exchange()</span><br><span class=line>				.expectStatus().isOk()</span><br><span class=line>				.expectBody(String.class).isEqualTo(<span class=string>"Honda Civic"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>WebFlux 应用程序仅支持此设置，因为在模拟的 Web 应用程序中使用<code>WebTestClient</code>目前仅适用于 WebFlux。<p><code>@WebFluxTest</code>无法检测通过功能 Web 框架注册的路由。要在上下文中测试<code>RouterFunction</code> bean，请考虑自己通过<code>@Import</code>或使用<code>@SpringBootTest</code>导入<code>RouterFunction</code>。<p>有时编写 Spring WebFlux 测试是不够的。 Spring Boot 可以帮助您运行<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-with-running-server rel=noopener target=_blank>使用实际服务器进行完整的端到端测试</a>。</blockquote><h4 id=3-23-3-12、自动配置的数据-JPA-测试><a title="3.23.3.12、自动配置的数据 JPA 测试" class=headerlink href=#3-23-3-12、自动配置的数据-JPA-测试></a>3.23.3.12、自动配置的数据 JPA 测试</h4><p>您可以使用<code>@DataJpaTest</code>注解来测试 JPA 应用程序。默认情况下，它配置一个内存嵌入式数据库，扫描<code>@Entity</code>类，并配置 Spring Data JPA 存储库。常规<code>@Component</code> bean 未加载到<code>ApplicationContext</code>中。<p>默认情况下，数据 JPA 测试是事务性的，并在每次测试结束时回滚。有关更多详细信息，请参见《 Spring Framework 参考文档》中的<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions rel=noopener target=_blank>relevant section</a>。如果这不是您想要的，则可以按以下方式禁用测试或整个类的事务 Management：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line><span class=keyword>import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class=line><span class=keyword>import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@DataJpaTest</span></span><br><span class=line><span class=meta>@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleNonTransactionalTests</span> {</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><p>数据 JPA 测试还可以注入<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-test-autoconfigure/src/main/java/org/springframework/boot/test/autoconfigure/orm/jpa/TestEntityManager.java rel=noopener target=_blank>TestEntityManager</a> bean，它提供了专门为测试设计的标准 JPA <code>EntityManager</code>的替代方案。如果要在<code>@DataJpaTest</code>实例之外使用<code>TestEntityManager</code>，则也可以使用<code>@AutoConfigureTestEntityManager</code>Comments。如果需要，也可以提供<code>JdbcTemplate</code>。以下示例显示了正在使用的<code>@DataJpaTest</code>注解：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.*;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.orm.jpa.*;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.assertj.core.api.Assertions.*;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@DataJpaTest</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleRepositoryTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> TestEntityManager entityManager;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> UserRepository repository;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testExample</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		<span class=built_in>this</span>.entityManager.persist(<span class=keyword>new</span> <span class="title class_">User</span>(<span class=string>"sboot"</span>, <span class=string>"1234"</span>));</span><br><span class=line>		<span class=type>User</span> <span class=variable>user</span> <span class=operator>=</span> <span class=built_in>this</span>.repository.findByUsername(<span class=string>"sboot"</span>);</span><br><span class=line>		assertThat(user.getUsername()).isEqualTo(<span class=string>"sboot"</span>);</span><br><span class=line>		assertThat(user.getVin()).isEqualTo(<span class=string>"1234"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>内存嵌入式数据库通常运行良好，不需要任何安装，因此通常可以很好地进行测试。但是，如果您希望对真实数据库运行测试，则可以使用<code>@AutoConfigureTestDatabase</code>注解，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@DataJpaTest</span></span><br><span class=line><span class=meta>@AutoConfigureTestDatabase(replace=Replace.NONE)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleRepositoryTests</span> {</span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-3-13、自动配置的-JDBC-测试><a title="3.23.3.13、自动配置的 JDBC 测试" class=headerlink href=#3-23-3-13、自动配置的-JDBC-测试></a>3.23.3.13、自动配置的 JDBC 测试</h4><p><code>@JdbcTest</code>与<code>@DataJpaTest</code>类似，但适用于只需要<code>DataSource</code>并且不使用 Spring Data JDBC 的测试。默认情况下，它配置内存嵌入式数据库和<code>JdbcTemplate</code>。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。<p>缺省情况下，JDBC 测试是事务性的，并在每次测试结束时回滚。有关更多详细信息，请参见《 Spring Framework 参考文档》中的<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions rel=noopener target=_blank>relevant section</a>。如果这不是您想要的，则可以为测试或整个类禁用事务 Management，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.jdbc.JdbcTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line><span class=keyword>import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class=line><span class=keyword>import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@JdbcTest</span></span><br><span class=line><span class=meta>@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleNonTransactionalTests</span> {</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><p>如果您希望测试针对真实数据库运行，则可以使用 Comments，方式与<code>DataJpaTest</code>相同。 (请参阅“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test rel=noopener target=_blank>第 45.3.12 节，“自动配置的数据 JPA 测试”</a>”。)<h4 id=3-23-3-14、自动配置的数据-JDBC-测试><a title="3.23.3.14、自动配置的数据 JDBC 测试" class=headerlink href=#3-23-3-14、自动配置的数据-JDBC-测试></a>3.23.3.14、自动配置的数据 JDBC 测试</h4><p><code>@DataJdbcTest</code>与<code>@JdbcTest</code>类似，但适用于使用 Spring Data JDBC 存储库的测试。默认情况下，它配置一个内存嵌入式数据库<code>JdbcTemplate</code>和 Spring Data JDBC 存储库。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。<p>默认情况下，Data JDBC 测试是事务性的，并在每个测试结束时回滚。有关更多详细信息，请参见《 Spring Framework 参考文档》中的<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions rel=noopener target=_blank>relevant section</a>。如果这不是您想要的，则可以禁用测试或整个测试类的事务 Management，即<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test rel=noopener target=_blank>在 JDBC 示例中显示</a>。<p>如果您希望测试针对真实数据库运行，则可以使用 Comments，方式与<code>DataJpaTest</code>相同。 (请参阅“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test rel=noopener target=_blank>“自动配置的数据 JPA 测试”</a>”。)<h4 id=3-23-3-15、自动配置的-jOOQ-测试><a title="3.23.3.15、自动配置的 jOOQ 测试" class=headerlink href=#3-23-3-15、自动配置的-jOOQ-测试></a>3.23.3.15、自动配置的 jOOQ 测试</h4><p>您可以以与<code>@JdbcTest</code>类似的方式使用<code>@JooqTest</code>，但可以用于与 jOOQ 相关的测试。由于 jOOQ 严重依赖与数据库模式相对应的基于 Java 的模式，因此使用现有的<code>DataSource</code>。如果要将其替换为内存数据库，则可以使用<code>@AutoConfigureTestDatabase</code>覆盖这些设置。 (有关将 jOOQ 与 Spring Boot 结合使用的更多信息，请参阅本章前面的“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-sql.html#boot-features-jooq rel=noopener target=_blank>第 30.6 节“使用 jOOQ”</a>”。)常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。<p><code>@JooqTest</code>配置<code>DSLContext</code>。常规<code>@Component</code> bean 未加载到<code>ApplicationContext</code>中。以下示例显示了正在使用的<code>@JooqTest</code>Comments：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.jooq.DSLContext;</span><br><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.jooq.JooqTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@JooqTest</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleJooqTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> DSLContext dslContext;</span><br><span class=line>}</span><br></pre></table></figure><p>JOOQ 测试是事务性的，默认情况下会在每个测试结束时回滚。如果这不是您想要的，则可以禁用测试或整个测试类的事务 Management，例如<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test rel=noopener target=_blank>在 JDBC 示例中显示</a>。<h4 id=3-23-3-16、自动配置的-Data-MongoDB-测试><a title="3.23.3.16、自动配置的 Data MongoDB 测试" class=headerlink href=#3-23-3-16、自动配置的-Data-MongoDB-测试></a>3.23.3.16、自动配置的 Data MongoDB 测试</h4><p>您可以使用<code>@DataMongoTest</code>测试 MongoDB 应用程序。默认情况下，它配置内存嵌入式 MongoDB(如果可用)，配置<code>MongoTemplate</code>，扫描<code>@Document</code>类，并配置 Spring Data MongoDB 存储库。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。 (有关将 MongoDB 与 Spring Boot 结合使用的更多信息，请参阅本章前面的“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-nosql.html#boot-features-mongodb rel=noopener target=_blank>第 31.2 节“ MongoDB”</a>”。)<p>此类显示正在使用的<code>@DataMongoTest</code>注解：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.data.mongodb.core.MongoTemplate;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@DataMongoTest</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleDataMongoTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> MongoTemplate mongoTemplate;</span><br><span class=line>	<span class=comment>//</span></span><br><span class=line>}</span><br></pre></table></figure><p>内存嵌入式 MongoDB 通常运行良好，不需要任何开发人员安装，因此通常可以很好地用于测试。但是，如果您希望对真实的 MongoDB 服务器运行测试，则应排除嵌入式 MongoDB 自动配置，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line> <span class=keyword>import</span> org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@DataMongoTest(excludeAutoConfiguration = EmbeddedMongoAutoConfiguration.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleDataMongoNonEmbeddedTests</span> {</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-3-17、自动配置的数据-Neo4j-测试><a title="3.23.3.17、自动配置的数据 Neo4j 测试" class=headerlink href=#3-23-3-17、自动配置的数据-Neo4j-测试></a>3.23.3.17、自动配置的数据 Neo4j 测试</h4><p>您可以使用<code>@DataNeo4jTest</code>测试 Neo4j 应用程序。默认情况下，它使用内存中嵌入式 Neo4j(如果有嵌入式驱动程序可用)，扫描<code>@NodeEntity</code>类，并配置 Spring Data Neo4j 存储库。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。 (有关将 Neo4J 与 Spring Boot 结合使用的更多信息，请参阅本章前面的“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-nosql.html#boot-features-neo4j rel=noopener target=_blank>第 31.3 节“ Neo4j”</a>”。)<p>以下示例显示了在 Spring Boot 中使用 Neo4J 测试的典型设置：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@DataNeo4jTest</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleDataNeo4jTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> YourRepository repository;</span><br><span class=line></span><br><span class=line>	<span class=comment>//</span></span><br><span class=line>}</span><br></pre></table></figure><p>默认情况下，Data Neo4j 测试是事务性的，并在每个测试结束时回滚。有关更多详细信息，请参见《 Spring Framework 参考文档》中的<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions rel=noopener target=_blank>relevant section</a>。如果这不是您想要的，则可以为测试或整个类禁用事务 Management，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line><span class=keyword>import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class=line><span class=keyword>import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@DataNeo4jTest</span></span><br><span class=line><span class=meta>@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleNonTransactionalTests</span> {</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-3-18、自动配置的数据-Redis-测试><a title="3.23.3.18、自动配置的数据 Redis 测试" class=headerlink href=#3-23-3-18、自动配置的数据-Redis-测试></a>3.23.3.18、自动配置的数据 Redis 测试</h4><p>您可以使用<code>@DataRedisTest</code>测试 Redis 应用程序。默认情况下，它将扫描<code>@RedisHash</code>类并配置 Spring Data Redis 存储库。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。 (有关在 Spring Boot 中使用 Redis 的更多信息，请参阅本章前面的“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-nosql.html#boot-features-redis rel=noopener target=_blank>“ Redis”</a>”。)<p>以下示例显示了正在使用的<code>@DataRedisTest</code>注解：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@DataRedisTest</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleDataRedisTests</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> YourRepository repository;</span><br><span class=line></span><br><span class=line>	<span class=comment>//</span></span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-3-19、自动配置的数据-LDAP-测试><a title="3.23.3.19、自动配置的数据 LDAP 测试" class=headerlink href=#3-23-3-19、自动配置的数据-LDAP-测试></a>3.23.3.19、自动配置的数据 LDAP 测试</h4><p>您可以使用<code>@DataLdapTest</code>测试 LDAP 应用程序。默认情况下，它配置内存嵌入式 LDAP(如果可用)，配置<code>LdapTemplate</code>，扫描<code>@Entry</code>类，并配置 Spring Data LDAP 存储库。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。 (有关将 LDAP 与 Spring Boot 结合使用的更多信息，请参阅本章前面的“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-nosql.html#boot-features-ldap rel=noopener target=_blank>“ LDAP”</a>”。)<p>以下示例显示了正在使用的<code>@DataLdapTest</code>注解：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.ldap.core.LdapTemplate;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@DataLdapTest</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleDataLdapTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> LdapTemplate ldapTemplate;</span><br><span class=line>	<span class=comment>//</span></span><br><span class=line>}</span><br></pre></table></figure><p>内存嵌入式 LDAP 通常非常适合测试，因为它速度快并且不需要安装任何开发人员。但是，如果您希望针对真实的 LDAP 服务器运行测试，则应排除嵌入式 LDAP 自动配置，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@DataLdapTest(excludeAutoConfiguration = EmbeddedLdapAutoConfiguration.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleDataLdapNonEmbeddedTests</span> {</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-3-20、自动配置的-REST-Client-端><a title="3.23.3.20、自动配置的 REST Client 端" class=headerlink href=#3-23-3-20、自动配置的-REST-Client-端></a>3.23.3.20、自动配置的 REST Client 端</h4><p>您可以使用<code>@RestClientTest</code>注解来测试 REST Client 端。默认情况下，它会自动配置 Jackson，GSON 和 Jsonb 支持，配置<code>RestTemplateBuilder</code>，并添加对<code>MockRestServiceServer</code>的支持。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。<p>应该使用<code>@RestClientTest</code>的<code>value</code>或<code>components</code>属性指定要测试的特定 bean，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@RestClientTest(RemoteVehicleDetailsService.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleRestClientTest</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> RemoteVehicleDetailsService service;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> MockRestServiceServer server;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">getVehicleDetailsWhenResultIsSuccessShouldReturnDetails</span><span class=params>()</span></span><br><span class=line>			<span class=keyword>throws</span> Exception {</span><br><span class=line>		<span class=built_in>this</span>.server.expect(requestTo(<span class=string>"/greet/details"</span>))</span><br><span class=line>				.andRespond(withSuccess(<span class=string>"hello"</span>, MediaType.TEXT_PLAIN));</span><br><span class=line>		<span class=type>String</span> <span class=variable>greeting</span> <span class=operator>=</span> <span class=built_in>this</span>.service.callRestService();</span><br><span class=line>		assertThat(greeting).isEqualTo(<span class=string>"hello"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-3-21、自动配置的-Spring-REST-文档测试><a title="3.23.3.21、自动配置的 Spring REST 文档测试" class=headerlink href=#3-23-3-21、自动配置的-Spring-REST-文档测试></a>3.23.3.21、自动配置的 Spring REST 文档测试</h4><p>您可以在 Mock MVC，REST 保证或 WebTestClient 的测试中使用<code>@AutoConfigureRestDocs</code>注解来使用<a href=https://projects.spring.io/spring-restdocs/ rel=noopener target=_blank>Spring REST 文件</a>。它消除了 Spring REST Docs 中对 JUnit 规则的需求。<p><code>@AutoConfigureRestDocs</code>可用于覆盖默认输出目录(如果使用 Maven，则使用<code>target/generated-snippets</code>；如果使用 Gradle，则使用<code>build/generated-snippets</code>)。它也可以用于配置出现在任何记录的 URI 中的主机，方案和端口。<h5 id=使用-Mock-MVC-自动配置的-Spring-REST-Docs-测试><a title="使用 Mock MVC 自动配置的 Spring REST Docs 测试" class=headerlink href=#使用-Mock-MVC-自动配置的-Spring-REST-Docs-测试></a>使用 Mock MVC 自动配置的 Spring REST Docs 测试</h5><p><code>@AutoConfigureRestDocs</code>自定义<code>MockMvc</code> bean 以使用 Spring REST Docs。您可以使用<code>@Autowired</code>注入它，并像通常使用 Mock MVC 和 Spring REST Docs 一样在测试中使用它，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.http.MediaType;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@WebMvcTest(UserController.class)</span></span><br><span class=line><span class=meta>@AutoConfigureRestDocs</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">UserDocumentationTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> MockMvc mvc;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">listUsers</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		<span class=built_in>this</span>.mvc.perform(get(<span class=string>"/users"</span>).accept(MediaType.TEXT_PLAIN))</span><br><span class=line>				.andExpect(status().isOk())</span><br><span class=line>				.andDo(document(<span class=string>"list-users"</span>));</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>如果您需要对 Spring REST Docs 配置进行更多控制，而不是<code>@AutoConfigureRestDocs</code>属性所提供的控制，则可以使用<code>RestDocsMockMvcConfigurationCustomizer</code> bean，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@TestConfiguration</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">CustomizationConfiguration</span></span><br><span class=line>		<span class=keyword>implements</span> <span class="title class_">RestDocsMockMvcConfigurationCustomizer</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">customize</span><span class=params>(MockMvcRestDocumentationConfigurer configurer)</span> {</span><br><span class=line>		configurer.snippets().withTemplateFormat(TemplateFormats.markdown());</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><p>如果要使用 Spring REST Docs 对参数化输出目录的支持，则可以创建<code>RestDocumentationResultHandler</code> bean。自动配置使用此结果处理程序调用<code>alwaysDo</code>，从而使每个<code>MockMvc</code>调用自动生成默认片段。以下示例显示正在定义的<code>RestDocumentationResultHandler</code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@TestConfiguration</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">ResultHandlerConfiguration</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> RestDocumentationResultHandler <span class="title function_">restDocumentation</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> MockMvcRestDocumentation.document(<span class=string>"{method-name}"</span>);</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><h5 id=具有-REST-保证的自动配置的-Spring-REST-文档测试><a title="具有 REST 保证的自动配置的 Spring REST 文档测试" class=headerlink href=#具有-REST-保证的自动配置的-Spring-REST-文档测试></a>具有 REST 保证的自动配置的 Spring REST 文档测试</h5><p><code>@AutoConfigureRestDocs</code>使预配置为使用 Spring REST 文档的<code>RequestSpecification</code> bean 可用于您的测试。您可以使用<code>@Autowired</code>注入它，并像在使用 REST Assured 和 Spring REST Docs 时一样，在测试中使用它，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> io.restassured.specification.RequestSpecification;</span><br><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.context.SpringBootTest.WebEnvironment;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.web.server.LocalServerPort;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> io.restassured.RestAssured.given;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.hamcrest.CoreMatchers.is;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.springframework.restdocs.restassured3.RestAssuredRestDocumentation.document;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></span><br><span class=line><span class=meta>@AutoConfigureRestDocs</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">UserDocumentationTests</span> {</span><br><span class=line>	<span class=meta>@LocalServerPort</span></span><br><span class=line>	<span class=keyword>private</span> <span class=type>int</span> port;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> RequestSpecification documentationSpec;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">listUsers</span><span class=params>()</span> {</span><br><span class=line>		given(<span class=built_in>this</span>.documentationSpec).filter(document(<span class=string>"list-users"</span>)).when()</span><br><span class=line>				.port(<span class=built_in>this</span>.port).get(<span class=string>"/"</span>).then().assertThat().statusCode(is(<span class=number>200</span>));</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>如果您需要对 Spring REST Docs 配置进行更多控制而不是<code>@AutoConfigureRestDocs</code>属性提供的控制，则可以使用<code>RestDocsRestAssuredConfigurationCustomizer</code> bean，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@TestConfiguration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">CustomizationConfiguration</span></span><br><span class=line>		<span class=keyword>implements</span> <span class="title class_">RestDocsRestAssuredConfigurationCustomizer</span> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">customize</span><span class=params>(RestAssuredRestDocumentationConfigurer configurer)</span> {</span><br><span class=line>		configurer.snippets().withTemplateFormat(TemplateFormats.markdown());</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-3-22、其他自动配置和切片><a class=headerlink href=#3-23-3-22、其他自动配置和切片 title=3.23.3.22、其他自动配置和切片></a>3.23.3.22、其他自动配置和切片</h4><p>每个切片提供一个或多个<code>@AutoConfigure…</code>注解，即定义应包含在切片中的自动配置。可以通过创建自定义<code>@AutoConfigure…</code>Comments 或仅通过向测试中添加<code>@ImportAutoConfiguration</code>来添加其他自动配置，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@JdbcTest</span></span><br><span class=line><span class=meta>@ImportAutoConfiguration(IntegrationAutoConfiguration.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleJdbcTests</span> {</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>确保不要使用常规的<code>@Import</code>Comments 来导入自动配置，因为它们是由 Spring Boot 以特定方式处理的。</blockquote><h4 id=3-23-3-23、用户配置和切片><a class=headerlink href=#3-23-3-23、用户配置和切片 title=3.23.3.23、用户配置和切片></a>3.23.3.23、用户配置和切片</h4><p>如果您以明智的方式<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-structuring-your-code.html rel=noopener target=_blank>结构化代码</a>，则您的<code>@SpringBootApplication</code>类为<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-detecting-config rel=noopener target=_blank>默认使用</a>作为测试的配置。<p>因此，重要的是不要用特定于其功能特定区域的配置设置来乱扔应用程序的主类。<p>假设您正在使用 Spring Batch，并且依赖于它的自动配置。您可以按以下方式定义<code>@SpringBootApplication</code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>@SpringBootApplication</span></span><br><span class=line><span class=meta>@EnableBatchProcessing</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SampleApplication</span> { ... }</span><br></pre></table></figure><p>因为此类是测试的源配置，所以任何切片测试实际上都尝试启动 Spring Batch，这绝对不是您想要执行的操作。建议的方法是将特定于区域的配置移到与您的应用程序相同级别的单独的<code>@Configuration</code>类，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableBatchProcessing</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BatchConfiguration</span> { ... }</span><br></pre></table></figure><blockquote><p>根据您应用程序的复杂性，您可以为自己的自定义设置一个<code>@Configuration</code>类，或者每个域区域一个类。后一种方法可让您在必要的测试中使用<code>@Import</code>注解启用它。</blockquote><p>混乱的另一个来源是 Classpath 扫描。假设在以合理的方式组织代码的同时，您需要扫描其他程序包。您的应用程序可能类似于以下代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>@SpringBootApplication</span></span><br><span class=line><span class=meta>@ComponentScan({ "com.example.app", "org.acme.another" })</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SampleApplication</span> { ... }</span><br></pre></table></figure><p>这样做有效地覆盖了默认的组件扫描指令，并且具有扫描这两个软件包的副作用，而与您选择的切片无关。例如，<code>@DataJpaTest</code>似乎突然扫描了应用程序的组件和用户配置。同样，将自定义指令移至单独的类是解决此问题的好方法。<blockquote><p>如果这不是您的选择，则可以在测试层次结构中的某个位置创建<code>@SpringBootConfiguration</code>，以便代替它使用。另外，您可以为测试指定一个源，从而禁用查找默认源的行为。</blockquote><h4 id=3-23-3-24、使用-Spock-测试-Spring-Boot-应用程序><a title="3.23.3.24、使用 Spock 测试 Spring Boot 应用程序" class=headerlink href=#3-23-3-24、使用-Spock-测试-Spring-Boot-应用程序></a>3.23.3.24、使用 Spock 测试 Spring Boot 应用程序</h4><p>如果希望使用 Spock 测试 Spring Boot 应用程序，则应在应用程序的构建中添加对 Spock 的<code>spock-spring</code>模块的依赖。 <code>spock-spring</code>将 Spring 的测试框架集成到 Spock 中。建议您使用 Spock 1.2 或更高版本，以受益于 Spock 的 Spring Framework 和 Spring Boot 集成的许多改进。有关更多详细信息，请参见<a href=http://spockframework.org/spock/docs/1.2/modules.html#_spring_module rel=noopener target=_blank>Spock 的 Spring 模块的文档</a>。<h3 id=3-23-4、测试-Util><a title="3.23.4、测试 Util" class=headerlink href=#3-23-4、测试-Util></a>3.23.4、测试 Util</h3><p>一些测试 Util 类通常在测试您的应用程序时有用，它们被打包为<code>spring-boot</code>的一部分。<h4 id=3-23-4-1、ConfigFileApplicationContextInitializer><a class=headerlink href=#3-23-4-1、ConfigFileApplicationContextInitializer title=3.23.4.1、ConfigFileApplicationContextInitializer></a>3.23.4.1、ConfigFileApplicationContextInitializer</h4><p><code>ConfigFileApplicationContextInitializer</code>是<code>ApplicationContextInitializer</code>，您可以将其应用于测试以加载 Spring Boot <code>application.properties</code>文件。如不需要以下示例所示，可以在不需要<code>@SpringBootTest</code>提供的全部功能时使用它：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta>@ContextConfiguration(classes = Config.class,</span></span><br><span class=line><span class=meta>	initializers = ConfigFileApplicationContextInitializer.class)</span></span><br></pre></table></figure><blockquote><p>单独使用<code>ConfigFileApplicationContextInitializer</code>不支持<code>@Value("${…}")</code>注入。它唯一的工作就是确保将<code>application.properties</code>文件加载到 Spring 的<code>Environment</code>中。为了获得<code>@Value</code>支持，您需要另外配置<code>PropertySourcesPlaceholderConfigurer</code>或使用<code>@SpringBootTest</code>，后者会为您自动配置一个。</blockquote><h4 id=3-23-4-2、TestPropertyValues><a class=headerlink href=#3-23-4-2、TestPropertyValues title=3.23.4.2、TestPropertyValues></a>3.23.4.2、TestPropertyValues</h4><p><code>TestPropertyValues</code>可让您快速将属性添加到<code>ConfigurableEnvironment</code>或<code>ConfigurableApplicationContext</code>。您可以使用<code>key=value</code>字符串来调用它，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>TestPropertyValues.of(<span class=string>"org=Spring"</span>, <span class=string>"name=Boot"</span>).applyTo(env);</span><br></pre></table></figure><h4 id=3-23-4-3、OutputCapture><a class=headerlink href=#3-23-4-3、OutputCapture title=3.23.4.3、OutputCapture></a>3.23.4.3、OutputCapture</h4><p><code>OutputCapture</code>是一个 JUnit <code>Rule</code>，可用于捕获<code>System.out</code>和<code>System.err</code>输出。您可以将捕获声明为<code>@Rule</code>，然后将<code>toString()</code>用于 assert，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.Rule;</span><br><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.rule.OutputCapture;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.hamcrest.Matchers.*;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.junit.Assert.*;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyTest</span> {</span><br><span class=line>	<span class=meta>@Rule</span></span><br><span class=line>	<span class=keyword>public</span> <span class=type>OutputCapture</span> <span class=variable>capture</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">OutputCapture</span>();</span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testName</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		System.out.println(<span class=string>"Hello World!"</span>);</span><br><span class=line>		assertThat(capture.toString(), containsString(<span class=string>"World"</span>));</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-4-4、TestRestTemplate><a class=headerlink href=#3-23-4-4、TestRestTemplate title=3.23.4.4、TestRestTemplate></a>3.23.4.4、TestRestTemplate</h4><blockquote><p>Spring Framework 5.0 提供了一个新的<code>WebTestClient</code>，它适用于<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-webflux-tests rel=noopener target=_blank>WebFlux 集成测试</a>和<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-with-running-server rel=noopener target=_blank>WebFlux 和 MVC 端到端测试</a>。与<code>TestRestTemplate</code>不同，它为声明提供了流畅的 API。</blockquote><p><code>TestRestTemplate</code>是 Spring <code>RestTemplate</code>的便捷替代方法，在集成测试中非常有用。您可以使用普通模板或发送基本 HTTP 身份验证(带有用户名和密码)的模板。在这两种情况下，模板都不会通过在服务器端错误上引发异常来以易于测试的方式运行。建议(但不是强制性的)使用 Apache HTTP Client(版本 4.3.2 或更高版本)。如果您在 Classpath 中具有该名称，则<code>TestRestTemplate</code>会通过适当配置 Client 端进行响应。如果确实使用 Apache 的 HTTP Client 端，则会启用一些其他易于测试的功能：<ul><li>不遵循重定向(因此您可以声明响应位置)。<li>Cookies 被忽略(因此模板是 Stateless 的)。</ul><p><code>TestRestTemplate</code>可以在集成测试中直接实例化，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyTest</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=type>TestRestTemplate</span> <span class=variable>template</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TestRestTemplate</span>();</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testRequest</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		<span class=type>HttpHeaders</span> <span class=variable>headers</span> <span class=operator>=</span> <span class=built_in>this</span>.template.getForEntity(</span><br><span class=line>				<span class=string>"http://myhost.example.com/example"</span>, String.class).getHeaders();</span><br><span class=line>		assertThat(headers.getLocation()).hasHost(<span class=string>"other.example.com"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>另外，如果您将<code>@SpringBootTest</code>Comments 与<code>WebEnvironment.RANDOM_PORT</code>或<code>WebEnvironment.DEFINED_PORT</code>一起使用，则可以注入已完全配置的<code>TestRestTemplate</code>并开始使用它。如有必要，可以通过<code>RestTemplateBuilder</code> bean 应用其他定制。未指定主机和端口的所有 URL 都会自动连接到嵌入式服务器，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SampleWebClientTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> TestRestTemplate template;</span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testRequest</span><span class=params>()</span> {</span><br><span class=line>		<span class=type>HttpHeaders</span> <span class=variable>headers</span> <span class=operator>=</span> <span class=built_in>this</span>.template.getForEntity(<span class=string>"/example"</span>, String.class)</span><br><span class=line>				.getHeaders();</span><br><span class=line>		assertThat(headers.getLocation()).hasHost(<span class=string>"other.example.com"</span>);</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=meta>@TestConfiguration</span></span><br><span class=line>	<span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">Config</span> {</span><br><span class=line></span><br><span class=line>		<span class=meta>@Bean</span></span><br><span class=line>		<span class=keyword>public</span> RestTemplateBuilder <span class="title function_">restTemplateBuilder</span><span class=params>()</span> {</span><br><span class=line>			<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">RestTemplateBuilder</span>().setConnectTimeout(Duration.ofSeconds(<span class=number>1</span>))</span><br><span class=line>					.setReadTimeout(Duration.ofSeconds(<span class=number>1</span>));</span><br><span class=line>		}</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h2 id=3-24、WebSockets><a class=headerlink href=#3-24、WebSockets title=3.24、WebSockets></a>3.24、WebSockets</h2><p>Spring Boot 为嵌入式 Tomcat，Jetty 和 Undertow 提供了 WebSockets 自动配置。如果将 war 文件部署到独立容器，Spring Boot 会假定该容器负责其 WebSocket 支持的配置。<p>Spring Framework 为 MVC Web 应用程序提供了<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#websocket rel=noopener target=_blank>丰富的 WebSocket 支持</a>，可以通过<code>spring-boot-starter-websocket</code>模块轻松访问。<p>WebSocket 支持也可用于<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web-reactive.html#webflux-websocket rel=noopener target=_blank>响应式 Web 应用程序</a>，并且需要在<code>spring-boot-starter-webflux</code>旁边包括 WebSocket API：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>javax.websocket<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>javax.websocket-api<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><h2 id=3-25、Web-Service><a title="3.25、Web Service" class=headerlink href=#3-25、Web-Service></a>3.25、Web Service</h2><p>Spring Boot 提供了 Web 服务自动配置，因此您所要做的就是定义<code>Endpoints</code>。<p><a href=https://docs.spring.io/spring-ws/docs/3.0.4.RELEASE/reference/ rel=noopener target=_blank>Spring Web Services 功能</a>可以通过<code>spring-boot-starter-webservices</code>模块轻松访问。<p>可以分别为您的 WSDL 和 XSD 自动创建<code>SimpleWsdl11Definition</code>和<code>SimpleXsdSchema</code> bean。为此，请配置其位置，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.webservices.wsdl-locations</span>=<span class=string>classpath:/wsdl</span></span><br></pre></table></figure><h2 id=3-26、使用-WebServiceTemplate-调用-Web-服务><a title="3.26、使用 WebServiceTemplate 调用 Web 服务" class=headerlink href=#3-26、使用-WebServiceTemplate-调用-Web-服务></a>3.26、使用 WebServiceTemplate 调用 Web 服务</h2><p>如果需要从应用程序调用远程 Web 服务，则可以使用<a href=https://docs.spring.io/spring-ws/docs/3.0.4.RELEASE/reference/#client-web-service-template rel=noopener target=_blank>WebServiceTemplate</a>类。由于<code>WebServiceTemplate</code>实例在使用前通常需要自定义，因此 Spring Boot 不提供任何单个自动配置的<code>WebServiceTemplate</code> bean。但是，它会自动配置<code>WebServiceTemplateBuilder</code>，可以在需要时创建<code>WebServiceTemplate</code>实例。<p>以下代码显示了一个典型示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyService</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> WebServiceTemplate webServiceTemplate;</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyService</span><span class=params>(WebServiceTemplateBuilder webServiceTemplateBuilder)</span> {</span><br><span class=line>		<span class=built_in>this</span>.webServiceTemplate = webServiceTemplateBuilder.build();</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> DetailsResp <span class="title function_">someWsCall</span><span class=params>(DetailsReq detailsReq)</span> {</span><br><span class=line>		 <span class=keyword>return</span> (DetailsResp) <span class=built_in>this</span>.webServiceTemplate.marshalSendAndReceive(detailsReq, <span class=keyword>new</span> <span class="title class_">SoapActionCallback</span>(ACTION));</span><br><span class=line></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>默认情况下，<code>WebServiceTemplateBuilder</code>使用 Classpath 上可用的 HTTP Client 端库检测合适的基于 HTTP 的<code>WebServiceMessageSender</code>。您还可以如下自定义读取和连接超时：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> WebServiceTemplate <span class="title function_">webServiceTemplate</span><span class=params>(WebServiceTemplateBuilder builder)</span> {</span><br><span class=line>	<span class=keyword>return</span> builder.messageSenders(<span class=keyword>new</span> <span class="title class_">HttpWebServiceMessageSenderBuilder</span>()</span><br><span class=line>			.setConnectTimeout(<span class=number>5000</span>).setReadTimeout(<span class=number>2000</span>).build()).build();</span><br><span class=line>}</span><br></pre></table></figure><h2 id=3-27、创建自己的自动配置><a class=headerlink href=#3-27、创建自己的自动配置 title=3.27、创建自己的自动配置></a>3.27、创建自己的自动配置</h2><p>如果您在开发共享库的公司中工作，或者在开源或商业库中工作，则可能需要开发自己的自动配置。自动配置类可以 Binding 在外部 jar 中，并且仍由 Spring Boot 拾取。<p>自动配置可以与“启动器”相关联，该“启动器”提供自动配置代码以及您将使用的典型库。我们首先介绍构建自己的自动配置所需的知识，然后 continue 进行<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-auto-configuration.html#boot-features-custom-starter rel=noopener target=_blank>创建自定义启动器所需的典型步骤</a>。<h3 id=3-27-1、了解自动配置的Bean><a class=headerlink href=#3-27-1、了解自动配置的Bean title=3.27.1、了解自动配置的Bean></a>3.27.1、了解自动配置的Bean</h3><p>在后台，自动配置是通过标准的<code>@Configuration</code>类实现的。其他<code>@Conditional</code>Comments 用于约束何时应应用自动配置。通常，自动配置类使用<code>@ConditionalOnClass</code>和<code>@ConditionalOnMissingBean</code>Comments。这样可以确保仅当找到相关的类并且没有声明自己的<code>@Configuration</code>时，自动配置才适用。<p>您可以浏览<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure rel=noopener target=_blank>spring-boot-autoconfigure</a>的源代码以查看 Spring 提供的<code>@Configuration</code>类(请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories rel=noopener target=_blank>META-INF/spring.factories</a>文件)。<h3 id=3-27-2、查找自动配置的候选人><a class=headerlink href=#3-27-2、查找自动配置的候选人 title=3.27.2、查找自动配置的候选人></a>3.27.2、查找自动配置的候选人</h3><p>Spring Boot 检查发布的 jar 中是否存在<code>META-INF/spring.factories</code>文件。该文件应在<code>EnableAutoConfiguration</code>键下列出您的配置类，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class=string>\</span></span><br><span class=line><span class=string>com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\</span></span><br><span class=line><span class=string>com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</span></span><br></pre></table></figure><p>如果需要按特定 Sequences 应用配置，则可以使用<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureAfter.java rel=noopener target=_blank>@AutoConfigureAfter</a>或<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureBefore.java rel=noopener target=_blank>@AutoConfigureBefore</a>注解。例如，如果您提供特定于 Web 的配置，则可能需要在<code>WebMvcAutoConfiguration</code>之后应用您的类。<p>如果要 Order 某些彼此之间没有直接知识的自动配置，则也可以使用<code>@AutoConfigureOrder</code>。该 Comments 与常规<code>@Order</code>Comments 具有相同的语义，但为自动配置类提供了专用 Sequences。<blockquote><p>自动配置必须以* only *的方式加载。确保在特定的软件包空间中定义了它们，尤其是它们绝不是组件扫描的目标。</blockquote><h3 id=3-27-3、条件Comments><a class=headerlink href=#3-27-3、条件Comments title=3.27.3、条件Comments></a>3.27.3、条件Comments</h3><p>您几乎总是希望在自动配置类中包含一个或多个<code>@Conditional</code>Comments。 <code>@ConditionalOnMissingBean</code>Comments 是一个常见示例，用于使开发人员在对默认设置不满意的情况下覆盖自动配置。<p>Spring Boot 包含许多<code>@Conditional</code>Comments，您可以通过 Comments<code>@Configuration</code>类或单个<code>@Bean</code>方法在自己的代码中重用。这些 Comments 包括：<ul><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-auto-configuration.html#boot-features-class-conditions rel=noopener target=_blank>第 49.3.1 节“类条件”</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-auto-configuration.html#boot-features-bean-conditions rel=noopener target=_blank>第 49.3.2 节“ Bean 条件”</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-auto-configuration.html#boot-features-property-conditions rel=noopener target=_blank>第 49.3.3 节“财产条件”</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-auto-configuration.html#boot-features-resource-conditions rel=noopener target=_blank>第 49.3.4 节“资源条件”</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-auto-configuration.html#boot-features-web-application-conditions rel=noopener target=_blank>第 49.3.5 节“ Web 应用程序条件”</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-auto-configuration.html#boot-features-spel-conditions rel=noopener target=_blank>第 49.3.6 节“ SpEL 表达条件”</a></ul><h4 id=3-27-3-1、Class-条件><a title="3.27.3.1、Class 条件" class=headerlink href=#3-27-3-1、Class-条件></a>3.27.3.1、Class 条件</h4><p><code>@ConditionalOnClass</code>和<code>@ConditionalOnMissingClass</code>注解允许根据是否存在特定类来包含配置。由于 Comments 元数据是通过使用<a href=http://asm.ow2.org/ rel=noopener target=_blank>ASM</a>进行解析的，因此即使该类实际上可能未出现在正在运行的应用程序 Classpath 上，您也可以使用<code>value</code>属性来引用真实的类。如果您希望通过使用<code>String</code>值来指定类名，则也可以使用<code>name</code>属性。<blockquote><p>如果您使用<code>@ConditionalOnClass</code>或<code>@ConditionalOnMissingClass</code>作为元 Comments 的一部分来组成自己的组合 Comments，则必须使用<code>name</code>，因为在这种情况下无法引用该类。</blockquote><h4 id=3-27-3-2、Bean-条件><a title="3.27.3.2、Bean 条件" class=headerlink href=#3-27-3-2、Bean-条件></a>3.27.3.2、Bean 条件</h4><p><code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>Comments 根据是否存在特定的 bean 来包含 bean。您可以使用<code>value</code>属性按类型指定 bean，或使用<code>name</code>按名称指定 bean。 <code>search</code>属性使您可以限制搜索 Bean 时应考虑的<code>ApplicationContext</code>层次结构。<p>当放置在<code>@Bean</code>方法上时，目标类型默认为该方法的返回类型，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyAutoConfiguration</span> {</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=meta>@ConditionalOnMissingBean</span></span><br><span class=line>	<span class=keyword>public</span> MyService <span class="title function_">myService</span><span class=params>()</span> { ... }</span><br><span class=line>}</span><br></pre></table></figure><p>在前面的示例中，如果<code>ApplicationContext</code>中没有包含<code>MyService</code>类型的 bean，则将创建<code>myService</code> bean。<blockquote><p>您需要非常注意添加 bean 定义的 Sequences，因为这些条件是根据到目前为止已处理的内容来评估的。因此，我们建议在自动配置类上仅使用<code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>Comments(因为保证在添加任何用户定义的 Bean 定义后即可加载这些 Comments)。<p><code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>不会阻止<code>@Configuration</code>类的创建。在类级别使用这些条件与使用 Comments 标记每个包含的<code>@Bean</code>方法之间的唯一区别是，如果条件不匹配，则前者会阻止<code>@Configuration</code>类注册为 bean。</blockquote><h4 id=3-27-3-3、财产条件><a class=headerlink href=#3-27-3-3、财产条件 title=3.27.3.3、财产条件></a>3.27.3.3、财产条件</h4><p><code>@ConditionalOnProperty</code>Comments 允许基于 Spring Environment 属性包含配置。使用<code>prefix</code>和<code>name</code>属性来指定应检查的属性。默认情况下，匹配存在且不等于<code>false</code>的任何属性。您还可以使用<code>havingValue</code>和<code>matchIfMissing</code>属性创建更高级的检查。<h4 id=3-27-3-4、资源条件><a class=headerlink href=#3-27-3-4、资源条件 title=3.27.3.4、资源条件></a>3.27.3.4、资源条件</h4><p><code>@ConditionalOnResource</code>Comments 仅在存在特定资源时才包括配置。可以使用通常的 Spring 约定来指定资源，如以下示例所示：<code>file:/home/user/test.dat</code>。<h4 id=3-27-3-5、Web-应用程序条件><a title="3.27.3.5、Web 应用程序条件" class=headerlink href=#3-27-3-5、Web-应用程序条件></a>3.27.3.5、Web 应用程序条件</h4><p>根据应用程序是否为“ Web 应用程序”，可以使用<code>@ConditionalOnWebApplication</code>和<code>@ConditionalOnNotWebApplication</code>注解包含配置。 Web 应用程序是使用 Spring <code>WebApplicationContext</code>，定义<code>session</code>范围或具有<code>StandardServletEnvironment</code>的任何应用程序。<h4 id=3-27-3-6、SpEL-表达条件><a title="3.27.3.6、SpEL 表达条件" class=headerlink href=#3-27-3-6、SpEL-表达条件></a>3.27.3.6、SpEL 表达条件</h4><p><code>@ConditionalOnExpression</code>注解允许基于<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/core.html#expressions rel=noopener target=_blank>SpEL expression</a>的结果包括配置。<h3 id=3-27-4、测试您的自动配置><a class=headerlink href=#3-27-4、测试您的自动配置 title=3.27.4、测试您的自动配置></a>3.27.4、测试您的自动配置</h3><p>自动配置可能受许多因素影响：用户配置(<code>@Bean</code>定义和<code>Environment</code>定制)，条件评估(特定库的存在)和其他因素。具体而言，每个测试都应创建定义良好的<code>ApplicationContext</code>，以表示这些自定义项的组合。 <code>ApplicationContextRunner</code>提供了一种实现此目标的好方法。<p><code>ApplicationContextRunner</code>通常定义为测试类的一个字段，用于收集基本的通用配置。下面的示例确保始终调用<code>UserServiceAutoConfiguration</code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=keyword>final</span> <span class=type>ApplicationContextRunner</span> <span class=variable>contextRunner</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ApplicationContextRunner</span>()</span><br><span class=line>.withConfiguration(AutoConfigurations.of(UserServiceAutoConfiguration.class));</span><br></pre></table></figure><blockquote><p>如果必须定义多个自动配置，则无需按与运行应用程序时完全相同的 Sequences 调用它们的声明。</blockquote><p>每个测试都可以使用运行器来表示特定的用例。例如，下面的示例调用一个用户配置(<code>UserConfiguration</code>)，并检查自动配置是否正确退出。调用<code>run</code>提供了可与<code>Assert4J</code>一起使用的回调上下文。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">defaultServiceBacksOff</span><span class=params>()</span> {</span><br><span class=line>	<span class=built_in>this</span>.contextRunner.withUserConfiguration(UserConfiguration.class)</span><br><span class=line>			.run((context) -> {</span><br><span class=line>				assertThat(context).hasSingleBean(UserService.class);</span><br><span class=line>				assertThat(context.getBean(UserService.class)).isSameAs(</span><br><span class=line>						context.getBean(UserConfiguration.class).myUserService());</span><br><span class=line>			});</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">UserConfiguration</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> UserService <span class="title function_">myUserService</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">UserService</span>(<span class=string>"mine"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>还可以轻松自定义<code>Environment</code>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">serviceNameCanBeConfigured</span><span class=params>()</span> {</span><br><span class=line>	<span class=built_in>this</span>.contextRunner.withPropertyValues(<span class=string>"user.name=test123"</span>).run((context) -> {</span><br><span class=line>		assertThat(context).hasSingleBean(UserService.class);</span><br><span class=line>		assertThat(context.getBean(UserService.class).getName()).isEqualTo(<span class=string>"test123"</span>);</span><br><span class=line>	});</span><br><span class=line>}</span><br></pre></table></figure><p>Running 者也可以用来显示<code>ConditionEvaluationReport</code>。该报告可以<code>INFO</code>或<code>DEBUG</code>级别打印。以下示例显示如何在自动配置测试中使用<code>ConditionEvaluationReportLoggingListener</code>打印报告。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> autoConfigTest {</span><br><span class=line>	<span class=type>ConditionEvaluationReportLoggingListener</span> <span class=variable>initializer</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ConditionEvaluationReportLoggingListener</span>(</span><br><span class=line>			LogLevel.INFO);</span><br><span class=line>	<span class=type>ApplicationContextRunner</span> <span class=variable>contextRunner</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ApplicationContextRunner</span>()</span><br><span class=line>			.withInitializer(initializer).run((context) -> {</span><br><span class=line>					<span class=comment>// Do something...</span></span><br><span class=line>			});</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-27-4-1、模拟网络环境><a class=headerlink href=#3-27-4-1、模拟网络环境 title=3.27.4.1、模拟网络环境></a>3.27.4.1、模拟网络环境</h4><p>如果您需要测试仅在 Servlet 或 Reactive Web 应用程序上下文中运行的自动配置，请分别使用<code>WebApplicationContextRunner</code>或<code>ReactiveWebApplicationContextRunner</code>。<h4 id=3-27-4-2、覆盖Classpath><a class=headerlink href=#3-27-4-2、覆盖Classpath title=3.27.4.2、覆盖Classpath></a>3.27.4.2、覆盖Classpath</h4><p>还可以测试在运行时不存在特定的类和/或程序包时发生的情况。 Spring Boot 附带<code>FilteredClassLoader</code>，Running 者可以轻松使用。在以下示例中，我们 assert 如果不存在<code>UserService</code>，则会自动禁用自动配置：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">serviceIsIgnoredIfLibraryIsNotPresent</span><span class=params>()</span> {</span><br><span class=line>	<span class=built_in>this</span>.contextRunner.withClassLoader(<span class=keyword>new</span> <span class="title class_">FilteredClassLoader</span>(UserService.class))</span><br><span class=line>			.run((context) -> assertThat(context).doesNotHaveBean(<span class=string>"userService"</span>));</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-27-5、创建自己的启动器><a class=headerlink href=#3-27-5、创建自己的启动器 title=3.27.5、创建自己的启动器></a>3.27.5、创建自己的启动器</h3><p>库的完整 Spring BootStarter 程序可能包含以下组件：<ul><li>包含自动配置代码的<code>autoconfigure</code>模块。<li><code>starter</code>模块提供对<code>autoconfigure</code>模块以及库的依赖关系，以及通常有用的任何其他依赖关系。简而言之，添加启动程序应提供开始使用该库所需的一切。</ul><h4 id=3-27-5-1、Naming><a class=headerlink href=#3-27-5-1、Naming title=3.27.5.1、Naming></a>3.27.5.1、Naming</h4><p>您应该确保为启动器提供适当的名称空间。即使您使用其他 Maven <code>groupId</code>，也不要以<code>spring-boot</code>开头模块名称。将来，我们可能会为您自动配置的内容提供官方支持。<p>根据经验，您应该在启动器后命名一个组合模块。例如，假设您要为“ acme”创建启动程序，并且将自动配置模块命名为<code>acme-spring-boot-autoconfigure</code>，而启动程序则命名为<code>acme-spring-boot-starter</code>。如果只有一个将两者结合的模块，请将其命名为<code>acme-spring-boot-starter</code>。<p>另外，如果您的 Starter 者提供了配置密钥，请为其使用唯一的名称空间。特别是，不要在 Spring Boot 使用的名称空间中包含您的密钥(例如<code>server</code>，<code>management</code>，<code>spring</code>等)。如果使用相同的名称空间，将来我们可能会以破坏模块的方式修改这些名称空间。<p>确保<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/configuration-metadata.html#configuration-metadata-annotation-processor rel=noopener target=_blank>触发元数据生成</a>，以便您的按键也可以使用 IDE 协助。您可能需要查看生成的元数据(<code>META-INF/spring-configuration-metadata.json</code>)，以确保正确记录了您的密钥。<h4 id=3-27-5-2、自动配置模块><a class=headerlink href=#3-27-5-2、自动配置模块 title=3.27.5.2、自动配置模块></a>3.27.5.2、自动配置模块</h4><p><code>autoconfigure</code>模块包含开始使用该库所需的所有内容。它还可能包含配置键定义(例如<code>@ConfigurationProperties</code>)和可用于进一步自定义组件初始化方式的任何回调接口。<blockquote><p>您应该将对库的依赖关系标记为可选，以便可以更轻松地在项目中包含<code>autoconfigure</code>模块。如果这样做，则不提供该库，并且默认情况下，Spring Boot 会后退。</blockquote><p>Spring Boot 使用 Comments 处理器来收集元数据文件(<code>META-INF/spring-autoconfigure-metadata.properties</code>)中自动配置的条件。如果存在该文件，它将用于急切过滤不匹配的自动配置，这将缩短启动时间。建议在包含自动配置的模块中添加以下依赖项：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>spring-boot-autoconfigure-processor<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>optional</span>></span>true<span class=tag>&LT/<span class=name>optional</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><p>对于 Gradle 4.5 及更早版本，依赖关系应在<code>compileOnly</code>配置中声明，如以下示例所示：<figure class="highlight groovy"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>dependencies {</span><br><span class=line>	compileOnly <span class=string>"org.springframework.boot:spring-boot-autoconfigure-processor"</span></span><br><span class=line>}</span><br></pre></table></figure><p>在 Gradle 4.6 及更高版本中，依赖性应在<code>annotationProcessor</code>配置中声明，如以下示例所示：<figure class="highlight groovy"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>dependencies {</span><br><span class=line>	annotationProcessor <span class=string>"org.springframework.boot:spring-boot-autoconfigure-processor"</span></span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-27-5-3、Starter模块><a class=headerlink href=#3-27-5-3、Starter模块 title=3.27.5.3、Starter模块></a>3.27.5.3、Starter模块</h4><p>起动器确实是一个空Jar子。其唯一目的是提供必要的依赖关系以使用库。您可以将其视为对 Starter 所需的看法。<p>不要对添加了启动器的项目做任何假设。如果您要自动配置的库通常需要其他启动器，请同时提及它们。如果可选依赖项的数量很高，则提供一组适当的* default *依赖项可能会很困难，因为您应避免包括对于库的典型用法而言不必要的依赖项。换句话说，您不应包括可选的依赖项。<blockquote><p>无论哪种方式，您的启动程序都必须直接或间接引用核心 Spring Boot 启动程序(<code>spring-boot-starter</code>)(即，如果您的启动程序依赖于另一个启动程序，则无需添加它)。如果仅使用您的自定义启动器创建项目，则通过使用该核心启动器来兑现 Spring Boot 的核心功能。</blockquote><h2 id=3-28、Kotlin-support><a title="3.28、Kotlin support" class=headerlink href=#3-28、Kotlin-support></a>3.28、Kotlin support</h2><p><a href=https://kotlinlang.org/ rel=noopener target=_blank>Kotlin</a>是针对 JVM(和其他平台)的静态类型的语言，它允许编写简洁明了的代码，同时为<a href=https://kotlinlang.org/docs/reference/java-interop.html rel=noopener target=_blank>interoperability</a>提供以 Java 编写的现有库。<p>Spring Boot 通过利用其他 Spring 项目(例如 Spring Framework，Spring Data 和 Reactor)中的支持来提供 Kotlin 支持。有关更多信息，请参见<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/languages.html#kotlin rel=noopener target=_blank>Spring Framework Kotlin 支持文档</a>。<p>从 Spring Boot 和 Kotlin 开始的最简单方法是遵循<a href=https://spring.io/guides/tutorials/spring-boot-kotlin/ rel=noopener target=_blank>本综合教程</a>。您可以通过<a href=https://start.spring.io/#!language=kotlin rel=noopener target=_blank>start.spring.io</a>创建新的 Kotlin 项目。如果需要支持，可以随时加入<a href=http://slack.kotlinlang.org/ rel=noopener target=_blank>Kotlin Slack</a>的#spring Channels，或在<a href=https://stackoverflow.com/questions/tagged/spring+kotlin rel=noopener target=_blank>Stack Overflow</a>上使用<code>spring</code>和<code>kotlin</code>标签询问问题。<h3 id=3-28-1、Requirements><a class=headerlink href=#3-28-1、Requirements title=3.28.1、Requirements></a>3.28.1、Requirements</h3><p>Spring Boot 支持 Kotlin1.2.x。要使用 Kotlin，Classpath 上必须存在<code>org.jetbrains.kotlin:kotlin-stdlib</code>和<code>org.jetbrains.kotlin:kotlin-reflect</code>。也可以使用<code>kotlin-stdlib</code>变体<code>kotlin-stdlib-jdk7</code>和<code>kotlin-stdlib-jdk8</code>。<p>从<a href=https://discuss.kotlinlang.org/t/classes-final-by-default/166 rel=noopener target=_blank>Kotlin 类默认为 final</a>开始，您可能需要配置<a href=https://kotlinlang.org/docs/reference/compiler-plugins.html#spring-support rel=noopener target=_blank>kotlin-spring</a>插件，以便自动打开带有 Spring Comments 的类，以便对其进行代理。<p>在 Kotlin 中序列化/反序列化 JSON 数据需要<a href=https://github.com/FasterXML/jackson-module-kotlin rel=noopener target=_blank>Jackson 的 Kotlin 模块</a>。在 Classpath 上找到它会自动注册。如果存在 Jackson 和 Kotlin 但不存在 Jackson Kotlin 模块，则会记录一条警告消息。<blockquote><p>如果一个人在<a href=https://start.spring.io/#!language=kotlin rel=noopener target=_blank>start.spring.io</a>上引导 Kotlin 项目，则默认情况下会提供这些依赖项和插件。</blockquote><h3 id=3-28-2、Null-safety><a class=headerlink href=#3-28-2、Null-safety title=3.28.2、Null-safety></a>3.28.2、Null-safety</h3><p>Kotlin 的主要功能之一是<a href=https://kotlinlang.org/docs/reference/null-safety.html rel=noopener target=_blank>null-safety</a>。它在编译时处理<code>null</code>值，而不是将问题推迟到运行时并遇到<code>NullPointerException</code>。这有助于消除常见的错误源，而无需支付<code>Optional</code>之类的包装器的费用。 Kotlin 还允许使用具有可空值的函数构造，如<a href=http://www.baeldung.com/kotlin-null-safety rel=noopener target=_blank>Kotlin 空安全综合指南</a>中所述。<p>尽管 Java 不允许人在其类型系统中表示空安全性，但 Spring Framework，Spring Data 和 Reactor 现在通过易于使用工具的注解为 API 提供了空安全性。默认情况下，Kotlin 中使用的 Java API 中的类型被识别为<a href=https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types rel=noopener target=_blank>platform types</a>，对此类型的空检查得到了放宽。 <a href=https://kotlinlang.org/docs/reference/java-interop.html#jsr-305-support rel=noopener target=_blank>Kotlin 对 JSR 305 注解的支持</a>与可空性 Comments 结合使用，为 Kotlin 中的相关 Spring API 提供了空安全性。<p>可以通过添加带有以下选项的<code>-Xjsr305</code>编译器标志来配置 JSR 305 检查：<code>-Xjsr305={strict|warn|ignore}</code>。默认行为与<code>-Xjsr305=warn</code>相同。必须使用<code>strict</code>值来考虑从 Spring API 推断出的 Kotlin 类型的空安全性，但应使用该知识，即使 Spring API 的空性声明即使在次要发行版之间也可能会演变，并且将来可能会添加更多检查，这一点应得到使用。<blockquote><p>尚不支持泛型类型参数，varargs 和数组元素的可空性。有关最新信息，请参见<a href=https://jira.spring.io/browse/SPR-15942 rel=noopener target=_blank>SPR-15942</a>。另外请注意，Spring Boot 自己的 API 是<a href=https://github.com/spring-projects/spring-boot/issues/10712 rel=noopener target=_blank>尚未 Comments</a>。</blockquote><h3 id=3-28-3、Kotlin-API><a title="3.28.3、Kotlin API" class=headerlink href=#3-28-3、Kotlin-API></a>3.28.3、Kotlin API</h3><h4 id=3-28-3-1、runApplication><a class=headerlink href=#3-28-3-1、runApplication title=3.28.3.1、runApplication></a>3.28.3.1、runApplication</h4><p>Spring Boot 提供了一种惯用的方式来使用<code>runApplication&LTMyApplication>(*args)</code>运行应用程序，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.boot.autoconfigure.SpringBootApplication</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.runApplication</span><br><span class=line></span><br><span class=line><span class=meta>@SpringBootApplication</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">MyApplication</span></span><br><span class=line></span><br><span class=line>fun <span class="title function_">main</span><span class=params>(args: Array&LTString>)</span> {</span><br><span class=line>	runApplication&LTMyApplication>(*args)</span><br><span class=line>}</span><br></pre></table></figure><p>这是<code>SpringApplication.run(MyApplication::class.java, *args)</code>的直接替代。它还允许自定义应用程序，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>runApplication&LTMyApplication>(*args) {</span><br><span class=line>	setBannerMode(OFF)</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-28-3-2、Extensions><a class=headerlink href=#3-28-3-2、Extensions title=3.28.3.2、Extensions></a>3.28.3.2、Extensions</h4><p>Kotlin <a href=https://kotlinlang.org/docs/reference/extensions.html rel=noopener target=_blank>extensions</a>提供了使用其他功能扩展现有类的功能。 Spring Boot Kotlin API 利用这些扩展为现有 API 添加了新的 Kotlin 专用便利。<p>提供了<code>TestRestTemplate</code>extensions，类似于 Spring Framework 为<code>RestOperations</code>在 Spring Framework 中提供的 extensions。除其他事项外，这些扩展使利用 Kotlin 修饰类型参数成为可能。<h3 id=3-28-4、依赖性-Management><a title="3.28.4、依赖性 Management" class=headerlink href=#3-28-4、依赖性-Management></a>3.28.4、依赖性 Management</h3><p>为了避免在 Classpath 上混合使用不同版本的 Kotlin 依赖项，提供了以下 Kotlin 依赖项的依赖项 Management：<ul><li><code>kotlin-reflect</code><li><code>kotlin-runtime</code><li><code>kotlin-stdlib</code><li><code>kotlin-stdlib-jdk7</code><li><code>kotlin-stdlib-jdk8</code><li><code>kotlin-stdlib-jre7</code><li><code>kotlin-stdlib-jre8</code></ul><p>使用 Maven，可以通过<code>kotlin.version</code>属性自定义 Kotlin 版本，并为<code>kotlin-maven-plugin</code>提供插件 Management。使用 Gradle，Spring Boot 插件会自动将<code>kotlin.version</code>与 Kotlin 插件的版本对齐。<h3 id=3-28-5、-ConfigurationProperties><a class=headerlink href=#3-28-5、-ConfigurationProperties title=3.28.5、@ConfigurationProperties></a>3.28.5、@ConfigurationProperties</h3><p><code>@ConfigurationProperties</code>目前仅适用于<code>lateinit</code>或可为空的<code>var</code>属性(建议使用前者)，因为构造函数初始化的不可变类为<a href=https://github.com/spring-projects/spring-boot/issues/8762 rel=noopener target=_blank>尚不支持</a>。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>@ConfigurationProperties("example.kotlin")</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">KotlinExampleProperties</span> {</span><br><span class=line>	lateinit <span class=keyword>var</span> name: String</span><br><span class=line>	lateinit <span class=keyword>var</span> description: String</span><br><span class=line>	<span class=type>val</span> <span class=variable>myService</span> <span class=operator>=</span> MyService()</span><br><span class=line></span><br><span class=line>	<span class=keyword>class</span> <span class="title class_">MyService</span> {</span><br><span class=line>		lateinit <span class=keyword>var</span> apiToken: String</span><br><span class=line>		lateinit <span class=keyword>var</span> uri: URI</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>要使用 Comments 处理器生成<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/configuration-metadata.html#configuration-metadata-annotation-processor rel=noopener target=_blank>您自己的元数据</a>，具有<code>spring-boot-configuration-processor</code>依赖性的<a href=https://kotlinlang.org/docs/reference/kapt.html rel=noopener target=_blank>kapt 应该配置</a>。</blockquote><h3 id=3-28-6、Testing><a class=headerlink href=#3-28-6、Testing title=3.28.6、Testing></a>3.28.6、Testing</h3><p>虽然可以使用 JUnit 4(由<code>spring-boot-starter-test</code>提供的默认值)来测试 Kotlin 代码，但建议使用 JUnit 5. JUnit 5 使一个测试类可以实例化一次，并可以重新用于该类的所有测试。这样就可以在非静态方法上使用<code>@BeforeAll</code>和<code>@AfterAll</code>注解，这非常适合 Kotlin。<p>要使用 JUnit 5，请从<code>spring-boot-starter-test</code>中排除<code>junit:junit</code>依赖性，添加 JUnit 5 依赖性，并相应地配置 Maven 或 Gradle 插件。有关更多详细信息，请参见<a href=https://junit.org/junit5/docs/current/user-guide/#dependency-metadata-junit-jupiter-samples rel=noopener target=_blank>JUnit 5 文档</a>。您还需要<a href=https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle-changing-default rel=noopener target=_blank>将测试实例生命周期切换为“每个类”</a>。<h3 id=3-28-7、Resources><a class=headerlink href=#3-28-7、Resources title=3.28.7、Resources></a>3.28.7、Resources</h3><h4 id=3-28-7-1、进一步阅读><a class=headerlink href=#3-28-7-1、进一步阅读 title=3.28.7.1、进一步阅读></a>3.28.7.1、进一步阅读</h4><ul><li><a href=https://kotlinlang.org/docs/reference/ rel=noopener target=_blank>Kotlin 语言参考</a><li><a href=http://slack.kotlinlang.org/ rel=noopener target=_blank>Kotlin Slack</a>(带有专用的#spring Channels)<li><a href=https://stackoverflow.com/questions/tagged/spring+kotlin rel=noopener target=_blank>具有 Spring 和 Kotlin 标签的 Stackoverflow</a><li><a href=https://try.kotlinlang.org/ rel=noopener target=_blank>在浏览器中尝试 Kotlin</a><li><a href=https://blog.jetbrains.com/kotlin/ rel=noopener target=_blank>Kotlin blog</a><li><a href=https://kotlin.link/ rel=noopener target=_blank>Awesome Kotlin</a><li><a href=https://spring.io/guides/tutorials/spring-boot-kotlin/ rel=noopener target=_blank>教程：使用 Spring Boot 和 Kotlin 构建 Web 应用程序</a><li><a href=https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin rel=noopener target=_blank>使用 Kotlin 开发 Spring Boot 应用程序</a><li><a href=https://spring.io/blog/2016/03/20/a-geospatial-messenger-with-kotlin-spring-boot-and-postgresql rel=noopener target=_blank>带有 Kotlin，Spring Boot 和 PostgreSQL 的地理空间 Messenger</a><li><a href=https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0 rel=noopener target=_blank>在 Spring Framework 5.0 中引入 Kotlin 支持</a><li><a href=https://spring.io/blog/2017/08/01/spring-framework-5-kotlin-apis-the-functional-way rel=noopener target=_blank>Spring Framework 5 Kotlin API 的功能方式</a></ul><h4 id=3-28-7-2、Examples><a class=headerlink href=#3-28-7-2、Examples title=3.28.7.2、Examples></a>3.28.7.2、Examples</h4><ul><li><a href=https://github.com/sdeleuze/spring-boot-kotlin-demo rel=noopener target=_blank>spring-boot-kotlin-demo</a>：常规 Spring Boot Spring Data JPA 项目<li><a href=https://github.com/mixitconf/mixit rel=noopener target=_blank>mixit</a>：Spring Boot 2 WebFlux Reactive Spring Data MongoDB<li><a href=https://github.com/sdeleuze/spring-kotlin-fullstack rel=noopener target=_blank>spring-kotlin-fullstack</a>：WebFlux Kotlin 全栈示例，其中 Kotlin2js 用于前端，而不是 JavaScript 或 TypeScript<li><a href=https://github.com/spring-petclinic/spring-petclinic-kotlin rel=noopener target=_blank>spring-petclinic-kotlin</a>：Spring PetClinic 示例应用程序的 Kotlin 版本<li><a href=https://github.com/sdeleuze/spring-kotlin-deepdive rel=noopener target=_blank>spring-kotlin-deepdive</a>：从 Boot 1.0 Java 到 Boot 2.0 Kotlin 的逐步迁移</ul><h1 id=4、Spring-Boot-Actuator><a title="4、Spring Boot Actuator" class=headerlink href=#4、Spring-Boot-Actuator></a>4、Spring Boot Actuator</h1><p>Spring Boot 包含许多附加功能，可在您将应用程序投入生产时帮助您监视和 Management 应用程序。您可以选择使用 HTTP 端点或 JMX Management 和监视您的应用程序。审核，运行状况和 Metrics 收集也可以自动应用于您的应用程序。<h2 id=4-1、启用生产就绪功能><a class=headerlink href=#4-1、启用生产就绪功能 title=4.1、启用生产就绪功能></a>4.1、启用生产就绪功能</h2><p><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator rel=noopener target=_blank>spring-boot-actuator</a>模块提供了 Spring Boot 生产就绪的所有功能。启用功能的最简单方法是将依赖项添加到<code>spring-boot-starter-actuator</code>‘Starter’。<blockquote><p>致动器是制造术语，是指用于移动或控制某些物体的机械设备。Actuator 可以通过很小的变化产生大量的运动。</blockquote><p>要将 Actuator 添加到基于 Maven 的项目中，请添加以下“ Starter”依赖项：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>	<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>		<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>		<span class=tag><<span class=name>artifactId</span>></span>spring-boot-starter-actuator<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencies</span>></span></span><br></pre></table></figure><p>对于 Gradle，使用以下声明：<figure class="highlight groovy"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>dependencies {</span><br><span class=line>	compile(<span class=string>"org.springframework.boot:spring-boot-starter-actuator"</span>)</span><br><span class=line>}</span><br></pre></table></figure><h2 id=4-2、Endpoints><a class=headerlink href=#4-2、Endpoints title=4.2、Endpoints></a>4.2、Endpoints</h2><p>Actuator 端点使您可以监视应用程序并与之交互。 Spring Boot 包含许多内置端点，可让您添加自己的端点。例如，<code>health</code>端点提供基本的应用程序运行状况信息。<p>每个端点可以是<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-endpoints.html#production-ready-endpoints-enabling-endpoints rel=noopener target=_blank>启用或禁用</a>。这控制了是否创建了端点以及它的 bean 在应用程序上下文中是否存在。要远程访问，端点也必须是<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-endpoints.html#production-ready-endpoints-exposing-endpoints rel=noopener target=_blank>通过 JMX 或 HTTP 公开</a>。大多数应用程序选择 HTTP，其中终结点的 ID 和前缀<code>/actuator</code>Map 到 URL。例如，默认情况下，<code>health</code>端点 Map 到<code>/actuator/health</code>。<p>可以使用以下与技术无关的端点：<table><thead><tr><th>ID<th>Description<th>默认启用<tbody><tr><td><code>auditevents</code><td>公开当前应用程序的审核事件信息。<td>Yes<tr><td><code>beans</code><td>显示应用程序中所有 Spring Bean 的完整列表。<td>Yes<tr><td><code>caches</code><td>公开可用的缓存。<td>Yes<tr><td><code>conditions</code><td>显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因。<td>Yes<tr><td><code>configprops</code><td>显示所有<code>@ConfigurationProperties</code>的整理列表。<td>Yes<tr><td><code>env</code><td>从 Spring 的<code>ConfigurableEnvironment</code>公开属性。<td>Yes<tr><td><code>flyway</code><td>显示已应用的所有 Flyway 数据库迁移。<td>Yes<tr><td><code>health</code><td>显示应用程序运行状况信息。<td>Yes<tr><td><code>httptrace</code><td>显示 HTTP 跟踪信息(默认情况下，最近 100 个 HTTP 请求-响应交换)。<td>Yes<tr><td><code>info</code><td>显示任意应用程序信息。<td>Yes<tr><td><code>integrationgraph</code><td>显示 Spring Integration 图。<td>Yes<tr><td><code>loggers</code><td>显示和修改应用程序中 Logger 的配置。<td>Yes<tr><td><code>liquibase</code><td>显示已应用的所有 Liquibase 数据库迁移。<td>Yes<tr><td><code>metrics</code><td>显示当前应用程序的“Metrics”信息。<td>Yes<tr><td><code>mappings</code><td>显示所有<code>@RequestMapping</code>路径的整理列表。<td>Yes<tr><td><code>scheduledtasks</code><td>显示应用程序中的计划任务。<td>Yes<tr><td><code>sessions</code><td>允许从 Spring Session 支持的会话存储中检索和删除用户会话。使用 Spring Session 对反应式 Web 应用程序的支持时不可用。<td>Yes<tr><td><code>shutdown</code><td>使应用程序正常关闭。<td>No<tr><td><code>threaddump</code><td>执行线程转储。<td>Yes</table><p>如果您的应用程序是 Web 应用程序(Spring MVC，Spring WebFlux 或 Jersey)，则可以使用以下附加端点：<table><thead><tr><th>ID<th>Description<th>默认启用<tbody><tr><td><code>heapdump</code><td>返回一个<code>hprof</code>堆转储文件。<td>Yes<tr><td><code>jolokia</code><td>通过 HTTP 公开 JMX bean(当 Jolokia 在 Classpath 上时，不适用于 WebFlux)。<td>Yes<tr><td><code>logfile</code><td>返回日志文件的内容(如果已设置<code>logging.file</code>或<code>logging.path</code>属性)。支持使用 HTTP <code>Range</code>Headers 来检索部分日志文件的内容。<td>Yes<tr><td><code>prometheus</code><td>以 Prometheus 服务器可以抓取的格式公开 Metrics。<td>Yes</table><p>要了解有关 Actuator 端点及其请求和响应格式的更多信息，请参阅单独的 API 文档(<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/actuator-api//html rel=noopener target=_blank>HTML</a>或<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/actuator-api//pdf/spring-boot-actuator-web-api.pdf rel=noopener target=_blank>PDF</a>)。<h3 id=4-2-1、启用端点><a class=headerlink href=#4-2-1、启用端点 title=4.2.1、启用端点></a>4.2.1、启用端点</h3><p>默认情况下，除<code>shutdown</code>之外的所有端点均处于启用状态。要配置端点的启用，请使用其<code>management.endpoint.&LTid>.enabled</code>属性。以下示例启用<code>shutdown</code>端点：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoint.shutdown.enabled</span>=<span class=string>true</span></span><br></pre></table></figure><p>如果您宁愿选择启用端点启用而不是选择退出，请将<code>management.endpoints.enabled-by-default</code>属性设置为<code>false</code>并使用单个端点<code>enabled</code>属性选择重新加入。以下示例启用<code>info</code>端点并禁用所有其他端点：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoints.enabled-by-default</span>=<span class=string>false</span></span><br><span class=line><span class=attr>management.endpoint.info.enabled</span>=<span class=string>true</span></span><br></pre></table></figure><h3 id=4-2-2、公开端点><a class=headerlink href=#4-2-2、公开端点 title=4.2.2、公开端点></a>4.2.2、公开端点</h3><p>由于端点可能包含敏感信息，因此应谨慎考虑何时公开它们。下表显示了内置端点的默认暴露：<table><thead><tr><th>ID<th>JMX<th>Web<tbody><tr><td><code>auditevents</code><td>Yes<td>No<tr><td><code>beans</code><td>Yes<td>No<tr><td><code>caches</code><td>Yes<td>No<tr><td><code>conditions</code><td>Yes<td>No<tr><td><code>configprops</code><td>Yes<td>No<tr><td><code>env</code><td>Yes<td>No<tr><td><code>flyway</code><td>Yes<td>No<tr><td><code>health</code><td>Yes<td>Yes<tr><td><code>heapdump</code><td>N/A<td>No<tr><td><code>httptrace</code><td>Yes<td>No<tr><td><code>info</code><td>Yes<td>Yes<tr><td><code>integrationgraph</code><td>Yes<td>No<tr><td><code>jolokia</code><td>N/A<td>No<tr><td><code>logfile</code><td>N/A<td>No<tr><td><code>loggers</code><td>Yes<td>No<tr><td><code>liquibase</code><td>Yes<td>No<tr><td><code>metrics</code><td>Yes<td>No<tr><td><code>mappings</code><td>Yes<td>No<tr><td><code>prometheus</code><td>N/A<td>No<tr><td><code>scheduledtasks</code><td>Yes<td>No<tr><td><code>sessions</code><td>Yes<td>No<tr><td><code>shutdown</code><td>Yes<td>No<tr><td><code>threaddump</code><td>Yes<td>No</table><p>要更改公开哪些端点，请使用以下特定于技术的<code>include</code>和<code>exclude</code>属性：<table><thead><tr><th>Property<th>Default<tbody><tr><td><code>management.endpoints.jmx.exposure.exclude</code><td><tr><td><code>management.endpoints.jmx.exposure.include</code><td><code>*</code><tr><td><code>management.endpoints.web.exposure.exclude</code><td><tr><td><code>management.endpoints.web.exposure.include</code><td><code>info, health</code></table><p><code>include</code>属性列出了公开的端点的 ID。 <code>exclude</code>属性列出了不应公开的端点的 ID。 <code>exclude</code>属性优先于<code>include</code>属性。 <code>include</code>和<code>exclude</code>属性都可以使用端点 ID 列表进行配置。<p>例如，要停止通过 JMX 公开所有端点，而仅公开<code>health</code>和<code>info</code>端点，请使用以下属性：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoints.jmx.exposure.include</span>=<span class=string>health,info</span></span><br></pre></table></figure><p><code>*</code>可用于选择所有端点。例如，要通过 HTTP 公开除<code>env</code>和<code>beans</code>端点之外的所有内容，请使用以下属性：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoints.web.exposure.include</span>=<span class=string>*</span></span><br><span class=line><span class=attr>management.endpoints.web.exposure.exclude</span>=<span class=string>env,beans</span></span><br></pre></table></figure><blockquote><p><code>*</code>在 YAML 中具有特殊含义，因此，如果要包括(或排除)所有端点，请确保添加引号，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>management:</span><br><span class=line>endpoints:</span><br><span class=line>web:</span><br><span class=line>exposure:</span><br><span class=line>include: "*"</span><br></pre></table></figure><p>如果您的申请公开公开，我们强烈建议您也<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-endpoints.html#production-ready-endpoints-security rel=noopener target=_blank>保护您的端点</a>。<p>如果要针对暴露端点的时间实施自己的策略，则可以注册<code>EndpointFilter</code> bean。</blockquote><h3 id=4-2-3、保护HTTP端点><a class=headerlink href=#4-2-3、保护HTTP端点 title=4.2.3、保护HTTP端点></a>4.2.3、保护HTTP端点</h3><p>您应该像对待其他任何敏感 URL 一样，小心保护 HTTP 端点的安全。如果存在 Spring Security，则默认情况下使用 Spring Security 的内容协商策略保护端点的安全。例如，如果您希望为 HTTP 端点配置自定义安全性，只允许具有特定角色的用户访问它们，Spring Boot 提供了一些方便的<code>RequestMatcher</code>对象，可以将它们与 Spring Security 结合使用。<p>典型的 Spring Security 配置可能类似于以下示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ActuatorSecurity</span> <span class=keyword>extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>protected</span> <span class=keyword>void</span> <span class="title function_">configure</span><span class=params>(HttpSecurity http)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests()</span><br><span class=line>				.anyRequest().hasRole(<span class=string>"ENDPOINT_ADMIN"</span>)</span><br><span class=line>				.and()</span><br><span class=line>			.httpBasic();</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>前面的示例使用<code>EndpointRequest.toAnyEndpoint()</code>将请求匹配到任何端点，然后确保所有角色都具有<code>ENDPOINT_ADMIN</code>角色。 <code>EndpointRequest</code>上还有其他几种匹配器方法。有关详细信息，请参见 API 文档(<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/actuator-api//html rel=noopener target=_blank>HTML</a>或<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/actuator-api//pdf/spring-boot-actuator-web-api.pdf rel=noopener target=_blank>PDF</a>)。<p>如果将应用程序部署在防火墙后面，则可能希望可以在不进行身份验证的情况下访问所有 Actuator 端点。您可以通过更改<code>management.endpoints.web.exposure.include</code>属性来做到这一点，如下所示：<p><strong>application.properties.</strong><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoints.web.exposure.include</span>=<span class=string>*</span></span><br></pre></table></figure><p>此外，如果存在 Spring Security，则需要添加自定义安全配置，该配置允许未经身份验证的端点访问，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ActuatorSecurity</span> <span class=keyword>extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>protected</span> <span class=keyword>void</span> <span class="title function_">configure</span><span class=params>(HttpSecurity http)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests()</span><br><span class=line>			.anyRequest().permitAll();</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h3 id=4-2-4、配置端点><a class=headerlink href=#4-2-4、配置端点 title=4.2.4、配置端点></a>4.2.4、配置端点</h3><p>端点自动缓存对不带任何参数的读取操作的响应。要配置端点缓存响应的时间，请使用其<code>cache.time-to-live</code>属性。以下示例将<code>beans</code>终结点的缓存的生存时间设置为 10 秒：<p><strong>application.properties.</strong><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoint.beans.cache.time-to-live</span>=<span class=string>10s</span></span><br></pre></table></figure><blockquote><p>前缀<code>management.endpoint.&LTname></code>用于唯一标识正在配置的端点。<p>发出经过身份验证的 HTTP 请求时，<code>Principal</code>被视为端点的 Importing，因此将不缓存响应。</blockquote><h3 id=4-2-5、用于-Actuator-Web-端点的超媒体><a title="4.2.5、用于 Actuator Web 端点的超媒体" class=headerlink href=#4-2-5、用于-Actuator-Web-端点的超媒体></a>4.2.5、用于 Actuator Web 端点的超媒体</h3><p>添加了“发现页面”以及指向所有端点的链接。默认情况下，“发现页面”在<code>/actuator</code>上可用。<p>配置自定义 Management 上下文路径后，“发现页面”会自动从<code>/actuator</code>移到 Management 上下文的根目录。例如，如果 Management 上下文路径为<code>/management</code>，则可从<code>/management</code>访问发现页面。当 Management 上下文路径设置为<code>/</code>时，将禁用发现页面，以防止与其他 Map 发生冲突的可能性。<h3 id=4-2-6、CORS-支持><a title="4.2.6、CORS 支持" class=headerlink href=#4-2-6、CORS-支持></a>4.2.6、CORS 支持</h3><p><a href=https://en.wikipedia.org/wiki/Cross-origin_resource_sharing rel=noopener target=_blank>跨域资源共享</a>(CORS)是<a href=https://www.w3.org/TR/cors/ rel=noopener target=_blank>W3C specification</a>，它使您可以灵活地指定授权哪种类型的跨域请求。如果使用 Spring MVC 或 Spring WebFlux，则可以将 Actuator 的 Web 端点配置为支持此类方案。<p>默认情况下，CORS 支持是禁用的，只有在设置<code>management.endpoints.web.cors.allowed-origins</code>属性后才启用。以下配置允许来自<code>example.com</code>域的<code>GET</code>和<code>POST</code>调用：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoints.web.cors.allowed-origins</span>=<span class=string>http://example.com</span></span><br><span class=line><span class=attr>management.endpoints.web.cors.allowed-methods</span>=<span class=string>GET,POST</span></span><br></pre></table></figure><h3 id=4-2-7、实施自定义端点><a class=headerlink href=#4-2-7、实施自定义端点 title=4.2.7、实施自定义端点></a>4.2.7、实施自定义端点</h3><p>如果添加带有<code>@Endpoint</code>Comments 的<code>@Bean</code>，则带有<code>@ReadOperation</code>，<code>@WriteOperation</code>或<code>@DeleteOperation</code>Comments 的任何方法都将通过 JMX 以及 Web 应用程序中的 HTTP 自动公开。可以使用 Jersey，Spring MVC 或 Spring WebFlux 通过 HTTP 公开端点。<p>您还可以使用<code>@JmxEndpoint</code>或<code>@WebEndpoint</code>编写技术特定的端点。这些端点仅限于其各自的技术。例如，<code>@WebEndpoint</code>仅通过 HTTP 而不是 JMX 公开。<p>您可以使用<code>@EndpointWebExtension</code>和<code>@EndpointJmxExtension</code>编写技术特定的扩展。这些 Comments 使您可以提供特定于技术的操作来扩展现有端点。<p>最后，如果您需要访问特定于 Web 框架的功能，则可以实现 Servlet 或 Spring <code>@Controller</code>和<code>@RestController</code>端点，但代价是它们无法通过 JMX 或使用其他 Web 框架使用。<h4 id=4-2-7-1、接收-Importing><a title="4.2.7.1、接收 Importing" class=headerlink href=#4-2-7-1、接收-Importing></a>4.2.7.1、接收 Importing</h4><p>端点上的操作通过其参数接收 Importing。通过网络公开时，这些参数的值取自 URL 的查询参数和 JSON 请求正文。通过 JMX 公开时，参数将 Map 到 MBean 操作的参数。默认情况下，参数是必需的。可以通过使用<code>@org.springframework.lang.Nullable</code>对其进行 Comments 来使它们成为可选的。<p>JSON 请求正文中的每个根属性都可以 Map 到端点的参数。考虑以下 JSON 请求正文：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>{</span><br><span class=line>	"name": "test",</span><br><span class=line>	"counter": 42</span><br><span class=line>}</span><br></pre></table></figure><p>这可用于调用采用<code>String name</code>和<code>int counter</code>参数的写操作。<blockquote><p>由于端点与技术无关，因此只能在方法签名中指定简单类型。特别是，不支持使用定义<code>name</code>和<code>counter</code>属性的自定义类型声明单个参数。<p>为了将 ImportingMap 到操作方法的参数，实现端点的 Java 代码应使用<code>-parameters</code>编译，而实现端点的 Kotlin 代码应使用<code>-java-parameters</code>编译。如果您使用的是 Spring Boot 的 Gradle 插件，或者您使用的是 Maven 和<code>spring-boot-starter-parent</code>，那么这将自动发生。</blockquote><h5 id=Importing-类型转换><a title="Importing 类型转换" class=headerlink href=#Importing-类型转换></a>Importing 类型转换</h5><p>如有必要，传递给端点操作方法的参数会自动转换为所需的类型。在调用操作方法之前，使用<code>ApplicationConversionService</code>实例将通过 JMX 或 HTTP 请求接收的 Importing 转换为所需的类型。<h4 id=4-2-7-2、自定义-Web-端点><a title="4.2.7.2、自定义 Web 端点" class=headerlink href=#4-2-7-2、自定义-Web-端点></a>4.2.7.2、自定义 Web 端点</h4><p>使用 Jersey，Spring MVC 或 Spring WebFlux 通过 HTTP 自动公开<code>@Endpoint</code>，<code>@WebEndpoint</code>或<code>@EndpointWebExtension</code>上的操作。<h5 id=Web-端点请求谓词><a title="Web 端点请求谓词" class=headerlink href=#Web-端点请求谓词></a>Web 端点请求谓词</h5><p>对于在暴露于 Web 的端点上的每个操作，都会自动生成一个请求谓词。<h5 id=Path><a class=headerlink href=#Path title=Path></a>Path</h5><p>谓词的路径由终结点的 ID 和暴露于 Web 的终结点的基本路径确定。默认基本路径为<code>/actuator</code>。例如，ID 为<code>sessions</code>的端点将使用<code>/actuator/sessions</code>作为其在谓词中的路径。<p>通过使用<code>@Selector</code>Comments 操作方法的一个或多个参数，可以进一步自定义路径。将这样的参数作为路径变量添加到路径谓词。当端点操作被调用时，变量的值被传递到操作方法中。<h5 id=HTTP-method><a title="HTTP method" class=headerlink href=#HTTP-method></a>HTTP method</h5><p>谓词的 HTTP 方法由操作类型决定，如下表所示：<table><thead><tr><th>Operation<th>HTTP method<tbody><tr><td><code>@ReadOperation</code><td><code>GET</code><tr><td><code>@WriteOperation</code><td><code>POST</code><tr><td><code>@DeleteOperation</code><td><code>DELETE</code></table><h5 id=Consumes><a class=headerlink href=#Consumes title=Consumes></a>Consumes</h5><p>对于使用请求正文的<code>@WriteOperation</code>(HTTP <code>POST</code>)，谓词的消耗子句为<code>application/vnd.spring-boot.actuator.v2+json, application/json</code>。对于所有其他操作，消耗子句为空。<h5 id=Produces><a class=headerlink href=#Produces title=Produces></a>Produces</h5><p>谓词的 Produces 子句可以由<code>@DeleteOperation</code>，<code>@ReadOperation</code>和<code>@WriteOperation</code>注解的<code>produces</code>属性确定。该属性是可选的。如果未使用，则会自动确定 produces 子句。<p>如果操作方法返回<code>void</code>或<code>Void</code>，则 produces 子句为空。如果操作方法返回<code>org.springframework.core.io.Resource</code>，则 Produces 子句为<code>application/octet-stream</code>。对于所有其他操作，produces 子句为<code>application/vnd.spring-boot.actuator.v2+json, application/json</code>。<h5 id=Web-端点响应状态><a title="Web 端点响应状态" class=headerlink href=#Web-端点响应状态></a>Web 端点响应状态</h5><p>端点操作的默认响应状态取决于操作类型(读，写或删除)以及该操作返回的内容(如果有)。<p><code>@ReadOperation</code>返回一个值，响应状态将为 200(确定)。如果未返回值，则响应状态将为 404(未找到)。<p>如果<code>@WriteOperation</code>或<code>@DeleteOperation</code>返回值，则响应状态将为 200(确定)。如果未返回值，则响应状态将为 204(无内容)。<p>如果在没有必需参数或无法将参数转换为必需类型的参数的情况下调用操作，则不会调用该操作方法，并且响应状态将为 400(错误请求)。<h5 id=Web-端点范围请求><a title="Web 端点范围请求" class=headerlink href=#Web-端点范围请求></a>Web 端点范围请求</h5><p>HTTP 范围请求可用于请求 HTTP 资源的一部分。使用 Spring MVC 或 Spring Web Flux 时，返回<code>org.springframework.core.io.Resource</code>的操作自动支持范围请求。<blockquote><p>使用 Jersey 时不支持范围请求。</blockquote><h5 id=Web-端点安全><a title="Web 端点安全" class=headerlink href=#Web-端点安全></a>Web 端点安全</h5><p>Web 终结点或特定于 Web 的终结点扩展上的操作可以接收当前的<code>java.security.Principal</code>或<code>org.springframework.boot.actuate.endpoint.SecurityContext</code>作为方法参数。前者通常与<code>@Nullable</code>结合使用，以为经过身份验证和未经身份验证的用户提供不同的行为。后者通常用于使用其<code>isUserInRole(String)</code>方法执行授权检查。<h4 id=4-2-7-3、Servlet-端点><a title="4.2.7.3、Servlet 端点" class=headerlink href=#4-2-7-3、Servlet-端点></a>4.2.7.3、Servlet 端点</h4><p>通过实现带有<code>@ServletEndpoint</code>Comments 的类(也可以实现<code>Supplier&LTEndpointServlet></code>)，可以将<code>Servlet</code>公开为端点。 Servlet 端点提供了与 Servlet 容器的更深层集成，但以可移植性为代价。它们旨在用于将现有的<code>Servlet</code>公开为端点。对于新端点，应尽可能使用<code>@Endpoint</code>和<code>@WebEndpoint</code>注解。<h4 id=4-2-7-4、控制器端点><a class=headerlink href=#4-2-7-4、控制器端点 title=4.2.7.4、控制器端点></a>4.2.7.4、控制器端点</h4><p><code>@ControllerEndpoint</code>和<code>@RestControllerEndpoint</code>可用于实现仅由 Spring MVC 或 Spring WebFlux 公开的端点。使用 Spring MVC 和 Spring WebFlux 的标准 Comments(例如<code>@RequestMapping</code>和<code>@GetMapping</code>)Map 方法，并将端点的 ID 用作路径的前缀。控制器端点提供了与 Spring Web 框架的更深层集成，但以可移植性为代价。尽可能使用<code>@Endpoint</code>和<code>@WebEndpoint</code>注解。<h3 id=4-2-8、健康信息><a class=headerlink href=#4-2-8、健康信息 title=4.2.8、健康信息></a>4.2.8、健康信息</h3><p>您可以使用运行状况信息来检查正在运行的应用程序的状态。监视软件通常使用它在生产系统出现故障时向某人发出警报。 <code>health</code>端点公开的信息取决于<code>management.endpoint.health.show-details</code>属性，该属性可以配置以下值之一：<table><thead><tr><th>Name<th>Description<tbody><tr><td><code>never</code><td>详细信息永远不会显示。<tr><td><code>when-authorized</code><td>详细信息仅显示给授权用户。可以使用<code>management.endpoint.health.roles</code>配置授权角色。<tr><td><code>always</code><td>向所有用户显示详细信息。</table><p>默认值为<code>never</code>。当用户担任一个或多个端点的角色时，该用户被视为已授权。如果端点没有配置的角色(默认值)，则所有通过身份验证的用户均被视为已授权。可以使用<code>management.endpoint.health.roles</code>属性配置角色。<blockquote><p>如果您已保护应用程序安全并希望使用<code>always</code>，则安全配置必须允许经过身份验证的用户和未经身份验证的用户都可以访问运行状况端点。</blockquote><p>运行状况信息是从<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicatorRegistry.java rel=noopener target=_blank>HealthIndicatorRegistry</a>的内容中收集的(默认情况下，<code>ApplicationContext</code>中定义的所有<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java rel=noopener target=_blank>HealthIndicator</a>实例。Spring Boot 包含许多自动配置的<code>HealthIndicators</code>，您也可以编写自己的实例。默认情况下，最终的系统状态由<code>HealthAggregator</code>根据状态的有序列表对每个<code>HealthIndicator</code>的状态进行排序。排序后的列表中的第一个状态用作整体运行状况。如果没有<code>HealthIndicator</code>返回<code>HealthAggregator</code>已知的状态，则使用<code>UNKNOWN</code>状态。<blockquote><p><code>HealthIndicatorRegistry</code>可用于在运行时注册和注销运行状况指示器。</blockquote><h4 id=4-2-8-1、自动配置的健康-Metrics><a title="4.2.8.1、自动配置的健康 Metrics" class=headerlink href=#4-2-8-1、自动配置的健康-Metrics></a>4.2.8.1、自动配置的健康 Metrics</h4><p>适当时，Spring Boot 会自动配置以下<code>HealthIndicators</code>：<table><thead><tr><th>Name<th>Description<tbody><tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/cassandra/CassandraHealthIndicator.java rel=noopener target=_blank>CassandraHealthIndicator</a><td>检查 Cassandra 数据库是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/couchbase/CouchbaseHealthIndicator.java rel=noopener target=_blank>CouchbaseHealthIndicator</a><td>检查 Couchbase 群集是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/system/DiskSpaceHealthIndicator.java rel=noopener target=_blank>DiskSpaceHealthIndicator</a><td>检查磁盘空间不足。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/jdbc/DataSourceHealthIndicator.java rel=noopener target=_blank>DataSourceHealthIndicator</a><td>检查是否可以构建到<code>DataSource</code>的连接。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/elasticsearch/ElasticsearchHealthIndicator.java rel=noopener target=_blank>ElasticsearchHealthIndicator</a><td>检查 Elasticsearch 集群是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/influx/InfluxDbHealthIndicator.java rel=noopener target=_blank>InfluxDbHealthIndicator</a><td>检查 InfluxDB 服务器是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/jms/JmsHealthIndicator.java rel=noopener target=_blank>JmsHealthIndicator</a><td>检查 JMS 代理是否启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mail/MailHealthIndicator.java rel=noopener target=_blank>MailHealthIndicator</a><td>检查邮件服务器是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mongo/MongoHealthIndicator.java rel=noopener target=_blank>MongoHealthIndicator</a><td>检查 Mongo 数据库是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/neo4j/Neo4jHealthIndicator.java rel=noopener target=_blank>Neo4jHealthIndicator</a><td>检查 Neo4j 服务器是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/amqp/RabbitHealthIndicator.java rel=noopener target=_blank>RabbitHealthIndicator</a><td>检查 Rabbit 服务器是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/redis/RedisHealthIndicator.java rel=noopener target=_blank>RedisHealthIndicator</a><td>检查 Redis 服务器是否启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/solr/SolrHealthIndicator.java rel=noopener target=_blank>SolrHealthIndicator</a><td>检查 Solr 服务器是否已启动。</table><blockquote><p>您可以通过设置<code>management.health.defaults.enabled</code>属性来全部禁用它们。</blockquote><h4 id=4-2-8-2、编写自定义健康-Metrics><a title="4.2.8.2、编写自定义健康 Metrics" class=headerlink href=#4-2-8-2、编写自定义健康-Metrics></a>4.2.8.2、编写自定义健康 Metrics</h4><p>要提供自定义健康信息，您可以注册实现<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java rel=noopener target=_blank>HealthIndicator</a>接口的 Spring bean。您需要提供<code>health()</code>方法的实现并返回<code>Health</code>响应。 <code>Health</code>响应应包含状态，并且可以选择包含要显示的其他详细信息。以下代码显示了示例<code>HealthIndicator</code>实现：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.boot.actuate.health.Health;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.actuate.health.HealthIndicator;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyHealthIndicator</span> <span class=keyword>implements</span> <span class="title class_">HealthIndicator</span> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> Health <span class="title function_">health</span><span class=params>()</span> {</span><br><span class=line>		<span class=type>int</span> <span class=variable>errorCode</span> <span class=operator>=</span> check(); <span class=comment>// perform some specific health check</span></span><br><span class=line>		<span class=keyword>if</span> (errorCode != <span class=number>0</span>) {</span><br><span class=line>			<span class=keyword>return</span> Health.down().withDetail(<span class=string>"Error Code"</span>, errorCode).build();</span><br><span class=line>		}</span><br><span class=line>		<span class=keyword>return</span> Health.up().build();</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>给定<code>HealthIndicator</code>的标识符是不带<code>HealthIndicator</code>后缀的 bean 的名称(如果存在)。在前面的示例中，健康信息在名为<code>my</code>的条目中可用。</blockquote><p>除了 Spring Boot 的 sched 义<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/Status.java rel=noopener target=_blank>Status</a>类型之外，<code>Health</code>还可以返回表示新系统状态的自定义<code>Status</code>。在这种情况下，还需要提供<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthAggregator.java rel=noopener target=_blank>HealthAggregator</a>接口的自定义实现，或者必须使用<code>management.health.status.order</code>配置属性来配置默认实现。<p>例如，假设在您的<code>HealthIndicator</code>实现中使用了新的<code>Status</code>代码<code>FATAL</code>。要配置严重性 Sequences，请将以下属性添加到您的应用程序属性中：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.health.status.order</span>=<span class=string>FATAL, DOWN, OUT_OF_SERVICE, UNKNOWN, UP</span></span><br></pre></table></figure><p>响应中的 HTTP 状态代码反映了总体健康状态(例如<code>UP</code>Map 为 200，而<code>OUT_OF_SERVICE</code>和<code>DOWN</code>Map 为 503)。如果通过 HTTP 访问运行状况终结点，则可能还需要注册自定义状态 Map。例如，以下属性将<code>FATAL</code>Map 到 503(服务不可用)：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.health.status.http-mapping.FATAL</span>=<span class=string>503</span></span><br></pre></table></figure><blockquote><p>如果需要更多控制，则可以定义自己的<code>HealthStatusHttpMapper</code> bean。</blockquote><p>下表显示了内置状态的默认状态 Map：<table><thead><tr><th>Status<th>Mapping<tbody><tr><td>DOWN<td>SERVICE_UNAVAILABLE (503)<tr><td>OUT_OF_SERVICE<td>SERVICE_UNAVAILABLE (503)<tr><td>UP<td>默认情况下没有 Map，因此 http 状态为 200<tr><td>UNKNOWN<td>默认情况下没有 Map，因此 http 状态为 200</table><h4 id=4-2-8-3、Reactive-健康-Metrics><a title="4.2.8.3、Reactive 健康 Metrics" class=headerlink href=#4-2-8-3、Reactive-健康-Metrics></a>4.2.8.3、Reactive 健康 Metrics</h4><p>对于响应式应用程序，例如使用 Spring WebFlux 的应用程序，<code>ReactiveHealthIndicator</code>提供了非阻塞 Contract 以获取应用程序的运行状况。与传统<code>HealthIndicator</code>相似，健康信息是从<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicatorRegistry.java rel=noopener target=_blank>ReactiveHealthIndicatorRegistry</a>的内容中收集的(默认情况下，在<code>ApplicationContext</code>中定义的所有<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java rel=noopener target=_blank>HealthIndicator</a>和<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicator.java rel=noopener target=_blank>ReactiveHealthIndicator</a>实例。常规<code>HealthIndicator</code>不会根据反应式 API 进行检查，都是在弹性调度程序上执行的。<blockquote><p>在响应式应用程序中，<code>ReactiveHealthIndicatorRegistry</code>可用于在运行时注册和注销运行状况指示器。</blockquote><p>要从反应式 API 提供自定义健康信息，您可以注册实现<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicator.java rel=noopener target=_blank>ReactiveHealthIndicator</a>接口的 Spring bean。以下代码显示了一个示例<code>ReactiveHealthIndicator</code>实现：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyReactiveHealthIndicator</span> <span class=keyword>implements</span> <span class="title class_">ReactiveHealthIndicator</span> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> Mono&LTHealth> <span class="title function_">health</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> doHealthCheck() <span class=comment>//perform some specific health check that returns a Mono&LTHealth></span></span><br><span class=line>			.onErrorResume(ex -> Mono.just(<span class=keyword>new</span> <span class="title class_">Health</span>.Builder().down(ex).build())));</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>要自动处理错误，请考虑从<code>AbstractReactiveHealthIndicator</code>扩展。</blockquote><h4 id=4-2-8-4、自动配置的-ReactiveHealthIndicators><a title="4.2.8.4、自动配置的 ReactiveHealthIndicators" class=headerlink href=#4-2-8-4、自动配置的-ReactiveHealthIndicators></a>4.2.8.4、自动配置的 ReactiveHealthIndicators</h4><p>适当时，Spring Boot 会自动配置以下<code>ReactiveHealthIndicators</code>：<table><thead><tr><th>Name<th>Description<tbody><tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/cassandra/CassandraReactiveHealthIndicator.java rel=noopener target=_blank>CassandraReactiveHealthIndicator</a><td>检查 Cassandra 数据库是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/couchbase/CouchbaseReactiveHealthIndicator.java rel=noopener target=_blank>CouchbaseReactiveHealthIndicator</a><td>检查 Couchbase 群集是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mongo/MongoReactiveHealthIndicator.java rel=noopener target=_blank>MongoReactiveHealthIndicator</a><td>检查 Mongo 数据库是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/redis/RedisReactiveHealthIndicator.java rel=noopener target=_blank>RedisReactiveHealthIndicator</a><td>检查 Redis 服务器是否启动。</table><blockquote><p>如有必要，可用无功指示器代替常规指示器。另外，任何未明确处理的<code>HealthIndicator</code>都会自动包装。</blockquote><h3 id=4-2-9、申请信息><a class=headerlink href=#4-2-9、申请信息 title=4.2.9、申请信息></a>4.2.9、申请信息</h3><p>应用程序信息公开了从<code>ApplicationContext</code>中定义的所有<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java rel=noopener target=_blank>InfoContributor</a> bean 中收集的各种信息。 Spring Boot 包含许多自动配置的<code>InfoContributor</code> bean，您可以编写自己的。<h4 id=4-2-9-1、自动配置的信息贡献者><a class=headerlink href=#4-2-9-1、自动配置的信息贡献者 title=4.2.9.1、自动配置的信息贡献者></a>4.2.9.1、自动配置的信息贡献者</h4><p>适当时，Spring Boot 会自动配置以下<code>InfoContributor</code> bean：<table><thead><tr><th>Name<th>Description<tbody><tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/EnvironmentInfoContributor.java rel=noopener target=_blank>EnvironmentInfoContributor</a><td>在<code>info</code>键下公开<code>Environment</code>中的任何键。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/GitInfoContributor.java rel=noopener target=_blank>GitInfoContributor</a><td>如果<code>git.properties</code>文件可用，则公开 git 信息。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/BuildInfoContributor.java rel=noopener target=_blank>BuildInfoContributor</a><td>如果<code>META-INF/build-info.properties</code>文件可用，则公开构建信息。</table><blockquote><p>通过设置<code>management.info.defaults.enabled</code>属性，可以全部禁用它们。</blockquote><h4 id=4-2-9-2、自定义应用程序信息><a class=headerlink href=#4-2-9-2、自定义应用程序信息 title=4.2.9.2、自定义应用程序信息></a>4.2.9.2、自定义应用程序信息</h4><p>您可以通过设置<code>info.*</code> Spring 属性来自定义<code>info</code>终结点公开的数据。 <code>info</code>键下的所有<code>Environment</code>属性将自动显示。例如，您可以将以下设置添加到<code>application.properties</code>文件中：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>info.app.encoding</span>=<span class=string>UTF-8</span></span><br><span class=line><span class=attr>info.app.java.source</span>=<span class=string>1.8</span></span><br><span class=line><span class=attr>info.app.java.target</span>=<span class=string>1.8</span></span><br></pre></table></figure><blockquote><p>除了对这些值进行硬编码，您还可以<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/howto-properties-and-configuration.html#howto-automatic-expansion rel=noopener target=_blank>在构建时扩展信息属性</a>。<p>假设您使用 Maven，则可以按如下所示重写前面的示例：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>info.app.encoding[emailprotected]@</span></span><br><span class=line><span class=attr>info.app.java.source[emailprotected]@</span></span><br><span class=line><span class=attr>info.app.java.target[emailprotected]@</span></span><br></pre></table></figure></blockquote><h4 id=4-2-9-3、Git-提交信息><a title="4.2.9.3、Git 提交信息" class=headerlink href=#4-2-9-3、Git-提交信息></a>4.2.9.3、Git 提交信息</h4><p><code>info</code>端点的另一个有用功能是，它可以在项目构建时发布有关<code>git</code>源代码存储库状态的信息。如果<code>GitProperties</code> bean 可用，则公开<code>git.branch</code>，<code>git.commit.id</code>和<code>git.commit.time</code>属性。<blockquote><p>如果<code>git.properties</code>文件在 Classpath 的根目录中可用，则会自动配置<code>GitProperties</code> bean。有关更多详细信息，请参见“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/howto-build.html#howto-git-info rel=noopener target=_blank>生成 git 信息</a>”。</blockquote><p>如果要显示完整的 git 信息(即<code>git.properties</code>的完整内容)，请使用<code>management.info.git.mode</code>属性，如下所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.info.git.mode</span>=<span class=string>full</span></span><br></pre></table></figure><h4 id=4-2-9-4、生成信息><a class=headerlink href=#4-2-9-4、生成信息 title=4.2.9.4、生成信息></a>4.2.9.4、生成信息</h4><p>如果有<code>BuildProperties</code> bean，则<code>info</code>端点也可以发布有关构建的信息。如果<code>META-INF/build-info.properties</code>文件在 Classpath 中可用，则会发生这种情况。<blockquote><p>Maven 和 Gradle 插件都可以生成该文件。</blockquote><h4 id=4-2-9-5、编写自定义信息提供者><a class=headerlink href=#4-2-9-5、编写自定义信息提供者 title=4.2.9.5、编写自定义信息提供者></a>4.2.9.5、编写自定义信息提供者</h4><p>要提供自定义应用程序信息，您可以注册实现<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java rel=noopener target=_blank>InfoContributor</a>接口的 Spring bean。<p>下面的示例使用单个值贡献一个<code>example</code>条目：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.Collections;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.boot.actuate.info.Info;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.actuate.info.InfoContributor;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleInfoContributor</span> <span class=keyword>implements</span> <span class="title class_">InfoContributor</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">contribute</span><span class=params>(Info.Builder builder)</span> {</span><br><span class=line>		builder.withDetail(<span class=string>"example"</span>,</span><br><span class=line>				Collections.singletonMap(<span class=string>"key"</span>, <span class=string>"value"</span>));</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><p>如果到达<code>info</code>端点，则应该看到包含以下附加条目的响应：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>{</span><br><span class=line>	"example": {</span><br><span class=line>		"key" : "value"</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h2 id=4-3、通过-HTTP-进行监视和-Management><a title="4.3、通过 HTTP 进行监视和 Management" class=headerlink href=#4-3、通过-HTTP-进行监视和-Management></a>4.3、通过 HTTP 进行监视和 Management</h2><p>如果您正在开发 Web 应用程序，则 Spring Boot Actuator 会自动配置所有启用的端点以通过 HTTP 公开。默认约定是使用端点的<code>id</code>和前缀<code>/actuator</code>作为 URL 路径。例如，<code>health</code>被公开为<code>/actuator/health</code>。提示：Spring MVC，Spring WebFlux 和 Jersey 本身支持 Actuator。<h3 id=4-3-1、自定义-Management-端点路径><a title="4.3.1、自定义 Management 端点路径" class=headerlink href=#4-3-1、自定义-Management-端点路径></a>4.3.1、自定义 Management 端点路径</h3><p>有时，自定义 Management 端点的前缀很有用。例如，您的应用程序可能已经将<code>/actuator</code>用于其他用途。您可以使用<code>management.endpoints.web.base-path</code>属性来更改 Management 端点的前缀，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.endpoints.web.base-path=/manage</span><br></pre></table></figure><p>前面的<code>application.properties</code>示例将端点从<code>/actuator/{id}</code>更改为<code>/manage/{id}</code>(例如<code>/manage/info</code>)。<blockquote><p>除非 Management 端口已配置为<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-monitoring.html#production-ready-customizing-management-server-port rel=noopener target=_blank>通过使用其他 HTTP 端口公开端点</a>，否则<code>management.endpoints.web.base-path</code>是相对于<code>server.servlet.context-path</code>的。如果配置了<code>management.server.port</code>，则<code>management.endpoints.web.base-path</code>相对于<code>management.server.servlet.context-path</code>。</blockquote><p>如果要将端点 Map 到其他路径，可以使用<code>management.endpoints.web.path-mapping</code>属性。<p>以下示例将<code>/actuator/health</code>重新 Map 到<code>/healthcheck</code>：<p><strong>application.properties.</strong><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoints.web.base-path</span>=<span class=string>/</span></span><br><span class=line><span class=attr>management.endpoints.web.path-mapping.health</span>=<span class=string>healthcheck</span></span><br></pre></table></figure><h3 id=4-3-2、自定义-Management-服务器端口><a title="4.3.2、自定义 Management 服务器端口" class=headerlink href=#4-3-2、自定义-Management-服务器端口></a>4.3.2、自定义 Management 服务器端口</h3><p>对于基于云的部署，使用默认的 HTTP 端口公开 Management 端点是明智的选择。但是，如果您的应用程序在自己的数据中心内运行，则您可能更喜欢使用其他 HTTP 端口公开端点。<p>您可以设置<code>management.server.port</code>属性来更改 HTTP 端口，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.server.port</span>=<span class=string>8081</span></span><br></pre></table></figure><h3 id=4-3-3、配置特定于-Management-的-SSL><a title="4.3.3、配置特定于 Management 的 SSL" class=headerlink href=#4-3-3、配置特定于-Management-的-SSL></a>4.3.3、配置特定于 Management 的 SSL</h3><p>当配置为使用自定义端口时，还可以通过使用各种<code>management.server.ssl.*</code>属性将 Management 服务器配置为其自己的 SSL。例如，这样做可以使 Management 服务器在主应用程序使用 HTTPS 时通过 HTTP 可用，如以下属性设置所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=attr>server.port</span>=<span class=string>8443</span></span><br><span class=line><span class=attr>server.ssl.enabled</span>=<span class=string>true</span></span><br><span class=line><span class=attr>server.ssl.key-store</span>=<span class=string>classpath:store.jks</span></span><br><span class=line><span class=attr>server.ssl.key-password</span>=<span class=string>secret</span></span><br><span class=line><span class=attr>management.server.port</span>=<span class=string>8080</span></span><br><span class=line><span class=attr>management.server.ssl.enabled</span>=<span class=string>false</span></span><br></pre></table></figure><p>另外，主服务器和 Management 服务器都可以使用 SSL，但具有不同的密钥库，如下所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=attr>server.port</span>=<span class=string>8443</span></span><br><span class=line><span class=attr>server.ssl.enabled</span>=<span class=string>true</span></span><br><span class=line><span class=attr>server.ssl.key-store</span>=<span class=string>classpath:main.jks</span></span><br><span class=line><span class=attr>server.ssl.key-password</span>=<span class=string>secret</span></span><br><span class=line><span class=attr>management.server.port</span>=<span class=string>8080</span></span><br><span class=line><span class=attr>management.server.ssl.enabled</span>=<span class=string>true</span></span><br><span class=line><span class=attr>management.server.ssl.key-store</span>=<span class=string>classpath:management.jks</span></span><br><span class=line><span class=attr>management.server.ssl.key-password</span>=<span class=string>secret</span></span><br></pre></table></figure><h3 id=4-3-4、自定义-Management-服务器地址><a title="4.3.4、自定义 Management 服务器地址" class=headerlink href=#4-3-4、自定义-Management-服务器地址></a>4.3.4、自定义 Management 服务器地址</h3><p>您可以通过设置<code>management.server.address</code>属性来自定义 Management 端点可用的地址。如果您只想侦听内部或面向操作的网络，或者只侦听来自<code>localhost</code>的连接，则这样做很有用。<blockquote><p>仅当端口与主服务器端口不同时，您才能在其他地址上侦听。</blockquote><p>以下示例<code>application.properties</code>不允许远程 Management 连接：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>management.server.port</span>=<span class=string>8081</span></span><br><span class=line><span class=attr>management.server.address</span>=<span class=string>127.0.0.1</span></span><br></pre></table></figure><h3 id=4-3-5、禁用-HTTP-端点><a title="4.3.5、禁用 HTTP 端点" class=headerlink href=#4-3-5、禁用-HTTP-端点></a>4.3.5、禁用 HTTP 端点</h3><p>如果您不想通过 HTTP 公开端点，则可以将 Management 端口设置为<code>-1</code>，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.server.port</span>=<span class=string>-1</span></span><br></pre></table></figure><p>也可以使用<code>management.endpoints.web.exposure.exclude</code>属性来实现，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoints.web.exposure.exclude</span>=<span class=string>*</span></span><br></pre></table></figure><h2 id=4-4、通过-JMX-进行监视和-Management><a title="4.4、通过 JMX 进行监视和 Management" class=headerlink href=#4-4、通过-JMX-进行监视和-Management></a>4.4、通过 JMX 进行监视和 Management</h2><p>Java Management 扩展(JMX)提供了监视和 Management 应用程序的标准机制。默认情况下，Spring Boot 在<code>org.springframework.boot</code>域下将 Management 端点公开为 JMX MBean。<h3 id=4-4-1、自定义-MBean-名称><a title="4.4.1、自定义 MBean 名称" class=headerlink href=#4-4-1、自定义-MBean-名称></a>4.4.1、自定义 MBean 名称</h3><p>MBean 的名称通常是从端点的<code>id</code>生成的。例如，<code>health</code>端点公开为<code>org.springframework.boot:type=Endpoint,name=Health</code>。<p>如果您的应用程序包含多个 Spring <code>ApplicationContext</code>，则您可能会发现名称冲突。要解决此问题，可以将<code>spring.jmx.unique-names</code>属性设置为<code>true</code>，以便 MBean 名称始终是唯一的。<p>您还可以自定义暴露端点的 JMX 域。以下设置显示了在<code>application.properties</code>中执行此操作的示例：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.jmx.unique-names</span>=<span class=string>true</span></span><br><span class=line><span class=attr>management.endpoints.jmx.domain</span>=<span class=string>com.example.myapp</span></span><br></pre></table></figure><h3 id=4-4-2、禁用-JMX-端点><a title="4.4.2、禁用 JMX 端点" class=headerlink href=#4-4-2、禁用-JMX-端点></a>4.4.2、禁用 JMX 端点</h3><p>如果不想通过 JMX 公开终结点，可以将<code>management.endpoints.jmx.exposure.exclude</code>属性设置为<code>*</code>，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoints.jmx.exposure.exclude</span>=<span class=string>*</span></span><br></pre></table></figure><h3 id=4-4-3、通过-HTTP-将-Jolokia-用于-JMX><a title="4.4.3、通过 HTTP 将 Jolokia 用于 JMX" class=headerlink href=#4-4-3、通过-HTTP-将-Jolokia-用于-JMX></a>4.4.3、通过 HTTP 将 Jolokia 用于 JMX</h3><p>Jolokia 是一个 JMX-HTTP bridge，它提供了一种访问 JMX Bean 的替代方法。要使用 Jolokia，请包括对<code>org.jolokia:jolokia-core</code>的依赖。例如，使用 Maven，您将添加以下依赖项：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>org.jolokia<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>jolokia-core<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><p>然后，可以通过向<code>management.endpoints.web.exposure.include</code>属性添加<code>jolokia</code>或<code>*</code>来暴露 Jolokia 端点。然后，可以通过在 Management HTTP 服务器上使用<code>/actuator/jolokia</code>来访问它。<h4 id=4-4-3-1、自定义-Jolokia><a title="4.4.3.1、自定义 Jolokia" class=headerlink href=#4-4-3-1、自定义-Jolokia></a>4.4.3.1、自定义 Jolokia</h4><p>Jolokia 具有许多设置，这些设置通常是通过设置 servlet 参数进行配置的。通过 Spring Boot，您可以使用<code>application.properties</code>文件。为此，请在参数前面加上<code>management.endpoint.jolokia.config.</code>，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoint.jolokia.config.debug</span>=<span class=string>true</span></span><br></pre></table></figure><h4 id=4-4-3-2、禁用-Jolokia><a title="4.4.3.2、禁用 Jolokia" class=headerlink href=#4-4-3-2、禁用-Jolokia></a>4.4.3.2、禁用 Jolokia</h4><p>如果您使用 Jolokia 但不希望 Spring Boot 对其进行配置，则将<code>management.endpoint.jolokia.enabled</code>属性设置为<code>false</code>，如下所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoint.jolokia.enabled</span>=<span class=string>false</span></span><br></pre></table></figure><h2 id=4-5、Loggers><a class=headerlink href=#4-5、Loggers title=4.5、Loggers></a>4.5、Loggers</h2><p>Spring Boot Actuator 可以在运行时查看和配置应用程序的日志级别。您可以查看整个列表，也可以查看单个 Logger 的配置，该配置由显式配置的记录级别以及由记录框架赋予它的有效记录级别组成。这些级别可以是以下之一：<ul><li><code>TRACE</code><li><code>DEBUG</code><li><code>INFO</code><li><code>WARN</code><li><code>ERROR</code><li><code>FATAL</code><li><code>OFF</code><li><code>null</code></ul><p><code>null</code>表示没有显式配置。<h3 id=4-5-1、配置Logger><a class=headerlink href=#4-5-1、配置Logger title=4.5.1、配置Logger></a>4.5.1、配置Logger</h3><p>要配置给定的 Logger，请为资源的 URI <code>POST</code>部分实体，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>{</span><br><span class=line>	"configuredLevel": "DEBUG"</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>要“重置”Logger 的特定级别(并使用默认配置)，可以将值<code>null</code>作为<code>configuredLevel</code>传递。</blockquote><h2 id=4-6、Metrics><a class=headerlink href=#4-6、Metrics title=4.6、Metrics></a>4.6、Metrics</h2><p>Spring Boot Actuator 为<a href=https://micrometer.io/ rel=noopener target=_blank>Micrometer</a>提供依赖关系 Management 和自动配置，<a href=https://micrometer.io/ rel=noopener target=_blank>Micrometer</a>是一种应用程序 Metrics 外观，支持众多监视系统，包括：<ul><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-appoptics rel=noopener target=_blank>AppOptics</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-atlas rel=noopener target=_blank>Atlas</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-datadog rel=noopener target=_blank>Datadog</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-dynatrace rel=noopener target=_blank>Dynatrace</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-dynatrace rel=noopener target=_blank>Elastic</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-ganglia rel=noopener target=_blank>Ganglia</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-graphite rel=noopener target=_blank>Graphite</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-humio rel=noopener target=_blank>Humio</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-influx rel=noopener target=_blank>Influx</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-jmx rel=noopener target=_blank>JMX</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-kairos rel=noopener target=_blank>KairosDB</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-newrelic rel=noopener target=_blank>New Relic</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-prometheus rel=noopener target=_blank>Prometheus</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-signalfx rel=noopener target=_blank>SignalFx</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-simple rel=noopener target=_blank>Simple (in-memory)</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-statsd rel=noopener target=_blank>StatsD</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-wavefront rel=noopener target=_blank>Wavefront</a></ul><h3 id=4-6-1、使用-Starter><a title="4.6.1、使用 Starter" class=headerlink href=#4-6-1、使用-Starter></a>4.6.1、使用 Starter</h3><p>Spring Boot 自动配置组合<code>MeterRegistry</code>，并为其在 Classpath 上找到的每个受支持的实现向组合添加注册表。在运行时 Classpath 中具有<code>micrometer-registry-{system}</code>的依赖关系足以让 Spring Boot 配置注册表。<p>大多数注册表具有共同的 Feature。例如，即使 Micrometer 注册表实现位于 Classpath 中，您也可以禁用特定的注册表。例如，要禁用 Datadog：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.metrics.export.datadog.enabled</span>=<span class=string>false</span></span><br></pre></table></figure><p>Spring Boot 还会将任何自动配置的注册表添加到<code>Metrics</code>类的全局静态复合注册表中，除非您明确告知不要：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.metrics.use-global-registry</span>=<span class=string>false</span></span><br></pre></table></figure><p>您可以注册任意数量的<code>MeterRegistryCustomizer</code> bean 来进一步配置注册表，例如在向注册表注册任何计量器之前应用通用标签：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line>MeterRegistryCustomizer&LTMeterRegistry> <span class="title function_">metricsCommonTags</span><span class=params>()</span> {</span><br><span class=line>	<span class=keyword>return</span> registry -> registry.config().commonTags(<span class=string>"region"</span>, <span class=string>"us-east-1"</span>);</span><br><span class=line>}</span><br></pre></table></figure><p>您可以通过更具体地了解通用类型，将自定义应用于特定的注册表实现：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line>MeterRegistryCustomizer&LTGraphiteMeterRegistry> <span class="title function_">graphiteMetricsNamingConvention</span><span class=params>()</span> {</span><br><span class=line>	<span class=keyword>return</span> registry -> registry.config().namingConvention(MY_CUSTOM_CONVENTION);</span><br><span class=line>}</span><br></pre></table></figure><p>完成该设置后，您可以在组件中注入<code>MeterRegistry</code>并注册 Metrics：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SampleBean</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> Counter counter;</span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">SampleBean</span><span class=params>(MeterRegistry registry)</span> {</span><br><span class=line>		<span class=built_in>this</span>.counter = registry.counter(<span class=string>"received.messages"</span>);</span><br><span class=line>	}</span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">handleMessage</span><span class=params>(String message)</span> {</span><br><span class=line>		<span class=built_in>this</span>.counter.increment();</span><br><span class=line>		<span class=comment>// handle message implementation</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>Spring Boot 也是<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-meter rel=noopener target=_blank>配置内置仪器</a>(即<code>MeterBinder</code>实现)，您可以通过配置或专用 Comments 标记进行控制。<h3 id=4-6-2、支持的监视系统><a class=headerlink href=#4-6-2、支持的监视系统 title=4.6.2、支持的监视系统></a>4.6.2、支持的监视系统</h3><h4 id=4-6-2-1、AppOptics><a class=headerlink href=#4-6-2-1、AppOptics title=4.6.2.1、AppOptics></a>4.6.2.1、AppOptics</h4><p>默认情况下，AppOptics 注册表会定期将 Metrics 推送到<a href=https://api.appoptics.com/v1/measurements rel=noopener target=_blank>api.appoptics.com/v1/measurements</a>。要将 Metrics 导出到 SaaS <a href=http://micrometer.io/docs/registry/appoptics rel=noopener target=_blank>AppOptics</a>，必须提供您的 API 令牌：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.appoptics.api-token=YOUR_TOKEN</span><br></pre></table></figure><h4 id=4-6-2-2、Atlas><a class=headerlink href=#4-6-2-2、Atlas title=4.6.2.2、Atlas></a>4.6.2.2、Atlas</h4><p>默认情况下，度量标准导出到在本地计算机上运行的<a href=http://micrometer.io/docs/registry/atlas rel=noopener target=_blank>Atlas</a>。可以使用以下方式提供要使用的<a href=https://github.com/Netflix/atlas rel=noopener target=_blank>Atlas server</a>的位置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.atlas.uri=http://atlas.example.com:7101/api/v1/publish</span><br></pre></table></figure><h4 id=4-6-2-3、Datadog><a class=headerlink href=#4-6-2-3、Datadog title=4.6.2.3、Datadog></a>4.6.2.3、Datadog</h4><p>Datadog 注册表会定期将 Metrics 推送到<a href=https://www.datadoghq.com/ rel=noopener target=_blank>datadoghq</a>。要将 Metrics 导出到<a href=http://micrometer.io/docs/registry/datadog rel=noopener target=_blank>Datadog</a>，必须提供您的 API 密钥：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.datadog.api-key=YOUR_KEY</span><br></pre></table></figure><p>您还可以更改将度量标准发送到 Datadog 的时间间隔：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.datadog.step=30s</span><br></pre></table></figure><h4 id=4-6-2-4、Dynatrace><a class=headerlink href=#4-6-2-4、Dynatrace title=4.6.2.4、Dynatrace></a>4.6.2.4、Dynatrace</h4><p>Dynatrace 注册表会定期将 Metrics 推送到配置的 URI。要将 Metrics 导出到<a href=http://micrometer.io/docs/registry/dynatrace rel=noopener target=_blank>Dynatrace</a>，必须提供您的 API 令牌，设备 ID 和 URI：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>management.metrics.export.dynatrace.api-token=YOUR_TOKEN</span><br><span class=line>management.metrics.export.dynatrace.device-id=YOUR_DEVICE_ID</span><br><span class=line>management.metrics.export.dynatrace.uri=YOUR_URI</span><br></pre></table></figure><p>您还可以更改将度量标准发送到 Dynatrace 的时间间隔：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.dynatrace.step=30s</span><br></pre></table></figure><h4 id=4-6-2-5、Elastic><a class=headerlink href=#4-6-2-5、Elastic title=4.6.2.5、Elastic></a>4.6.2.5、Elastic</h4><p>默认情况下，度量标准导出到在本地计算机上运行的<a href=http://micrometer.io/docs/registry/elastic rel=noopener target=_blank>Elastic</a>。可以使用以下属性提供要使用的 Elastic 服务器的位置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.elastic.host=http://elastic.example.com:8086</span><br></pre></table></figure><h4 id=4-6-2-6、Ganglia><a class=headerlink href=#4-6-2-6、Ganglia title=4.6.2.6、Ganglia></a>4.6.2.6、Ganglia</h4><p>默认情况下，度量标准导出到在本地计算机上运行的<a href=http://micrometer.io/docs/registry/ganglia rel=noopener target=_blank>Ganglia</a>。可以使用以下方式提供要使用的<a href=http://ganglia.sourceforge.net/ rel=noopener target=_blank>Ganglia server</a>主机和端口：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>management.metrics.export.ganglia.host=ganglia.example.com</span><br><span class=line>management.metrics.export.ganglia.port=9649</span><br></pre></table></figure><h4 id=4-6-2-7、Graphite><a class=headerlink href=#4-6-2-7、Graphite title=4.6.2.7、Graphite></a>4.6.2.7、Graphite</h4><p>默认情况下，度量标准导出到在本地计算机上运行的<a href=http://micrometer.io/docs/registry/graphite rel=noopener target=_blank>Graphite</a>。可以使用以下方式提供要使用的<a href=https://graphiteapp.org/ rel=noopener target=_blank>Graphite server</a>主机和端口：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>management.metrics.export.graphite.host=graphite.example.com</span><br><span class=line>management.metrics.export.graphite.port=9004</span><br></pre></table></figure><p>千分尺提供默认值<code>HierarchicalNameMapper</code>，该默认值<code>HierarchicalNameMapper</code>决定尺寸表 ID <a href=http://micrometer.io/docs/registry/graphite#_hierarchical_name_mapping rel=noopener target=_blank>Map 到平面层次结构名称</a>的方式。<blockquote><p>要控制此行为，请定义您的<code>GraphiteMeterRegistry</code>并提供您自己的<code>HierarchicalNameMapper</code>。除非您定义自己的，否则将提供自动配置的<code>GraphiteConfig</code>和<code>Clock</code> bean：</blockquote><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> GraphiteMeterRegistry <span class="title function_">graphiteMeterRegistry</span><span class=params>(GraphiteConfig config, Clock clock)</span> {</span><br><span class=line>	<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">GraphiteMeterRegistry</span>(config, clock, MY_HIERARCHICAL_MAPPER);</span><br><span class=line>}</span><br></pre></table></figure><h4 id=4-6-2-8、Humio><a class=headerlink href=#4-6-2-8、Humio title=4.6.2.8、Humio></a>4.6.2.8、Humio</h4><p>默认情况下，Humio 注册表会定期将 Metrics 推送到<a href=https://cloud.humio.com/ rel=noopener target=_blank>cloud.humio.com</a>。要将 Metrics 导出到 SaaS <a href=http://micrometer.io/docs/registry/humio rel=noopener target=_blank>Humio</a>，必须提供您的 API 令牌：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.humio.api-token=YOUR_TOKEN</span><br></pre></table></figure><p>您还应该配置一个或多个标记以标识将度量标准推送到的数据源：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>management.metrics.export.humio.tags.alpha=a</span><br><span class=line>management.metrics.export.humio.tags.bravo=b</span><br></pre></table></figure><h4 id=4-6-2-9、Influx><a class=headerlink href=#4-6-2-9、Influx title=4.6.2.9、Influx></a>4.6.2.9、Influx</h4><p>默认情况下，度量标准导出到在本地计算机上运行的<a href=http://micrometer.io/docs/registry/influx rel=noopener target=_blank>Influx</a>。可以使用以下方式提供要使用的<a href=https://www.influxdata.com/ rel=noopener target=_blank>Influx server</a>的位置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.influx.uri=http://influx.example.com:8086</span><br></pre></table></figure><h4 id=4-6-2-10、JMX><a class=headerlink href=#4-6-2-10、JMX title=4.6.2.10、JMX></a>4.6.2.10、JMX</h4><p>千分尺提供到<a href=http://micrometer.io/docs/registry/jmx rel=noopener target=_blank>JMX</a>的层次结构 Map，主要是作为一种便宜且可移植的方式在本地查看 Metrics。默认情况下，Metrics 会导出到<code>metrics</code> JMX 域。可以使用以下方式提供要使用的域：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.jmx.domain=com.example.app.metrics</span><br></pre></table></figure><p>千分尺提供默认值<code>HierarchicalNameMapper</code>，该默认值<code>HierarchicalNameMapper</code>决定尺寸表 ID <a href=http://micrometer.io/docs/registry/jmx#_hierarchical_name_mapping rel=noopener target=_blank>Map 到平面层次结构名称</a>的方式。<blockquote><p>要控制此行为，请定义您的<code>JmxMeterRegistry</code>并提供您自己的<code>HierarchicalNameMapper</code>。除非您定义自己的，否则将提供自动配置的<code>JmxConfig</code>和<code>Clock</code> bean：</blockquote><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> JmxMeterRegistry <span class="title function_">jmxMeterRegistry</span><span class=params>(JmxConfig config, Clock clock)</span> {</span><br><span class=line>	<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">JmxMeterRegistry</span>(config, clock, MY_HIERARCHICAL_MAPPER);</span><br><span class=line>}</span><br></pre></table></figure><h4 id=4-6-2-11、KairosDB><a class=headerlink href=#4-6-2-11、KairosDB title=4.6.2.11、KairosDB></a>4.6.2.11、KairosDB</h4><p>默认情况下，度量标准导出到在本地计算机上运行的<a href=http://micrometer.io/docs/registry/kairos rel=noopener target=_blank>KairosDB</a>。可以使用以下方式提供要使用的<a href=https://kairosdb.github.io/ rel=noopener target=_blank>KairosDB server</a>的位置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.kairos.uri=http://kairosdb.example.com:8080/api/v1/datapoints</span><br></pre></table></figure><h4 id=4-6-2-12、New-Relic><a title="4.6.2.12、New Relic" class=headerlink href=#4-6-2-12、New-Relic></a>4.6.2.12、New Relic</h4><p>新的 Relic 注册表会定期将 Metrics 推送到<a href=http://micrometer.io/docs/registry/new-relic rel=noopener target=_blank>New Relic</a>。要将 Metrics 导出到<a href=https://newrelic.com/ rel=noopener target=_blank>New Relic</a>，必须提供您的 API 密钥和帐户 ID：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>management.metrics.export.newrelic.api-key=YOUR_KEY</span><br><span class=line>management.metrics.export.newrelic.account-id=YOUR_ACCOUNT_ID</span><br></pre></table></figure><p>您还可以更改将度量标准发送到 New Relic 的时间间隔：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.newrelic.step=30s</span><br></pre></table></figure><h4 id=4-6-2-13、Prometheus><a class=headerlink href=#4-6-2-13、Prometheus title=4.6.2.13、Prometheus></a>4.6.2.13、Prometheus</h4><p><a href=http://micrometer.io/docs/registry/prometheus rel=noopener target=_blank>Prometheus</a>希望抓取或轮询单个应用程序实例以获取 Metrics。 Spring Boot 在<code>/actuator/prometheus</code>处提供了一个 Actuator 端点，以渲染具有适当格式的<a href=https://prometheus.io/ rel=noopener target=_blank>Prometheus scrape</a>。<p>这是将<code>scrape_config</code>添加到<code>prometheus.yml</code>的示例：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>scrape_configs:</span><br><span class=line>  - job_name: 'spring'</span><br><span class=line>	metrics_path: '/actuator/prometheus'</span><br><span class=line>	static_configs:</span><br><span class=line>	  - targets: ['HOST:PORT']</span><br></pre></table></figure><h4 id=4-6-2-14、SignalFx><a class=headerlink href=#4-6-2-14、SignalFx title=4.6.2.14、SignalFx></a>4.6.2.14、SignalFx</h4><p>SignalFx 注册表会定期将 Metrics 推送到<a href=http://micrometer.io/docs/registry/signalfx rel=noopener target=_blank>SignalFx</a>。要将 Metrics 导出到<a href=https://signalfx.com/ rel=noopener target=_blank>SignalFx</a>，必须提供您的访问令牌：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.signalfx.access-token=YOUR_ACCESS_TOKEN</span><br></pre></table></figure><p>您还可以更改将度量标准发送到 SignalFx 的时间间隔：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.signalfx.step=30s</span><br></pre></table></figure><h4 id=4-6-2-15、Simple><a class=headerlink href=#4-6-2-15、Simple title=4.6.2.15、Simple></a>4.6.2.15、Simple</h4><p>千分尺附带一个简单的内存后端，如果未配置其他注册表，该后端将自动用作后备。这使您可以查看<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-endpoint rel=noopener target=_blank>metrics endpoint</a>中收集了哪些 Metrics。<p>使用任何其他可用后端时，内存后端都会自行禁用。您还可以显式禁用它：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.simple.enabled=false</span><br></pre></table></figure><h4 id=4-6-2-16、StatsD><a class=headerlink href=#4-6-2-16、StatsD title=4.6.2.16、StatsD></a>4.6.2.16、StatsD</h4><p>StatsD 注册表急切地通过 UDP 将度量标准推送到 StatsD 代理。默认情况下，Metrics 会导出到本地计算机上运行的<a href=http://micrometer.io/docs/registry/statsd rel=noopener target=_blank>StatsD</a>代理。可以使用以下方式提供要使用的 StatsD 代理主机和端口：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>management.metrics.export.statsd.host=statsd.example.com</span><br><span class=line>management.metrics.export.statsd.port=9125</span><br></pre></table></figure><p>您还可以更改要使用的 StatsD 线路协议(默认为 Datadog)：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.statsd.flavor=etsy</span><br></pre></table></figure><h4 id=4-6-2-17、Wavefront><a class=headerlink href=#4-6-2-17、Wavefront title=4.6.2.17、Wavefront></a>4.6.2.17、Wavefront</h4><p>Wavefront 注册表会定期将 Metrics 推送到<a href=http://micrometer.io/docs/registry/wavefront rel=noopener target=_blank>Wavefront</a>。如果您直接将 Metrics 导出到<a href=https://www.wavefront.com/ rel=noopener target=_blank>Wavefront</a>，则必须提供您的 API 令牌：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.wavefront.api-token=YOUR_API_TOKEN</span><br></pre></table></figure><p>或者，您可以使用在您的环境中设置的 Wavefront 辅助工具或内部代理，将 Metrics 数据转发到 Wavefront API 主机：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.wavefront.uri=proxy://localhost:2878</span><br></pre></table></figure><blockquote><p>如果将 Metrics 发布到 Wavefront 代理(如<a href=https://docs.wavefront.com/proxies_installing.html rel=noopener target=_blank>the documentation</a>中所述)，则主机必须为<code>proxy://HOST:PORT</code>格式。</blockquote><p>您还可以更改将度量标准发送到 Wavefront 的时间间隔：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.wavefront.step=30s</span><br></pre></table></figure><h3 id=4-6-3、支持的-Metrics><a title="4.6.3、支持的 Metrics" class=headerlink href=#4-6-3、支持的-Metrics></a>4.6.3、支持的 Metrics</h3><p>如果适用，Spring Boot 将注册以下核心 Metrics：<ul><li>JVM Metrics，报告以下方面的利用率：<li>各种内存和缓冲池<ul><li>与垃圾收集有关的统计数据<li>Threads utilization<li>加载/卸载的类数</ul><li>CPU metrics<li>文件 DescriptorsMetrics<li>KafkaConsumerMetrics<li>Log4j2 Metrics：记录每个级别记录到 Log4j2 的事件数<li>Logback Metrics：记录每个级别记录到 Logback 的事件数<li>正常运行时间 Metrics：报告正常运行时间的量度和代表应用程序绝对启动时间的固定量度<li>Tomcat metrics<li><a href=https://docs.spring.io/spring-integration/docs/current/reference/html/system-management-chapter.html#micrometer-integration rel=noopener target=_blank>Spring Integration</a> metrics</ul><h4 id=4-6-3-1、Spring-MVC-Metrics><a title="4.6.3.1、Spring MVC Metrics" class=headerlink href=#4-6-3-1、Spring-MVC-Metrics></a>4.6.3.1、Spring MVC Metrics</h4><p>通过自动配置，可以检测由 Spring MVC 处理的请求。当<code>management.metrics.web.server.auto-time-requests</code>为<code>true</code>时，将对所有请求进行检测。或者，当设置为<code>false</code>时，可以通过将<code>@Timed</code>添加到请求处理方法来启用检测：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@RestController</span></span><br><span class=line><span class=meta>@Timed</span> (<span class=number>1</span>)</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyController</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@GetMapping("/api/people")</span></span><br><span class=line>	<span class=meta>@Timed(extraTags = { "region", "us-east-1" })</span> (<span class=number>2</span>)</span><br><span class=line>	<span class=meta>@Timed(value = "all.people", longTask = true)</span> (<span class=number>3</span>)</span><br><span class=line>	<span class=keyword>public</span> List&LTPerson> <span class="title function_">listPeople</span><span class=params>()</span> { ... }</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><ul><li><strong>(1)</strong> 控制器类，用于对控制器中的每个请求处理程序启用计时。<li><strong>(2)</strong> 一种启用单个端点的方法。如果您将它放在类中，则不必这样做，但是可以用于进一步为此特定端点自定义计时器。<li><strong>(3)</strong> 具有<code>longTask = true</code>的方法为该方法启用长任务计时器。长任务计时器需要一个单独的度量标准名称，并且可以与短任务计时器堆叠在一起。</ul><p>默认情况下，使用名称<code>http.server.requests</code>生成度量。可以通过设置<code>management.metrics.web.server.requests-metric-name</code>属性来自定义名称。<p>默认情况下，与 Spring MVC 相关的 Metrics 带有以下信息标记：<table><thead><tr><th>Tag<th>Description<tbody><tr><td><code>exception</code><td>处理请求时引发的任何异常的简单类名。<tr><td><code>method</code><td>请求的方法(例如<code>GET</code>或<code>POST</code>)<tr><td><code>outcome</code><td>请求的结果基于响应的状态码。 1xx 是<code>INFORMATIONAL</code>，2xx 是<code>SUCCESS</code>，3xx 是<code>REDIRECTION</code>，4xx <code>CLIENT_ERROR</code>，5xx 是<code>SERVER_ERROR</code><tr><td><code>status</code><td>响应的 HTTP 状态代码(例如<code>200</code>或<code>500</code>)<tr><td><code>uri</code><td>变量替换之前的请求 URI 模板(如果可能)(例如<code>/api/person/{id}</code>)</table><p>要自定义标签，请提供实现<code>WebMvcTagsProvider</code>的<code>@Bean</code>。<h4 id=4-6-3-2、Spring-WebFlux-Metrics><a title="4.6.3.2、Spring WebFlux Metrics" class=headerlink href=#4-6-3-2、Spring-WebFlux-Metrics></a>4.6.3.2、Spring WebFlux Metrics</h4><p>通过自动配置，可以检测 WebFlux 控制器和功能处理程序处理的所有请求。<p>默认情况下，使用名称<code>http.server.requests</code>生成度量。您可以通过设置<code>management.metrics.web.server.requests-metric-name</code>属性来自定义名称。<p>默认情况下，与 WebFlux 相关的度量标准标记有以下信息：<table><thead><tr><th>Tag<th>Description<tbody><tr><td><code>exception</code><td>处理请求时引发的任何异常的简单类名。<tr><td><code>method</code><td>请求的方法(例如<code>GET</code>或<code>POST</code>)<tr><td><code>outcome</code><td>请求的结果基于响应的状态码。 1xx 是<code>INFORMATIONAL</code>，2xx 是<code>SUCCESS</code>，3xx 是<code>REDIRECTION</code>，4xx <code>CLIENT_ERROR</code>，5xx 是<code>SERVER_ERROR</code><tr><td><code>status</code><td>响应的 HTTP 状态代码(例如<code>200</code>或<code>500</code>)<tr><td><code>uri</code><td>变量替换之前的请求 URI 模板(如果可能)(例如<code>/api/person/{id}</code>)</table><p>要自定义标签，请提供实现<code>WebFluxTagsProvider</code>的<code>@Bean</code>。<h4 id=4-6-3-3、Jersey-服务器-Metrics><a title="4.6.3.3、Jersey 服务器 Metrics" class=headerlink href=#4-6-3-3、Jersey-服务器-Metrics></a>4.6.3.3、Jersey 服务器 Metrics</h4><p>通过自动配置，可以检测由 Jersey JAX-RS 实现处理的请求。当<code>management.metrics.web.server.auto-time-requests</code>为<code>true</code>时，将对所有请求进行检测。或者，当设置为<code>false</code>时，可以通过将<code>@Timed</code>添加到请求处理方法来启用检测：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Path("/api/people")</span></span><br><span class=line><span class=meta>@Timed</span> (<span class=number>1</span>)</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Endpoint</span> {</span><br><span class=line>	<span class=meta>@GET</span></span><br><span class=line>	<span class=meta>@Timed(extraTags = { "region", "us-east-1" })</span> (<span class=number>2</span>)</span><br><span class=line>	<span class=meta>@Timed(value = "all.people", longTask = true)</span> (<span class=number>3</span>)</span><br><span class=line>	<span class=keyword>public</span> List&LTPerson> <span class="title function_">listPeople</span><span class=params>()</span> { ... }</span><br><span class=line>}</span><br></pre></table></figure><ul><li><strong>(1)</strong> 在资源类上，以对资源中的每个请求处理程序启用计时。<li><strong>(2)</strong> 关于启用单个端点的方法。如果您将它放在类中，则不必这样做，但是可以用于进一步为此特定端点自定义计时器。<li><strong>(3)</strong> 在具有<code>longTask = true</code>的方法上为该方法启用长任务计时器。长任务计时器需要一个单独的度量标准名称，并且可以与短任务计时器堆叠在一起。</ul><p>默认情况下，使用名称<code>http.server.requests</code>生成度量。可以通过设置<code>management.metrics.web.server.requests-metric-name</code>属性来自定义名称。<p>默认情况下，Jersey 服务器 Metrics 带有以下信息：<table><thead><tr><th>Tag<th>Description<tbody><tr><td><code>exception</code><td>处理请求时引发的任何异常的简单类名。<tr><td><code>method</code><td>请求的方法(例如<code>GET</code>或<code>POST</code>)<tr><td><code>outcome</code><td>请求的结果基于响应的状态码。 1xx 是<code>INFORMATIONAL</code>，2xx 是<code>SUCCESS</code>，3xx 是<code>REDIRECTION</code>，4xx <code>CLIENT_ERROR</code>，5xx 是<code>SERVER_ERROR</code><tr><td><code>status</code><td>响应的 HTTP 状态代码(例如<code>200</code>或<code>500</code>)<tr><td><code>uri</code><td>变量替换之前的请求 URI 模板(如果可能)(例如<code>/api/person/{id}</code>)</table><p>要自定义标签，请提供实现<code>JerseyTagsProvider</code>的<code>@Bean</code>。<h4 id=4-6-3-4、HTTP-Client-端-Metrics><a title="4.6.3.4、HTTP Client 端 Metrics" class=headerlink href=#4-6-3-4、HTTP-Client-端-Metrics></a>4.6.3.4、HTTP Client 端 Metrics</h4><p>Spring Boot Actuator Management<code>RestTemplate</code>和<code>WebClient</code>的工具。为此，您必须注入自动配置的构建器并使用它来创建实例：<ul><li><code>RestTemplateBuilder</code> <code>RestTemplate</code><li><code>WebClient.Builder</code> <code>WebClient</code></ul><p>也可以手动应用负责此工具的定制程序，即<code>MetricsRestTemplateCustomizer</code>和<code>MetricsWebClientCustomizer</code>。<p>默认情况下，使用名称<code>http.client.requests</code>生成度量。可以通过设置<code>management.metrics.web.client.requests-metric-name</code>属性来自定义名称。<p>默认情况下，由检测的 Client 端生成的度量标准标记有以下信息：<ul><li><code>method</code>，即请求的方法(例如<code>GET</code>或<code>POST</code>)。<li><code>uri</code>，变量替换之前的请求 URI 模板(如果可能的话，例如<code>/api/person/{id}</code>)。<li><code>status</code>，即响应的 HTTP 状态代码(例如<code>200</code>或<code>500</code>)。<li><code>clientName</code>，即 URI 的主机部分。</ul><p>要自定义标签，并根据您选择的 Client 端，可以提供实现<code>RestTemplateExchangeTagsProvider</code>或<code>WebClientExchangeTagsProvider</code>的<code>@Bean</code>。 <code>RestTemplateExchangeTags</code>和<code>WebClientExchangeTags</code>中有便捷的静态函数。<h4 id=4-6-3-5、缓存-Metrics><a title="4.6.3.5、缓存 Metrics" class=headerlink href=#4-6-3-5、缓存-Metrics></a>4.6.3.5、缓存 Metrics</h4><p>通过自动配置，可以在启动时使用前缀<code>cache</code>的度量来检测所有可用的<code>Cache</code>。高速缓存检测针对一组基本 Metrics 进行了标准化。还提供其他特定于缓存的 Metrics。<p>支持以下缓存库：<ul><li>Caffeine<li>EhCache 2<li>Hazelcast<li>任何兼容的 JCache(JSR-107)实现</ul><p>用高速缓存的名称和从 Bean 名称派生的<code>CacheManager</code>的名称来标记度量标准。<h4 id=4-6-3-6、数据源-Metrics><a title="4.6.3.6、数据源 Metrics" class=headerlink href=#4-6-3-6、数据源-Metrics></a>4.6.3.6、数据源 Metrics</h4><p>通过自动配置，可以使用名为<code>jdbc</code>的度量标准检测所有可用的<code>DataSource</code>对象。数据源检测产生的量规表示池中当前 Active，最大允许和最小允许的连接。这些仪表中的每个都有一个以<code>jdbc</code>为前缀的名称。<p>度量标准还标有根据 Bean 名称计算出的<code>DataSource</code>的名称。<blockquote><p>默认情况下，Spring Boot 为所有支持的数据源提供元数据。如果不支持立即使用您喜欢的数据源，则可以添加其他<code>DataSourcePoolMetadataProvider</code> bean。有关示例，请参见<code>DataSourcePoolMetadataProvidersConfiguration</code>。</blockquote><p>此外，特定于 Hikari 的 Metrics 以<code>hikaricp</code>前缀公开。每个度量标准都由池的名称标记(可以使用<code>spring.datasource.name</code>进行控制)。<h4 id=4-6-3-7、HibernateMetrics><a class=headerlink href=#4-6-3-7、HibernateMetrics title=4.6.3.7、HibernateMetrics></a>4.6.3.7、HibernateMetrics</h4><p>通过自动配置，可以检测所有可用名为<code>hibernate</code>的 Metrics 启用了统计信息的 Hibernate <code>EntityManagerFactory</code>实例。<p>度量标准还标有从 Bean 名称派生的<code>EntityManagerFactory</code>的名称。<p>要启用统计信息，必须将标准 JPA 属性<code>hibernate.generate_statistics</code>设置为<code>true</code>。您可以在自动配置的<code>EntityManagerFactory</code>上启用它，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.jpa.properties.hibernate.generate_statistics=true</span><br></pre></table></figure><h4 id=4-6-3-8、RabbitMQ-Metrics><a title="4.6.3.8、RabbitMQ Metrics" class=headerlink href=#4-6-3-8、RabbitMQ-Metrics></a>4.6.3.8、RabbitMQ Metrics</h4><p>自动配置将启用所有名为<code>rabbitmq</code>的度量的可用 RabbitMQ 连接工厂的检测。<h3 id=4-6-4、注册自定义-Metrics><a title="4.6.4、注册自定义 Metrics" class=headerlink href=#4-6-4、注册自定义-Metrics></a>4.6.4、注册自定义 Metrics</h3><p>要注册自定义 Metrics，请在组件中注入<code>MeterRegistry</code>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">Dictionary</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> List&LTString> words = <span class=keyword>new</span> <span class="title class_">CopyOnWriteArrayList</span><>();</span><br><span class=line>	Dictionary(MeterRegistry registry) {</span><br><span class=line>		registry.gaugeCollectionSize(<span class=string>"dictionary.size"</span>, Tags.empty(), <span class=built_in>this</span>.words);</span><br><span class=line>	}</span><br><span class=line>	<span class=comment>// …</span></span><br><span class=line>}</span><br></pre></table></figure><p>如果发现您在组件或应用程序中反复测试了一套 Metrics，则可以将此套件封装在<code>MeterBinder</code>实现中。默认情况下，所有<code>MeterBinder</code> bean 的度量将自动绑定到 Spring Management 的<code>MeterRegistry</code>。<h3 id=4-6-5、自定义单个-Metrics><a title="4.6.5、自定义单个 Metrics" class=headerlink href=#4-6-5、自定义单个-Metrics></a>4.6.5、自定义单个 Metrics</h3><p>如果您需要对特定的<code>Meter</code>实例应用自定义设置，则可以使用<code>io.micrometer.core.instrument.config.MeterFilter</code>界面。默认情况下，所有<code>MeterFilter</code> bean 将自动应用于千分尺<code>MeterRegistry.Config</code>。<p>例如，如果要将所有以<code>com.example</code>开头的仪表 ID 的<code>mytag.region</code>标签重命名为<code>mytag.area</code>，则可以执行以下操作：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> MeterFilter <span class="title function_">renameRegionTagMeterFilter</span><span class=params>()</span> {</span><br><span class=line>	<span class=keyword>return</span> MeterFilter.renameTag(<span class=string>"com.example"</span>, <span class=string>"mytag.region"</span>, <span class=string>"mytag.area"</span>);</span><br><span class=line>}</span><br></pre></table></figure><h4 id=4-6-5-1、常用标签><a class=headerlink href=#4-6-5-1、常用标签 title=4.6.5.1、常用标签></a>4.6.5.1、常用标签</h4><p>通用标签通常用于在操作环境(如主机，实例，区域，堆栈等)上进行维度深入分析。通用标签适用于所有仪表，可以按以下示例所示进行配置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>management.metrics.tags.region=us-east-1</span><br><span class=line>management.metrics.tags.stack=prod</span><br></pre></table></figure><p>上面的示例将<code>region</code>和<code>stack</code>标签添加到所有仪表，其值分别为<code>us-east-1</code>和<code>prod</code>。<blockquote><p>如果使用 Graphite，则常用标签的 Sequences 很重要。由于使用这种方法不能保证通用标签的 Sequences，因此建议 Graphite 用户定义自定义<code>MeterFilter</code>。</blockquote><h4 id=4-6-5-2、每米属性><a class=headerlink href=#4-6-5-2、每米属性 title=4.6.5.2、每米属性></a>4.6.5.2、每米属性</h4><p>除了<code>MeterFilter</code> bean 外，还可以使用属性在每米基础上应用有限的一组自定义设置。每表定制适用于以给定名称开头的所有所有表 ID。例如，以下将禁用所有 ID 以<code>example.remote</code>开头的仪表<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.enable.example.remote=false</span><br></pre></table></figure><p>以下属性允许按米自定义：<p><strong>表 57.1. 每米自定义</strong><table><thead><tr><th>Property<th>Description<tbody><tr><td><code>management.metrics.enable</code><td>是否拒绝仪表发出任何 Metrics。<tr><td><code>management.metrics.distribution.percentiles-histogram</code><td>是否发布适合计算可凝集(跨维度)百分位数逼近的直方图。<tr><td><code>management.metrics.distribution.minimum-expected-value</code> , <code>management.metrics.distribution.maximum-expected-value</code><td>通过限制期望值的范围来发布较少的直方图桶。<tr><td><code>management.metrics.distribution.percentiles</code><td>发布在应用程序中计算的百分位值<tr><td><code>management.metrics.distribution.sla</code><td>发布包含您的 SLA 定义的存储区的累积直方图。</table><p>有关<code>percentiles-histogram</code>，<code>percentiles</code>和<code>sla</code>后面的概念的更多详细信息，请参阅千分尺文档的<a href=https://micrometer.io/docs/concepts#_histograms_and_percentiles rel=noopener target=_blank>“直方图和百分位数”部分</a>。<h3 id=4-6-6、Metrics-终结点><a title="4.6.6、Metrics 终结点" class=headerlink href=#4-6-6、Metrics-终结点></a>4.6.6、Metrics 终结点</h3><p>Spring Boot 提供了一个<code>metrics</code>端点，可用于诊断检查应用程序收集的 Metrics。该端点默认情况下不可用，必须公开，有关更多详细信息，请参见<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-endpoints.html#production-ready-endpoints-exposing-endpoints rel=noopener target=_blank>exposing endpoints</a>。<p>导航到<code>/actuator/metrics</code>将显示可用仪表名称的列表。您可以通过提供特定名称作为 selectors 来深入查看有关特定仪表的信息，例如<code>/actuator/metrics/jvm.memory.max</code>。<blockquote><p>您在此处使用的名称应与代码中使用的名称相匹配，而不是已针对其出厂的监视系统进行了命名约定标准化后的名称。换句话说，如果<code>jvm.memory.max</code>由于其蛇形命名约定而在 Prometheus 中显示为<code>jvm_memory_max</code>，则在<code>metrics</code>端点中检查电表时，仍应使用<code>jvm.memory.max</code>作为 selectors。</blockquote><p>您还可以在网址末尾添加任意数量的<code>tag=KEY:VALUE</code>查询参数，以在维度上更深入地了解电表，例如<code>/actuator/metrics/jvm.memory.max?tag=area:nonheap</code>。<blockquote><p>报告的测量值是与仪表名称和已应用的所有标签相匹配的所有仪表的统计信息的<em>和</em>。因此，在上面的示例中，返回的“值”统计量是堆的“代码缓存”，“压缩类空间”和“元空间”区域的最大内存占用量的总和。如果您只想查看“ Metaspace”的最大大小，则可以添加一个额外的<code>tag=id:Metaspace</code>，即<code>/actuator/metrics/jvm.memory.max?tag=area:nonheap&tag=id:Metaspace</code>。</blockquote><h2 id=4-7、Auditing><a class=headerlink href=#4-7、Auditing title=4.7、Auditing></a>4.7、Auditing</h2><p>一旦运行了 Spring Security，Spring Boot Actuator 将具有一个灵活的审核框架，该框架可以发布事件(默认情况下，“身份验证成功”，“失败”和“访问被拒绝”异常)。此功能对于基于身份验证失败的报告和实施锁定策略非常有用。要自定义已发布的安全事件，可以提供自己的<code>AbstractAuthenticationAuditListener</code>和<code>AbstractAuthorizationAuditListener</code>实现。<p>您也可以将审核服务用于自己的业务事件。为此，可以将现有的<code>AuditEventRepository</code>注入到您自己的组件中，然后直接使用它，或者通过 Spring <code>ApplicationEventPublisher</code>发布<code>AuditApplicationEvent</code>(通过实现<code>ApplicationEventPublisherAware</code>)。<h2 id=4-8、HTTP-跟踪><a title="4.8、HTTP 跟踪" class=headerlink href=#4-8、HTTP-跟踪></a>4.8、HTTP 跟踪</h2><p>将为所有 HTTP 请求自动启用跟踪。您可以查看<code>httptrace</code>端点，并获取有关最近 100 次请求-响应交换的基本信息。<h3 id=4-8-1-自定义-HTTP-跟踪><a title="4.8.1 自定义 HTTP 跟踪" class=headerlink href=#4-8-1-自定义-HTTP-跟踪></a>4.8.1 自定义 HTTP 跟踪</h3><p>要自定义每个跟踪中包含的项目，请使用<code>management.trace.http.include</code>配置属性。要进行高级自定义，请考虑注册自己的<code>HttpExchangeTracer</code>实现。<p>默认情况下，使用<code>InMemoryHttpTraceRepository</code>来存储最近 100 次请求-响应交换的跟踪。如果需要扩展容量，则可以定义自己的<code>InMemoryHttpTraceRepository</code> bean 实例。您还可以创建自己的替代<code>HttpTraceRepository</code>实现。<h2 id=4-9、Process-Monitoring><a title="4.9、Process Monitoring" class=headerlink href=#4-9、Process-Monitoring></a>4.9、Process Monitoring</h2><p>在<code>spring-boot</code>模块中，您可以找到两个类来创建通常对过程监视有用的文件：<ul><li><code>ApplicationPidFileWriter</code>创建一个包含应用程序 PID 的文件(默认情况下，在应用程序目录中，文件名为<code>application.pid</code>)。<li><code>WebServerPortFileWriter</code>创建一个(或多个)文件，其中包含正在运行的 Web 服务器的端口(默认情况下，在应用程序目录中，文件名为<code>application.port</code>)。</ul><p>默认情况下，不会激活这些编写器，但是您可以启用：<ul><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-process-monitoring.html#production-ready-process-monitoring-configuration rel=noopener target=_blank>通过扩展配置</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-process-monitoring.html#production-ready-process-monitoring-programmatically rel=noopener target=_blank>第 60.2 节“以编程方式”</a></ul><h3 id=4-9-1、扩展配置><a class=headerlink href=#4-9-1、扩展配置 title=4.9.1、扩展配置></a>4.9.1、扩展配置</h3><p>在<code>META-INF/spring.factories</code>文件中，可以激活写入 PID 文件的侦听器，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>org.springframework.context.ApplicationListener=\</span><br><span class=line>org.springframework.boot.context.ApplicationPidFileWriter,\</span><br><span class=line>org.springframework.boot.web.context.WebServerPortFileWriter</span><br></pre></table></figure><h3 id=4-9-2、Programmatically><a class=headerlink href=#4-9-2、Programmatically title=4.9.2、Programmatically></a>4.9.2、Programmatically</h3><p>您还可以通过调用<code>SpringApplication.addListeners(…)</code>方法并传递适当的<code>Writer</code>对象来激活侦听器。此方法还允许您自定义<code>Writer</code>构造函数中的文件名和路径。<h2 id=4-10、Cloud-Foundry-支持><a title="4.10、Cloud Foundry 支持" class=headerlink href=#4-10、Cloud-Foundry-支持></a>4.10、Cloud Foundry 支持</h2><p>Spring Boot 的 Actuator 模块包括额外的支持，当您将其部署到兼容的 Cloud Foundry 实例时就会激活。 <code>/cloudfoundryapplication</code>路径提供了通往所有<code>@Endpoint</code> bean 的备用安全路由。<p>扩展支持使 Cloud Foundry Management UI(例如可用于查看已部署的应用程序的 Web 应用程序)增加了 Spring Boot Actuator 信息。例如，应用程序状态页面可能包含完整的运行状况信息，而不是典型的“正在运行”或“已停止”状态。<blockquote><p>普通用户无法直接访问<code>/cloudfoundryapplication</code>路径。为了使用端点，必须将有效的 UAA 令牌与请求一起传递。</blockquote><h3 id=4-10-1、禁用扩展的-Cloud-Foundry-Actuator-支持><a title="4.10.1、禁用扩展的 Cloud Foundry Actuator 支持" class=headerlink href=#4-10-1、禁用扩展的-Cloud-Foundry-Actuator-支持></a>4.10.1、禁用扩展的 Cloud Foundry Actuator 支持</h3><p>如果要完全禁用<code>/cloudfoundryapplication</code>端点，则可以将以下设置添加到<code>application.properties</code>文件中：<p><strong>application.properties.</strong><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.cloudfoundry.enabled=false</span><br></pre></table></figure><h3 id=4-10-2、Cloud-Foundry-自签名证书><a title="4.10.2、Cloud Foundry 自签名证书" class=headerlink href=#4-10-2、Cloud-Foundry-自签名证书></a>4.10.2、Cloud Foundry 自签名证书</h3><p>默认情况下，对<code>/cloudfoundryapplication</code>个端点的安全性验证会对各种 Cloud Foundry 服务进行 SSL 调用。如果您的 Cloud Foundry UAA 或 Cloud Controller 服务使用自签名证书，则需要设置以下属性：<p><strong>application.properties.</strong><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.cloudfoundry.skip-ssl-validation=true</span><br></pre></table></figure><h3 id=4-10-3、自定义上下文路径><a class=headerlink href=#4-10-3、自定义上下文路径 title=4.10.3、自定义上下文路径></a>4.10.3、自定义上下文路径</h3><p>如果服务器的上下文路径已配置为<code>/</code>以外的其他值，则 Cloud Foundry 端点在应用程序的根目录将不可用。例如，如果<code>server.servlet.context-path=/app</code>，Cloud Foundry 端点将在<code>/app/cloudfoundryapplication/*</code>可用。<p>如果您希望 Cloud Foundry 端点始终在<code>/cloudfoundryapplication/*</code>可用，而与服务器的上下文路径无关，则需要在应用程序中进行显式配置。配置将根据所使用的 Web 服务器而有所不同。对于 Tomcat，可以添加以下配置：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> TomcatServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class=params>()</span> {</span><br><span class=line>	<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">TomcatServletWebServerFactory</span>() {</span><br><span class=line></span><br><span class=line>		<span class=meta>@Override</span></span><br><span class=line>		<span class=keyword>protected</span> <span class=keyword>void</span> <span class="title function_">prepareContext</span><span class=params>(Host host,</span></span><br><span class=line><span class=params>				ServletContextInitializer[] initializers)</span> {</span><br><span class=line>			<span class=built_in>super</span>.prepareContext(host, initializers);</span><br><span class=line>			<span class=type>StandardContext</span> <span class=variable>child</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StandardContext</span>();</span><br><span class=line>			child.addLifecycleListener(<span class=keyword>new</span> <span class="title class_">Tomcat</span>.FixContextListener());</span><br><span class=line>			child.setPath(<span class=string>"/cloudfoundryapplication"</span>);</span><br><span class=line>			<span class=type>ServletContainerInitializer</span> <span class=variable>initializer</span> <span class=operator>=</span> getServletContextInitializer(</span><br><span class=line>					getContextPath());</span><br><span class=line>			child.addServletContainerInitializer(initializer, Collections.emptySet());</span><br><span class=line>			child.setCrossContext(<span class=literal>true</span>);</span><br><span class=line>			host.addChild(child);</span><br><span class=line>		}</span><br><span class=line></span><br><span class=line>	};</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>private</span> ServletContainerInitializer <span class="title function_">getServletContextInitializer</span><span class=params>(String contextPath)</span> {</span><br><span class=line>	<span class=keyword>return</span> (c, context) -> {</span><br><span class=line>		<span class=type>Servlet</span> <span class=variable>servlet</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">GenericServlet</span>() {</span><br><span class=line></span><br><span class=line>			<span class=meta>@Override</span></span><br><span class=line>			<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">service</span><span class=params>(ServletRequest req, ServletResponse res)</span></span><br><span class=line>					<span class=keyword>throws</span> ServletException, IOException {</span><br><span class=line>				<span class=type>ServletContext</span> <span class=variable>context</span> <span class=operator>=</span> req.getServletContext()</span><br><span class=line>						.getContext(contextPath);</span><br><span class=line>				context.getRequestDispatcher(<span class=string>"/cloudfoundryapplication"</span>).forward(req,</span><br><span class=line>						res);</span><br><span class=line>			}</span><br><span class=line></span><br><span class=line>		};</span><br><span class=line>		context.addServlet(<span class=string>"cloudfoundry"</span>, servlet).addMapping(<span class=string>"/*"</span>);</span><br><span class=line>	};</span><br><span class=line>}</span><br></pre></table></figure><h1 id=5、部署-SpringBoot-应用><a title="5、部署 SpringBoot 应用" class=headerlink href=#5、部署-SpringBoot-应用></a>5、部署 SpringBoot 应用</h1><p>在部署应用程序时，Spring Boot 的灵活打包选项提供了很多选择。您可以将 Spring Boot 应用程序部署到各种云平台，容器映像(例如 Docker)或虚拟机/真实机上。<h2 id=5-1、部署到云端><a class=headerlink href=#5-1、部署到云端 title=5.1、部署到云端></a>5.1、部署到云端</h2><p>Spring Boot 的可执行 jar 已为大多数流行的云 PaaS(平台即服务)提供程序准备就绪。这些提供程序往往要求您“自带容器”。他们 Management 应用程序流程(不是专门用于 Java 应用程序)，因此他们需要一个中间层，以使您的应用程序适应运行过程的“云”概念。<p>两家受欢迎的云提供商，Heroku 和 Cloud Foundry，采用了“构建包”方法。 buildpack 将您部署的代码包装在“启动”应用程序所需的任何内容中。它可能是 JDK，也可能是对<code>java</code>的调用，嵌入式 Web 服务器或成熟的应用程序服务器。一个 buildpack 是可插入的，但是理想情况下，您应该能够通过尽可能少的自定义来获得它。这减少了您无法控制的功能的占用空间。它使开发和生产环境之间的差异最小化。<p>理想情况下，您的应用程序像 Spring Boot 可执行 jar 一样，具有打包运行所需的一切。<p>在本节中，我们将介绍如何在“Starter”部分中启动<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/getting-started-first-application.html rel=noopener target=_blank>我们开发的简单应用程序</a>并在云中运行。<h3 id=5-1-1、Cloud-Foundry><a title="5.1.1、Cloud Foundry" class=headerlink href=#5-1-1、Cloud-Foundry></a>5.1.1、Cloud Foundry</h3><p>如果未指定其他构建包，Cloud Foundry 将提供默认的构建包。 Cloud Foundry <a href=https://github.com/cloudfoundry/java-buildpack rel=noopener target=_blank>Java buildpack</a>对 Spring 应用程序(包括 Spring Boot)提供了出色的支持。您可以部署独立的可执行 jar 应用程序以及传统的<code>.war</code>打包应用程序。<p>一旦构建了应用程序(例如，使用<code>mvn clean package</code>)并拥有<a href=https://docs.cloudfoundry.org/cf-cli/install-go-cli.html rel=noopener target=_blank>安装了 cf 命令行工具</a>，就可以使用<code>cf push</code>命令部署您的应用程序，并替换已编译的<code>.jar</code>的路径。在推送应用程序之前，请确保拥有<a href=https://docs.cloudfoundry.org/cf-cli/getting-started.html#login rel=noopener target=_blank>使用 cf 命令行 Client 端登录</a>。以下行显示了使用<code>cf push</code>命令部署应用程序：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>cf push acloudyspringtime -p target/demo-0.0.1-SNAPSHOT.jar</span></span><br></pre></table></figure><blockquote><p>在前面的示例中，我们用<code>acloudyspringtime</code>代替您给<code>cf</code>作为应用程序名称的任何值。</blockquote><p>有关更多选项，请参见<a href=https://docs.cloudfoundry.org/cf-cli/getting-started.html#push rel=noopener target=_blank>cf 推文档</a>。如果同一目录中存在 Cloud Foundry <a href=https://docs.cloudfoundry.org/devguide/deploy-apps/manifest.html rel=noopener target=_blank>manifest.yml</a>文件，则认为该文件。<p>此时，<code>cf</code>开始上载您的应用程序，产生类似于以下示例的输出：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line>Uploading acloudyspringtime... OK</span><br><span class=line>Preparing to start acloudyspringtime... OK</span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Downloaded app package (8.9M)</span></span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Java Buildpack Version: v3.12 (offline) | https://github.com/cloudfoundry/java-buildpack.git#6f25b7e</span></span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Downloading Open Jdk JRE 1.8.0_121 from https://java-buildpack.cloudfoundry.org/openjdk/trusty/x86_64/openjdk-1.8.0_121.tar.gz (found <span class=keyword>in</span> cache)</span></span><br><span class=line>       Expanding Open Jdk JRE to .java-buildpack/open_jdk_jre (1.6s)</span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Downloading Open JDK Like Memory Calculator 2.0.2_RELEASE from https://java-buildpack.cloudfoundry.org/memory-calculator/trusty/x86_64/memory-calculator-2.0.2_RELEASE.tar.gz (found <span class=keyword>in</span> cache)</span></span><br><span class=line>       Memory Settings: -Xss349K -Xmx681574K -XX:MaxMetaspaceSize=104857K -Xms681574K -XX:MetaspaceSize=104857K</span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Downloading Container Certificate Trust Store 1.0.0_RELEASE from https://java-buildpack.cloudfoundry.org/container-certificate-trust-store/container-certificate-trust-store-1.0.0_RELEASE.jar (found <span class=keyword>in</span> cache)</span></span><br><span class=line>       Adding certificates to .java-buildpack/container_certificate_trust_store/truststore.jks (0.6s)</span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Downloading Spring Auto Reconfiguration 1.10.0_RELEASE from https://java-buildpack.cloudfoundry.org/auto-reconfiguration/auto-reconfiguration-1.10.0_RELEASE.jar (found <span class=keyword>in</span> cache)</span></span><br><span class=line>Checking status of app 'acloudyspringtime'...</span><br><span class=line>  0 of 1 instances running (1 starting)</span><br><span class=line>  ...</span><br><span class=line>  0 of 1 instances running (1 starting)</span><br><span class=line>  ...</span><br><span class=line>  0 of 1 instances running (1 starting)</span><br><span class=line>  ...</span><br><span class=line>  1 of 1 instances running (1 running)</span><br><span class=line></span><br><span class=line>App started</span><br></pre></table></figure><p>恭喜你！该应用程序现已上线！<p>应用程序上线后，可以使用<code>cf apps</code>命令验证已部署应用程序的状态，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>cf apps</span></span><br><span class=line>Getting applications in ...</span><br><span class=line>OK</span><br><span class=line></span><br><span class=line>name                 requested state   instances   memory   disk   urls</span><br><span class=line>...</span><br><span class=line>acloudyspringtime    started           1/1         512M     1G     acloudyspringtime.cfapps.io</span><br><span class=line>...</span><br></pre></table></figure><p>一旦 Cloud Foundry 确认已部署了您的应用程序，您就应该能够在给定的 URI 上找到该应用程序。在前面的示例中，您可以在<code>http://acloudyspringtime.cfapps.io/</code>找到它。<h4 id=5-1-1-1、绑定到服务><a class=headerlink href=#5-1-1-1、绑定到服务 title=5.1.1.1、绑定到服务></a>5.1.1.1、绑定到服务</h4><p>默认情况下，有关正在运行的应用程序以及服务连接信息的元数据作为环境变量(例如<code>$VCAP_SERVICES</code>)公开给应用程序。该架构决定是由于 Cloud Foundry 的多语言(可以将任何语言和平台支持为 buildpack)所决定的。过程范围的环境变量与语言无关。<p>环境变量并非总是使用最简单的 API，因此 Spring Boot 会自动提取它们并将数据展平为可以通过 Spring 的<code>Environment</code>抽象访问的属性，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">MyBean</span> <span class=keyword>implements</span> <span class="title class_">EnvironmentAware</span> {</span><br><span class=line>	<span class=keyword>private</span> String instanceId;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setEnvironment</span><span class=params>(Environment environment)</span> {</span><br><span class=line>		<span class=built_in>this</span>.instanceId = environment.getProperty(<span class=string>"vcap.application.instance_id"</span>);</span><br><span class=line>	}</span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>所有 Cloud Foundry 属性均以<code>vcap</code>为前缀。您可以使用<code>vcap</code>属性来访问应用程序信息(例如应用程序的公共 URL)和服务信息(例如数据库凭据)。有关完整的详细信息，请参见<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/cloud/CloudFoundryVcapEnvironmentPostProcessor.html rel=noopener target=_blank>‘CloudFoundryVcapEnvironmentPostProcessor’</a> Javadoc。<blockquote><p><a href=https://cloud.spring.io/spring-cloud-connectors/ rel=noopener target=_blank>Spring Cloud 连接器</a>项目更适合诸如配置数据源之类的任务。 Spring Boot 包括自动配置支持和<code>spring-boot-starter-cloud-connectors</code>启动器。</blockquote><h3 id=5-1-2、Heroku><a class=headerlink href=#5-1-2、Heroku title=5.1.2、Heroku></a>5.1.2、Heroku</h3><p>Heroku 是另一个流行的 PaaS 平台。要自定义 Heroku 构建，请提供<code>Procfile</code>，它提供部署应用程序所需的内容。 Heroku 为 Java 应用程序分配一个<code>port</code>，然后确保路由到外部 URI 起作用。<p>您必须配置您的应用程序以侦听正确的端口。以下示例显示了我们的 Starter REST 应用程序的<code>Procfile</code>：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>web: java -Dserver.port=$PORT -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></table></figure><p>Spring Boot 使<code>-D</code>参数作为可从 Spring <code>Environment</code>实例访问的属性。 <code>server.port</code>配置属性被馈送到嵌入式 Tomcat，Jetty 或 Undertow 实例，然后在启动时使用该端口。 <code>$PORT</code>环境变量是由 Heroku PaaS 分配给我们的。<p>这应该是您需要的一切。 Heroku 部署最常见的部署工作流程是将代码<code>git push</code>投入生产，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git push heroku master</span></span><br><span class=line></span><br><span class=line>Initializing repository, done.</span><br><span class=line>Counting objects: 95, done.</span><br><span class=line>Delta compression using up to 8 threads.</span><br><span class=line>Compressing objects: 100% (78/78), done.</span><br><span class=line>Writing objects: 100% (95/95), 8.66 MiB | 606.00 KiB/s, done.</span><br><span class=line>Total 95 (delta 31), reused 0 (delta 0)</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Java app detected</span></span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Installing OpenJDK 1.8... <span class=keyword>done</span></span></span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Installing Maven 3.3.1... <span class=keyword>done</span></span></span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Installing settings.xml... <span class=keyword>done</span></span></span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Executing: mvn -B -DskipTests=<span class=literal>true</span> clean install</span></span><br><span class=line></span><br><span class=line>       [INFO] Scanning for projects...</span><br><span class=line>       Downloading: https://repo.spring.io/...</span><br><span class=line>       Downloaded: https://repo.spring.io/... (818 B at 1.8 KB/sec)</span><br><span class=line>		....</span><br><span class=line>       Downloaded: http://s3pository.heroku.com/jvm/... (152 KB at 595.3 KB/sec)</span><br><span class=line>       [INFO] Installing /tmp/build_0c35a5d2-a067-4abc-a232-14b1fb7a8229/target/...</span><br><span class=line>       [INFO] Installing /tmp/build_0c35a5d2-a067-4abc-a232-14b1fb7a8229/pom.xml ...</span><br><span class=line>       [INFO] ------------------------------------------------------------------------</span><br><span class=line>       [INFO] BUILD SUCCESS</span><br><span class=line>       [INFO] ------------------------------------------------------------------------</span><br><span class=line>       [INFO] Total time: 59.358s</span><br><span class=line>       [INFO] Finished at: Fri Mar 07 07:28:25 UTC 2014</span><br><span class=line>       [INFO] Final Memory: 20M/493M</span><br><span class=line>       [INFO] ------------------------------------------------------------------------</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Discovering process types</span></span><br><span class=line>       Procfile declares types -> web</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Compressing... <span class=keyword>done</span>, 70.4MB</span></span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Launching... <span class=keyword>done</span>, v6</span></span><br><span class=line>       http://agile-sierra-1405.herokuapp.com/ deployed to Heroku</span><br><span class=line></span><br><span class=line>To [emailprotected]:agile-sierra-1405.git</span><br><span class=line> * [new branch]      master -> master</span><br></pre></table></figure><p>您的应用程序现在应该已经在 Heroku 上启动并运行了。<h3 id=5-1-3、OpenShift><a class=headerlink href=#5-1-3、OpenShift title=5.1.3、OpenShift></a>5.1.3、OpenShift</h3><p><a href=https://www.openshift.com/ rel=noopener target=_blank>OpenShift</a>是 Kubernetes 容器编排平台的 Red Hat 公共(和企业)扩展。与 Kubernetes 相似，OpenShift 具有许多用于安装基于 Spring Boot 的应用程序的选项。<p>OpenShift 有许多资源描述了如何部署 Spring Boot 应用程序，包括：<ul><li><a href=https://blog.openshift.com/using-openshift-enterprise-grade-spring-boot-deployments/ rel=noopener target=_blank>使用 S2I 构建器</a><li><a href=https://access.redhat.com/documentation/en-us/reference_architectures/2017/html-single/spring_boot_microservices_on_red_hat_openshift_container_platform_3/ rel=noopener target=_blank>Architecture guide</a><li><a href=https://blog.openshift.com/using-spring-boot-on-openshift/ rel=noopener target=_blank>在 Wildfly 上作为传统的 Web 应用程序运行</a><li><a href=https://blog.openshift.com/openshift-commons-briefing-96-cloud-native-applications-spring-rhoar/ rel=noopener target=_blank>OpenShift 公共简报</a></ul><h3 id=5-1-4、Amazon-Web-Services-AWS><a title="5.1.4、Amazon Web Services(AWS)" class=headerlink href=#5-1-4、Amazon-Web-Services-AWS></a>5.1.4、Amazon Web Services(AWS)</h3><p>Amazon Web Services 提供了多种安装基于 Spring Boot 的应用程序的方法，这些方法既可以作为传统的 Web 应用程序(war)，也可以作为具有嵌入式 Web 服务器的可执行 jar 文件安装。选项包括：<ul><li>AWS Elastic Beanstalk<li>AWS Code Deploy<li>AWS OPS 作品<li>AWS 云形成<li>AWS 容器注册表</ul><p>每个都有不同的功能和定价模型。在本文档中，我们仅描述最简单的选项：AWS Elastic Beanstalk。<h4 id=5-1-4-1、AWS-Elastic-Beanstalk><a title="5.1.4.1、AWS Elastic Beanstalk" class=headerlink href=#5-1-4-1、AWS-Elastic-Beanstalk></a>5.1.4.1、AWS Elastic Beanstalk</h4><p>如官方<a href=https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_Java.html rel=noopener target=_blank>Elastic Beanstalk Java 指南</a>中所述，部署 Java 应用程序有两个主要选项。您可以使用“ Tomcat 平台”或“ Java SE 平台”。<h5 id=使用-Tomcat-平台><a title="使用 Tomcat 平台" class=headerlink href=#使用-Tomcat-平台></a>使用 Tomcat 平台</h5><p>该选项适用于产生 war 文件的 Spring Boot 项目。无需特殊配置。您只需要遵循官方指南即可。<h5 id=使用-Java-SE-平台><a title="使用 Java SE 平台" class=headerlink href=#使用-Java-SE-平台></a>使用 Java SE 平台</h5><p>该选项适用于产生 jar 文件并运行嵌入式 Web 容器的 Spring Boot 项目。 Elastic Beanstalk 环境在端口 80 上运行 nginx 实例以代理在端口 5000 上运行的实际应用程序。要对其进行配置，请将以下行添加到<code>application.properties</code>文件：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>server.port=5000</span><br></pre></table></figure><blockquote><p>默认情况下，Elastic Beanstalk 上载源并在 AWS 中进行编译。但是，最好改为上传二进制文件。为此，请在您的<code>.elasticbeanstalk/config.yml</code>文件中添加类似于以下内容的行：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>deploy:</span></span><br><span class=line>	<span class=attr>artifact:</span> <span class=string>target/demo-0.0.1-SNAPSHOT.jar</span></span><br></pre></table></figure><p>默认情况下，Elastic Beanstalk 环境是负载平衡的。负载均衡器的成本很高。为避免该开销，请按照<a href=https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/environments-create-wizard.html#environments-create-wizard-capacity rel=noopener target=_blank>亚马逊文档</a>所述将环境类型设置为“单个实例”。您还可以使用 CLI 和以下命令来创建单实例环境：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>eb create -s</span><br></pre></table></figure></blockquote><h4 id=5-1-4-2、Summary><a class=headerlink href=#5-1-4-2、Summary title=5.1.4.2、Summary></a>5.1.4.2、Summary</h4><p>这是通向 AWS 的最简单方法之一，但还有更多内容要讲，例如如何将 Elastic Beanstalk 集成到任何 CI/CD 工具中，如何使用 Elastic Beanstalk Maven 插件而不是 CLI 等等。 <a href=https://exampledriven.wordpress.com/2017/01/09/spring-boot-aws-elastic-beanstalk-example/ rel=noopener target=_blank>blog post</a>详细介绍了这些主题。<h3 id=5-1-5、Boxfuse-和-Amazon-Web-Services><a title="5.1.5、Boxfuse 和 Amazon Web Services" class=headerlink href=#5-1-5、Boxfuse-和-Amazon-Web-Services></a>5.1.5、Boxfuse 和 Amazon Web Services</h3><p><a href=https://boxfuse.com/ rel=noopener target=_blank>Boxfuse</a>通过将您的 Spring Boot 可执行 jar 或 war 变成一个最小的 VM 映像来工作，该映像可以在 VirtualBox 或 AWS 上不变地部署。 Boxfuse 与 Spring Boot 进行了深度集成，并使用 Spring Boot 配置文件中的信息自动配置端口和运行状况检查 URL。 Boxfuse 在生成的图像以及它提供的所有资源(实例，安全组，弹性负载均衡器等)中均利用此信息。<p>创建<a href=https://console.boxfuse.com/ rel=noopener target=_blank>Boxfuse account</a>，将其连接到您的 AWS 账户，安装最新版本的 Boxfuse Client 并确保该应用程序已由 Maven 或 Gradle 构建(通过使用<code>mvn clean package</code>)后，就可以部署 Spring 使用与以下类似的命令将应用程序引导到 AWS：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>boxfuse run myapp-1.0.jar -<span class=built_in>env</span>=prod</span></span><br></pre></table></figure><p>有关更多选项，请参见<a href=https://boxfuse.com/docs/commandline/run.html rel=noopener target=_blank>boxfuse 运行文档</a>。如果当前目录中存在<a href=https://boxfuse.com/docs/commandline/#configuration rel=noopener target=_blank>boxfuse.conf</a>文件，则将其考虑。<blockquote><p>默认情况下，Boxfuse 在启动时会激活名为<code>boxfuse</code>的 Spring 配置文件。如果您的可执行 jar 或 war 包含<a href=https://boxfuse.com/docs/payloads/springboot.html#configuration rel=noopener target=_blank>application-boxfuse.properties</a>文件，则 Boxfuse 的配置将基于其包含的属性。</blockquote><p>此时，<code>boxfuse</code>为您的应用程序创建一个映像，上传该映像，并在 AWS 上配置和启动必要的资源，其输出类似于以下示例：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line>Fusing Image for myapp-1.0.jar ...</span><br><span class=line>Image fused in 00:06.838s (53937 K) -> axelfontaine/myapp:1.0</span><br><span class=line>Creating axelfontaine/myapp ...</span><br><span class=line>Pushing axelfontaine/myapp:1.0 ...</span><br><span class=line>Verifying axelfontaine/myapp:1.0 ...</span><br><span class=line>Creating Elastic IP ...</span><br><span class=line>Mapping myapp-axelfontaine.boxfuse.io to 52.28.233.167 ...</span><br><span class=line>Waiting for AWS to create an AMI for axelfontaine/myapp:1.0 in eu-central-1 (this may take up to 50 seconds) ...</span><br><span class=line>AMI created in 00:23.557s -> ami-d23f38cf</span><br><span class=line>Creating security group boxfuse-sg_axelfontaine/myapp:1.0 ...</span><br><span class=line>Launching t2.micro instance of axelfontaine/myapp:1.0 (ami-d23f38cf) in eu-central-1 ...</span><br><span class=line>Instance launched in 00:30.306s -> i-92ef9f53</span><br><span class=line>Waiting for AWS to boot Instance i-92ef9f53 and Payload to start at http://52.28.235.61/ ...</span><br><span class=line>Payload started in 00:29.266s -> http://52.28.235.61/</span><br><span class=line>Remapping Elastic IP 52.28.233.167 to i-92ef9f53 ...</span><br><span class=line>Waiting 15s for AWS to complete Elastic IP Zero Downtime transition ...</span><br><span class=line>Deployment completed successfully. axelfontaine/myapp:1.0 is up and running at http://myapp-axelfontaine.boxfuse.io/</span><br></pre></table></figure><p>您的应用程序现在应该已启动并在 AWS 上运行。<p>请参阅<a href=https://boxfuse.com/blog/spring-boot-ec2.html rel=noopener target=_blank>在 EC2 上部署 Spring Boot 应用</a>和<a href=https://boxfuse.com/docs/payloads/springboot.html rel=noopener target=_blank>Boxfuse Spring Boot 集成的文档</a>上的博客文章，以开始使用 Maven 构建来运行该应用程序。<h3 id=5-1-6、Google-Cloud><a title="5.1.6、Google Cloud" class=headerlink href=#5-1-6、Google-Cloud></a>5.1.6、Google Cloud</h3><p>Google Cloud 有多个选项可用于启动 Spring Boot 应用程序。最容易上手的可能是 App Engine，但您也可以找到在 Container Engine 的容器中或 Compute Engine 的虚拟机上运行 Spring Boot 的方法。<p>要在 App Engine 中运行，您可以先在用户界面中创建一个项目，该项目将为您设置一个唯一的标识符，并还设置 HTTP 路由。将 Java 应用程序添加到项目中，并将其保留为空，然后使用<a href=https://cloud.google.com/sdk/downloads rel=noopener target=_blank>Google Cloud SDK</a>从命令行或 CI 构建将 Spring Boot 应用程序推入该插槽。<p>App Engine Standard 要求您使用 WAR 包装。按照<a href=https://github.com/GoogleCloudPlatform/getting-started-java/blob/master/appengine-standard-java8/springboot-appengine-standard/README.md rel=noopener target=_blank>these steps</a>的要求将 App Engine Standard 应用程序部署到 Google Cloud。<p>另外，App Engine Flex 要求您创建一个<code>app.yaml</code>文件来描述您的应用程序所需的资源。通常，您将此文件放在<code>src/main/appengine</code>中，它应类似于以下文件：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line>service: default</span><br><span class=line></span><br><span class=line>runtime: java</span><br><span class=line>env: flex</span><br><span class=line></span><br><span class=line>runtime_config:</span><br><span class=line>  jdk: openjdk8</span><br><span class=line></span><br><span class=line>handlers:</span><br><span class=line>- url: /.*</span><br><span class=line>  script: this field is required, but ignored</span><br><span class=line></span><br><span class=line>manual_scaling:</span><br><span class=line>  instances: 1</span><br><span class=line></span><br><span class=line>health_check:</span><br><span class=line>  enable_health_check: False</span><br><span class=line></span><br><span class=line>env_variables:</span><br><span class=line>  ENCRYPT_KEY: your_encryption_key_here</span><br></pre></table></figure><p>您可以通过将项目 ID 添加到构建配置中来部署应用程序(例如，使用 Maven 插件)，如以下示例所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>plugin</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>com.google.cloud.tools<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>appengine-maven-plugin<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>version</span>></span>1.3.0<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>	<span class=tag><<span class=name>configuration</span>></span></span><br><span class=line>		<span class=tag><<span class=name>project</span>></span>myproject<span class=tag>&LT/<span class=name>project</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>configuration</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>plugin</span>></span></span><br></pre></table></figure><p>然后使用<code>mvn appengine:deploy</code>进行部署(如果您需要先进行身份验证，则构建将失败)。<h2 id=5-2、安装-Spring-Boot-应用程序><a title="5.2、安装 Spring Boot 应用程序" class=headerlink href=#5-2、安装-Spring-Boot-应用程序></a>5.2、安装 Spring Boot 应用程序</h2><p>除了使用<code>java -jar</code>运行 Spring Boot 应用程序外，还可以为 Unix 系统制作完全可执行的应用程序。完全可执行的 jar 可以像其他任何可执行二进制文件一样执行，也可以是<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/deployment-install.html#deployment-service rel=noopener target=_blank>在 init.d 或 systemd 中注册</a>。这使得在普通生产环境中安装和 Management Spring Boot 应用程序变得非常容易。<blockquote><p>完全可执行的 jar 通过在文件的开头嵌入一个额外的脚本来工作。当前，某些工具不接受此格式，因此您可能无法始终使用此技术。例如，<code>jar -xf</code>可能会默默地提取无法完全执行的 jar 或 war。建议仅在打算直接执行 jar 或 war 时才使它们完全可执行，而不是使用<code>java -jar</code>运行它或将其部署到 servlet 容器中。</blockquote><p>要使用 Maven 创建一个“完全可执行”的 jar，请使用以下插件配置：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>plugin</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>spring-boot-maven-plugin<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>configuration</span>></span></span><br><span class=line>		<span class=tag><<span class=name>executable</span>></span>true<span class=tag>&LT/<span class=name>executable</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>configuration</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>plugin</span>></span></span><br></pre></table></figure><p>以下示例显示了等效的 Gradle 配置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>bootJar {</span><br><span class=line>	launchScript()</span><br><span class=line>}</span><br></pre></table></figure><p>然后，您可以通过键入<code>./my-application.jar</code>(其中<code>my-application</code>是工件的名称)来运行您的应用程序。包含 jar 的目录用作应用程序的工作目录。<h3 id=5-2-1、支持的-os><a title="5.2.1、支持的 os" class=headerlink href=#5-2-1、支持的-os></a>5.2.1、支持的 os</h3><p>默认脚本支持大多数 Linux 发行版，并已在 CentOS 和 Ubuntu 上进行了测试。其他平台，例如 OS X 和 FreeBSD，则需要使用自定义的<code>embeddedLaunchScript</code>。<h3 id=5-2-2、Unix-Linux-服务><a title="5.2.2、Unix/Linux 服务" class=headerlink href=#5-2-2、Unix-Linux-服务></a>5.2.2、Unix/Linux 服务</h3><p>使用<code>init.d</code>或<code>systemd</code>可以轻松地将 Spring Boot 应用程序作为 Unix/Linux 服务启动。<h4 id=5-2-2-1、作为-init-d-服务安装-系统-V><a title="5.2.2.1、作为 init.d 服务安装(系统 V)" class=headerlink href=#5-2-2-1、作为-init-d-服务安装-系统-V></a>5.2.2.1、作为 init.d 服务安装(系统 V)</h4><p>如果您将 Spring Boot 的 Maven 或 Gradle 插件配置为生成<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/deployment-install.html rel=noopener target=_blank>完全可执行的 jar</a>，而不使用自定义<code>embeddedLaunchScript</code>，则您的应用程序可以用作<code>init.d</code>服务。为此，请将 jar 链接到<code>init.d</code>以支持标准<code>start</code>，<code>stop</code>，<code>restart</code>和<code>status</code>命令。<p>该脚本支持以下功能：<ul><li>以拥有 jar 文件的用户身份启动服务<li>使用<code>/var/run/&LTappname>/&LTappname>.pid</code>跟踪应用程序的 PID<li>将控制台日志写入<code>/var/log/&LTappname>.log</code></ul><p>假设您已在<code>/var/myapp</code>中安装了 Spring Boot 应用程序，要将 Spring Boot 应用程序安装为<code>init.d</code>服务，请创建一个符号链接，如下所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>sudo</span> <span class=built_in>ln</span> -s /var/myapp/myapp.jar /etc/init.d/myapp</span></span><br></pre></table></figure><p>安装后，您可以按照通常的方式启动和停止服务。例如，在基于 Debian 的系统上，可以使用以下命令启动它：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>service myapp start</span></span><br></pre></table></figure><blockquote><p>如果您的应用程序无法启动，请检查写入<code>/var/log/&LTappname>.log</code>的日志文件是否有错误。</blockquote><p>您还可以使用标准 os 工具将应用程序标记为自动启动。例如，在 Debian 上，您可以使用以下命令：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>update-rc.d myapp defaults &LTpriority></span></span><br></pre></table></figure><h5 id=保护-init-d-服务><a title="保护 init.d 服务" class=headerlink href=#保护-init-d-服务></a>保护 init.d 服务</h5><p>当以 root 身份执行时(例如使用 root 来启动 init.d 服务时)，默认的可执行脚本以拥有 jar 文件的用户身份运行应用程序。您永远不要以<code>root</code>的身份运行 Spring Boot 应用程序，因此您的应用程序的 jar 文件绝对不应由 root 拥有。而是创建一个特定用户来运行您的应用程序，并使用<code>chown</code>使其成为 jar 文件的所有者，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>chown</span> bootapp:bootapp your-app.jar</span></span><br></pre></table></figure><p>在这种情况下，默认的可执行脚本以<code>bootapp</code>用户身份运行该应用程序。<blockquote><p>为了减少应用程序的用户帐户遭到破坏的机会，应考虑阻止它使用登录 Shell 程序。例如，您可以将帐户的 Shell 设置为<code>/usr/sbin/nologin</code>。</blockquote><p>您还应该采取步骤来防止修改应用程序的 jar 文件。首先，配置其权限，使其不能被写入，只能由其所有者读取或执行，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>chmod</span> 500 your-app.jar</span></span><br></pre></table></figure><p>其次，如果您的应用程序或运行该应用程序的帐户受到威胁，您还应采取措施限制损害。如果攻击者确实获得了访问权限，则他们可以使 jar 文件可写并更改其内容。防止这种情况发生的一种方法是使用<code>chattr</code>使其不变，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>sudo</span> chattr +i your-app.jar</span></span><br></pre></table></figure><p>这将阻止任何用户(包括 root 用户)修改 jar。<p>如果使用 root 来控制应用程序的服务，并且您<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/deployment-install.html#deployment-script-customization-conf-file rel=noopener target=_blank>使用.conf 文件</a>自定义其启动，则 root 用户将读取并评估<code>.conf</code>文件。应该相应地对其进行保护。使用<code>chmod</code>，以便只有所有者可以读取文件，并使用<code>chown</code>将 root 成为所有者，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>chmod</span> 400 your-app.conf</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>sudo</span> <span class=built_in>chown</span> root:root your-app.conf</span></span><br></pre></table></figure><h4 id=5-2-2-2、作为系统服务安装><a class=headerlink href=#5-2-2-2、作为系统服务安装 title=5.2.2.2、作为系统服务安装></a>5.2.2.2、作为系统服务安装</h4><p><code>systemd</code>是 System V init 系统的后继产品，现已被许多现代 Linux 发行版使用。尽管您可以 continue 将_脚本与<code>systemd</code>一起使用，但是也可以通过使用<code>systemd</code>‘service’脚本来启动 Spring Boot 应用程序。<p>假设您已在<code>/var/myapp</code>中安装了 Spring Boot 应用程序，要将 Spring Boot 应用程序安装为<code>systemd</code>服务，请创建名为<code>myapp.service</code>的脚本并将其放置在<code>/etc/systemd/system</code>目录中。以下脚本提供了一个示例：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>[Unit]</span><br><span class=line>Description=myapp</span><br><span class=line>After=syslog.target</span><br><span class=line></span><br><span class=line>[Service]</span><br><span class=line>User=myapp</span><br><span class=line>ExecStart=/var/myapp/myapp.jar</span><br><span class=line>SuccessExitStatus=143</span><br><span class=line></span><br><span class=line>[Install]</span><br><span class=line>WantedBy=multi-user.target</span><br></pre></table></figure><blockquote><p>切记为您的应用程序更改<code>Description</code>，<code>User</code>和<code>ExecStart</code>字段。<p><code>ExecStart</code>字段未声明脚本操作命令，这意味着默认情况下使用<code>run</code>命令。</blockquote><p>请注意，与作为<code>init.d</code>服务运行时不同，运行应用程序，PID 文件和控制台日志文件的用户由<code>systemd</code>本身 Management，因此必须通过在“服务”脚本中使用适当的字段进行配置。有关更多详细信息，请咨询<a href=https://www.freedesktop.org/software/systemd/man/systemd.service.html rel=noopener target=_blank>服务单元配置手册页</a>。<p>要将应用程序标记为在系统启动时自动启动，请使用以下命令：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>systemctl <span class=built_in>enable</span> myapp.service</span></span><br></pre></table></figure><p>有关更多详细信息，请参考<code>man systemctl</code>。<h4 id=5-2-2-3、自定义启动脚本><a class=headerlink href=#5-2-2-3、自定义启动脚本 title=5.2.2.3、自定义启动脚本></a>5.2.2.3、自定义启动脚本</h4><p>由 Maven 或 Gradle 插件编写的默认嵌入式启动脚本可以通过多种方式进行自定义。对于大多数人来说，使用默认脚本和一些自定义设置通常就足够了。如果发现无法自定义所需的内容，请使用<code>embeddedLaunchScript</code>选项完全编写自己的文件。<h5 id=编写后自定义启动脚本><a class=headerlink href=#编写后自定义启动脚本 title=编写后自定义启动脚本></a>编写后自定义启动脚本</h5><p>在将启动脚本写入 jar 文件时，自定义启动脚本的元素通常很有意义。例如，init.d 脚本可以提供“描述”。由于您已经预先了解了描述(并且无需更改)，因此在生成 jar 时也可以提供它。<p>要自定义书面元素，请使用 Spring Boot Maven 插件的<code>embeddedLaunchScriptProperties</code>选项或<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/gradle-plugin/reference/html/#packaging-executable-configuring-launch-script rel=noopener target=_blank>Spring Boot Gradle 插件的 launchScript 的 properties 属性</a>。<p>默认脚本支持以下属性替换：<table><thead><tr><th>Name<th>Description<th>Gradle default<th>Maven default<tbody><tr><td><code>mode</code><td>脚本模式。<td><code>auto</code><td><code>auto</code><tr><td><code>initInfoProvides</code><td>“ INIT INFO”的<code>Provides</code>部分<td><code>${task.baseName}</code><td><code>${project.artifactId}</code><tr><td><code>initInfoRequiredStart</code><td>“ INIT INFO”的<code>Required-Start</code>部分。<td><code>$remote_fs $syslog $network</code><td><code>$remote_fs $syslog $network</code><tr><td><code>initInfoRequiredStop</code><td>“ INIT INFO”的<code>Required-Stop</code>部分。<td><code>$remote_fs $syslog $network</code><td><code>$remote_fs $syslog $network</code><tr><td><code>initInfoDefaultStart</code><td>“ INIT INFO”的<code>Default-Start</code>部分。<td><code>2 3 4 5</code><td><code>2 3 4 5</code><tr><td><code>initInfoDefaultStop</code><td>“ INIT INFO”的<code>Default-Stop</code>部分。<td><code>0 1 6</code><td><code>0 1 6</code><tr><td><code>initInfoShortDescription</code><td>“ INIT INFO”的<code>Short-Description</code>部分。<td>单行版本的<code>${project.description}</code>(回退到<code>${task.baseName}</code>)<td><code>${project.name}</code><tr><td><code>initInfoDescription</code><td>“ INIT INFO”的<code>Description</code>部分。<td><code>${project.description}</code>(回到<code>${task.baseName}</code>)<td><code>${project.description}</code>(回到<code>${project.name}</code>)<tr><td><code>initInfoChkconfig</code><td>“ INIT INFO”的<code>chkconfig</code>部分<td><code>2345 99 01</code><td><code>2345 99 01</code><tr><td><code>confFolder</code><td><code>CONF_FOLDER</code>的默认值<td>包含Jar子的文件夹<td>包含Jar子的文件夹<tr><td><code>inlinedConfScript</code><td>引用应在默认启动脚本中内联的文件脚本。可以在加载任何外部配置文件之前设置环境变量，例如<code>JAVA_OPTS</code><td><td><tr><td><code>logFolder</code><td><code>LOG_FOLDER</code>的默认值。仅对<code>init.d</code>服务有效<td><td><tr><td><code>logFilename</code><td><code>LOG_FILENAME</code>的默认值。仅对<code>init.d</code>服务有效<td><td><tr><td><code>pidFolder</code><td><code>PID_FOLDER</code>的默认值。仅对<code>init.d</code>服务有效<td><td><tr><td><code>pidFilename</code><td>PID 文件名在<code>PID_FOLDER</code>中的默认值。仅对<code>init.d</code>服务有效<td><td><tr><td><code>useStartStopDaemon</code><td><code>start-stop-daemon</code>命令(如果可用)是否应用于控制过程<td><code>true</code><td><code>true</code><tr><td><code>stopWaitTime</code><td><code>STOP_WAIT_TIME</code>的默认值，以秒为单位。仅对<code>init.d</code>服务有效<td>60<td>60</table><h5 id=运行时自定义脚本><a class=headerlink href=#运行时自定义脚本 title=运行时自定义脚本></a>运行时自定义脚本</h5><p>对于<em>在</em>编写 jar 之后需要自定义脚本的项目，可以使用环境变量或<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/deployment-install.html#deployment-script-customization-conf-file rel=noopener target=_blank>config file</a>。<p>默认脚本支持以下环境属性：<table><thead><tr><th>Variable<th>Description<tbody><tr><td><code>MODE</code><td>操作的“模式”。默认值取决于 jar 的构建方式，但通常为<code>auto</code>(这意味着它会通过检查目录<code>init.d</code>中的符号链接来尝试猜测它是否为初始化脚本)。您可以将其显式设置为<code>service</code>，以便`stop<tr><td><code>USE_START_STOP_DAEMON</code><td><code>start-stop-daemon</code>命令(如果可用)是否应用于控制过程。默认为<code>true</code>。<tr><td><code>PID_FOLDER</code><td>pid 文件夹的根名称(默认为<code>/var/run</code>)。<tr><td><code>LOG_FOLDER</code><td>放置日志文件的文件夹的名称(默认为<code>/var/log</code>)。<tr><td><code>CONF_FOLDER</code><td>从中读取.conf 文件的文件夹的名称(默认情况下与 jar 文件相同的文件夹)。<tr><td><code>LOG_FILENAME</code><td><code>LOG_FOLDER</code>(默认为<code>&LTappname>.log</code>)中的日志文件名称。<tr><td><code>APP_NAME</code><td>应用程序的名称。如果 jar 是从符号链接运行的，则脚本会猜测该应用程序的名称。如果它不是符号链接，或者您要显式设置应用程序名称，则这将很有用。<tr><td><code>RUN_ARGS</code><td>传递给程序的参数(Spring Boot 应用程序)。<tr><td><code>JAVA_HOME</code><td>默认情况下，通过使用<code>PATH</code>发现<code>java</code>可执行文件的位置，但是如果<code>$JAVA_HOME/bin/java</code>处有可执行文件，则可以显式设置它。<tr><td><code>JAVA_OPTS</code><td>启动 JVM 时传递给 JVM 的选项。<tr><td><code>JARFILE</code><td>jar 文件的显式位置，以防脚本用于启动实际上未嵌入的 jar。<tr><td><code>DEBUG</code><td>如果不为空，请在 shell 进程中设置<code>-x</code>标志，从而易于查看脚本中的逻辑。<tr><td><code>STOP_WAIT_TIME</code><td>停止应用程序之前要强制关闭的 await 时间(以秒为单位)(默认为<code>60</code>)。</table><blockquote><p><code>PID_FOLDER</code>，<code>LOG_FOLDER</code>和<code>LOG_FILENAME</code>变量仅对<code>init.d</code>服务有效。对于<code>systemd</code>，使用’service’脚本进行等效的自定义。有关更多详细信息，请参见<a href=https://www.freedesktop.org/software/systemd/man/systemd.service.html rel=noopener target=_blank>服务单元配置手册页</a>。</blockquote><p>除<code>JARFILE</code>和<code>APP_NAME</code>以外，可以使用<code>.conf</code>文件配置上一节中列出的设置。该文件应位于 jar 文件的旁边，并且具有相同的名称，但后缀为<code>.conf</code>而不是<code>.jar</code>。例如，名为<code>/var/myapp/myapp.jar</code>的 jar 使用名为<code>/var/myapp/myapp.conf</code>的配置文件，如以下示例所示：<p><strong>myapp.conf.</strong><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>JAVA_OPTS=-Xmx1024M</span><br><span class=line>LOG_FOLDER=/custom/log/folder</span><br></pre></table></figure><blockquote><p>如果您不喜欢将配置文件放在 jar 文件旁边，则可以设置<code>CONF_FOLDER</code>环境变量以自定义配置文件的位置。</blockquote><h3 id=5-2-3、Microsoft-Windows-服务><a title="5.2.3、Microsoft Windows 服务" class=headerlink href=#5-2-3、Microsoft-Windows-服务></a>5.2.3、Microsoft Windows 服务</h3><p>可以使用<a href=https://github.com/kohsuke/winsw rel=noopener target=_blank>winsw</a>将 Spring Boot 应用程序作为 Windows 服务启动。<p>(<a href=https://github.com/snicoll-scratches/spring-boot-daemon rel=noopener target=_blank>单独维护的 samples</a>)分步说明了如何为 Spring Boot 应用程序创建 Windows 服务。<h1 id=6、Spring-Boot-CLI><a title="6、Spring Boot CLI" class=headerlink href=#6、Spring-Boot-CLI></a>6、Spring Boot CLI</h1><p>Spring Boot CLI 是一个命令行工具，如果您想快速开发 Spring 应用程序，可以使用它。它使您可以运行 Groovy 脚本，这意味着您具有类似 Java 的熟悉语法，而没有太多样板代码。您还可以引导一个新项目或为其编写自己的命令。<h2 id=6-1、安装CLI><a class=headerlink href=#6-1、安装CLI title=6.1、安装CLI></a>6.1、安装CLI</h2><p>可以使用 SDKMAN 手动安装 Spring Boot CLI(命令行界面)！ (SDK Manager)或使用 Homebrew 或 MacPorts(如果您是 OSX 用户)。有关全面的安装说明，请参阅“Starter”部分中的* <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/getting-started-installing-spring-boot.html#getting-started-installing-the-cli rel=noopener target=_blank>第 10.2 节“安装 Spring Boot CLI”</a> *。<h2 id=6-2、使用CLI><a class=headerlink href=#6-2、使用CLI title=6.2、使用CLI></a>6.2、使用CLI</h2><p>安装 CLI 后，可以通过键入<code>spring</code>并在命令行中按 Enter 来运行它。如果您不带任何参数运行<code>spring</code>，则会显示一个简单的帮助屏幕，如下所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring</span></span><br><span class=line>usage: spring [--help] [--version]</span><br><span class=line>       &LTcommand> [&LTargs>]</span><br><span class=line></span><br><span class=line>Available commands are:</span><br><span class=line></span><br><span class=line>  run [options] &LTfiles> [--] [args]</span><br><span class=line>    Run a spring groovy script</span><br><span class=line></span><br><span class=line>  ... more command help is shown here</span><br></pre></table></figure><p>您可以键入<code>spring help</code>以获取有关任何受支持命令的更多详细信息，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring <span class=built_in>help</span> run</span></span><br><span class=line>spring run - Run a spring groovy script</span><br><span class=line></span><br><span class=line>usage: spring run [options] &LTfiles> [--] [args]</span><br><span class=line></span><br><span class=line>Option                     Description</span><br><span class=line>------                     -----------</span><br><span class=line>--autoconfigure [Boolean]  Add autoconfigure compiler</span><br><span class=line>                             transformations (default: true)</span><br><span class=line>--classpath, -cp           Additional classpath entries</span><br><span class=line>-e, --edit                 Open the file with the default system</span><br><span class=line>                             editor</span><br><span class=line>--no-guess-dependencies    Do not attempt to guess dependencies</span><br><span class=line>--no-guess-imports         Do not attempt to guess imports</span><br><span class=line>-q, --quiet                Quiet logging</span><br><span class=line>-v, --verbose              Verbose logging of dependency</span><br><span class=line>                             resolution</span><br><span class=line>--watch                    Watch the specified file for changes</span><br></pre></table></figure><p><code>version</code>命令提供了一种快速的方法来检查您正在使用的 Spring Boot 版本，如下所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring version</span></span><br><span class=line>Spring CLI v2.1.1.RELEASE</span><br></pre></table></figure><h3 id=6-2-1、使用-CLI-运行应用程序><a title="6.2.1、使用 CLI 运行应用程序" class=headerlink href=#6-2-1、使用-CLI-运行应用程序></a>6.2.1、使用 CLI 运行应用程序</h3><p>您可以使用<code>run</code>命令来编译和运行 Groovy 源代码。 Spring Boot CLI 是完全独立的，因此您不需要任何外部 Groovy 安装。<p>以下示例显示了用 Groovy 编写的“ hello world” Web 应用程序：<p><strong>hello.groovy.</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@RestController</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">WebApplication</span> {</span><br><span class=line>	<span class=meta>@RequestMapping("/")</span></span><br><span class=line>	String <span class="title function_">home</span><span class=params>()</span> {</span><br><span class=line>		<span class=string>"Hello World!"</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>要编译并运行该应用程序，请键入以下命令：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring run hello.groovy</span></span><br></pre></table></figure><p>要将命令行参数传递给应用程序，请使用<code>--</code>将命令与“ spring”命令参数分开，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring run hello.groovy -- --server.port=9000</span></span><br></pre></table></figure><p>要设置 JVM 命令行参数，可以使用<code>JAVA_OPTS</code>环境变量，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>JAVA_OPTS=-Xmx1024m spring run hello.groovy</span></span><br></pre></table></figure><blockquote><p>在 Microsoft Windows 上设置<code>JAVA_OPTS</code>时，请确保引用整个指令，例如<code>set "JAVA_OPTS=-Xms256m -Xmx2048m"</code>。这样做可以确保将值正确传递给流程。</blockquote><h4 id=6-2-1-1、推论”grab”依赖性><a class=headerlink href=#6-2-1-1、推论”grab”依赖性 title=6.2.1.1、推论”grab”依赖性></a>6.2.1.1、推论”grab”依赖性</h4><p>标准 Groovy 包含<code>@Grab</code>注解，该注解使您可以声明对第三方库的依赖关系。 Groovy 可以使用这种有用的技术以与 Maven 或 Gradle 相同的方式下载 jar，而无需使用构建工具。<p>Spring Boot 进一步扩展了该技术，并尝试根据您的代码推断出哪些库可以“抢”。例如，由于先前显示的<code>WebApplication</code>代码使用<code>@RestController</code>注解，因此 Spring Boot 会捕获“ Tomcat”和“ Spring MVC”。<p>以下各项用作“抓取提示”：<table><thead><tr><th>Items<th>Grabs<tbody><tr><td><code>JdbcTemplate</code> , <code>NamedParameterJdbcTemplate</code> , <code>DataSource</code><td>JDBC Application.<tr><td><code>@EnableJms</code><td>JMS Application.<tr><td><code>@EnableCaching</code><td>Caching abstraction.<tr><td><code>@Test</code><td>JUnit.<tr><td><code>@EnableRabbit</code><td>RabbitMQ.<tr><td>延伸<code>Specification</code><td>Spock test.<tr><td><code>@EnableBatchProcessing</code><td>Spring Batch.<tr><td><code>@MessageEndpoint</code> <code>@EnableIntegration</code><td>Spring Integration.<tr><td><code>@Controller</code> <code>@RestController</code> <code>@EnableWebMvc</code><td>Spring MVC 嵌入式 Tomcat。<tr><td><code>@EnableWebSecurity</code><td>Spring Security.<tr><td><code>@EnableTransactionManagement</code><td>SpringTransactionManagement。</table><blockquote><p>请参阅 Spring Boot CLI 源代码中的<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-cli/src/main/java/org/springframework/boot/cli/compiler/CompilerAutoConfiguration.java rel=noopener target=_blank>CompilerAutoConfiguration</a>的子类，以确切地了解如何应用定制。</blockquote><h4 id=6-2-1-2、推导”grab”坐标><a class=headerlink href=#6-2-1-2、推导”grab”坐标 title=6.2.1.2、推导”grab”坐标></a>6.2.1.2、推导”grab”坐标</h4><p>Spring Boot 通过允许您指定不带组或版本的依赖项(例如<code>@Grab('freemarker')</code>)来扩展 Groovy 的标准<code>@Grab</code>支持。这样做可以参考 Spring Boot 的默认依赖元数据来推断工件的组和版本。<blockquote><p>默认元数据与您使用的 CLI 版本相关。仅当您移至新版本的 CLI 时，它才会更改，从而使您可以控制依赖项的版本何时更改。可以在<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/appendix-dependency-versions.html rel=noopener target=_blank>appendix</a>中找到一个表格，其中显示了默认元数据中包含的依赖项及其版本。</blockquote><h4 id=6-2-1-3、默认导入语句><a class=headerlink href=#6-2-1-3、默认导入语句 title=6.2.1.3、默认导入语句></a>6.2.1.3、默认导入语句</h4><p>为了帮助减少 Groovy 代码的大小，将自动包含多个<code>import</code>语句。注意，前面的示例如何引用<code>@Component</code>，<code>@RestController</code>和<code>@RequestMapping</code>，而无需使用完全限定的名称或<code>import</code>语句。<blockquote><p>许多 Spring Comments 无需使用<code>import</code>语句即可工作。在添加导入之前，请尝试运行您的应用程序以查看失败的原因。</blockquote><h4 id=6-2-1-4、自动-main-方法><a title="6.2.1.4、自动 main 方法" class=headerlink href=#6-2-1-4、自动-main-方法></a>6.2.1.4、自动 main 方法</h4><p>与等效的 Java 应用程序不同，您不需要在<code>Groovy</code>脚本中包含<code>public static void main(String[] args)</code>方法。会自动创建一个<code>SpringApplication</code>，并将您的编译后代码用作<code>source</code>。<h4 id=6-2-1-5、自定义依赖项-Management><a title="6.2.1.5、自定义依赖项 Management" class=headerlink href=#6-2-1-5、自定义依赖项-Management></a>6.2.1.5、自定义依赖项 Management</h4><p>默认情况下，CLI 使用<code>spring-boot-dependencies</code>中声明的依赖性 Management 来解决<code>@Grab</code>依赖性。可以使用<code>@DependencyManagementBom</code>注解来配置其他依赖项 Management，这些依赖项 Management 将覆盖默认的依赖项 Management。Comments 的值应指定一个或多个 Maven BOM 的坐标(<code>groupId:artifactId:version</code>)。<p>例如，考虑以下声明：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=meta>@DependencyManagementBom("com.example.custom-bom:1.0.0")</span></span><br></pre></table></figure><p>前面的声明在<code>com/example/custom-versions/1.0.0/</code>下的 Maven 存储库中选取<code>custom-bom-1.0.0.pom</code>。<p>当您指定多个 BOM 时，它们以声明它们的 Sequences 应用，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>@DependencyManagementBom(["com.example.custom-bom:1.0.0",</span><br><span class=line>		"com.example.another-bom:1.0.0"])</span><br></pre></table></figure><p>前面的示例表明<code>another-bom</code>中的依赖项 Management 覆盖<code>custom-bom</code>中的依赖项 Management。<p>您可以在可以使用<code>@Grab</code>的任何地方使用<code>@DependencyManagementBom</code>。但是，为确保依赖性 Management 的 Sequences 一致，您最多可以在应用程序中使用<code>@DependencyManagementBom</code>。 <a href=https://platform.spring.io/ rel=noopener target=_blank>Spring IO 平台</a>是依赖 Management 的有用资源(它是 Spring Boot 依赖 Management 的超集)，您可以将其包括在以下行中：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>@DependencyManagementBom('io.spring.platform:platform-bom:1.1.2.RELEASE')</span><br></pre></table></figure><h3 id=6-2-2、具有多个源文件的应用程序><a class=headerlink href=#6-2-2、具有多个源文件的应用程序 title=6.2.2、具有多个源文件的应用程序></a>6.2.2、具有多个源文件的应用程序</h3><p>您可以对所有接受文件 Importing 的命令使用“ shell globbing”。这样可以使您从单个目录使用多个文件，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring run *.groovy</span></span><br></pre></table></figure><h3 id=6-2-3、打包您的应用程序><a class=headerlink href=#6-2-3、打包您的应用程序 title=6.2.3、打包您的应用程序></a>6.2.3、打包您的应用程序</h3><p>您可以使用<code>jar</code>命令将您的应用程序打包到一个独立的可执行 jar 文件中，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring jar my-app.jar *.groovy</span></span><br></pre></table></figure><p>生成的 jar 包含通过编译应用程序产生的类以及应用程序的所有依赖关系，以便随后可以使用<code>java -jar</code>来运行它。 jar 文件还包含来自应用程序的 Classpath 的条目。您可以使用<code>--include</code>和<code>--exclude</code>添加和删除 jar 的显式路径。两者都用逗号分隔，并且都接受形式为“”和“-”的前缀，以表示应将其从默认值中删除。默认包括以下内容：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>public/**, resources/**, static/**, templates/**, META-INF/**, *</span><br></pre></table></figure><p>默认排除项如下：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>.*, repository/**, build/**, target/**, **/*.jar, **/*.groovy</span><br></pre></table></figure><p>在命令行上键入<code>spring help jar</code>以获取更多信息。<h3 id=6-2-4、初始化新项目><a class=headerlink href=#6-2-4、初始化新项目 title=6.2.4、初始化新项目></a>6.2.4、初始化新项目</h3><p><code>init</code>命令使您可以使用<a href=https://start.spring.io/ rel=noopener target=_blank>start.spring.io</a>创建新项目，而无需离开 Shell，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring init --dependencies=web,data-jpa my-project</span></span><br><span class=line>Using service at https://start.spring.io</span><br><span class=line>Project extracted to '/Users/developer/example/my-project'</span><br></pre></table></figure><p>前面的示例使用<code>spring-boot-starter-web</code>和<code>spring-boot-starter-data-jpa</code>创建一个基于 Maven 的项目的<code>my-project</code>目录。您可以使用<code>--list</code>标志列出服务的功能，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring init --list</span></span><br><span class=line>=======================================</span><br><span class=line>Capabilities of https://start.spring.io</span><br><span class=line>=======================================</span><br><span class=line></span><br><span class=line>Available dependencies:</span><br><span class=line>-----------------------</span><br><span class=line>actuator - Actuator: Production ready features to help you monitor and manage your application</span><br><span class=line>...</span><br><span class=line>web - Web: Support for full-stack web development, including Tomcat and spring-webmvc</span><br><span class=line>websocket - Websocket: Support for WebSocket development</span><br><span class=line>ws - WS: Support for Spring Web Services</span><br><span class=line></span><br><span class=line>Available project types:</span><br><span class=line>------------------------</span><br><span class=line>gradle-build -  Gradle Config [format:build, build:gradle]</span><br><span class=line>gradle-project -  Gradle Project [format:project, build:gradle]</span><br><span class=line>maven-build -  Maven POM [format:build, build:maven]</span><br><span class=line>maven-project -  Maven Project [format:project, build:maven] (default)</span><br><span class=line></span><br><span class=line>...</span><br></pre></table></figure><p><code>init</code>命令支持许多选项。有关更多详细信息，请参见<code>help</code>输出。例如，以下命令创建使用 Java 8 和<code>war</code>打包的 Gradle 项目：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring init --build=gradle --java-version=1.8 --dependencies=websocket --packaging=war sample-app.zip</span></span><br><span class=line>Using service at https://start.spring.io</span><br><span class=line>Content saved to 'sample-app.zip'</span><br></pre></table></figure><h3 id=6-2-5、使用嵌入式-Shell><a title="6.2.5、使用嵌入式 Shell" class=headerlink href=#6-2-5、使用嵌入式-Shell></a>6.2.5、使用嵌入式 Shell</h3><p>Spring Boot 包含用于 BASH 和 zsh Shell 的命令行完成脚本。如果您不使用这两个 Shell 程序(也许您是 Windows 用户)，则可以使用<code>shell</code>命令启动集成 Shell 程序，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring shell</span></span><br><span class=line>Spring Boot (v2.1.1.RELEASE)</span><br><span class=line>Hit TAB to complete. Type \'help' and hit RETURN for help, and \'exit' to quit.</span><br></pre></table></figure><p>在嵌入式 Shell 程序内部，您可以直接运行其他命令：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>version</span></span><br><span class=line>Spring CLI v2.1.1.RELEASE</span><br></pre></table></figure><p>嵌入式 Shell 支持 ANSI 颜色输出以及<code>tab</code>完成。如果需要运行本机命令，则可以使用<code>!</code>前缀。要退出嵌入式 Shell，请按<code>ctrl-c</code>。<h3 id=6-2-6、将扩展添加到-CLI><a title="6.2.6、将扩展添加到 CLI" class=headerlink href=#6-2-6、将扩展添加到-CLI></a>6.2.6、将扩展添加到 CLI</h3><p>您可以使用<code>install</code>命令将扩展添加到 CLI。该命令采用<code>group:artifact:version</code>格式的一组或多组工件坐标，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring install com.example:spring-boot-cli-extension:1.0.0.RELEASE</span></span><br></pre></table></figure><p>除了安装由您提供的坐标标识的工件之外，还将安装所有工件的依赖项。<p>要卸载依赖项，请使用<code>uninstall</code>命令。与<code>install</code>命令一样，它采用<code>group:artifact:version</code>格式的一组或多组工件坐标，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring uninstall com.example:spring-boot-cli-extension:1.0.0.RELEASE</span></span><br></pre></table></figure><p>它将卸载由您提供的坐标及其依赖项标识的工件。<p>要卸载所有其他依赖项，可以使用<code>--all</code>选项，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring uninstall --all</span></span><br></pre></table></figure><h2 id=6-3、使用-Groovy-Bean-DSL-开发应用程序><a title="6.3、使用 Groovy Bean DSL 开发应用程序" class=headerlink href=#6-3、使用-Groovy-Bean-DSL-开发应用程序></a>6.3、使用 Groovy Bean DSL 开发应用程序</h2><p>Spring Framework 4.0 对<code>beans{}</code>“ DSL”(从<a href=http://grails.org/ rel=noopener target=_blank>Grails</a>借来)具有本地支持，并且您可以使用相同的格式将 Bean 定义嵌入 Groovy 应用程序脚本中。有时，这是包括外部功能(如中间件声明)的好方法，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line>@Configuration</span><br><span class=line>class Application implements CommandLineRunner {</span><br><span class=line></span><br><span class=line>	@Autowired</span><br><span class=line>	SharedService service</span><br><span class=line></span><br><span class=line>	@Override</span><br><span class=line>	void run(String... args) {</span><br><span class=line>		println service.message</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>}</span><br><span class=line></span><br><span class=line>import my.company.SharedService</span><br><span class=line></span><br><span class=line>beans {</span><br><span class=line>	service(SharedService) {</span><br><span class=line>		message = "Hello World"</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>您可以将类声明与<code>beans{}</code>混合在同一文件中，只要它们位于顶层即可；或者，如果愿意，可以将 bean DSL 放在单独的文件中。<h2 id=6-4、使用-settings-xml-配置-CLI><a title="6.4、使用 settings.xml 配置 CLI" class=headerlink href=#6-4、使用-settings-xml-配置-CLI></a>6.4、使用 settings.xml 配置 CLI</h2><p>Spring Boot CLI 使用 Maven 的依赖关系解析引擎 Aether 来解决依赖关系。 CLI 利用<code>~/.m2/settings.xml</code>中的 Maven 配置来配置 Aether。 CLI 遵循以下配置设置：<ul><li>Offline<li>Mirrors<li>Servers<li>Proxies<li>Profiles<li>Activation<ul><li>Repositories</ul><li>Active profiles</ul><p>有关更多信息，请参见<a href=https://maven.apache.org/settings.html rel=noopener target=_blank>Maven 的设置文档</a>。<h2 id=6-5、接下来读什么><a class=headerlink href=#6-5、接下来读什么 title=6.5、接下来读什么></a>6.5、接下来读什么</h2><p>GitHub 存储库中有一些<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-cli/samples rel=noopener target=_blank>常规脚本示例</a>可用于尝试 Spring Boot CLI。整个<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-cli/src/main/java/org/springframework/boot/cli rel=noopener target=_blank>source code</a>中也有广泛的 Javadoc。<p>如果发现达到了 CLI 工具的极限，则可能需要考虑将应用程序转换为完整的 Gradle 或 Maven 构建的“ Groovy 项目”。下一节将介绍 Spring Boot 的“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/build-tool-plugins.html rel=noopener target=_blank>构建工具插件</a>”，您可以将其与 Gradle 或 Maven 一起使用。<h1 id=7、构建工具插件><a class=headerlink href=#7、构建工具插件 title=7、构建工具插件></a>7、构建工具插件</h1><p>Spring Boot 为 Maven 和 Gradle 提供了构建工具插件。插件提供了多种功能，包括可执行 jar 的打包。本节提供了有关这两个插件的更多详细信息，以及在扩展不受支持的构建系统时所需的一些帮助。如果您刚刚 Starter，则可能需要先从“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot.html rel=noopener target=_blank>第三部分，“使用 Spring Boot”</a>”部分阅读“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html rel=noopener target=_blank>第 13 章，构建系统</a>”。<h2 id=7-1、Spring-Boot-Maven-插件><a title="7.1、Spring Boot Maven 插件" class=headerlink href=#7-1、Spring-Boot-Maven-插件></a>7.1、Spring Boot Maven 插件</h2><p><a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/maven-plugin rel=noopener target=_blank>Spring Boot Maven 插件</a>在 Maven 中提供 Spring Boot 支持，使您可以打包可执行 jar 或 war 归档文件并“就地”运行应用程序。要使用它，必须使用 Maven 3.2(或更高版本)。<h3 id=7-1-1、包含插件><a class=headerlink href=#7-1-1、包含插件 title=7.1.1、包含插件></a>7.1.1、包含插件</h3><p>要使用 Spring Boot Maven 插件，请在<code>pom.xml</code>的<code>plugins</code>部分中包含适当的 XML，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line>&LT?xml version="1.0" encoding="UTF-8"?></span><br><span class=line>&LTproject xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class=line>	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"></span><br><span class=line>	&LTmodelVersion>4.0.0&LT/modelVersion></span><br><span class=line>	&LT!-- ... --></span><br><span class=line>	&LTbuild></span><br><span class=line>		&LTplugins></span><br><span class=line>			&LTplugin></span><br><span class=line>				&LTgroupId>org.springframework.boot&LT/groupId></span><br><span class=line>				&LTartifactId>spring-boot-maven-plugin&LT/artifactId></span><br><span class=line>				&LTversion>2.1.1.RELEASE&LT/version></span><br><span class=line>				&LTexecutions></span><br><span class=line>					&LTexecution></span><br><span class=line>						&LTgoals></span><br><span class=line>							&LTgoal>repackage&LT/goal></span><br><span class=line>						&LT/goals></span><br><span class=line>					&LT/execution></span><br><span class=line>				&LT/executions></span><br><span class=line>			&LT/plugin></span><br><span class=line>		&LT/plugins></span><br><span class=line>	&LT/build></span><br><span class=line>&LT/project></span><br></pre></table></figure><p>前面的配置重新打包了在 Maven 生命周期的<code>package</code>阶段构建的 jar 或 war。以下示例显示了重新打包的 jar 和<code>target</code>目录中的原始 jar：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>mvn package</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>ls</span> target/*.jar</span></span><br><span class=line>target/myproject-1.0.0.jar target/myproject-1.0.0.jar.original</span><br></pre></table></figure><p>如上例所示，如果不包括<code>&LTexecution/></code>配置，则可以单独运行插件(但也必须同时使用软件包目标)，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>mvn package spring-boot:repackage</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>ls</span> target/*.jar</span></span><br><span class=line>target/myproject-1.0.0.jar target/myproject-1.0.0.jar.original</span><br></pre></table></figure><p>如果使用里程碑或快照发行版，则还需要添加相应的<code>pluginRepository</code>元素，如以下 Lists 所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>pluginRepositories</span>></span></span><br><span class=line>	<span class=tag><<span class=name>pluginRepository</span>></span></span><br><span class=line>		<span class=tag><<span class=name>id</span>></span>spring-snapshots<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>		<span class=tag><<span class=name>url</span>></span>https://repo.spring.io/snapshot<span class=tag>&LT/<span class=name>url</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>pluginRepository</span>></span></span><br><span class=line>	<span class=tag><<span class=name>pluginRepository</span>></span></span><br><span class=line>		<span class=tag><<span class=name>id</span>></span>spring-milestones<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>		<span class=tag><<span class=name>url</span>></span>https://repo.spring.io/milestone<span class=tag>&LT/<span class=name>url</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>pluginRepository</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>pluginRepositories</span>></span></span><br></pre></table></figure><h3 id=7-1-2、包装可执行的-Jar-和-War-文件><a title="7.1.2、包装可执行的 Jar 和 War 文件" class=headerlink href=#7-1-2、包装可执行的-Jar-和-War-文件></a>7.1.2、包装可执行的 Jar 和 War 文件</h3><p>将<code>spring-boot-maven-plugin</code>包含在<code>pom.xml</code>中后，它会自动尝试重写 Files，以使 Files 可以通过<code>spring-boot:repackage</code>目标执行。您应该使用通常的<code>packaging</code>元素将项目配置为构建 jar 或 war(视情况而定)，如以下示例所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>project</span> <span class=attr>xmlns</span>=<span class=string>"http://maven.apache.org/POM/4.0.0"</span> <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>	<span class=attr>xsi:schemaLocation</span>=<span class=string>"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>></span></span><br><span class=line>	<span class=comment>&LT!-- ... --></span></span><br><span class=line>	<span class=tag><<span class=name>packaging</span>></span>jar<span class=tag>&LT/<span class=name>packaging</span>></span></span><br><span class=line>	<span class=comment>&LT!-- ... --></span></span><br><span class=line><span class=tag>&LT/<span class=name>project</span>></span></span><br></pre></table></figure><p>Spring Boot 在<code>package</code>阶段会增强您现有的存档。可以通过使用配置选项或通过以常规方式向 Lists 添加<code>Main-Class</code>属性来指定要启动的主类。如果未指定主类，则插件将使用<code>public static void main(String[] args)</code>方法搜索一个类。<p>要构建和运行项目工件，可以键入以下内容：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>mvn package</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -jar target/mymodule-0.0.1-SNAPSHOT.jar</span></span><br></pre></table></figure><p>要构建既可执行又可部署到外部容器的 war 文件，您需要将嵌入式容器的依赖关系标记为“已提供”，如以下示例所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>project</span> <span class=attr>xmlns</span>=<span class=string>"http://maven.apache.org/POM/4.0.0"</span> <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>	<span class=attr>xsi:schemaLocation</span>=<span class=string>"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>></span></span><br><span class=line>	<span class=comment>&LT!-- ... --></span></span><br><span class=line>	<span class=tag><<span class=name>packaging</span>></span>war<span class=tag>&LT/<span class=name>packaging</span>></span></span><br><span class=line>	<span class=comment>&LT!-- ... --></span></span><br><span class=line>	<span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>		<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>			<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>artifactId</span>></span>spring-boot-starter-web<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>		<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>			<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>artifactId</span>></span>spring-boot-starter-tomcat<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>scope</span>></span>provided<span class=tag>&LT/<span class=name>scope</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>		<span class=comment>&LT!-- ... --></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>dependencies</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>project</span>></span></span><br></pre></table></figure><h2 id=7-2、Spring-Boot-Gradle-插件><a title="7.2、Spring Boot Gradle 插件" class=headerlink href=#7-2、Spring-Boot-Gradle-插件></a>7.2、Spring Boot Gradle 插件</h2><p>Spring Boot Gradle 插件在 Gradle 中提供了 Spring Boot 支持，使您可以打包可执行 jar 或 war 归档文件，运行 Spring Boot 应用程序以及使用<code>spring-boot-dependencies</code>提供的依赖项 Management。它需要 Gradle 4.4 或更高版本。请参考插件的文档以了解更多信息：<ul><li>参考(<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/gradle-plugin/reference/html rel=noopener target=_blank>HTML</a>和<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/gradle-plugin/reference/pdf/spring-boot-gradle-plugin-reference.pdf rel=noopener target=_blank>PDF</a>)<li><a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/gradle-plugin/api rel=noopener target=_blank>API</a></ul><h2 id=7-3、Spring-Boot-AntLib-模块><a title="7.3、Spring Boot AntLib 模块" class=headerlink href=#7-3、Spring-Boot-AntLib-模块></a>7.3、Spring Boot AntLib 模块</h2><p>Spring Boot AntLib 模块为 Apache Ant 提供了基本的 Spring Boot 支持。您可以使用该模块创建可执行 jar。要使用该模块，您需要在<code>build.xml</code>中声明一个额外的<code>spring-boot</code>命名空间，如以下示例所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>project</span> <span class=attr>xmlns:ivy</span>=<span class=string>"antlib:org.apache.ivy.ant"</span></span></span><br><span class=line><span class=tag>	<span class=attr>xmlns:spring-boot</span>=<span class=string>"antlib:org.springframework.boot.ant"</span></span></span><br><span class=line><span class=tag>	<span class=attr>name</span>=<span class=string>"myapp"</span> <span class=attr>default</span>=<span class=string>"build"</span>></span></span><br><span class=line>	...</span><br><span class=line><span class=tag>&LT/<span class=name>project</span>></span></span><br></pre></table></figure><p>您需要记住使用<code>-lib</code>选项启动 Ant，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>ant -lib &LTfolder containing spring-boot-antlib-2.1.1.RELEASE.jar></span></span><br></pre></table></figure><h3 id=7-3-1、Spring-Boot-Ant-任务><a title="7.3.1、Spring Boot Ant 任务" class=headerlink href=#7-3-1、Spring-Boot-Ant-任务></a>7.3.1、Spring Boot Ant 任务</h3><p>声明<code>spring-boot-antlib</code>名称空间后，可以使用以下附加任务：<ul><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/build-tool-plugins-antlib.html#spring-boot-ant-exejar rel=noopener target=_blank>第 73.1.1 节“ spring-boot：exejar”</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/build-tool-plugins-antlib.html#spring-boot-ant-findmainclass rel=noopener target=_blank>第 73.2 节“ spring-boot：findmainclass”</a></ul><h4 id=7-3-1-1、spring-boot-exejar><a class=headerlink href=#7-3-1-1、spring-boot-exejar title=7.3.1.1、spring-boot:exejar></a>7.3.1.1、spring-boot:exejar</h4><p>您可以使用<code>exejar</code>任务创建一个 Spring Boot 可执行 jar。任务支持以下属性：<table><thead><tr><th>Attribute<th>Description<th>Required<tbody><tr><td><code>destfile</code><td>要创建的目标 jar 文件<td>Yes<tr><td><code>classes</code><td>Java 类文件的根目录<td>Yes<tr><td><code>start-class</code><td>要运行的主要应用程序类<td>否*(默认为找到的第一个声明<code>main</code>方法的类)*</table><p>以下嵌套元素可用于任务：<table><thead><tr><th>Element<th>Description<tbody><tr><td><code>resources</code><td>一个或多个<a href=https://ant.apache.org/manual/Types/resources.html#collection rel=noopener target=_blank>Resource Collections</a>描述一组<a href=https://ant.apache.org/manual/Types/resources.html rel=noopener target=_blank>Resources</a>，应将其添加到创建的 jar 文件的内容中。<tr><td><code>lib</code><td>应该将一个或多个<a href=https://ant.apache.org/manual/Types/resources.html#collection rel=noopener target=_blank>Resource Collections</a>添加到组成应用程序运行时依赖项 Classpath 的 jar 库集合中。</table><h4 id=7-3-1-2、Examples><a class=headerlink href=#7-3-1-2、Examples title=7.3.1.2、Examples></a>7.3.1.2、Examples</h4><p>本节显示了两个 Ant 任务示例。<p><strong>Specify start-class.</strong><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>spring-boot:exejar</span> <span class=attr>destfile</span>=<span class=string>"target/my-application.jar"</span></span></span><br><span class=line><span class=tag>		<span class=attr>classes</span>=<span class=string>"target/classes"</span> <span class=attr>start-class</span>=<span class=string>"com.example.MyApplication"</span>></span></span><br><span class=line>	<span class=tag><<span class=name>resources</span>></span></span><br><span class=line>		<span class=tag><<span class=name>fileset</span> <span class=attr>dir</span>=<span class=string>"src/main/resources"</span> /></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>resources</span>></span></span><br><span class=line>	<span class=tag><<span class=name>lib</span>></span></span><br><span class=line>		<span class=tag><<span class=name>fileset</span> <span class=attr>dir</span>=<span class=string>"lib"</span> /></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>lib</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>spring-boot:exejar</span>></span></span><br></pre></table></figure><p><strong>Detect start-class.</strong><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>exejar</span> <span class=attr>destfile</span>=<span class=string>"target/my-application.jar"</span> <span class=attr>classes</span>=<span class=string>"target/classes"</span>></span></span><br><span class=line>	<span class=tag><<span class=name>lib</span>></span></span><br><span class=line>		<span class=tag><<span class=name>fileset</span> <span class=attr>dir</span>=<span class=string>"lib"</span> /></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>lib</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>exejar</span>></span></span><br></pre></table></figure><h3 id=7-3-2、spring-boot-findmainclass><a class=headerlink href=#7-3-2、spring-boot-findmainclass title=7.3.2、spring-boot:findmainclass></a>7.3.2、spring-boot:findmainclass</h3><p><code>exejar</code>在内部使用<code>findmainclass</code>任务来查找声明<code>main</code>的类。如有必要，您也可以直接在构建中使用此任务。支持以下属性：<table><thead><tr><th>Attribute<th>Description<th>Required<tbody><tr><td><code>classesroot</code><td>Java 类文件的根目录<td>是*(除非指定了<code>mainclass</code>)*<tr><td><code>mainclass</code><td>可用于短路<code>main</code>类搜索<td>No<tr><td><code>property</code><td>应该与结果一起设置的 Ant 属性<td>否*(如果未指定，将记录结果)*</table><h4 id=7-3-2-1、Examples><a class=headerlink href=#7-3-2-1、Examples title=7.3.2.1、Examples></a>7.3.2.1、Examples</h4><p>本节包含三个使用<code>findmainclass</code>的示例。<p><strong>查找并记录.</strong><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>&LTfindmainclass classesroot="target/classes" /></span><br></pre></table></figure><p><strong>查找并设置.</strong><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>&LTfindmainclass classesroot="target/classes" property="main-class" /></span><br></pre></table></figure><p><strong>覆盖并设置.</strong><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>&LTfindmainclass mainclass="com.example.MainClass" property="main-class" /></span><br></pre></table></figure><h2 id=7-4、支持其他构建系统><a class=headerlink href=#7-4、支持其他构建系统 title=7.4、支持其他构建系统></a>7.4、支持其他构建系统</h2><p>如果要使用 Maven，Gradle 或 Ant 以外的构建工具，则可能需要开发自己的插件。可执行的 jar 需要遵循特定的格式，并且某些条目需要以未压缩的形式编写(有关详细信息，请参见附录中的“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/executable-jar.html rel=noopener target=_blank>可执行 jar 格式</a>”部分)。<p>Spring Boot Maven 和 Gradle 插件都使用<code>spring-boot-loader-tools</code>来实际生成 jar。如果需要，可以直接使用此库。<h3 id=7-4-1、重新打包-Files><a title="7.4.1、重新打包 Files" class=headerlink href=#7-4-1、重新打包-Files></a>7.4.1、重新打包 Files</h3><p>要重新打包现有存档，使其成为独立的可执行存档，请使用<code>org.springframework.boot.loader.tools.Repackager</code>。 <code>Repackager</code>类采用单个构造函数参数，该参数引用现有的 jar 或 war 存档。使用两个可用的<code>repackage()</code>方法之一替换原始文件或写入新目标。在重新打包程序运行之前，还可以在其上配置各种设置。<h3 id=7-4-2、嵌套库><a class=headerlink href=#7-4-2、嵌套库 title=7.4.2、嵌套库></a>7.4.2、嵌套库</h3><p>重新打包归档文件时，可以使用<code>org.springframework.boot.loader.tools.Libraries</code>接口包含对依赖文件的引用。我们在这里不提供<code>Libraries</code>的任何具体实现，因为它们通常是特定于构建系统的。<p>如果您的存档中已经包含库，则可以使用<code>Libraries.NONE</code>。<h3 id=7-4-3、查找主要类><a class=headerlink href=#7-4-3、查找主要类 title=7.4.3、查找主要类></a>7.4.3、查找主要类</h3><p>如果不使用<code>Repackager.setMainClass()</code>指定主类，则重新打包程序将使用<a href=http://asm.ow2.org/ rel=noopener target=_blank>ASM</a>读取类文件，并尝试使用<code>public static void main(String[] args)</code>方法查找合适的类。如果找到多个候选者，则会引发异常。<h3 id=7-4-4、重新打包实施示例><a class=headerlink href=#7-4-4、重新打包实施示例 title=7.4.4、重新打包实施示例></a>7.4.4、重新打包实施示例</h3><p>以下示例显示了典型的重新打包实现：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>Repackager repackager = new Repackager(sourceJarFile);</span><br><span class=line>repackager.setBackupSource(false);</span><br><span class=line>repackager.repackage(new Libraries() {</span><br><span class=line>			@Override</span><br><span class=line>			public void doWithLibraries(LibraryCallback callback) throws IOException {</span><br><span class=line>				// Build system specific implementation, callback for each dependency</span><br><span class=line>				// callback.library(new Library(nestedFile, LibraryScope.COMPILE));</span><br><span class=line>			}</span><br><span class=line>		});</span><br></pre></table></figure></div><footer class=post-footer><div class=post-tags><a href=/tags/SpringBoot/ rel=tag># SpringBoot</a><a href=/tags/SpringBoot%E5%9F%BA%E7%A1%80/ rel=tag># SpringBoot基础</a></div><div class=post-nav><div class=post-nav-item><a href=/2024/08/21/SpringBoot%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/ rel=prev title=SpringBoot系列-SpringBoot原理解析> <i class="fa fa-angle-left"></i> SpringBoot系列-SpringBoot原理解析 </a></div><div class=post-nav-item><a href=/2024/08/21/SpringIOC/ rel=next title=Spring系列-SpringIOC> Spring系列-SpringIOC <i class="fa fa-angle-right"></i> </a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script>