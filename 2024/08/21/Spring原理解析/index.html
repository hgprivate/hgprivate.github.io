<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hgprivate.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="IOC（控制反转）1、refresh()0、源码org.springframework.context.support.AbstractApplication.refresh()： 1234567891011121314151617181920212223242526272829303132@Overridepublic void refresh() throws BeansException," name=description><meta content=article property=og:type><meta content=Spring系列-Spring原理解析 property=og:title><meta content=https://hgprivate.github.io/2024/08/21/Spring%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content="IOC（控制反转）1、refresh()0、源码org.springframework.context.support.AbstractApplication.refresh()： 1234567891011121314151617181920212223242526272829303132@Overridepublic void refresh() throws BeansException," property=og:description><meta content=zh_CN property=og:locale><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210320173030372.png property=og:image><meta content=2024-08-21T13:39:14.805Z property=article:published_time><meta content=2023-10-04T07:59:52.025Z property=article:modified_time><meta content=豪哥 property=article:author><meta content=Spring property=article:tag><meta content=Spring原理 property=article:tag><meta content=summary name=twitter:card><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210320173030372.png name=twitter:image><link href=https://hgprivate.github.io/2024/08/21/Spring%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hgprivate.github.io/2024/08/21/Spring%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","path":"2024/08/21/Spring原理解析/","title":"Spring系列-Spring原理解析"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>Spring系列-Spring原理解析 | 豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>豪哥博客</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#IOC%EF%BC%88%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%89><span class=nav-number>1.</span> <span class=nav-text>IOC（控制反转）</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1%E3%80%81refresh><span class=nav-number>1.1.</span> <span class=nav-text>1、refresh()</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#0%E3%80%81%E6%BA%90%E7%A0%81><span class=nav-number>1.1.1.</span> <span class=nav-text>0、源码</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1%E3%80%81prepareRefresh><span class=nav-number>1.1.2.</span> <span class=nav-text>1、prepareRefresh()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2%E3%80%81beanFactory-obtainFreshBeanFactory><span class=nav-number>1.1.3.</span> <span class=nav-text>2、beanFactory = obtainFreshBeanFactory()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3%E3%80%81prepareBeanFactory-beanFactory><span class=nav-number>1.1.4.</span> <span class=nav-text>3、prepareBeanFactory(beanFactory)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4%E3%80%81postProcessBeanFactory-beanFactory><span class=nav-number>1.1.5.</span> <span class=nav-text>4、postProcessBeanFactory(beanFactory)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#5%E3%80%81invokeBeanFactoryPostProcessors-beanFactory><span class=nav-number>1.1.6.</span> <span class=nav-text>5、invokeBeanFactoryPostProcessors(beanFactory)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#6%E3%80%81registerBeanPostProcessors-beanFactory><span class=nav-number>1.1.7.</span> <span class=nav-text>6、registerBeanPostProcessors(beanFactory)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#7%E3%80%81initMessageSource><span class=nav-number>1.1.8.</span> <span class=nav-text>7、initMessageSource()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#8%E3%80%81initApplicationEventMulticaster><span class=nav-number>1.1.9.</span> <span class=nav-text>8、initApplicationEventMulticaster()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#9%E3%80%81onRefresh><span class=nav-number>1.1.10.</span> <span class=nav-text>9、onRefresh()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#10%E3%80%81registerListeners><span class=nav-number>1.1.11.</span> <span class=nav-text>10、registerListeners()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#11%E3%80%81finishBeanFactoryInitialization-beanFactory><span class=nav-number>1.1.12.</span> <span class=nav-text>11、finishBeanFactoryInitialization(beanFactory)</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#12%E3%80%81finishRefresh><span class=nav-number>1.1.13.</span> <span class=nav-text>12、finishRefresh()</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#13%E3%80%81%E6%80%BB%E7%BB%93><span class=nav-number>1.1.14.</span> <span class=nav-text>13、总结</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2%E3%80%81BeanPostProcessor%E4%B8%8EBeanFactoryPostProcessor><span class=nav-number>1.2.</span> <span class=nav-text>2、BeanPostProcessor与BeanFactoryPostProcessor</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.2.1.</span> <span class=nav-text>2.1、简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-2%E3%80%81BeanFactoryPostProcessor%E5%8E%9F%E7%90%86><span class=nav-number>1.2.2.</span> <span class=nav-text>2.2、BeanFactoryPostProcessor原理</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3%E3%80%81ApplicationListener><span class=nav-number>1.3.</span> <span class=nav-text>3、ApplicationListener</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.3.1.</span> <span class=nav-text>3.1、简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-2%E3%80%81%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4><span class=nav-number>1.3.2.</span> <span class=nav-text>3.2、开发步骤</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-3%E3%80%81%E5%8E%9F%E7%90%86><span class=nav-number>1.3.3.</span> <span class=nav-text>3.3、原理</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3%E3%80%81%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%85%A5><span class=nav-number>1.4.</span> <span class=nav-text>3、组件注入</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-1%E3%80%81%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B><span class=nav-number>1.4.1.</span> <span class=nav-text>3.1、注入类型</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#setter%E6%B3%A8%E5%85%A5><span class=nav-number>1.4.1.1.</span> <span class=nav-text>setter注入</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%9E%84%E9%80%A0%E6%B3%A8%E5%85%A5><span class=nav-number>1.4.1.2.</span> <span class=nav-text>构造注入</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%8E%A5%E5%8F%A3%E6%B3%A8%E5%85%A5><span class=nav-number>1.4.1.3.</span> <span class=nav-text>接口注入</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%B3%A8%E8%A7%A3%E6%B3%A8%E5%85%A5><span class=nav-number>1.4.1.4.</span> <span class=nav-text>注解注入</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5><span class=nav-number>1.4.1.5.</span> <span class=nav-text>文件属性注入</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-2%E3%80%81Autowired%E6%B3%A8%E8%A7%A3><span class=nav-number>1.4.2.</span> <span class=nav-text>3.2、Autowired注解</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#4%E3%80%81%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96><span class=nav-number>1.5.</span> <span class=nav-text>4、循环依赖</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-1%E3%80%81%E5%89%8D%E8%A8%80><span class=nav-number>1.5.1.</span> <span class=nav-text>4.1、前言</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-2%E3%80%81%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98><span class=nav-number>1.5.2.</span> <span class=nav-text>4.2、循环依赖问题</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-3%E3%80%81%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96><span class=nav-number>1.5.3.</span> <span class=nav-text>4.3、解决循环依赖</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-4%E3%80%81%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98><span class=nav-number>1.5.4.</span> <span class=nav-text>4.4、为何需要三级缓存</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-5%E3%80%81%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E4%BC%9A%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E5%90%97%EF%BC%9F><span class=nav-number>1.5.5.</span> <span class=nav-text>4.5、三级缓存会提高效率吗？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-6%E3%80%81%E6%80%BB%E7%BB%93><span class=nav-number>1.5.6.</span> <span class=nav-text>4.6、总结</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#AOP%EF%BC%88%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%EF%BC%89><span class=nav-number>2.</span> <span class=nav-text>AOP（切面编程）</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#2%E3%80%81AOP%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86><span class=nav-number>2.1.</span> <span class=nav-text>2、AOP动态代理</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-1%E3%80%81%E7%AE%80%E4%BB%8B-1><span class=nav-number>2.1.1.</span> <span class=nav-text>2.1、简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0><span class=nav-number>2.1.2.</span> <span class=nav-text>2.2、代码实现</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3%E3%80%81AOP%E5%8E%9F%E7%90%86><span class=nav-number>2.2.</span> <span class=nav-text>3、AOP原理</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-1%E3%80%81-EnableAspectJAutoProxy><span class=nav-number>2.2.1.</span> <span class=nav-text>3.1、@EnableAspectJAutoProxy</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-2%E3%80%81%E6%B5%81%E7%A8%8B><span class=nav-number>2.2.2.</span> <span class=nav-text>3.2、流程</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-3%E3%80%81AnnotationAwareAspectJAutoProxyCreator><span class=nav-number>2.2.3.</span> <span class=nav-text>3.3、AnnotationAwareAspectJAutoProxyCreator</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#3-3-1%E3%80%81bean%E5%88%9B%E5%BB%BA%E5%89%8D%EF%BC%8C%E8%B0%83%E7%94%A8postProcessBeforeInstantiation><span class=nav-number>2.2.3.1.</span> <span class=nav-text>3.3.1、bean创建前，调用postProcessBeforeInstantiation()</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-3-2%E3%80%81%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1><span class=nav-number>2.2.3.2.</span> <span class=nav-text>3.3.2、创建对象</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#3-3-3%E3%80%81%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C><span class=nav-number>2.2.3.3.</span> <span class=nav-text>3.3.3、目标方法执行</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#3-4%E3%80%81%E6%80%BB%E7%BB%93><span class=nav-number>2.2.4.</span> <span class=nav-text>3.4、总结</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#MVC><span class=nav-number>3.</span> <span class=nav-text>MVC</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1%E3%80%81%E8%AF%B7%E6%B1%82%E5%8C%B9%E9%85%8D><span class=nav-number>3.1.</span> <span class=nav-text>1、请求匹配</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2%E3%80%81%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90-%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C><span class=nav-number>3.2.</span> <span class=nav-text>2、参数解析/返回结果</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3%E3%80%81%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86><span class=nav-number>3.3.</span> <span class=nav-text>3、内容协商</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#4%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86><span class=nav-number>3.4.</span> <span class=nav-text>4、异常处理</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#5%E3%80%81%E6%80%BB%E7%BB%93><span class=nav-number>3.5.</span> <span class=nav-text>5、总结</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#5-1%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5><span class=nav-number>3.5.1.</span> <span class=nav-text>5.1、初始化阶段</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#5-2%E3%80%81%E5%8C%B9%E9%85%8D%E9%98%B6%E6%AE%B5><span class=nav-number>3.5.2.</span> <span class=nav-text>5.2、匹配阶段</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#5-3%E3%80%81%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5><span class=nav-number>3.5.3.</span> <span class=nav-text>5.3、执行阶段</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#Transaction%EF%BC%88%E4%BA%8B%E5%8A%A1%EF%BC%89><span class=nav-number>4.</span> <span class=nav-text>Transaction（事务）</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA><span class=nav-number>4.1.</span> <span class=nav-text>1、环境搭建</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2%E3%80%81%E5%8E%9F%E7%90%86><span class=nav-number>4.2.</span> <span class=nav-text>2、原理</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#XML%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90><span class=nav-number>5.</span> <span class=nav-text>XML配置原理解析</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81%E5%88%9B%E5%BB%BA%E5%B9%B6%E9%85%8D%E7%BD%AExsd%E6%96%87%E4%BB%B6><span class=nav-number>5.1.</span> <span class=nav-text>1.1、创建并配置xsd文件</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-2%E3%80%81%E5%88%9B%E5%BB%BAspring-schemas%E6%96%87%E4%BB%B6><span class=nav-number>5.2.</span> <span class=nav-text>1.2、创建spring.schemas文件</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-3%E3%80%81%E5%88%9B%E5%BB%BA%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%A4%84%E7%90%86%E5%99%A8><span class=nav-number>5.3.</span> <span class=nav-text>1.3、创建命名空间处理器</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-4%E3%80%81%E5%88%9B%E5%BB%BAspring-handlers%E6%96%87%E4%BB%B6><span class=nav-number>5.4.</span> <span class=nav-text>1.4、创建spring.handlers文件</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-5%E3%80%81%E6%B5%8B%E8%AF%95%E6%95%88%E6%9E%9C><span class=nav-number>5.5.</span> <span class=nav-text>1.5、测试效果</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#Spring%E6%95%B4%E5%90%88MyBatis><span class=nav-number>6.</span> <span class=nav-text>Spring整合MyBatis</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81%E6%A6%82%E8%BF%B0><span class=nav-number>6.1.</span> <span class=nav-text>1.1、概述</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-2%E3%80%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90><span class=nav-number>6.2.</span> <span class=nav-text>1.2、流程分析</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#Spring%E5%B7%A5%E5%85%B7%E7%B1%BB><span class=nav-number>7.</span> <span class=nav-text>Spring工具类</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81PropertiesLoaderUtils><span class=nav-number>7.1.</span> <span class=nav-text>1.1、PropertiesLoaderUtils</span></a></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>116</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>36</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>129</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://hgprivate.github.io/2024/08/21/Spring%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="Spring系列-Spring原理解析 | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>Spring系列-Spring原理解析</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-04 15:59:52" datetime=2023-10-04T15:59:52+08:00 itemprop=dateModified>2023-10-04</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Spring/ itemprop=url rel=index><span itemprop=name>Spring</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=IOC（控制反转）><a class=headerlink href=#IOC（控制反转） title=IOC（控制反转）></a>IOC（控制反转）</h1><h2 id=1、refresh><a class=headerlink href=#1、refresh title=1、refresh()></a>1、refresh()</h2><h3 id=0、源码><a class=headerlink href=#0、源码 title=0、源码></a>0、源码</h3><p><code>org.springframework.context.support.AbstractApplication.refresh()</code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">refresh</span><span class=params>()</span> <span class=keyword>throws</span> BeansException, IllegalStateException {</span><br><span class=line>    <span class=keyword>synchronized</span> (<span class=built_in>this</span>.startupShutdownMonitor) {</span><br><span class=line>        <span class=comment>// 1、准备容器</span></span><br><span class=line>        prepareRefresh();</span><br><span class=line>        <span class=comment>// 2、告知子类刷新内部BeanFactory</span></span><br><span class=line>        <span class=type>ConfigurableListableBeanFactory</span> <span class=variable>beanFactory</span> <span class=operator>=</span> obtainFreshBeanFactory();</span><br><span class=line>        <span class=comment>// 3、准备BeanFactory</span></span><br><span class=line>        prepareBeanFactory(beanFactory);</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            <span class=comment>// 4、Allows post-processing of the bean factory in context subclasses.</span></span><br><span class=line>            postProcessBeanFactory(beanFactory);</span><br><span class=line>            <span class=comment>// 5、Invoke factory processors registered as beans in the context.</span></span><br><span class=line>            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=line>            <span class=comment>// 6、Register bean processors that intercept bean creation.</span></span><br><span class=line>            registerBeanPostProcessors(beanFactory);</span><br><span class=line>            <span class=comment>// 7、Initialize message source for this context.</span></span><br><span class=line>            initMessageSource();</span><br><span class=line>            <span class=comment>// 8、Initialize event multicaster for this context.</span></span><br><span class=line>            initApplicationEventMulticaster();</span><br><span class=line>            <span class=comment>// 9、Initialize other special beans in specific context subclasses.</span></span><br><span class=line>            onRefresh();</span><br><span class=line>            <span class=comment>// 10、Check for listener beans and register them.</span></span><br><span class=line>            registerListeners();</span><br><span class=line>            <span class=comment>// 11、Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class=line>            finishBeanFactoryInitialization(beanFactory);</span><br><span class=line>            <span class=comment>// 12、Last step: publish corresponding event.</span></span><br><span class=line>            finishRefresh();</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 省略部分代码，不重要 //</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1、prepareRefresh><a class=headerlink href=#1、prepareRefresh title=1、prepareRefresh()></a>1、prepareRefresh()</h3><p>刷新前的预处理：<strong>初始化属性，检验属性合法性，保存容器中的事件</strong>。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>1）、initPropertySources()初始化一些属性设置;子类自定义个性化的属性设置方法；</span><br><span class=line>2）、getEnvironment().validateRequiredProperties();检验属性的合法等</span><br><span class=line>3）、earlyApplicationEvents= new LinkedHashSet&LTApplicationEvent>();保存容器中的一些早期的事件；</span><br></pre></table></figure><h3 id=2、beanFactory-obtainFreshBeanFactory><a title="2、beanFactory = obtainFreshBeanFactory()" class=headerlink href=#2、beanFactory-obtainFreshBeanFactory></a>2、beanFactory = obtainFreshBeanFactory()</h3><p>获取BeanFactory。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>1）、refreshBeanFactory();</span><br><span class=line>	刷新【创建】BeanFactory（this.beanFactory = new DefaultListableBeanFactory();）</span><br><span class=line>	设置id；</span><br><span class=line>2）、getBeanFactory();返回刚才GenericApplicationContext创建的BeanFactory对象；</span><br><span class=line>3）、将创建的BeanFactory【DefaultListableBeanFactory】返回；</span><br></pre></table></figure><h3 id=3、prepareBeanFactory-beanFactory><a class=headerlink href=#3、prepareBeanFactory-beanFactory title=3、prepareBeanFactory(beanFactory)></a>3、prepareBeanFactory(beanFactory)</h3><p>BeanFactory的预准备工作（BeanFactory进行一些设置）。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>1）、设置BeanFactory的类加载器、支持表达式解析器...</span><br><span class=line>2）、添加部分BeanPostProcessor【ApplicationContextAwareProcessor】</span><br><span class=line>3）、设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、xxx；</span><br><span class=line>4）、注册可以解析的自动装配；我们能直接在任何组件中自动注入：</span><br><span class=line>	BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext</span><br><span class=line>5）、添加BeanPostProcessor【ApplicationListenerDetector】</span><br><span class=line>6）、添加编译时的AspectJ；</span><br><span class=line>7）、给BeanFactory中注册一些能用的组件；</span><br><span class=line>	environment【ConfigurableEnvironment】、</span><br><span class=line>	systemProperties【Map&LTString, Object>】、</span><br><span class=line>	systemEnvironment【Map&LTString, Object>】</span><br></pre></table></figure><h3 id=4、postProcessBeanFactory-beanFactory><a class=headerlink href=#4、postProcessBeanFactory-beanFactory title=4、postProcessBeanFactory(beanFactory)></a>4、postProcessBeanFactory(beanFactory)</h3><p><strong>BeanFactory准备完成后的后置处理工作，默认空，留给子类重写实现</strong>；<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>1）、子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置。</span><br></pre></table></figure><h3 id=5、invokeBeanFactoryPostProcessors-beanFactory><a class=headerlink href=#5、invokeBeanFactoryPostProcessors-beanFactory title=5、invokeBeanFactoryPostProcessors(beanFactory)></a>5、invokeBeanFactoryPostProcessors(beanFactory)</h3><p>执行BeanFactoryPostProcessor方法；<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line>BeanFactoryPostProcessor：BeanFactory后置处理器在BeanFactory标准初始化之后执行；</span><br><span class=line>两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor</span><br><span class=line></span><br><span class=line>1）、执行BeanFactoryPostProcessor的方法；</span><br><span class=line>先执行BeanDefinitionRegistryPostProcessor</span><br><span class=line>	1）、获取所有的BeanDefinitionRegistryPostProcessor；</span><br><span class=line>	2）、先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor、</span><br><span class=line>		postProcessor.postProcessBeanDefinitionRegistry(registry)</span><br><span class=line>	3）、再执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor；</span><br><span class=line>		postProcessor.postProcessBeanDefinitionRegistry(registry)</span><br><span class=line>	4）、最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessors；</span><br><span class=line>		postProcessor.postProcessBeanDefinitionRegistry(registry)</span><br><span class=line>再执行BeanFactoryPostProcessor的方法</span><br><span class=line>	1）、获取所有的BeanFactoryPostProcessor</span><br><span class=line>	2）、先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor、</span><br><span class=line>		postProcessor.postProcessBeanFactory()</span><br><span class=line>	3）、在执行实现了Ordered顺序接口的BeanFactoryPostProcessor；</span><br><span class=line>		postProcessor.postProcessBeanFactory()</span><br><span class=line>	4）、最后执行没有实现任何优先级或者是顺序接口的BeanFactoryPostProcessor；</span><br><span class=line>		postProcessor.postProcessBeanFactory()</span><br></pre></table></figure><h3 id=6、registerBeanPostProcessors-beanFactory><a class=headerlink href=#6、registerBeanPostProcessors-beanFactory title=6、registerBeanPostProcessors(beanFactory)></a>6、registerBeanPostProcessors(beanFactory)</h3><p>注册BeanPostProcessor（Bean后置处理器）<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line>不同接口类型的BeanPostProcessor；在Bean创建前后的执行时机是不一样的</span><br><span class=line>	BeanPostProcessor、</span><br><span class=line>	DestructionAwareBeanPostProcessor、</span><br><span class=line>	InstantiationAwareBeanPostProcessor、</span><br><span class=line>	SmartInstantiationAwareBeanPostProcessor、</span><br><span class=line>	MergedBeanDefinitionPostProcessor【internalPostProcessors】、</span><br><span class=line>		</span><br><span class=line>1）、获取所有的BeanPostProcessor;增强器可以通过PriorityOrdered、Ordered接口来设置执行优先级。</span><br><span class=line>2）、先注册实现PriorityOrdered接口的BeanPostProcessor，把每一个BeanPostProcessor添加到BeanFactory中。</span><br><span class=line>3）、再注册实现Ordered接口BeanPostProcessor。</span><br><span class=line>4）、最后注册没有实现任何优先级接口的BeanPostProcessor。</span><br><span class=line>5）、最终注册MergedBeanDefinitionPostProcessor；</span><br><span class=line>6）、注册一个ApplicationListenerDetector；在Bean创建完成后检查是否是ApplicationListener，如果是则将其添加到上下文中。</span><br></pre></table></figure><h3 id=7、initMessageSource><a class=headerlink href=#7、initMessageSource title=7、initMessageSource()></a>7、initMessageSource()</h3><p>初始化MessageSource组件（做国际化功能；消息绑定，消息解析）；<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>1）、获取BeanFactory</span><br><span class=line>2）、检查容器中是否有id为messageSource，类型是MessageSource的组件。</span><br><span class=line>	如果有赋值给messageSource，如果没有自己创建一个DelegatingMessageSource；</span><br><span class=line>	MessageSource：取出国际化配置文件中的某个key的值；能按照区域信息获取；</span><br><span class=line>3）、把创建好的MessageSource注册到容器中，以后获取国际化配置文件值时，可自动注入MessageSource；</span><br></pre></table></figure><h3 id=8、initApplicationEventMulticaster><a class=headerlink href=#8、initApplicationEventMulticaster title=8、initApplicationEventMulticaster()></a>8、initApplicationEventMulticaster()</h3><p>初始化事件派发器；<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>1）、获取BeanFactory</span><br><span class=line>2）、从BeanFactory中获取ApplicationEventMulticaster；</span><br><span class=line>3）、如果上一步没有配置；则会创建一个SimpleApplicationEventMulticaster</span><br><span class=line>4）、将创建的ApplicationEventMulticaster添加到BeanFactory中，以后其他组件直接自动注入</span><br></pre></table></figure><h3 id=9、onRefresh><a class=headerlink href=#9、onRefresh title=9、onRefresh()></a>9、onRefresh()</h3><p>默认为空，留给子容器（子类）实现。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>1、子类可重写该方法，容器刷新时可自定义逻辑；</span><br></pre></table></figure><h3 id=10、registerListeners><a class=headerlink href=#10、registerListeners title=10、registerListeners()></a>10、registerListeners()</h3><p>把容器中所有ApplicationListener注册进来；<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>1、从容器中拿到所有的ApplicationListener</span><br><span class=line>2、将每个监听器添加到事件派发器中；</span><br><span class=line>	getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class=line>3、派发之前生成的事件；</span><br></pre></table></figure><h3 id=11、finishBeanFactoryInitialization-beanFactory><a class=headerlink href=#11、finishBeanFactoryInitialization-beanFactory title=11、finishBeanFactoryInitialization(beanFactory)></a>11、finishBeanFactoryInitialization(beanFactory)</h3><p><strong>初始化剩下的所有单实例 bean</strong>；<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br></pre><td class=code><pre><span class=line>1、beanFactory.preInstantiateSingletons();初始化后剩下的单实例bean</span><br><span class=line>	1）、获取容器中的所有Bean，依次进行初始化和创建对象</span><br><span class=line>	2）、获取Bean定义信息；RootBeanDefinition</span><br><span class=line>	3）、Bean不是抽象的，是单实例的，不是懒加载；</span><br><span class=line>		1）、判断是否是FactoryBean（是否是实现FactoryBean接口的Bean）</span><br><span class=line>		2）、若不是工厂Bean，则利用getBean(beanName)创建对象</span><br><span class=line>			0、getBean(beanName)； ioc.getBean();</span><br><span class=line>			1、doGetBean(name, null, null, false);</span><br><span class=line>			2、先获取缓存中的单例Bean。若缓存中有说明先前已经创建过。</span><br><span class=line>				从singletonObjects = new ConcurrentHashMap&LTString, Object>(256);中获取</span><br><span class=line>			3、缓存中没有，执行Bean创建流程；</span><br><span class=line>			4、标记当前bean已经被创建</span><br><span class=line>			5、获取Bean定义信息；</span><br><span class=line>			6、【获取当前Bean依赖的其他Bean;如果有按照getBean()把依赖的Bean先创建出来；】</span><br><span class=line>			7、启动单实例Bean的创建流程；</span><br><span class=line>				1）、createBean(beanName, mbd, args);</span><br><span class=line>				2）、resolveBeforeInstantiation(beanName, mbdToUse);让Bean增强器先拦截返回代理对象；</span><br><span class=line>				【InstantiationAwareBeanPostProcessor】：提前执行；</span><br><span class=line>					- 先触发：postProcessBeforeInstantiation()；看是否已经创建过Bean。</span><br><span class=line>					- 如果已经创建过Bean，那么触发postProcessAfterInitialization()；看是否需要代理，若需要代理则创建代理对象并返回，否则直接返回原始对象。</span><br><span class=line>				    - 如果没有创建过Bean，则调用3）</span><br><span class=line>				3）、Object beanInstance = doCreateBean(beanName, mbdToUse, args);创建Bean</span><br><span class=line>					 1）、【创建Bean实例】；createBeanInstance(beanName, mbd, args);</span><br><span class=line>						利用 工厂方法 或 构造器 创建出Bean实例；</span><br><span class=line>					 2）、applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class=line>						调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class=line>					 3）、【Bean属性赋值】populateBean(beanName, mbd, instanceWrapper);</span><br><span class=line>						赋值之前：</span><br><span class=line>						1）、拿到InstantiationAwareBeanPostProcessor后置处理器；</span><br><span class=line>							postProcessAfterInstantiation()；</span><br><span class=line>						2）、拿到InstantiationAwareBeanPostProcessor后置处理器；</span><br><span class=line>							postProcessPropertyValues()；</span><br><span class=line>						3）、设置Bean的属性值；利用setter方法等为属性赋值；</span><br><span class=line>							applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class=line>					 4）、【Bean初始化】initializeBean(beanName, exposedObject, mbd);</span><br><span class=line>						1）、【执行Aware接口方法】invokeAwareMethods(beanName, bean);</span><br><span class=line>							BeanNameAware\BeanClassLoaderAware\BeanFactoryAware</span><br><span class=line>						2）、【执行后置处理器的初始化之前】applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class=line>							BeanPostProcessor.postProcessBeforeInitialization（）;</span><br><span class=line>						3）、【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class=line>							1）、是否实现了InitializingBean接口；是则执行该接口的初始化方法；</span><br><span class=line>							2）、是否自定义初始化方法；</span><br><span class=line>						4）、【执行后置处理器初始化之后】applyBeanPostProcessorsAfterInitialization</span><br><span class=line>							BeanPostProcessor.postProcessAfterInitialization()；</span><br><span class=line>					 5）、注册Bean的销毁方法；</span><br><span class=line>				4）、将创建的Bean添加到缓存中singletonObjects；</span><br><span class=line>			ioc容器就是这些Map；很多的Map里面保存了单实例Bean，环境信息。。。。；</span><br><span class=line></span><br><span class=line>所有Bean都利用getBean创建完成以后；</span><br><span class=line>检查所有的Bean是否是SmartInitializingSingleton接口的，如果是，就执行afterSingletonsInstantiated()；</span><br></pre></table></figure><h3 id=12、finishRefresh><a class=headerlink href=#12、finishRefresh title=12、finishRefresh()></a>12、finishRefresh()</h3><p>最后一步：<strong>发布相应的事件</strong>。（完成此上下文的刷新，调用<code>LifecycleProcessor.onRefresh()</code>方法并发布org.springframework.context.event.ContextRefreshedEvent 事件）<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>1）、initLifecycleProcessor();初始化与生命周期有关的后置处理器（LifecycleProcessor）</span><br><span class=line>	默认从容器中找是否有lifecycleProcessor的组件【LifecycleProcessor】，如果没有new DefaultLifecycleProcessor()加入到容器；</span><br><span class=line>	写一个LifecycleProcessor实现类，可以在BeanFactory</span><br><span class=line>		void onRefresh();</span><br><span class=line>		void onClose();	</span><br><span class=line>2）、getLifecycleProcessor().onRefresh();</span><br><span class=line>	拿到前面定义的生命周期处理器（BeanFactory），回调onRefresh()；</span><br><span class=line>3）、publishEvent(new ContextRefreshedEvent(this));发布容器刷新完成事件；</span><br><span class=line>4）、liveBeansView.registerApplicationContext(this);</span><br></pre></table></figure><h3 id=13、总结><a class=headerlink href=#13、总结 title=13、总结></a>13、总结</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line>1）、Spring容器启动时，会先保存所有Bean定义信息；</span><br><span class=line>	1）、xml注册bean；&LTbean></span><br><span class=line>	2）、注解注册Bean；@Service、@Component、@Bean、xxx</span><br><span class=line>2）、Spring容器会在合适时机创建Bean</span><br><span class=line>	1）、用到某个bean时，用getBean创建bean，建好以后保存在容器中；</span><br><span class=line>	2）、统一创建剩下的所有bean：inishBeanFactoryInitialization()；</span><br><span class=line>3）、后置处理器；BeanPostProcessor</span><br><span class=line>	1）、每一个bean创建完成，都会使用各种后置处理器进行处理；来增强bean的功能；</span><br><span class=line>		AutowiredAnnotationBeanPostProcessor:处理自动注入</span><br><span class=line>		AnnotationAwareAspectJAutoProxyCreator:来做AOP功能；</span><br><span class=line>		xxx....</span><br><span class=line>		增强的功能注解：</span><br><span class=line>		AsyncAnnotationBeanPostProcessor</span><br><span class=line>		....</span><br><span class=line>4）、事件驱动模型；</span><br><span class=line>	ApplicationListener；事件监听；</span><br><span class=line>	ApplicationEventMulticaster；事件派发：</span><br></pre></table></figure><h2 id=2、BeanPostProcessor与BeanFactoryPostProcessor><a class=headerlink href=#2、BeanPostProcessor与BeanFactoryPostProcessor title=2、BeanPostProcessor与BeanFactoryPostProcessor></a>2、BeanPostProcessor与BeanFactoryPostProcessor</h2><h3 id=2-1、简介><a class=headerlink href=#2-1、简介 title=2.1、简介></a>2.1、简介</h3><p><strong>BeanPostProcessor是bean后置处理器，会在bean创建过程中的初始化前后执行</strong>。<p><strong>BeanFactoryPostProcessor是beanFactory后置处理器，会在BeanFactory标准初始化之后执行</strong>，此时所有的bean定义已经保存加载到beanFactory，但还未创建bean实例。其作用就是增强扩展BeanFactory的功能；<h3 id=2-2、BeanFactoryPostProcessor原理><a class=headerlink href=#2-2、BeanFactoryPostProcessor原理 title=2.2、BeanFactoryPostProcessor原理></a>2.2、BeanFactoryPostProcessor原理</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line>1、BeanFactoryPostProcessor</span><br><span class=line>	1)、ioc容器创建对象</span><br><span class=line>    2)、invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=line>        找到所有的BeanFactoryPostProcessor并执行他们的方法：</span><br><span class=line>            1）、在BeanFactory中找到所有类型是BeanFactoryPostProcessor的组件，并执行他们的方法</span><br><span class=line>            2）、在 初始化创建其他组件前 执行。</span><br><span class=line>            </span><br><span class=line>2、BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor</span><br><span class=line>	postProcessBeanDefinitionRegistry();</span><br><span class=line>	在所有bean定义将要被加载，且bean实例还未创建时执行；</span><br><span class=line>	优先于BeanFactoryPostProcessor执行；</span><br><span class=line>	利用BeanDefinitionRegistryPostProcessor给容器中再额外添加一些组件；</span><br><span class=line>	</span><br><span class=line>原理：</span><br><span class=line>	1）、ioc创建对象</span><br><span class=line>	2）、refresh()-》invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=line>	3）、从容器中获取到所有的BeanDefinitionRegistryPostProcessor组件。</span><br><span class=line>		1、依次触发所有的postProcessBeanDefinitionRegistry()方法</span><br><span class=line>		2、再来触发postProcessBeanFactory()方法（BeanFactoryPostProcessor）；</span><br><span class=line>	4）、再来从容器中找到BeanFactoryPostProcessor组件；然后依次触发postProcessBeanFactory()方法</span><br></pre></table></figure><h2 id=3、ApplicationListener><a class=headerlink href=#3、ApplicationListener title=3、ApplicationListener></a>3、ApplicationListener</h2><h3 id=3-1、简介><a class=headerlink href=#3-1、简介 title=3.1、简介></a>3.1、简介</h3><p>监听容器中发布的事件。<code>public interface ApplicationListener&LTE extends ApplicationEvent></code>用来<br>监听 ApplicationEvent 及其子事件；<h3 id=3-2、开发步骤><a class=headerlink href=#3-2、开发步骤 title=3.2、开发步骤></a>3.2、开发步骤</h3><pre><code>1）、写一个监听器（ApplicationListener实现类）来监听某个事件（ApplicationEvent及其子类）
    @EventListener;
    原理：使用EventListenerMethodProcessor处理器来解析方法上的@EventListener；
2）、把监听器加入到容器；
3）、只要容器中有相关事件的发布，我们就能监听到这个事件；
    ContextRefreshedEvent：容器刷新完成（所有bean都完全创建）会发布这个事件；
    ContextClosedEvent：关闭容器会发布这个事件；
4）、发布一个事件：
    applicationContext.publishEvent()；
</code></pre><h3 id=3-3、原理><a class=headerlink href=#3-3、原理 title=3.3、原理></a>3.3、原理</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line>【事件发布流程】：</span><br><span class=line>1、publishEvent(new ContextRefreshedEvent(this));</span><br><span class=line>	1）、获取事件的多播器（派发器）：getApplicationEventMulticaster()</span><br><span class=line>	2）、multicastEvent派发事件：</span><br><span class=line>		1）、获取到所有的ApplicationListener，遍历每一项。</span><br><span class=line>			for (final ApplicationListener&LT?> listener : getApplicationListeners(event, type)) </span><br><span class=line>		2）、如果有Executor，使用Executor进行异步派发；</span><br><span class=line>			Executor executor = getTaskExecutor();</span><br><span class=line>		3）、否则，同步执行listener方法；invokeListener(listener, event);</span><br><span class=line>			 拿到listener回调onApplicationEvent方法；</span><br><span class=line></span><br><span class=line>【事件多播器（派发器）】</span><br><span class=line>容器创建对象：refresh();</span><br><span class=line>    1）、initApplicationEventMulticaster();初始化ApplicationEventMulticaster；</span><br><span class=line>        1）、先看容器中 是否有id=“applicationEventMulticaster”的组件；</span><br><span class=line>        2）、如果没有则创建 this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);</span><br><span class=line>        3）、将之加入到容器，后期可在其他组件要派发事件时自动注入这个applicationEventMulticaster；</span><br><span class=line></span><br><span class=line>【容器中有哪些监听器】</span><br><span class=line>容器创建对象：refresh();</span><br><span class=line>    1）、registerListeners();</span><br><span class=line>        从容器中拿到所有的监听器，把他们注册到applicationEventMulticaster中；</span><br><span class=line>        String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);</span><br><span class=line>        //将listener注册到ApplicationEventMulticaster中</span><br><span class=line>        getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class=line>	</span><br><span class=line>SmartInitializingSingleton 原理：->afterSingletonsInstantiated();</span><br><span class=line>	1）、ioc容器创建对象并refresh()；</span><br><span class=line>	2）、finishBeanFactoryInitialization(beanFactory);初始化剩下的单实例bean；</span><br><span class=line>		1）、先创建所有的单实例bean；getBean();</span><br><span class=line>		2）、获取所有创建好的单实例bean，判断是否是SmartInitializingSingleton类型的；</span><br><span class=line>			如果是就调用afterSingletonsInstantiated();</span><br></pre></table></figure><h2 id=3、组件注入><a class=headerlink href=#3、组件注入 title=3、组件注入></a>3、组件注入</h2><h3 id=3-1、注入类型><a class=headerlink href=#3-1、注入类型 title=3.1、注入类型></a>3.1、注入类型</h3><h4 id=setter注入><a class=headerlink href=#setter注入 title=setter注入></a>setter注入</h4><h4 id=构造注入><a class=headerlink href=#构造注入 title=构造注入></a>构造注入</h4><h4 id=接口注入><a class=headerlink href=#接口注入 title=接口注入></a>接口注入</h4><h4 id=注解注入><a class=headerlink href=#注解注入 title=注解注入></a>注解注入</h4><p>（1）Spring注解<ol><li><p><strong>@Autowired / @Qualifier</strong></p> <p>@Autowired默认按照类型装配注入，默认情况下它要求依赖对象必须存在，如果允许为null，可以设置它的required属性为false，如果想按照名称来注入，则需要结合@Qualifier一起使用；</p><li><p><strong>@Primary</strong></p> <p>自动装配时要使用的首选bean。</p><li><p><strong>@Import</strong></p> <p>可通过多种方式（class）导入多个组件。</p><li><p><strong>@ImportResource</strong></p> <p>通过导入bean.xml文件来注入组件。</p></ol><p>（2）Java注解<ol><li><strong>@Resource（JSR 250）</strong></ol><p>@Resource默认按照名称注入，只有找不到与名称匹配的bean时才会按照类型来注入；<ol start=2><li><p><strong>@Inject（JSR 330）</strong></p> <p>需要导入javax.inject包，和Autowired的功能一样。没有required=false的功能；</p></ol><h4 id=文件属性注入><a class=headerlink href=#文件属性注入 title=文件属性注入></a>文件属性注入</h4><ul><li><p><strong>@PropertySource(value = {“jdbc.properties”})</strong></p> <p>加载properties文件中配置的以 db 开头的属性配置信息，并会自动赋值给变量。</p><li><p><strong>@ConfigurationProperties(prefix = “db”) + @EnableConfigurationProperties(xxx.class)</strong></p> <p>xxx类上需要加注解<code>@ConfigurationProperties(prefix = "db")</code>，然后在配置类中加注解<code>@EnableConfigurationProperties(xxx.class)</code>来开启属性填充配置。这样会将文件配置信息赋值给变量。</p></ul><h3 id=3-2、Autowired注解><a class=headerlink href=#3-2、Autowired注解 title=3.2、Autowired注解></a>3.2、Autowired注解</h3><p>@Autowired相关类架构如下所示：<p><img alt=image-20210320173030372 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210320173030372.png><h2 id=4、循环依赖><a class=headerlink href=#4、循环依赖 title=4、循环依赖></a>4、循环依赖</h2><h3 id=4-1、前言><a class=headerlink href=#4-1、前言 title=4.1、前言></a>4.1、前言</h3><p>创建Spring bean本质上是创建对象，一个完整对象包含两部分：<strong>对象实例化和对象属性初始化</strong>。<p>Spring Bean的创建分为三步：<ol><li><strong>实例化</strong>：对应方法 AbstractAutowireCapableBeanFactory中的createBeanInstance方法。<li><strong>属性注入</strong>：对应方法 AbstractAutowireCapableBeanFactory的populateBean方法。<li><strong>初始化</strong>：对应方法 AbstractAutowireCapableBeanFactory的initializeBean方法。</ol><p><strong>Spring Bean通过 反射 实现序列化，对象属性在 对象实例化后 设置</strong>。<h3 id=4-2、循环依赖问题><a class=headerlink href=#4-2、循环依赖问题 title=4.2、循环依赖问题></a>4.2、循环依赖问题</h3><p>循环依赖的产生可能有多种情况，例如：<ul><li>A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象。<li>A的构造方法中依赖了B的实例对象，同时B的某个field或者setter需要A的实例对象，以及反之。<li>A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象，以及反之。</ul><p>以 第三种为例 来 分析：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">A</span> {</span><br><span class=line>    <span class=keyword>private</span> B b;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setB</span><span class=params>(B b)</span> {</span><br><span class=line>        <span class=built_in>this</span>.b = b;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line>---</span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">B</span> {</span><br><span class=line>  <span class=keyword>private</span> A a;</span><br><span class=line>  <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setA</span><span class=params>(A a)</span> {</span><br><span class=line>    <span class=built_in>this</span>.a = a;</span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>首先，Spring实例化bean是通过ApplicationContext.getBean()方法触发开启</strong>。<p>如果 所需对象 依赖 另一对象，那么会先创建所需对象，然后递归调用<code>ApplicationContext.getBean()</code>来获取依赖对象，然后将依赖对象注入当前所需对象。<p>以先初始化对象A为例，Spring执行逻辑如下：<ol><li>首先Spring尝试通过ApplicationContext.getBean()方法 获取A对象实例，由于Spring容器中还没有A对象实例，因此会去创建一个A对象。创建A对象的过程中发现依赖了B对象，然后通过ApplicationContext.getBean()方法获取B对象实例。但此时Spring容器中没有B对象实例，因此会先创建一个B对象的实例。<li>Spring创建B对象之后，发现B对象依赖了A对象实例，故调用ApplicationContext.getBean()方法获取A对象实例。因为Spring中已经有了A对象实例，虽然只是半成品（其属性b还未初始化），但也是目标bean，故会将该A对象实例返回。此时，B对象的属性a就设置进去了，然后将B对象实例返回，并设置到A对象的属性b中，最终完成对象A和对象B的实例化。</ol><h3 id=4-3、解决循环依赖><a class=headerlink href=#4-3、解决循环依赖 title=4.3、解决循环依赖></a>4.3、解决循环依赖</h3><p><strong>单例对象在IOC容器生命周期内只有一个实例，为解决 单例 循环依赖问题，可以使用三级缓存</strong>（DefaultSingletonBeanRegistry.java中定义）。<p>三级缓存源码定义如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>/** 一级缓存 - 存放完整的Bean，直接可以使用。 */</span></span><br><span class=line><span class=keyword>private</span> <span class=keyword>final</span> Map&LTString, Object> singletonObjects = <span class=keyword>new</span> <span class="title class_">ConcurrentHashMap</span>&LTString, Object>(<span class=number>256</span>);</span><br><span class=line><span class=comment>/** 二级缓存 - 存放早期Bean的引用，Bean的属性还没有初始化。 */</span></span><br><span class=line><span class=keyword>private</span> <span class=keyword>final</span> Map&LTString, Object> earlySingletonObjects = <span class=keyword>new</span> <span class="title class_">HashMap</span>&LTString, Object>(<span class=number>16</span>);</span><br><span class=line><span class=comment>/** 三级缓存 - 存放实例化完成的Bean工厂。 */</span></span><br><span class=line><span class=keyword>private</span> <span class=keyword>final</span> Map&LTString, ObjectFactory&LT?>> singletonFactories = <span class=keyword>new</span> <span class="title class_">HashMap</span>&LTString, ObjectFactory&LT?>>(<span class=number>16</span>);</span><br></pre></table></figure><p>Spring首先从一级缓存<strong>singletonObjects</strong>中获取，如果获取不到，且对象正在创建中，就会从二级缓存<strong>earlySingletonObjects</strong>中获取，如果还是获取不到且允许通过<strong>调用 <code>singletonFactories</code> 的 <code>getObject()</code>方法获取</strong>，那就从三级缓存获取，<strong>如果获取到了，那就放入二级缓存，并将三级缓存中的删除</strong>。具体逻辑如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=meta>@Nullable</span></span><br><span class=line><span class=keyword>protected</span> Object <span class="title function_">getSingleton</span><span class=params>(String beanName, <span class=type>boolean</span> allowEarlyReference)</span> {</span><br><span class=line>    <span class=comment>// Quick check for existing instance without full singleton lock</span></span><br><span class=line>    <span class=type>Object</span> <span class=variable>singletonObject</span> <span class=operator>=</span> <span class=built_in>this</span>.singletonObjects.get(beanName);</span><br><span class=line>    <span class=keyword>if</span> (singletonObject == <span class=literal>null</span> && isSingletonCurrentlyInCreation(beanName)) {</span><br><span class=line>        singletonObject = <span class=built_in>this</span>.earlySingletonObjects.get(beanName);</span><br><span class=line>        <span class=keyword>if</span> (singletonObject == <span class=literal>null</span> && allowEarlyReference) {</span><br><span class=line>            <span class=keyword>synchronized</span> (<span class=built_in>this</span>.singletonObjects) {</span><br><span class=line>                <span class=comment>// Consistent creation of early reference within full singleton lock</span></span><br><span class=line>                singletonObject = <span class=built_in>this</span>.singletonObjects.get(beanName);</span><br><span class=line>                <span class=keyword>if</span> (singletonObject == <span class=literal>null</span>) {</span><br><span class=line>                    singletonObject = <span class=built_in>this</span>.earlySingletonObjects.get(beanName);</span><br><span class=line>                    <span class=keyword>if</span> (singletonObject == <span class=literal>null</span>) {</span><br><span class=line>                        ObjectFactory&LT?> singletonFactory = <span class=built_in>this</span>.singletonFactories.get(beanName);</span><br><span class=line>                        <span class=keyword>if</span> (singletonFactory != <span class=literal>null</span>) {</span><br><span class=line>                            singletonObject = singletonFactory.getObject();</span><br><span class=line>                            <span class=built_in>this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class=line>                            <span class=built_in>this</span>.singletonFactories.remove(beanName);</span><br><span class=line>                        }</span><br><span class=line>                    }</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> singletonObject;</span><br><span class=line>}</span><br></pre></table></figure><p><strong>Spring解决循环依赖的诀窍就在于三级缓存——singletonFactories。这个cache类型是接口ObjectFactory。</strong>这个接口在下面代码中被引用：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>protected</span> <span class=keyword>void</span> <span class="title function_">addSingletonFactory</span><span class=params>(String beanName, ObjectFactory&LT?> singletonFactory)</span> {</span><br><span class=line>    Assert.notNull(singletonFactory, <span class=string>"Singleton factory must not be null"</span>);</span><br><span class=line>    <span class=keyword>synchronized</span> (<span class=built_in>this</span>.singletonObjects) {</span><br><span class=line>        <span class=keyword>if</span> (!<span class=built_in>this</span>.singletonObjects.containsKey(beanName)) {</span><br><span class=line>            <span class=built_in>this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class=line>            <span class=built_in>this</span>.earlySingletonObjects.remove(beanName);</span><br><span class=line>            <span class=built_in>this</span>.registeredSingletons.add(beanName);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>上面代码是解决循环依赖的关键，这段代码发生在 createBeanInstance 之后，也就是说此时单例对象已经被创建出来(调用了构造器)，虽然还不完整，但是已经能被认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。<h3 id=4-4、为何需要三级缓存><a class=headerlink href=#4-4、为何需要三级缓存 title=4.4、为何需要三级缓存></a>4.4、为何需要三级缓存</h3><p>Spring处理AOP代理的规则是：<strong>通过后置处理器 <code>AnnotationAwareAspectJAutoProxyCreator</code>在Bean生命周期最后一步完成AOP代理，而并非实例化后就立马进行AOP代理</strong>。<p>如果对A进行了AOP代理，那么意味着 B对象中注入的A将是一个A的代理对象而并非A的原始对象。<p>所以，Spring定义一个缓存 <strong>singletonFactories</strong> 来存放Bean工厂对象ObjectFactory。该工厂对象的作用是<strong>延迟实例化阶段对象代理的生成，而只有真正发生循环依赖时才会生成代理对象，否则只会创建一个工厂对象并放入到三级缓存中</strong>。<p>注意事项：<ol><li><strong>如果A被代理了，但没有发生循环依赖。那么依然会将其添加到三级缓存中。</strong><li><strong>如果使用二级缓存，那么Bean实例化后会立即创建代理。这样做也就违背了Spring在Bean生命周期最后完成AOP代理的设计。</strong></ol><h3 id=4-5、三级缓存会提高效率吗？><a class=headerlink href=#4-5、三级缓存会提高效率吗？ title=4.5、三级缓存会提高效率吗？></a>4.5、三级缓存会提高效率吗？</h3><p>不会提高，下面分两种场景来讨论。<ul><li><p>场景一：没有AOP代理的循环依赖</p> <p>该情况下三级缓存根本没用，所以不存在提高效率。</p><li><p>场景二：存在AOP代理的循环依赖</p> <ul><li>如果使用三级缓存，那么只会在B依赖A时才会为A创建代理。<li>如果不使用三级缓存，则会在A实例化后立即为A创建代理，并将代理放入二级缓存。</ul></ul><h3 id=4-6、总结><a class=headerlink href=#4-6、总结 title=4.6、总结></a>4.6、总结</h3><p><strong>如果使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样就违背了Spring设计原则</strong>。（Spring的设计规则就是通过后置处理器<code>AnnotationAwareAspectJAutoProxyCreator</code>在Bean生命周期最后一步完成AOP代理，而并非是在实例化后来执行AOP代理。）<h1 id=AOP（切面编程）><a class=headerlink href=#AOP（切面编程） title=AOP（切面编程）></a>AOP（切面编程）</h1><h2 id=2、AOP动态代理><a class=headerlink href=#2、AOP动态代理 title=2、AOP动态代理></a>2、AOP动态代理</h2><h3 id=2-1、简介-1><a class=headerlink href=#2-1、简介-1 title=2.1、简介></a>2.1、简介</h3><p>切面编程是指<strong>程序运行期间在指定方法的指定位置动态植入增强逻辑的编程方式。</strong><h3 id=2-2、代码实现><a class=headerlink href=#2-2、代码实现 title=2.2、代码实现></a>2.2、代码实现</h3><ol><li>导入aop模块；Spring AOP：(spring-aspects)<li>定义一个业务逻辑类（MathCalculator）；在业务逻辑运行的时候将日志进行打印（方法之前、方法运行结束、方法出现异常，xxx）<li>定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知MathCalculator.div运行到哪里然后执行；<ul><li>前置通知(@Before)：logStart：在目标方法(div)运行之前运行<li>后置通知(@After)：logEnd：在目标方法(div)运行结束之后运行（无论方法正常结束还是异常结束）<li>返回通知(@AfterReturning)：logReturn：在目标方法(div)正常返回之后运行<li>异常通知(@AfterThrowing)：logException：在目标方法(div)出现异常以后运行<li>环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()）</ul><li>给切面类的目标方法标注何时何地运行（通知注解）；<li>将切面类和业务逻辑类（目标方法所在类）都加入到容器中;<li>必须告诉Spring哪个类是切面类（给切面类上加一个注解：@Aspect）<li>给配置类中加 @EnableAspectJAutoProxy 【开启基于注解的aop模式】</ol><h2 id=3、AOP原理><a class=headerlink href=#3、AOP原理 title=3、AOP原理></a>3、AOP原理</h2><h3 id=3-1、-EnableAspectJAutoProxy><a class=headerlink href=#3-1、-EnableAspectJAutoProxy title=3.1、@EnableAspectJAutoProxy></a>3.1、@EnableAspectJAutoProxy</h3><p>@EnableAspectJAutoProxy是什么？<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line>1、@Import(AspectJAutoProxyRegistrar.class)：给容器中导入AspectJAutoProxyRegistrar</span><br><span class=line>   利用AspectJAutoProxyRegistrar自定义给容器中注册bean；BeanDefinetion</span><br><span class=line>   internalAutoProxyCreator=AnnotationAwareAspectJAutoProxyCreator</span><br><span class=line>   给容器中注册一个AnnotationAwareAspectJAutoProxyCreator；</span><br><span class=line>2、AnnotationAwareAspectJAutoProxyCreator：</span><br><span class=line>     AnnotationAwareAspectJAutoProxyCreator</span><br><span class=line>     	->AspectJAwareAdvisorAutoProxyCreator</span><br><span class=line>     		->AbstractAdvisorAutoProxyCreator</span><br><span class=line>     			->AbstractAutoProxyCreator</span><br><span class=line>     				implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware</span><br><span class=line>     				关注后置处理器（在bean初始化完成前后做事情）、自动装配BeanFactory</span><br><span class=line></span><br><span class=line>AbstractAutoProxyCreator.setBeanFactory()</span><br><span class=line>AbstractAutoProxyCreator.有后置处理器的逻辑；</span><br><span class=line>AbstractAdvisorAutoProxyCreator.setBeanFactory()-》initBeanFactory()</span><br><span class=line>AnnotationAwareAspectJAutoProxyCreator.initBeanFactory()</span><br></pre></table></figure><h3 id=3-2、流程><a class=headerlink href=#3-2、流程 title=3.2、流程></a>3.2、流程</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br></pre><td class=code><pre><span class=line>1）、传入配置类，创建ioc容器</span><br><span class=line>2）、注册配置类，调用refresh（）刷新容器；</span><br><span class=line>3）、registerBeanPostProcessors(beanFactory);注册bean后置处理器来拦截bean的创建；</span><br><span class=line>  	1）、先获取ioc容器已经定义了的需要创建对象的所有BeanPostProcessor</span><br><span class=line>  	2）、给容器中注册其它BeanPostProcessor。</span><br><span class=line>  	3）、优先注册实现了PriorityOrdered接口的BeanPostProcessor；</span><br><span class=line>  	4）、再注册实现了Ordered接口的BeanPostProcessor；</span><br><span class=line>  	5）、再注册没有实现任何优先级接口的BeanPostProcessor；</span><br><span class=line>  	6）、注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象并注入到容器中；</span><br><span class=line>  			创建internalAutoProxyCreator的BeanPostProcessor【AnnotationAwareAspectJAutoProxyCreator】</span><br><span class=line>  			1）、创建Bean的实例</span><br><span class=line>  			2）、populateBean；给bean的各种属性赋值</span><br><span class=line>  			3）、initializeBean：初始化bean；</span><br><span class=line>  					1）、invokeAwareMethods()：处理Aware接口的方法回调</span><br><span class=line>  					2）、applyBeanPostProcessorsBeforeInitialization()：应用后置处理器的postProcessBeforeInitialization（）</span><br><span class=line>  					3）、invokeInitMethods()；执行自定义的初始化方法</span><br><span class=line>  					4）、applyBeanPostProcessorsAfterInitialization()；执行后置处理器的postProcessAfterInitialization（）；</span><br><span class=line>  			4）、BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；--》aspectJAdvisorsBuilder</span><br><span class=line>  	7）、把BeanPostProcessor注册到BeanFactory中；</span><br><span class=line>  		beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class=line></span><br><span class=line>=====以上是创建和注册AnnotationAwareAspectJAutoProxyCreator的过程====</span><br><span class=line></span><br><span class=line>  	   AnnotationAwareAspectJAutoProxyCreator => InstantiationAwareBeanPostProcessor</span><br><span class=line>4）、finishBeanFactoryInitialization(beanFactory);完成BeanFactory初始化工作；创建剩下的单实例bean</span><br><span class=line>  	1）、遍历获取容器中所有的Bean，依次创建对象getBean(beanName);</span><br><span class=line>  		getBean->doGetBean()->getSingleton()-></span><br><span class=line>  	2）、执行 创建bean 逻辑</span><br><span class=line>  		【AnnotationAwareAspectJAutoProxyCreator在所有bean创建之前会有一个拦截，InstantiationAwareBeanPostProcessor会调用postProcessBeforeInstantiation()】</span><br><span class=line>  		1）、先从缓存中获取当前bean，如果能获取到，说明bean是之前被创建过的，直接使用，否则再创建；只要创建好的Bean都会被缓存起来。</span><br><span class=line>  		2）、创建bean：createBean（）</span><br><span class=line>  			AnnotationAwareAspectJAutoProxyCreator 会在任何bean创建之前先尝试返回bean的实例</span><br><span class=line>  			【BeanPostProcessor是在Bean对象创建完成后的初始化前后调用的】</span><br><span class=line>  			【InstantiationAwareBeanPostProcessor是在创建Bean实例之前先尝试用后置处理器返回对象】</span><br><span class=line>  			1）、resolveBeforeInstantiation(beanName, mbdToUse);解析BeforeInstantiation</span><br><span class=line>  				希望后置处理器在此能返回一个代理对象；如果能返回代理对象就使用，如果不能就继续</span><br><span class=line>  				1）、后置处理器先尝试返回对象；</span><br><span class=line>  					bean = applyBeanPostProcessorsBeforeInstantiation（）：</span><br><span class=line>  					拿到所有后置处理器，如果是InstantiationAwareBeanPostProcessor;</span><br><span class=line>  					就执行postProcessBeforeInstantiation</span><br><span class=line>  					if (bean != null) {</span><br><span class=line>						bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class=line>					}</span><br><span class=line>  				2）、doCreateBean(beanName, mbdToUse, args);真正的去创建一个bean实例；和3.6流程一样；</span><br></pre></table></figure><h3 id=3-3、AnnotationAwareAspectJAutoProxyCreator><a class=headerlink href=#3-3、AnnotationAwareAspectJAutoProxyCreator title=3.3、AnnotationAwareAspectJAutoProxyCreator></a>3.3、AnnotationAwareAspectJAutoProxyCreator</h3><p>AnnotationAwareAspectJAutoProxyCreator底层就是一个InstantiationAwareBeanPostProcessor。<h4 id=3-3-1、bean创建前，调用postProcessBeforeInstantiation><a class=headerlink href=#3-3-1、bean创建前，调用postProcessBeforeInstantiation title=3.3.1、bean创建前，调用postProcessBeforeInstantiation()></a>3.3.1、bean创建前，调用postProcessBeforeInstantiation()</h4><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>关心MathCalculator和LogAspect的创建</span><br><span class=line>1）、判断当前bean是否在advisedBeans中（保存了所有需要增强bean）</span><br><span class=line>2）、判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean，或者是否是切面（@Aspect）</span><br><span class=line>3）、是否需要跳过</span><br><span class=line>  	1）、获取候选的增强器（切面里面的通知方法）【List&LTAdvisor> candidateAdvisors】</span><br><span class=line>  		每一个封装的通知方法的增强器是 InstantiationModelAwarePointcutAdvisor；</span><br><span class=line>  		判断每一个增强器是否是 AspectJPointcutAdvisor 类型的；返回true</span><br><span class=line>  	2）、永远返回false</span><br></pre></table></figure><h4 id=3-3-2、创建对象><a class=headerlink href=#3-3-2、创建对象 title=3.3.2、创建对象></a>3.3.2、创建对象</h4><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line>postProcessAfterInitialization；</span><br><span class=line>return wrapIfNecessary(bean, beanName, cacheKey);//包装如果需要的情况下</span><br><span class=line>1）、获取当前bean的所有增强器（通知方法）  Object[]  specificInterceptors</span><br><span class=line>  	1、找到候选的所有的增强器（找哪些通知方法是需要切入当前bean方法的）</span><br><span class=line>  	2、获取到能在bean使用的增强器。</span><br><span class=line>  	3、给增强器排序</span><br><span class=line>2）、保存当前bean在advisedBeans中；</span><br><span class=line>3）、如果当前bean需要增强，创建当前bean的代理对象；</span><br><span class=line>  	1）、获取所有增强器（通知方法）</span><br><span class=line>  	2）、保存到proxyFactory</span><br><span class=line>  	3）、创建代理对象：Spring自动决定</span><br><span class=line>  		JdkDynamicAopProxy(config);jdk动态代理；</span><br><span class=line>  		ObjenesisCglibAopProxy(config);cglib的动态代理；</span><br><span class=line>4）、给容器中返回当前组件使用cglib增强了的代理对象；</span><br><span class=line>5）、以后容器中获取到的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程；</span><br></pre></table></figure><h4 id=3-3-3、目标方法执行><a class=headerlink href=#3-3-3、目标方法执行 title=3.3.3、目标方法执行></a>3.3.3、目标方法执行</h4><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line>容器中保存了组件的代理对象（cglib增强后的对象），这个对象里面保存了详细信息（比如增强器，目标对象，xxx）；</span><br><span class=line>1）、CglibAopProxy.intercept();拦截目标方法的执行</span><br><span class=line>2）、根据ProxyFactory对象获取将要执行的目标方法拦截器链；</span><br><span class=line>  	List&LTObject> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class=line>  	1）、List&LTObject> interceptorList保存所有拦截器 5</span><br><span class=line>  		一个默认的ExposeInvocationInterceptor 和 4个增强器；</span><br><span class=line>  	2）、遍历所有的增强器，将其转为Interceptor；</span><br><span class=line>  		registry.getInterceptors(advisor);</span><br><span class=line>  	3）、将增强器转为List&LTMethodInterceptor>；</span><br><span class=line>  		如果是MethodInterceptor，直接加入到集合中</span><br><span class=line>  		如果不是，使用AdvisorAdapter将增强器转为MethodInterceptor；</span><br><span class=line>  		转换完成返回MethodInterceptor数组；</span><br><span class=line>3）、如果没有拦截器链，直接执行目标方法;</span><br><span class=line>  	拦截器链（每一个通知方法又被包装为方法拦截器，利用MethodInterceptor机制）</span><br><span class=line>4）、如果有拦截器链，把需要执行的目标对象，目标方法，拦截器链等信息传入创建一个 CglibMethodInvocation 对象，</span><br><span class=line>  	并调用 Object retVal =  cglibMehthodInvocation.proceed();</span><br><span class=line>5）、拦截器链的触发过程;</span><br><span class=line>  	1)、如果没有拦截器执行目标方法，或者拦截器的索引和拦截器数组大小一样（指定到了最后一个拦截器）执行目标方法；</span><br><span class=line>  	2)、链式获取每一个拦截器，拦截器执行invoke方法，每一个拦截器等待下一个拦截器执行完成返回以后再来执行；</span><br><span class=line>  		拦截器链的机制，保证通知方法与目标方法的执行顺序；</span><br></pre></table></figure><h3 id=3-4、总结><a class=headerlink href=#3-4、总结 title=3.4、总结></a>3.4、总结</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line>1）、@EnableAspectJAutoProxy 开启AOP功能</span><br><span class=line>2）、@EnableAspectJAutoProxy 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator</span><br><span class=line>3）、AnnotationAwareAspectJAutoProxyCreator是一个后置处理器；</span><br><span class=line>4）、容器创建流程：</span><br><span class=line>  	1）、registerBeanPostProcessors（）注册后置处理器；创建AnnotationAwareAspectJAutoProxyCreator对象</span><br><span class=line>  	2）、finishBeanFactoryInitialization（）初始化剩下的单实例bean</span><br><span class=line>  		1）、创建业务逻辑组件和切面组件</span><br><span class=line>  		2）、AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程</span><br><span class=line>  		3）、组件创建完之后，判断组件是否需要增强</span><br><span class=line>  			是：切面的通知方法，包装成增强器（Advisor）；给业务逻辑组件创建一个代理对象（cglib）；</span><br><span class=line>5）、执行目标方法：</span><br><span class=line>  	1）、代理对象执行目标方法</span><br><span class=line>  	2）、CglibAopProxy.intercept()；</span><br><span class=line>  		1）、得到目标方法的拦截器链（增强器包装成拦截器MethodInterceptor）</span><br><span class=line>  		2）、利用拦截器的链式机制，依次进入每一个拦截器进行执行；</span><br><span class=line>  		3）、效果：</span><br><span class=line>  			正常执行：前置通知-》目标方法-》后置通知-》返回通知</span><br><span class=line>  			出现异常：前置通知-》目标方法-》后置通知-》异常通知</span><br></pre></table></figure><h1 id=MVC><a class=headerlink href=#MVC title=MVC></a>MVC</h1><h2 id=1、请求匹配><a class=headerlink href=#1、请求匹配 title=1、请求匹配></a>1、请求匹配</h2><ol><li>拿到处理器执行器链：getHandler(HttpServletRequest)。<ul><li>拿到所有HandlerMapping（默认一开始时有5个），进行遍历<ul><li>拿到处理器执行器链，如果没有则返回空：mapping.getHandler(HttpServletRequest)<ul><li>基于HttpServletRequest来匹配handlerMapping（RequestMappingHadnlerMapping）<li>路径与方法的映射信息保存在RMHM.mappingRegistry.mappingLookup（LinkedHashMap）中。<li>拿到与路径<code>/xxx</code>匹配的所有映射项，如果匹配项有多个，那么报错。否则将之保存起来候用。</ul></ul></ul></ol><blockquote><p><strong>默认5个HandlerMapping</strong>：RequestMappingHadnlerMapping、WelcomePageHandlerMapping、BeanNameUril xxx、RouterFunction xxx、SimpleUrl xxx</blockquote><h2 id=2、参数解析-返回结果><a class=headerlink href=#2、参数解析-返回结果 title=2、参数解析/返回结果></a>2、参数解析/返回结果</h2><ol><li><p>从处理器执行器链中找到能处理请求的Hadnler</p><li><p>通过handler拿到对应的 处理器适配器（HandlerAdapter）</p> <p>默认适配器有4种：RequestMappingHandlerAdapter、HandlerFunction-xxx、HttpRequest-xxx、SimpleController-xxx）</p><li><p>判断请求方式（Get/POST/HEAD…）</p><li><p>调用适配器的handler()方法:ha.handler(…)</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line>执行目标方法：invokeHandlerMethod(request, response, HandlerMethod)</span><br><span class=line>	- 设置 参数解析器（ArgumentResover，默认26个）解析参数</span><br><span class=line>	  （找到匹配的解析器和参数时，会将之缓存起来，以后来请求就不要重复解析了。）</span><br><span class=line>	  - Map/Model类型的参数，会返回一个BindingAwareModelMap，它既是Mode也是Map。</span><br><span class=line>		两者都可以通过mavContainer.getModel()获取到值。</span><br><span class=line>	- 设置 返回值处理器（ReturnValueHandlers，默认15个）处理返回结果</span><br><span class=line>		- 获取返回值类型</span><br><span class=line>		- 调用handlerReturnValue(...)方法 处理返回结果。</span><br><span class=line>			- 找到能处理结果的处理器（），然后处理。</span><br><span class=line>			 （比如处理@ResponseBody返回json结果的处理器是 RequestResponseBodyMethodProcessor）</span><br><span class=line>				- 利用MessageConvert（默认10个）来处理结果</span><br><span class=line>					- 拿到spring支持的返回结果类型 和 客户端浏览器支持的 接收结果类型</span><br><span class=line>					- 拿到两者匹配兼容的转换类型，然后转换。</span><br><span class=line>					- 将转换结果 封装到 OutputMessage中，并返回。</span><br><span class=line>	- 执行目标方法：invokeAndHandler(webRequest, mavContainer)</span><br><span class=line>		- invokeForRequest(...)--->会跳到目标方法执行</span><br><span class=line>			- 获取 所有参数的值</span><br><span class=line>			- 通过 反射 调用目标方法</span><br><span class=line>	- 最终处理结果会放到 ModelAndViewContainer中，其中包含 页面 和 数据。</span><br></pre></table></figure><li><p>调用处理器执行器链的applyPostHandler()方法。</p><li><p>调用processDispatcherResult()：处理最终结果。</p><li><p>最终，将数据保存到请求域中并返回。</p></ol><h2 id=3、内容协商><a class=headerlink href=#3、内容协商 title=3、内容协商></a>3、内容协商</h2><ol><li>判断当前响应头中是否有确定的媒体类型，MediaType。<li>获取 客户端支持接收的内容类型（获取客户端Accepte请求头字段）。<li>获取 spring 可以提供的 媒体类型。<ul><li>遍历当前系统中所有的MessageConverter，拿到支持操作当前对象的MessageConverter。<li>将支持的MC的媒体类型统计出来并保存。</ul><li>进行 客户端和服务器 媒体类型 的 最佳匹配。<li>拿到 支持当前内容转换的 具体Converter，然后进行转换。</ol><h2 id=4、异常处理><a class=headerlink href=#4、异常处理 title=4、异常处理></a>4、异常处理</h2><p>ErrorMvcAutoConfiguration 自动配置异常处理规则：<ul><li>注入 DefatultErrorAttributes：定义错误页面可以包含哪些数据。<li>注入 BasicErrorController<ul><li>处理 /error 的请求（server.error.path/error.path），视图响应 ModelAndView(error)<li>组件View<li>注入组件BeanNameViewResolver，以 返回的视图名作为ID去找View对象。</ul><li>注入 DefaultErrorViewResolver<br> - 发生错误时，会以HTTP状态码 作为视图地址。（error/viewName.html）</ul><p>异常处理流程：<ol><li>目标方法执行期间，有异常时会被catch，并标记当前请求已结束，然后启用dispatchException。<li>进入视图解析逻辑。<li>执行处理器的异常并返回一个MV<ul><li>遍历所有handlerExceptionResolvers，找到可以处理当前异常的resolver。<li>遍历所有的默认异常解析器，找到可以解析当前异常的。<ul><li>DefaultErrorAttributes先处理异常，把异常保存到request域，并返回空。<li>默认没有任何组件能处理该异常，所以异常会抛出。<ul><li>如果没有人处理该异常，那么会发送 /error 请求。<li>解析错误视图，遍历 ErrorViewResolver，找到可以解析的resolver，然后解析。</ul></ul><li>封装错误视图，并返回。</ul></ol><h2 id=5、总结><a class=headerlink href=#5、总结 title=5、总结></a>5、总结</h2><h3 id=5-1、初始化阶段><a class=headerlink href=#5-1、初始化阶段 title=5.1、初始化阶段></a>5.1、初始化阶段</h3><ol><li>首次用到<code>DispatcherServlet</code>时，会初始化Web容器 WebApplicationContext。然后调用 onRefresh() 方法刷新 WebApplicationContext。<li>刷新过程会初始化一些重要组件（9个）：MultipartResolver、LocaleResolver、ThemeResolver、HandlerMapping、HandlerAdapters、HandlerExceptionResolvers、RequestToViewNameTranslator、ViewResolvers、FlashMapManager。<li>将初始化好后的组件赋值给DispatcherServlet，留待后用。</ol><h3 id=5-2、匹配阶段><a class=headerlink href=#5-2、匹配阶段 title=5.2、匹配阶段></a>5.2、匹配阶段</h3><ol><li>用户请求首先被DispatcherServlet拦截。<li>DispatcherServlet遍历所有HandlerMapping，找到与请求匹配的处理器。<ol><li><code>HandlerMapping</code>有多个，不同的<code>HandlerMapping</code>对应有不同的处理器对象。请求路径与处理器的映射在HandlerMapping初始化期间就已经被设置好。<li><code>@RequestMapping</code>注解优先级较高会被优先匹配到，其对应的处理器是<code>HandlerMethod</code>，该处理器包含 控制器对象 和 控制器方法 等信息。</ol><li>将<code>HandlerMethod</code>和 拦截器 封装成 处理执行器链<code>HandlerExecutionChain</code>。<li>找到可以处理当前<code>HandlerMethod</code>的适配器对象<code>HandlerAdapter</code>，通过该 适配器对象 来处理请求。</ol><h3 id=5-3、执行阶段><a class=headerlink href=#5-3、执行阶段 title=5.3、执行阶段></a>5.3、执行阶段</h3><ol><li><p>执行拦截器的<code>preHandler()</code>方法。</p><li><p>通过<code>HandlerAdapter</code>调用<code>HandlerMethod</code></p> <ol><li><p>调用前处理请求参数</p> <p>提取Request中的模型数据，填充Handler入参：</p> <ul><li>数据转换：如 String 转 Integer、Double等。<li>数据格式化：如 将 字符串 转为 格式化数字 或 日期 等。<li>数据验证：验证数据的有效性（长度、格式），验证结果存储到<code>BindingResult</code>或<code>Error</code>中。</ul><li><p>开始执行Handler（Controller）方法处理请求</p><li><p>处理返回值。如果控制器标注了ResponseBody注解，那么会生成json结果，并标记ModelAndView已经处理，这样就不再走视图渲染流程。</p></ol><li><p>若返回的视图不存在，则创建保存一个默认视图，若存在则继续执行。</p><li><p>执行拦截器<code>postHandler</code>方法</p><li><p>处理返回结果</p> <ul><li>执行流程中有异常会进入<code>HandlerExceptionResolver</code>异常处理流程。<li>没有异常会执行下列操作：<ol><li>拿到<code>ModelAndView</code>对象。<li>通过<code>ViewResolver</code>来解析视图，根据Model和View 来渲染视图。</ol><li>执行拦截器的<code>afterCompletion</code>方法。</ul><li><p>将渲染结果返回给客户端。</p></ol><h1 id=Transaction（事务）><a class=headerlink href=#Transaction（事务） title=Transaction（事务）></a>Transaction（事务）</h1><h2 id=1、环境搭建><a class=headerlink href=#1、环境搭建 title=1、环境搭建></a>1、环境搭建</h2><p>（1）导入相关依赖：数据源、数据库驱动、Spring-jdbc模块<p>（2）配置数据源、JdbcTemplate（Spring提供的简化数据库操作的工具）操作数据<p>（3）给方法上标注 @Transactional 表示当前方法是一个事务方法；<p>（4）@EnableTransactionManagement 开启基于注解的事务管理功能；@EnableXXX<p>（5）配置事务管理器来控制事务;<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class=params>()</span></span><br></pre></table></figure><h2 id=2、原理><a class=headerlink href=#2、原理 title=2、原理></a>2、原理</h2><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line>1）、@EnableTransactionManagement</span><br><span class=line>	利用TransactionManagementConfigurationSelector给容器中导入两个组件</span><br><span class=line>		AutoProxyRegister</span><br><span class=line>		ProxyTransactionManagementConfiguration</span><br><span class=line></span><br><span class=line>2）、AutoProxyRegistrar：</span><br><span class=line>	给容器中注册一个 InfrastructureAdvisorAutoProxyCreator 组件；</span><br><span class=line>	InfrastructureAdvisorAutoProxyCreator：？</span><br><span class=line>	利用后置处理器机制在对象创建以后，包装对象，返回一个代理对象（增强器），代理对象执行方法利用拦截器链进行调用；</span><br><span class=line></span><br><span class=line>3）、ProxyTransactionManagementConfiguration 做了什么？</span><br><span class=line>	1、给容器中注册事务增强器；</span><br><span class=line>		1）、事务增强器要用事务注解的信息，AnnotationTransactionAttributeSource解析事务注解</span><br><span class=line>		2）、事务拦截器：TransactionInterceptor；保存了事务属性、事务管理器信息；底层是MethodInterceptor；</span><br><span class=line>			在目标方法执行的时执行拦截器链；</span><br><span class=line>				事务拦截器：</span><br><span class=line>					1）、先获取事务相关的属性</span><br><span class=line>					2）、再获取PlatformTransactionManager，如果事先没有添加指定任何transactionmanger，最终会从容器中按照类型获取一个PlatformTransactionManager；</span><br><span class=line>					3）、执行目标方法</span><br><span class=line>						如果异常，获取到事务管理器，利用事务管理回滚操作；</span><br><span class=line>						如果正常，利用事务管理器，提交事务</span><br></pre></table></figure><h1 id=XML配置原理解析><a class=headerlink href=#XML配置原理解析 title=XML配置原理解析></a>XML配置原理解析</h1><p>以自定义标签<code>&LThaoge:haoge-driver /></code>为例进行分析。<p>要想使得spring配置文件中的标签生效，需要满足以下几点：<ol><li><strong>创建命名空间对应的xsd文件</strong>。比如context的xsd文件<code>org.springframework.context.config.spring-context.xsd</code><li><strong>创建命名空间处理器处理指定的命名空间</strong>。比如<code>context</code>命名空间；<li><strong>创建命名空间下各个标签的解析器，解析标签使其生效</strong>。比如解析<code>&LTcontext:component-scan base-package="xxx"/></code>标签；</ol><h2 id=1-1、创建并配置xsd文件><a class=headerlink href=#1-1、创建并配置xsd文件 title=1.1、创建并配置xsd文件></a>1.1、创建并配置xsd文件</h2><p>在路径<code>resources/cn/shh/spring/haoge/config</code>下创建文件<code>spring-haoge.xsd</code>，文件内容如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>xsd:schema</span> <span class=attr>xmlns</span>=<span class=string>"http://www.shihaohan.com/schema/haoge"</span></span></span><br><span class=line><span class=tag>		<span class=attr>xmlns:xsd</span>=<span class=string>"http://www.w3.org/2001/XMLSchema"</span></span></span><br><span class=line><span class=tag>		<span class=attr>targetNamespace</span>=<span class=string>"http://www.shihaohan.com/schema/haoge"</span>></span></span><br><span class=line></span><br><span class=line>	<span class=tag><<span class=name>xsd:element</span> <span class=attr>name</span>=<span class=string>"haoge-driver"</span>></span><span class=tag>&LT/<span class=name>xsd:element</span>></span></span><br><span class=line></span><br><span class=line><span class=tag>&LT/<span class=name>xsd:schema</span>></span></span><br></pre></table></figure><h2 id=1-2、创建spring-schemas文件><a class=headerlink href=#1-2、创建spring-schemas文件 title=1.2、创建spring.schemas文件></a>1.2、创建spring.schemas文件</h2><p>在路径<code>resources/META-INF</code>下创建<code>spring.schemas</code>文件，文件内容如下：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>http\://www.shihaohan.com/schema/haoge/spring-haoge.xsd</span>=<span class=string>cn.shh.spring.haoge.config/spring-haoge.xsd</span></span><br></pre></table></figure><h2 id=1-3、创建命名空间处理器><a class=headerlink href=#1-3、创建命名空间处理器 title=1.3、创建命名空间处理器></a>1.3、创建命名空间处理器</h2><p>创建Java类<code>HaogeNamespaceHandler</code>来处理命令自定义空间<code>haoge</code>，详细内容如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">HaogeNamespaceHandler</span> <span class=keyword>extends</span> <span class="title class_">NamespaceHandlerSupport</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">init</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>this</span>.registerBeanDefinitionParser(<span class=string>"haoge-driver"</span>, <span class=keyword>new</span> <span class="title class_">HaogeDriverBeanDefinitionParser</span>());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>创建Java类<code>HaogeDriverBeanDefinitionParser</code>来解析处理标签<code>haoge-driver</code>，该标签的功能就是向容器中注入一个<code>HaogeBeanPostProcessor</code>，详细内容如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">HaogeDriverBeanDefinitionParser</span> <span class=keyword>implements</span> <span class="title class_">BeanDefinitionParser</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> BeanDefinition <span class="title function_">parse</span><span class=params>(Element element, ParserContext parserContext)</span> {</span><br><span class=line>        <span class=type>RootBeanDefinition</span> <span class=variable>beanDefinition</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">RootBeanDefinition</span>();</span><br><span class=line>        beanDefinition.setBeanClassName(<span class=string>"cn.shh.demo.spring.ioc.customenamespace.HaogeBeanPostProcessor"</span>);</span><br><span class=line>        parserContext.getRegistry().registerBeanDefinition(<span class=string>"haogeBeanPostProcessor"</span>, beanDefinition);</span><br><span class=line>        <span class=keyword>return</span> beanDefinition;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>//================================</span></span><br><span class=line><span class=meta>@Slf4j</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">HaogeBeanPostProcessor</span> <span class=keyword>implements</span> <span class="title class_">BeanPostProcessor</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class=params>(Object bean, String beanName)</span> <span class=keyword>throws</span> BeansException {</span><br><span class=line>        log.info(<span class=string>"HaogeBeanPostProcessor.postProcessBeforeInitialization"</span>);</span><br><span class=line>        <span class=keyword>return</span> bean;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class=params>(Object bean, String beanName)</span> <span class=keyword>throws</span> BeansException {</span><br><span class=line>        log.info(<span class=string>"HaogeBeanPostProcessor.postProcessAfterInitialization"</span>);</span><br><span class=line>        <span class=keyword>return</span> bean;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=1-4、创建spring-handlers文件><a class=headerlink href=#1-4、创建spring-handlers文件 title=1.4、创建spring.handlers文件></a>1.4、创建spring.handlers文件</h2><p>在路径<code>resources/META-INF</code>下创建<code>spring.handlers</code>文件，文件内容如下：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>http\://www.shihaohan.com/schema/haoge</span>=<span class=string>cn.shh.demo.spring.ioc.customenamespace.HaogeNamespaceHandler</span></span><br></pre></table></figure><h2 id=1-5、测试效果><a class=headerlink href=#1-5、测试效果 title=1.5、测试效果></a>1.5、测试效果</h2><p>在spring配置文件中编写自定义标签：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>	   <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>	   <span class=attr>xmlns:haoge</span>=<span class=string>"http://www.shihaohan.com/schema/haoge"</span></span></span><br><span class=line><span class=tag>	   <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>	                       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>						   http://www.shihaohan.com/schema/haoge</span></span></span><br><span class=line><span class=string><span class=tag>	                       http://www.shihaohan.com/schema/haoge/spring-haoge.xsd"</span>></span></span><br><span class=line></span><br><span class=line>	<span class=comment>&LT!--扫描到该标签会向容器中注入一个HaogeBeanPostProcessor--></span></span><br><span class=line>	<span class=tag><<span class=name>haoge:haoge-driver</span> ></span><span class=tag>&LT/<span class=name>haoge:haoge-driver</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure><p>在Java的main方法中扫描spring配置文件，检测自定义标签功能是否实现。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">App</span> {</span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>		<span class=type>ApplicationContext</span> <span class=variable>context</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class=string>"beans.xml"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 如果打印结果中出现如下信息，则表示自定义标签成功。</span></span><br><span class=line>HaogeBeanPostProcessor.postProcessBeforeInitialization</span><br><span class=line>HaogeBeanPostProcessor.postProcessAftereforeInitialization</span><br></pre></table></figure><h1 id=Spring整合MyBatis><a class=headerlink href=#Spring整合MyBatis title=Spring整合MyBatis></a>Spring整合MyBatis</h1><h2 id=1-1、概述><a class=headerlink href=#1-1、概述 title=1.1、概述></a>1.1、概述</h2><p>Spring整合MyBatis的底层原理由以下4个类完成：<ul><li>SqlSessionFactoryBean<li>MapperScannerConfigurer<li>MapperFactoryBean<li>ClassPathMapperScanner</ul><h2 id=1-2、流程分析><a class=headerlink href=#1-2、流程分析 title=1.2、流程分析></a>1.2、流程分析</h2><p><strong>（1）通过<code>SqlSessionFactoryBean</code>创建<code>SqlSessionFactory</code></strong><p><code>SqlSessionFactoryBean</code>实现了<code>InitializingBean</code>的<code>afterPropertiesSet()</code>方法，会在该方法中构建<code>SqlSessionFactory</code>。<p><code>SqlSessionFactoryBean</code>实现了<code>FactoryBean</code>的<code>getObject()</code>方法，在该方法中获取构建好的<code>SqlSessionFactory</code>。<p><strong>（2）通过MapperScannerConfigurer扫描Mapper，将其包装成MapperFactoryBean</strong><p><code>MapperScannerConfigurer</code>实现了<code>BeanDefinitionRegistryPostProcessor</code>的<code>postProcessBeanDefinitionRegistry</code>方法，在该方法中通过<code>ClassPathMapperScanner</code>的<code>scan</code>方法来扫描并包装Mapper。<p><code>ClassPathMapperScanner</code>通过调用父类<code>ClassPathBeanDefinitionScanner</code>的<code>doScan</code>方法将所有Mapper的Bean定义信息放到容器中并返回给<code>ClassPathMapperScanner</code>。<p><code>ClassPathMapperScanner</code>通过调用自己<code>processBeanDefinitions(beanDefinitions)</code>方法对每一个Mapper的Beean定义信息进行配置，将每一个Mapper包装成一个<code>MapperFactoryBean</code>。<p><code>MapperFactoryBean</code>实现了<code>FactoryBean</code>的<code>getObject()</code>方法，在该方法中通过<code>SqlSession</code>获取Mapper。在获取Mapper时会通过<code>MapperProxyFactory</code>的<code>newInstance(mapperProxy)</code>方法并<strong>使用JDK代理</strong>为当前Mapper创建代理对象，所以这里获取的Mapper是代理对象，而并非是原始Mapper。<h1 id=Spring工具类><a class=headerlink href=#Spring工具类 title=Spring工具类></a>Spring工具类</h1><h2 id=1-1、PropertiesLoaderUtils><a class=headerlink href=#1-1、PropertiesLoaderUtils title=1.1、PropertiesLoaderUtils></a>1.1、PropertiesLoaderUtils</h2></div><footer class=post-footer><div class=post-tags><a href=/tags/Spring/ rel=tag># Spring</a><a href=/tags/Spring%E5%8E%9F%E7%90%86/ rel=tag># Spring原理</a></div><div class=post-nav><div class=post-nav-item><a href=/2024/08/21/TCP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ rel=prev title=计算机系列-TCP基础知识> <i class="fa fa-angle-left"></i> 计算机系列-TCP基础知识 </a></div><div class=post-nav-item><a href=/2024/08/21/Tomcat%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/ rel=next title=Tomcat系列-Tomcat基础> Tomcat系列-Tomcat基础 <i class="fa fa-angle-right"></i> </a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script>