<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hshz21.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="1、服务注册1.1、客户端12345678910111213141516171819- SPring启动时 加载 自动配置类 NacosServiceRegistryAutoConfiguration- 注入 return new NacosAutoServiceRegistration(...)	- 其父类 AbstractAutoServiceRegistration 也被初始化了		- 实现" name=description><meta content=article property=og:type><meta content=Nacos系列-Nacos原理解析 property=og:title><meta content=https://hshz21.gitee.io/2024/08/21/Nacos%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content="1、服务注册1.1、客户端12345678910111213141516171819- SPring启动时 加载 自动配置类 NacosServiceRegistryAutoConfiguration- 注入 return new NacosAutoServiceRegistration(...)	- 其父类 AbstractAutoServiceRegistration 也被初始化了		- 实现" property=og:description><meta content=zh_CN property=og:locale><meta content=2024-08-21T13:39:14.187Z property=article:published_time><meta content=2023-10-02T07:52:48.553Z property=article:modified_time><meta content=豪哥 property=article:author><meta content=Nacos property=article:tag><meta content=Nacos原理 property=article:tag><meta content=summary name=twitter:card><link href=https://hshz21.gitee.io/2024/08/21/Nacos%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hshz21.gitee.io/2024/08/21/Nacos%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","path":"2024/08/21/Nacos底层原理/","title":"Nacos系列-Nacos原理解析"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>Nacos系列-Nacos原理解析 | 豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>豪哥博客</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#1%E3%80%81%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C><span class=nav-number>1.</span> <span class=nav-text>1、服务注册</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF><span class=nav-number>1.1.</span> <span class=nav-text>1.1、客户端</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-2%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF><span class=nav-number>1.2.</span> <span class=nav-text>1.2、服务端</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-3%E3%80%81%E6%80%BB%E7%BB%93><span class=nav-number>1.3.</span> <span class=nav-text>1.3、总结</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#2%E3%80%81%E6%9C%8D%E5%8A%A1%E5%BF%83%E8%B7%B3><span class=nav-number>2.</span> <span class=nav-text>2、服务心跳</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#2-1%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF><span class=nav-number>2.1.</span> <span class=nav-text>2.1、客户端</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-2%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF><span class=nav-number>2.2.</span> <span class=nav-text>2.2、服务端</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-1%E3%80%81%E5%BC%82%E5%B8%B8%E6%A3%80%E6%9F%A5><span class=nav-number>2.2.1.</span> <span class=nav-text>2.2.1、异常检查</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-2%E3%80%81%E4%B8%BB%E5%8A%A8%E6%A3%80%E6%9F%A5><span class=nav-number>2.2.2.</span> <span class=nav-text>2.2.2、主动检查</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-3%E3%80%81%E6%80%BB%E7%BB%93><span class=nav-number>2.3.</span> <span class=nav-text>2.3、总结</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#3%E3%80%81%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0><span class=nav-number>3.</span> <span class=nav-text>3、服务发现</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#3-1%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF><span class=nav-number>3.1.</span> <span class=nav-text>3.1、客户端</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-2%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF><span class=nav-number>3.2.</span> <span class=nav-text>3.2、服务端</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-3%E3%80%81%E6%80%BB%E7%BB%93><span class=nav-number>3.3.</span> <span class=nav-text>3.3、总结</span></a></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>116</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>36</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>129</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://hshz21.gitee.io/2024/08/21/Nacos%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="Nacos系列-Nacos原理解析 | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>Nacos系列-Nacos原理解析</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 15:52:48" datetime=2023-10-02T15:52:48+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Nacos/ itemprop=url rel=index><span itemprop=name>Nacos</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、服务注册><a class=headerlink href=#1、服务注册 title=1、服务注册></a>1、服务注册</h1><h2 id=1-1、客户端><a class=headerlink href=#1-1、客户端 title=1.1、客户端></a>1.1、客户端</h2><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line>- SPring启动时 加载 自动配置类 NacosServiceRegistryAutoConfiguration</span><br><span class=line>- 注入 return new NacosAutoServiceRegistration(...)</span><br><span class=line>	- 其父类 AbstractAutoServiceRegistration 也被初始化了</span><br><span class=line>		- 实现了ApplicationListener接口，监听Spring容器启动过程中的事件</span><br><span class=line>		- 监听到 WebServerInitializedEvent（web服务初始化完成）的事件后，开启服务注册流程。</span><br><span class=line>			1、发布开始注册的事件</span><br><span class=line>			2、开始注册：register();</span><br><span class=line>			3、发布注册完成事件</span><br><span class=line>			4、服务状态设置为运行状态。</span><br><span class=line></span><br><span class=line>- 开始注册：register();</span><br><span class=line>- NacosServiceRegistry.register(Registration registration);</span><br><span class=line>	`NacosServiceRegistry`是Spring的`ServiceRegistry`接口的实现类，</span><br><span class=line>	而ServiceRegistry接口是服务注册、发现的规约接口，定义了register、</span><br><span class=line>	deregister等方法的声明。</span><br><span class=line>- NamingService.registerInstance(serviceId, group, instance);</span><br><span class=line>	NamingService接口的默认实现就是NacosNamingService。</span><br><span class=line>- NacosProxy.registerService(groupedServiceName, groupName, instance);</span><br><span class=line>	发送注册服务实例请求。发送到 /nacos/v1/ns/instance</span><br></pre></table></figure><h2 id=1-2、服务端><a class=headerlink href=#1-2、服务端 title=1.2、服务端></a>1.2、服务端</h2><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line>- 入口 com.alibaba.nacos.naming.controllers.InstanceController</span><br><span class=line></span><br><span class=line>- 将 实例信息 封装成 Instance对象。然后 执行注册实例方法。</span><br><span class=line>	ServiceManager.registerInstance(namespaceId, serviceName, instance);</span><br><span class=line>- 将 要注册的实例放入Service中</span><br><span class=line>	addInstance(namespaceId, serviceName, instance.isEphemeral(), instance);</span><br><span class=line>	</span><br><span class=line>	- 对服务加synchronized（不同服务不会阻塞，同一个服务的不同实例会被阻塞）</span><br><span class=line>		- 将实例列表封装成 instances 对象</span><br><span class=line>		- 更新注册表，完成 Nacos集群数据同步。 consistencyService.put(key, instances);</span><br><span class=line></span><br><span class=line>- 更新服务列表 ServiceManager.updateIpAddresses(...);</span><br><span class=line>	先获取旧的实例列表，然后把新的实例信息与旧的做对比，新的实例就添加，老的实例同步ID。</span><br><span class=line>	然后返回最新的实例列表。</span><br><span class=line></span><br><span class=line>- 集群一致性 更新 </span><br><span class=line>	- DelegateConsistencyServiceImpl.put(..);</span><br><span class=line>		- 根据实例是否是临时实例，判断委托对象</span><br><span class=line>			// 判断是否是临时实例：（默认情况下，所有实例都是临时实例，我们关注DistroConsistencyServiceImpl即可。）</span><br><span class=line>			// 是，选择 ephemeralConsistencyService，也就是 DistroConsistencyServiceImpl类</span><br><span class=line>			// 否，选择 persistentConsistencyService，也就是PersistentConsistencyServiceDelegateImpl</span><br><span class=line></span><br><span class=line>		- 先将要更新的实例信息写入本地实例列表，然后同步集群数据</span><br><span class=line>			- onPut(key, value);</span><br><span class=line>				- 将任务放入阻塞队列，通过线程池异步从队列中取出任务来执行。</span><br><span class=line>					notifier.addTask(key, DataOperation.CHANGE);</span><br><span class=line>					handle(pair);</span><br><span class=line>				- 根据 CHANGE事件 还是 DELETE 事件，来执行对应的操作。</span><br><span class=line>					- 获取旧实例列表</span><br><span class=line>					- 检查新加入实例状态</span><br><span class=line>					- 移除要删除的实例</span><br><span class=line>					- 覆盖旧实例。</span><br><span class=line>			- distroProtocol.sync(...);</span><br><span class=line>				- 遍历集群所有节点（除了自己），交给线程池去执行。</span><br><span class=line>					NacosDelayTaskExecuteEngine.addTask(distroKeyWithTarget, distroDelayTask);</span><br><span class=line>					NacosDelayTaskExecuteEngine，这个类维护了一个线程池，并且接收任务，执行任务。</span><br><span class=line>					去除任务来执行是基于Distro模式的同步是异步进行的，并且失败时会将任务重新入队，因此不保证强一致性，属于AP模式的一致性策略。</span><br></pre></table></figure><h2 id=1-3、总结><a class=headerlink href=#1-3、总结 title=1.3、总结></a>1.3、总结</h2><p><strong>（1）Nacos的注册表结构是什么样的？</strong><p>Nacos是多级存储模型，最外层通过namespace来实现环境隔离，然后是group分组，分组下就是服务，一个服务可分不同的集群，集群中包含多个实例。因此其注册表结构是一个Map结构：<p><code>Map&LTString, Map&LTString, Service>></code>，key是<code>namespace_id</code>，value代表的map结构的key是<code>group+serviceName</code>.<p>Service内部维护一个Map结构：<code>Map&LTString,Cluster></code>，key是clusterName，值是集群信息，Cluster内部维护一个Set集合，元素是Instance类型，代表集群中的多个实例。<p><strong>（2）Nacos如何保证并发写的安全性？</strong><p>注册实例时会对service加锁，不同service之间本身就不存在并发写问题，互不影响。相同service时通过锁来互斥。并且，在更新实例列表时，是基于异步的线程池来完成，且线程池的线程数量为1。<p><strong>（3）Nacos如何避免并发读写的冲突？</strong><p>Nacos在更新实例列表时，会<strong>采用 CopyOnWrite 技术</strong>，首先将Old实例列表拷贝一份，然后更新拷贝的实例列表，再用更新后的实例列表来覆盖旧的实例列表。<p><strong>（4）Nacos如何应对阿里内部数十万服务的并发写请求？</strong><p>Nacos内部会将服务注册的任务放入<em><strong>阻塞队列</strong></em>，采用<em><strong>线程池异步</strong></em>来完成实例更新，从而提高并发写能力。<h1 id=2、服务心跳><a class=headerlink href=#2、服务心跳 title=2、服务心跳></a>2、服务心跳</h1><h2 id=2-1、客户端><a class=headerlink href=#2-1、客户端 title=2.1、客户端></a>2.1、客户端</h2><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>- 入口 NacosNamingService.registerInstance(...);</span><br><span class=line>	- 触发心跳：BeatReactor.addBeatInfo(groupedServiceName, beatInfo)</span><br><span class=line>		- 利用线程池，定期执行心跳任务，周期为 beatInfo.getPeriod()，默认5S</span><br><span class=line>			executorService.schedule(new BeatTask(beatInfo), beatInfo.getPeriod(), TimeUnit.MILLISECONDS);</span><br><span class=line></span><br><span class=line>			发送心跳，然后判断心跳结果，若失败则重新 注册实例。</span><br><span class=line>- 发送心跳 NamingProxy.sendBeat(...)</span><br><span class=line>	请求地址：/v1/ns/instance/beat</span><br></pre></table></figure><h2 id=2-2、服务端><a class=headerlink href=#2-2、服务端 title=2.2、服务端></a>2.2、服务端</h2><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>- 入口：InstanceController.beat();</span><br><span class=line></span><br><span class=line>- 从Nacos注册表中获取实例</span><br><span class=line>- 实例为null，表示获取失败 说明心跳失败，实例未注册</span><br><span class=line>	- 重新注册新实例</span><br><span class=line>- 实例不为null，则从注册表中获取服务service</span><br><span class=line>- 若service为null, 则服务不存在，抛出异常</span><br><span class=line>- 如果心跳没有问题，就处理 心跳结果。</span><br><span class=line></span><br><span class=line>- 处理心跳请求</span><br><span class=line>	- 从集群中找到当前的心跳实例</span><br><span class=line>	- 更新 该实例 最后一次心跳时间 lastBeat。</span><br></pre></table></figure><h3 id=2-2-1、异常检查><a class=headerlink href=#2-2-1、异常检查 title=2.2.1、异常检查></a>2.2.1、异常检查</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line>- 入口 Service.init(); 服务注册时会被调用。</span><br><span class=line></span><br><span class=line>- 开启心跳检测任务</span><br><span class=line>	HealthCheckReactor.scheduleCheck(clientBeatCheckTask);</span><br><span class=line>	该任务会 每5秒对实例心跳状态 做一次检测。</span><br><span class=line></span><br><span class=line>	- clientBeatCheckTask</span><br><span class=line>		- 拿到 所有临时实例列表</span><br><span class=line>		- 判断 心跳间隔（当前时间-最后一次心跳时间）是否大于 心跳超时时间，默认15S</span><br><span class=line>			- 超时，则标记实例为 不健康。</span><br><span class=line>			- 不超时，发布实例状态变事件。</span><br><span class=line>		- 判断心跳间隔（当前时间 - 最后一次心跳时间）是否大于 实例被删除的最长超时时间，默认30秒</span><br><span class=line>			- 超过30S，删除实例。</span><br></pre></table></figure><h3 id=2-2-2、主动检查><a class=headerlink href=#2-2-2、主动检查 title=2.2.2、主动检查></a>2.2.2、主动检查</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line>- 入口 ServiceManager.registerInstance(...)</span><br><span class=line></span><br><span class=line>- 若服务不存在，创建新服务。</span><br><span class=line>	- 尝试获取服务</span><br><span class=line>	- 服务不存在，开始创建新服务。</span><br><span class=line>	- 将服务写入注册表 并初始化。</span><br><span class=line>		- 初始化逻辑</span><br><span class=line>			- 开启心跳检测任务</span><br><span class=line>			- 遍历注册表中的集群</span><br><span class=line>			- 完成集群初始化</span><br><span class=line>				- 创建健康检测任务</span><br><span class=line>				- 开启对 非临时实例 的定时检测。</span><br><span class=line>- 非临时实例 定时检测逻辑</span><br><span class=line>	- 获取所有 非临时实例 集合</span><br><span class=line>	- 将检测信息 封装成 beat</span><br><span class=line>	- 放入阻塞队列中。</span><br><span class=line>	</span><br><span class=line>	- 拿出任务去执行</span><br><span class=line>		- 将任务封装为一个 TaskProcessor，并放入集合。</span><br><span class=line>		- 批量处理集合中的任务。</span><br><span class=line>			- 获取实例信息</span><br><span class=line>			- 基于NIO建立TCP连接</span><br><span class=line>			- 注册 连接、读取 事件。</span><br></pre></table></figure><h2 id=2-3、总结><a class=headerlink href=#2-3、总结 title=2.3、总结></a>2.3、总结</h2><p>Nacos的健康检测有两种模式：<ul><li>临时实例：<ul><li>采用客户端心跳检测模式，心跳周期5秒。<li>心跳间隔超过15秒就标记为不健康。<li>心跳间隔超过30秒会被从服务列表删除。</ul><li>永久实例：<ul><li>采用服务端主动健康检测方式。<li>周期为2000 + 5000毫秒内的随机数。<li>检测异常只会标记为不健康，不会删除。</ul></ul><p><strong>为什么Nacos有临时和永久两种实例呢？</strong><p>以淘宝为例，双十一大促期间，流量会比平常高出很多，此时需要增加更多实例来应对高并发，而这些实例在双十一之后就无需继续使用了，采用<strong>临时实例</strong>比较合适。而对于服务的一些常备实例，则使用<strong>永久实例</strong>更合适。<p>与eureka相比，Nacos与Eureka在临时实例上都是基于心跳模式实现，差别不大，主要是心跳周期不同，eureka是30秒，Nacos是5秒。<p>另外，Nacos支持永久实例，而Eureka不支持，Eureka只提供了心跳模式的健康监测，而没有主动检测功能。<h1 id=3、服务发现><a class=headerlink href=#3、服务发现 title=3、服务发现></a>3、服务发现</h1><h2 id=3-1、客户端><a class=headerlink href=#3-1、客户端 title=3.1、客户端></a>3.1、客户端</h2><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br></pre><td class=code><pre><span class=line>- 入口 NacosNamingService. getAllInstances(...);</span><br><span class=line></span><br><span class=line>- 判断 是否需要 订阅服务（默认true）</span><br><span class=line>	- 若要订阅，执行订阅逻辑。serviceInfo = hostReactor.getServiceInfo(...);</span><br><span class=line>	- 否则，执行拉取逻辑。serviceInfo = hostReactor.getServiceInfoDirectlyFromServer()</span><br><span class=line>- 从服务信息中获取实力列表并返回。</span><br><span class=line></span><br><span class=line>- 拉取服务</span><br><span class=line>	- 查看本地服务列表缓存是否存在，缓存是map</span><br><span class=line>	- 不存在</span><br><span class=line>		- 创建空ServiceInfo</span><br><span class=line>		- 放入缓存</span><br><span class=line>		- 放入待更新的服务列表</span><br><span class=line>		- 立即更新服务列表</span><br><span class=line>			- 执行HostReactor中的updateService()方法。</span><br><span class=line>				- 基于ServerProxy发起远程调用，查询服务列表</span><br><span class=line>		- 从 待更新服务列表 中删除</span><br><span class=line>	- 存在，但需要更新</span><br><span class=line>		- 执行更新逻辑。等待5秒中，待更新完成</span><br><span class=line>	- 开启定时更新服务列表的功能</span><br><span class=line>		scheduleUpdateIfAbsent(serviceName, clusters);</span><br><span class=line>	- 返回缓存中的服务信息</span><br><span class=line>		serviceInfoMap.get(serviceObj.getKey());</span><br><span class=line>	</span><br><span class=line>- 推送服务</span><br><span class=line>	基本思路是：</span><br><span class=line>		- 通过PushReceiver监听服务端推送的变更数据</span><br><span class=line>		- 解析数据后，通过NotifyCenter发布服务变更的事件</span><br><span class=line>		- InstanceChangeNotifier监听变更事件，完成对服务列表的更新</span><br><span class=line></span><br><span class=line>	入口 PushReceiver</span><br><span class=line>		- 创建 UDP客户端</span><br><span class=line>		- 准备线程池</span><br><span class=line>		- 开启线程任务，准备接收变更数据</span><br><span class=line>			- 接收推送数据</span><br><span class=line>			- 解析为json字符串</span><br><span class=line>			- 反序列化为对象</span><br><span class=line>			- 交给 HostReactor去处理</span><br><span class=line>			- 发送ACK回执</span><br><span class=line></span><br><span class=line>	- 处理接收到的数据 HostReactor.processServiceJson(String json);</span><br><span class=line>		- 解析 接收到的数据，解析出ServiceInfo</span><br><span class=line>		- 查询缓存中的 ServiceInfo</span><br><span class=line>		- 如果缓存存在，则需要校验哪些数据要更新</span><br><span class=line>			- 将接收到的ServiceInfo 放入缓存。</span><br><span class=line>			- 对缓存中的数据 与 接收到的数据 进行对比。拿到</span><br><span class=line>				新增实例、待删除实例、要修改实例。</span><br><span class=line>			- 发布实例状态修改事件。</span><br><span class=line>			- 将接收到的数据ServiceInfo写入缓存。</span><br><span class=line>		- 缓存不存在</span><br><span class=line>			- 放入缓存</span><br><span class=line>			- 直接发布状态修改事件。</span><br></pre></table></figure><h2 id=3-2、服务端><a class=headerlink href=#3-2、服务端 title=3.2、服务端></a>3.2、服务端</h2><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>- 入口 InstanceController.list();</span><br><span class=line></span><br><span class=line>- 获取客户端UDP端口</span><br><span class=line>- 获取服务列表并返回</span><br><span class=line>	- 将消费者UDP端口、IP等封装成一个PushClient对象，存储到PushService中，</span><br><span class=line>		后期服务变更时，方便推送消息。pushService.addClient()</span><br><span class=line>	- PushService实现了ApplicationListener接口，当服务列表变化时，就会通知我们。</span><br></pre></table></figure><h2 id=3-3、总结><a class=headerlink href=#3-3、总结 title=3.3、总结></a>3.3、总结</h2><p>Nacos的服务发现分为两种模式：<ul><li><strong>主动拉取模式</strong>。消费者定期主动从Nacos拉取服务列表并缓存起来，在调用服务时优先读取本地缓存中的服务列表。<li><strong>订阅模式</strong>。消费者订阅服务列表，并基于UDP协议来接收服务变更通知。服务列表更新时会发送UDP广播给所有订阅者。</ul><p>与Eureka相比，Nacos服务状态更新更及时，同步更新更快，避免了因同步慢造成的一系列问题。</div><footer class=post-footer><div class=post-tags><a href=/tags/Nacos/ rel=tag># Nacos</a><a href=/tags/Nacos%E5%8E%9F%E7%90%86/ rel=tag># Nacos原理</a></div><div class=post-nav><div class=post-nav-item><a href=/2024/08/21/MySQL%E7%B2%BE%E9%80%9A%E8%B0%83%E4%BC%98/ rel=prev title=MySQL系列-MySQL调优> <i class="fa fa-angle-left"></i> MySQL系列-MySQL调优 </a></div><div class=post-nav-item><a href=/2024/08/21/Nacos%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/ rel=next title=Nacos系列-Nacos基础应用> Nacos系列-Nacos基础应用 <i class="fa fa-angle-right"></i> </a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script>