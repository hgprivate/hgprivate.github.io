<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hshz21.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="1、IO简介1.1、前言Linux 2.6以后，Java中NIO和AIO都通过epoll来实现，而Windows上的AIO是通过IOCP来实现。 Epoll 与 IOCP 区别如下：  Epoll 适用于 Linux；而 IOCP 适用于 Windows； Epoll 会在事件资源满足时发出可处理的通知消息；而 IOCP 会在事件完成时发出完成通知消息； 从应用程序角度来看， Epoll本质上是同" name=description><meta content=article property=og:type><meta content=计算机系列-IO property=og:title><meta content=https://hshz21.gitee.io/2024/08/21/IO%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content="1、IO简介1.1、前言Linux 2.6以后，Java中NIO和AIO都通过epoll来实现，而Windows上的AIO是通过IOCP来实现。 Epoll 与 IOCP 区别如下：  Epoll 适用于 Linux；而 IOCP 适用于 Windows； Epoll 会在事件资源满足时发出可处理的通知消息；而 IOCP 会在事件完成时发出完成通知消息； 从应用程序角度来看， Epoll本质上是同" property=og:description><meta content=zh_CN property=og:locale><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200927130712324.png?token=AIGEF3OVLUK27RBL6SLEFTLEZZV3U property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200927131236060.png?token=AIGEF3JJN3JOM6PIKPPGUA3EZZV4U property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200927132311222.png?token=AIGEF3NL6VRYEYFRUKUQF6TEZZV5Y property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200927131649129.png?token=AIGEF3OTZ73LT4QN6AP7KWLEZZV62 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200927132414881.png?token=AIGEF3LT4XPCFNCIGXH63A3EZZV7Y property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/5%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%9401.png?token=AIGEF3K7SADXDY2FIQ5EAUTEZZWBY property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/select-poll-epoll%E5%8C%BA%E5%88%AB_%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%94%AF%E6%8C%81%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B001.png?token=AIGEF3L5JFBKQGWZRDVHKEDEZZWE2 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/select-poll-epoll%E5%8C%BA%E5%88%AB_FD%E5%89%A7%E5%A2%9E%E5%90%8E%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%9801.png?token=AIGEF3IBWIKHFGDH77RBSP3EZZWGO property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/select-poll-epoll%E5%8C%BA%E5%88%AB_%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F01.png?token=AIGEF3P4I6JR72ZXBU2H6Z3EZZWIK property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210130120424783.png?token=AIGEF3LVAGFSNH77T3MR2Z3EZZWKI property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210130120745134.png?token=AIGEF3NURLY36AQHY2JQLJDEZZWLK property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210130121111912.png?token=AIGEF3P7PCE73Q4G6GRF7C3EZZWMM property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210130121212731.png?token=AIGEF3J26FNDQI3N67MR2ZTEZZWNQ property=og:image><meta content=2024-08-21T13:39:13.750Z property=article:published_time><meta content=2023-10-06T08:06:36.940Z property=article:modified_time><meta content=豪哥 property=article:author><meta content=IO property=article:tag><meta content=summary name=twitter:card><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200927130712324.png?token=AIGEF3OVLUK27RBL6SLEFTLEZZV3U name=twitter:image><link href=https://hshz21.gitee.io/2024/08/21/IO%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hshz21.gitee.io/2024/08/21/IO%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","path":"2024/08/21/IO知识总结/","title":"计算机系列-IO"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>计算机系列-IO | 豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>豪哥博客</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#1%E3%80%81IO%E7%AE%80%E4%BB%8B><span class=nav-number>1.</span> <span class=nav-text>1、IO简介</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81%E5%89%8D%E8%A8%80><span class=nav-number>1.1.</span> <span class=nav-text>1.1、前言</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-2%E3%80%81%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AFIO><span class=nav-number>1.2.</span> <span class=nav-text>1.2、到底什么是IO</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-3%E3%80%81%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%90%8C%E6%AD%A5%EF%BC%89><span class=nav-number>1.3.</span> <span class=nav-text>1.3、阻塞IO模型（同步）</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-4%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%90%8C%E6%AD%A5%EF%BC%89><span class=nav-number>1.4.</span> <span class=nav-text>1.4、非阻塞IO模型（同步）</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-5%E3%80%81%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%90%8C%E6%AD%A5%EF%BC%89><span class=nav-number>1.5.</span> <span class=nav-text>1.5、信号驱动模型（同步）</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-6%E3%80%81IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%90%8C%E6%AD%A5%EF%BC%89><span class=nav-number>1.6.</span> <span class=nav-text>1.6、IO多路复用模型（同步）</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-7%E3%80%81%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B%EF%BC%88%E5%BC%82%E6%AD%A5%EF%BC%89><span class=nav-number>1.7.</span> <span class=nav-text>1.7、异步IO模型（异步）</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-8%E3%80%81%E6%80%BB%E7%BB%93><span class=nav-number>1.8.</span> <span class=nav-text>1.8、总结</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-8-1%E3%80%81%E5%89%8D%E5%9B%9B%E7%A7%8D%E9%83%BD%E6%98%AF%E5%90%8C%E6%AD%A5IO%E6%A8%A1%E5%9E%8B><span class=nav-number>1.8.1.</span> <span class=nav-text>1.8.1、前四种都是同步IO模型</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-8-2%E3%80%81%E4%BA%94%E7%A7%8D-IO-%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94><span class=nav-number>1.8.2.</span> <span class=nav-text>1.8.2、五种 IO 模型对比</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#2%E3%80%81IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8><span class=nav-number>2.</span> <span class=nav-text>2、IO多路复用</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#2-1%E3%80%81%E5%BF%85%E7%9F%A5%E7%9F%A5%E8%AF%86><span class=nav-number>2.1.</span> <span class=nav-text>2.1、必知知识</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-1%E3%80%81%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4><span class=nav-number>2.1.1.</span> <span class=nav-text>2.1.1、用户空间和内核空间</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-2%E3%80%81%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2><span class=nav-number>2.1.2.</span> <span class=nav-text>2.1.2、进程切换</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-3%E3%80%81%E8%BF%9B%E7%A8%8B%E9%98%BB%E5%A1%9E><span class=nav-number>2.1.3.</span> <span class=nav-text>2.1.3、进程阻塞</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-4%E3%80%81%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6FD><span class=nav-number>2.1.4.</span> <span class=nav-text>2.1.4、文件描述符FD</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%AE%80%E4%BB%8B><span class=nav-number>2.1.4.1.</span> <span class=nav-text>简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%8E%9F%E7%90%86><span class=nav-number>2.1.4.2.</span> <span class=nav-text>文件描述符原理</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%99%90%E5%88%B6><span class=nav-number>2.1.4.3.</span> <span class=nav-text>文件描述符限制</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-5%E3%80%81%E7%BC%93%E5%AD%98I-O><span class=nav-number>2.1.5.</span> <span class=nav-text>2.1.5、缓存I/O</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-6%E3%80%81IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%AE%80%E4%BB%8B><span class=nav-number>2.1.6.</span> <span class=nav-text>2.1.6、IO多路复用简介</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-2%E3%80%81select%EF%BC%881983%EF%BC%89><span class=nav-number>2.2.</span> <span class=nav-text>2.2、select（1983）</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-1%E3%80%81%E5%8E%9F%E7%90%86><span class=nav-number>2.2.1.</span> <span class=nav-text>2.2.1、原理</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-2%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9><span class=nav-number>2.2.2.</span> <span class=nav-text>2.2.2、优缺点</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BC%98%E7%82%B9><span class=nav-number>2.2.2.1.</span> <span class=nav-text>优点</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%BC%BA%E7%82%B9><span class=nav-number>2.2.2.2.</span> <span class=nav-text>缺点</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-3%E3%80%81poll%EF%BC%881997%EF%BC%89><span class=nav-number>2.3.</span> <span class=nav-text>2.3、poll（1997）</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-1%E3%80%81%E5%8E%9F%E7%90%86><span class=nav-number>2.3.1.</span> <span class=nav-text>2.3.1、原理</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-2%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9><span class=nav-number>2.3.2.</span> <span class=nav-text>2.3.2、优缺点</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BC%98%E7%82%B9-1><span class=nav-number>2.3.2.1.</span> <span class=nav-text>优点</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%BC%BA%E7%82%B9-1><span class=nav-number>2.3.2.2.</span> <span class=nav-text>缺点</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9><span class=nav-number>2.3.2.3.</span> <span class=nav-text>注意事项</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-4%E3%80%81epoll%EF%BC%882002%EF%BC%89><span class=nav-number>2.4.</span> <span class=nav-text>2.4、epoll（2002）</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>2.4.1.</span> <span class=nav-text>2.4.1、简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-2%E3%80%81%E5%8E%9F%E7%90%86><span class=nav-number>2.4.2.</span> <span class=nav-text>2.4.2、原理</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-3%E3%80%81%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B><span class=nav-number>2.4.3.</span> <span class=nav-text>2.4.3、工作过程</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-4%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9><span class=nav-number>2.4.4.</span> <span class=nav-text>2.4.4、优缺点</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-4-5%E3%80%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F><span class=nav-number>2.4.5.</span> <span class=nav-text>2.4.5、工作模式</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-5%E3%80%81kqueue><span class=nav-number>2.5.</span> <span class=nav-text>2.5、kqueue</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-5-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>2.5.1.</span> <span class=nav-text>2.5.1、简介</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-6%E3%80%81%E6%80%BB%E7%BB%93><span class=nav-number>2.6.</span> <span class=nav-text>2.6、总结</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-6-1%E3%80%81select%E3%80%81poll%E3%80%81epoll%E5%8C%BA%E5%88%AB><span class=nav-number>2.6.1.</span> <span class=nav-text>2.6.1、select、poll、epoll区别</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-6-2%E3%80%81%E5%9C%BA%E6%99%AF%E5%8A%A9%E8%AE%B0><span class=nav-number>2.6.2.</span> <span class=nav-text>2.6.2、场景助记</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-6-3%E3%80%81%E4%B8%89%E8%80%85%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9><span class=nav-number>2.6.3.</span> <span class=nav-text>2.6.3、三者如何选择</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#3%E3%80%81BIO%EF%BC%88Blocking-Input-Output%EF%BC%89><span class=nav-number>3.</span> <span class=nav-text>3、BIO（Blocking Input/Output）</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#3-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>3.1.</span> <span class=nav-text>3.1、简介</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-2%E3%80%81%E7%89%B9%E7%82%B9><span class=nav-number>3.2.</span> <span class=nav-text>3.2、特点</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-3%E3%80%81%E9%98%BB%E5%A1%9E%E6%96%B9%E6%B3%95><span class=nav-number>3.3.</span> <span class=nav-text>3.3、阻塞方法</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-4%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9><span class=nav-number>3.4.</span> <span class=nav-text>3.4、优缺点</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-5%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF><span class=nav-number>3.5.</span> <span class=nav-text>3.5、使用场景</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-6%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9><span class=nav-number>3.6.</span> <span class=nav-text>3.6、注意事项</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#4%E3%80%81NIO%EF%BC%88New-Input-Output%EF%BC%89><span class=nav-number>4.</span> <span class=nav-text>4、NIO（New Input/Output）</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#4-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>4.1.</span> <span class=nav-text>4.1、简介</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#4-2%E3%80%81Channel><span class=nav-number>4.2.</span> <span class=nav-text>4.2、Channel</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#4-3%E3%80%81Buffer><span class=nav-number>4.3.</span> <span class=nav-text>4.3、Buffer</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-3-1%E3%80%81DirectByteBuffer-VS-HeapByteBuffer><span class=nav-number>4.3.1.</span> <span class=nav-text>4.3.1、DirectByteBuffer VS HeapByteBuffer</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#4-4%E3%80%81Selector><span class=nav-number>4.4.</span> <span class=nav-text>4.4、Selector</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-4-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>4.4.1.</span> <span class=nav-text>4.4.1、简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-4-2%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9><span class=nav-number>4.4.2.</span> <span class=nav-text>4.4.2、优缺点</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-4-3%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF><span class=nav-number>4.4.3.</span> <span class=nav-text>4.4.3、使用场景</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#4-5%E3%80%81%E6%80%BB%E7%BB%93><span class=nav-number>4.5.</span> <span class=nav-text>4.5、总结</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-5-1%E3%80%81NIO%E7%89%B9%E6%80%A7-NIO%E4%B8%8EIO%E7%9A%84%E5%8C%BA%E5%88%AB><span class=nav-number>4.5.1.</span> <span class=nav-text>4.5.1、NIO特性/NIO与IO的区别</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-5-2%E3%80%81NIO-VS-BIO><span class=nav-number>4.5.2.</span> <span class=nav-text>4.5.2、NIO VS BIO</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#5%E3%80%81AIO%EF%BC%88Asynchronous-Input-Output%EF%BC%89><span class=nav-number>5.</span> <span class=nav-text>5、AIO（Asynchronous Input/Output）</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#5-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>5.1.</span> <span class=nav-text>5.1、简介</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#5-2%E3%80%81%E7%89%B9%E7%82%B9><span class=nav-number>5.2.</span> <span class=nav-text>5.2、特点</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#5-3%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9><span class=nav-number>5.3.</span> <span class=nav-text>5.3、优缺点</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#5-4%E3%80%81%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF><span class=nav-number>5.4.</span> <span class=nav-text>5.4、使用场景</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#6%E3%80%81IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%BC%8F><span class=nav-number>6.</span> <span class=nav-text>6、IO多路复用模式</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#6-1%E3%80%81Reactor%E6%A8%A1%E5%BC%8F><span class=nav-number>6.1.</span> <span class=nav-text>6.1、Reactor模式</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#6-x-1%E3%80%81%E8%AF%BB%E6%93%8D%E4%BD%9C><span class=nav-number>6.1.1.</span> <span class=nav-text>6.x.1、读操作</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#6-x-2%E3%80%81%E5%86%99%E6%93%8D%E4%BD%9C><span class=nav-number>6.1.2.</span> <span class=nav-text>6.x.2、写操作</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#6-x-3%E3%80%81class%E7%BB%93%E6%9E%84><span class=nav-number>6.1.3.</span> <span class=nav-text>6.x.3、class结构</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#6-2%E3%80%81Proactor%E6%A8%A1%E5%BC%8F><span class=nav-number>6.2.</span> <span class=nav-text>6.2、Proactor模式</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#6-x-1%E3%80%81%E8%AF%BB%E6%93%8D%E4%BD%9C-1><span class=nav-number>6.2.1.</span> <span class=nav-text>6.x.1、读操作</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#6-x-2%E3%80%81%E5%86%99%E6%93%8D%E4%BD%9C-1><span class=nav-number>6.2.2.</span> <span class=nav-text>6.x.2、写操作</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#6-x-3%E3%80%81class%E7%BB%93%E6%9E%84-1><span class=nav-number>6.2.3.</span> <span class=nav-text>6.x.3、class结构</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#6-3%E3%80%81%E6%80%BB%E7%BB%93><span class=nav-number>6.3.</span> <span class=nav-text>6.3、总结</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#6-3-1%E3%80%81%E4%B8%BB%E5%8A%A8%E4%B8%8E%E8%A2%AB%E5%8A%A8><span class=nav-number>6.3.1.</span> <span class=nav-text>6.3.1、主动与被动</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#6-3-2%E3%80%81%E5%AE%9E%E7%8E%B0><span class=nav-number>6.3.2.</span> <span class=nav-text>6.3.2、实现</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#6-3-3%E3%80%81%E4%BC%98%E5%8A%A3><span class=nav-number>6.3.3.</span> <span class=nav-text>6.3.3、优劣</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E4%BC%98%E7%82%B9-2><span class=nav-number>6.3.3.1.</span> <span class=nav-text>优点</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#%E7%BC%BA%E7%82%B9-2><span class=nav-number>6.3.3.2.</span> <span class=nav-text>缺点</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#6-3-4%E3%80%81%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF><span class=nav-number>6.3.4.</span> <span class=nav-text>6.3.4、适用场景</span></a></ol></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>109</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>33</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>126</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://hshz21.gitee.io/2024/08/21/IO%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="计算机系列-IO | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>计算机系列-IO</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-06 16:06:36" datetime=2023-10-06T16:06:36+08:00 itemprop=dateModified>2023-10-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/ itemprop=url rel=index><span itemprop=name>计算机</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、IO简介><a class=headerlink href=#1、IO简介 title=1、IO简介></a>1、IO简介</h1><h2 id=1-1、前言><a class=headerlink href=#1-1、前言 title=1.1、前言></a>1.1、前言</h2><p><strong>Linux 2.6以后，Java中NIO和AIO都通过epoll来实现，而Windows上的AIO是通过IOCP来实现</strong>。<p>Epoll 与 IOCP 区别如下：<ol><li>Epoll 适用于 Linux；而 IOCP 适用于 Windows；<li>Epoll 会在事件资源满足时发出可处理的通知消息；而 IOCP 会在事件完成时发出完成通知消息；<li>从应用程序角度来看， Epoll本质上是同步非阻塞，IOCP本质上则是异步操作；</ol><p>Java中的BIO、NIO和AIO就是对操作系统中各种IO模型的封装。程序员在使用相关API时，无需关心系统底层知识，无需编写不同的代码，可直接使用Java提供的API。<p><strong>Linux(UNIX)操作系统共有五种IO模型：阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动IO模型、异步IO模型</strong>。<h2 id=1-2、到底什么是IO><a class=headerlink href=#1-2、到底什么是IO title=1.2、到底什么是IO></a>1.2、到底什么是IO</h2><p>拿一次磁盘文件读取为例，<strong>IO就是把数据从硬件（硬盘）中读取到用户空间中的一个过程</strong>。<p>其实真正的文件读取还涉及到缓存等细节，这里不再展开。关于用户空间、内核空间以及硬件等的关系如果不理解的话，可以通过钓鱼的例子来帮助理解。<p>钓鱼过程：我们通过鱼竿将鱼从鱼塘中钓上来并放入鱼篓中。<p>其中的鱼塘就可以看成是磁盘，鱼钩可以映射成内核空间，鱼篓可以映射成用户空间。一次完整的钓鱼（IO）操作，是鱼（文件）从鱼塘（硬盘）中转移（拷贝）到鱼篓（用户空间）的过程。<p>对于一个network IO (以read举例)，它会涉及到两个系统对象：一个是调用IO的进程，另一个就是系统内核(kernel)。<p>对于一次IO访问（以read举例），数据先拷贝至系统内核的缓冲区中，然后再拷贝到应用程序的地址空间。所以，一个read操作会经历两个阶段：<ul><li>**阶段1：等待数据准备 (Waiting for the data to be ready)**。<li>**阶段2： 将数据 从内核 拷贝到 进程中 (Copying the data from the kernel to the process)**。</ul><p>因为这两个阶段，linux系统生成了五种网络模式：<ul><li>阻塞 I/O（blocking IO）<li>非阻塞 I/O（nonblocking IO）<li>信号驱动 I/O（ signal driven IO）<li>I/O 多路复用（ IO multiplexing）<li>异步 I/O（asynchronous IO）</ul><h2 id=1-3、阻塞IO模型（同步）><a class=headerlink href=#1-3、阻塞IO模型（同步） title=1.3、阻塞IO模型（同步）></a>1.3、阻塞IO模型（同步）</h2><p>钓鱼的时候，有一种方式比较惬意，比较轻松，那就是我们坐在鱼竿面前，这个过程中我们什么也不做，双手一直把着鱼竿，就静静的等着鱼儿咬钩。一旦手上感受到鱼的力道，就把鱼钓起来放入鱼篓中。然后再钓下一条鱼。<p>映射到Linux操作系统中，这就是一种最简单的IO模型，即阻塞IO。 阻塞 I/O 是最简单的 I/O 模型，一般表现为进程或线程等待某个条件，如果条件不满足，则一直等下去。直到条件满足再进行下一步操作。<p>这种钓鱼方式相对来说比较简单，对于钓鱼的人来说，不需要什么特制的鱼竿，拿一根够长的木棍就可以悠闲的开始钓鱼了（实现简单）。缺点就是比较耗费时间，比较适合那种对鱼的需求量小的情况（并发低，时效性要求低）。<p><img alt=image-20200927130712324 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200927130712324.png?token=AIGEF3OVLUK27RBL6SLEFTLEZZV3U><p>如上图，当用户进程执行了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整 个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除 block的状态，重新运行起来。<h2 id=1-4、非阻塞IO模型（同步）><a class=headerlink href=#1-4、非阻塞IO模型（同步） title=1.4、非阻塞IO模型（同步）></a>1.4、非阻塞IO模型（同步）</h2><p>我们钓鱼的时候，在等待鱼儿咬钩的过程中，我们可以做点别的事情，比如玩一把王者荣耀、看一集《延禧攻略》等等。但是，我们要时不时的去看一下鱼竿，一旦发现有鱼儿上钩了，就把鱼钓上来。<p>映射到Linux操作系统中，这就是非阻塞的IO模型。应用进程与内核交互，目的未达到之前，不再一味的等着，而是直接返回。然后通过轮询的方式，不停的去问内核数据有没有准备好。如果某一次轮询发现数据已经准备好了，那就把数据拷贝到用户空间中。<p>这种方式钓鱼，和阻塞IO比，所使用的工具没有什么变化，但是钓鱼的时候可以做些其他事情，增加时间的利用率。<p><img alt=image-20200927131236060 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200927131236060.png?token=AIGEF3JJN3JOM6PIKPPGUA3EZZV4U><p>从上图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。 从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次 发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。<p>所以，用户进程第一个阶段不是阻塞的，需要不断的主动询问kernel数据好了没有；第二个阶段依然是阻塞的。<h2 id=1-5、信号驱动模型（同步）><a class=headerlink href=#1-5、信号驱动模型（同步） title=1.5、信号驱动模型（同步）></a>1.5、信号驱动模型（同步）</h2><p>我们钓鱼的时候，为了避免自己一遍一遍的去查看鱼竿，我们可以给鱼竿安装一个报警器。当有鱼儿咬钩的时候立刻报警。然后我们再收到报警后，去把鱼钓起来。<p>映射到Linux操作系统中，这就是信号驱动IO。应用进程在读取文件时通知内核，如果某个 socket 的某个事件发生时，请向我发一个信号。在收到信号后，信号对应的处理函数会进行后续处理。<p>这种方式钓鱼，和前几种相比，所使用的工具有了一些变化，需要有一些定制（实现复杂）。但是钓鱼的人就可以在鱼儿咬钩之前彻底做别的事儿去了。等着报警器响就行了。<p><img alt=image-20200927132311222 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200927132311222.png?token=AIGEF3NL6VRYEYFRUKUQF6TEZZV5Y><p>据上图所示，用户进程预先向内核注册一个信号处理函数，然后用户进程返回，并且不阻塞，当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝的用户空间中。<h2 id=1-6、IO多路复用模型（同步）><a class=headerlink href=#1-6、IO多路复用模型（同步） title=1.6、IO多路复用模型（同步）></a>1.6、IO多路复用模型（同步）</h2><p>我们钓鱼的时候，为了保证可以最短的时间钓到最多的鱼，我们同一时间摆放多个鱼竿，同时钓鱼。然后哪个鱼竿有鱼儿咬钩了，我们就把哪个鱼竿上面的鱼钓起来。映射到Linux操作系统中，这就是IO复用模型。多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。<p><strong>IO multiplexing（IO多路复用）就是常说的select，poll，epoll，有时也称为event driven IO</strong>。IO复用同非阻塞IO本质一样，不过利用了新的select系统调用，由内核来负责本来是请求进程该做的轮询操作。看似比非阻塞IO还多了一个系统调用开销，不过因为可以支持多路IO，才算提高了效率。<p>这种通过 增加鱼竿 的方式，可有效提升效率。<p><img alt=image-20200927131649129 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200927131649129.png?token=AIGEF3OTZ73LT4QN6AP7KWLEZZV62><p>据上图可知，当用户进程调用了<code>select</code>，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个 socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。<p>select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。在IO multiplexing Model中，实际对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被 block的。只不过process是被select这个函数block，而不是被socket IO给block。<h2 id=1-7、异步IO模型（异步）><a class=headerlink href=#1-7、异步IO模型（异步） title=1.7、异步IO模型（异步）></a>1.7、异步IO模型（异步）</h2><p>钓鱼时采用一种高科技钓鱼竿，即全自动钓鱼竿。可以自动感应鱼上钩，自动收竿，更厉害的可以自动把鱼放进鱼篓里。然后，通知我们鱼已经钓到了，他就继续去钓下一条鱼去了。<p>映射到Linux操作系统中，这就是异步IO模型。应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。<p><img alt=image-20200927132414881 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200927132414881.png?token=AIGEF3LT4XPCFNCIGXH63A3EZZV7Y><p>如上图所示，用户进程发起<code>aio_read</code>操作之后，给内核传递描述符、缓冲区指针、缓冲区大小等，告诉内核当整个操作完成时，如何通知进程，然后就立刻去做其他事情了。当内核收到<code>aio_read</code>后，会立刻返回，然后内核开始等待数据准备，数据准备好以后，直接把数据拷贝到用户空间，然后再通知进程本次IO已经完成。<p>这种钓鱼方式，最省事，只需要交给鱼竿就可以了。<h2 id=1-8、总结><a class=headerlink href=#1-8、总结 title=1.8、总结></a>1.8、总结</h2><h3 id=1-8-1、前四种都是同步IO模型><a class=headerlink href=#1-8-1、前四种都是同步IO模型 title=1.8.1、前四种都是同步IO模型></a>1.8.1、前四种都是同步IO模型</h3><p>我们说阻塞IO模型、非阻塞IO模型、IO复用模型和信号驱动IO模型都是同步的IO模型。原因是因为，无论以上那种模型，真正的数据拷贝过程，都是同步进行。<p>信号驱动逻辑是：<strong>数据准备好之后内核会通知进程，然后进程通过<code>recvfrom</code>操作进行数据拷贝</strong>。可以认为数据准备阶段是异步的，数据拷贝操作是同步的。所以，整个IO过程不能认为是异步。<h3 id=1-8-2、五种-IO-模型对比><a title="1.8.2、五种 IO 模型对比" class=headerlink href=#1-8-2、五种-IO-模型对比></a>1.8.2、五种 IO 模型对比</h3><p><img alt=5种IO模型对比01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/5%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%9401.png?token=AIGEF3K7SADXDY2FIQ5EAUTEZZWBY><h1 id=2、IO多路复用><a class=headerlink href=#2、IO多路复用 title=2、IO多路复用></a>2、IO多路复用</h1><h2 id=2-1、必知知识><a class=headerlink href=#2-1、必知知识 title=2.1、必知知识></a>2.1、必知知识</h2><h3 id=2-1-1、用户空间和内核空间><a class=headerlink href=#2-1-1、用户空间和内核空间 title=2.1.1、用户空间和内核空间></a>2.1.1、用户空间和内核空间</h3><p><strong>32位操作系统的寻址空间（虚拟存储空间）为4G（2的32次方）</strong>。<p>操作系统核心是内核，可访问受保护的内存空间，也有访问底层硬件设备的所有权限。<p>为了限制进程直接操作内核（kernel），保证内核安全，操作系统将虚拟空间划分为两部分：<ul><li><p><strong>内核空间</strong>：linux系统中，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF）供内核使用，称为内核空间。</p><li><p><strong>用户空间</strong>：将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF）供进程使用，称为用户空间。</p></ul><h3 id=2-1-2、进程切换><a class=headerlink href=#2-1-2、进程切换 title=2.1.2、进程切换></a>2.1.2、进程切换</h3><p><strong>内核可以挂起正在CPU上运行的进程，也可以恢复被挂起的某个进程，这种行为被称为进程切换</strong>。任何进程的运行都依赖于操作系统内核的支持。<p>从一个进程的运行转到另一个进程上运行，其过程变化如下：<ol><li>保存处理机上下文，包括程序计数器和其他寄存器。<li>更新PCB信息。<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。<li>选择另一个进程执行，并更新其PCB。<li>更新内存管理的数据结构。<li>恢复处理机上下文。</ol><p>详情可参考这篇文章：<a href=http://guojing.me/linux-kernel-architecture/posts/process-switch/ rel=noopener target=_blank>进程切换</a><h3 id=2-1-3、进程阻塞><a class=headerlink href=#2-1-3、进程阻塞 title=2.1.3、进程阻塞></a>2.1.3、进程阻塞</h3><p>正在执行的进程，若期待的某些事件未发生，则系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。<p>进程的阻塞是进程自身的一种主动行为，只有运行态的进程才能转为阻塞状态。阻塞状态下的进程不消耗CPU资源。<h3 id=2-1-4、文件描述符FD><a class=headerlink href=#2-1-4、文件描述符FD title=2.1.4、文件描述符FD></a>2.1.4、文件描述符FD</h3><h4 id=简介><a class=headerlink href=#简介 title=简介></a>简介</h4><p><strong>文件描述符（File descriptor）是计算机科学中的一个术语，是一个表述文件引用的抽象化概念</strong>。<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核会向进程返回一个文件描述符。<p><font color=red>注意：偏底层应用程序的设计通常会与文件描述符打交道，但要注意的是，文件描述符仅与Unix、Linux系统有关。</font><h4 id=文件描述符原理><a class=headerlink href=#文件描述符原理 title=文件描述符原理></a>文件描述符原理</h4><p>系统为了维护文件描述符建立了3张表：<ul><li><p><strong>进程级文件描述符表</strong></p> <p>主要记录了以下两项内容：</p> <ol><li>文件描述符标志。<li>文件指针（open file handle）。</ol><li><p><strong>系统级文件描述符表</strong></p> <p>记录内容如下：</p> <ol><li>当前文件偏移量。<li>状态标识。<li>文件访问模式（读、写、读和写）。<li>对该文件i-nod对象的引用。<li>文件类型（常规文件、套接字、FIFO….）。<li>访问权限。<li>一个指向该文件所持有的索引表的指针。<li>文件的各种属性。<li>与信号驱动相关设置。</ol><li><p><strong>文件系统i-node表</strong></p> <p>记录内容如下：</p> <ol><li>文件类型。<li>文件锁。</ol></ul><h4 id=文件描述符限制><a class=headerlink href=#文件描述符限制 title=文件描述符限制></a>文件描述符限制</h4><p><strong>理论上可以打开多少个文件描述符取决于系统内存的大小，但内核会有系统级限制，以及用户级限制</strong>（限制某个应用消耗掉所有文件资源，可使用ulimit -n 查看）。<p><strong>用户级限制</strong><ul><li><p>查看</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>ulimit</span> -n</span><br></pre></table></figure><li><p>修改</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># 重启后失效</span></span><br><span class=line><span class=built_in>ulimit</span> -SHn 65535</span><br><span class=line><span class=comment># 永久生效</span></span><br><span class=line>修改配置文件/etc/security/limits.conf，在最后一行加入：* - nofile 65535</span><br></pre></table></figure></ul><p><strong>系统级限制</strong><ul><li><p>查看</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>sysctl -a | grep -i file-max --color;</span><br><span class=line>---</span><br><span class=line><span class=built_in>cat</span> /proc/sys/fs/file-max</span><br></pre></table></figure><li><p>修改</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment># 重启后失效</span></span><br><span class=line>sysctl -w fs.file-max=65535;</span><br><span class=line>---</span><br><span class=line><span class=built_in>echo</span> 65535 > /proc/sys/fs/file-max</span><br><span class=line></span><br><span class=line><span class=comment>#永久生效</span></span><br><span class=line>修改配置文件/etc/sysctl.conf，在最后一行加入fs.file-max=65535。</span><br><span class=line>执行访问，触发生效。</span><br><span class=line>sysctl -p</span><br></pre></table></figure></ul><h3 id=2-1-5、缓存I-O><a class=headerlink href=#2-1-5、缓存I-O title=2.1.5、缓存I/O></a>2.1.5、缓存I/O</h3><p><strong>缓存 I/O 又被称作 标准 I/O，大多数文件系统的默认 I/O 都是缓存 I/O</strong>。<p>Linux 缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据先被拷贝至系统内核的缓冲区中，然后再拷贝到应用程序的地址空间。<h3 id=2-1-6、IO多路复用简介><a class=headerlink href=#2-1-6、IO多路复用简介 title=2.1.6、IO多路复用简介></a>2.1.6、IO多路复用简介</h3><p>IO多路复用是指：<strong>内核一旦发现进程指定的一个或者多个IO条件符合要求时就会通知该进程</strong>。<p>与多进程和多线程技术相比，I/O多路复用的最大优势就是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。<p>目前支持I/O多路复用的系统调用有 <code>select、pselect、poll、epoll</code>，I/O多路复用就是通过一种机制来实现一个进程监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作<code>。</code><p><code>select、pselect、poll、epoll</code>本质上都是同步I/O，需要在读写事件就绪后自己负责进行读写，这个读写过程是阻塞的，而异步I/O无需自己读写，其实现会自动把数据从内核拷贝到用户空间。<p><code>epoll</code>跟<code>select</code>都能提供I/O多路复用的解决方案。现在的Linux内核都能支持，其中<code>epoll</code>是Linux所特有，而<code>select</code>则是<code>POSIX</code>所规定，一般操作系统均有实现。<p><strong>select，poll，epoll都是I/O多路复用的具体实现，他们的出现有先后顺序</strong>。<h2 id=2-2、select（1983）><a class=headerlink href=#2-2、select（1983） title=2.2、select（1983）></a>2.2、select（1983）</h2><p>**I/O多路复用被提出来后，select是第一个实现 (1983 左右在BSD里实现)**。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>int</span> <span class="title function_">select</span> <span class=params>(<span class=type>int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span>;</span><br></pre></table></figure><h3 id=2-2-1、原理><a class=headerlink href=#2-2-1、原理 title=2.2.1、原理></a>2.2.1、原理</h3><p><code>select</code>函数监视的文件描述符分3类，分别是<code>writefds、readfds、exceptfds</code>。调用select函数后会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（<code>timeout</code>指定等待时间，如果立即返回设为<code>null</code>即可）后函数才返回。当select函数返回后，只能通过遍历<code>fdset</code>，来找到就绪的描述符。<h3 id=2-2-2、优缺点><a class=headerlink href=#2-2-2、优缺点 title=2.2.2、优缺点></a>2.2.2、优缺点</h3><h4 id=优点><a class=headerlink href=#优点 title=优点></a>优点</h4><p><strong><code>select</code>目前几乎在所有的平台上都支持，良好的跨平台特性也是它的一个优点</strong>。<h4 id=缺点><a class=headerlink href=#缺点 title=缺点></a>缺点</h4><ol><li><strong>select 会修改传入的参数数组</strong>。这个对于一个需要调用很多次的函数，是非常不友好的。<li>select 中的任何一个sock(I/O stream)出现了数据，<strong>select 仅仅会返回，但并不告诉你哪个sock上有数据</strong>，于是只能遍历一遍才能找到，这开销可想而知。<li><strong>select 只能监视1024个链接</strong>。这个和草榴没啥关系，linux 定义在头文件中的，参见<em>FD_SETSIZE。</em><li><strong>select 线程不安全</strong>。如果你把一个sock加入到select，然后突然另外一个线程发现，尼玛，这个sock不用，要收回。对不起，这个select不支持的，如果你丧心病狂的竟然关掉这个sock，select的标准行为是。呃。不可预测的，这个可是写在文档中的哦。</ol><h2 id=2-3、poll（1997）><a class=headerlink href=#2-3、poll（1997） title=2.3、poll（1997）></a>2.3、poll（1997）</h2><p><strong>1997年实现了poll</strong>。<p>与select使用三个位图来表示三个<code>fdset</code>的方式不同，poll使用一个<code>pollfd</code>指针实现。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>struct pollfd {</span><br><span class=line>    <span class=type>int</span> fd; <span class=comment>/* file descriptor */</span></span><br><span class=line>    <span class=type>short</span> events; <span class=comment>/* requested events to watch */</span></span><br><span class=line>    <span class=type>short</span> revents; <span class=comment>/* returned events witnessed */</span></span><br><span class=line>};</span><br></pre></table></figure><p>pollfd结构包含了要监视的 event 和发生的 event，不再使用 select的 “参数-值”传递方式。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>int</span> <span class="title function_">poll</span> <span class=params>(struct pollfd *fds, unsigned <span class=type>int</span> nfds, <span class=type>int</span> timeout)</span>;</span><br></pre></table></figure><h3 id=2-3-1、原理><a class=headerlink href=#2-3-1、原理 title=2.3.1、原理></a>2.3.1、原理</h3><p><code>poll</code>本质上和<code>select</code>没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历。如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时。挂起的线程被唤醒后会再次遍历fd。这个过程经历了多次无意义的遍历。<h3 id=2-3-2、优缺点><a class=headerlink href=#2-3-2、优缺点 title=2.3.2、优缺点></a>2.3.2、优缺点</h3><h4 id=优点-1><a class=headerlink href=#优点-1 title=优点></a>优点</h4><ol><li><strong>没有最大连接数的限制</strong>，因为是基于链表来存储。<li><strong>不再修改传入数组，不过这个要看平台了</strong>，所以小心为妙。</ol><h4 id=缺点-1><a class=headerlink href=#缺点-1 title=缺点></a>缺点</h4><ol><li>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。<li><strong><code>poll</code>有一个特点是“水平触发</strong>。如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。<li>线程非安全。</ol><h4 id=注意事项><a class=headerlink href=#注意事项 title=注意事项></a>注意事项</h4><p>从上面看，<code>select</code>和<code>poll</code>都需要在返回后通过遍历文件描述符来获取已经就绪的<code>socket</code>。事实上，同时连接的大量客户端可能只有很少数处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。<h2 id=2-4、epoll（2002）><a class=headerlink href=#2-4、epoll（2002） title=2.4、epoll（2002）></a>2.4、epoll（2002）</h2><h3 id=2-4-1、简介><a class=headerlink href=#2-4-1、简介 title=2.4.1、简介></a>2.4.1、简介</h3><p><strong>2002，大神 Davide Libenzi 实现了epoll，在内核2.6中提出</strong>。<p>epoll 是 select 和 poll 的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。<strong>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次</strong>。<h3 id=2-4-2、原理><a class=headerlink href=#2-4-2、原理 title=2.4.2、原理></a>2.4.2、原理</h3><p><strong><code>epoll</code>支持水平触发和边缘触发</strong>。最大特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是<code>epoll</code>使用“事件”就绪通知的方式，通过<code>epoll_ctl</code>注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。<h3 id=2-4-3、工作过程><a class=headerlink href=#2-4-3、工作过程 title=2.4.3、工作过程></a>2.4.3、工作过程</h3><p>epoll操作过程需要三个接口，分别如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>int</span> <span class="title function_">epoll_create</span><span class=params>(<span class=type>int</span> size)</span>；<span class=comment>// 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span></span><br><span class=line><span class=type>int</span> <span class="title function_">epoll_ctl</span><span class=params>(<span class=type>int</span> epfd, <span class=type>int</span> op, <span class=type>int</span> fd, struct epoll_event *event)</span>；</span><br><span class=line><span class=type>int</span> <span class="title function_">epoll_wait</span><span class=params>(<span class=type>int</span> epfd, struct epoll_event * events, <span class=type>int</span> maxevents, <span class=type>int</span> timeout)</span>;</span><br></pre></table></figure><p><strong>（1）epoll_create(int size)</strong><p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。 当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。<p>*<em>（2）epoll_ctl(int epfd, int op, int fd, struct epoll_event <em>event)</em></em><ul><li><p>epfd：是epoll_create()的返回值。</p><li><p>op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</p><li><p>fd：是需要监听的fd（文件描述符）</p><li><p>epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>struct epoll_event {</span><br><span class=line>    __uint32_t events; </span><br><span class=line>    <span class=comment>/* Epoll events / epoll_data_t data; / User data variable */</span> </span><br><span class=line>};</span><br></pre></table></figure> <p>events可以是以下几个宏的集合：</p> <ol><li><font color=orange>EPOLLIN </font>：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；<li><font color=orange>EPOLLOUT</font>：表示对应的文件描述符可以写；<li><font color=orange>EPOLLPRI</font>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<li><font color=orange>EPOLLERR</font>：表示对应的文件描述符发生错误；<li><font color=orange>EPOLLHUP</font>：表示对应的文件描述符被挂断；<li><font color=orange>EPOLLET</font>： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。<li><font color=orange>EPOLLONESHOT</font>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。</ol></ul><p><strong>（3）epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)</strong><p>等待epfd上的io事件，最多返回maxevents个事件。 参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。<h3 id=2-4-4、优缺点><a class=headerlink href=#2-4-4、优缺点 title=2.4.4、优缺点></a>2.4.4、优缺点</h3><p><strong>优点</strong><ol><li>没有最大并发连接的限制，能打开的FD上限远大于1024（1G的内存上能监听约10万个端口）。<li>线程安全。<li>效率提升，它并不采用轮询的方式，不会随着FD数目的增加而效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。<li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</ol><p><strong>缺点</strong>：只有linux支持epoll。比如BSD上面的实现是kqueue。<h3 id=2-4-5、工作模式><a class=headerlink href=#2-4-5、工作模式 title=2.4.5、工作模式></a>2.4.5、工作模式</h3><p><strong>epoll对文件描述符的操作有两种模式：LT（level trigger，水平触发，默认）和 ET（edge trigger，边缘触发）</strong>。两者的区别如下：<ul><li><p><strong>LT模式（事件发生就通知你，你不管，那就一直通知你）</strong></p> <p>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p> <p><code>LT(level triggered)</code>是默认的工作方式，并且同时支持<code>block和no-block socket</code>。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的`。</p><li><p><strong>ET模式（事件发生就通知你，你不管，那不好意思，只会通知一次）</strong></p> <p>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p> <p><code>ET(edge-triggered)</code>是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)。</p> <p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式下时必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p></ul><p>如果存在大量活跃连接，select/poll效率会较高一点，但如果活跃连接数量较少，那么epoll的效率会高于select/poll。<h2 id=2-5、kqueue><a class=headerlink href=#2-5、kqueue title=2.5、kqueue></a>2.5、kqueue</h2><h3 id=2-5-1、简介><a class=headerlink href=#2-5-1、简介 title=2.5.1、简介></a>2.5.1、简介</h3><p>与 epoll 类似，仅存于 FreeBSD（一种类UNIX操作系统）。<h2 id=2-6、总结><a class=headerlink href=#2-6、总结 title=2.6、总结></a>2.6、总结</h2><h3 id=2-6-1、select、poll、epoll区别><a class=headerlink href=#2-6-1、select、poll、epoll区别 title=2.6.1、select、poll、epoll区别></a>2.6.1、select、poll、epoll区别</h3><ol><li><p>一个进程所能打开的最大连接数</p> <p><img alt=select-poll-epoll区别_一个进程支持的最大连接数01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/select-poll-epoll%E5%8C%BA%E5%88%AB_%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%94%AF%E6%8C%81%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B001.png?token=AIGEF3L5JFBKQGWZRDVHKEDEZZWE2></p><li><p>FD剧增后带来的IO效率问题</p> <p><img alt=select-poll-epoll区别_FD剧增后带来的效率问题01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/select-poll-epoll%E5%8C%BA%E5%88%AB_FD%E5%89%A7%E5%A2%9E%E5%90%8E%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%9801.png?token=AIGEF3IBWIKHFGDH77RBSP3EZZWGO></p><li><p>消息传递方式</p> <p><img alt=select-poll-epoll区别_消息传递方式01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/select-poll-epoll%E5%8C%BA%E5%88%AB_%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F01.png?token=AIGEF3P4I6JR72ZXBU2H6Z3EZZWIK></p></ol><h3 id=2-6-2、场景助记><a class=headerlink href=#2-6-2、场景助记 title=2.6.2、场景助记></a>2.6.2、场景助记</h3><p>一个epoll场景：一个酒吧服务员（一个线程），前面趴了一群醉汉，突然一个吼一声“倒酒”（事件），你小跑过去给他倒一杯，然后随他去吧，突然又一个要倒酒，你又过去倒上，就这样一个服务员服务好多人，有时没人喝酒，服务员处于空闲状态，可以玩玩手机。<p>至于epoll与select，poll的区别在于后两者的场景中醉汉不说话，你要挨个问要不要酒，没时间玩手机了。I/O多路复用大概就是指这几个醉汉共用一个服务员。<h3 id=2-6-3、三者如何选择><a class=headerlink href=#2-6-3、三者如何选择 title=2.6.3、三者如何选择></a>2.6.3、三者如何选择</h3><ol><li>通常<code>epoll</code>性能最好，但在连接数少且连接都十分活跃的情况下，<code>select</code>和<code>poll</code>的性能可能要比<code>epoll</code>要好，毕竟<code>epoll</code>的通知机制需要很多函数回调。<li><code>select</code>低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计进行改善。</ol><h1 id=3、BIO（Blocking-Input-Output）><a title="3、BIO（Blocking Input/Output）" class=headerlink href=#3、BIO（Blocking-Input-Output）></a>3、BIO（Blocking Input/Output）</h1><h2 id=3-1、简介><a class=headerlink href=#3-1、简介 title=3.1、简介></a>3.1、简介</h2><p>BIO是一个同步阻塞IO。同步阻塞I/O模式下，数据的读取写入必须阻塞并等待其完成。<p>通过经典的烧开水例子来帮助理解，这里假设一个烧开水的场景，有一排水壶在烧开水，BIO的工作模式就是， 叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。但是实际上线程在等待水壶烧开的时间段什么都没有做。<h2 id=3-2、特点><a class=headerlink href=#3-2、特点 title=3.2、特点></a>3.2、特点</h2><ol><li><strong>一个线程对应一个请求。</strong></ol><h2 id=3-3、阻塞方法><a class=headerlink href=#3-3、阻塞方法 title=3.3、阻塞方法></a>3.3、阻塞方法</h2><ol><li>InputStream.read()<li>OutputStream.write()<li>ServerSocket.accept()</ol><h2 id=3-4、优缺点><a class=headerlink href=#3-4、优缺点 title=3.4、优缺点></a>3.4、优缺点</h2><ul><li><p>优点：（同步、使用复杂。）</p> <p>BIO模型程序开发起来较为简单，易于把握。（因为这是最基本与简单的I/O操作方式，其根本特性是做完一件事再去做另一件事，一件事一定要等前一件事做完，这很符合程序员传统的顺序开发思想。）</p><li><p>缺点：（阻塞、同步，三次握手耗时。）</p> <p>BIO模型下的线程阻塞会导致线程的频繁切换，进而影响整个系统性能。因为BIO模型下，一个线程同时只能做一个工作，如果线程在执行过程中依赖于需要等待的资源，那么该线程会长期处于阻塞状态，我们知道在整个操作系统中，线程是系统执行的基本单位。</p></ul><h2 id=3-5、使用场景><a class=headerlink href=#3-5、使用场景 title=3.5、使用场景></a>3.5、使用场景</h2><p>BIO方式适用于连接数量少且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。<h2 id=3-6、注意事项><a class=headerlink href=#3-6、注意事项 title=3.6、注意事项></a>3.6、注意事项</h2><p>系统开发中，线程的生命周期一定要准确控制，对于大并发的场景，尽量使用线程池来确保线程的创建数量在一个合理范围之内，切勿编写代码来限制线程创建上限。<h1 id=4、NIO（New-Input-Output）><a title="4、NIO（New Input/Output）" class=headerlink href=#4、NIO（New-Input-Output）></a>4、NIO（New Input/Output）</h1><h2 id=4-1、简介><a class=headerlink href=#4-1、简介 title=4.1、简介></a>4.1、简介</h2><p><strong>NIO是同步非阻塞I/O模型，Java 1.4 中引入 NIO 框架，对应 java.nio 包，提供了Channel , Selector，Buffer等抽象类</strong>。<p><strong>NIO中的N可以理解为Non-blocking，而不单纯是New</strong>。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种套接字通道实现，两种通道都支持阻塞和非阻塞两种模式。<p>阻塞模式比较简单，但性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 非阻塞模式来应对。<p><strong>NIO编程中，需要理解3个对象：Channel、Buffer和Selector</strong>。<h2 id=4-2、Channel><a class=headerlink href=#4-2、Channel title=4.2、Channel></a>4.2、Channel</h2><p>Channel和IO中的Stream(流)差不多。只不过Stream是单向的，譬如：InputStream, OutputStream。而Channel是双向的，既可以用来进行读操作，又可以用来进行写操作，NIO中的Channel实现有：<ol><li>FileChannel——文件IO<li>DatagramChannel——UDP<li>SocketChannel——TCP Client<li>ServerSocketChannel——TCP Server</ol><h2 id=4-3、Buffer><a class=headerlink href=#4-3、Buffer title=4.3、Buffer></a>4.3、Buffer</h2><p>NIO中的Buffer实现有：ByteBuffer、CharBuffer、DoubleBuffer、 FloatBuffer、IntBuffer、 LongBuffer、ShortBuffer，分别对应基本数据类型: byte、char、double、 float、int、 long、 short。当然NIO中还有MappedByteBuffer、HeapByteBuffer、DirectByteBuffer等。<h3 id=4-3-1、DirectByteBuffer-VS-HeapByteBuffer><a title="4.3.1、DirectByteBuffer VS HeapByteBuffer" class=headerlink href=#4-3-1、DirectByteBuffer-VS-HeapByteBuffer></a>4.3.1、DirectByteBuffer VS HeapByteBuffer</h3><p>它们是ByteBuffer分配内存的两种方式。<ol><li>HeapByteBuffer内存空间在JVM堆上分配，可以看做是jdk对于byte[]数组的封装；而DirectByteBuffer则直接利用了系统接口进行内存申请，其内存分配在C的heap中，这样就减少了内存之间的拷贝操作，如此一来，在使用 DirectByteBuffer 时，系统就可以直接从内存将数据写入到Channel中，而无需进行Java堆的内存申请，复制等操作，提高了性能。<li>DirectByteBuffer使用起来相对于完全托管于Java内存管理的HeapByteBuffer来说更复杂一些，如果用不好可能会引起OOM。因为DirectByteBuffer通过FGC来回收内存，且会自己检测情况是否调用system.gc()。如果参数中使用了DisableExplicitGC那么就无法回收该快内存了，-XX:+DisableExplicitGC标志会让System.gc()方法失效，失效后如果还想回收就需要我们手动来回收内存了。<li>DirectByteBuffer的内存大小受 -XX:MaxDirectMemorySize JVM参数控制（默认大小64M），在 DirectByteBuffer申请内存空间达到该设置大小后，会触发FGC。</ol><h2 id=4-4、Selector><a class=headerlink href=#4-4、Selector title=4.4、Selector></a>4.4、Selector</h2><h3 id=4-4-1、简介><a class=headerlink href=#4-4-1、简介 title=4.4.1、简介></a>4.4.1、简介</h3><p><strong>Selector通过单线程处理多个Channel，适用于多连接流量低的场景</strong>。<h3 id=4-4-2、优缺点><a class=headerlink href=#4-4-2、优缺点 title=4.4.2、优缺点></a>4.4.2、优缺点</h3><h3 id=4-4-3、使用场景><a class=headerlink href=#4-4-3、使用场景 title=4.4.3、使用场景></a>4.4.3、使用场景</h3><p>NIO适用于连接数多且连接较短的场景，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。<h2 id=4-5、总结><a class=headerlink href=#4-5、总结 title=4.5、总结></a>4.5、总结</h2><h3 id=4-5-1、NIO特性-NIO与IO的区别><a class=headerlink href=#4-5-1、NIO特性-NIO与IO的区别 title=4.5.1、NIO特性/NIO与IO的区别></a>4.5.1、NIO特性/NIO与IO的区别</h3><ul><li><p>Non-Blocking IO：IO流是阻塞的，NIO流不阻塞。</p><li><p>Buffer（缓冲区）：IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。</p> <p>Buffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。</p><li><p>Channel（通道）：NIO 基于通道进行读写。通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互，故可以异步地读写。</p><li><p>Selector（选择器）：NIO有选择器，而IO没有。</p></ul><h3 id=4-5-2、NIO-VS-BIO><a title="4.5.2、NIO VS BIO" class=headerlink href=#4-5-2、NIO-VS-BIO></a>4.5.2、NIO VS BIO</h3><ol><li>BIO以流的方式处理数据，而NIO以块的方式处理数据。块IO的效率要比流IO高。<li>BIO是阻塞的，而NIO非阻塞。<li>BIO基于字节流和字符流进行操作，而NIO基于Channel和Buffer进行操作，数据既可以从Channel读到Buffer中，也可以从Buffer写入Channel中。Selector可用单个线程监听多个客户端。</ol><h1 id=5、AIO（Asynchronous-Input-Output）><a title="5、AIO（Asynchronous Input/Output）" class=headerlink href=#5、AIO（Asynchronous-Input-Output）></a>5、AIO（Asynchronous Input/Output）</h1><h2 id=5-1、简介><a class=headerlink href=#5-1、简介 title=5.1、简介></a>5.1、简介</h2><p>AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2，它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。<p>AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。（除了 AIO 其他的 IO 类型都是同步的，这一点可以从底层IO线程模型解释。<h2 id=5-2、特点><a class=headerlink href=#5-2、特点 title=5.2、特点></a>5.2、特点</h2><p>在进行IO操作时，不需要阻塞等待操作完成，期间可以执行其它操作，一旦操作完成会直接返回结果给你。<h2 id=5-3、优缺点><a class=headerlink href=#5-3、优缺点 title=5.3、优缺点></a>5.3、优缺点</h2><p>优点：提升IO操作的效率和系统的并发性能。<p>缺点：系统对其的支持不够完善，且实现较为复杂，只适用于大数据量的IO操作场景。<h2 id=5-4、使用场景><a class=headerlink href=#5-4、使用场景 title=5.4、使用场景></a>5.4、使用场景</h2><p>AIO方式适用于连接数目多且连接较长的场景，比如相册服务器。JDK7开始支持。<h1 id=6、IO多路复用模式><a class=headerlink href=#6、IO多路复用模式 title=6、IO多路复用模式></a>6、IO多路复用模式</h1><p>一般地，I/O多路复用机制都依赖于一个事件多路分离器(Event Demultiplexer)。分离器对象可将 来自事件源的I/O事件分离出来，然后分发到对应的read/write事件处理器(Event Handler)。开发人员预先注册需要处理的事件及其事件处理器（或回调函数）；事件分离器负责将请求事件传递给事件处理器。<p>两个与事件分离器有关的模式是Reactor和Proactor。Reactor模式采用同步IO，而Proactor采用异步IO。<p>在Reactor中，事件分离器负责 等待 文件描述符或socket为读写操作 准备就绪，然后将就绪事件传递给对应的处理器，最后由处理器负责完成实际的读写工作。<p>在Proactor中，处理器或兼任处理器的事件分离器，只负责发起异步读写操作。IO操作本身由操作系统来完成。传递给操作系统的参数需要包含用户定义的数据缓冲区地址和数据大小，操作系统才能从中得到写出操作所需数据，或写入从socket读到的数据。事件分离器捕获IO操作完成事件，然后将事件传递给对应事件处理器。比如，在windows上，处理器发起一个异步IO操作，再由事件分离器等待IOCompletion事件。典型的异步模式实现，都建立在操作系统支持异步API的基础之上，我们将这种实现称为“系统级”异步或“真”异步，因为应用程序完全依赖操作系统执行真正的IO工作。<h2 id=6-1、Reactor模式><a class=headerlink href=#6-1、Reactor模式 title=6.1、Reactor模式></a>6.1、Reactor模式</h2><h3 id=6-x-1、读操作><a class=headerlink href=#6-x-1、读操作 title=6.x.1、读操作></a>6.x.1、读操作</h3><ol><li>注册读就绪事件和相关的事件处理器。<li>事件分离器等待事件发生。<li>当读就绪事件发生时，事件分离器调用第一步中的事件处理器。<li>事件处理器首先执行读取操作，处理读到的数据，注册新的事件，然后返还控制权。</ol><h3 id=6-x-2、写操作><a class=headerlink href=#6-x-2、写操作 title=6.x.2、写操作></a>6.x.2、写操作</h3><p>写入操作类似于读取操作，只不过第一步注册的是写就绪事件。<h3 id=6-x-3、class结构><a class=headerlink href=#6-x-3、class结构 title=6.x.3、class结构></a>6.x.3、class结构</h3><p><img alt=image-20210130120424783 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210130120424783.png?token=AIGEF3LVAGFSNH77T3MR2Z3EZZWKI><p>Reactor包含如下角色：<ul><li>Handle 句柄；用来标识socket连接或是打开文件；<li>Synchronous Event Demultiplexer：同步事件多路分解器：由操作系统内核实现的一个函数；用于阻塞等待发生在句柄集合上的一个或多个事件；（如select/epoll；）<li>Event Handler：事件处理接口<li>Concrete Event HandlerA：实现应用程序所提供的特定事件处理逻辑；<li>Reactor：反应器，定义一个接口，实现以下功能：<ol><li>供应用程序注册和删除关注的事件句柄；<li>运行事件循环；<li>有就绪事件到来时，分发事件到之前注册的回调函数上处理；</ol></ul><p>具体事件处理程序不调用反应器，而是由反应器分配一个具体事件处理程序，具体事件处理程序对某个指定的事件发生做出反应；这种控制逆转又称为“好莱坞法则”（不要调用我，让我来调用你）。<p>业务流程时序图：<p><img alt=image-20210130120745134 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210130120745134.png?token=AIGEF3NURLY36AQHY2JQLJDEZZWLK><ol><li>应用启动，将关注的事件handle注册到Reactor中；<li>调用Reactor，进入无限事件循环，等待注册的事件到来；<li>事件到来，select返回，Reactor将事件分发到之前注册的回调函数中处理；</ol><h2 id=6-2、Proactor模式><a class=headerlink href=#6-2、Proactor模式 title=6.2、Proactor模式></a>6.2、Proactor模式</h2><h3 id=6-x-1、读操作-1><a class=headerlink href=#6-x-1、读操作-1 title=6.x.1、读操作></a>6.x.1、读操作</h3><ol><li>应用程序初始化一个异步读取操作，然后注册事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。<li>事件分离器等待读取操作完成事件。<li>在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作（异步IO都是操作系统负责将数据读写到应用传递进来的缓冲区供应用程序操作，操作系统扮演了重要角色），并将读取的内容放入用户传递过来的缓存区中。Proactor中，应用程序需要传递缓存区，这也是区别于Reactor的一点。<li>事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。</ol><h3 id=6-x-2、写操作-1><a class=headerlink href=#6-x-2、写操作-1 title=6.x.2、写操作></a>6.x.2、写操作</h3><p>写操作与读操作类似。<h3 id=6-x-3、class结构-1><a class=headerlink href=#6-x-3、class结构-1 title=6.x.3、class结构></a>6.x.3、class结构</h3><p><img alt=image-20210130121111912 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210130121111912.png?token=AIGEF3P7PCE73Q4G6GRF7C3EZZWMM><p><strong>Proactor主动器模式包含如下角色</strong><ul><li>Handle 句柄；用来标识socket连接或是打开文件；<li>Asynchronous Operation Processor：异步操作处理器；负责执行异步操作，一般由操作系统内核实现；<li>Asynchronous Operation：异步操作;<li>Completion Event Queue：完成事件队列；异步操作完成的结果放到队列中等待后续使用;<li>Proactor：主动器；为应用程序进程提供事件循环；从完成事件队列中取出异步操作的结果，分发调用相应的后续处理逻辑；<li>Completion Handler：完成事件接口；一般是由回调函数组成的接口；<li>Concrete Completion Handler：完成事件处理逻辑；实现接口定义特定的应用处理逻辑；</ul><p>业务流程时序图：<p><img alt=image-20210130121212731 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210130121212731.png?token=AIGEF3J26FNDQI3N67MR2ZTEZZWNQ><ol><li>应用程序启动，调用异步操作处理器提供的异步操作接口函数，调用之后应用程序和异步操作处理就独立运行；应用程序可以调用新的异步操作，而其它操作可以并发进行；<li>应用程序启动Proactor主动器，进行无限的事件循环，等待完成事件到来；<li>异步操作处理器执行异步操作，完成后将结果放入到完成事件队列；<li>主动器从完成事件队列中取出结果，分发到相应的完成事件回调函数处理逻辑中；</ol><h2 id=6-3、总结><a class=headerlink href=#6-3、总结 title=6.3、总结></a>6.3、总结</h2><h3 id=6-3-1、主动与被动><a class=headerlink href=#6-3-1、主动与被动 title=6.3.1、主动与被动></a>6.3.1、主动与被动</h3><p>以主动写为例：<ul><li>Reactor将handle放到select()，等待可写就绪，然后调用write()写入数据；写完后 处理后续逻辑；<li>Proactor调用aoi_write后立刻返回，由内核负责写操作，写完后调用相应的回调函数处理后续逻辑；</ul><h3 id=6-3-2、实现><a class=headerlink href=#6-3-2、实现 title=6.3.2、实现></a>6.3.2、实现</h3><p>Reactor实现了一个被动的事件分离和分发模型，服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应。<p>Proactor实现了一个主动的事件分离和分发模型；这种设计允许多个任务并发执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响）。<h3 id=6-3-3、优劣><a class=headerlink href=#6-3-3、优劣 title=6.3.3、优劣></a>6.3.3、优劣</h3><h4 id=优点-2><a class=headerlink href=#优点-2 title=优点></a>优点</h4><ul><li>Reactor<ol><li>Reactor实现相对简单，对于耗时短的处理场景处理高效；<li>操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性；<li>事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁；<li>事务分离：将与应用无关的多路分解、分配机制 和 与应用相关的回调函数 分离开来。</ol><li>Proactor<ol><li>Proactor性能更高，能够处理耗时长的并发场景；</ol></ul><h4 id=缺点-2><a class=headerlink href=#缺点-2 title=缺点></a>缺点</h4><ul><li><p>Reactor：Reactor处理耗时长的操作会造成事件分发的阻塞，影响后续事件的处理；</p><li><p>Proactor</p> <ol><li>Proactor实现逻辑复杂；<li>依赖操作系统对异步的支持；（目前纯异步的操作系统较少，但有优秀实现如windows IOCP，但由于windows系统用于服务器的局限性，目前应用范围较小；）<li>Unix/Linux系统对纯异步支持有限，应用事件驱动的主流还是通过select/epoll来实现；</ol></ul><h3 id=6-3-4、适用场景><a class=headerlink href=#6-3-4、适用场景 title=6.3.4、适用场景></a>6.3.4、适用场景</h3><ul><li><p>Reactor：同时接收多个服务请求，且依次同步处理它们的事件驱动程序；</p><li><p>Proactor：异步接收和同时处理多个服务请求的事件驱动程序；</p></ul></div><footer class=post-footer><div class=post-tags><a href=/tags/IO/ rel=tag># IO</a></div><div class=post-nav><div class=post-nav-item><a href=/2024/08/21/HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ rel=prev title=计算机系列-HTTP基础知识> <i class="fa fa-angle-left"></i> 计算机系列-HTTP基础知识 </a></div><div class=post-nav-item><a href=/2024/08/21/IP%E5%9B%BE%E8%A1%A8%E8%A7%A3%E6%9E%90/ rel=next title=计算机系列-IP图表分析> 计算机系列-IP图表分析 <i class="fa fa-angle-right"></i> </a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script>