<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hgprivate.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="1、Eureka1.1、Eureka底层原理1.1.1、服务注册1.1.1.1、注册时机客户端 主动注册自己 的两种情况：  客户端刚启动时； 客户端 instance信息 发生变化时；  1.1.1.2、定时器注册com.netflix.discovery.DiscoveryClient使用的@Inject //google guice 注入，遵循 JSR-330 规范。 1" name=description><meta content=article property=og:type><meta content=Eureka系列-Eureka原理解析 property=og:title><meta content=https://hgprivate.github.io/2024/08/21/Eureka%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content="1、Eureka1.1、Eureka底层原理1.1.1、服务注册1.1.1.1、注册时机客户端 主动注册自己 的两种情况：  客户端刚启动时； 客户端 instance信息 发生变化时；  1.1.1.2、定时器注册com.netflix.discovery.DiscoveryClient使用的@Inject //google guice 注入，遵循 JSR-330 规范。 1" property=og:description><meta content=zh_CN property=og:locale><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Eureka-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Eureka-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E5%9B%BE.jpg property=og:image><meta content=2024-08-21T13:39:13.634Z property=article:published_time><meta content=2023-09-23T12:36:01.846Z property=article:modified_time><meta content=豪哥 property=article:author><meta content=Eureka property=article:tag><meta content=Eureka原理 property=article:tag><meta content=summary name=twitter:card><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Eureka-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg name=twitter:image><link href=https://hgprivate.github.io/2024/08/21/Eureka%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hgprivate.github.io/2024/08/21/Eureka%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","path":"2024/08/21/Eureka底层原理/","title":"Eureka系列-Eureka原理解析"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>Eureka系列-Eureka原理解析 | 豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>豪哥博客</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#1%E3%80%81Eureka><span class=nav-number>1.</span> <span class=nav-text>1、Eureka</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81Eureka%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86><span class=nav-number>1.1.</span> <span class=nav-text>1.1、Eureka底层原理</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-1%E3%80%81%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C><span class=nav-number>1.1.1.</span> <span class=nav-text>1.1.1、服务注册</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-1-1%E3%80%81%E6%B3%A8%E5%86%8C%E6%97%B6%E6%9C%BA><span class=nav-number>1.1.1.1.</span> <span class=nav-text>1.1.1.1、注册时机</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-1-2%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8%E6%B3%A8%E5%86%8C><span class=nav-number>1.1.1.2.</span> <span class=nav-text>1.1.1.2、定时器注册</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-1-3%E3%80%81%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%86%8C><span class=nav-number>1.1.1.3.</span> <span class=nav-text>1.1.1.3、自动注册</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-1-4%E3%80%81%E5%A4%84%E7%90%86%E6%B3%A8%E5%86%8C%E8%AF%B7%E6%B1%82><span class=nav-number>1.1.1.4.</span> <span class=nav-text>1.1.1.4、处理注册请求</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-1-5%E3%80%81%E9%87%8D%E6%96%B0%E6%B3%A8%E5%86%8C><span class=nav-number>1.1.1.5.</span> <span class=nav-text>1.1.1.5、重新注册</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-1-6%E3%80%81%E6%80%BB%E7%BB%93><span class=nav-number>1.1.1.6.</span> <span class=nav-text>1.1.1.6、总结</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-2%E3%80%81%E6%9C%8D%E5%8A%A1%E6%8B%89%E5%8F%96><span class=nav-number>1.1.2.</span> <span class=nav-text>1.1.2、服务拉取</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-2-1%E3%80%81%E6%8B%89%E5%8F%96%E6%96%B9%E5%BC%8F><span class=nav-number>1.1.2.1.</span> <span class=nav-text>1.1.2.1、拉取方式</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-2-2%E3%80%81%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0><span class=nav-number>1.1.2.2.</span> <span class=nav-text>1.1.2.2、注册表数据更新</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-2-3%E3%80%81%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6><span class=nav-number>1.1.2.3.</span> <span class=nav-text>1.1.2.3、多级缓存机制</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-2-4%E3%80%81%E5%A2%9E%E9%87%8F%E5%85%A8%E9%87%8F%E6%8B%89%E5%8F%96><span class=nav-number>1.1.2.4.</span> <span class=nav-text>1.1.2.4、增量全量拉取</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-2-5%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9><span class=nav-number>1.1.2.5.</span> <span class=nav-text>1.1.2.5、注意事项</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-2-6%E3%80%81%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0><span class=nav-number>1.1.2.6.</span> <span class=nav-text>1.1.2.6、重要参数</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-3%E3%80%81%E6%9C%8D%E5%8A%A1%E7%BB%AD%E7%BA%A6><span class=nav-number>1.1.3.</span> <span class=nav-text>1.1.3、服务续约</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-3-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.1.3.1.</span> <span class=nav-text>1.1.3.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-3-2%E3%80%81%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0><span class=nav-number>1.1.3.2.</span> <span class=nav-text>1.1.3.2、重要参数</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-4%E3%80%81%E6%9C%8D%E5%8A%A1%E5%88%A0%E9%99%A4><span class=nav-number>1.1.4.</span> <span class=nav-text>1.1.4、服务删除</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-4-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.1.4.1.</span> <span class=nav-text>1.1.4.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-4-2%E3%80%81%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0><span class=nav-number>1.1.4.2.</span> <span class=nav-text>1.1.4.2、重要参数</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-5%E3%80%81%E6%9C%8D%E5%8A%A1%E4%B8%8B%E7%BA%BF><span class=nav-number>1.1.5.</span> <span class=nav-text>1.1.5、服务下线</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-5-1%E3%80%81%E4%B8%BB%E5%8A%A8%E4%B8%8B%E7%BA%BF><span class=nav-number>1.1.5.1.</span> <span class=nav-text>1.1.5.1、主动下线</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-5-2%E3%80%81%E7%8A%B6%E6%80%81%E5%8F%98%E6%9B%B4><span class=nav-number>1.1.5.2.</span> <span class=nav-text>1.1.5.2、状态变更</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-6%E3%80%81%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8><span class=nav-number>1.1.6.</span> <span class=nav-text>1.1.6、远程调用</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-7%E3%80%81%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6><span class=nav-number>1.1.7.</span> <span class=nav-text>1.1.7、自我保护机制</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-7-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.1.7.1.</span> <span class=nav-text>1.1.7.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-7-2%E3%80%81%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E5%8A%9F%E8%83%BD><span class=nav-number>1.1.7.2.</span> <span class=nav-text>1.1.7.2、自我保护机制功能</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-7-3%E3%80%81%E5%BC%80%E5%90%AF%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6><span class=nav-number>1.1.7.3.</span> <span class=nav-text>1.1.7.3、开启自我保护机制</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-7-4%E3%80%81%E5%85%B3%E9%97%AD%E8%87%AA%E6%88%91%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6><span class=nav-number>1.1.7.4.</span> <span class=nav-text>1.1.7.4、关闭自我保护机制</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-7-5%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9><span class=nav-number>1.1.7.5.</span> <span class=nav-text>1.1.7.5、注意事项</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-7-6%E3%80%81%E9%87%8D%E8%A6%81%E5%8F%82%E6%95%B0><span class=nav-number>1.1.7.6.</span> <span class=nav-text>1.1.7.6、重要参数</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-8%E3%80%81Eureka%E9%9B%86%E7%BE%A4><span class=nav-number>1.1.8.</span> <span class=nav-text>1.1.8、Eureka集群</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-8-1%E3%80%81%E9%9B%86%E7%BE%A4%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86><span class=nav-number>1.1.8.1.</span> <span class=nav-text>1.1.8.1、集群工作原理</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-8-2%E3%80%81Eureka%E5%88%86%E5%8C%BA><span class=nav-number>1.1.8.2.</span> <span class=nav-text>1.1.8.2、Eureka分区</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-8-3%E3%80%81AP%E5%8E%9F%E5%88%99><span class=nav-number>1.1.8.3.</span> <span class=nav-text>1.1.8.3、AP原则</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-8-4%E3%80%81%E9%9B%86%E7%BE%A4%E5%90%8C%E6%AD%A5><span class=nav-number>1.1.8.4.</span> <span class=nav-text>1.1.8.4、集群同步</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-9%E3%80%81Eureka%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B><span class=nav-number>1.1.9.</span> <span class=nav-text>1.1.9、Eureka工作流程</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-2%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98><span class=nav-number>1.2.</span> <span class=nav-text>1.2、常见问题</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-1%E3%80%81Eureka-Client%E5%88%9A%E5%90%AF%E5%8A%A8%E6%98%AF%E5%90%A6%E4%BC%9A%E7%AB%8B%E5%8D%B3%E6%B3%A8%E5%86%8C%EF%BC%9F><span class=nav-number>1.2.1.</span> <span class=nav-text>1.2.1、Eureka Client刚启动是否会立即注册？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-2%E3%80%81Eureka-Server%E9%9B%86%E7%BE%A4%E5%AE%95%E6%9C%BA%E5%90%8E%EF%BC%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%98%AF%E5%90%A6%E5%8F%AF%E7%94%A8%EF%BC%9F><span class=nav-number>1.2.2.</span> <span class=nav-text>1.2.2、Eureka Server集群宕机后，客户端是否可用？</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-3%E3%80%81%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E8%AE%B0%E5%BD%95><span class=nav-number>1.2.3.</span> <span class=nav-text>1.2.3、时间间隔记录</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-4%E3%80%81Eureka-Client-90%E7%A7%92%E6%B2%A1%E6%9C%89%E5%8F%91%E9%80%81%E5%BF%83%E8%B7%B3%EF%BC%8C%E4%B8%80%E5%AE%9A%E4%BC%9A%E8%BF%87%E6%9C%9F%E5%90%97%EF%BC%9F><span class=nav-number>1.2.4.</span> <span class=nav-text>1.2.4、Eureka Client 90秒没有发送心跳，一定会过期吗？</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#2%E3%80%81Nacos><span class=nav-number>2.</span> <span class=nav-text>2、Nacos</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#2-1%E3%80%81%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C><span class=nav-number>2.1.</span> <span class=nav-text>2.1、服务注册</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>2.1.1.</span> <span class=nav-text>2.1.1、简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-2%E3%80%81%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B><span class=nav-number>2.1.2.</span> <span class=nav-text>2.1.2、服务注册流程</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-2%E3%80%81%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0><span class=nav-number>2.2.</span> <span class=nav-text>2.2、服务发现</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>2.2.1.</span> <span class=nav-text>2.2.1、简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-2%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9><span class=nav-number>2.2.2.</span> <span class=nav-text>2.2.2、注意事项</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-3%E3%80%81%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1><span class=nav-number>2.3.</span> <span class=nav-text>2.3、负载均衡</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>2.3.1.</span> <span class=nav-text>2.3.1、简介</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#3%E3%80%81Zookeeper><span class=nav-number>3.</span> <span class=nav-text>3、Zookeeper</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#3-1%E3%80%81%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C><span class=nav-number>3.1.</span> <span class=nav-text>3.1、服务注册</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-2%E3%80%81%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0><span class=nav-number>3.2.</span> <span class=nav-text>3.2、服务发现</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-3%E3%80%81%E6%9C%8D%E5%8A%A1%E9%80%9A%E7%9F%A5><span class=nav-number>3.3.</span> <span class=nav-text>3.3、服务通知</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%AF%B9%E6%AF%94><span class=nav-number>4.</span> <span class=nav-text>注册中心对比</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1%E3%80%81Eureka%E3%80%81Nacos%E3%80%81Consul%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB><span class=nav-number>4.1.</span> <span class=nav-text>1、Eureka、Nacos、Consul之间的区别</span></a></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>116</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>36</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>129</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://hgprivate.github.io/2024/08/21/Eureka%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="Eureka系列-Eureka原理解析 | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>Eureka系列-Eureka原理解析</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-09-23 20:36:01" datetime=2023-09-23T20:36:01+08:00 itemprop=dateModified>2023-09-23</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Eureka/ itemprop=url rel=index><span itemprop=name>Eureka</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、Eureka><a class=headerlink href=#1、Eureka title=1、Eureka></a>1、Eureka</h1><h2 id=1-1、Eureka底层原理><a class=headerlink href=#1-1、Eureka底层原理 title=1.1、Eureka底层原理></a>1.1、Eureka底层原理</h2><h3 id=1-1-1、服务注册><a class=headerlink href=#1-1-1、服务注册 title=1.1.1、服务注册></a>1.1.1、服务注册</h3><h4 id=1-1-1-1、注册时机><a class=headerlink href=#1-1-1-1、注册时机 title=1.1.1.1、注册时机></a>1.1.1.1、注册时机</h4><p>客户端 主动注册自己 的两种情况：<ol start=2><li>客户端刚启动时；<li>客户端 instance信息 发生变化时；</ol><h4 id=1-1-1-2、定时器注册><a class=headerlink href=#1-1-1-2、定时器注册 title=1.1.1.2、定时器注册></a>1.1.1.2、定时器注册</h4><p><code>com.netflix.discovery.DiscoveryClient</code>使用的<code>@Inject</code> //google guice 注入，遵循 JSR-330 规范。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">initScheduledTasks</span><span class=params>()</span> {</span><br><span class=line>        <span class=type>int</span> renewalIntervalInSecs;</span><br><span class=line>        <span class=type>int</span> expBackOffBound;</span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>this</span>.clientConfig.shouldFetchRegistry()) {</span><br><span class=line>            renewalIntervalInSecs = <span class=built_in>this</span>.clientConfig.getRegistryFetchIntervalSeconds();</span><br><span class=line>            expBackOffBound = <span class=built_in>this</span>.clientConfig.getCacheRefreshExecutorExponentialBackOffBound();</span><br><span class=line>            <span class=built_in>this</span>.cacheRefreshTask = <span class=keyword>new</span> <span class="title class_">TimedSupervisorTask</span>(<span class=string>"cacheRefresh"</span>, <span class=built_in>this</span>.scheduler, <span class=built_in>this</span>.cacheRefreshExecutor, renewalIntervalInSecs, TimeUnit.SECONDS, expBackOffBound, <span class=keyword>new</span> <span class="title class_">DiscoveryClient</span>.CacheRefreshThread());</span><br><span class=line>            <span class=built_in>this</span>.scheduler.schedule(<span class=built_in>this</span>.cacheRefreshTask, (<span class=type>long</span>)renewalIntervalInSecs, TimeUnit.SECONDS);</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>this</span>.clientConfig.shouldRegisterWithEureka()) {</span><br><span class=line>            renewalIntervalInSecs = <span class=built_in>this</span>.instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();</span><br><span class=line>            expBackOffBound = <span class=built_in>this</span>.clientConfig.getHeartbeatExecutorExponentialBackOffBound();</span><br><span class=line>            logger.info(<span class=string>"Starting heartbeat executor: renew interval is: {}"</span>, renewalIntervalInSecs);</span><br><span class=line>            <span class=built_in>this</span>.heartbeatTask = <span class=keyword>new</span> <span class="title class_">TimedSupervisorTask</span>(<span class=string>"heartbeat"</span>, <span class=built_in>this</span>.scheduler, <span class=built_in>this</span>.heartbeatExecutor, renewalIntervalInSecs, TimeUnit.SECONDS, expBackOffBound, <span class=keyword>new</span> <span class="title class_">DiscoveryClient</span>.HeartbeatThread());</span><br><span class=line>            <span class=built_in>this</span>.scheduler.schedule(<span class=built_in>this</span>.heartbeatTask, (<span class=type>long</span>)renewalIntervalInSecs, TimeUnit.SECONDS);</span><br><span class=line>            <span class=built_in>this</span>.instanceInfoReplicator = <span class=keyword>new</span> <span class="title class_">InstanceInfoReplicator</span>(<span class=built_in>this</span>, <span class=built_in>this</span>.instanceInfo, <span class=built_in>this</span>.clientConfig.getInstanceInfoReplicationIntervalSeconds(), <span class=number>2</span>);</span><br><span class=line>            <span class=built_in>this</span>.statusChangeListener = <span class=keyword>new</span> <span class="title class_">StatusChangeListener</span>() {</span><br><span class=line>                <span class=keyword>public</span> String <span class="title function_">getId</span><span class=params>()</span> {</span><br><span class=line>                    <span class=keyword>return</span> <span class=string>"statusChangeListener"</span>;</span><br><span class=line>                }</span><br><span class=line></span><br><span class=line>                <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">notify</span><span class=params>(StatusChangeEvent statusChangeEvent)</span> {</span><br><span class=line>                    DiscoveryClient.logger.info(<span class=string>"Saw local status change event {}"</span>, statusChangeEvent);</span><br><span class=line>                    DiscoveryClient.<span class=built_in>this</span>.instanceInfoReplicator.onDemandUpdate();</span><br><span class=line>                }</span><br><span class=line>            };</span><br><span class=line>            <span class=keyword>if</span> (<span class=built_in>this</span>.clientConfig.shouldOnDemandUpdateStatusChange()) {</span><br><span class=line>                <span class=built_in>this</span>.applicationInfoManager.registerStatusChangeListener(<span class=built_in>this</span>.statusChangeListener);</span><br><span class=line>            }</span><br><span class=line></span><br><span class=line>            <span class=built_in>this</span>.instanceInfoReplicator.start(<span class=built_in>this</span>.clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            logger.info(<span class=string>"Not registering with Eureka server per configuration"</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br></pre></table></figure><p>DiscoverClient 构造函数 会调用<code>initScheduledTasks()</code>方法，该方法主要作用：<ol><li>开启 缓存刷新 定时器；<li>开启 心跳发送 定时器；<li>开启 实例状态 变更监听；<li>开启 应用状态 复制器；（开启一个定时线程，每40秒判断实例信息是否变更，如果有变更则重新注册）</ol><p><code>InstanceInfoReplicator</code>是一个服务注册任务， 有两个地方会执行该任务：<ol><li>定时线程 每40秒 执行 一次该任务；<li>当instance状态发生变更（除去DOWN这个状态）时，监听器statusChangeListener 会监听到并执行服务注册；</ol><h4 id=1-1-1-3、自动注册><a class=headerlink href=#1-1-1-3、自动注册 title=1.1.1.3、自动注册></a>1.1.1.3、自动注册</h4><p><strong>自动化配置类<code>EurekaClientAutoConfiguration</code>逻辑：实例化一个实现了接口SmartLifecycle 的 Bean，spring 容器加载完所有Bean之后 会执行被接口标识的类的start方法。</strong><h4 id=1-1-1-4、处理注册请求><a class=headerlink href=#1-1-1-4、处理注册请求 title=1.1.1.4、处理注册请求></a>1.1.1.4、处理注册请求</h4><p>程序入口：<code>com.netflix.eureka.resources.ApplicationResource.addInstance();</code> addInstance()方法调用链如下：<p><font color=orange><code>addInstance() ---> register() ---> PeerAwareInstanceRegistryImpl中的方法</code>。</font><p><font color=red>注意：Eureka-Server最终处理注册信息的任务会由 Lease对象 来负责。</font><p>与类Lease相关参数如下：<ul><li><font color=orange>DEFAULT_DURATION_IN_SECS</font>：租约过期时间，默认90秒；也就是说超过90秒没有发送心跳续约的实例将会被删除。<li><font color=orange>holder</font>：这个租约是属于谁的， 目前占用这个属性的是 instanceInfo，也就是客户端实例信息。<li><font color=orange>evictionTimestamp</font>： 租约过期时间，服务下线的时候，会更新这个时间戳；<li><font color=orange>registrationTimestamp</font>：租约注册时间；<li><font color=orange>serviceUpTimestamp</font>：服务启动时间 ；当客户端注册时且instanceInfo的status 为UP时，更新这个时间戳。<li><font color=orange>lastUpdateTimestamp</font>：最后更新时间；每次续约时会更新这个时间戳。<li><font color=orange>duration</font>：过期时间，毫秒单位。</ul><h4 id=1-1-1-5、重新注册><a class=headerlink href=#1-1-1-5、重新注册 title=1.1.1.5、重新注册></a>1.1.1.5、重新注册</h4><p>客户端会重新注册的三种情况：<ol><li>服务端 注册信息 不存在；<li>(客户端<code>lastDirtyTimestamp</code>) > (服务端实例 <code>lastDirtyTimestamp</code>) 时会认为服务端信息无效，需要重新发起注册请求；<li>服务端instance的<code>status = UNKNOW</code>时。（出现UNKNOW是因为deleteStatusOverride时存在传入UNKONW的可能性）</ol><h4 id=1-1-1-6、总结><a class=headerlink href=#1-1-1-6、总结 title=1.1.1.6、总结></a>1.1.1.6、总结</h4><p>eureka注册中心底层是一个hashmap，源码参考如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">AbstractInstanceRegistry</span> <span class=keyword>implements</span> <span class="title class_">InstanceRegistry</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> ConcurrentHashMap&LTString, Map&LTString, Lease&LTInstanceInfo>>> registry</span><br><span class=line>            = <span class=keyword>new</span> <span class="title class_">ConcurrentHashMap</span>&LTString, Map&LTString, Lease&LTInstanceInfo>>>();</span><br><span class=line>    <span class=comment>// else fields and methods...</span></span><br><span class=line>}</span><br></pre></table></figure><p>根据源码分析如下：<ol><li><strong>Eureka Server的注册表直接基于内存，即在内存中维护一个数据结构。</strong><li><strong>各个服务的注册、服务下线、服务故障等变化都将更新并记录到注册表。</strong><li><strong>每个服务会每隔30秒从注册表拉取最新服务列表，而eureka server会直接返回有变化的注册表。</strong><li><strong>每个服务会每隔30秒发起心跳，也就是更新心跳时间。</strong></ol><blockquote><p>维护注册表、拉取注册表、更新心跳时间，全部发生在内存中！这是Eureka Server核心之一。</blockquote><h3 id=1-1-2、服务拉取><a class=headerlink href=#1-1-2、服务拉取 title=1.1.2、服务拉取></a>1.1.2、服务拉取</h3><h4 id=1-1-2-1、拉取方式><a class=headerlink href=#1-1-2-1、拉取方式 title=1.1.2.1、拉取方式></a>1.1.2.1、拉取方式</h4><ul><li><p><strong>启动时拉取</strong></p> <p>客户端 启动过程中 初始化DiscoverClient时，会主动全量获取一次注册信息。</p><li><p><strong>定时任务拉取</strong></p> <p>通过定时任务 每隔30秒 拉取一次注册表，拉取过程如下：</p> <ol><li>首先从缓存ReadOnlyCacheMap中查找注册表，若没有则执行第二步。<li>从缓存ReadWriteCacheMap中查找注册表，若没有则执行第三步。<li>从内存中获取实际的注册表数据。</ol></ul><h4 id=1-1-2-2、注册表数据更新><a class=headerlink href=#1-1-2-2、注册表数据更新 title=1.1.2.2、注册表数据更新></a>1.1.2.2、注册表数据更新</h4><ol><li><strong>注册表发生变化时会将最新数据更新到内存，同时清除缓存<code>ReadWriteCacheMap</code>中的数据。</strong>此过程不会影响<code>ReadOnlyCacheMap</code>继续提供服务。<li><strong>30秒内的每一个服务在拉取注册表时会直接读取<code>ReadOnlyCacheMap</code>。</strong><li><strong>30秒过后，当eureka server发现<code>ReadWriteCacheMap</code>被清空时，也会清空<code>ReadOnlyCacheMap</code>中的缓存。</strong><li><strong>当有服务拉取注册表时，会从内存中获取最新数据，同时填充更新各个缓存。</strong></ol><h4 id=1-1-2-3、多级缓存机制><a class=headerlink href=#1-1-2-3、多级缓存机制 title=1.1.2.3、多级缓存机制></a>1.1.2.3、多级缓存机制</h4><p><strong>Eureka Server为避免同时读写同一内存数据造成并发冲突问题，会通过 <font color=orange>多级缓存机制</font> 来提高请求响应速度。</strong><p>多级缓存优点：<ol><li>避免了内存注册表频繁读写冲突问题；<li>基于内存，性能很高；</ol><h4 id=1-1-2-4、增量全量拉取><a class=headerlink href=#1-1-2-4、增量全量拉取 title=1.1.2.4、增量全量拉取></a>1.1.2.4、增量全量拉取</h4><ul><li>增量获取<ol><li>clientConfig.shouldDisableDelta()为false时；<li>clientConfig.getRegistryRefreshSingleVipAddress()为空时；<li>forceFullRegistryFetch为false时；</ol><li>全量获取<ol><li>clientConfig.shouldDisableDelta()为true时；<li>clientConfig.getRegistryRefreshSingleVipAddress()非空时；<li>forceFullRegistryFetch为true时；<li>applications表示本地注册信息的缓存，如果本地缓存为空，或者里面的版本号为-1，那么就需要全量获取；</ol></ul><p>onCacheRefreshed() : 发布缓存刷新事件，用户可以自定义是否监听这个事件，比如需要将注册信息的变化落库。<h4 id=1-1-2-5、注意事项><a class=headerlink href=#1-1-2-5、注意事项 title=1.1.2.5、注意事项></a>1.1.2.5、注意事项</h4><ol><li><font color=red>注册列表信息不能及时匹配时，Eureka Client 会重新获取整个注册表信息。 </font><li><font color=red>整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。</font><li><font color=red>Eureka Client 和 Eureka Server 可以使用 JSON/XML格式 进行通讯。Eureka Client 默认使用 压缩JSON格式来获取注册列表信息。</font></ol><h4 id=1-1-2-6、重要参数><a class=headerlink href=#1-1-2-6、重要参数 title=1.1.2.6、重要参数></a>1.1.2.6、重要参数</h4><ul><li><p><font color=orange>eureka.client.fetch-registry=true</font>：开启 服务消费者从注册中心拉取服务列表的 功能。</p><li><p><font color=orange>eureka.client.registry-fetch-interval-seconds=30</font>：服务消费者从注册中心拉取服务列表的时间间隔（单位：秒）。</p></ul><h3 id=1-1-3、服务续约><a class=headerlink href=#1-1-3、服务续约 title=1.1.3、服务续约></a>1.1.3、服务续约</h3><h4 id=1-1-3-1、简介><a class=headerlink href=#1-1-3-1、简介 title=1.1.3.1、简介></a>1.1.3.1、简介</h4><p><font color=orange>Eureka Client 每隔 30 秒会发送一次心跳来续约。</font>告知自己状态良好。<h4 id=1-1-3-2、重要参数><a class=headerlink href=#1-1-3-2、重要参数 title=1.1.3.2、重要参数></a>1.1.3.2、重要参数</h4><ul><li><font color=orange>eureka.instance.lease-renewal-interval-in-seconds=30</font>：服务续约任务的调用间隔时间，默认为30秒。</ul><h3 id=1-1-4、服务删除><a class=headerlink href=#1-1-4、服务删除 title=1.1.4、服务删除></a>1.1.4、服务删除</h3><h4 id=1-1-4-1、简介><a class=headerlink href=#1-1-4-1、简介 title=1.1.4.1、简介></a>1.1.4.1、简介</h4><p><strong>Eureka Server启动完成后会初始化一个清理过期实例的线程，该线程每60秒执行一次清理任务。</strong><p><strong>默认情况下，Eureka Client 超过 90 秒没有续约 就会被删除。</strong><h4 id=1-1-4-2、重要参数><a class=headerlink href=#1-1-4-2、重要参数 title=1.1.4.2、重要参数></a>1.1.4.2、重要参数</h4><ul><li>eureka.instance.lease-expiration-duration-in-seconds=90：心跳超时时间，默认为90秒。（没有开启自我保护机制时过期实例会被删除）</ul><h3 id=1-1-5、服务下线><a class=headerlink href=#1-1-5、服务下线 title=1.1.5、服务下线></a>1.1.5、服务下线</h3><h4 id=1-1-5-1、主动下线><a class=headerlink href=#1-1-5-1、主动下线 title=1.1.5.1、主动下线></a>1.1.5.1、主动下线</h4><p><strong>程序关闭时 Eureka Client 会向 Eureka Server 发送下线请求，Eureka Server 会从注册表中删除该实例信息。</strong><p>主动下线过程如下：<ol><li>从本地的CurrentHashMap中获取当前appName对应的的Map信息；<li>通过机器ID，获取要下线的机器对应的Lease；<li>修改Lease的evictionTimestamp ， 也就是设置下线时间为当前时间点；</ol><h4 id=1-1-5-2、状态变更><a class=headerlink href=#1-1-5-2、状态变更 title=1.1.5.2、状态变更></a>1.1.5.2、状态变更</h4><p>状态类型共有5种，分类如下：<ul><li>STARTING：服务正在启动中；<li>UP：服务正在运行；<li>DOWN：服务已经宕机，无法继续提供服务；<li>OUT_OF_SERVICE：不再提供服务，其它Eureka Client无法再调用该服务；（强制下线时可考虑设置该状态。）<li>UNKNOW：未知状态；</ul><p>状态变更分析如下：<ol><li>容器刚启动且实例化instance信息时，默认状态为STARTING；<li>初始化ApplicationInfoManager时会设置一个最初Instance信息，此时的instance信息的状态为STARTING；<li>自动注册类 初始化时会设置Instance状态为UP，同时触发监听器，让Eureka Client发起注册；</ol><h3 id=1-1-6、远程调用><a class=headerlink href=#1-1-6、远程调用 title=1.1.6、远程调用></a>1.1.6、远程调用</h3><p><strong>Eureka Client 获取到服务提供者信息后，可通过 HTTP 请求来调用对应服务；当服务提供者有多个时会通过 Ribbon 负载均衡来挑选一个。</strong><h3 id=1-1-7、自我保护机制><a class=headerlink href=#1-1-7、自我保护机制 title=1.1.7、自我保护机制></a>1.1.7、自我保护机制</h3><h4 id=1-1-7-1、简介><a class=headerlink href=#1-1-7-1、简介 title=1.1.7.1、简介></a>1.1.7.1、简介</h4><p>固定时间内大量实例被注销，可能会严重威胁整个微服务架构的可用性。为解决该问题提出了 自我保护机制。<p><strong>Eureka 自我保护机制是为了防止误杀服务而提供的一个机制。当存在大量心跳超时情况时，会进入自我保护机制；当客户端心跳恢复时，Eureka 会自动退出自我保护机制。</strong><h4 id=1-1-7-2、自我保护机制功能><a class=headerlink href=#1-1-7-2、自我保护机制功能 title=1.1.7.2、自我保护机制功能></a>1.1.7.2、自我保护机制功能</h4><p>Eureka Server 进入自我保护机制，会出现以下几种情况：<ol><li>Eureka不再直接移除长时间没有发送心跳 的服务；<li>让长时间没有发送心跳的服务继续对外提供服务；（保证可用性）<li>当网络稳定时，当前实例新的注册信息会被同步到其它节点；（保证最终一致性）</ol><h4 id=1-1-7-3、开启自我保护机制><a class=headerlink href=#1-1-7-3、开启自我保护机制 title=1.1.7.3、开启自我保护机制></a>1.1.7.3、开启自我保护机制</h4><p>相关源码如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">isLeaseExpirationEnabled</span><span class=params>()</span> {</span><br><span class=line>    <span class=comment>// 是否开启自我保护机制，这是个配置，默认为true</span></span><br><span class=line>    <span class=keyword>if</span> (!isSelfPreservationModeEnabled()) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 计算是否需要自我保护</span></span><br><span class=line>    <span class=keyword>return</span> numberOfRenewsPerMinThreshold > <span class=number>0</span> && getNumOfRenewsInLastMin() > numberOfRenewsPerMinThreshold;</span><br><span class=line>}</span><br></pre></table></figure><p>getNumOfRenewInLastMin()方法返回的是每分钟续约数量（每个客户端续约时都会更新这个值，每分钟重置一次，会有一个线程专门去执行累加操作）。<strong>如果 每分钟的续约数量>最小续约数，则不需要开启自我保护机制， 如果是小于则需要开启， 所以当返回false的时就需要开启自我保护机制。</strong><p>自我保护模式被激活的条件是：<strong>1 分钟后满足 (Eureka Server 最后 1 分钟收到客户端实例续约的总数) < (Eureka Server 期望每分钟收到客户端实例续约的总数)。</strong><h4 id=1-1-7-4、关闭自我保护机制><a class=headerlink href=#1-1-7-4、关闭自我保护机制 title=1.1.7.4、关闭自我保护机制></a>1.1.7.4、关闭自我保护机制</h4><p>自我保护机制的关闭和解除方式如下：<ol><li>当服务的网络分区解除之后，客户端在续约时会更新每分钟的续约数，<strong>每分钟的续约数大于85%时就自动解除</strong>。<li>重启服务。</ol><h4 id=1-1-7-5、注意事项><a class=headerlink href=#1-1-7-5、注意事项 title=1.1.7.5、注意事项></a>1.1.7.5、注意事项</h4><ol><li>如果在保护期内刚好这个服务提供者非正常下线了，需要服务消费者端有一些容错机制，如重试，断路器等。<li>Eureka Server过期时间默认60s，客户端续约时间间隔默认30s，修改该配置可能会打破自我保护机制的规则。</ol><h4 id=1-1-7-6、重要参数><a class=headerlink href=#1-1-7-6、重要参数 title=1.1.7.6、重要参数></a>1.1.7.6、重要参数</h4><ul><li>eureka.server.enable-self-preservation=true：是否开启自我保护机制，true表示开启，false表示关闭。</ul><h3 id=1-1-8、Eureka集群><a class=headerlink href=#1-1-8、Eureka集群 title=1.1.8、Eureka集群></a>1.1.8、Eureka集群</h3><h4 id=1-1-8-1、集群工作原理><a class=headerlink href=#1-1-8-1、集群工作原理 title=1.1.8.1、集群工作原理></a>1.1.8.1、集群工作原理</h4><p>eureka集群架构图示例如下：<p><img alt=img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Eureka-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg><p>Eureka Server 集群间通过 Replicate 来同步数据，不区分主节点和从节点。通过节点间互相注册来提高可用性，每个节点需要添加一个或多个有效的 serviceUrl 指向其他节点。<p>某个Eureka Server宕机时Eureka Client 请求会切换到新的 Eureka Server 节点。当宕机的节点恢复后会被纳入到服务器集群管理之中。当节点开始接受客户端请求时，所有的操作都会进行节点间复制，将请求复制到其它当前可知的所有 Eureka Server 节点中。<p><strong>Eureka Server 同步遵循一个原则：节点间可以形成通路 就可以实现共享信息。多个 Eureka Server 之间通过 P2P 方式完成服务注册表的同步。</strong><p><strong>Eureka Server 集群采用异步方式来同步状态，所以不保证节点间的状态能达到实时一致性，但能保证最终一致性。</strong><h4 id=1-1-8-2、Eureka分区><a class=headerlink href=#1-1-8-2、Eureka分区 title=1.1.8.2、Eureka分区></a>1.1.8.2、Eureka分区</h4><p>Eureka 提供了 Region 和 Zone 两个概念来进行分区，这两个概念来自于亚马逊的 AWS：<ul><li><p><font color=orange>region</font></p> <p>可以理解为【不同地理区域】，比如亚洲地区，中国区或者深圳等等。没有具体大小的限制。根据项目具体的情况，可以自行合理划分 region。</p><li><p><font color=orange>zone</font></p> <p>可以简单理解为 region 内的【具体机房】，比如将 region 划分为深圳，深圳有两个机房，那么就可以在此 region 之下划分出 zone1、zone2 两个 zone。</p></ul><p>上图中的 us-east-1c、us-east-1d、us-east-1e 就代表了不同的 Zone。Zone 内的 Eureka Client 优先和 Zone 内的 Eureka Server 进行心跳同步，同样调用端优先在 Zone 内的 Eureka Server 获取服务列表，当 Zone 内的 Eureka Server 挂掉之后，才会从别的 Zone 中获取信息。<h4 id=1-1-8-3、AP原则><a class=headerlink href=#1-1-8-3、AP原则 title=1.1.8.3、AP原则></a>1.1.8.3、AP原则</h4><p>Eureka Server 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而 Eureka Client 在向某个 Eureka 注册时，如果发现连接失败，则会自动切换至其它节点。<strong>只要有一个 Eureka Server 存在就能保证注册服务可用，但不保证信息最新。</strong><h4 id=1-1-8-4、集群同步><a class=headerlink href=#1-1-8-4、集群同步 title=1.1.8.4、集群同步></a>1.1.8.4、集群同步</h4><p><strong>Eureka Server 收到来自客户端的注册、下线、心跳请求时，会将操作同步给相邻的集群节点。</strong><ol><li>同步操作采用异步方式，Eureka Server构建同步信息的任务，放入线程池，供线程异步来执行，默认是批量同步，即线程会一次性从队列里面取走所有数据进行同步， 如果相邻Eureka Server Node不可用时会进行重试，超出过期时间会放弃该同步任务。过期时间默认为30秒。<li>通过HTTP方式发送请求给其他Eureka Server，比如：register， Eureka Server收到其他节点的批量同步注册请求时会调用本地的register方法，跟客户端注册走的流程一直，只不过方法参数isReplication = true如此，带有isReplication = true参数的请求不会同步给其他节点，避免了循环同步。</ol><h3 id=1-1-9、Eureka工作流程><a class=headerlink href=#1-1-9、Eureka工作流程 title=1.1.9、Eureka工作流程></a>1.1.9、Eureka工作流程</h3><p>Eureka 工作流程 分析如下：<ol><li>Eureka Server 启动成功，等待服务端注册。如果是集群模式，那么启动过程中集群之间会通过 Replicate 同步注册表信息。<li>Eureka Client 启动时会注册服务到注册中心。<li>Eureka Client 每隔 30s 会发送一次心跳到Eureka Server端，告知状态良好。<li>Eureka Server 90s 内没有收到 Eureka Client 心跳续约时，会删除该实例。（没有开启自我保护机制）<li>如果大量Eureka Client 在90s内没有发送心跳，eureka server会进入自我保护机制，且不再删除长时间没有发送心跳的客户端。<li>Eureka Client 心跳请求恢复正常后，Eureka Server 会自动退出自我保护模式。<li>Eureka Client 定时全量 或 增量 从注册中心获取服务注册表，并且将这些信息缓存到本地。<li>服务调用时，Eureka Client 会先从本地缓存查找需要调用的服务。如果本地缓存不存在，则会从注册中心拉取然后同步到本地缓存。<li>Eureka Client 获取到目标服务器信息后发起服务调用。<li>程序关闭时 Client 会向 Server 发送下线请求，然后该实例信息会从注册表中被删除。</ol><h2 id=1-2、常见问题><a class=headerlink href=#1-2、常见问题 title=1.2、常见问题></a>1.2、常见问题</h2><h3 id=1-2-1、Eureka-Client刚启动是否会立即注册？><a title="1.2.1、Eureka Client刚启动是否会立即注册？" class=headerlink href=#1-2-1、Eureka-Client刚启动是否会立即注册？></a>1.2.1、Eureka Client刚启动是否会立即注册？</h3><p><strong>client端启动之后会立马向服务端发起注册。</strong><h3 id=1-2-2、Eureka-Server集群宕机后，客户端是否可用？><a title="1.2.2、Eureka Server集群宕机后，客户端是否可用？" class=headerlink href=#1-2-2、Eureka-Server集群宕机后，客户端是否可用？></a>1.2.2、Eureka Server集群宕机后，客户端是否可用？</h3><ul><li><p>场景一</p> <p>Eureka Client 启动时会主动全量从服务端获取一次注册信息，如果此时Eureka Server集群已经宕机，那么Eureka Client端将不可用。</p><li><p>场景二</p> <p>如果Eureka Client 启动时会全量获取注册信息并缓存至本地之后 Eureka Server 集群发生宕机，Eureka Client也可以继续对外提供服务。唯一不足的是后续无法获取最新注册信息。</p></ul><h3 id=1-2-3、时间间隔记录><a class=headerlink href=#1-2-3、时间间隔记录 title=1.2.3、时间间隔记录></a>1.2.3、时间间隔记录</h3><ul><li>Eureka Client<ul><li><strong>拉取服务信息并更新：默认30秒；</strong><li><strong>发送心跳：默认30秒；</strong><li><strong>检查应用是否变化，若变化则重新发起注册：默认30秒；</strong></ul><li>Eureka Server<ul><li><strong>只读缓存过期时间：默认30秒；</strong><li><strong>启动时同步节点数据的等待时间：默认30秒；</strong><li><strong>清空每分钟续约次数间隔：默认60秒；</strong><li><strong>清理过期任务：默认60秒；</strong><li><strong>租约过期时间：默认90秒；</strong><li><strong>读写缓存过期时间：默认180秒；</strong></ul></ul><h3 id=1-2-4、Eureka-Client-90秒没有发送心跳，一定会过期吗？><a title="1.2.4、Eureka Client 90秒没有发送心跳，一定会过期吗？" class=headerlink href=#1-2-4、Eureka-Client-90秒没有发送心跳，一定会过期吗？></a>1.2.4、Eureka Client 90秒没有发送心跳，一定会过期吗？</h3><ul><li><p>场景一</p> <p>自我保护模式开启时 将不会被清除；</p><li><p>场景二</p> <p>Eureka Server中租约过期时间默认90秒，服务端维护了一个变量<code>lastUpdaeTimestap</code>，其表示最后修改时间。</p> <p>最后修改时间的更新逻辑是：当前时间+90秒，最终判断是否过期，源码如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">isExpired</span><span class=params>(<span class=type>long</span> additionalLeaseMs)</span> {</span><br><span class=line>    <span class=keyword>return</span> (evictionTimestamp > <span class=number>0</span> || System.currentTimeMillis() > (lastUpdateTimestamp + duration + additionalLeaseMs));</span><br><span class=line>}</span><br></pre></table></figure> <p>代码变量解析如下：</p> <ul><li>evictionTimestamp： 表示 下线时间，下线操作时会更新这个值。</ul> <p><strong>综上可知：最后修改时间 在续约时已经加了90秒，这里再加90秒就是180秒，所以，当前时间大于(最后修改时间+90秒)时才能判定为过期。</strong></p></ul><h1 id=2、Nacos><a class=headerlink href=#2、Nacos title=2、Nacos></a>2、Nacos</h1><p>Nacos注册中心实现原理图参考如下：<p><img alt=img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Eureka-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86%E5%9B%BE.jpg><p>Nacos 中的服务注册方式是通过 轮询 注册中心集群节点地址来进行服务注册，Nacos Server 接收到 服务注册请求 后会通过Map来保存注册的服务信息，如果配置了持久化则会被保存到数据库中。<p><strong>服务消费者会采用 Pull 和 Push 两种方式同时运作。</strong><h2 id=2-1、服务注册><a class=headerlink href=#2-1、服务注册 title=2.1、服务注册></a>2.1、服务注册</h2><h3 id=2-1-1、简介><a class=headerlink href=#2-1-1、简介 title=2.1.1、简介></a>2.1.1、简介</h3><p>注册服务分两步：<ol><li>将 服务信息 注册到 服务端；<li>向服务端 发送 心跳包，这两个操作都是通过 NamingProxy 和服务端进行数据交互。</ol><h3 id=2-1-2、服务注册流程><a class=headerlink href=#2-1-2、服务注册流程 title=2.1.2、服务注册流程></a>2.1.2、服务注册流程</h3><p>Dubbo服务发布 是通过【事件监听机制】完成。当springboot应用启动完成后会发布 <code>ApplicationStartedEvent</code> 事件，而Dubbo类<code>DubboServiceRegistrationNonWebApplicationAutoConfiguration</code>会监听该事件，当监听到该事件时会立即触发 服务注册操作。相关源码如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>@EventListener(ApplicationStartedEvent.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">onApplicationStarted</span><span class=params>()</span> {</span><br><span class=line>    setServerPort();</span><br><span class=line>    register();</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">register</span><span class=params>()</span> {</span><br><span class=line>    <span class=keyword>if</span> (registered) {</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line>    serviceRegistry.register(registration);  <span class=comment>//这里注入的应该是 NacosServiceRegistry</span></span><br><span class=line>    registered = <span class=literal>true</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>服务注册流程参考如下：<ol><li><p>调用 NacosServiceRegistry.register() 方法发起服务注册请求</p> <ol><li>调用NacosNamingService.registerInstance(serviceId, group, instance)方法；<ol><li>调用this.beatReactor.addBeatInfo(groupedServiceName, beatInfo)方法；<ol><li>调用this.executorService.schedule(new BeatReactor.BeatTask(beatInfo), beatInfo.getPeriod(), TimeUnit.MILLISECONDS)方法。</ol><li>调用this.serverProxy.registerService(groupedServiceName, groupName, instance)方法；<ol><li>调用NamingProxy.registerService(groupedServiceName, groupName, instance)方法，拼接请求参数并发起注册服务的POST请求。</ol></ol></ol><li><p>Nacos服务端处理</p> <p>服务端提供了一个InstanceController类，服务端消费者发起注册服务请求时，调用的接口是： <code>[post]: /nacos/v1/ns/instance</code> ，<code>serviceName</code>代表客户端的项目名称 ，<code>namespace</code>代表nacos 的namespace。</p> <p>Nacos通过不同的 namespace 来维护服务，每个namespace下有不同的group，不同的group下才有对应的Service ，然后通过这个 serviceName 来确定服务实例。</p> <p>第一次进来则会进入初始化，初始化完会调用 putServiceAndInit，获取到服务以后把服务实例添加到集合中，然后基于一致性协议进行数据同步。然后调用 addInstance，然后返回注册成功响应。</p></ol><h2 id=2-2、服务发现><a class=headerlink href=#2-2、服务发现 title=2.2、服务发现></a>2.2、服务发现</h2><h3 id=2-2-1、简介><a class=headerlink href=#2-2-1、简介 title=2.2.1、简介></a>2.2.1、简介</h3><p>服务成功注册到注册中心后，消费者就可以获取可用服务。服务发现分两种：<ul><li>第一种：消费者向注册中心发起获取服务实例的请求，注册中心 会返回 所有可用服务实例。一般不推荐这种情况。<li>第二种：消费者从注册中心订阅某个服务，并通过 监听器 来监听服务状态信息，当被监听的服务实例发生变化时 消费者会更新本地服务实例列表，以保证所有服务可用。</ul><p>服务发现 分两步：<ol><li>不断查询 服务端可用服务实例的 定时任务；<li>不断从已变服务队列中取出服务 并通知 EventListener 持有者的 定时任务；</ol><h3 id=2-2-2、注意事项><a class=headerlink href=#2-2-2、注意事项 title=2.2.2、注意事项></a>2.2.2、注意事项</h3><p><strong>客户端会将获取到的服务实例保存在map中，map中的内容由调度任务定时更新，故会存在延时。</strong><h2 id=2-3、负载均衡><a class=headerlink href=#2-3、负载均衡 title=2.3、负载均衡></a>2.3、负载均衡</h2><h3 id=2-3-1、简介><a class=headerlink href=#2-3-1、简介 title=2.3.1、简介></a>2.3.1、简介</h3><p><strong>负载均衡有多种，可分为 服务端负载均衡 和 客户端负载均衡。</strong><p>Nacos客户端获取到服务列表后，会通过负载均衡算法从列表中选出一个可用实例，算法默认是【随机获取】。<h1 id=3、Zookeeper><a class=headerlink href=#3、Zookeeper title=3、Zookeeper></a>3、Zookeeper</h1><h2 id=3-1、服务注册><a class=headerlink href=#3-1、服务注册 title=3.1、服务注册></a>3.1、服务注册</h2><p>服务提供者 启动时 会注册服务信息到Zookeeper服务端，即会在Zookeeper服务器上创建一个服务节点，并在节点上存储服务的相关数据（如服务提供者的ip地址、端口等）。<h2 id=3-2、服务发现><a class=headerlink href=#3-2、服务发现 title=3.2、服务发现></a>3.2、服务发现</h2><p>服务消费者 启动时 会根据自身依赖的服务信息 向Zookeeper获取可用的服务提供者并设置Watch，后会将服务提供者信息缓存在本地，调用服务时直接从Zookeeper注册中心获取一个服务进行调用。<h2 id=3-3、服务通知><a class=headerlink href=#3-3、服务通知 title=3.3、服务通知></a>3.3、服务通知</h2><p>服务提供者 因某种原因宕机 或 不提供服务时，Zookeeper中对应的服务节点会被删除，同时Zookeeper会异步向所有关联的 服务消费者 发出 节点删除通知，服务消费者 收到通知后 更新本地缓存。<h1 id=注册中心对比><a class=headerlink href=#注册中心对比 title=注册中心对比></a>注册中心对比</h1><h2 id=1、Eureka、Nacos、Consul之间的区别><a class=headerlink href=#1、Eureka、Nacos、Consul之间的区别 title=1、Eureka、Nacos、Consul之间的区别></a>1、Eureka、Nacos、Consul之间的区别</h2><p>（1）版本迭代<ul><li>eureka：目前停止维护升级。<li>nacos：依然在升级迭代。<li>consul：依然在升级迭代。</ul><p>（2）ACP原则<ul><li><p>eureka：遵循AP原则（可用性+分离容忍），有较强的可用性，服务注册快，但牺牲了一致性。</p><li><p>nacos：遵循CP原则（一致性+分离容忍） 和AP原则（可用性+分离容忍）。</p><li><p>consul：遵循CP原则（一致性+分离容忍），服务注册慢，一致性会导致Leader挂掉后重新选举，选举期间整个consul不可用。</p></ul><p>（3）访问协议<ul><li>eureka：HTTP。<li>nacos：HTTP / 动态DNS / UDP。<li>consul：HTTP / DNS。</ul><p>（4）集成支持<ul><li>eureka：只支持SpringCloud集成。<li>nacos：支持Dubbo 、SpringCloud、K8S集成。<li>consul：支持SpringCloud、K8S集成。</ul><p>（5）应用内外<ul><li><p>eureka：直接集成到应用中，依赖于应用自身完成服务的注册与发现。</p><li><p>nacos：属于外部应用，侵入性小。</p><li><p>consul：属于外部应用，侵入性小。</p></ul><p>（6）雪崩保护<ul><li>eureka：支持雪崩保护。<li>nacos：支持雪崩保护。<li>consul：不支持雪崩保护。</ul><p>（7）配置中心<ul><li>eureka：不支持。<li>nacos：支持，使用简单，springBoot命名风格，支持动态刷新。<li>consul：支持，使用偏麻烦，不太符合springBoot命名风格，支持动态刷新。</ul><p>（8）自我保护方式和范围<ul><li><p>eureka</p> <p>保护方式：当在短时间内，统计续约失败的比例，如果达到一定阈值，则会触发自我保护的机制，在该机制下，Eureka Server不会剔除任何的微服务，等到正常后，再退出自我保护机制。自我保护开关(eureka.server.enable-self-preservation: false)</p> <p>保护范围：针对所有服务。</p><li><p>nacos</p> <p>保护方式：当健康实例 (Instance) 占服务总实例数量的比例小于阈值时，无论实例 (Instance) 是否健康，都会将这个实例 (Instance) 返回给客户端。虽然损失了部分流量，但保证了集群中剩余的健康实例 (Instance) 能正常工作。</p> <p>保护范围：针对某个具体 Service，而不是针对所有服务。</p></ul></div><footer class=post-footer><div class=post-tags><a href=/tags/Eureka/ rel=tag># Eureka</a><a href=/tags/Eureka%E5%8E%9F%E7%90%86/ rel=tag># Eureka原理</a></div><div class=post-nav><div class=post-nav-item><a href=/2024/08/21/ElasticSearch%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/ rel=prev title=ElasticSearch系列-ElasticSearch基础应用> <i class="fa fa-angle-left"></i> ElasticSearch系列-ElasticSearch基础应用 </a></div><div class=post-nav-item><a href=/2024/08/21/Eureka%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/ rel=next title=Eureka系列-Eureka基础应用> Eureka系列-Eureka基础应用 <i class="fa fa-angle-right"></i> </a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script>