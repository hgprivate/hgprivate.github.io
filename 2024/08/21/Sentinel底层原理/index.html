<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hshz21.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="1、基本概念Sentinel实现限流、隔离、降级、熔断等功能，本质要做的就是两件事情：  统计数据：统计某个资源的访问数据（QPS、RT等信息）。 规则判断：判断限流规则、隔离规则、降级规则、熔断规则是否满足。  1.1、ProcessorSlotChainSentinel核心骨架是类ProcessorSlotChain。该类基于责任链模式将不同功能（限流、降级、系统保护）封装成一个个的Slot，" name=description><meta content=article property=og:type><meta content=Sentinel系列-Sentinel原理解析 property=og:title><meta content=https://hshz21.gitee.io/2024/08/21/Sentinel%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content="1、基本概念Sentinel实现限流、隔离、降级、熔断等功能，本质要做的就是两件事情：  统计数据：统计某个资源的访问数据（QPS、RT等信息）。 规则判断：判断限流规则、隔离规则、降级规则、熔断规则是否满足。  1.1、ProcessorSlotChainSentinel核心骨架是类ProcessorSlotChain。该类基于责任链模式将不同功能（限流、降级、系统保护）封装成一个个的Slot，" property=og:description><meta content=zh_CN property=og:locale><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20220428170120087.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20220428170236302.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925180522926.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925180619492.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925180810181.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925180954856.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925181359203.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925181714605.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925182127206.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925210716675.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925211020881.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925213440686.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925213939035.png property=og:image><meta content=2024-08-21T13:39:14.635Z property=article:published_time><meta content=2023-08-07T07:01:01.345Z property=article:modified_time><meta content=豪哥 property=article:author><meta content=Sentinel property=article:tag><meta content=Sentinel原理 property=article:tag><meta content=summary name=twitter:card><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20220428170120087.png name=twitter:image><link href=https://hshz21.gitee.io/2024/08/21/Sentinel%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hshz21.gitee.io/2024/08/21/Sentinel%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/","path":"2024/08/21/Sentinel底层原理/","title":"Sentinel系列-Sentinel原理解析"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>Sentinel系列-Sentinel原理解析 | 豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>豪哥博客</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#1%E3%80%81%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5><span class=nav-number>1.</span> <span class=nav-text>1、基本概念</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81ProcessorSlotChain><span class=nav-number>1.1.</span> <span class=nav-text>1.1、ProcessorSlotChain</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-2%E3%80%81Node><span class=nav-number>1.2.</span> <span class=nav-text>1.2、Node</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-3%E3%80%81Entry><span class=nav-number>1.3.</span> <span class=nav-text>1.3、Entry</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-1%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B5%84%E6%BA%90><span class=nav-number>1.3.1.</span> <span class=nav-text>1.3.1、自定义资源</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-2%E3%80%81%E9%80%9A%E8%BF%87%E6%B3%A8%E8%A7%A3%E6%A0%87%E8%AE%B0%E8%B5%84%E6%BA%90><span class=nav-number>1.3.2.</span> <span class=nav-text>1.3.2、通过注解标记资源</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-4%E3%80%81Context><span class=nav-number>1.4.</span> <span class=nav-text>1.4、Context</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-1%E3%80%81Context%E5%AE%9A%E4%B9%89><span class=nav-number>1.4.1.</span> <span class=nav-text>1.4.1、Context定义</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-2%E3%80%81Context%E5%88%9D%E5%A7%8B%E5%8C%96><span class=nav-number>1.4.2.</span> <span class=nav-text>1.4.2、Context初始化</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-4-2-1%E3%80%81%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D><span class=nav-number>1.4.2.1.</span> <span class=nav-text>1.4.2.1、自动装配</span></a></ol></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#2%E3%80%81ProcessorSlotChain><span class=nav-number>2.</span> <span class=nav-text>2、ProcessorSlotChain</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#2-1-%E5%85%A5%E5%8F%A3><span class=nav-number>2.1.</span> <span class=nav-text>2.1.入口</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-2-DefaultProcessorSlotChain><span class=nav-number>2.2.</span> <span class=nav-text>2.2.DefaultProcessorSlotChain</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-3-NodeSelectorSlot><span class=nav-number>2.3.</span> <span class=nav-text>2.3.NodeSelectorSlot</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-4-ClusterBuilderSlot><span class=nav-number>2.4.</span> <span class=nav-text>2.4.ClusterBuilderSlot</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-5-StatisticSlot><span class=nav-number>2.5.</span> <span class=nav-text>2.5.StatisticSlot</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-6-AuthoritySlot><span class=nav-number>2.6.</span> <span class=nav-text>2.6.AuthoritySlot</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-7-SystemSlot><span class=nav-number>2.7.</span> <span class=nav-text>2.7.SystemSlot</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-8-ParamFlowSlot><span class=nav-number>2.8.</span> <span class=nav-text>2.8.ParamFlowSlot</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-8-1-%E4%BB%A4%E7%89%8C%E6%A1%B6><span class=nav-number>2.8.1.</span> <span class=nav-text>2.8.1.令牌桶</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-9-FlowSlot><span class=nav-number>2.9.</span> <span class=nav-text>2.9.FlowSlot</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-9-1-%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B><span class=nav-number>2.9.1.</span> <span class=nav-text>2.9.1.核心流程</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-9-2-%E6%BB%91%E5%8A%A8%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3><span class=nav-number>2.9.2.</span> <span class=nav-text>2.9.2.滑动时间窗口</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-9-2-1-%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3%E8%AF%B7%E6%B1%82%E9%87%8F%E7%BB%9F%E8%AE%A1><span class=nav-number>2.9.2.1.</span> <span class=nav-text>2.9.2.1.时间窗口请求量统计</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-9-2-2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3QPS%E8%AE%A1%E7%AE%97><span class=nav-number>2.9.2.2.</span> <span class=nav-text>2.9.2.2.滑动窗口QPS计算</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-9-3-%E6%BC%8F%E6%A1%B6><span class=nav-number>2.9.3.</span> <span class=nav-text>2.9.3.漏桶</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-10-DegradeSlot><span class=nav-number>2.10.</span> <span class=nav-text>2.10.DegradeSlot</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-10-1-CircuitBreaker><span class=nav-number>2.10.1.</span> <span class=nav-text>2.10.1.CircuitBreaker</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-10-2-%E8%A7%A6%E5%8F%91%E6%96%AD%E8%B7%AF%E5%99%A8><span class=nav-number>2.10.2.</span> <span class=nav-text>2.10.2.触发断路器</span></a></ol></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>116</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>35</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>128</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://hshz21.gitee.io/2024/08/21/Sentinel%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="Sentinel系列-Sentinel原理解析 | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>Sentinel系列-Sentinel原理解析</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-07 15:01:01" datetime=2023-08-07T15:01:01+08:00 itemprop=dateModified>2023-08-07</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Sentinel/ itemprop=url rel=index><span itemprop=name>Sentinel</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、基本概念><a class=headerlink href=#1、基本概念 title=1、基本概念></a>1、基本概念</h1><p>Sentinel实现限流、隔离、降级、熔断等功能，本质要做的就是两件事情：<ul><li><strong>统计数据</strong>：统计某个资源的访问数据（QPS、RT等信息）。<li><strong>规则判断</strong>：判断限流规则、隔离规则、降级规则、熔断规则是否满足。</ul><h2 id=1-1、ProcessorSlotChain><a class=headerlink href=#1-1、ProcessorSlotChain title=1.1、ProcessorSlotChain></a>1.1、ProcessorSlotChain</h2><p><strong>Sentinel核心骨架是类ProcessorSlotChain。该类基于责任链模式将不同功能（限流、降级、系统保护）封装成一个个的Slot，请求进入后会逐个执行。</strong><p><img alt=image-20220428170120087 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20220428170120087.png><p>责任链中的Slot也分为两大类：<ul><li><strong>统计数据构建部分（statistic）</strong><ul><li>NodeSelectorSlot：负责构建簇点链路中的节点（DefaultNode），将这些节点形成链路树。<li>ClusterBuilderSlot：负责构建某个资源的ClusterNode，ClusterNode可以保存资源的运行信息（响应时间、QPS、block 数目、线程数、异常数等）以及来源信息（origin名称）。<li>StatisticSlot：负责统计实时调用数据，包括运行信息、来源信息等。</ul><li><strong>规则判断部分（rule checking）</strong><ul><li>AuthoritySlot：负责授权规则（来源控制）。<li>SystemSlot：负责系统保护规则。<li>ParamFlowSlot：负责热点参数限流规则。<li>FlowSlot：负责限流规则。<li>DegradeSlot：负责降级规则。</ul></ul><h2 id=1-2、Node><a class=headerlink href=#1-2、Node title=1.2、Node></a>1.2、Node</h2><p>Sentinel中的簇点链路是由一个个Node组成，Node是一个接口，有其如下实现：<p><img alt=image-20220428170236302 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20220428170236302.png><p>按照作用分为两类Node：<ul><li><strong>DefaultNode</strong>：代表链路树中的每一个资源，一个资源出现在不同链路中时会创建不同的DefaultNode节点。而树的入口节点叫EntranceNode，是一种特殊的DefaultNode。<li><strong>ClusterNode</strong>：代表资源，一个资源不管出现在多少链路中，只会有一个ClusterNode。记录当前资源被访问的统计数据。</ul><h2 id=1-3、Entry><a class=headerlink href=#1-3、Entry title=1.3、Entry></a>1.3、Entry</h2><p>默认情况下Sentinel会将controller中的方法作为被保护资源，如何将一段代码标记为一个Sentinel资源呢？<p>Sentinel中的资源用Entry表示。声明Entry的API示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment>// 资源名可使用任意有业务语义的字符串，比如方法名、接口名或其它可唯一标识的字符串。</span></span><br><span class=line><span class=keyword>try</span> (<span class=type>Entry</span> <span class=variable>entry</span> <span class=operator>=</span> SphU.entry(<span class=string>"resourceName"</span>)) {</span><br><span class=line>  <span class=comment>// 被保护的业务逻辑</span></span><br><span class=line>  <span class=comment>// do something here...</span></span><br><span class=line>} <span class=keyword>catch</span> (BlockException ex) {</span><br><span class=line>  <span class=comment>// 资源访问阻止，被限流或被降级</span></span><br><span class=line>  <span class=comment>// 在此处进行相应的处理操作</span></span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-3-1、自定义资源><a class=headerlink href=#1-3-1、自定义资源 title=1.3.1、自定义资源></a>1.3.1、自定义资源</h3><p>1）首先在order-service中引入sentinel依赖。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!--sentinel--></span></span><br><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>com.alibaba.cloud<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>spring-cloud-starter-alibaba-sentinel<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><p>2）然后配置Sentinel地址。<figure class="highlight yaml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>cloud:</span></span><br><span class=line>    <span class=attr>sentinel:</span></span><br><span class=line>      <span class=attr>transport:</span></span><br><span class=line>        <span class=attr>dashboard:</span> <span class=string>localhost:8089</span> <span class=comment># 这里我的sentinel用了8089的端口</span></span><br></pre></table></figure><p>3）修改OrderService类的queryOrderById方法。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> Order <span class="title function_">queryOrderById</span><span class=params>(Long orderId)</span> {</span><br><span class=line>    <span class=comment>// 创建Entry，标记资源，资源名为resource1</span></span><br><span class=line>    <span class=keyword>try</span> (<span class=type>Entry</span> <span class=variable>entry</span> <span class=operator>=</span> SphU.entry(<span class=string>"resource1"</span>)) {</span><br><span class=line>        <span class=comment>// 1.查询订单，这里是假数据</span></span><br><span class=line>        <span class=type>Order</span> <span class=variable>order</span> <span class=operator>=</span> Order.build(<span class=number>101L</span>, <span class=number>4999L</span>, <span class=string>"小米 MIX4"</span>, <span class=number>1</span>, <span class=number>1L</span>, <span class=literal>null</span>);</span><br><span class=line>        <span class=comment>// 2.查询用户，基于Feign的远程调用</span></span><br><span class=line>        <span class=type>User</span> <span class=variable>user</span> <span class=operator>=</span> userClient.findById(order.getUserId());</span><br><span class=line>        <span class=comment>// 3.设置</span></span><br><span class=line>        order.setUser(user);</span><br><span class=line>        <span class=comment>// 4.返回</span></span><br><span class=line>        <span class=keyword>return</span> order;</span><br><span class=line>    }<span class=keyword>catch</span> (BlockException e){</span><br><span class=line>        log.error(<span class=string>"被限流或降级"</span>, e);</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>4）访问微服务后，打开Sentinel控制台，查看是否生效。<h3 id=1-3-2、通过注解标记资源><a class=headerlink href=#1-3-2、通过注解标记资源 title=1.3.2、通过注解标记资源></a>1.3.2、通过注解标记资源</h3><p>除编码外，还可以添加<code>@SentinelResource</code>注解来标记资源。<p>该功能的关键在于自动配置类<code>SentinelAutoConfiguration</code>。该配置类会注入<code>SentinelResourceAspect</code>。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br></pre><td class=code><pre><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SentinelResourceAspect</span> <span class=keyword>extends</span> <span class="title class_">AbstractSentinelAspectSupport</span> {</span><br><span class=line>	<span class=comment>// 切点是添加了 @SentinelResource注解的类</span></span><br><span class=line>    <span class=meta>@Pointcut("@annotation(com.alibaba.csp.sentinel.annotation.SentinelResource)")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">sentinelResourceAnnotationPointcut</span><span class=params>()</span> {</span><br><span class=line>    }</span><br><span class=line>	</span><br><span class=line>    <span class=comment>// 环绕增强</span></span><br><span class=line>    <span class=meta>@Around("sentinelResourceAnnotationPointcut()")</span></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">invokeResourceWithSentinel</span><span class=params>(ProceedingJoinPoint pjp)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        <span class=comment>// 获取受保护的方法</span></span><br><span class=line>        <span class=type>Method</span> <span class=variable>originMethod</span> <span class=operator>=</span> resolveMethod(pjp);</span><br><span class=line>		<span class=comment>// 获取 @SentinelResource注解</span></span><br><span class=line>        <span class=type>SentinelResource</span> <span class=variable>annotation</span> <span class=operator>=</span> originMethod.getAnnotation(SentinelResource.class);</span><br><span class=line>        <span class=keyword>if</span> (annotation == <span class=literal>null</span>) {</span><br><span class=line>            <span class=comment>// Should not go through here.</span></span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalStateException</span>(<span class=string>"Wrong state for SentinelResource annotation"</span>);</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 获取注解上的资源名称</span></span><br><span class=line>        <span class=type>String</span> <span class=variable>resourceName</span> <span class=operator>=</span> getResourceName(annotation.value(), originMethod);</span><br><span class=line>        <span class=type>EntryType</span> <span class=variable>entryType</span> <span class=operator>=</span> annotation.entryType();</span><br><span class=line>        <span class=type>int</span> <span class=variable>resourceType</span> <span class=operator>=</span> annotation.resourceType();</span><br><span class=line>        <span class=type>Entry</span> <span class=variable>entry</span> <span class=operator>=</span> <span class=literal>null</span>;</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            <span class=comment>// 创建资源 Entry</span></span><br><span class=line>            entry = SphU.entry(resourceName, resourceType, entryType, pjp.getArgs());</span><br><span class=line>            <span class=comment>// 执行受保护的方法</span></span><br><span class=line>            <span class=type>Object</span> <span class=variable>result</span> <span class=operator>=</span> pjp.proceed();</span><br><span class=line>            <span class=keyword>return</span> result;</span><br><span class=line>        } <span class=keyword>catch</span> (BlockException ex) {</span><br><span class=line>            <span class=keyword>return</span> handleBlockException(pjp, annotation, ex);</span><br><span class=line>        } <span class=keyword>catch</span> (Throwable ex) {</span><br><span class=line>            Class&LT? <span class=keyword>extends</span> <span class="title class_">Throwable</span>>[] exceptionsToIgnore = annotation.exceptionsToIgnore();</span><br><span class=line>            <span class=comment>// The ignore list will be checked first.</span></span><br><span class=line>            <span class=keyword>if</span> (exceptionsToIgnore.length > <span class=number>0</span> && exceptionBelongsTo(ex, exceptionsToIgnore)) {</span><br><span class=line>                <span class=keyword>throw</span> ex;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (exceptionBelongsTo(ex, annotation.exceptionsToTrace())) {</span><br><span class=line>                traceException(ex);</span><br><span class=line>                <span class=keyword>return</span> handleFallback(pjp, annotation, ex);</span><br><span class=line>            }</span><br><span class=line></span><br><span class=line>            <span class=comment>// No fallback function can handle the exception, so throw it out.</span></span><br><span class=line>            <span class=keyword>throw</span> ex;</span><br><span class=line>        } <span class=keyword>finally</span> {</span><br><span class=line>            <span class=keyword>if</span> (entry != <span class=literal>null</span>) {</span><br><span class=line>                entry.exit(<span class=number>1</span>, pjp.getArgs());</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong><code>@SentinelResource</code>注解原理是基于AOP来对被标记方法做环绕增强，完成资源（<code>Entry</code>）创建。</strong><h2 id=1-4、Context><a class=headerlink href=#1-4、Context title=1.4、Context></a>1.4、Context</h2><p>簇点链路中除了controller方法、service方法两个资源外，还有一个默认入口节点<code>sentinel_spring_web_context</code>，是一个EntranceNode 类型节点，该节点在初始化Context时由Sentinel创建。<h3 id=1-4-1、Context定义><a class=headerlink href=#1-4-1、Context定义 title=1.4.1、Context定义></a>1.4.1、Context定义</h3><ul><li>Context 代表调用链路上下文，贯穿一次调用链路中的所有资源（ <code>Entry</code>），基于ThreadLocal。<li>Context 维持着入口节点（<code>entranceNode</code>）、本次调用链路的 curNode（当前资源节点）、调用来源（<code>origin</code>）等信息。<li>后续的Slot都可以通过Context拿到DefaultNode或者ClusterNode，从而获取统计数据，完成规则判断。<li>Context初始化的过程中，会创建EntranceNode，contextName就是EntranceNode的名称。</ul><p>对应API：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>// 创建context，包含两个参数：context名称、 来源名称</span></span><br><span class=line>ContextUtil.enter(<span class=string>"contextName"</span>, <span class=string>"originName"</span>);</span><br></pre></table></figure><h3 id=1-4-2、Context初始化><a class=headerlink href=#1-4-2、Context初始化 title=1.4.2、Context初始化></a>1.4.2、Context初始化</h3><h4 id=1-4-2-1、自动装配><a class=headerlink href=#1-4-2-1、自动装配 title=1.4.2.1、自动装配></a>1.4.2.1、自动装配</h4><p>sentine依赖包下的<code>spring.factories</code>文件中会注入很多配置类。<p><code>SentinelWebAutoConfiguration</code>实现了<code>WebMvcConfigurer</code>，且添加了拦截器<code>SentinelWebInterceptor</code>。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">addInterceptors</span><span class=params>(InterceptorRegistry registry)</span> {</span><br><span class=line>    <span class=keyword>if</span> (<span class=built_in>this</span>.sentinelWebInterceptorOptional.isPresent()) {</span><br><span class=line>        <span class=type>Filter</span> <span class=variable>filterConfig</span> <span class=operator>=</span> <span class=built_in>this</span>.properties.getFilter();</span><br><span class=line>        </span><br><span class=line>        registry.addInterceptor((HandlerInterceptor)<span class=built_in>this</span>.sentinelWebInterceptorOptional.get())</span><br><span class=line>        .order(filterConfig.getOrder())</span><br><span class=line>        .addPathPatterns(filterConfig.getUrlPatterns());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><code>SentinelWebInterceptors</code>实现了<code>HandlerInterceptor</code>接口，会拦截controller中的方法先执行拦截器的<code>preHandle</code>方法，Context初始化在这里完成。<h1 id=2、ProcessorSlotChain><a class=headerlink href=#2、ProcessorSlotChain title=2、ProcessorSlotChain></a>2、ProcessorSlotChain</h1><h2 id=2-1-入口><a class=headerlink href=#2-1-入口 title=2.1.入口></a>2.1.入口</h2><p>首先，回到一切的入口，<code>AbstractSentinelInterceptor</code>类的<code>preHandle</code>方法，还有<code>SentinelResourceAspect</code>的环绕增强方法。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>entry = SphU.entry(resourceName, resourceType, entryType, pjp.getArgs());</span><br><span class=line><span class=type>Object</span> <span class=variable>result</span> <span class=operator>=</span> pjp.proceed();</span><br><span class=line>var18 = result;</span><br><span class=line><span class=keyword>return</span> var18;</span><br></pre></table></figure><p>任何一个资源必定要执行<code>SphU.entry()</code>这个方法:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> Entry <span class="title function_">entry</span><span class=params>(String name, <span class=type>int</span> resourceType, EntryType trafficType, Object[] args)</span></span><br><span class=line>    <span class=keyword>throws</span> BlockException {</span><br><span class=line>    <span class=keyword>return</span> Env.sph.entryWithType(name, resourceType, trafficType, <span class=number>1</span>, args);</span><br><span class=line>}</span><br></pre></table></figure><p>继续进入<code>Env.sph.entryWithType(name, resourceType, trafficType, 1, args);</code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> Entry <span class="title function_">entryWithType</span><span class=params>(String name, <span class=type>int</span> resourceType, EntryType entryType, <span class=type>int</span> count, <span class=type>boolean</span> prioritized,</span></span><br><span class=line><span class=params>                           Object[] args)</span> <span class=keyword>throws</span> BlockException {</span><br><span class=line>    <span class=comment>// 将 资源名称等基本信息 封装为一个 StringResourceWrapper对象</span></span><br><span class=line>    <span class=type>StringResourceWrapper</span> <span class=variable>resource</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StringResourceWrapper</span>(name, entryType, resourceType);</span><br><span class=line>    <span class=comment>// 继续</span></span><br><span class=line>    <span class=keyword>return</span> entryWithPriority(resource, count, prioritized, args);</span><br><span class=line>}</span><br></pre></table></figure><p>进入<code>entryWithPriority</code>方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> Entry <span class="title function_">entryWithPriority</span><span class=params>(ResourceWrapper resourceWrapper, <span class=type>int</span> count, <span class=type>boolean</span> prioritized, Object... args)</span></span><br><span class=line>    <span class=keyword>throws</span> BlockException {</span><br><span class=line>    <span class=comment>// 获取 Context</span></span><br><span class=line>    <span class=type>Context</span> <span class=variable>context</span> <span class=operator>=</span> ContextUtil.getContext();</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (context == <span class=literal>null</span>) {</span><br><span class=line>        <span class=comment>// Using default context.</span></span><br><span class=line>        context = InternalContextUtil.internalEnter(Constants.CONTEXT_DEFAULT_NAME);</span><br><span class=line>    }</span><br><span class=line>、	<span class=comment>// 获取 Slot执行链，同一个资源，会创建一个执行链，放入缓存</span></span><br><span class=line>    ProcessorSlot&LTObject> chain = lookProcessChain(resourceWrapper);</span><br><span class=line></span><br><span class=line>	<span class=comment>// 创建 Entry，并将 resource、chain、context 记录在 Entry中</span></span><br><span class=line>    <span class=type>Entry</span> <span class=variable>e</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">CtEntry</span>(resourceWrapper, chain, context);</span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        <span class=comment>// 执行 slotChain</span></span><br><span class=line>        chain.entry(context, resourceWrapper, <span class=literal>null</span>, count, prioritized, args);</span><br><span class=line>    } <span class=keyword>catch</span> (BlockException e1) {</span><br><span class=line>        e.exit(count, args);</span><br><span class=line>        <span class=keyword>throw</span> e1;</span><br><span class=line>    } <span class=keyword>catch</span> (Throwable e1) {</span><br><span class=line>        <span class=comment>// This should not happen, unless there are errors existing in Sentinel internal.</span></span><br><span class=line>        RecordLog.info(<span class=string>"Sentinel unexpected exception"</span>, e1);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> e;</span><br><span class=line>}</span><br></pre></table></figure><p>在这段代码中，会获取<code>ProcessorSlotChain</code>对象，然后基于chain.entry()开始执行slotChain中的每一个Slot. 而这里创建的是其实现类：DefaultProcessorSlotChain.<p>获取ProcessorSlotChain以后会保存到一个Map中，key是ResourceWrapper，值是ProcessorSlotChain.<p>所以，<strong>一个资源只会有一个ProcessorSlotChain</strong>.<h2 id=2-2-DefaultProcessorSlotChain><a class=headerlink href=#2-2-DefaultProcessorSlotChain title=2.2.DefaultProcessorSlotChain></a>2.2.DefaultProcessorSlotChain</h2><p>进入DefaultProcessorSlotChain的entry方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">entry</span><span class=params>(Context context, ResourceWrapper resourceWrapper, Object t, <span class=type>int</span> count, <span class=type>boolean</span> prioritized, Object... args)</span></span><br><span class=line>    <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=comment>// first，就是责任链中的第一个 slot</span></span><br><span class=line>    first.transformEntry(context, resourceWrapper, t, count, prioritized, args);</span><br><span class=line>}</span><br></pre></table></figure><p>这里的 first 类型是AbstractLinkedProcessorSlot：<p>因此，first一定是这些实现类中的一个，按照最早讲的责任链顺序，first应该就是 <code>NodeSelectorSlot</code>。<p>不过，既然是基于责任链模式，所以这里只要记住下一个slot就可以了，也就是next，next确实是NodeSelectSlot类型。<p>而NodeSelectSlot的next一定是ClusterBuilderSlot，依次类推，责任链就建立起来了。<h2 id=2-3-NodeSelectorSlot><a class=headerlink href=#2-3-NodeSelectorSlot title=2.3.NodeSelectorSlot></a>2.3.NodeSelectorSlot</h2><p>NodeSelectorSlot负责构建簇点链路中的节点（DefaultNode），将这些节点形成链路树。<p>核心代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">entry</span><span class=params>(Context context, ResourceWrapper resourceWrapper, Object obj, <span class=type>int</span> count, <span class=type>boolean</span> prioritized, Object... args)</span></span><br><span class=line>    <span class=keyword>throws</span> Throwable {</span><br><span class=line>  	<span class=comment>// 尝试获取 当前资源的 DefaultNode</span></span><br><span class=line>    <span class=type>DefaultNode</span> <span class=variable>node</span> <span class=operator>=</span> map.get(context.getName());</span><br><span class=line>    <span class=keyword>if</span> (node == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>synchronized</span> (<span class=built_in>this</span>) {</span><br><span class=line>            node = map.get(context.getName());</span><br><span class=line>            <span class=keyword>if</span> (node == <span class=literal>null</span>) {</span><br><span class=line>                <span class=comment>// 如果为空，为当前资源创建一个新的 DefaultNode</span></span><br><span class=line>                node = <span class=keyword>new</span> <span class="title class_">DefaultNode</span>(resourceWrapper, <span class=literal>null</span>);</span><br><span class=line>                HashMap&LTString, DefaultNode> cacheMap = <span class=keyword>new</span> <span class="title class_">HashMap</span>&LTString, DefaultNode>(map.size());</span><br><span class=line>                cacheMap.putAll(map);</span><br><span class=line>                <span class=comment>// 放入缓存中，注意这里的 key是contextName，</span></span><br><span class=line>                <span class=comment>// 这样不同链路进入相同资源，就会创建多个 DefaultNode</span></span><br><span class=line>                cacheMap.put(context.getName(), node);</span><br><span class=line>                map = cacheMap;</span><br><span class=line>                <span class=comment>// 当前节点加入上一节点的 child中，这样就构成了调用链路树</span></span><br><span class=line>                ((DefaultNode) context.getLastNode()).addChild(node);</span><br><span class=line>            }</span><br><span class=line></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// context中的curNode（当前节点）设置为新的 node</span></span><br><span class=line>    context.setCurNode(node);</span><br><span class=line>    <span class=comment>// 执行下一个 slot</span></span><br><span class=line>    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=line>}</span><br></pre></table></figure><p>这个Slot完成了这么几件事情：<ul><li>为当前资源创建 DefaultNode<li>将DefaultNode放入缓存中，key是contextName，这样不同链路入口的请求，将会创建多个DefaultNode，相同链路则只有一个DefaultNode<li>将当前资源的DefaultNode设置为上一个资源的childNode<li>将当前资源的DefaultNode设置为Context中的curNode（当前节点）</ul><p>下一个slot，就是ClusterBuilderSlot<h2 id=2-4-ClusterBuilderSlot><a class=headerlink href=#2-4-ClusterBuilderSlot title=2.4.ClusterBuilderSlot></a>2.4.ClusterBuilderSlot</h2><p>ClusterBuilderSlot负责构建某个资源的ClusterNode，核心代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">entry</span><span class=params>(Context context, ResourceWrapper resourceWrapper, DefaultNode node,</span></span><br><span class=line><span class=params>                  <span class=type>int</span> count, <span class=type>boolean</span> prioritized, Object... args)</span></span><br><span class=line>    <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=comment>// 判空，注意ClusterNode是共享的成员变量，也就是说一个资源只有一个ClusterNode，与链路无关</span></span><br><span class=line>    <span class=keyword>if</span> (clusterNode == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>synchronized</span> (lock) {</span><br><span class=line>            <span class=keyword>if</span> (clusterNode == <span class=literal>null</span>) {</span><br><span class=line>                <span class=comment>// 创建 cluster node.</span></span><br><span class=line>                clusterNode = <span class=keyword>new</span> <span class="title class_">ClusterNode</span>(resourceWrapper.getName(), resourceWrapper.getResourceType());</span><br><span class=line>                HashMap&LTResourceWrapper, ClusterNode> newMap = <span class=keyword>new</span> <span class="title class_">HashMap</span><>(Math.max(clusterNodeMap.size(), <span class=number>16</span>));</span><br><span class=line>                newMap.putAll(clusterNodeMap);</span><br><span class=line>                <span class=comment>// 放入缓存，可以是nodeId，也就是resource名称</span></span><br><span class=line>                newMap.put(node.getId(), clusterNode);</span><br><span class=line>                clusterNodeMap = newMap;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 将资源的 DefaultNode与 ClusterNode关联</span></span><br><span class=line>    node.setClusterNode(clusterNode);</span><br><span class=line>	<span class=comment>// 记录请求来源 origin 将 origin放入 entry</span></span><br><span class=line>    <span class=keyword>if</span> (!<span class=string>""</span>.equals(context.getOrigin())) {</span><br><span class=line>        <span class=type>Node</span> <span class=variable>originNode</span> <span class=operator>=</span> node.getClusterNode().getOrCreateOriginNode(context.getOrigin());</span><br><span class=line>        context.getCurEntry().setOriginNode(originNode);</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 继续下一个slot</span></span><br><span class=line>    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=line>}</span><br></pre></table></figure><h2 id=2-5-StatisticSlot><a class=headerlink href=#2-5-StatisticSlot title=2.5.StatisticSlot></a>2.5.StatisticSlot</h2><p>StatisticSlot负责统计实时调用数据，包括运行信息（访问次数、线程数）、来源信息等。<p>StatisticSlot是实现限流的关键，其中<strong>基于滑动时间窗口算法维护了计数器，统计进入某个资源的请求次数。</strong><p>核心代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">entry</span><span class=params>(Context context, ResourceWrapper resourceWrapper, DefaultNode node, </span></span><br><span class=line><span class=params>                  <span class=type>int</span> count, <span class=type>boolean</span> prioritized, Object... args)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        <span class=comment>// 放行到下一个 slot，做限流、降级等判断</span></span><br><span class=line>        fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 请求通过了, 线程计数器 +1 ，用作线程隔离</span></span><br><span class=line>        node.increaseThreadNum();</span><br><span class=line>        <span class=comment>// 请求计数器 +1 用作限流</span></span><br><span class=line>        node.addPassRequest(count);</span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> (context.getCurEntry().getOriginNode() != <span class=literal>null</span>) {</span><br><span class=line>            <span class=comment>// 如果有 origin，来源计数器也都要 +1</span></span><br><span class=line>            context.getCurEntry().getOriginNode().increaseThreadNum();</span><br><span class=line>            context.getCurEntry().getOriginNode().addPassRequest(count);</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> (resourceWrapper.getEntryType() == EntryType.IN) {</span><br><span class=line>            <span class=comment>// 如果是入口资源，还要给全局计数器 +1.</span></span><br><span class=line>            Constants.ENTRY_NODE.increaseThreadNum();</span><br><span class=line>            Constants.ENTRY_NODE.addPassRequest(count);</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=comment>// 请求通过后的回调.</span></span><br><span class=line>        <span class=keyword>for</span> (ProcessorSlotEntryCallback&LTDefaultNode> handler : StatisticSlotCallbackRegistry.getEntryCallbacks()) {</span><br><span class=line>            handler.onPass(context, resourceWrapper, node, count, args);</span><br><span class=line>        }</span><br><span class=line>    } <span class=keyword>catch</span> (Throwable e) {</span><br><span class=line>        <span class=comment>// 各种异常处理就省略了。。。</span></span><br><span class=line>        context.getCurEntry().setError(e);</span><br><span class=line></span><br><span class=line>        <span class=keyword>throw</span> e;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>另外，需要注意的是，所有的计数+1动作都包括两部分，以<code> node.addPassRequest(count);</code>为例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">addPassRequest</span><span class=params>(<span class=type>int</span> count)</span> {</span><br><span class=line>    <span class=comment>// DefaultNode的计数器，代表当前链路的 计数器</span></span><br><span class=line>    <span class=built_in>super</span>.addPassRequest(count);</span><br><span class=line>    <span class=comment>// ClusterNode计数器，代表当前资源的 总计数器</span></span><br><span class=line>    <span class=built_in>this</span>.clusterNode.addPassRequest(count);</span><br><span class=line>}</span><br></pre></table></figure><p>具体计数方式，我们后续再看。<p>接下来，进入规则校验的相关slot了，依次是：<ul><li>AuthoritySlot：负责授权规则（来源控制）<li>SystemSlot：负责系统保护规则<li>ParamFlowSlot：负责热点参数限流规则<li>FlowSlot：负责限流规则<li>DegradeSlot：负责降级规则</ul><h2 id=2-6-AuthoritySlot><a class=headerlink href=#2-6-AuthoritySlot title=2.6.AuthoritySlot></a>2.6.AuthoritySlot</h2><p>核心API：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">entry</span><span class=params>(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class=type>int</span> count, <span class=type>boolean</span> prioritized, Object... args)</span></span><br><span class=line>    <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=comment>// 校验黑白名单</span></span><br><span class=line>    checkBlackWhiteAuthority(resourceWrapper, context);</span><br><span class=line>    <span class=comment>// 进入下一个 slot</span></span><br><span class=line>    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=line>}</span><br></pre></table></figure><p>黑白名单校验的逻辑：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> <span class="title function_">checkBlackWhiteAuthority</span><span class=params>(ResourceWrapper resource, Context context)</span> <span class=keyword>throws</span> AuthorityException {</span><br><span class=line>    <span class=comment>// 获取授权规则</span></span><br><span class=line>    Map&LTString, Set&LTAuthorityRule>> authorityRules = AuthorityRuleManager.getAuthorityRules();</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (authorityRules == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    Set&LTAuthorityRule> rules = authorityRules.get(resource.getName());</span><br><span class=line>    <span class=keyword>if</span> (rules == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 遍历规则并判断</span></span><br><span class=line>    <span class=keyword>for</span> (AuthorityRule rule : rules) {</span><br><span class=line>        <span class=keyword>if</span> (!AuthorityRuleChecker.passCheck(rule, context)) {</span><br><span class=line>            <span class=comment>// 规则不通过，直接抛出异常</span></span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">AuthorityException</span>(context.getOrigin(), rule);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>再看下<code>AuthorityRuleChecker.passCheck(rule, context)</code>方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line><span class=keyword>static</span> <span class=type>boolean</span> <span class="title function_">passCheck</span><span class=params>(AuthorityRule rule, Context context)</span> {</span><br><span class=line>    <span class=comment>// 得到请求来源 origin</span></span><br><span class=line>    <span class=type>String</span> <span class=variable>requester</span> <span class=operator>=</span> context.getOrigin();</span><br><span class=line></span><br><span class=line>    <span class=comment>// 来源为空，或者规则为空，都直接放行</span></span><br><span class=line>    <span class=keyword>if</span> (StringUtil.isEmpty(requester) || StringUtil.isEmpty(rule.getLimitApp())) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// rule.getLimitApp()得到的就是 白名单 或 黑名单 的字符串，这里先用 indexOf方法判断</span></span><br><span class=line>    <span class=type>int</span> <span class=variable>pos</span> <span class=operator>=</span> rule.getLimitApp().indexOf(requester);</span><br><span class=line>    <span class=type>boolean</span> <span class=variable>contain</span> <span class=operator>=</span> pos > -<span class=number>1</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (contain) {</span><br><span class=line>        <span class=comment>// 如果包含 origin，还要进一步做精确判断，把名单列表以","分割，逐个判断</span></span><br><span class=line>        <span class=type>boolean</span> <span class=variable>exactlyMatch</span> <span class=operator>=</span> <span class=literal>false</span>;</span><br><span class=line>        String[] appArray = rule.getLimitApp().split(<span class=string>","</span>);</span><br><span class=line>        <span class=keyword>for</span> (String app : appArray) {</span><br><span class=line>            <span class=keyword>if</span> (requester.equals(app)) {</span><br><span class=line>                exactlyMatch = <span class=literal>true</span>;</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        contain = exactlyMatch;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 如果是黑名单，并且包含origin，则返回false</span></span><br><span class=line>    <span class=type>int</span> <span class=variable>strategy</span> <span class=operator>=</span> rule.getStrategy();</span><br><span class=line>    <span class=keyword>if</span> (strategy == RuleConstant.AUTHORITY_BLACK && contain) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 如果是白名单，并且不包含origin，则返回false</span></span><br><span class=line>    <span class=keyword>if</span> (strategy == RuleConstant.AUTHORITY_WHITE && !contain) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 其它情况返回true</span></span><br><span class=line>    <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>}</span><br></pre></table></figure><h2 id=2-7-SystemSlot><a class=headerlink href=#2-7-SystemSlot title=2.7.SystemSlot></a>2.7.SystemSlot</h2><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">entry</span><span class=params>(Context context, ResourceWrapper resourceWrapper, DefaultNode node, </span></span><br><span class=line><span class=params>                  <span class=type>int</span> count,<span class=type>boolean</span> prioritized, Object... args)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=comment>// 系统规则校验</span></span><br><span class=line>    SystemRuleManager.checkSystem(resourceWrapper);</span><br><span class=line>    <span class=comment>// 进入下一个 slot</span></span><br><span class=line>    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=line>}</span><br></pre></table></figure><p>来看下<code>SystemRuleManager.checkSystem(resourceWrapper);</code>的代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">checkSystem</span><span class=params>(ResourceWrapper resourceWrapper)</span> <span class=keyword>throws</span> BlockException {</span><br><span class=line>    <span class=keyword>if</span> (resourceWrapper == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// Ensure the checking switch is on.</span></span><br><span class=line>    <span class=keyword>if</span> (!checkSystemStatus.get()) {</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 只针对入口资源做校验，其它直接返回</span></span><br><span class=line>    <span class=keyword>if</span> (resourceWrapper.getEntryType() != EntryType.IN) {</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 全局 QPS校验</span></span><br><span class=line>    <span class=type>double</span> <span class=variable>currentQps</span> <span class=operator>=</span> Constants.ENTRY_NODE == <span class=literal>null</span> ? <span class=number>0.0</span> : Constants.ENTRY_NODE.successQps();</span><br><span class=line>    <span class=keyword>if</span> (currentQps > qps) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">SystemBlockException</span>(resourceWrapper.getName(), <span class=string>"qps"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 全局 线程数 校验</span></span><br><span class=line>    <span class=type>int</span> <span class=variable>currentThread</span> <span class=operator>=</span> Constants.ENTRY_NODE == <span class=literal>null</span> ? <span class=number>0</span> : Constants.ENTRY_NODE.curThreadNum();</span><br><span class=line>    <span class=keyword>if</span> (currentThread > maxThread) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">SystemBlockException</span>(resourceWrapper.getName(), <span class=string>"thread"</span>);</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 全局平均 RT校验</span></span><br><span class=line>    <span class=type>double</span> <span class=variable>rt</span> <span class=operator>=</span> Constants.ENTRY_NODE == <span class=literal>null</span> ? <span class=number>0</span> : Constants.ENTRY_NODE.avgRt();</span><br><span class=line>    <span class=keyword>if</span> (rt > maxRt) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">SystemBlockException</span>(resourceWrapper.getName(), <span class=string>"rt"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 全局 系统负载 校验</span></span><br><span class=line>    <span class=keyword>if</span> (highestSystemLoadIsSet && getCurrentSystemAvgLoad() > highestSystemLoad) {</span><br><span class=line>        <span class=keyword>if</span> (!checkBbr(currentThread)) {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">SystemBlockException</span>(resourceWrapper.getName(), <span class=string>"load"</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 全局 CPU使用率 校验</span></span><br><span class=line>    <span class=keyword>if</span> (highestCpuUsageIsSet && getCurrentCpuUsage() > highestCpuUsage) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">SystemBlockException</span>(resourceWrapper.getName(), <span class=string>"cpu"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=2-8-ParamFlowSlot><a class=headerlink href=#2-8-ParamFlowSlot title=2.8.ParamFlowSlot></a>2.8.ParamFlowSlot</h2><p>是针对进入资源的请求，针对不同的请求参数值分别统计QPS的限流方式。<ul><li><p>这里的单机阈值，就是最大令牌数量：maxCount</p><li><p>这里的统计窗口时长，就是统计时长：duration</p></ul><p>含义是每隔duration时间长度内，最多生产maxCount个令牌，上图配置的含义是每1秒钟生产2个令牌。<p>核心API：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">entry</span><span class=params>(Context context, ResourceWrapper resourceWrapper, DefaultNode node,</span></span><br><span class=line><span class=params>                  <span class=type>int</span> count, <span class=type>boolean</span> prioritized, Object... args)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=comment>// 如果没有设置热点规则，直接放行</span></span><br><span class=line>    <span class=keyword>if</span> (!ParamFlowRuleManager.hasRules(resourceWrapper.getName())) {</span><br><span class=line>        fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 热点规则判断</span></span><br><span class=line>    checkFlow(resourceWrapper, count, args);</span><br><span class=line>    <span class=comment>// 进入下一个 slot</span></span><br><span class=line>    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=line>}</span><br></pre></table></figure><h3 id=2-8-1-令牌桶><a class=headerlink href=#2-8-1-令牌桶 title=2.8.1.令牌桶></a>2.8.1.令牌桶</h3><p>热点规则判断采用了令牌桶算法来实现参数限流，为每一个不同参数值设置令牌桶，Sentinel的令牌桶有两部分组成：<p>这两个Map的key都是请求的参数值，value却不同，其中：<ul><li>tokenCounters：用来记录剩余令牌数量<li>timeCounters：用来记录上一个请求的时间</ul><h2 id=2-9-FlowSlot><a class=headerlink href=#2-9-FlowSlot title=2.9.FlowSlot></a>2.9.FlowSlot</h2><p>包括：<ul><li>三种流控模式：直接模式、关联模式、链路模式<li>三种流控效果：快速失败、warm up、排队等待</ul><p>三种流控模式，从底层<strong>数据统计</strong>角度，分为两类：<ul><li>对进入资源的所有请求（ClusterNode）做限流统计：直接模式、关联模式<li>对进入资源的部分链路（DefaultNode）做限流统计：链路模式</ul><p>三种流控效果，从<strong>限流算法</strong>来看，分为两类：<ul><li>滑动时间窗口算法：快速失败、warm up<li>漏桶算法：排队等待效果</ul><h3 id=2-9-1-核心流程><a class=headerlink href=#2-9-1-核心流程 title=2.9.1.核心流程></a>2.9.1.核心流程</h3><p>核心API如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">entry</span><span class=params>(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class=type>int</span> count,</span></span><br><span class=line><span class=params>                  <span class=type>boolean</span> prioritized, Object... args)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=comment>// 限流规则检测</span></span><br><span class=line>    checkFlow(resourceWrapper, context, node, count, prioritized);</span><br><span class=line>	<span class=comment>// 放行</span></span><br><span class=line>    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=line>}</span><br></pre></table></figure><p>checkFlow方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> <span class="title function_">checkFlow</span><span class=params>(ResourceWrapper resource, Context context, DefaultNode node, <span class=type>int</span> count, <span class=type>boolean</span> prioritized)</span></span><br><span class=line>    <span class=keyword>throws</span> BlockException {</span><br><span class=line>    <span class=comment>// checker是 FlowRuleChecker 类的一个对象</span></span><br><span class=line>    checker.checkFlow(ruleProvider, resource, context, node, count, prioritized);</span><br><span class=line>}</span><br></pre></table></figure><p>跟入FlowRuleChecker：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">checkFlow</span><span class=params>(Function&LTString, Collection&LTFlowRule>> ruleProvider, </span></span><br><span class=line><span class=params>                      ResourceWrapper resource,Context context, DefaultNode node,</span></span><br><span class=line><span class=params>                      <span class=type>int</span> count, <span class=type>boolean</span> prioritized)</span> <span class=keyword>throws</span> BlockException {</span><br><span class=line>        <span class=keyword>if</span> (ruleProvider == <span class=literal>null</span> || resource == <span class=literal>null</span>) {</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 获取当前资源的所有限流规则</span></span><br><span class=line>        Collection&LTFlowRule> rules = ruleProvider.apply(resource.getName());</span><br><span class=line>        <span class=keyword>if</span> (rules != <span class=literal>null</span>) {</span><br><span class=line>            <span class=keyword>for</span> (FlowRule rule : rules) {</span><br><span class=line>                <span class=comment>// 遍历，逐个规则做校验</span></span><br><span class=line>                <span class=keyword>if</span> (!canPassCheck(rule, context, node, count, prioritized)) {</span><br><span class=line>                    <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">FlowException</span>(rule.getLimitApp(), rule);</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br></pre></table></figure><p>这里的FlowRule就是限流规则接口，其中的几个成员变量，刚好对应表单参数：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">FlowRule</span> <span class=keyword>extends</span> <span class="title class_">AbstractRule</span> {</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 阈值类型 (0: 线程, 1: QPS).</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>grade</span> <span class=operator>=</span> RuleConstant.FLOW_GRADE_QPS;</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 阈值.</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>private</span> <span class=type>double</span> count;</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 三种限流模式.</span></span><br><span class=line><span class=comment>     *</span></span><br><span class=line><span class=comment>     * {<span class=doctag>@link</span> RuleConstant#STRATEGY_DIRECT} 直连模式;</span></span><br><span class=line><span class=comment>     * {<span class=doctag>@link</span> RuleConstant#STRATEGY_RELATE} 关联模式;</span></span><br><span class=line><span class=comment>     * {<span class=doctag>@link</span> RuleConstant#STRATEGY_CHAIN} 链路模式.</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>strategy</span> <span class=operator>=</span> RuleConstant.STRATEGY_DIRECT;</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 关联模式关联的资源名称.</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>private</span> String refResource;</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 3种流控效果.</span></span><br><span class=line><span class=comment>     * 0. 快速失败, 1. warm up, 2. 排队等待, 3. warm up + 排队等待</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>controlBehavior</span> <span class=operator>=</span> RuleConstant.CONTROL_BEHAVIOR_DEFAULT;</span><br><span class=line>	<span class=comment>// 预热时长</span></span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>warmUpPeriodSec</span> <span class=operator>=</span> <span class=number>10</span>;</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 队列最大等待时间.</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>maxQueueingTimeMs</span> <span class=operator>=</span> <span class=number>500</span>;</span><br><span class=line>    <span class=comment>// 。。。 略</span></span><br><span class=line>}</span><br></pre></table></figure><p>校验的逻辑定义在<code>FlowRuleChecker</code>的<code>canPassCheck</code>方法中：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">canPassCheck</span><span class=params>(<span class=comment>/*@NonNull*/</span> FlowRule rule, Context context, DefaultNode node, <span class=type>int</span> acquireCount,</span></span><br><span class=line><span class=params>                            <span class=type>boolean</span> prioritized)</span> {</span><br><span class=line>    <span class=comment>// 获取限流资源名称</span></span><br><span class=line>    <span class=type>String</span> <span class=variable>limitApp</span> <span class=operator>=</span> rule.getLimitApp();</span><br><span class=line>    <span class=keyword>if</span> (limitApp == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 校验规则</span></span><br><span class=line>    <span class=keyword>return</span> passLocalCheck(rule, context, node, acquireCount, prioritized);</span><br><span class=line>}</span><br></pre></table></figure><p>进入<code>passLocalCheck()</code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=keyword>static</span> <span class=type>boolean</span> <span class="title function_">passLocalCheck</span><span class=params>(FlowRule rule, Context context, DefaultNode node,</span></span><br><span class=line><span class=params>                                      <span class=type>int</span> acquireCount,  <span class=type>boolean</span> prioritized)</span> {</span><br><span class=line>    <span class=comment>// 基于限流模式判断要统计的节点， </span></span><br><span class=line>    <span class=comment>// 如果是直连模式，关联模式，对ClusterNode统计，如果是链路模式，则对DefaultNode统计</span></span><br><span class=line>    <span class=type>Node</span> <span class=variable>selectedNode</span> <span class=operator>=</span> selectNodeByRequesterAndStrategy(rule, context, node);</span><br><span class=line>    <span class=keyword>if</span> (selectedNode == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 判断规则</span></span><br><span class=line>    <span class=keyword>return</span> rule.getRater().canPass(selectedNode, acquireCount, prioritized);</span><br><span class=line>}</span><br></pre></table></figure><p>这里对规则的判断先要通过<code>FlowRule#getRater()</code>获取流量控制器<code>TrafficShapingController</code>，然后再做限流。<p>而<code>TrafficShapingController</code>有3种实现：<ul><li>DefaultController：快速失败，默认的方式，基于滑动时间窗口算法<li>WarmUpController：预热模式，基于滑动时间窗口算法，只不过阈值是动态的<li>RateLimiterController：排队等待模式，基于漏桶算法</ul><p>最终的限流判断都在TrafficShapingController的canPass方法中。<h3 id=2-9-2-滑动时间窗口><a class=headerlink href=#2-9-2-滑动时间窗口 title=2.9.2.滑动时间窗口></a>2.9.2.滑动时间窗口</h3><p>滑动时间窗口的功能分两部分来看：<ul><li>一是时间区间窗口的QPS计数功能，这个是在StatisticSlot中调用的<li>二是对滑动窗口内的时间区间窗口QPS累加，这个是在FlowRule中调用的</ul><p>先来看时间区间窗口的QPS计数功能。<h4 id=2-9-2-1-时间窗口请求量统计><a class=headerlink href=#2-9-2-1-时间窗口请求量统计 title=2.9.2.1.时间窗口请求量统计></a>2.9.2.1.时间窗口请求量统计</h4><p>回顾2.5章节中的StatisticSlot部分，有这样一段代码：<p><img alt=image-20210925180522926 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925180522926.png><p>就是在统计通过该节点的QPS，我们跟入看看，这里进入了DefaultNode内部：<p><img alt=image-20210925180619492 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925180619492.png><p>发现同时对<code>DefaultNode</code>和<code>ClusterNode</code>在做QPS统计，我们知道<code>DefaultNode</code>和<code>ClusterNode</code>都是<code>StatisticNode</code>的子类，这里调用<code>addPassRequest()</code>方法，最终都会进入<code>StatisticNode</code>中。<p>随便跟入一个：<p><img alt=image-20210925180810181 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925180810181.png><p>这里有秒、分两种纬度的统计，对应两个计数器。找到对应的成员变量，可以看到：<p><img alt=image-20210925180954856 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925180954856.png><p>两个计数器都是ArrayMetric类型，并且传入了两个参数：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment>// intervalInMs：是滑动窗口的时间间隔，默认为 1 秒</span></span><br><span class=line><span class=comment>// sampleCount: 时间窗口的分隔数量，默认为 2，就是把 1秒分为 2个小时间窗</span></span><br><span class=line><span class=keyword>public</span> <span class="title function_">ArrayMetric</span><span class=params>(<span class=type>int</span> sampleCount, <span class=type>int</span> intervalInMs)</span> {</span><br><span class=line>    <span class=built_in>this</span>.data = <span class=keyword>new</span> <span class="title class_">OccupiableBucketLeapArray</span>(sampleCount, intervalInMs);</span><br><span class=line>}</span><br></pre></table></figure><p>如图：<p><img alt=image-20210925181359203 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925181359203.png><p>接下来，我们进入<code>ArrayMetric</code>类的<code>addPass</code>方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">addPass</span><span class=params>(<span class=type>int</span> count)</span> {</span><br><span class=line>    <span class=comment>// 获取当前时间所在的时间窗</span></span><br><span class=line>    WindowWrap&LTMetricBucket> wrap = data.currentWindow();</span><br><span class=line>    <span class=comment>// 计数器 +1</span></span><br><span class=line>    wrap.value().addPass(count);</span><br><span class=line>}</span><br></pre></table></figure><p>那么，计数器如何知道当前所在的窗口是哪个呢？<p>这里的data是一个LeapArray：<p><img alt=image-20210925181714605 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925181714605.png><p>LeapArray的四个属性：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">LeapArray</span>&LTT> {</span><br><span class=line>    <span class=comment>// 小窗口的时间长度，默认是500ms ，值 = intervalInMs / sampleCount</span></span><br><span class=line>    <span class=keyword>protected</span> <span class=type>int</span> windowLengthInMs;</span><br><span class=line>    <span class=comment>// 滑动窗口内的 小窗口 数量，默认为 2</span></span><br><span class=line>    <span class=keyword>protected</span> <span class=type>int</span> sampleCount;</span><br><span class=line>    <span class=comment>// 滑动窗口的时间间隔，默认为 1000ms</span></span><br><span class=line>    <span class=keyword>protected</span> <span class=type>int</span> intervalInMs;</span><br><span class=line>    <span class=comment>// 滑动窗口的时间间隔，单位为秒，默认为 1</span></span><br><span class=line>    <span class=keyword>private</span> <span class=type>double</span> intervalInSecond;</span><br><span class=line>}</span><br></pre></table></figure><p>LeapArray是一个环形数组，因为时间是无限的，数组长度不可能无限，因此数组中每一个格子放入一个时间窗（window），当数组放满后，角标归0，覆盖最初的window。<p><img alt=image-20210925182127206 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925182127206.png><p>因为滑动窗口最多分成sampleCount数量的小窗口，因此数组长度只要大于sampleCount，那么最近的一个滑动窗口内的2个小窗口就永远不会被覆盖，就不用担心旧数据被覆盖的问题了。<p>我们跟入<code> data.currentWindow();</code>方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> WindowWrap&LTT> <span class="title function_">currentWindow</span><span class=params>(<span class=type>long</span> timeMillis)</span> {</span><br><span class=line>    <span class=keyword>if</span> (timeMillis < <span class=number>0</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 计算当前时间对应的数组角标</span></span><br><span class=line>    <span class=type>int</span> <span class=variable>idx</span> <span class=operator>=</span> calculateTimeIdx(timeMillis);</span><br><span class=line>    <span class=comment>// 计算当前时间所在窗口的开始时间.</span></span><br><span class=line>    <span class=type>long</span> <span class=variable>windowStart</span> <span class=operator>=</span> calculateWindowStart(timeMillis);</span><br><span class=line></span><br><span class=line>    <span class=comment>/*</span></span><br><span class=line><span class=comment>         * 先根据角标获取数组中保存的 oldWindow 对象，可能是旧数据，需要判断.</span></span><br><span class=line><span class=comment>         *</span></span><br><span class=line><span class=comment>         * (1) oldWindow 不存在, 说明是第一次，创建新 window并存入，然后返回即可</span></span><br><span class=line><span class=comment>         * (2) oldWindow的 starTime = 本次请求的 windowStar, 说明正是要找的窗口，直接返回.</span></span><br><span class=line><span class=comment>         * (3) oldWindow的 starTime < 本次请求的 windowStar, 说明是旧数据，需要被覆盖，创建 </span></span><br><span class=line><span class=comment>         *     新窗口，覆盖旧窗口</span></span><br><span class=line><span class=comment>         */</span></span><br><span class=line>    <span class=keyword>while</span> (<span class=literal>true</span>) {</span><br><span class=line>        WindowWrap&LTT> old = array.get(idx);</span><br><span class=line>        <span class=keyword>if</span> (old == <span class=literal>null</span>) {</span><br><span class=line>            <span class=comment>// 创建新 window</span></span><br><span class=line>            WindowWrap&LTT> window = <span class=keyword>new</span> <span class="title class_">WindowWrap</span>&LTT>(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));</span><br><span class=line>            <span class=comment>// 基于CAS写入数组，避免线程安全问题</span></span><br><span class=line>            <span class=keyword>if</span> (array.compareAndSet(idx, <span class=literal>null</span>, window)) {</span><br><span class=line>                <span class=comment>// 写入成功，返回新的 window</span></span><br><span class=line>                <span class=keyword>return</span> window;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=comment>// 写入失败，说明有并发更新，等待其它人更新完成即可</span></span><br><span class=line>                Thread.<span class=keyword>yield</span>();</span><br><span class=line>            }</span><br><span class=line>        } <span class=keyword>else</span> <span class=keyword>if</span> (windowStart == old.windowStart()) {</span><br><span class=line>            <span class=keyword>return</span> old;</span><br><span class=line>        } <span class=keyword>else</span> <span class=keyword>if</span> (windowStart > old.windowStart()) {</span><br><span class=line>            <span class=keyword>if</span> (updateLock.tryLock()) {</span><br><span class=line>                <span class=keyword>try</span> {</span><br><span class=line>                    <span class=comment>// 获取并发锁，覆盖旧窗口并返回</span></span><br><span class=line>                    <span class=keyword>return</span> resetWindowTo(old, windowStart);</span><br><span class=line>                } <span class=keyword>finally</span> {</span><br><span class=line>                    updateLock.unlock();</span><br><span class=line>                }</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=comment>// 获取锁失败，等待其它线程处理就可以了</span></span><br><span class=line>                Thread.<span class=keyword>yield</span>();</span><br><span class=line>            }</span><br><span class=line>        } <span class=keyword>else</span> <span class=keyword>if</span> (windowStart < old.windowStart()) {</span><br><span class=line>            <span class=comment>// 这种情况不应该存在，写这里只是以防万一。</span></span><br><span class=line>            <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">WindowWrap</span>&LTT>(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>找到当前时间所在窗口（WindowWrap）后，只要调用WindowWrap对象中的add方法，计数器+1即可。<p>这里只负责统计每个窗口的请求量，不负责拦截。限流拦截要看FlowSlot中的逻辑。<h4 id=2-9-2-2-滑动窗口QPS计算><a class=headerlink href=#2-9-2-2-滑动窗口QPS计算 title=2.9.2.2.滑动窗口QPS计算></a>2.9.2.2.滑动窗口QPS计算</h4><p>在2.9.1小节我们讲过，FlowSlot的限流判断最终都由<code>TrafficShapingController</code>接口中的<code>canPass</code>方法来实现。该接口有三个实现类：<ul><li>DefaultController：快速失败，默认的方式，基于滑动时间窗口算法。<li>WarmUpController：预热模式，基于滑动时间窗口算法，只不过阈值是动态的。<li>RateLimiterController：排队等待模式，基于漏桶算法</ul><p>因此，我们跟入默认的DefaultController中的canPass方法来分析：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">canPass</span><span class=params>(Node node, <span class=type>int</span> acquireCount, <span class=type>boolean</span> prioritized)</span> {</span><br><span class=line>    <span class=comment>// 计算目前为止滑动窗口内已经存在的请求量</span></span><br><span class=line>    <span class=type>int</span> <span class=variable>curCount</span> <span class=operator>=</span> avgUsedTokens(node);</span><br><span class=line>    <span class=comment>// 判断：已使用请求量 + 需要的请求量（1） 是否大于 窗口的请求阈值</span></span><br><span class=line>    <span class=keyword>if</span> (curCount + acquireCount > count) {</span><br><span class=line>        <span class=comment>// 大于，说明超出阈值，返回false</span></span><br><span class=line>        <span class=keyword>if</span> (prioritized && grade == RuleConstant.FLOW_GRADE_QPS) {</span><br><span class=line>            <span class=type>long</span> currentTime;</span><br><span class=line>            <span class=type>long</span> waitInMs;</span><br><span class=line>            currentTime = TimeUtil.currentTimeMillis();</span><br><span class=line>            waitInMs = node.tryOccupyNext(currentTime, acquireCount, count);</span><br><span class=line>            <span class=keyword>if</span> (waitInMs < OccupyTimeoutProperty.getOccupyTimeout()) {</span><br><span class=line>                node.addWaitingRequest(currentTime + waitInMs, acquireCount);</span><br><span class=line>                node.addOccupiedPass(acquireCount);</span><br><span class=line>                sleep(waitInMs);</span><br><span class=line></span><br><span class=line>                <span class=comment>// PriorityWaitException indicates that the request will pass after waiting for {@link @waitInMs}.</span></span><br><span class=line>                <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">PriorityWaitException</span>(waitInMs);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 小于等于，说明在阈值范围内，返回true</span></span><br><span class=line>    <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>因此，判断的关键就是<code>int curCount = avgUsedTokens(node);</code><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=type>int</span> <span class="title function_">avgUsedTokens</span><span class=params>(Node node)</span> {</span><br><span class=line>    <span class=keyword>if</span> (node == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>return</span> DEFAULT_AVG_USED_TOKENS;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> grade == RuleConstant.FLOW_GRADE_THREAD ? node.curThreadNum() : (<span class=type>int</span>)(node.passQps());</span><br><span class=line>}</span><br></pre></table></figure><p>因为我们采用的是限流，走<code>node.passQps()</code>逻辑：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// 这里又进入了 StatisticNode类</span></span><br><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=type>double</span> <span class="title function_">passQps</span><span class=params>()</span> {</span><br><span class=line>    <span class=comment>// 请求量 ÷ 滑动窗口时间间隔 ，得到的就是QPS</span></span><br><span class=line>    <span class=keyword>return</span> rollingCounterInSecond.pass() / rollingCounterInSecond.getWindowIntervalInSec();</span><br><span class=line>}</span><br></pre></table></figure><p>那么<code>rollingCounterInSecond.pass()</code>是如何得到请求量的呢？<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=comment>// rollingCounterInSecond 本质是ArrayMetric，之前说过</span></span><br><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=type>long</span> <span class="title function_">pass</span><span class=params>()</span> {</span><br><span class=line>    <span class=comment>// 获取当前窗口</span></span><br><span class=line>    data.currentWindow();</span><br><span class=line>    <span class=type>long</span> <span class=variable>pass</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=comment>// 获取 当前时间的 滑动窗口范围内 的所有小窗口</span></span><br><span class=line>    List&LTMetricBucket> list = data.values();</span><br><span class=line>	<span class=comment>// 遍历</span></span><br><span class=line>    <span class=keyword>for</span> (MetricBucket window : list) {</span><br><span class=line>        <span class=comment>// 累加求和</span></span><br><span class=line>        pass += window.pass();</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 返回</span></span><br><span class=line>    <span class=keyword>return</span> pass;</span><br><span class=line>}</span><br></pre></table></figure><p>来看看<code>data.values()</code>如何获取 滑动窗口范围内 的所有小窗口：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=comment>// 此处进入LeapArray类中：</span></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> List&LTT> <span class="title function_">values</span><span class=params>(<span class=type>long</span> timeMillis)</span> {</span><br><span class=line>    <span class=keyword>if</span> (timeMillis < <span class=number>0</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">ArrayList</span>&LTT>();</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 创建空集合，大小等于 LeapArray长度</span></span><br><span class=line>    <span class=type>int</span> <span class=variable>size</span> <span class=operator>=</span> array.length();</span><br><span class=line>    List&LTT> result = <span class=keyword>new</span> <span class="title class_">ArrayList</span>&LTT>(size);</span><br><span class=line>	<span class=comment>// 遍历 LeapArray</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < size; i++) {</span><br><span class=line>        <span class=comment>// 获取每一个小窗口</span></span><br><span class=line>        WindowWrap&LTT> windowWrap = array.get(i);</span><br><span class=line>        <span class=comment>// 判断这个小窗口是否在 滑动窗口时间范围内（1秒内）</span></span><br><span class=line>        <span class=keyword>if</span> (windowWrap == <span class=literal>null</span> || isWindowDeprecated(timeMillis, windowWrap)) {</span><br><span class=line>            <span class=comment>// 不在范围内，则跳过</span></span><br><span class=line>            <span class=keyword>continue</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 在范围内，则添加到集合中</span></span><br><span class=line>        result.add(windowWrap.value());</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 返回集合</span></span><br><span class=line>    <span class=keyword>return</span> result;</span><br><span class=line>}</span><br></pre></table></figure><p>那么，<code>isWindowDeprecated(timeMillis, windowWrap)</code>又是如何判断窗口是否符合要求呢？<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">isWindowDeprecated</span><span class=params>(<span class=type>long</span> time, WindowWrap&LTT> windowWrap)</span> {</span><br><span class=line>    <span class=comment>// 当前时间 - 窗口开始时间  是否大于 滑动窗口的最大间隔（1秒）</span></span><br><span class=line>    <span class=comment>// 也就是说，我们要统计的时 距离当前时间1秒内的 小窗口的 count之和</span></span><br><span class=line>    <span class=keyword>return</span> time - windowWrap.windowStart() > intervalInMs;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=2-9-3-漏桶><a class=headerlink href=#2-9-3-漏桶 title=2.9.3.漏桶></a>2.9.3.漏桶</h3><p>上一节我们讲过，FlowSlot的限流判断最终都由<code>TrafficShapingController</code>接口中的<code>canPass</code>方法来实现。该接口有三个实现类：<ul><li>DefaultController：快速失败，默认的方式，基于滑动时间窗口算法<li>WarmUpController：预热模式，基于滑动时间窗口算法，只不过阈值是动态的<li>RateLimiterController：排队等待模式，基于漏桶算法</ul><p>因此，我们跟入默认的RateLimiterController中的canPass方法来分析：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">canPass</span><span class=params>(Node node, <span class=type>int</span> acquireCount, <span class=type>boolean</span> prioritized)</span> {</span><br><span class=line>    <span class=comment>// Pass when acquire count is less or equal than 0.</span></span><br><span class=line>    <span class=keyword>if</span> (acquireCount <= <span class=number>0</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 阈值小于等于 0 ，阻止请求</span></span><br><span class=line>    <span class=keyword>if</span> (count <= <span class=number>0</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 获取当前时间</span></span><br><span class=line>    <span class=type>long</span> <span class=variable>currentTime</span> <span class=operator>=</span> TimeUtil.currentTimeMillis();</span><br><span class=line>    <span class=comment>// 计算两次请求之间允许的最小时间间隔</span></span><br><span class=line>    <span class=type>long</span> <span class=variable>costTime</span> <span class=operator>=</span> Math.round(<span class=number>1.0</span> * (acquireCount) / count * <span class=number>1000</span>);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 计算本次请求 允许执行的时间点 = 最近一次请求的可执行时间 + 两次请求的最小间隔</span></span><br><span class=line>    <span class=type>long</span> <span class=variable>expectedTime</span> <span class=operator>=</span> costTime + latestPassedTime.get();</span><br><span class=line>	<span class=comment>// 如果允许执行的时间点小于当前时间，说明可以立即执行</span></span><br><span class=line>    <span class=keyword>if</span> (expectedTime <= currentTime) {</span><br><span class=line>        <span class=comment>// 更新上一次的请求的执行时间</span></span><br><span class=line>        latestPassedTime.set(currentTime);</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>        <span class=comment>// 不能立即执行，需要计算 预期等待时长</span></span><br><span class=line>        <span class=comment>// 预期等待时长 = 两次请求的最小间隔 +最近一次请求的可执行时间 - 当前时间</span></span><br><span class=line>        <span class=type>long</span> <span class=variable>waitTime</span> <span class=operator>=</span> costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();</span><br><span class=line>        <span class=comment>// 如果预期等待时间超出阈值，则拒绝请求</span></span><br><span class=line>        <span class=keyword>if</span> (waitTime > maxQueueingTimeMs) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=comment>// 预期等待时间小于阈值，更新最近一次请求的可执行时间，加上costTime</span></span><br><span class=line>            <span class=type>long</span> <span class=variable>oldTime</span> <span class=operator>=</span> latestPassedTime.addAndGet(costTime);</span><br><span class=line>            <span class=keyword>try</span> {</span><br><span class=line>                <span class=comment>// 保险起见，再判断一次预期等待时间，是否超过阈值</span></span><br><span class=line>                waitTime = oldTime - TimeUtil.currentTimeMillis();</span><br><span class=line>                <span class=keyword>if</span> (waitTime > maxQueueingTimeMs) {</span><br><span class=line>                    <span class=comment>// 如果超过，则把刚才 加 的时间再 减回来</span></span><br><span class=line>                    latestPassedTime.addAndGet(-costTime);</span><br><span class=line>                    <span class=comment>// 拒绝</span></span><br><span class=line>                    <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>                }</span><br><span class=line>                <span class=comment>// in race condition waitTime may <= 0</span></span><br><span class=line>                <span class=keyword>if</span> (waitTime > <span class=number>0</span>) {</span><br><span class=line>                    <span class=comment>// 预期等待时间在阈值范围内，休眠要等待的时间，醒来后继续执行</span></span><br><span class=line>                    Thread.sleep(waitTime);</span><br><span class=line>                }</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>            } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>与我们之前分析的漏桶算法基本一致：<p><img alt=image-20210925210716675 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925210716675.png><h2 id=2-10-DegradeSlot><a class=headerlink href=#2-10-DegradeSlot title=2.10.DegradeSlot></a>2.10.DegradeSlot</h2><p>最后一关，就是降级规则判断了。<p>Sentinel的降级是基于状态机来实现的：<p><img alt=image-20210925211020881 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925211020881.png><p>对应的实现在DegradeSlot类中，核心API：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">entry</span><span class=params>(Context context, ResourceWrapper resourceWrapper, DefaultNode node, </span></span><br><span class=line><span class=params>                  <span class=type>int</span> count, <span class=type>boolean</span> prioritized, Object... args)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=comment>// 熔断降级规则判断</span></span><br><span class=line>    performChecking(context, resourceWrapper);</span><br><span class=line>	<span class=comment>// 继续下一个slot</span></span><br><span class=line>    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=line>}</span><br></pre></table></figure><p>继续进入<code>performChecking</code>方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> <span class="title function_">performChecking</span><span class=params>(Context context, ResourceWrapper r)</span> <span class=keyword>throws</span> BlockException {</span><br><span class=line>    <span class=comment>// 获取当前资源上的所有的断路器 CircuitBreaker</span></span><br><span class=line>    List&LTCircuitBreaker> circuitBreakers = DegradeRuleManager.getCircuitBreakers(r.getName());</span><br><span class=line>    <span class=keyword>if</span> (circuitBreakers == <span class=literal>null</span> || circuitBreakers.isEmpty()) {</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>for</span> (CircuitBreaker cb : circuitBreakers) {</span><br><span class=line>        <span class=comment>// 遍历断路器，逐个判断</span></span><br><span class=line>        <span class=keyword>if</span> (!cb.tryPass(context)) {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">DegradeException</span>(cb.getRule().getLimitApp(), cb.getRule());</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=2-10-1-CircuitBreaker><a class=headerlink href=#2-10-1-CircuitBreaker title=2.10.1.CircuitBreaker></a>2.10.1.CircuitBreaker</h3><p>我们进入CircuitBreaker的tryPass方法中：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">tryPass</span><span class=params>(Context context)</span> {</span><br><span class=line>    <span class=comment>// 判断状态机状态</span></span><br><span class=line>    <span class=keyword>if</span> (currentState.get() == State.CLOSED) {</span><br><span class=line>        <span class=comment>// 如果是closed状态，直接放行</span></span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>if</span> (currentState.get() == State.OPEN) {</span><br><span class=line>        <span class=comment>// 如果是OPEN状态，断路器打开</span></span><br><span class=line>        <span class=comment>// 继续判断OPEN时间窗是否结束，如果是则把状态从OPEN切换到 HALF_OPEN，返回true</span></span><br><span class=line>        <span class=keyword>return</span> retryTimeoutArrived() && fromOpenToHalfOpen(context);</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// OPEN状态，并且时间窗未到，返回false</span></span><br><span class=line>    <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>有关时间窗的判断在<code>retryTimeoutArrived()</code>方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>protected</span> <span class=type>boolean</span> <span class="title function_">retryTimeoutArrived</span><span class=params>()</span> {</span><br><span class=line>    <span class=comment>// 当前时间 大于 下一次 HalfOpen的重试时间</span></span><br><span class=line>    <span class=keyword>return</span> TimeUtil.currentTimeMillis() >= nextRetryTimestamp;</span><br><span class=line>}</span><br></pre></table></figure><p>OPEN到HALF_OPEN切换在<code>fromOpenToHalfOpen(context)</code>方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=keyword>protected</span> <span class=type>boolean</span> <span class="title function_">fromOpenToHalfOpen</span><span class=params>(Context context)</span> {</span><br><span class=line>    <span class=comment>// 基于CAS修改状态，从 OPEN到 HALF_OPEN</span></span><br><span class=line>    <span class=keyword>if</span> (currentState.compareAndSet(State.OPEN, State.HALF_OPEN)) {</span><br><span class=line>        <span class=comment>// 状态变更的事件通知</span></span><br><span class=line>        notifyObservers(State.OPEN, State.HALF_OPEN, <span class=literal>null</span>);</span><br><span class=line>        <span class=comment>// 得到当前资源</span></span><br><span class=line>        <span class=type>Entry</span> <span class=variable>entry</span> <span class=operator>=</span> context.getCurEntry();</span><br><span class=line>        <span class=comment>// 给资源设置监听器，在资源Entry销毁时（资源业务执行完毕时）触发</span></span><br><span class=line>        entry.whenTerminate(<span class=keyword>new</span> <span class="title class_">BiConsumer</span>&LTContext, Entry>() {</span><br><span class=line>            <span class=meta>@Override</span></span><br><span class=line>            <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">accept</span><span class=params>(Context context, Entry entry)</span> {</span><br><span class=line>                <span class=comment>// 判断 资源业务是否异常</span></span><br><span class=line>                <span class=keyword>if</span> (entry.getBlockError() != <span class=literal>null</span>) {</span><br><span class=line>                    <span class=comment>// 如果异常，则再次进入OPEN状态</span></span><br><span class=line>                    currentState.compareAndSet(State.HALF_OPEN, State.OPEN);</span><br><span class=line>                    notifyObservers(State.HALF_OPEN, State.OPEN, <span class=number>1.0d</span>);</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        });</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>这里出现了从OPEN到HALF_OPEN、从HALF_OPEN到OPEN的变化，但是还有几个没有：<ul><li>从CLOSED到OPEN<li>从HALF_OPEN到CLOSED</ul><h3 id=2-10-2-触发断路器><a class=headerlink href=#2-10-2-触发断路器 title=2.10.2.触发断路器></a>2.10.2.触发断路器</h3><p>请求经过所有插槽 后，一定会执行exit方法，而在DegradeSlot的exit方法中：<p><img alt=image-20210925213440686 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925213440686.png><p>会调用CircuitBreaker的onRequestComplete方法。而CircuitBreaker有两个实现：<p><img alt=image-20210925213939035 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925213939035.png><p>我们这里以异常比例熔断为例来看，进入<code>ExceptionCircuitBreaker</code>的<code>onRequestComplete</code>方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">onRequestComplete</span><span class=params>(Context context)</span> {</span><br><span class=line>    <span class=comment>// 获取资源 Entry</span></span><br><span class=line>    <span class=type>Entry</span> <span class=variable>entry</span> <span class=operator>=</span> context.getCurEntry();</span><br><span class=line>    <span class=keyword>if</span> (entry == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 尝试获取 资源中的 异常</span></span><br><span class=line>    <span class=type>Throwable</span> <span class=variable>error</span> <span class=operator>=</span> entry.getError();</span><br><span class=line>    <span class=comment>// 获取计数器，同样采用了滑动窗口来计数</span></span><br><span class=line>    <span class=type>SimpleErrorCounter</span> <span class=variable>counter</span> <span class=operator>=</span> stat.currentWindow().value();</span><br><span class=line>    <span class=keyword>if</span> (error != <span class=literal>null</span>) {</span><br><span class=line>        <span class=comment>// 如果出现异常，则 error计数器 +1</span></span><br><span class=line>        counter.getErrorCount().add(<span class=number>1</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 不管是否出现异常，total计数器 +1</span></span><br><span class=line>    counter.getTotalCount().add(<span class=number>1</span>);</span><br><span class=line>	<span class=comment>// 判断异常比例是否超出阈值</span></span><br><span class=line>    handleStateChangeWhenThresholdExceeded(error);</span><br><span class=line>}</span><br></pre></table></figure><p>来看阈值判断的方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">handleStateChangeWhenThresholdExceeded</span><span class=params>(Throwable error)</span> {</span><br><span class=line>    <span class=comment>// 如果当前已经是OPEN状态，不做处理</span></span><br><span class=line>    <span class=keyword>if</span> (currentState.get() == State.OPEN) {</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 如果已经是 HALF_OPEN 状态，判断是否需求切换状态</span></span><br><span class=line>    <span class=keyword>if</span> (currentState.get() == State.HALF_OPEN) {</span><br><span class=line>        <span class=keyword>if</span> (error == <span class=literal>null</span>) {</span><br><span class=line>            <span class=comment>// 没有异常，则从 HALF_OPEN 到 CLOSED</span></span><br><span class=line>            fromHalfOpenToClose();</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=comment>// 有一次，再次进入OPEN</span></span><br><span class=line>            fromHalfOpenToOpen(<span class=number>1.0d</span>);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 说明当前是CLOSE状态，需要判断是否触发阈值</span></span><br><span class=line>    List&LTSimpleErrorCounter> counters = stat.values();</span><br><span class=line>    <span class=type>long</span> <span class=variable>errCount</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=type>long</span> <span class=variable>totalCount</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=comment>// 累加计算 异常请求数量、总请求数量</span></span><br><span class=line>    <span class=keyword>for</span> (SimpleErrorCounter counter : counters) {</span><br><span class=line>        errCount += counter.errorCount.sum();</span><br><span class=line>        totalCount += counter.totalCount.sum();</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 如果总请求数量未达到阈值，什么都不做</span></span><br><span class=line>    <span class=keyword>if</span> (totalCount < minRequestAmount) {</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=type>double</span> <span class=variable>curCount</span> <span class=operator>=</span> errCount;</span><br><span class=line>    <span class=keyword>if</span> (strategy == DEGRADE_GRADE_EXCEPTION_RATIO) {</span><br><span class=line>        <span class=comment>// 计算请求的异常比例</span></span><br><span class=line>        curCount = errCount * <span class=number>1.0d</span> / totalCount;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 如果比例超过阈值，切换到 OPEN</span></span><br><span class=line>    <span class=keyword>if</span> (curCount > threshold) {</span><br><span class=line>        transformToOpen(curCount);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure></div><footer class=post-footer><div class=post-tags><a href=/tags/Sentinel/ rel=tag># Sentinel</a><a href=/tags/Sentinel%E5%8E%9F%E7%90%86/ rel=tag># Sentinel原理</a></div><div class=post-nav><div class=post-nav-item><a href=/2024/08/21/Sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/ rel=prev title=Sentinel系列-Sentinel规则持久化> <i class="fa fa-angle-left"></i> Sentinel系列-Sentinel规则持久化 </a></div><div class=post-nav-item><a href=/2024/08/21/Sentinel%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/ rel=next title=Sentinel系列-Sentinel基础使用> Sentinel系列-Sentinel基础使用 <i class="fa fa-angle-right"></i> </a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script>