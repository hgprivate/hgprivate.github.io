<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hgprivate.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="0、前言本文档基于ASM4.0来分析。 1、简介1.1、简析ASM不是生成和转换已编译Java的唯一工具类，但它是最新且有效的类之一。其主要优点如下：  它具有易使用、简单、精心设计的模块化API。 并且具有关联的Eclipse插件。 它支持最新的Java版本Java 7 它体积小，速度快且非常稳定。 庞大的社区支持。 完全开源。  1.2、总述1.2.1、作用域ASM库的目标是生成、转换和分析以" name=description><meta content=article property=og:type><meta content=Java系列-ASM property=og:title><meta content=https://hgprivate.github.io/2024/08/21/ASM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content="0、前言本文档基于ASM4.0来分析。 1、简介1.1、简析ASM不是生成和转换已编译Java的唯一工具类，但它是最新且有效的类之一。其主要优点如下：  它具有易使用、简单、精心设计的模块化API。 并且具有关联的Eclipse插件。 它支持最新的Java版本Java 7 它体积小，速度快且非常稳定。 庞大的社区支持。 完全开源。  1.2、总述1.2.1、作用域ASM库的目标是生成、转换和分析以" property=og:description><meta content=zh_CN property=og:locale><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200905140752294.png?token=AIGEF3IRGWSRIZT72N35LHDEZZZXO property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200905141030231.png?token=AIGEF3NN3ZCLCO7OIRB5P5TEZZZYO property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200906150115558.png?token=AIGEF3PER5BJHXJG27CVUGDEZZZ2Q property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200906150426003.png?token=AIGEF3MGQCPQK5TETM4YJWDEZZZ32 property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200906151656565.png?token=AIGEF3NVDVSTEU3H4PJNRM3EZZZ5W property=og:image><meta content=2024-08-21T13:39:13.333Z property=article:published_time><meta content=2023-08-06T02:57:52.700Z property=article:modified_time><meta content=豪哥 property=article:author><meta content=ASM property=article:tag><meta content=summary name=twitter:card><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200905140752294.png?token=AIGEF3IRGWSRIZT72N35LHDEZZZXO name=twitter:image><link href=https://hgprivate.github.io/2024/08/21/ASM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hgprivate.github.io/2024/08/21/ASM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","path":"2024/08/21/ASM知识点总结/","title":"Java系列-ASM"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>Java系列-ASM | 豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>豪哥博客</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#0%E3%80%81%E5%89%8D%E8%A8%80><span class=nav-number>1.</span> <span class=nav-text>0、前言</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>2.</span> <span class=nav-text>1、简介</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81%E7%AE%80%E6%9E%90><span class=nav-number>2.1.</span> <span class=nav-text>1.1、简析</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-2%E3%80%81%E6%80%BB%E8%BF%B0><span class=nav-number>2.2.</span> <span class=nav-text>1.2、总述</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-1%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F><span class=nav-number>2.2.1.</span> <span class=nav-text>1.2.1、作用域</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-2%E3%80%81%E6%A8%A1%E5%9D%97><span class=nav-number>2.2.2.</span> <span class=nav-text>1.2.2、模块</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-3%E3%80%81%E7%BB%93%E6%9E%84><span class=nav-number>2.2.3.</span> <span class=nav-text>1.2.3、结构</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-3%E3%80%81%E7%BB%84%E7%BB%87><span class=nav-number>2.3.</span> <span class=nav-text>1.3、组织</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#2%E3%80%81%E7%B1%BB><span class=nav-number>3.</span> <span class=nav-text>2、类</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#2-1%E3%80%81%E7%BB%93%E6%9E%84><span class=nav-number>3.1.</span> <span class=nav-text>2.1、结构</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-3%E3%80%81%E7%B1%BB%E5%9E%8B%E6%8F%8F%E8%BF%B0%E7%AC%A6><span class=nav-number>3.1.1.</span> <span class=nav-text>2.1.3、类型描述符</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-1-4%E3%80%81%E6%96%B9%E6%B3%95%E6%8F%8F%E8%BF%B0%E7%AC%A6><span class=nav-number>3.1.2.</span> <span class=nav-text>2.1.4、方法描述符</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-2%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%BB%84%E4%BB%B6><span class=nav-number>3.2.</span> <span class=nav-text>2.2、接口与组件</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>3.2.1.</span> <span class=nav-text>2.2.1、简介</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-2%E3%80%81%E8%A7%A3%E6%9E%90%E7%B1%BB><span class=nav-number>3.2.2.</span> <span class=nav-text>2.2.2、解析类</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-3%E3%80%81%E7%94%9F%E6%88%90%E7%B1%BB><span class=nav-number>3.2.3.</span> <span class=nav-text>2.2.3、生成类</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-3-1%E3%80%81%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E7%9A%84%E7%B1%BB%EF%BC%9A><span class=nav-number>3.2.3.1.</span> <span class=nav-text>2.2.3.1、使用生成的类：</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-4%E3%80%81%E8%BD%AC%E6%8D%A2%E7%B1%BB><span class=nav-number>3.2.4.</span> <span class=nav-text>2.2.4、转换类</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-4-1%E3%80%81%E4%BC%98%E5%8C%96><span class=nav-number>3.2.4.1.</span> <span class=nav-text>2.2.4.1、优化</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#2-2-4-2%E3%80%81%E4%BD%BF%E7%94%A8%E8%BD%AC%E6%8D%A2%E7%B1%BB><span class=nav-number>3.2.4.2.</span> <span class=nav-text>2.2.4.2、使用转换类</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-5%E3%80%81%E5%88%A0%E9%99%A4%E7%B1%BB%E6%88%90%E5%91%98><span class=nav-number>3.2.5.</span> <span class=nav-text>2.2.5、删除类成员</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-6%E3%80%81%E6%B7%BB%E5%8A%A0%E7%B1%BB%E6%88%90%E5%91%98><span class=nav-number>3.2.6.</span> <span class=nav-text>2.2.6、添加类成员</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-7%E3%80%81%E8%BD%AC%E5%9E%8B%E9%93%BE><span class=nav-number>3.2.7.</span> <span class=nav-text>2.2.7、转型链</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#2-3%E3%80%81%E5%B7%A5%E5%85%B7><span class=nav-number>3.3.</span> <span class=nav-text>2.3、工具</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-1%E3%80%81Type><span class=nav-number>3.3.1.</span> <span class=nav-text>2.3.1、Type</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-2%E3%80%81TraceClassVisitor><span class=nav-number>3.3.2.</span> <span class=nav-text>2.3.2、TraceClassVisitor</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-3%E3%80%81CheckClassAdapter><span class=nav-number>3.3.3.</span> <span class=nav-text>2.3.3、CheckClassAdapter</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-3-4%E3%80%81ASMifier><span class=nav-number>3.3.4.</span> <span class=nav-text>2.3.4、ASMifier</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#3%E3%80%81%E6%96%B9%E6%B3%95><span class=nav-number>4.</span> <span class=nav-text>3、方法</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#3-1%E3%80%81%E7%BB%93%E6%9E%84><span class=nav-number>4.1.</span> <span class=nav-text>3.1、结构</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-1%E3%80%81%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%BC%8F><span class=nav-number>4.1.1.</span> <span class=nav-text>3.1.1、执行模式</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-2%E3%80%81%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4><span class=nav-number>4.1.2.</span> <span class=nav-text>3.1.2、字节码指令</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-3%E3%80%81%E5%AE%9E%E4%BE%8B><span class=nav-number>4.1.3.</span> <span class=nav-text>3.1.3、实例</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-4%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86><span class=nav-number>4.1.4.</span> <span class=nav-text>3.1.4、异常处理</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-5%E3%80%81Frames><span class=nav-number>4.1.5.</span> <span class=nav-text>3.1.5、Frames</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-2%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%BB%84%E4%BB%B6><span class=nav-number>4.2.</span> <span class=nav-text>3.2、接口与组件</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-2-2%E3%80%81%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95><span class=nav-number>4.2.1.</span> <span class=nav-text>3.2.2、生成方法</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-2-3%E3%80%81%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95><span class=nav-number>4.2.2.</span> <span class=nav-text>3.2.3、转换方法</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-2-4%E3%80%81%E6%97%A0%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2><span class=nav-number>4.2.3.</span> <span class=nav-text>3.2.4、无状态转换</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-2-5%E3%80%81%E6%9C%89%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2><span class=nav-number>4.2.4.</span> <span class=nav-text>3.2.5、有状态转换</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#3-3%E3%80%81%E5%B7%A5%E5%85%B7><span class=nav-number>4.3.</span> <span class=nav-text>3.3、工具</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-3-1%E3%80%81%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7><span class=nav-number>4.3.1.</span> <span class=nav-text>3.3.1、基础工具</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-3-2%E3%80%81%E5%88%86%E6%9E%90%E9%80%82%E9%85%8D%E5%99%A8><span class=nav-number>4.3.2.</span> <span class=nav-text>3.3.2、分析适配器</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-3-3%E3%80%81LocalVariablesSorter><span class=nav-number>4.3.3.</span> <span class=nav-text>3.3.3、LocalVariablesSorter</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-3-4%E3%80%81AdviceAdapter><span class=nav-number>4.3.4.</span> <span class=nav-text>3.3.4、AdviceAdapter</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#4%E3%80%81%E5%85%83%E6%95%B0%E6%8D%AE><span class=nav-number>5.</span> <span class=nav-text>4、元数据</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#4-1%E3%80%81%E6%B3%9B%E5%9E%8B><span class=nav-number>5.1.</span> <span class=nav-text>4.1、泛型</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-1-2%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%BB%84%E4%BB%B6><span class=nav-number>5.1.1.</span> <span class=nav-text>4.1.2、接口与组件</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-1-3%E3%80%81%E5%B7%A5%E5%85%B7><span class=nav-number>5.1.2.</span> <span class=nav-text>4.1.3、工具</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#4-2%E3%80%81%E6%B3%A8%E8%A7%A3><span class=nav-number>5.2.</span> <span class=nav-text>4.2、注解</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-2-1%E3%80%81%E7%BB%93%E6%9E%84><span class=nav-number>5.2.1.</span> <span class=nav-text>4.2.1、结构</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-2-2%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%BB%84%E4%BB%B6><span class=nav-number>5.2.2.</span> <span class=nav-text>4.2.2、接口与组件</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-2-3%E3%80%81%E5%B7%A5%E5%85%B7><span class=nav-number>5.2.3.</span> <span class=nav-text>4.2.3、工具</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#4-3%E3%80%81Debug><span class=nav-number>5.3.</span> <span class=nav-text>4.3、Debug</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#4-3-2%E3%80%81%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%BB%84%E4%BB%B6><span class=nav-number>5.3.1.</span> <span class=nav-text>4.3.2、接口与组件</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#4-3-3%E3%80%81%E5%B7%A5%E5%85%B7><span class=nav-number>5.3.2.</span> <span class=nav-text>4.3.3、工具</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#5%E3%80%81%E5%90%91%E5%90%8E%E5%85%BC%E5%AE%B9%EF%BC%88Backward-compatibility%EF%BC%89><span class=nav-number>6.</span> <span class=nav-text>5、向后兼容（Backward compatibility）</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#5-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>6.1.</span> <span class=nav-text>5.1、简介</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#5-1-1%E3%80%81Backward-compatibility-contract><span class=nav-number>6.1.1.</span> <span class=nav-text>5.1.1、Backward compatibility contract</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#5-1-2%E3%80%81%E4%BE%8B%E5%AD%90><span class=nav-number>6.1.2.</span> <span class=nav-text>5.1.2、例子</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#5-2%E3%80%81%E6%8C%87%E5%AF%BC><span class=nav-number>6.2.</span> <span class=nav-text>5.2、指导</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#5-2-1%E3%80%81%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99><span class=nav-number>6.2.1.</span> <span class=nav-text>5.2.1、基本规则</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#5-2-2%E3%80%81%E7%BB%A7%E6%89%BF%E8%A7%84%E5%88%99><span class=nav-number>6.2.2.</span> <span class=nav-text>5.2.2、继承规则</span></a></ol></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>117</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>36</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>129</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://hgprivate.github.io/2024/08/21/ASM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="Java系列-ASM | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>Java系列-ASM</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-06 10:57:52" datetime=2023-08-06T10:57:52+08:00 itemprop=dateModified>2023-08-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/ASM/ itemprop=url rel=index><span itemprop=name>ASM</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=0、前言><a class=headerlink href=#0、前言 title=0、前言></a>0、前言</h1><p>本文档基于ASM4.0来分析。<h1 id=1、简介><a class=headerlink href=#1、简介 title=1、简介></a>1、简介</h1><h2 id=1-1、简析><a class=headerlink href=#1-1、简析 title=1.1、简析></a>1.1、简析</h2><p>ASM不是生成和转换已编译Java的唯一工具类，但它是最新且有效的类之一。其主要优点如下：<ol><li>它具有易使用、简单、精心设计的模块化API。<li>并且具有关联的Eclipse插件。<li>它支持最新的Java版本Java 7<li>它体积小，速度快且非常稳定。<li>庞大的社区支持。<li>完全开源。</ol><h2 id=1-2、总述><a class=headerlink href=#1-2、总述 title=1.2、总述></a>1.2、总述</h2><h3 id=1-2-1、作用域><a class=headerlink href=#1-2-1、作用域 title=1.2.1、作用域></a>1.2.1、作用域</h3><p>ASM库的目标是生成、转换和分析以字节数组表示的已编译Java类（因为它们存储在磁盘上并已加载到Java虚拟机中）。为此，ASM提供了使用比字节更高的概念来读取，写入和转换此类字节数组的工具，例如数字常量，字符串，Java标识符，Java类型，Java类结构元素等。请注意，ASM的范围图书馆严格限于阅读，写作，转换和分析类。特别是类加载过程超出了范围。<h3 id=1-2-2、模块><a class=headerlink href=#1-2-2、模块 title=1.2.2、模块></a>1.2.2、模块</h3><p>ASM库提供了两个用于生成和转换已编译类的API：核心API提供基于事件的类表示，而树API提供基于对象的表示。<p>这两个API可以与XML文档的简单API（SAX）和XML文档的文档对象模型（DOM）API进行比较：基于事件的API与SAX类似，而基于对象的API与DOM类似。基于对象的API建立在基于事件的API之上，就像可以在SAX之上提供DOM一样。<p>优缺点：<ul><li>与基于对象的API相比，基于事件的API更快，并且所需的内存更少，因为不需要创建并在内存中存储代表该类的对象树（SAX和DOM之间也存在相同的区别）。<li>但是，使用基于事件的API来实现类转换可能会更加困难，因为在任何给定时间只有该类的一个元素（与当前事件相对应的元素）才可用，而整个类可以在基于对象的内存中使用API。</ul><h3 id=1-2-3、结构><a class=headerlink href=#1-2-3、结构 title=1.2.3、结构></a>1.2.3、结构</h3><p>ASM应用程序具有强大的体系结构方面。实际上，基于事件的API是围绕事件生成器（类解析器），事件使用者（类编写器）和各种预定义的事件过滤器组织的，可以向其中添加用户定义的生产者，使用者和过滤器。因此，使用此API分为两个步骤：<ol><li>将事件产生器，过滤器和使用者组件组装成可能复杂的架构。<li>然后启动事件生产者以运行生成或转换过程。</ol><h2 id=1-3、组织><a class=headerlink href=#1-3、组织 title=1.3、组织></a>1.3、组织</h2><p>ASM库组织在几个包中，这些包分布在几个jar文件中：<ol><li>asm.jar<li>asm-util.jar<li>asm-commons.jar<li>asm-tree.jar<li>asm-analysis.jar</ol><h1 id=2、类><a class=headerlink href=#2、类 title=2、类></a>2、类</h1><h2 id=2-1、结构><a class=headerlink href=#2-1、结构 title=2.1、结构></a>2.1、结构</h2><h3 id=2-1-3、类型描述符><a class=headerlink href=#2-1-3、类型描述符 title=2.1.3、类型描述符></a>2.1.3、类型描述符</h3><p>内部名称仅用于约束为类或接口类型的类型。在所有其他情况下，例如字段类型，Java类型都在带有类型描述符的已编译类中表示：<p><img alt=image-20200905140752294 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200905140752294.png?token=AIGEF3IRGWSRIZT72N35LHDEZZZXO><h3 id=2-1-4、方法描述符><a class=headerlink href=#2-1-4、方法描述符 title=2.1.4、方法描述符></a>2.1.4、方法描述符</h3><p>方法描述符是类型描述符的列表，这些类型描述符在单个字符串中描述方法的参数类型和返回类型。方法描述符以左括号开头，然后是每个形式参数的类型描述符，然后是右括号，然后是返回类型的类型描述符，如果该方法返回void，则返回V（方法描述符不包含方法名称或参数名称）。<p><img alt=image-20200905141030231 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200905141030231.png?token=AIGEF3NN3ZCLCO7OIRB5P5TEZZZYO><h2 id=2-2、接口与组件><a class=headerlink href=#2-2、接口与组件 title=2.2、接口与组件></a>2.2、接口与组件</h2><h3 id=2-2-1、简介><a class=headerlink href=#2-2-1、简介 title=2.2.1、简介></a>2.2.1、简介</h3><p>用于生成和转换已编译类的 ASM API 基于 ClassVisitor 抽象类。此类中的每个方法都对应于同名的类文件结构部分。通过单个方法调用可以访问简单部分，该方法的参数描述其内容，并返回void。使用初始方法调用（其返回辅助访问者类）访问其内容可以具有任意长度和复杂度的节。 visitAnnotation，visitField和visitMethod方法就是这种情况，它们分别返回AnnotationVisitor，FieldVisitor和MethodVisitor。<p>这些辅助类递归使用相同的原理。例如，FieldVisitor抽象类中的每个方法（请参见图2.5）对应于具有相同名称的类文件子结构，并且与ClassVisitor中一样，返回一个辅助AnnotationVisitor。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ClassVisitor</span><span class=params>(<span class=type>int</span> api)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ClassVisitor</span><span class=params>(<span class=type>int</span> api, ClassVisitor cv)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(<span class=type>int</span> version, <span class=type>int</span> access, String name,String signature, String superName, String[] interfaces)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitSource</span><span class=params>(String source, String debug)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitOuterClass</span><span class=params>(String owner, String name, String desc)</span>;</span><br><span class=line>    AnnotationVisitor <span class="title function_">visitAnnotation</span><span class=params>(String desc, <span class=type>boolean</span> visible)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitAttribute</span><span class=params>(Attribute attr)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInnerClass</span><span class=params>(String name, String outerName,String innerName, <span class=type>int</span> access)</span>;</span><br><span class=line>    <span class=keyword>public</span> FieldVisitor <span class="title function_">visitField</span><span class=params>(<span class=type>int</span> access, String name, String desc,String signature, Object value)</span>;</span><br><span class=line>    <span class=keyword>public</span> MethodVisitor <span class="title function_">visitMethod</span><span class=params>(<span class=type>int</span> access, String name, String desc,String signature, String[] exceptions)</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">FieldVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">FieldVisitor</span><span class=params>(<span class=type>int</span> api)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">FieldVisitor</span><span class=params>(<span class=type>int</span> api, FieldVisitor fv)</span>;</span><br><span class=line>    <span class=keyword>public</span> AnnotationVisitor <span class="title function_">visitAnnotation</span><span class=params>(String desc, <span class=type>boolean</span> visible)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitAttribute</span><span class=params>(Attribute attr)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><p>ASM提供了三个基于ClassVisitor API的核心组件，用于生成和转换类：<ol><li>ClassReader类解析以字节数组形式给出的已编译类，并在作为参数传递给其accept方法的ClassVisitor实例上调用相应的visitXxx方法。可以将其视为事件产生器。<li>ClassWriter类是ClassVisitor抽象类的子类，该类直接以二进制形式构建编译的类。它产生包含已编译类的字节数组作为输出，可以使用toByteArray方法进行检索。可以将其视为事件消费者。<li>ClassVisitor类将它收到的所有方法调用委托给另一个ClassVisitor实例。可以将其视为事件过滤器。</ol><h3 id=2-2-2、解析类><a class=headerlink href=#2-2-2、解析类 title=2.2.2、解析类></a>2.2.2、解析类</h3><p>解析现有类的唯一必需组件是ClassReader组件。让我们以一个例子来说明这一点。假设我们希望以类似于javap工具的方式打印类的内容。第一步是编写ClassVisitor类的子类，该子类打印有关其访问的类的信息。这是一个可能的，过于简化的实现：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ClassPrinter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ClassPrinter</span><span class=params>()</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(<span class=type>int</span> version, <span class=type>int</span> access, String name,String signature, String superName, String[] interfaces)</span> {</span><br><span class=line>    	System.out.println(name + <span class=string>" extends "</span> + superName + <span class=string>" {"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitSource</span><span class=params>(String source, String debug)</span> {}</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitOuterClass</span><span class=params>(String owner, String name, String desc)</span> {}</span><br><span class=line>    <span class=keyword>public</span> AnnotationVisitor <span class="title function_">visitAnnotation</span><span class=params>(String desc,<span class=type>boolean</span> visible)</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitAttribute</span><span class=params>(Attribute attr)</span> {}</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInnerClass</span><span class=params>(String name, String outerName, String innerName, <span class=type>int</span> access)</span> {}</span><br><span class=line>    <span class=keyword>public</span> FieldVisitor <span class="title function_">visitField</span><span class=params>(<span class=type>int</span> access, String name, String desc,String signature, Object value)</span> {</span><br><span class=line>    	System.out.println(<span class=string>" "</span> + desc + <span class=string>" "</span> + name);</span><br><span class=line>    	<span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> MethodVisitor <span class="title function_">visitMethod</span><span class=params>(<span class=type>int</span> access, String name,String desc, String signature, String[] exceptions)</span> {</span><br><span class=line>    	System.out.println(<span class=string>" "</span> + name + desc);</span><br><span class=line>    	<span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span> {</span><br><span class=line>    	System.out.println(<span class=string>"}"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><p>第二步是将该ClassPrinter与ClassReader组件结合起来，以便ClassReader产生的事件由我们的ClassPrinter消耗：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>ClassPrinter</span> <span class=variable>cp</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPrinter</span>();</span><br><span class=line><span class=type>ClassReader</span> <span class=variable>cr</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassReader</span>(<span class=string>"java.lang.Runnable"</span>);</span><br><span class=line>cr.accept(cp, <span class=number>0</span>);</span><br></pre></table></figure><p>请注意，有几种方法可以构造ClassReader实例。可以通过名称（如上所述）或通过值（字节数组或InputStream）指定必须读取的类。可以使用ClassLoader的getResourceAsStream方法通过以下方式获取用于读取类内容的输入流：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>cl.getResourceAsStream(classname.replace(’.’, ’/’) + <span class=string>".class"</span>);</span><br></pre></table></figure><h3 id=2-2-3、生成类><a class=headerlink href=#2-2-3、生成类 title=2.2.3、生成类></a>2.2.3、生成类</h3><p>生成类的唯一必需组件是ClassWriter组件。让我们以一个例子来说明这一点。考虑以下接口：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Comparable</span> <span class=keyword>extends</span> <span class="title class_">Mesurable</span> {</span><br><span class=line>    <span class=type>int</span> <span class=variable>LESS</span> <span class=operator>=</span> -<span class=number>1</span>;</span><br><span class=line>    <span class=type>int</span> <span class=variable>EQUAL</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=type>int</span> <span class=variable>GREATER</span> <span class=operator>=</span> <span class=number>1</span>;</span><br><span class=line>    <span class=type>int</span> <span class="title function_">compareTo</span><span class=params>(Object o)</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>它可以通过对ClassVisitor的六个方法调用来生成：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line>cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, <span class=string>"pkg/Comparable"</span>, <span class=literal>null</span>, <span class=string>"java/lang/Object"</span>,<span class=keyword>new</span> <span class="title class_">String</span>[] { <span class=string>"pkg/Mesurable"</span> });</span><br><span class=line>cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class=string>"LESS"</span>, <span class=string>"I"</span>, <span class=literal>null</span>, <span class=keyword>new</span> <span class="title class_">Integer</span>(-<span class=number>1</span>)).visitEnd();</span><br><span class=line>cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class=string>"EQUAL"</span>, <span class=string>"I"</span>, <span class=literal>null</span>, <span class=keyword>new</span> <span class="title class_">Integer</span>(<span class=number>0</span>)).visitEnd();</span><br><span class=line>cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class=string>"GREATER"</span>, <span class=string>"I"</span>, <span class=literal>null</span>, <span class=keyword>new</span> <span class="title class_">Integer</span>(<span class=number>1</span>)).visitEnd();</span><br><span class=line>cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, <span class=string>"compareTo"</span>, <span class=string>"(Ljava/lang/Object;)I"</span>, <span class=literal>null</span>, <span class=literal>null</span>).visitEnd();</span><br><span class=line>cw.visitEnd();</span><br><span class=line><span class=type>byte</span>[] b = cw.toByteArray();</span><br></pre></table></figure><h4 id=2-2-3-1、使用生成的类：><a class=headerlink href=#2-2-3-1、使用生成的类： title=2.2.3.1、使用生成的类：></a>2.2.3.1、使用生成的类：</h4><p>先前的字节数组可以存储在Comparable.class文件中，以备将来使用。另外，也可以使用ClassLoader动态加载它。一种方法是定义ClassLoader子类，其defineClass方法是公共的：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">MyClassLoader</span> <span class=keyword>extends</span> <span class="title class_">ClassLoader</span> {</span><br><span class=line>    <span class=keyword>public</span> Class <span class="title function_">defineClass</span><span class=params>(String name, <span class=type>byte</span>[] b)</span> {</span><br><span class=line>    	<span class=keyword>return</span> defineClass(name, b, <span class=number>0</span>, b.length);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><p>然后，可以使用以下命令直接加载生成的类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>Class</span> <span class=variable>c</span> <span class=operator>=</span> myClassLoader.defineClass(<span class=string>"pkg.Comparable"</span>, b);</span><br></pre></table></figure><p>加载生成的类的另一种方法（可能更干净）是定义ClassLoader子类，该类的findClass方法被重写，以便动态生成请求的类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">StubClassLoader</span> <span class=keyword>extends</span> <span class="title class_">ClassLoader</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> Class <span class="title function_">findClass</span><span class=params>(String name)</span> <span class=keyword>throws</span> ClassNotFoundException {</span><br><span class=line>        <span class=keyword>if</span> (name.endsWith(<span class=string>"_Stub"</span>)) {</span><br><span class=line>            <span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line>            <span class=comment>//...</span></span><br><span class=line>            <span class=type>byte</span>[] b = cw.toByteArray();</span><br><span class=line>            <span class=keyword>return</span> defineClass(name, b, <span class=number>0</span>, b.length);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>super</span>.findClass(name);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>实际上，使用生成的类的方式取决于上下文，并且超出了ASM API的范围。如果正在编写编译器，则类生成过程将由表示要编译的程序的抽象语法树驱动，并且生成的类将存储在磁盘上。如果要编写动态代理类生成器或Aspect Weaver，则将以一种或另一种方式使用ClassLoader。<h3 id=2-2-4、转换类><a class=headerlink href=#2-2-4、转换类 title=2.2.4、转换类></a>2.2.4、转换类</h3><p>到目前为止，仅单独使用了ClassReader和ClassWriter组件。这些事件是“手动”产生的，并由ClassWriter直接消耗，或者对称地，它们是由ClassReader产生并“手动”消耗的，即由自定义的ClassVisitor实现。当这些组件一起使用时，事情开始变得非常有趣。第一步是将ClassReader产生的事件定向到ClassWriter。结果是由类编写器重构了由类读取器解析的类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=type>byte</span>[] b1 = ...;</span><br><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line><span class=type>ClassReader</span> <span class=variable>cr</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassReader</span>(b1);</span><br><span class=line>cr.accept(cw, <span class=number>0</span>);</span><br><span class=line><span class=type>byte</span>[] b2 = cw.toByteArray();  <span class=comment>// b2 represents the same class as b1</span></span><br></pre></table></figure><p>下一步是在类读取器和类写入器之间引入ClassVisitor：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>byte</span>[] b1 = ...;</span><br><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line><span class=comment>// cv forwards all events to cw</span></span><br><span class=line><span class=type>ClassVisitor</span> <span class=variable>cv</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassVisitor</span>(ASM4, cw) { };</span><br><span class=line><span class=type>ClassReader</span> <span class=variable>cr</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassReader</span>(b1);</span><br><span class=line>cr.accept(cv, <span class=number>0</span>);</span><br><span class=line><span class=type>byte</span>[] b2 = cw.toByteArray(); <span class=comment>// b2 represents the same class as b1</span></span><br></pre></table></figure><p>但是，结果不会改变，因为ClassVisitor事件过滤器不过滤任何内容。但是，现在可以通过重写某些方法来过滤某些事件，以便能够转换类。例如，考虑以下ClassVisitor子类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ChangeVersionAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ChangeVersionAdapter</span><span class=params>(ClassVisitor cv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(<span class=type>int</span> version, <span class=type>int</span> access, String name, String signature, String superName, String[] interfaces)</span> {</span><br><span class=line>    	cv.visit(V1_5, access, name, signature, superName, interfaces);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>此类仅覆盖ClassVisitor类的一个方法。结果，除了对visit方法的调用之外，所有调用均以不变的方式转发给传递给构造函数的类visitor cv，后者以修改后的类版本号转发。<h4 id=2-2-4-1、优化><a class=headerlink href=#2-2-4-1、优化 title=2.2.4.1、优化></a>2.2.4.1、优化</h4><p>上一个转换仅更改原始类中的四个字节。但是，使用上面的代码，b1被完全解析，并且相应的事件用于从头开始构造b2，这不是很有效。复制不直接转换为b2的b1部分，而无需解析这些部分并且不生成相应的事件，将更加有效。 ASM自动为方法执行此优化：<ol><li>如果ClassReader组件检测到作为参数传递给其accept方法的ClassVisitor返回的MethodVisitor来自ClassWriter，则这意味着该方法的内容将不会被转换，并且实际上甚至不会被应用程序看到。<li>在这种情况下，ClassReader组件不会解析此方法的内容，不会生成相应的事件，而只是复制ClassWriter中此方法的字节数组表示形式</ol><p>如果ClassReader和ClassWriter组件具有相互引用，则可以通过以下方式进行此优化：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=type>byte</span>[] b1 = ...</span><br><span class=line><span class=type>ClassReader</span> <span class=variable>cr</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassReader</span>(b1);</span><br><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(cr, <span class=number>0</span>);</span><br><span class=line><span class=type>ChangeVersionAdapter</span> <span class=variable>ca</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ChangeVersionAdapter</span>(cw);</span><br><span class=line>cr.accept(ca, <span class=number>0</span>);</span><br><span class=line><span class=type>byte</span>[] b2 = cw.toByteArray();</span><br></pre></table></figure><h4 id=2-2-4-2、使用转换类><a class=headerlink href=#2-2-4-2、使用转换类 title=2.2.4.2、使用转换类></a>2.2.4.2、使用转换类</h4><p>可以将转换后的类b2存储在磁盘上或用ClassLoader加载。但是在ClassLoader内部完成的类转换只能转换由此类加载器加载的类。如果要转换所有类，则必须将转换放入ClassFileTransformer内，如java.lang.instrument包中所定义（有关更多详细信息，请参见此包的文档）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">premain</span><span class=params>(String agentArgs, Instrumentation inst)</span> {</span><br><span class=line>    inst.addTransformer(<span class=keyword>new</span> <span class="title class_">ClassFileTransformer</span>() {</span><br><span class=line>    	<span class=keyword>public</span> <span class=type>byte</span>[] transform(ClassLoader l, String name, Class c, ProtectionDomain d, <span class=type>byte</span>[] b)<span class=keyword>throws</span> IllegalClassFormatException {</span><br><span class=line>            <span class=type>ClassReader</span> <span class=variable>cr</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassReader</span>(b);</span><br><span class=line>            <span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(cr, <span class=number>0</span>);</span><br><span class=line>            <span class=type>ClassVisitor</span> <span class=variable>cv</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ChangeVersionAdapter</span>(cw);</span><br><span class=line>            cr.accept(cv, <span class=number>0</span>);</span><br><span class=line>            <span class=keyword>return</span> cw.toByteArray();</span><br><span class=line>    	}</span><br><span class=line>    });</span><br><span class=line>}</span><br></pre></table></figure><h3 id=2-2-5、删除类成员><a class=headerlink href=#2-2-5、删除类成员 title=2.2.5、删除类成员></a>2.2.5、删除类成员</h3><p>例如，以下类适配器删除有关外部类和内部类的信息，以及从中编译该类的源文件的名称（生成的类保持完整的功能，因为这些元素仅用于调试目的）。这是通过不以适当的访问方法转发任何内容来完成的：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoveDebugAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RemoveDebugAdapter</span><span class=params>(ClassVisitor cv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitSource</span><span class=params>(String source, String debug)</span> {}</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitOuterClass</span><span class=params>(String owner, String name, String desc)</span> {}</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInnerClass</span><span class=params>(String name, String outerName, String innerName, <span class=type>int</span> access)</span> {}</span><br><span class=line>}</span><br></pre></table></figure><p>该策略不适用于字段和方法，因为visitField和visitMethod方法必须返回结果。为了删除字段或方法，您必须不要转发方法调用，并且必须将null返回给调用方。例如，以下类适配器删除由其名称和其描述符指定的单个方法（该名称不足以标识一个方法，因为一个类可以包含多个同名但参数不同的方法）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoveMethodAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>private</span> String mName;</span><br><span class=line>    <span class=keyword>private</span> String mDesc;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RemoveMethodAdapter</span><span class=params>(ClassVisitor cv, String mName, String mDesc)</span> {</span><br><span class=line>        <span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>        <span class=built_in>this</span>.mName = mName;</span><br><span class=line>        <span class=built_in>this</span>.mDesc = mDesc;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> MethodVisitor <span class="title function_">visitMethod</span><span class=params>(<span class=type>int</span> access, String name, String desc, String signature, String[] exceptions)</span> {</span><br><span class=line>        <span class=keyword>if</span> (name.equals(mName) && desc.equals(mDesc)) {</span><br><span class=line>            <span class=comment>// do not delegate to next visitor -> this removes the method</span></span><br><span class=line>            <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=2-2-6、添加类成员><a class=headerlink href=#2-2-6、添加类成员 title=2.2.6、添加类成员></a>2.2.6、添加类成员</h3><p>这里是一个类适配器，它将一个字段添加到类中，除非该字段已经存在：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AddFieldAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> fAcc;</span><br><span class=line>    <span class=keyword>private</span> String fName;</span><br><span class=line>    <span class=keyword>private</span> String fDesc;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>boolean</span> isFieldPresent;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AddFieldAdapter</span><span class=params>(ClassVisitor cv, <span class=type>int</span> fAcc, String fName, String fDesc)</span> {</span><br><span class=line>        <span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>        <span class=built_in>this</span>.fAcc = fAcc;</span><br><span class=line>        <span class=built_in>this</span>.fName = fName;</span><br><span class=line>        <span class=built_in>this</span>.fDesc = fDesc;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> FieldVisitor <span class="title function_">visitField</span><span class=params>(<span class=type>int</span> access, String name, String desc, String signature, Object value)</span> {</span><br><span class=line>        <span class=keyword>if</span> (name.equals(fName)) {</span><br><span class=line>            isFieldPresent = <span class=literal>true</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cv.visitField(access, name, desc, signature, value);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>if</span> (!isFieldPresent) {</span><br><span class=line>            <span class=type>FieldVisitor</span> <span class=variable>fv</span> <span class=operator>=</span> cv.visitField(fAcc, fName, fDesc, <span class=literal>null</span>, <span class=literal>null</span>);</span><br><span class=line>            <span class=keyword>if</span> (fv != <span class=literal>null</span>) {</span><br><span class=line>            	fv.visitEnd();</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        cv.visitEnd();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=2-2-7、转型链><a class=headerlink href=#2-2-7、转型链 title=2.2.7、转型链></a>2.2.7、转型链</h3><p>到目前为止，我们已经看到了由ClassReader，类适配器和ClassWriter组成的简单转换链。当然，可以使用更复杂的链，将多个类适配器链在一起。链接多个适配器可让您组成多个独立的类转换，以执行复杂的转换。还要注意，转换链不一定是线性的。您可以编写一个ClassVisitor，将它同时收到的所有方法调用转发到多个ClassVisitor：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MultiClassAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>protected</span> ClassVisitor[] cvs;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MultiClassAdapter</span><span class=params>(ClassVisitor[] cvs)</span> {</span><br><span class=line>        <span class=built_in>super</span>(ASM4);</span><br><span class=line>        <span class=built_in>this</span>.cvs = cvs;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(<span class=type>int</span> version, <span class=type>int</span> access, String name, String signature, String superName, String[] interfaces)</span> {</span><br><span class=line>        <span class=keyword>for</span> (ClassVisitor cv : cvs) {</span><br><span class=line>        	cv.visit(version, access, name, signature, superName, interfaces);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    ...</span><br><span class=line>}</span><br></pre></table></figure><h2 id=2-3、工具><a class=headerlink href=#2-3、工具 title=2.3、工具></a>2.3、工具</h2><h3 id=2-3-1、Type><a class=headerlink href=#2-3-1、Type title=2.3.1、Type></a>2.3.1、Type</h3><p>如前几节所述，ASM API公开了Java类型，因为它们存储在编译的类中，即作为内部名称或类型描述符。可以将它们公开显示在源代码中，以使代码更具可读性。但这需要在ClassReader和ClassWriter中的两种表示形式之间进行系统的转换，这会降低性能。这就是ASM不会将内部名称和类型描述符透明转换为等效的源代码形式的原因。但是，它提供了Type类，以便在必要时手动执行此操作。<p>Type对象表示Java类型，可以从类型描述符或从Class对象构造。 Type类还包含表示原始类型的静态变量。例如，Type.INT_TYPE是表示int类型的Type对象。<h3 id=2-3-2、TraceClassVisitor><a class=headerlink href=#2-3-2、TraceClassVisitor title=2.3.2、TraceClassVisitor></a>2.3.2、TraceClassVisitor</h3><p>为了检查生成的或转换的类是否符合您的期望，ClassWriter返回的字节数组并没有真正的帮助，因为它是人类无法读取的。文本表示将更易于使用。这是TraceClassVisitor类提供的。顾名思义，该类扩展了ClassVisitor类，并构造了所访问类的文本表示形式。因此，可以使用TraceClassVisitor而不是使用ClassWriter来生成类，以便获得对实际生成内容的可读记录。或者，甚至更好的是，您可以同时使用两者。实际上，TraceClassVisitor除了其默认行为外，还可以将对其方法的所有调用委派给另一个访问者，例如ClassWriter：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line><span class=type>TraceClassVisitor</span> <span class=variable>cv</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TraceClassVisitor</span>(cw, printWriter);</span><br><span class=line>cv.visit(...);</span><br><span class=line>...</span><br><span class=line>cv.visitEnd();</span><br><span class=line><span class=type>byte</span> b[] = cw.toByteArray();</span><br><span class=line></span><br></pre></table></figure><p>这段代码创建了一个TraceClassVisitor，它将接收到的所有调用委托给cw，并将这些调用的文本表示输出到printWriter。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=comment>// class version 49.0 (49)</span></span><br><span class=line><span class=comment>// access flags 1537</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>interface</span> <span class="title class_">pkg</span>/Comparable <span class=keyword>implements</span> <span class="title class_">pkg</span>/Mesurable {</span><br><span class=line>    <span class=comment>// access flags 25</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>I</span> <span class=variable>LESS</span> <span class=operator>=</span> -<span class=number>1</span></span><br><span class=line>    <span class=comment>// access flags 25</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>I</span> <span class=variable>EQUAL</span> <span class=operator>=</span> <span class=number>0</span></span><br><span class=line>    <span class=comment>// access flags 25</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>I</span> <span class=variable>GREATER</span> <span class=operator>=</span> <span class=number>1</span></span><br><span class=line>    <span class=comment>// access flags 1025</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> <span class="title function_">compareTo</span><span class=params>(Ljava/lang/Object;)</span>I</span><br><span class=line>}</span><br></pre></table></figure><h3 id=2-3-3、CheckClassAdapter><a class=headerlink href=#2-3-3、CheckClassAdapter title=2.3.3、CheckClassAdapter></a>2.3.3、CheckClassAdapter</h3><p>为了检查一个类，打印该类的文本表示形式，最后创建一个字节数组表示形式，您应该使用类似以下内容的方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line><span class=type>TraceClassVisitor</span> <span class=variable>tcv</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TraceClassVisitor</span>(cw, printWriter);</span><br><span class=line><span class=type>CheckClassAdapter</span> <span class=variable>cv</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">CheckClassAdapter</span>(tcv);</span><br><span class=line>cv.visit(...);</span><br><span class=line>...</span><br><span class=line>cv.visitEnd();</span><br><span class=line><span class=type>byte</span> b[] = cw.toByteArray();</span><br></pre></table></figure><p>请注意，如果以不同的顺序链接这些类访问者，则它们执行的操作也将以不同的顺序进行。例如，使用以下代码，检查将在跟踪之后进行：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line><span class=type>CheckClassAdapter</span> <span class=variable>cca</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">CheckClassAdapter</span>(cw);</span><br><span class=line><span class=type>TraceClassVisitor</span> <span class=variable>cv</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TraceClassVisitor</span>(cca, printWriter);</span><br></pre></table></figure><p>与TraceClassVisitor一样，您可以在生成或转换链中的任何点使用CheckClassAdapter，不仅可以在ClassWriter之前使用，还可以在链中此点检查类。<h3 id=2-3-4、ASMifier><a class=headerlink href=#2-3-4、ASMifier title=2.3.4、ASMifier></a>2.3.4、ASMifier</h3><p>可以从命令行使用ASMifier类。例如使用：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>java -classpath asm.jar:asm-util.jar \</span><br><span class=line>org.objectweb.asm.util.ASMifier \</span><br><span class=line>java.lang.Runnable</span><br></pre></table></figure><p>产生缩进后的代码为：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> asm.java.lang;</span><br><span class=line><span class=keyword>import</span> org.objectweb.asm.*;</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RunnableDump</span> <span class=keyword>implements</span> <span class="title class_">Opcodes</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=type>byte</span>[] dump() <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line>        FieldVisitor fv;</span><br><span class=line>        MethodVisitor mv;</span><br><span class=line>        AnnotationVisitor av0;</span><br><span class=line>        cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, <span class=string>"java/lang/Runnable"</span>, <span class=literal>null</span>, <span class=string>"java/lang/Object"</span>, <span class=literal>null</span>);</span><br><span class=line>    {</span><br><span class=line>        mv = cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, <span class=string>"run"</span>, <span class=string>"()V"</span>, <span class=literal>null</span>, <span class=literal>null</span>);</span><br><span class=line>        mv.visitEnd();</span><br><span class=line>    }</span><br><span class=line>    cw.visitEnd();</span><br><span class=line>    <span class=keyword>return</span> cw.toByteArray();</span><br><span class=line>}</span><br></pre></table></figure><h1 id=3、方法><a class=headerlink href=#3、方法 title=3、方法></a>3、方法</h1><p>本章介绍如何使用核心ASM API生成和转换编译方法。它首先介绍了已编译的方法，然后提供了许多说明性示例，介绍了相应的ASM接口，组件以及生成和转换它们的工具。<h2 id=3-1、结构><a class=headerlink href=#3-1、结构 title=3.1、结构></a>3.1、结构</h2><p>在已编译的类中，方法的代码存储为一系列字节码指令。为了生成和转换类，了解这些指令并理解它们的工作原理至关重要。<h3 id=3-1-1、执行模式><a class=headerlink href=#3-1-1、执行模式 title=3.1.1、执行模式></a>3.1.1、执行模式</h3><p>在呈现字节码指令之前，必须呈现Java虚拟机执行模型。如您所知，Java代码是在线程内部执行的。每个线程都有其自己的执行堆栈，该堆栈由框架组成。每个框架代表一个方法调用：每次调用一个方法时，都会在当前线程的执行堆栈上推送一个新框架。当方法返回时，无论是正常情况还是由于异常而返回，都会从执行堆栈弹出该框架，并在调用方法中继续执行（其框架现在位于堆栈的顶部）。<p>局部变量和操作数堆栈部分的大小取决于方法的代码。它是在编译时计算的，并与字节码指令一起存储在已编译的类中。结果，与给定方法的调用相对应的所有框架都具有相同的大小，但是与不同方法相对应的框架的局部变量和操作数堆栈部分可以具有不同的大小。<h3 id=3-1-2、字节码指令><a class=headerlink href=#3-1-2、字节码指令 title=3.1.2、字节码指令></a>3.1.2、字节码指令</h3><p>字节码指令由标识该指令的操作码和固定数量的参数组成：<ul><li>操作码是一个无符号的字节值（因此为字节码名称），并由助记符标识。例如，操作码值0由助记符NOP设计，并且对应于不执行任何操作的指令。<li>参数是定义精确指令行为的静态值。它们在操作码之后给出。例如，操作码值为167的GOTO标签指令将自变量标签指定为要执行的下一条指令。指令参数不能与指令操作数混淆：参数值是静态已知的，并存储在编译后的代码中，而操作数值来自操作数堆栈，并且仅在运行时才知道。</ul><p>字节码指令可分为两类：一小组指令旨在将值从局部变量传输到操作数堆栈，反之亦然；其他指令仅作用于操作数堆栈：它们从堆栈中弹出一些值，根据这些值计算结果，然后将其推回堆栈。<p>所有其他字节码指令仅在操作数堆栈上工作。它们可以分为以下类别：<ul><li>Stack<li>Constants<li>Arithmetic and logic<li>Casts<li>Objects<li>Fields<li>Methods<li>Arrays<li>Jumps<li>Return</ul><h3 id=3-1-3、实例><a class=headerlink href=#3-1-3、实例 title=3.1.3、实例></a>3.1.3、实例</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> pkg;</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Bean</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> f;</span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">getF</span><span class=params>()</span> {</span><br><span class=line>    	<span class=keyword>return</span> <span class=built_in>this</span>.f;</span><br><span class=line>    }	</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setF</span><span class=params>(<span class=type>int</span> f)</span> {</span><br><span class=line>    	<span class=built_in>this</span>.f = f;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>getter方法的字节码为：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>ALOAD <span class=number>0</span></span><br><span class=line>GETFIELD pkg/Bean f I</span><br><span class=line>IRETURN</span><br></pre></table></figure><p>第一条指令读取局部变量0，该局部变量在创建此方法调用的帧期间已初始化为0，并将此值压入操作数堆栈。第二条指令从堆栈中弹出此值，即this，并压入此对象的f字段，即this.f.最后一条指令从堆栈中弹出该值，并将其返回给调用方。此方法的执行帧的连续状态如下图所示：<p><img alt=image-20200906150115558 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200906150115558.png?token=AIGEF3PER5BJHXJG27CVUGDEZZZ2Q><p>setter方法的字节码为：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>ALOAD <span class=number>0</span></span><br><span class=line>ILOAD <span class=number>1</span></span><br><span class=line>PUTFIELD pkg/Bean f I</span><br><span class=line>RETURN</span><br></pre></table></figure><p>第一条指令将其压入操作数堆栈。第二条指令压入局部变量1，该局部变量在创建用于此方法调用的框架期间使用f参数值初始化。第三条指令弹出这两个值，并将int值存储在所引用对象的f字段中，即在this.f中。最后一条指令在源代码中是隐式的，而在编译后的代码中是强制性的，它会破坏当前执行框架并返回给调用者。此方法的执行帧的连续状态如图3.3所示。<p><img alt=image-20200906150426003 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200906150426003.png?token=AIGEF3MGQCPQK5TETM4YJWDEZZZ32><p>现在让我们考虑一个稍微复杂一些的setter方法<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">checkAndSetF</span><span class=params>(<span class=type>int</span> f)</span> {</span><br><span class=line>    <span class=keyword>if</span> (f >= <span class=number>0</span>) {</span><br><span class=line>    	<span class=built_in>this</span>.f = f;</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>    	<span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>对应字节码如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line>    ILOAD <span class=number>1</span></span><br><span class=line>    IFLT label</span><br><span class=line>    ALOAD <span class=number>0</span></span><br><span class=line>    ILOAD <span class=number>1</span></span><br><span class=line>    PUTFIELD pkg/Bean f I</span><br><span class=line>    GOTO end</span><br><span class=line>label:</span><br><span class=line>    NEW java/lang/IllegalArgumentException</span><br><span class=line>    DUP</span><br><span class=line>    INVOKESPECIAL java/lang/IllegalArgumentException &LTinit> ()V</span><br><span class=line>    ATHROW</span><br><span class=line>end:</span><br><span class=line>	RETURN</span><br></pre></table></figure><h3 id=3-1-4、异常处理><a class=headerlink href=#3-1-4、异常处理 title=3.1.4、异常处理></a>3.1.4、异常处理</h3><p>例如下面的源代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">sleep</span><span class=params>(<span class=type>long</span> d)</span> {</span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>    	Thread.sleep(d);</span><br><span class=line>    } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>    	e.printStackTrace();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>其可以编译成：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>TRYCATCHBLOCK <span class=keyword>try</span> <span class=keyword>catch</span> <span class=keyword>catch</span> java/lang/InterruptedException</span><br><span class=line><span class=keyword>try</span>:</span><br><span class=line>LLOAD <span class=number>0</span></span><br><span class=line>INVOKESTATIC java/lang/Thread <span class="title function_">sleep</span> <span class=params>(J)</span>V</span><br><span class=line>RETURN</span><br><span class=line><span class=keyword>catch</span>:</span><br><span class=line>INVOKEVIRTUAL java/lang/InterruptedException <span class="title function_">printStackTrace</span> <span class=params>()</span>V</span><br><span class=line>RETURN</span><br></pre></table></figure><h3 id=3-1-5、Frames><a class=headerlink href=#3-1-5、Frames title=3.1.5、Frames></a>3.1.5、Frames</h3><p>例如，如果考虑上一节的getF方法，则可以定义三个堆栈映射框架，这些框架映射框架给出了执行框架的状态，这些状态仅在ALOAD之前，在GETFIELD之前和在IRETURN之前。这三个堆栈映射框架对应于图3.2中所示的三种情况，可以描述如下，其中第一个方括号之间的类型对应于局部变量，其他类型对应于操作数堆栈：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>State of the execution frame before 	Instruction</span><br><span class=line>[pkg/Bean] [] 						  ALOAD <span class=number>0</span></span><br><span class=line>[pkg/Bean] [pkg/Bean] 				   GETFIELD</span><br><span class=line>[pkg/Bean] [I] 						  IRETURN</span><br></pre></table></figure><p>我们可以对checkAndSetF方法做同样的事情：<p><img alt=image-20200906151656565 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200906151656565.png?token=AIGEF3NVDVSTEU3H4PJNRM3EZZZ5W><p>为了节省更多空间，通过仅存储与前一帧的差异来压缩每个帧，并且不存储初始帧，因为它可以很容易地从方法参数类型推导出来。在使用checkAndSetF方法的情况下，必须存储的两个帧相等并且等于初始帧，因此将它们存储为F_SAME助记符指定的单字节值。这些帧可以在它们关联的字节码指令之前被表示。这给出了checkAndSetF方法的最终字节码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line>ILOAD <span class=number>1</span></span><br><span class=line>IFLT label</span><br><span class=line>ALOAD <span class=number>0</span></span><br><span class=line>ILOAD <span class=number>1</span></span><br><span class=line>PUTFIELD pkg/Bean f I</span><br><span class=line>GOTO end</span><br><span class=line>label:</span><br><span class=line>F_SAME</span><br><span class=line>NEW java/lang/IllegalArgumentException</span><br><span class=line>DUP</span><br><span class=line>INVOKESPECIAL java/lang/IllegalArgumentException &LTinit> ()V</span><br><span class=line>ATHROW</span><br><span class=line>end:</span><br><span class=line>F_SAME</span><br><span class=line>RETURN</span><br></pre></table></figure><h2 id=3-2、接口与组件><a class=headerlink href=#3-2、接口与组件 title=3.2、接口与组件></a>3.2、接口与组件</h2><h3 id=3-2-2、生成方法><a class=headerlink href=#3-2-2、生成方法 title=3.2.2、生成方法></a>3.2.2、生成方法</h3><p>如果mv是MethodVisitor，则可以使用以下方法调用生成3.1.3节中定义的getF方法的字节码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>mv.visitCode();</span><br><span class=line>mv.visitVarInsn(ALOAD, <span class=number>0</span>);</span><br><span class=line>mv.visitFieldInsn(GETFIELD, <span class=string>"pkg/Bean"</span>, <span class=string>"f"</span>, <span class=string>"I"</span>);</span><br><span class=line>mv.visitInsn(IRETURN);</span><br><span class=line>mv.visitMaxs(<span class=number>1</span>, <span class=number>1</span>);</span><br><span class=line>mv.visitEnd();</span><br></pre></table></figure><p>setF方法和构造函数的字节码可以类似的方式生成。一个更有趣的示例是checkAndSetF方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line>mv.visitCode();</span><br><span class=line>mv.visitVarInsn(ILOAD, <span class=number>1</span>);</span><br><span class=line><span class=type>Label</span> <span class=variable>label</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Label</span>();</span><br><span class=line>mv.visitJumpInsn(IFLT, label);</span><br><span class=line>mv.visitVarInsn(ALOAD, <span class=number>0</span>);</span><br><span class=line>mv.visitVarInsn(ILOAD, <span class=number>1</span>);</span><br><span class=line>mv.visitFieldInsn(PUTFIELD, <span class=string>"pkg/Bean"</span>, <span class=string>"f"</span>, <span class=string>"I"</span>);</span><br><span class=line><span class=type>Label</span> <span class=variable>end</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Label</span>();</span><br><span class=line>mv.visitJumpInsn(GOTO, end);</span><br><span class=line>mv.visitLabel(label);</span><br><span class=line>mv.visitFrame(F_SAME, <span class=number>0</span>, <span class=literal>null</span>, <span class=number>0</span>, <span class=literal>null</span>);</span><br><span class=line>mv.visitTypeInsn(NEW, <span class=string>"java/lang/IllegalArgumentException"</span>);</span><br><span class=line>mv.visitInsn(DUP);</span><br><span class=line>mv.visitMethodInsn(INVOKESPECIAL,</span><br><span class=line><span class=string>"java/lang/IllegalArgumentException"</span>, <span class=string>"&LTinit>"</span>, <span class=string>"()V"</span>);</span><br><span class=line>mv.visitInsn(ATHROW);</span><br><span class=line>mv.visitLabel(end);</span><br><span class=line>mv.visitFrame(F_SAME, <span class=number>0</span>, <span class=literal>null</span>, <span class=number>0</span>, <span class=literal>null</span>);</span><br><span class=line>mv.visitInsn(RETURN);</span><br><span class=line>mv.visitMaxs(<span class=number>2</span>, <span class=number>2</span>);</span><br><span class=line>mv.visitEnd();</span><br></pre></table></figure><blockquote><p>注意：Label对象指定该标签的visitLabel调用之后的指令。例如，end指定RETURN指令，而不是紧随其后访问的帧，因为这不是指令。拥有多个指定同一条指令的标签是完全合法的，但是标签必须精确地指定一条指令。换句话说，可以使用不同的标签连续调用visitLabel，但是指令中使用的标签必须使用visitLabel进行一次精确的访问。最后一个约束是不能共享标签：每个方法必须具有自己的标签。</blockquote><h3 id=3-2-3、转换方法><a class=headerlink href=#3-2-3、转换方法 title=3.2.3、转换方法></a>3.2.3、转换方法</h3><p>为了了解如何使用方法适配器，让我们考虑一个非常简单的适配器，它删除了方法内部的NOP指令（可以删除它们，因为它们什么都不做，因此不会出现问题）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoveNopAdapter</span> <span class=keyword>extends</span> <span class="title class_">MethodVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RemoveNopAdapter</span><span class=params>(MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        <span class=keyword>if</span> (opcode != NOP) {</span><br><span class=line>        	mv.visitInsn(opcode);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>可以在类适配器内部使用此适配器，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoveNopClassAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RemoveNopClassAdapter</span><span class=params>(ClassVisitor cv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> MethodVisitor <span class="title function_">visitMethod</span><span class=params>(<span class=type>int</span> access, String name,</span></span><br><span class=line><span class=params>        String desc, String signature, String[] exceptions)</span> {</span><br><span class=line>        MethodVisitor mv;</span><br><span class=line>        mv = cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class=line>        <span class=keyword>if</span> (mv != <span class=literal>null</span>) {</span><br><span class=line>        	mv = <span class=keyword>new</span> <span class="title class_">RemoveNopAdapter</span>(mv);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> mv;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>但是请注意，这不是强制性的：完全有可能构建与类适配器链不同的方法适配器链。每个方法甚至可以具有不同的方法适配器链。例如，类适配器可以选择仅在方法中而不在构造函数中删除NOP。可以按照以下步骤进行：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>...</span><br><span class=line>mv = cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class=line><span class=keyword>if</span> (mv != <span class=literal>null</span> && !name.equals(<span class=string>"&LTinit>"</span>)) {</span><br><span class=line>mv = <span class=keyword>new</span> <span class="title class_">RemoveNopAdapter</span>(mv);</span><br><span class=line>}</span><br><span class=line>...</span><br></pre></table></figure><p>方法适配器链甚至可以具有与类适配器链不同的拓扑。例如，类适配器链可以是线性的，而方法适配器链具有分支：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> MethodVisitor <span class="title function_">visitMethod</span><span class=params>(<span class=type>int</span> access, String name, String desc, String signature, String[] exceptions)</span> {</span><br><span class=line>    MethodVisitor mv1, mv2;</span><br><span class=line>    mv1 = cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class=line>    mv2 = cv.visitMethod(access, <span class=string>"_"</span> + name, desc, signature, exceptions);</span><br><span class=line>    <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">MultiMethodAdapter</span>(mv1, mv2);</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-2-4、无状态转换><a class=headerlink href=#3-2-4、无状态转换 title=3.2.4、无状态转换></a>3.2.4、无状态转换</h3><p>假设我们要衡量一个程序的每个类所花费的时间。我们需要在每个类中添加一个静态计时器字段，并且需要将该类的每个方法的执行时间添加到此计时器字段中。换句话说，我们要转换一个诸如C的类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">C</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">m</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>    	Thread.sleep(<span class=number>100</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>转为：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">C</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=type>long</span> timer;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">m</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        timer -= System.currentTimeMillis();</span><br><span class=line>        Thread.sleep(<span class=number>100</span>);</span><br><span class=line>        timer += System.currentTimeMillis();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>为了了解如何在ASM中实现这一点，我们可以编译这两个类，并比较这两个版本上的TraceClassVisitor的输出（使用默认的Textifier后端或使用ASMifier后端）。使用默认后端，我们得到以下差异（粗体）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line>GETSTATIC C.timer : J</span><br><span class=line>INVOKESTATIC java/lang/System.currentTimeMillis()J</span><br><span class=line>LSUB</span><br><span class=line>PUTSTATIC C.timer : J</span><br><span class=line>LDC <span class=number>100</span></span><br><span class=line>INVOKESTATIC java/lang/Thread.sleep(J)V</span><br><span class=line>GETSTATIC C.timer : J</span><br><span class=line>INVOKESTATIC java/lang/System.currentTimeMillis()J</span><br><span class=line>LADD</span><br><span class=line>PUTSTATIC C.timer : J</span><br><span class=line><span class=type>RETURN</span></span><br><span class=line><span class=variable>MAXSTACK</span> <span class=operator>=</span> <span class=number>4</span></span><br><span class=line>MAXLOCALS = <span class=number>1</span></span><br></pre></table></figure><p>我们看到必须在方法的开头添加四个指令，在返回指令之前添加四个其他指令。我们还需要更新最大操作数堆栈大小。该方法代码的开头是通过visitCode方法访问的。因此，我们可以通过在方法适配器中重写此方法来添加前四个指令：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitCode</span><span class=params>()</span> {</span><br><span class=line>    mv.visitCode();</span><br><span class=line>    mv.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>    mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>    mv.visitInsn(LSUB);</span><br><span class=line>    mv.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>}</span><br></pre></table></figure><p>必须将owner设置为要转换的类的名称。现在，我们必须在任何RETURN之前，任何xRETURN或ATHROW之前添加其他四条指令，它们都是终止该方法执行的所有指令。这些指令没有任何参数，因此可以在visitInsn方法中进行访问。然后，我们可以覆盖此方法以添加我们的说明：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>    <span class=keyword>if</span> ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {</span><br><span class=line>        mv.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>        mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>        mv.visitInsn(LADD);</span><br><span class=line>        mv.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>    }</span><br><span class=line>    mv.visitInsn(opcode);</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-2-5、有状态转换><a class=headerlink href=#3-2-5、有状态转换 title=3.2.5、有状态转换></a>3.2.5、有状态转换</h3><p>为了实现删除或替换某些指令序列的转换，可以方便地引入MethodVisitor子类，该子类的visitXxx Insn方法调用通用的visitInsn（）方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">PatternMethodAdapter</span> <span class=keyword>extends</span> <span class="title class_">MethodVisitor</span> {</span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>int</span> <span class=variable>SEEN_NOTHING</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>protected</span> <span class=type>int</span> state;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">PatternMethodAdapter</span><span class=params>(<span class=type>int</span> api, MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(api, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Overrid</span> <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        visitInsn();</span><br><span class=line>        mv.visitInsn(opcode);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitIntInsn</span><span class=params>(<span class=type>int</span> opcode, <span class=type>int</span> operand)</span> {</span><br><span class=line>        visitInsn();</span><br><span class=line>        mv.visitIntInsn(opcode, operand);</span><br><span class=line>    }</span><br><span class=line>    ...</span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>然后可以像这样实现上面的转换：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoveAddZeroAdapter</span> <span class=keyword>extends</span> <span class="title class_">PatternMethodAdapter</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>int</span> <span class=variable>SEEN_ICONST_0</span> <span class=operator>=</span> <span class=number>1</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RemoveAddZeroAdapter</span><span class=params>(MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        <span class=keyword>if</span> (state == SEEN_ICONST_0) {</span><br><span class=line>            <span class=keyword>if</span> (opcode == IADD) {</span><br><span class=line>            	state = SEEN_NOTHING;</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        visitInsn();</span><br><span class=line>        <span class=keyword>if</span> (opcode == ICONST_0) {</span><br><span class=line>            state = SEEN_ICONST_0;</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        mv.visitInsn(opcode);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> <span class=keyword>protected</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>if</span> (state == SEEN_ICONST_0) {</span><br><span class=line>        	mv.visitInsn(ICONST_0);</span><br><span class=line>        }</span><br><span class=line>        state = SEEN_NOTHING;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=3-3、工具><a class=headerlink href=#3-3、工具 title=3.3、工具></a>3.3、工具</h2><h3 id=3-3-1、基础工具><a class=headerlink href=#3-3-1、基础工具 title=3.3.1、基础工具></a>3.3.1、基础工具</h3><ul><li>Type<li>TraceClassVisitor<li>CheckClassAdapter<li>ASMifier</ul><h3 id=3-3-2、分析适配器><a class=headerlink href=#3-3-2、分析适配器 title=3.3.2、分析适配器></a>3.3.2、分析适配器</h3><p>在我们的AddTimerAdapter示例中，可以使用此适配器来获取RETURN指令之前的操作数堆栈的大小，从而允许为visitMaxs中的maxStack计算最佳转换值（实际上，不建议使用此方法，因为它比使用COMPUTE_MAXS效率低得多）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">AddTimerMethodAdapter2</span> <span class=keyword>extends</span> <span class="title class_">AnalyzerAdapter</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> maxStack;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AddTimerMethodAdapter2</span><span class=params>(String owner, <span class=type>int</span> access, String name, String desc, MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, owner, access, name, desc, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitCode</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>super</span>.visitCode();</span><br><span class=line>        mv.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>        mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>        mv.visitInsn(LSUB);</span><br><span class=line>        mv.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>        maxStack = <span class=number>4</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        <span class=keyword>if</span> ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {</span><br><span class=line>            mv.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>            mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>            mv.visitInsn(LADD);</span><br><span class=line>            mv.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>            maxStack = Math.max(maxStack, stack.size() + <span class=number>4</span>);</span><br><span class=line>        }</span><br><span class=line>    	<span class=built_in>super</span>.visitInsn(opcode);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitMaxs</span><span class=params>(<span class=type>int</span> maxStack, <span class=type>int</span> maxLocals)</span> {</span><br><span class=line>    	<span class=built_in>super</span>.visitMaxs(Math.max(<span class=built_in>this</span>.maxStack, maxStack), maxLocals);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>或者，可以通过调用超类的方法来插入新指令：结果是这些指令的帧将由AnalyzerAdapter计算。此外，由于此适配器基于其计算的帧来更新visitMaxs的参数，因此我们不需要自己更新它们：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">AddTimerMethodAdapter3</span> <span class=keyword>extends</span> <span class="title class_">AnalyzerAdapter</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AddTimerMethodAdapter3</span><span class=params>(String owner, <span class=type>int</span> access, String name, String desc, MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, owner, access, name, desc, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitCode</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>super</span>.visitCode();</span><br><span class=line>        <span class=built_in>super</span>.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>        <span class=built_in>super</span>.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>        <span class=built_in>super</span>.visitInsn(LSUB);</span><br><span class=line>        <span class=built_in>super</span>.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        <span class=keyword>if</span> ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {</span><br><span class=line>            <span class=built_in>super</span>.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>            <span class=built_in>super</span>.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>            <span class=built_in>super</span>.visitInsn(LADD);</span><br><span class=line>            <span class=built_in>super</span>.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>        }</span><br><span class=line>        <span class=built_in>super</span>.visitInsn(opcode);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-3-3、LocalVariablesSorter><a class=headerlink href=#3-3-3、LocalVariablesSorter title=3.3.3、LocalVariablesSorter></a>3.3.3、LocalVariablesSorter</h3><p>为了展示如何使用此适配器，假设我们要使用局部变量来实现AddTimerAdapter：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">C</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=type>long</span> timer;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">m</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>long</span> <span class=variable>t</span> <span class=operator>=</span> System.currentTimeMillis();</span><br><span class=line>        Thread.sleep(<span class=number>100</span>);</span><br><span class=line>        timer += System.currentTimeMillis() - t;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>通过扩展LocalVariablesSorter并使用此类中定义的newLocal方法，可以轻松完成此操作：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">AddTimerMethodAdapter4</span> <span class=keyword>extends</span> <span class="title class_">LocalVariablesSorter</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> time;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AddTimerMethodAdapter4</span><span class=params>(<span class=type>int</span> access, String desc, MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, access, desc, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitCode</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>super</span>.visitCode();</span><br><span class=line>        mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>        time = newLocal(Type.LONG_TYPE);</span><br><span class=line>        mv.visitVarInsn(LSTORE, time);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        <span class=keyword>if</span> ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {</span><br><span class=line>            mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>            mv.visitVarInsn(LLOAD, time);</span><br><span class=line>            mv.visitInsn(LSUB);</span><br><span class=line>            mv.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>            mv.visitInsn(LADD);</span><br><span class=line>            mv.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>        }</span><br><span class=line>        <span class=built_in>super</span>.visitInsn(opcode);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitMaxs</span><span class=params>(<span class=type>int</span> maxStack, <span class=type>int</span> maxLocals)</span> {</span><br><span class=line>    	<span class=built_in>super</span>.visitMaxs(maxStack + <span class=number>4</span>, maxLocals);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>使用局部变量不能解决我们在此类的原始版本中遇到的问题，该问题涉及maxStack的最坏情况。如果要使用AnalyzerAdapter来解决此问题，除了LocalVariablesSorter之外，还必须通过委派而不是通过继承使用这些适配器（因为无法进行多重继承）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">AddTimerMethodAdapter5</span> <span class=keyword>extends</span> <span class="title class_">MethodVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> LocalVariablesSorter lvs;</span><br><span class=line>    <span class=keyword>public</span> AnalyzerAdapter aa;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> time;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> maxStack;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AddTimerMethodAdapter5</span><span class=params>(MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitCode</span><span class=params>()</span> {</span><br><span class=line>        mv.visitCode();</span><br><span class=line>        mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>        time = lvs.newLocal(Type.LONG_TYPE);</span><br><span class=line>        mv.visitVarInsn(LSTORE, time);</span><br><span class=line>        maxStack = <span class=number>4</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        <span class=keyword>if</span> ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {</span><br><span class=line>            mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>            mv.visitVarInsn(LLOAD, time);</span><br><span class=line>            mv.visitInsn(LSUB);</span><br><span class=line>            mv.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>            mv.visitInsn(LADD);</span><br><span class=line>            mv.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>            maxStack = Math.max(aa.stack.size() + <span class=number>4</span>, maxStack);</span><br><span class=line>        }</span><br><span class=line>        mv.visitInsn(opcode);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitMaxs</span><span class=params>(<span class=type>int</span> maxStack, <span class=type>int</span> maxLocals)</span> {</span><br><span class=line>    	mv.visitMaxs(Math.max(<span class=built_in>this</span>.maxStack, maxStack), maxLocals);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>为了使用此适配器，您必须将LocalVariablesSorter链接到AnalyzerAdapter，后者本身也链接到您的适配器：第一个适配器将对局部变量进行排序并相应地更新帧，分析器适配器将计算中间帧，并考虑到前一个适配器中完成的重新编号，您的适配器将可以访问这些重新编号的中间框架。该链可以在visitMethod中构造如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>mv = cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class=line><span class=keyword>if</span> (!isInterface && mv != <span class=literal>null</span> && !name.equals(<span class=string>"&LTinit>"</span>)) {</span><br><span class=line>    <span class=type>AddTimerMethodAdapter5</span> <span class=variable>at</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AddTimerMethodAdapter5</span>(mv);</span><br><span class=line>    at.aa = <span class=keyword>new</span> <span class="title class_">AnalyzerAdapter</span>(owner, access, name, desc, at);</span><br><span class=line>    at.lvs = <span class=keyword>new</span> <span class="title class_">LocalVariablesSorter</span>(access, desc, at.aa);</span><br><span class=line>    <span class=keyword>return</span> at.lvs;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-3-4、AdviceAdapter><a class=headerlink href=#3-3-4、AdviceAdapter title=3.3.4、AdviceAdapter></a>3.3.4、AdviceAdapter</h3><h1 id=4、元数据><a class=headerlink href=#4、元数据 title=4、元数据></a>4、元数据</h1><p>本章说明如何使用核心API生成和转换已编译的Java类元数据，例如注释。每个部分都以一种类型的元数据开始呈现，然后以一些说明性示例呈现相应的ASM接口，组件和工具以生成和转换这些元数据。<h2 id=4-1、泛型><a class=headerlink href=#4-1、泛型 title=4.1、泛型></a>4.1、泛型</h2><p>诸如List之类的通用类以及使用它们的类包含有关它们声明或使用的通用类型的信息。字节码指令在运行时不使用此信息，但是可以通过反射API进行访问。编译器还使用它进行单独的编译。<h3 id=4-1-2、接口与组件><a class=headerlink href=#4-1-2、接口与组件 title=4.1.2、接口与组件></a>4.1.2、接口与组件</h3><p>与描述符一样，出于相同的效率原因（请参阅第2.3.1节），ASM API公开存储在已编译类中的签名（签名的主要出现位置是ClassVisitor类的visit，visitField和visitMethod方法，作为可选的类，类型或方法签名参数）。希望它还在org.objectweb.asm.signature包中基于SignatureVisitor抽象类提供了一些生成和转换签名的工具。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">SignatureVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>char</span> <span class=variable>EXTENDS</span> <span class=operator>=</span> ’+’;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>char</span> <span class=variable>SUPER</span> <span class=operator>=</span> ’-’;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>char</span> <span class=variable>INSTANCEOF</span> <span class=operator>=</span> ’=’;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">SignatureVisitor</span><span class=params>(<span class=type>int</span> api)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitFormalTypeParameter</span><span class=params>(String name)</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitClassBound</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitInterfaceBound</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitSuperclass</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitInterface</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitParameterType</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitReturnType</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitExceptionType</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitBaseType</span><span class=params>(<span class=type>char</span> descriptor)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitTypeVariable</span><span class=params>(String name)</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitArrayType</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitClassType</span><span class=params>(String name)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInnerClassType</span><span class=params>(String name)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitTypeArgument</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitTypeArgument</span><span class=params>(<span class=type>char</span> wildcard)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>以下代码的结果为“ LA.B;”：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=type>String</span> <span class=variable>s</span> <span class=operator>=</span> <span class=string>"Ljava/util/HashMap&LTTK;TV;>.HashIterator&LTTK;>;"</span>;</span><br><span class=line>Map&LTString, String> renaming = <span class=keyword>new</span> <span class="title class_">HashMap</span>&LTString, String>();</span><br><span class=line>renaming.put(<span class=string>"java/util/HashMap"</span>, <span class=string>"A"</span>);</span><br><span class=line>renaming.put(<span class=string>"java/util/HashMap.HashIterator"</span>, <span class=string>"B"</span>);</span><br><span class=line><span class=type>SignatureWriter</span> <span class=variable>sw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SignatureWriter</span>();</span><br><span class=line><span class=type>SignatureVisitor</span> <span class=variable>sa</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">RenameSignatureAdapter</span>(sw, renaming);</span><br><span class=line><span class=type>SignatureReader</span> <span class=variable>sr</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SignatureReader</span>(s);</span><br><span class=line>sr.acceptType(sa);</span><br><span class=line>sw.toString();</span><br></pre></table></figure><h3 id=4-1-3、工具><a class=headerlink href=#4-1-3、工具 title=4.1.3、工具></a>4.1.3、工具</h3><p>2.3节中介绍的TraceClassVisitor和ASMifier类以内部形式打印类文件中包含的签名。它们可以通过以下方式用于查找与给定泛型类型相对应的签名：编写具有某些泛型类型的Java类，对其进行编译，然后使用这些命令行工具来找到相应的签名。<h2 id=4-2、注解><a class=headerlink href=#4-2、注解 title=4.2、注解></a>4.2、注解</h2><p>如果类，字段，方法和方法参数的注释（例如@Deprecated或@Override）存储在已编译的类中，则其保留策略不是RetentionPolicy.SOURCE。该信息在运行时不会由字节码指令使用，但是如果保留策略为RetentionPolicy.RUNTIME，则可以通过反射API进行访问。编译器也可以使用它。<h3 id=4-2-1、结构><a class=headerlink href=#4-2-1、结构 title=4.2.1、结构></a>4.2.1、结构</h3><p>源代码中的注释可以采用各种形式，例如@ Deprecated，@ Retention（RetentionPolicy.CLASS）或@Task（desc =“ refactor”，id = 1）。但是，在内部，所有注释都具有相同的形式，并由注释类型和一组名称值对指定，其中值限于：<ol><li>基本值，字符串或类值。<li>枚举值。<li>注释值。<li>以上值的数组。</ol><p>请注意，注释可以包含其他注释，甚至可以包含注释数组。因此，注释可能非常复杂。<h3 id=4-2-2、接口与组件><a class=headerlink href=#4-2-2、接口与组件 title=4.2.2、接口与组件></a>4.2.2、接口与组件</h3><p>用于生成和转换注释的ASM API基于AnnotationVisitor抽象类。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">AnnotationVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AnnotationVisitor</span><span class=params>(<span class=type>int</span> api)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AnnotationVisitor</span><span class=params>(<span class=type>int</span> api, AnnotationVisitor av)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(String name, Object value)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnum</span><span class=params>(String name, String desc, String value)</span>;</span><br><span class=line>    <span class=keyword>public</span> AnnotationVisitor <span class="title function_">visitAnnotation</span><span class=params>(String name, String desc)</span>;</span><br><span class=line>    <span class=keyword>public</span> AnnotationVisitor <span class="title function_">visitArray</span><span class=params>(String name)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure><p><strong>添加，删除和检测注释：</strong><p>像字段和方法一样，可以通过在visitAnnotation方法中返回null来删除注释：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoveAnnotationAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>private</span> String annDesc;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RemoveAnnotationAdapter</span><span class=params>(ClassVisitor cv, String annDesc)</span> {</span><br><span class=line>        <span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>        <span class=built_in>this</span>.annDesc = annDesc;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> AnnotationVisitor <span class="title function_">visitAnnotation</span><span class=params>(String desc, <span class=type>boolean</span> vis)</span> {</span><br><span class=line>        <span class=keyword>if</span> (desc.equals(annDesc)) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cv.visitAnnotation(desc, vis);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>由于必须调用ClassVisitor类的方法的限制，添加类注释会更加困难。实际上，必须重写所有在visitAnnotation之后的方法，以检测何时访问了所有注释（由于使用了visitCode方法，方法注释更易于添加）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AddAnnotationAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>private</span> String annotationDesc;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>boolean</span> isAnnotationPresent;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AddAnnotationAdapter</span><span class=params>(ClassVisitor cv, String annotationDesc)</span> {</span><br><span class=line>        <span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>        <span class=built_in>this</span>.annotationDesc = annotationDesc;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(<span class=type>int</span> version, <span class=type>int</span> access, String name, String signature, String superName, String[] interfaces)</span> {</span><br><span class=line>        <span class=type>int</span> <span class=variable>v</span> <span class=operator>=</span> (version & <span class=number>0xFF</span>) < V1_5 ? V1_5 : version;</span><br><span class=line>        cv.visit(v, access, name, signature, superName, interfaces);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> AnnotationVisitor <span class="title function_">visitAnnotation</span><span class=params>(String desc, <span class=type>boolean</span> visible)</span> {</span><br><span class=line>        <span class=keyword>if</span> (visible && desc.equals(annotationDesc)) {</span><br><span class=line>            isAnnotationPresent = <span class=literal>true</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cv.visitAnnotation(desc, visible);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInnerClass</span><span class=params>(String name, String outerName, String innerName, <span class=type>int</span> access)</span> {</span><br><span class=line>        addAnnotation();</span><br><span class=line>        cv.visitInnerClass(name, outerName, innerName, access);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> FieldVisitor <span class="title function_">visitField</span><span class=params>(<span class=type>int</span> access, String name, String desc, String signature, Object value)</span> {</span><br><span class=line>        addAnnotation();</span><br><span class=line>        <span class=keyword>return</span> cv.visitField(access, name, desc, signature, value);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> MethodVisitor <span class="title function_">visitMethod</span><span class=params>(<span class=type>int</span> access, String name, String desc, String signature, String[] exceptions)</span> {</span><br><span class=line>        addAnnotation();</span><br><span class=line>        <span class=keyword>return</span> cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span> {</span><br><span class=line>        addAnnotation();</span><br><span class=line>        cv.visitEnd();</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">addAnnotation</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>if</span> (!isAnnotationPresent) {</span><br><span class=line>            <span class=type>AnnotationVisitor</span> <span class=variable>av</span> <span class=operator>=</span> cv.visitAnnotation(annotationDesc, <span class=literal>true</span>);</span><br><span class=line>            <span class=keyword>if</span> (av != <span class=literal>null</span>) {</span><br><span class=line>            	av.visitEnd();</span><br><span class=line>            }</span><br><span class=line>            isAnnotationPresent = <span class=literal>true</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=4-2-3、工具><a class=headerlink href=#4-2-3、工具 title=4.2.3、工具></a>4.2.3、工具</h3><p>2.3节中介绍的TraceClassVisitor，CheckClassAdapter和ASMifier类也支持注释（与方法一样，也可以使用TraceAnnotationVisitor或CheckAnnotationAdapter在单个注释级别而不是在类级别使用）。它们可以用来查看如何生成一些特定的注释。例如使用：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>java -classpath asm.jar:asm-util.jar \</span><br><span class=line>org.objectweb.asm.util.ASMifier \</span><br><span class=line>java.lang.Deprecated</span><br></pre></table></figure><p>打印经过少量重构后的代码，其内容为：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> asm.java.lang;</span><br><span class=line><span class=keyword>import</span> org.objectweb.asm.*;</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DeprecatedDump</span> <span class=keyword>implements</span> <span class="title class_">Opcodes</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=type>byte</span>[] dump() <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line>        AnnotationVisitor av;</span><br><span class=line>        cw.visit(V1_5, ACC_PUBLIC + ACC_ANNOTATION + ACC_ABSTRACT + ACC_INTERFACE, <span class=string>"java/lang/Deprecated"</span>, <span class=literal>null</span>, <span class=string>"java/lang/Object"</span>, <span class=keyword>new</span> <span class="title class_">String</span>[] {<span class=string>"java/lang/annotation/Annotation"</span> });</span><br><span class=line>        {</span><br><span class=line>            av = cw.visitAnnotation(<span class=string>"Ljava/lang/annotation/Documented;"</span>, <span class=literal>true</span>);</span><br><span class=line>            av.visitEnd();</span><br><span class=line>        }</span><br><span class=line>        {</span><br><span class=line>            av = cw.visitAnnotation(<span class=string>"Ljava/lang/annotation/Retention;"</span>, <span class=literal>true</span>);</span><br><span class=line>            av.visitEnum(<span class=string>"value"</span>, <span class=string>"Ljava/lang/annotation/RetentionPolicy;"</span>,</span><br><span class=line>            <span class=string>"RUNTIME"</span>);</span><br><span class=line>            av.visitEnd();</span><br><span class=line>        }</span><br><span class=line>        cw.visitEnd();</span><br><span class=line>        <span class=keyword>return</span> cw.toByteArray();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=4-3、Debug><a class=headerlink href=#4-3、Debug title=4.3、Debug></a>4.3、Debug</h2><p>用javac -g编译的类包含其源文件的名称，源行号和字节码指令之间的映射以及源代码中的本地变量名称和字节码中的本地变量槽之间的映射。此可选信息在调试器中使用，并且在可用时在异常堆栈跟踪中使用。<h3 id=4-3-2、接口与组件><a class=headerlink href=#4-3-2、接口与组件 title=4.3.2、接口与组件></a>4.3.2、接口与组件</h3><p>使用ClassVisitor和MethodVisitor类的三种方法访问调试信息：<ul><li>使用ClassVisitor类的visitSource方法访问源文件名；<li>使用MethodVisitor类的visitLineNumber方法访问源行号和字节码指令之间的映射，一次一对。<li>使用MethodVisitor类的visitLocalVariable方法访问源代码中的局部变量名称和字节码中的局部变量槽之间的映射，一次访问一个元组。</ul><p>在访问作为参数传递的标签之后，必须调用visitLineNumber方法。实际上，在该标签之后调用它，这使得在方法访问者中很容易知道当前指令的源代码行：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyAdapter</span> <span class=keyword>extends</span> <span class="title class_">MethodVisitor</span> {</span><br><span class=line>    <span class=type>int</span> currentLine;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MyAdapter</span><span class=params>(MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitLineNumber</span><span class=params>(<span class=type>int</span> line, Label start)</span> {</span><br><span class=line>        mv.visitLineNumber(line, start);</span><br><span class=line>        currentLine = line;</span><br><span class=line>    }</span><br><span class=line>    ...</span><br><span class=line>}</span><br></pre></table></figure><p>同样，在访问作为参数传递的标签之后，必须调用visitLocalVariable方法。这是与上一节中介绍的对和元组相对应的示例方法调用：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>visitLineNumber(n1, l1);</span><br><span class=line>visitLineNumber(n2, l2);</span><br><span class=line>visitLineNumber(n3, l3);</span><br><span class=line>visitLocalVariable(<span class=string>"i"</span>, <span class=string>"I"</span>, <span class=literal>null</span>, l1, l2, <span class=number>1</span>);</span><br><span class=line>visitLocalVariable(<span class=string>"j"</span>, <span class=string>"I"</span>, <span class=literal>null</span>, l2, l3, <span class=number>1</span>);</span><br><span class=line>visitLocalVariable(<span class=string>"i"</span>, <span class=string>"I"</span>, <span class=literal>null</span>, l3, end, <span class=number>1</span>);</span><br></pre></table></figure><p><strong>忽略调试信息</strong><p>注意：ClassReader类提供其他选项，例如SKIP_CODE跳过对已编译代码的访问（如果您只需要类结构，这将很有用），SKIP_FRAMES跳过堆栈映射框架，以及EXPAND_FRAMES取消压缩这些框架。<h3 id=4-3-3、工具><a class=headerlink href=#4-3-3、工具 title=4.3.3、工具></a>4.3.3、工具</h3><p>与通用类型和注释一样，您可以使用TraceClassVisitor，CheckClassAdapter和ASMifier类来查找如何使用调试信息。<h1 id=5、向后兼容（Backward-compatibility）><a title="5、向后兼容（Backward compatibility）" class=headerlink href=#5、向后兼容（Backward-compatibility）></a>5、向后兼容（Backward compatibility）</h1><h2 id=5-1、简介><a class=headerlink href=#5-1、简介 title=5.1、简介></a>5.1、简介</h2><p>ASM 4.0中引入的向后兼容机制，需要将ClassVisitor，FieldVisitor，MethodVisitor等从接口更改为抽象类，并使用构造函数以ASM版本作为参数。如果您的代码是针对ASM 3.x实施的，则可以通过在代码分析器和适配器中将扩展替换为工具，并在其构造函数中指定ASM版本，将其升级到ASM 4.0。此外，ClassAdapter和MethodAdapter已合并为ClassVisitor和MethodVisitor。要转换代码，只需要将ClassAdapter替换为ClassVisitor，并将MethodAdapter替换为MethodVisitor。另外，如果定义了自定义FieldAdapter或AnnotationAdapter类，则现在可以将它们替换为FieldVisitor和AnnotationVisitor。<h3 id=5-1-1、Backward-compatibility-contract><a title="5.1.1、Backward compatibility contract" class=headerlink href=#5-1-1、Backward-compatibility-contract></a>5.1.1、Backward compatibility contract</h3><p>实际上，对于类生成器，分析器和适配器，影响是不同的：<ul><li>类生成器不受影响：它们生成具有某些固定类版本的代码，并且这些生成的类将在将来的JVM版本中保持有效，因为JVM确保了向后二进制兼容性。<li>•类分析器可能会受到影响，也可能不会受到影响。例如，尽管引入了注释，但是分析针对Java 4编写的字节码指令的代码可能仍将适用于Java 5类。但是，这些相同的代码可能不再适用于Java 7类，因为它不能忽略新的invokedynamic指令。<li>类适配器可能会受到影响，也可能不会受到影响。无效代码删除工具不受注释的引入甚至新的invokedynamic指令的影响。另一方面，类重命名工具受这两者的影响。类适配器可能会受到影响，也可能不会受到影响。无效代码删除工具不受注释的引入甚至新的invokedynamic指令的影响。另一方面，类重命名工具受这两者的影响。</ul><p>所有这些导致了以下向后兼容协议的定义：<ul><li>ASM版本X是为版本小于或等于x的Java类编写的。它不能生成版本y> x的类，并且在ClassReader.accept中输入大于x的类作为输入时必须失败。<li>为ASM X编写的代码并遵循下面介绍的准则，必须继续使用未经修改的输入类，并且输入类的版本必须为x，且ASM的将来版本为Y> X。<li>为ASM X编写并遵循下面介绍的准则的代码必须继续使用未经声明的输入类，它们的声明版本为y，但仅使用具有ASM Y或更高版本的旧版本或等于x的版本中定义的功能。<li>如果将使用ASM X或任何其他将来版本的，使用类版本y> x中引入的功能的输入作为输入，则为ASM X编写并遵循下面介绍的准则的代码必须失败。</ul><p>请注意，最后三点与类别生成器无关，后者没有类别输入。<h3 id=5-1-2、例子><a class=headerlink href=#5-1-2、例子 title=5.1.2、例子></a>5.1.2、例子</h3><p>为了说明用户指南和确保向后兼容性的内部ASM机制，我们在本章中假设将向Java 8类添加两个新的虚构属性，一个用于存储类作者，另一个用于存储其许可证。 。我们还假设这些新属性将通过ASM 5.0中的ClassVisitor中的两个新方法公开：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> <span class="title function_">visitLicense</span><span class=params>(String license)</span>;</span><br></pre></table></figure><p>来访问许可证，并使用新版本的visitSource来与源文件名和调试信息1一起访问作者：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> <span class="title function_">visitSource</span><span class=params>(String author, String source, String debug)</span>;</span><br></pre></table></figure><p>旧的visitSource方法仍然有效，但是在ASM 5.0中声明为已弃用：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta>@Deprecated</span> </span><br><span class=line><span class=keyword>void</span> <span class="title function_">visitSource</span><span class=params>(String source, String debug)</span>;</span><br></pre></table></figure><p>author和license属性是可选的，即，调用visitLicense不是必需的，在visitSource调用中author可以为null。<h2 id=5-2、指导><a class=headerlink href=#5-2、指导 title=5.2、指导></a>5.2、指导</h2><h3 id=5-2-1、基本规则><a class=headerlink href=#5-2-1、基本规则 title=5.2.1、基本规则></a>5.2.1、基本规则</h3><p>准则1：为ASM版本X编写ClassVisitor子类，以该确切版本作为参数调用ClassVisitor构造函数，并且永远不要覆盖或调用在此版本的ClassVisitor类中不推荐使用的方法（或在更高版本中引入的方法）。<h3 id=5-2-2、继承规则><a class=headerlink href=#5-2-2、继承规则 title=5.2.2、继承规则></a>5.2.2、继承规则</h3><p>准则2：不要使用访问者的继承，而应使用委派（即访问者链）。一种好的做法是，默认情况下将您的访问者班级定为最终班，以确保做到这一点。<p>实际上，该规则有两个例外：<ol><li>如果您自己完全控制继承链，并同时释放层次结构的所有类，则可以使用访问者的继承。然后，您必须确保为同一ASM版本编写层次结构中的所有类。尽管如此，将层次结构的叶类定为最终类。<li>如果除叶子类之外没有其他类重写任何访问方法，则可以使用“访问者”的继承（例如，如果您在ClassVisitor和具体访问者类之间使用中间类只是为了引入便捷方法）。仍然，使层次结构的叶类成为最终类（除非它们也不覆盖任何访问方法；在这种情况下，请提供一个构造器，以ASM版本作为参数，以便子类可以指定为其编写的版本）。</ol></div><footer class=post-footer><div class=post-tags><a href=/tags/ASM/ rel=tag># ASM</a></div><div class=post-nav><div class=post-nav-item><a href=/2024/08/21/Apache%20Dubbo%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/ rel=prev title=Dubbo系列-Dubbo基础应用> <i class="fa fa-angle-left"></i> Dubbo系列-Dubbo基础应用 </a></div><div class=post-nav-item><a href=/2024/08/21/Canal%E7%9B%91%E6%8E%A7MySQL/ rel=next title=Canal系列-Canal监听MySQL> Canal系列-Canal监听MySQL <i class="fa fa-angle-right"></i> </a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script>