<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hshz21.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="KafKa概述何为KafKaKafka是由Apache软件基金会开发的一个开源流处理平台，基于Scala和Java编写。 Apache Kafka是一个分布式发布 - 订阅消息系统和一个强大队列，可以处理大量数据，并使您能够将消息从一个端点传递到另一个端点。Kafka适合离线和在线消息消费。 Kafka消息保留在磁盘上，并在群集内复制以防止数据丢失。 Kafka构建在ZooKeeper同步服务之上" name=description><meta content=article property=og:type><meta content=Kafka系列-KafKa基础应用 property=og:title><meta content=https://hshz21.gitee.io/2024/08/21/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content="KafKa概述何为KafKaKafka是由Apache软件基金会开发的一个开源流处理平台，基于Scala和Java编写。 Apache Kafka是一个分布式发布 - 订阅消息系统和一个强大队列，可以处理大量数据，并使您能够将消息从一个端点传递到另一个端点。Kafka适合离线和在线消息消费。 Kafka消息保留在磁盘上，并在群集内复制以防止数据丢失。 Kafka构建在ZooKeeper同步服务之上" property=og:description><meta content=zh_CN property=og:locale><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20230807101619914.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-image-20210324153055048.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-image-20210324153535778.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-image-20210324153902808.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-image-20210324172846378.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-image-20210324173345094.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-image-20210324173658271.png property=og:image><meta content=2024-08-21T13:39:13.897Z property=article:published_time><meta content=2023-10-02T13:16:15.962Z property=article:modified_time><meta content=豪哥 property=article:author><meta content=KafKa property=article:tag><meta content=KafKa基础 property=article:tag><meta content=summary name=twitter:card><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20230807101619914.png name=twitter:image><link href=https://hshz21.gitee.io/2024/08/21/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hshz21.gitee.io/2024/08/21/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/","path":"2024/08/21/KafKa基础入门/","title":"Kafka系列-KafKa基础应用"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>Kafka系列-KafKa基础应用 | 豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>豪哥博客</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#KafKa%E6%A6%82%E8%BF%B0><span class=nav-number>1.</span> <span class=nav-text>KafKa概述</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BD%95%E4%B8%BAKafKa><span class=nav-number>1.1.</span> <span class=nav-text>何为KafKa</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF><span class=nav-number>1.2.</span> <span class=nav-text>使用场景</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5><span class=nav-number>1.3.</span> <span class=nav-text>重要概念</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#Broker%EF%BC%88%E5%AE%9E%E4%BE%8B%EF%BC%89><span class=nav-number>1.3.1.</span> <span class=nav-text>Broker（实例）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Topic%EF%BC%88%E4%B8%BB%E9%A2%98%EF%BC%89><span class=nav-number>1.3.2.</span> <span class=nav-text>Topic（主题）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Partition%EF%BC%88%E5%88%86%E5%8C%BA%EF%BC%89><span class=nav-number>1.3.3.</span> <span class=nav-text>Partition（分区）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Offset%EF%BC%88%E5%81%8F%E7%A7%BB%E9%87%8F%EF%BC%89><span class=nav-number>1.3.4.</span> <span class=nav-text>Offset（偏移量）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Producer%EF%BC%88%E7%94%9F%E4%BA%A7%E8%80%85%EF%BC%89><span class=nav-number>1.3.5.</span> <span class=nav-text>Producer（生产者）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Consumer%EF%BC%88%E6%B6%88%E8%B4%B9%E8%80%85%EF%BC%89><span class=nav-number>1.3.6.</span> <span class=nav-text>Consumer（消费者）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#Replication%EF%BC%88%E5%A4%8D%E5%88%B6%EF%BC%89><span class=nav-number>1.3.7.</span> <span class=nav-text>Replication（复制）</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%B0%8F%E7%BB%93><span class=nav-number>1.3.8.</span> <span class=nav-text>小结</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#KafKa%E7%89%B9%E7%82%B9><span class=nav-number>1.4.</span> <span class=nav-text>KafKa特点</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%B0%8F%E7%BB%93-1><span class=nav-number>1.5.</span> <span class=nav-text>小结</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#Kafka%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86><span class=nav-number>2.</span> <span class=nav-text>Kafka基本原理</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E5%88%86%E5%8C%BA><span class=nav-number>2.1.</span> <span class=nav-text>分布式和分区</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%89%AF%E6%9C%AC><span class=nav-number>2.2.</span> <span class=nav-text>副本</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%95%B4%E4%BD%93%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B><span class=nav-number>2.3.</span> <span class=nav-text>整体数据流程</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7%E8%BF%87%E7%A8%8B><span class=nav-number>2.3.1.</span> <span class=nav-text>数据生产过程</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E6%95%B0%E6%8D%AE%E6%B6%88%E8%B4%B9%E8%BF%87%E7%A8%8B><span class=nav-number>2.3.2.</span> <span class=nav-text>数据消费过程</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%81%E6%9C%BA%E5%88%B6><span class=nav-number>2.4.</span> <span class=nav-text>消息传送机制</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#Kafka%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B><span class=nav-number>3.</span> <span class=nav-text>Kafka工作流程</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%89%8D%E8%A8%80><span class=nav-number>3.1.</span> <span class=nav-text>前言</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B><span class=nav-number>3.2.</span> <span class=nav-text>发布订阅消息流程</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E9%98%9F%E5%88%97%E6%B6%88%E6%81%AF-%E7%94%A8%E6%88%B7%E7%BB%84%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81><span class=nav-number>3.3.</span> <span class=nav-text>队列消息/用户组的工作流</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#Zookeeper%E4%BD%9C%E7%94%A8><span class=nav-number>3.4.</span> <span class=nav-text>Zookeeper作用</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#Kafka%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C><span class=nav-number>4.</span> <span class=nav-text>Kafka基本操作</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%90%AF%E5%8A%A8ZooKeeper><span class=nav-number>4.1.</span> <span class=nav-text>启动ZooKeeper</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8D%95%E8%8A%82%E7%82%B9%E5%8D%95%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE><span class=nav-number>4.2.</span> <span class=nav-text>单节点单代理配置</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%88%9B%E5%BB%BA-Kafka-%E4%B8%BB%E9%A2%98><span class=nav-number>4.2.1.</span> <span class=nav-text>创建 Kafka 主题</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%B8%BB%E9%A2%98%E5%88%97%E8%A1%A8><span class=nav-number>4.2.2.</span> <span class=nav-text>主题列表</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%90%AF%E5%8A%A8%E7%94%9F%E4%BA%A7%E8%80%85%E5%B9%B6%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF><span class=nav-number>4.2.3.</span> <span class=nav-text>启动生产者并发送消息</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%90%AF%E5%8A%A8%E6%B6%88%E8%B4%B9%E8%80%85%E5%B9%B6%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF><span class=nav-number>4.2.4.</span> <span class=nav-text>启动消费者并接收消息</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E5%8D%95%E8%8A%82%E7%82%B9%E5%A4%9A%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE><span class=nav-number>4.3.</span> <span class=nav-text>单节点多代理配置</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AAKafka-Brokers><span class=nav-number>4.3.1.</span> <span class=nav-text>创建多个Kafka Brokers</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AA%E4%BB%A3%E7%90%86><span class=nav-number>4.3.2.</span> <span class=nav-text>启动多个代理</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%A2%98><span class=nav-number>4.3.3.</span> <span class=nav-text>创建主题</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%90%AF%E5%8A%A8%E7%94%9F%E4%BA%A7%E8%80%85%E4%BB%A5%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF><span class=nav-number>4.3.4.</span> <span class=nav-text>启动生产者以发送消息</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%90%AF%E5%8A%A8%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A5%E6%8E%A5%E6%94%B6%E6%B6%88%E6%81%AF><span class=nav-number>4.3.5.</span> <span class=nav-text>启动消费者以接收消息</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#%E4%B8%BB%E9%A2%98%E6%93%8D%E4%BD%9C><span class=nav-number>4.4.</span> <span class=nav-text>主题操作</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98><span class=nav-number>4.4.1.</span> <span class=nav-text>修改主题</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#%E5%88%A0%E9%99%A4%E4%B8%BB%E9%A2%98><span class=nav-number>4.4.2.</span> <span class=nav-text>删除主题</span></a></ol></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>116</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>35</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>128</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://hshz21.gitee.io/2024/08/21/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="Kafka系列-KafKa基础应用 | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>Kafka系列-KafKa基础应用</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 21:16:15" datetime=2023-10-02T21:16:15+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/KafKa/ itemprop=url rel=index><span itemprop=name>KafKa</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=KafKa概述><a class=headerlink href=#KafKa概述 title=KafKa概述></a>KafKa概述</h1><h2 id=何为KafKa><a class=headerlink href=#何为KafKa title=何为KafKa></a>何为KafKa</h2><p><strong>Kafka是由Apache软件基金会开发的一个开源流处理平台，基于Scala和Java编写。</strong><p>Apache Kafka是一个分布式发布 - 订阅消息系统和一个强大队列，可以处理大量数据，并使您能够将消息从一个端点传递到另一个端点。Kafka适合离线和在线消息消费。 Kafka消息保留在磁盘上，并在群集内复制以防止数据丢失。 Kafka构建在ZooKeeper同步服务之上。 它与Apache Storm和Spark可以很好地集成，可用于实时流式数据分析。<p>Kafka 是一个分布式消息队列，具有高性能、持久化、多副本备份、横向扩展等能力。生产者往队列里写消息，消费者从队列里取消息进行业务逻辑。一般在架构设计中起到解耦、削峰、异步处理的作用。<h2 id=使用场景><a class=headerlink href=#使用场景 title=使用场景></a>使用场景</h2><ul><li><font color=orange>指标</font>：Kafka通常用于操作监控数据。 这涉及聚合来自分布式应用程序的统计信息，以产生操作数据的集中馈送。<li><font color=orange>日志聚合解决方案</font>：Kafka可用于跨组织从多个服务收集日志，并使它们以标准格式提供给多个服务器。<li><font color=orange>流处理</font>：流行的框架(如Storm和Spark Streaming)从主题中读取数据，对其进行处理，并将处理后的数据写入新主题，供用户和应用程序使用。 Kafka的强耐久性在流处理的上下文中也非常有用。</ul><h2 id=重要概念><a class=headerlink href=#重要概念 title=重要概念></a>重要概念</h2><h3 id=Broker（实例）><a class=headerlink href=#Broker（实例） title=Broker（实例）></a>Broker（实例）</h3><p><strong>Kafka 集群有多个Server，每一个Server都可以存储消息，且每一个Server称为一个 kafka 实例，也叫做broker。</strong><p><strong>Producer和Consumer通过 TCP协议 与Kafka集群通信，Producer和Consumer可以看作是Kafka集群的客户端。</strong>Producer通过TCP协议发送消息到KafKa集群，KafKa集群再将这些消息提供给Consumer。如下图所示：<p><img alt=image-20230807101619914 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20230807101619914.png><h3 id=Topic（主题）><a class=headerlink href=#Topic（主题） title=Topic（主题）></a>Topic（主题）</h3><p>每个 topic 中保存同一类消息。每个 producer 发送消息至 kafka 时都需要指明要将消息存到哪个 topic 中，也就是将这个消息进行分类。<h3 id=Partition（分区）><a class=headerlink href=#Partition（分区） title=Partition（分区）></a>Partition（分区）</h3><p>每个 topic 都可以分多个 partition，每个 partition 在存储层面是【append log 文件】。任何发布到此 partition 的消息都会被直接追加到 log 文件尾部。<p><img alt=image-20210324153055048 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-image-20210324153055048.png><p>为何需要分区？根本原因就是：kafka基于文件进行存储，当文件内容大到一定程度时，很容易达到单个磁盘的上限，因此，采用分区法，一个分区对应一个文件，这样就可以将数据分别存储到不同的server上去，另外这样做也可以负载均衡，容纳更多的消费者。<p>Kafka将topic划分为多个partition进行存储 有两个好处：<ul><li><p><font color=orange>消息存储扩容</font></p> <p>一个文件其存储容量有限，但集群中的多个文件存储就可以大大增加一个topic能够保存的消息数量。</p><li><p><font color=orange>并行读写</font></p> <p>通过多个partition文件存储消息，意味着 producer 和 consumer 可以并行读写一个topic。</p></ul><h3 id=Offset（偏移量）><a class=headerlink href=#Offset（偏移量） title=Offset（偏移量）></a>Offset（偏移量）</h3><p><strong>一个分区对应一个磁盘上的文件，而消息在文件中的位置就称为 offset（偏移量），offset 是一个 long 型数字，它可以唯一标记一条消息。</strong>由于kafka 并没有提供其他额外的索引机制来存储 offset，文件只能顺序的读写，所以在kafka中几乎不允许对消息进行“随机读写”。<h3 id=Producer（生产者）><a class=headerlink href=#Producer（生产者） title=Producer（生产者）></a>Producer（生产者）</h3><p>消息发送者。<strong>将消息发送到topic的进程叫做Producer。</strong><p>Producer负责将消息发送到Kafka集群的某一个topic中。Producer发送消息时可以指定partition号，故可以将消息持久化到特定partition中。<p>如果没有指定partition号，那么Kafka Producer可以通过 特定算法 计算出partition号。具体算法如下：<ul><li>如果 待发送的消息 指定了key，则 <font color=orange>【hash key】来映射到对应partition号。</font><li>如果 待发送的消息 没有指定key，则 <font color=orange>通过【Round Robin轮询算法】确定partition号。</font>这样可保证数据在所有的partition上平均分配。<li>Kafka Producer也 <font color=orange>支持自定义partition分配方式。</font>客户端提供一个<code>org.apache.kafka.clients.producer.Partitioner</code>实现类，然后 将此实现类 配置到Producer中即可。</ul><h3 id=Consumer（消费者）><a class=headerlink href=#Consumer（消费者） title=Consumer（消费者）></a>Consumer（消费者）</h3><p>消息消费者。<font color=orange>将订阅topic，获取消息的进程叫做Consumer。Kafka中的Consumer采用【poll模型】。</font><p><font color=orange>Consumer通过移动 offset 顺序来读取消息。offset由Consumer维护。</font>Kafka集群只负责根据Consumer传入的offset来返回对应消息。<p>Kafka 0.9前，offset信息保存在zookeeper <code>[consumers/{group}/offsets/{topic}/{partition}]</code> 目录中。而0.9之后，所有offset信息都保存在Broker上的一个名为<code>__consumer_offsets</code> 的 topic 中。<p>如下图所示：<p><img alt=image-20210324153535778 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-image-20210324153535778.png><p><strong>Kafka不会立刻删除已经被消费的消息，而会根据broker中的配置来决定多久清理一次。</strong>当broker中配置的时间到达时，不论消息是否被消费，Kafka都会清理磁盘空间。<p>传统的消息队列提供两种消息消费模式：<ul><li>队列模式：一条消息只能被多个消费者中的一个消费。<li>发布订阅模式：一条消息能够被多个消费者同时消费。</ul><p><strong>Kafka为了支持这两种消费模型，提出了 消费者组（consumer group）概念。</strong>如下图所示：<p><img alt=image-20210324153902808 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-image-20210324153902808.png><p>如图，每一个消费者不再是一个简单的订阅了某个topic的个体，多个消费者被放在了一个消费者组中。每一个消费者必须属于一个消费者组，同时一个消费者组能够拥有多个消费者。对于一个消费者组，Kafka拥有以下约束：<ul><li>一条消息只能被一个消费者组中的一个消费者消费。<li>同一个partition中的消息只能被某个消费者组中的某个固定消费者消费。</ul><p>如上图所示，在一个消费者组中，一旦某个partition被分配给了某个消费者，那么该partition就不会再分配给任何其它的同组消费者。因此如果一个consumer group中消费者数量超过了partition数量，那么一定会有多余的消费者永远收不到消息。<p>最后，KafKa只能够保证消费一个分区内的消费是有序的。无法保证一个topic下（拥有多个分区）所有消息的消费都是有序的。<h3 id=Replication（复制）><a class=headerlink href=#Replication（复制） title=Replication（复制）></a>Replication（复制）</h3><p><strong>一个topic的多个partition被分在Kafka集群的多个broker上。</strong>每个broker负责partition中消息的读写操作。此外，Kafka还支持为每个partition设置需要备份（replicas）的个数，所有的备份partition分布在Kafka集群中，以提高可用性。<p>既然Kafka支持replication，那么就意味着需要对多个备份进行调度。每个partition 都有一个机器被称为”leader”，同时零个或多个机器作为follower。leader 负责所有读写操作，follower执行leader指令。如果 leader 失效，那么将会有其他follower 来接管进而晋升为新leader。follower只是单调的和leader 跟进同步消息即可。因此，所有发送到Kafka集群的读写请求本质上均是针对leader的操作，leader操作完成后，发送指令给follower进行数据同步，从而实现了高可用性。<h3 id=小结><a class=headerlink href=#小结 title=小结></a>小结</h3><ul><li>kafka 是一个基于发布-订阅的分布式消息系统（消息队列）<li>Kafka 面向大数据，消息保存在主题中，而每个 topic 有分为多个分区<li>kafak 的消息数据保存在磁盘，每个 partition 对应磁盘上的一个文件，消息写入就是简单的文件追加，文件可以在集群内复制备份以防丢失<li>即使消息被消费，kafka 也不会立即删除该消息，可以通过配置使得过一段时间后自动删除以释放磁盘空间<li>kafka依赖分布式协调服务Zookeeper，适合离线/在线信息的消费，与 storm 和 spark 等实时流式数据分析常常结合使用</ul><h2 id=KafKa特点><a class=headerlink href=#KafKa特点 title=KafKa特点></a>KafKa特点</h2><ul><li><font color=orange>可靠</font>：Kafka是分布式，分区，复制和容错的。<li><font color=orange>可扩展</font>：Kafka消息传递系统轻松缩放，无需停机。<li><font color=orange>耐用</font>：Kafka使用分布式提交日志，这意味着消息会尽可能快地保留在磁盘上，因此它是持久的。<li><font color=orange>高性能</font>：Kafka对于发布和订阅消息都具有高吞吐量。 即使存储了许多TB的消息，它也保持稳定的性能。</ul><p>Kafka非常快，并可保证零停机和零数据丢失。<h2 id=小结-1><a class=headerlink href=#小结-1 title=小结></a>小结</h2><p>Kafka是一个统一平台，用于处理所有的实时数据Feed。 Kafka支持低延迟消息传递，并在出现机器故障时提供容错保证。 Kafka非常快，执行2百万写/秒。 Kafka将所有数据保存到磁盘，这实质上意味着所有写入都会进入操作系统(RAM)的页面缓存。 这使得将数据从页面缓存传输到网络套接字非常有效。<h1 id=Kafka基本原理><a class=headerlink href=#Kafka基本原理 title=Kafka基本原理></a>Kafka基本原理</h1><h2 id=分布式和分区><a class=headerlink href=#分布式和分区 title=分布式和分区></a>分布式和分区</h2><p>kafka 是一个分布式消息系统。消息保存在 Topic 中，可实现大量数据存储，一个 topic 有多个分区，每个分区对应一个文件，分别存储到不同机器上，实现分布式集群存储。每个 partition 可以有副本，备份到多台机器上可提高可用性。<p>总结就是：一个 topic 对应的多个 partition 分散存储到集群中的多个 broker 上，存储方式是一个 partition 对应一个文件，每个 broker 负责存储在自己机器上的 partition 中的消息读写。<h2 id=副本><a class=headerlink href=#副本 title=副本></a>副本</h2><p><strong>每个 partition 将会被备份到多台机器上以提高可用性，备份的数量可以通过配置文件指定。</strong><p>冗余备份方式 在分布式系统中 很常见，对于 同一文件的多个备份进行管理和调度，其kafka做法是：每个 partition 选举一个 server 作为“leader”，由 leader 负责所有对该分区的读写，其他 server 作为 follower 只需要简单与 leader 同步，保持跟进即可。如果 原 leader 失效，会重新 从其它follower中 挑选一个晋升为新leader。<p>Kafka 通过 ZK 来在 Broker 中选出一个 Controller，用于 Partition分配 和 Leader选举。<p><strong>leader级别的server 承担了 该分区所有读写请求，压力较大，从整体考虑，有多少个 partition 就意味着会有多少个leader，kafka 会将 leader 分散到不同 broker 上，确保整体负载均衡。</strong><h2 id=整体数据流程><a class=headerlink href=#整体数据流程 title=整体数据流程></a>整体数据流程</h2><p>Kafka 的总体数据流满足下图，该图可以说是概括了整个 kafka 的基本原理。<p><img alt=image-20210324172846378 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-image-20210324172846378.png><h3 id=数据生产过程><a class=headerlink href=#数据生产过程 title=数据生产过程></a>数据生产过程</h3><p><strong>对于 生产者 要写入一条记录，可以指定四个参数：topic、partition、key 和 value，其中 topic 和 value 是必须的，而 key 和 partition 是可选的。</strong><p><strong>对于一条记录，会先对其进行序列化，然后按照 Topic 和 Partition放进对应的发送队列中。</strong>如果 Partition 没填，那么会是如下情况：<ol><li>Key 有填，通过对 Key 进行哈希，相同 Key 去一个 Partition。<li>Key 没填，通过 Round-Robin 来选 Partition。</ol><p><img alt=image-20210324173345094 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-image-20210324173345094.png><p>producer 将会和Topic下所有 partition leader 保持 socket 连接，消息由 producer 直接通过 socket 发送到 broker。其中 partition leader 的位置( host : port )注册在 zookeeper 中，producer 作为 zookeeper client，已经注册了 watch 用来监听 partition leader 的变更事件，因此，可以准确的知道谁是当前的 leader。<p>producer 端采用异步发送：将多条消息暂且在客户端 buffer 起来，并将他们批量的发送到 broker，小数据 IO 太多，会拖慢整体的网络延迟，批量延迟发送事实上提升了网络效率。<h3 id=数据消费过程><a class=headerlink href=#数据消费过程 title=数据消费过程></a>数据消费过程</h3><p>对于消费者，不是以单独的形式存在的，每一个消费者属于一个 consumer group，一个 group 包含多个 consumer。特别需要注意的是：订阅 Topic 是以一个消费组来订阅的，发送到 Topic 的消息，只会被订阅此 Topic 的每个 group 中的一个 consumer 消费。<p>如果所有的 Consumer 都具有相同的 group，那么就像是一个点对点的消息系统；如果每个 consumer 都具有不同的 group，那么消息会广播给所有的消费者。<p>具体说来，这实际上是根据 partition 来分的，一个 Partition，只能被消费组里的一个消费者消费，但是可以同时被多个消费组消费，消费组里的每个消费者是关联到一个 partition 的，因此有这样的说法：对于一个 topic，同一个 group 中不能有多于 partitions 个数的 consumer 同时消费，否则将意味着某些 consumer 将无法得到消息。<p>同一个消费组的两个消费者不会同时消费一个 partition。<p><img alt=image-20210324173658271 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-image-20210324173658271.png><p>在 kafka 中，采用了 pull 方式，即 consumer 在和 broker 建立连接之后，主动去 pull(或者说 fetch )消息，首先 consumer 端可以根据自己的消费能力适时的去 fetch 消息并处理，且可以控制消息消费的进度(offset)。<p>partition 中的消息只有一个 consumer 在消费，且不存在消息状态的控制，也没有复杂的消息确认机制，可见 kafka broker 端是相当轻量级的。当消息被 consumer 接收之后，需要保存 Offset 记录消费到哪，以前保存在 ZK 中，由于 ZK 的写性能不好，以前的解决方法都是 Consumer 每隔一分钟上报一次，在 0.10 版本后，Kafka 把这个 Offset 的保存，从 ZK 中剥离，保存在一个名叫 consumeroffsets topic 的 Topic 中，由此可见，consumer 客户端也很轻量级。<h2 id=消息传送机制><a class=headerlink href=#消息传送机制 title=消息传送机制></a>消息传送机制</h2><p><font color=orange>Kafka 支持 3 种 消息投递语义，通常会使用 At least once 模型：</font><ul><li>At most once：最多一次，消息可能会丢失，但不会重复。<li>At least once：最少一次，消息不会丢失，可能会重复。<li>Exactly once：只有一次，消息不丢失不重复，且只消费一次。</ul><h1 id=Kafka工作流程><a class=headerlink href=#Kafka工作流程 title=Kafka工作流程></a>Kafka工作流程</h1><h2 id=前言><a class=headerlink href=#前言 title=前言></a>前言</h2><p><strong>Kafka 以快速，可靠，持久，容错和零停机 的优点 提供 基于pub-sub 和队列的消息系统。 在这两种情况下，生产者只需将消息发送到主题，消费者可以根据自己的需要选择任何一种类型的消息传递系统。</strong><h2 id=发布订阅消息流程><a class=headerlink href=#发布订阅消息流程 title=发布订阅消息流程></a>发布订阅消息流程</h2><p>以下是 Pub-Sub 消息工作流程：<ul><li>生产者定期向主题发送消息。<li>如果生产者发送两个消息并且有两个分区，Kafka 将在第一分区中存储一个消息，在第二分区中存储第二消息。（Kafka 代理存储特定主题分区中的所有消息，它确保消息在分区之间平等共享。）<li>消费者订阅特定主题，然后Kafka会返回主题当前偏移给消费者，且将偏移保存在 Zookeeper 中。<li>消费者 定期请求 Kafka (如100 Ms)新消息。Kafka 收到 生产者消息 时 会 立即转发消息给消费者。<li>消费者消费消息 后 将向 Kafka 代理发送确认。Kafka 收到确认后 会将 偏移 更改为新值。因 Zookeeper 中维护着偏移，故 消费者可以 正确读取 下一封邮件。<li>以上流程将重复，直到消费者停止请求。<li>消费者可以随时回退/跳到所需的主题偏移量，并阅读所有后续消息。</ul><h2 id=队列消息-用户组的工作流><a class=headerlink href=#队列消息-用户组的工作流 title=队列消息/用户组的工作流></a>队列消息/用户组的工作流</h2><p>在队列消息传递系统而不是单个消费者中，具有相同组 ID 的一组消费者将订阅主题。 简单来说，订阅具有相同 Group ID 的主题的消费者被认为是单个组，并且消息在它们之间共享。 让我们检查这个系统的实际工作流程。<ul><li>生产者以固定间隔向某个主题发送消息。<li>Kafka存储在为该特定主题配置的分区中的所有消息，类似于前面的方案。<li>单个消费者订阅特定主题，假设 Topic-01 为 Group ID 为 Group-1 。<li>Kafka 以与发布 - 订阅消息相同的方式与消费者交互，直到新消费者以相同的组 ID 订阅相同主题Topic-01 1 。<li>一旦新消费者到达，Kafka 将其操作切换到共享模式，并在两个消费者之间共享数据。 此共享将继续，直到用户数达到为该特定主题配置的分区数。<li>一旦消费者的数量超过分区的数量，新消费者将不会接收任何进一步的消息，直到现有消费者取消订阅任何一个消费者。 出现这种情况是因为 Kafka 中的每个消费者将被分配至少一个分区，并且一旦所有分区被分配给现有消费者，新消费者将必须等待。<li>此功能也称为使用者组。 同样，Kafka 将以非常简单和高效的方式提供两个系统中最好的。</ul><h2 id=Zookeeper作用><a class=headerlink href=#Zookeeper作用 title=Zookeeper作用></a>Zookeeper作用</h2><p>Apache Kafka 的一个关键依赖是 Apache Zookeeper，它是一个分布式配置和同步服务。Zookeeper 是 Kafka 代理和消费者之间的协调接口。Kafka 服务器通过 Zookeeper 集群共享信息。Kafka 在 Zookeeper 中存储基本元数据，例如关于主题，代理，消费者偏移(队列读取器)等的信息。<p>由于所有关键信息存储在 Zookeeper 中，并且它通常在其整体上复制此数据，因此Kafka代理/ Zookeeper 的故障不会影响 Kafka 集群的状态。Kafka 将恢复状态，一旦 Zookeeper 重新启动。 这为Kafka带来了零停机时间。Kafka 代理之间的领导者选举也通过使用 Zookeeper 在领导者失败的情况下完成。<h1 id=Kafka基本操作><a class=headerlink href=#Kafka基本操作 title=Kafka基本操作></a>Kafka基本操作</h1><h2 id=启动ZooKeeper><a class=headerlink href=#启动ZooKeeper title=启动ZooKeeper></a>启动ZooKeeper</h2><p>打开一个新终端并键入以下命令<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>bin/zookeeper-server-start.sh config/zookeeper.properties</span><br></pre></table></figure><p>要启动 <code>Kafka Broker</code>，请键入以下命令<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>bin/kafka-server-start.sh config/server.properties</span><br></pre></table></figure><p>启动 <code>Kafka Broker</code>后，在 ZooKeeper 终端上键入命令 <code>jps</code> ，您将看到以下响应 -<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>821 QuorumPeerMain</span><br><span class=line>928 Kafka</span><br><span class=line>931 Jps</span><br></pre></table></figure><p>其中，<code>QuorumPeerMain</code> 是 ZooKeeper 守护进程，另一个是 Kafka 守护进程。<h2 id=单节点单代理配置><a class=headerlink href=#单节点单代理配置 title=单节点单代理配置></a>单节点单代理配置</h2><p>在此配置中，您有一个 ZooKeeper 和代理 id 实例。 以下是配置它的步骤 ：<h3 id=创建-Kafka-主题><a title="创建 Kafka 主题" class=headerlink href=#创建-Kafka-主题></a>创建 Kafka 主题</h3><p><code>Kafka</code> 提供了一个名为 <code>kafka-topics.sh</code> 的命令行实用程序，用于在服务器上创建主题。 打开新终端并键入以下示例。<p><strong>语法</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 </span><br><span class=line>--partitions 1 --topic topic-name</span><br></pre></table></figure><p><strong>示例</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1   </span><br><span class=line>--partitions 1 --topic Hello-Kafka</span><br></pre></table></figure><p>以上命令创建了一个名为 <code>Hello-Kafka</code> 的主题，其中包含一个分区和一个副本因子。<p>创建主题后可以在 <code>Kafka</code> 代理终端窗口中获取通知，并在 <code>config / server.properties</code> 文件中的<code>“/tmp/kafka-logs/"</code>中指定 创建的主题日志。<h3 id=主题列表><a class=headerlink href=#主题列表 title=主题列表></a>主题列表</h3><p>要获取<code>Kafka</code>服务器中的主题列表，可以使用以下命令<p><strong>语法</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>bin/kafka-topics.sh --list --zookeeper localhost:2181</span><br></pre></table></figure><p><strong>输出</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>Hello-Kafka</span><br></pre></table></figure><p>由于我们已经创建了一个主题，它将仅列出 <code>Hello-Kafka</code> 。<h3 id=启动生产者并发送消息><a class=headerlink href=#启动生产者并发送消息 title=启动生产者并发送消息></a>启动生产者并发送消息</h3><p><strong>语法</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic topic-name</span><br></pre></table></figure><p>从上面的语法，生产者命令行客户端需要两个主要参数 -<ul><li><font color=orange>代理列表</font>：我们要发送邮件的代理列表。 在这种情况下，我们只有一个代理。 <code>Config / server.properties</code> 文件包含代理端口 ID，因为我们知道我们的代理正在侦听端口 9092，因此您可以直接指定它。<li><font color=orange>主题名称</font>：以下是主题名称的示例。</ul><p><strong>示例</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic Hello-Kafka</span><br></pre></table></figure><p>生产者将等待来自 <code>stdin</code> 的输入并发布到 <code>Kafka</code> 集群。 默认情况下，每个新行都作为新消息发布，然后在<code> config / producer.properties</code> 文件中指定默认生产者属性。 现在，您可以在终端中键入几行消息，如下所示。<p><strong>输出</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>$ bin/kafka-console-producer.sh --broker-list localhost:9092 --topic Hello-Kafka</span><br><span class=line>[2016-01-16 13:50:45,931] </span><br><span class=line>WARN property topic is not valid (kafka.utils.Verifia-bleProperties)</span><br><span class=line>Hello</span><br><span class=line>My first message</span><br><span class=line>My second message</span><br></pre></table></figure><h3 id=启动消费者并接收消息><a class=headerlink href=#启动消费者并接收消息 title=启动消费者并接收消息></a>启动消费者并接收消息</h3><p>与生产者类似，在<code>config / consumer.proper-ties</code> 文件中指定了缺省使用者属性。 打开一个新终端并键入以下消息消息语法。<p><strong>语法</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>bin/kafka-console-consumer.sh --zookeeper localhost:2181 —topic topic-name </span><br><span class=line>--from-beginning</span><br></pre></table></figure><p><strong>示例</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>bin/kafka-console-consumer.sh --zookeeper localhost:2181 —topic Hello-Kafka </span><br><span class=line>--from-beginning</span><br></pre></table></figure><p><strong>输出</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>Hello</span><br><span class=line>My first message</span><br><span class=line>My second message</span><br></pre></table></figure><p>最后，可以在生产者终端中输入消息，这些消息会出现在消费者的终端。<h2 id=单节点多代理配置><a class=headerlink href=#单节点多代理配置 title=单节点多代理配置></a>单节点多代理配置</h2><p>在进入多个代理集群设置之前，首先启动 ZooKeeper 服务器。<h3 id=创建多个Kafka-Brokers><a title="创建多个Kafka Brokers" class=headerlink href=#创建多个Kafka-Brokers></a>创建多个Kafka Brokers</h3><p>我们在配置<code>/ server.properties</code> 中已有一个 <code>Kafka</code> 代理实例。 现在我们需要多个代理实例，因此将现有的 <code>server.properties</code> 文件复制到两个新的配置文件中，并将其重命名为 <code>server-one.properties</code> 和 <code>server-two.properties</code>。并编辑文件填充如下内容：<p>config / server-one.properties<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment># The id of the broker. This must be set to a unique integer for each broker.</span></span><br><span class=line><span class=attr>broker.id</span>=<span class=string>1</span></span><br><span class=line><span class=comment># The port the socket server listens on</span></span><br><span class=line><span class=attr>port</span>=<span class=string>9093</span></span><br><span class=line><span class=comment># A comma seperated list of directories under which to store log files</span></span><br><span class=line><span class=attr>log.dirs</span>=<span class=string>/tmp/kafka-logs-1</span></span><br></pre></table></figure><p>config / server-two.properties<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment># The id of the broker. This must be set to a unique integer for each broker.</span></span><br><span class=line><span class=attr>broker.id</span>=<span class=string>2</span></span><br><span class=line><span class=comment># The port the socket server listens on</span></span><br><span class=line><span class=attr>port</span>=<span class=string>9094</span></span><br><span class=line><span class=comment># A comma seperated list of directories under which to store log files</span></span><br><span class=line><span class=attr>log.dirs</span>=<span class=string>/tmp/kafka-logs-2</span></span><br></pre></table></figure><h3 id=启动多个代理><a class=headerlink href=#启动多个代理 title=启动多个代理></a>启动多个代理</h3><p>在三台服务器上进行所有更改后，打开三个新终端，逐个启动每个代理。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>Broker1：</span><br><span class=line>bin/kafka-server-start.sh config/server.properties</span><br><span class=line>Broker2：</span><br><span class=line>bin/kafka-server-start.sh config/server-one.properties</span><br><span class=line>Broker3：</span><br><span class=line>bin/kafka-server-start.sh config/server-two.properties</span><br></pre></table></figure><p>通过在 ZooKeeper 终端上键入 <strong><code>jps</code></strong> 检查所有守护程序，然后您将看到响应。<h3 id=创建主题><a class=headerlink href=#创建主题 title=创建主题></a>创建主题</h3><p>让我们为此主题将复制因子值指定为三个，因为我们有三个不同的代理运行。 如果您有两个代理，那么分配的副本值将是两个。<p>示例如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>bin/kafka-topics.sh </span><br><span class=line>--create </span><br><span class=line>--zookeeper localhost:2181 </span><br><span class=line>--replication-factor 3 </span><br><span class=line>-partitions 1 </span><br><span class=line>--topic Multibrokerapplication</span><br></pre></table></figure><p>Describe 命令用于检查哪个代理正在侦听当前创建的主题，示例如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>bin/kafka-topics.sh </span><br><span class=line>--describe </span><br><span class=line>--zookeeper localhost:2181 </span><br><span class=line>--topic Multibrokerappli-cation</span><br></pre></table></figure><p><strong>输出</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line>bin/kafka-topics.sh </span><br><span class=line>--describe </span><br><span class=line>--zookeeper localhost:2181 </span><br><span class=line>--topic Multibrokerappli-cation</span><br><span class=line></span><br><span class=line>Topic:Multibrokerapplication    PartitionCount:1 </span><br><span class=line>ReplicationFactor:3 Configs:</span><br><span class=line>   </span><br><span class=line>Topic:Multibrokerapplication Partition:0 Leader:0 </span><br><span class=line>Replicas:0,2,1 Isr:0,2,1</span><br></pre></table></figure><p>从上面的输出，我们可以得出结论，第一行给出所有分区的摘要，显示主题名称，分区数量和我们已经选择的复制因子。 在第二行中，每个节点将是分区的随机选择部分的领导者。<p>在我们的例子中，我们看到我们的第一个 <code>broker(with broker.id 0)</code>是领导者。 然后 <code>Replicas:0,2,1</code> 意味着所有代理复制主题最后 <code>Isr</code> 是 <code>in-sync</code> 副本的集合。 那么，这是副本的子集，当前活着并被领导者赶上。<h3 id=启动生产者以发送消息><a class=headerlink href=#启动生产者以发送消息 title=启动生产者以发送消息></a>启动生产者以发送消息</h3><p>此过程保持与单代理设置中相同。<p>示例：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>bin/kafka-console-producer.sh --broker-list localhost:9092 </span><br><span class=line>--topic Multibrokerapplication</span><br></pre></table></figure><p>输出：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic Multibrokerapplication</span><br><span class=line>[2016-01-20 19:27:21,045] WARN Property topic is not valid (kafka.utils.Verifia-bleProperties)</span><br><span class=line>This is single node-multi broker demo</span><br><span class=line>This is the second message</span><br></pre></table></figure><h3 id=启动消费者以接收消息><a class=headerlink href=#启动消费者以接收消息 title=启动消费者以接收消息></a>启动消费者以接收消息</h3><p>此过程保持与单代理设置中所示的相同。<p>示例：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>bin/kafka-console-consumer.sh </span><br><span class=line>--zookeeper localhost:2181 </span><br><span class=line>—topic Multibrokerapplica-tion </span><br><span class=line>--from-beginning</span><br></pre></table></figure><p>输出：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>bin/kafka-console-consumer.sh </span><br><span class=line>--zookeeper localhost:2181 </span><br><span class=line>—topic Multibrokerapplica-tion —from-beginning</span><br><span class=line>This is single node-multi broker demo</span><br><span class=line>This is the second message</span><br></pre></table></figure><h2 id=主题操作><a class=headerlink href=#主题操作 title=主题操作></a>主题操作</h2><h3 id=修改主题><a class=headerlink href=#修改主题 title=修改主题></a>修改主题</h3><p>语法：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>bin/kafka-topics.sh </span><br><span class=line>—zookeeper localhost:2181 </span><br><span class=line>--alter </span><br><span class=line>--topic topic_name </span><br><span class=line>--parti-tions count</span><br></pre></table></figure><p>示例：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>We have already created a topic “Hello-Kafka<span class=string>" with single partition count and one replica factor. </span></span><br><span class=line><span class=string>Now using “alter"</span> <span class=built_in>command</span> we have changed the partition count.</span><br><span class=line>bin/kafka-topics.sh </span><br><span class=line>--zookeeper localhost:2181 </span><br><span class=line>--alter </span><br><span class=line>--topic Hello-kafka </span><br><span class=line>--parti-tions 2</span><br></pre></table></figure><p>输出：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>WARNING: If partitions are increased <span class=keyword>for</span> a topic that has a key, </span><br><span class=line>the partition logic or ordering of the messages will be affected</span><br><span class=line>Adding partitions succeeded!</span><br></pre></table></figure><h3 id=删除主题><a class=headerlink href=#删除主题 title=删除主题></a>删除主题</h3><p>语法：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>bin/kafka-topics.sh </span><br><span class=line>--zookeeper localhost:2181 </span><br><span class=line>--delete </span><br><span class=line>--topic topic_name</span><br></pre></table></figure><p>示例：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>bin/kafka-topics.sh </span><br><span class=line>--zookeeper localhost:2181</span><br><span class=line>--delete </span><br><span class=line>--topic Hello-kafka</span><br></pre></table></figure><p>输出：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>> Topic Hello-kafka marked <span class=keyword>for</span> deletion</span><br></pre></table></figure><p>**注意 **：如果 <code>delete.topic.enable</code>未设置为 <code>true</code>，则此操作不会产生任何影响。</div><footer class=post-footer><div class=post-tags><a href=/tags/KafKa/ rel=tag># KafKa</a><a href=/tags/KafKa%E5%9F%BA%E7%A1%80/ rel=tag># KafKa基础</a></div><div class=post-nav><div class=post-nav-item><a href=/2024/08/21/KafKa%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ rel=prev title=Kafka系列-KafKa原理解析> <i class="fa fa-angle-left"></i> Kafka系列-KafKa原理解析 </a></div><div class=post-nav-item><a href=/2024/08/21/Linux%E5%9F%BA%E7%A1%80%E7%AF%87/ rel=next title=Linux系列-Linux基础篇> Linux系列-Linux基础篇 <i class="fa fa-angle-right"></i> </a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script>