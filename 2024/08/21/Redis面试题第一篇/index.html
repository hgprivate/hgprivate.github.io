<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hgprivate.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="1、基础摸底1.1、何为RedisRedis 是 NoSQL 数据库，也即非关系型数据库。。 1.2、NoSQL BASE理论BASE理论是对CAP中一致性的妥协。与 传统事务ACID 不同，BASE不追求强一致性，只要最终达到一致就行。  CAP是三个单词的首字母，其代表的意思如下：  C：一致性 A：可用性 P：分区容错性  BASE是Basically Available（基本可用）、Sof" name=description><meta content=article property=og:type><meta content=Redis系列-Redis模拟面试题第一篇 property=og:title><meta content=https://hgprivate.github.io/2024/08/21/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content="1、基础摸底1.1、何为RedisRedis 是 NoSQL 数据库，也即非关系型数据库。。 1.2、NoSQL BASE理论BASE理论是对CAP中一致性的妥协。与 传统事务ACID 不同，BASE不追求强一致性，只要最终达到一致就行。  CAP是三个单词的首字母，其代表的意思如下：  C：一致性 A：可用性 P：分区容错性  BASE是Basically Available（基本可用）、Sof" property=og:description><meta content=zh_CN property=og:locale><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629223912586.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629224144667.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629224615221.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629224859742.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629230205745.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629230331075.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629230456394.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629230808740.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629231059635.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629231239734.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629231531238.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629231746172.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629232059868.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629232345450.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023%2F08%2F07%2FRedis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629233454825.png property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023%2F08%2F07%2FRedis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629234221317.png property=og:image><meta content=2024-08-21T13:39:14.519Z property=article:published_time><meta content=2023-08-07T01:59:37.709Z property=article:modified_time><meta content=豪哥 property=article:author><meta content=Redis面试 property=article:tag><meta content=summary name=twitter:card><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629223912586.png name=twitter:image><link href=https://hgprivate.github.io/2024/08/21/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hgprivate.github.io/2024/08/21/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87/","path":"2024/08/21/Redis面试题第一篇/","title":"Redis系列-Redis模拟面试题第一篇"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>Redis系列-Redis模拟面试题第一篇 | 豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>豪哥博客</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#1%E3%80%81%E5%9F%BA%E7%A1%80%E6%91%B8%E5%BA%95><span class=nav-number>1.</span> <span class=nav-text>1、基础摸底</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81%E4%BD%95%E4%B8%BARedis><span class=nav-number>1.1.</span> <span class=nav-text>1.1、何为Redis</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-2%E3%80%81NoSQL-BASE%E7%90%86%E8%AE%BA><span class=nav-number>1.2.</span> <span class=nav-text>1.2、NoSQL BASE理论</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-3%E3%80%81Redis%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4><span class=nav-number>1.3.</span> <span class=nav-text>1.3、Redis常用命令</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-4%E3%80%81Redis-key%E6%B8%85%E9%99%A4%E7%AD%96%E7%95%A5><span class=nav-number>1.4.</span> <span class=nav-text>1.4、Redis key清除策略</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-5%E3%80%81%E8%BF%87%E6%9C%9F%E9%94%AE%E6%B2%A1%E6%9C%89%E8%A2%AB%E8%AE%BF%E9%97%AE%EF%BC%8C%E4%B8%94%E5%88%A0%E9%99%A4%E5%8F%88%E8%B7%9F%E4%B8%8D%E4%B8%8A%E6%96%B0%E9%94%AE%E9%80%9F%E5%BA%A6%EF%BC%8C%E5%86%85%E5%AD%98%E4%BC%9A%E8%80%97%E5%B0%BD%E5%90%97%EF%BC%9F><span class=nav-number>1.5.</span> <span class=nav-text>1.5、过期键没有被访问，且删除又跟不上新键速度，内存会耗尽吗？</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-6%E3%80%81%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%94%A8%E5%88%B0%E7%9A%84%E6%98%AFLRU%E7%AE%97%E6%B3%95%E5%90%97%EF%BC%9F><span class=nav-number>1.6.</span> <span class=nav-text>1.6、内存淘汰用到的是LRU算法吗？</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#2%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84><span class=nav-number>2.</span> <span class=nav-text>2、数据结构</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#2-1%E3%80%81Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84><span class=nav-number>2.1.</span> <span class=nav-text>2.1、Redis数据结构</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-2%E3%80%81Redis%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%89%B9%E7%82%B9><span class=nav-number>2.2.</span> <span class=nav-text>2.2、Redis字符串特点</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-3%E3%80%81Hash%E6%89%A9%E5%AE%B9><span class=nav-number>2.3.</span> <span class=nav-text>2.3、Hash扩容</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-4%E3%80%81Rehash%E8%BF%87%E7%A8%8B><span class=nav-number>2.4.</span> <span class=nav-text>2.4、Rehash过程</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-5%E3%80%81rehash%E6%97%B6%E6%9C%89%E8%AF%B7%E6%B1%82%E8%BF%87%E6%9D%A5%EF%BC%8Credis%E4%BC%9A%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F><span class=nav-number>2.5.</span> <span class=nav-text>2.5、rehash时有请求过来，redis会如何处理？</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-6%E3%80%81%E8%B7%B3%E8%A1%A8><span class=nav-number>2.6.</span> <span class=nav-text>2.6、跳表</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-7%E3%80%81%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E5%A4%9A%E5%B0%91%E5%B1%82%EF%BC%9F><span class=nav-number>2.7.</span> <span class=nav-text>2.7、每个节点多少层？</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-8%E3%80%81Zset%E4%B8%BA%E4%BD%95%E9%9C%80%E8%A6%81%E5%AD%97%E5%85%B8%E5%92%8C%E8%B7%B3%E8%A1%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%EF%BC%9F><span class=nav-number>2.8.</span> <span class=nav-text>2.8、Zset为何需要字典和跳表来实现？</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#3%E3%80%81%E7%B3%BB%E7%BB%9F%E5%AE%B9%E7%81%BE><span class=nav-number>3.</span> <span class=nav-text>3、系统容灾</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#3-1%E3%80%81Redis%E6%9C%8D%E5%8A%A1%E9%87%8D%E5%90%AF%EF%BC%8C%E6%95%B0%E6%8D%AE%E4%BC%9A%E4%B8%A2%E5%A4%B1%E5%90%97%EF%BC%9F><span class=nav-number>3.1.</span> <span class=nav-text>3.1、Redis服务重启，数据会丢失吗？</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-2%E3%80%81AOF%E6%96%87%E4%BB%B6%E4%BC%9A%E8%B6%8A%E6%9D%A5%E8%B6%8A%E5%A4%A7%EF%BC%8C%E6%9C%80%E5%90%8E%E7%A3%81%E7%9B%98%E4%B8%8D%E5%B0%B1%E8%A3%85%E4%B8%8D%E4%B8%8B%E4%BA%86%EF%BC%9F><span class=nav-number>3.2.</span> <span class=nav-text>3.2、AOF文件会越来越大，最后磁盘不就装不下了？</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-3%E3%80%81Redis%E6%8C%82%E6%8E%89%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F><span class=nav-number>3.3.</span> <span class=nav-text>3.3、Redis挂掉怎么办？</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-4%E3%80%81%E4%B8%BB%E4%BB%8E%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E5%90%97%EF%BC%9F><span class=nav-number>3.4.</span> <span class=nav-text>3.4、主从可以自动切换吗？</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-5%E3%80%81%E5%A6%82%E6%9E%9CMaster%E6%8C%82%E6%8E%89%EF%BC%8C%E4%BC%9A%E9%80%89%E6%8B%A9%E5%93%AA%E4%B8%AASlave%E5%91%A2%EF%BC%9F><span class=nav-number>3.5.</span> <span class=nav-text>3.5、如果Master挂掉，会选择哪个Slave呢？</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-6%E3%80%81%E5%93%A8%E5%85%B5Leader%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%89%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%9F><span class=nav-number>3.6.</span> <span class=nav-text>3.6、哨兵Leader是如何选出来的？</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#4%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96><span class=nav-number>4.</span> <span class=nav-text>4、性能优化</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#4-1%E3%80%81Redis%E6%80%A7%E8%83%BD%E5%A6%82%E4%BD%95%EF%BC%9F><span class=nav-number>4.1.</span> <span class=nav-text>4.1、Redis性能如何？</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#4-2%E3%80%81Redis%E6%98%AF%E5%8D%8F%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%8C%E8%BF%98%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9F><span class=nav-number>4.2.</span> <span class=nav-text>4.2、Redis是协程模型，还是多线程模型？</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#4-3%E3%80%816-0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8A%9F%E8%83%BD><span class=nav-number>4.3.</span> <span class=nav-text>4.3、6.0多线程功能</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#4-4%E3%80%81%E6%95%B0%E6%8D%AE%E5%A4%AA%E5%A4%A7%E5%AD%98%E4%B8%8D%E4%B8%8B%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F><span class=nav-number>4.4.</span> <span class=nav-text>4.4、数据太大存不下怎么办？</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#4-5%E3%80%81%E4%B8%80%E8%87%B4%E6%80%A7hash><span class=nav-number>4.5.</span> <span class=nav-text>4.5、一致性hash</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#5%E3%80%81%E5%9C%BA%E6%99%AF%E5%BA%94%E7%94%A8><span class=nav-number>5.</span> <span class=nav-text>5、场景应用</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#5-1%E3%80%81Redis%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7><span class=nav-number>5.1.</span> <span class=nav-text>5.1、Redis数据一致性</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#5-2%E3%80%81%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E5%93%AA%E4%B8%AA%E6%9B%B4%E5%A5%BD%EF%BC%9F><span class=nav-number>5.2.</span> <span class=nav-text>5.2、两种模式哪个更好？</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#5-3%E3%80%81%E6%95%B0%E6%8D%AE%E5%8F%98%E5%8C%96%E6%97%B6%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98%EF%BC%9F><span class=nav-number>5.3.</span> <span class=nav-text>5.3、数据变化时如何更新缓存？</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#5-4%E3%80%81Redis%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9><span class=nav-number>5.4.</span> <span class=nav-text>5.4、Redis缓存雪崩</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#5-5%E3%80%81Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F><span class=nav-number>5.5.</span> <span class=nav-text>5.5、Redis缓存穿透</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#5-6%E3%80%81%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86><span class=nav-number>5.6.</span> <span class=nav-text>5.6、布隆过滤器实现原理</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#5-7%E3%80%81Redis%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF><span class=nav-number>5.7.</span> <span class=nav-text>5.7、Redis缓存击穿</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#5-8%E3%80%81Redis%E6%94%AF%E6%8C%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8A%9F%E8%83%BD%E5%90%97%EF%BC%9F><span class=nav-number>5.8.</span> <span class=nav-text>5.8、Redis支持消息队列功能吗？</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#5-9%E3%80%81Redis%E5%9C%A8%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8><span class=nav-number>5.9.</span> <span class=nav-text>5.9、Redis在秒杀场景中的应用</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#5-10%E3%80%81Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81><span class=nav-number>5.10.</span> <span class=nav-text>5.10、Redis分布式锁</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#5-11%E3%80%81Redis%E5%9C%A8%E9%99%90%E6%B5%81%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8><span class=nav-number>5.11.</span> <span class=nav-text>5.11、Redis在限流场景中的应用</span></a></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>116</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>36</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>129</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://hgprivate.github.io/2024/08/21/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="Redis系列-Redis模拟面试题第一篇 | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>Redis系列-Redis模拟面试题第一篇</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-07 09:59:37" datetime=2023-08-07T09:59:37+08:00 itemprop=dateModified>2023-08-07</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Redis/ itemprop=url rel=index><span itemprop=name>Redis</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、基础摸底><a class=headerlink href=#1、基础摸底 title=1、基础摸底></a>1、基础摸底</h1><h2 id=1-1、何为Redis><a class=headerlink href=#1-1、何为Redis title=1.1、何为Redis></a>1.1、何为Redis</h2><p><strong>Redis 是 NoSQL 数据库，也即非关系型数据库。</strong>。<h2 id=1-2、NoSQL-BASE理论><a title="1.2、NoSQL BASE理论" class=headerlink href=#1-2、NoSQL-BASE理论></a>1.2、NoSQL BASE理论</h2><p><strong>BASE理论是对CAP中一致性的妥协</strong>。与 传统事务ACID 不同，BASE不追求强一致性，只要最终达到一致就行。<blockquote><p>CAP是三个单词的首字母，其代表的意思如下：<ul><li>C：一致性<li>A：可用性<li>P：分区容错性</ul><p>BASE是Basically Available（基本可用）、Soft-state（软状态）和 Eventually Consistent（最终一致性）三个词语的缩写。</blockquote><h2 id=1-3、Redis常用命令><a class=headerlink href=#1-3、Redis常用命令 title=1.3、Redis常用命令></a>1.3、Redis常用命令</h2><ul><li><strong>读操作</strong>：get a 表示获取a对应的数据；<li><strong>写操作</strong>：setex a t b 表示将a的数据设置为b，并且在t秒后过期；</ul><h2 id=1-4、Redis-key清除策略><a title="1.4、Redis key清除策略" class=headerlink href=#1-4、Redis-key清除策略></a>1.4、Redis key清除策略</h2><p>过期键 清除策略 有三种，分别如下：<ul><li><strong>定时删除</strong>：为键设置过期时间时，创建一个定时器，让定时器在键过期时，立即删除该键；<li><strong>定期删除</strong>：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键；<li><strong>惰性删除</strong>：实际去使用时若发现Key过期了，此时再进行删除；</ul><p><strong>Redis采用的是 定期删除 和 惰性删除 相结合的方式</strong>。<h2 id=1-5、过期键没有被访问，且删除又跟不上新键速度，内存会耗尽吗？><a class=headerlink href=#1-5、过期键没有被访问，且删除又跟不上新键速度，内存会耗尽吗？ title=1.5、过期键没有被访问，且删除又跟不上新键速度，内存会耗尽吗？></a>1.5、过期键没有被访问，且删除又跟不上新键速度，内存会耗尽吗？</h2><p><strong>Redis支持内存淘汰，参数<code>maxmemory_policy</code>决定了内存淘汰策略的种类。</strong>这个参数一共有8个枚举值。<ul><li>不开启数据淘汰<ol><li>noeviction</ol><li>基于有过期时间的数据<ol><li>volatitle-lfu<li>volatitle-lru<li>volatitle-random<li>volatitle-ttl</ol><li>基于所有数据<ol><li>allkeys-lru<li>allkeys-random<li>allkeys-ttl</ol></ul><h2 id=1-6、内存淘汰用到的是LRU算法吗？><a class=headerlink href=#1-6、内存淘汰用到的是LRU算法吗？ title=1.6、内存淘汰用到的是LRU算法吗？></a>1.6、内存淘汰用到的是LRU算法吗？</h2><p>LRU算法需要一个双向链表来记录数据最近被访问的顺序，为节省内存，<strong>Redis的LRU算法并非是原生LRU算法</strong>。<p>Redis内存淘汰过程：<strong>Redis通过对少量键进行取样，然后与淘汰池中的进行综合比较，最终回收最久未被访问的键</strong>。<p>注意：通过<strong>调整每次回收时的采样数量<code>maxmemory-samples</code>，可以调整算法精度</strong>。<h1 id=2、数据结构><a class=headerlink href=#2、数据结构 title=2、数据结构></a>2、数据结构</h1><h2 id=2-1、Redis数据结构><a class=headerlink href=#2-1、Redis数据结构 title=2.1、Redis数据结构></a>2.1、Redis数据结构</h2><p>对外暴露5种Redis对象，分别是<code>String、List、Hash、Set、Zset</code>。底层实现依托于<code>sds、ziplist、skiplist、dict</code>等数据结构。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629223912586.png><h2 id=2-2、Redis字符串特点><a class=headerlink href=#2-2、Redis字符串特点 title=2.2、Redis字符串特点></a>2.2、Redis字符串特点</h2><p>如果保存的对象是整数就用int存储，否则使用SDS来存储。SDS通过记录长度，和预分配空间，可以高效计算长度，进行append操作。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629224144667.png><h2 id=2-3、Hash扩容><a class=headerlink href=#2-3、Hash扩容 title=2.3、Hash扩容></a>2.3、Hash扩容</h2><p><strong>两张Hash表，一般先使用0号表，当装载因子超过阈值时会进行Rehash，将0号表上的每一个bucket慢慢移动到1号表，所以叫渐进式Rehash。</strong>渐进式Rehash方式可以减少迁移大量数据造成的性能影响。<h2 id=2-4、Rehash过程><a class=headerlink href=#2-4、Rehash过程 title=2.4、Rehash过程></a>2.4、Rehash过程</h2><p>当周期函数发现装载因子超过阈值时就会进行Rehash。Rehash流程主要分成三步：<ol><li><p><strong>生成新Hash表ht[1]，为 ht[1] 分配空间</strong>。</p> <p>字典持有ht[0]和ht[1]两个哈希表。字典的偏移索引从-1变为0，表示Rehash 工作正式开始。</p><li><p>**迁移 ht[0] 数据到 ht[1]**。</p> <p>在 Rehash执行期间，每次对字典执行增删查改操作，程序会顺带迁移一个ht[0]上的数据，并更新偏移索引。与此同时，周期函数也会定时迁移一批。</p><li><p><strong>交换 ht[1] 和 ht[0] 的指针</strong>。</p> <p>随着字典操作的不断执行， 最终在某个时间点上，ht[0]的所有键值对都会被Rehash至 ht[1]，此时再将ht[1]和ht[0]的指针对象进行互换，同时把偏移索引的值设为-1，表示Rehash操作已完成。</p></ol><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629224615221.png><h2 id=2-5、rehash时有请求过来，redis会如何处理？><a class=headerlink href=#2-5、rehash时有请求过来，redis会如何处理？ title=2.5、rehash时有请求过来，redis会如何处理？></a>2.5、rehash时有请求过来，redis会如何处理？</h2><ul><li>插入请求：将数据插入到ht[1]中；<li>读取请求：先从ht[0]读取，若没有再从ht[1]中查找；<li>删除/更新请求：先找ht[0]，再找ht[1]，然后执行相关操作；</ul><h2 id=2-6、跳表><a class=headerlink href=#2-6、跳表 title=2.6、跳表></a>2.6、跳表</h2><p><strong>跳表本质是对链表的优化。通过逐层跳步采样构建索引，加快查找速度</strong>。跳表可高层索引，一次跳跃多个节点，如果找过头了，就使用下层索引。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629224859742.png><h2 id=2-7、每个节点多少层？><a class=headerlink href=#2-7、每个节点多少层？ title=2.7、每个节点多少层？></a>2.7、每个节点多少层？</h2><p>使用 概率均衡思路 确定新插入节点的层数。Redis <strong>使用随机函数决定层数</strong>。直观上来说，默认1层，和丢硬币一样，如果是正面就继续往上，这样持续迭代，<strong>最大层数 32 层</strong>。<p>可以看到，50%的概率被分配到第一层，25%的概率被分配到第二层，12.5%的概率被分配到第三层。这种方式保证了层数越高其数量越少，自然跨越起来越方便。<h2 id=2-8、Zset为何需要字典和跳表来实现？><a class=headerlink href=#2-8、Zset为何需要字典和跳表来实现？ title=2.8、Zset为何需要字典和跳表来实现？></a>2.8、Zset为何需要字典和跳表来实现？</h2><p>Zset是一个有序列表，<strong>字典和跳表分别适用 按成员查询数据 和 按范围查询</strong>。<h1 id=3、系统容灾><a class=headerlink href=#3、系统容灾 title=3、系统容灾></a>3、系统容灾</h1><h2 id=3-1、Redis服务重启，数据会丢失吗？><a class=headerlink href=#3-1、Redis服务重启，数据会丢失吗？ title=3.1、Redis服务重启，数据会丢失吗？></a>3.1、Redis服务重启，数据会丢失吗？</h2><p>不会丢失。可通过持久化机制来备份数据，有两种方式：<ol><li><strong>RDB持久化</strong>：RDB是Redis的二进制快照文件，优点是文件紧凑，占用空间小，恢复速度快。同时，由于是子进程Fork模式，对Redis本身读写性能影响很小。<li><strong>AOF持久化</strong>：AOF会以日志形式记录Redis操作命令，AOF文件 比 RDB大很多，恢复速度较慢；</ol><p>如果开启AOF，会将命令先记录在AOF缓冲，之后再刷入磁盘。数据刷入磁盘的时机是根据参数决定，有三种模式：1.关闭时刷入；2.每秒定期刷入；3.执行命令后立刻触发。<p>AOF优点 是 发生故障时丢失数据比RDB少。执行命令后立马刷入会拖慢执行速度，故一般设为每秒定期刷入。<h2 id=3-2、AOF文件会越来越大，最后磁盘不就装不下了？><a class=headerlink href=#3-2、AOF文件会越来越大，最后磁盘不就装不下了？ title=3.2、AOF文件会越来越大，最后磁盘不就装不下了？></a>3.2、AOF文件会越来越大，最后磁盘不就装不下了？</h2><p><strong>Redis会在AOF文件体积达到设定阈值时自动Fork一个子进程，用来对AOF文件进行重写</strong>。<p>重写过程中，Redis将新的操作记录在原有AOF缓冲区，且还会记录在AOF重写缓冲区。一旦新AOF文件创建完毕，Redis 就会将重写缓冲区内容追加到新AOF文件中，然后用 新AOF文件 替换 旧AOF文件。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629230205745.png><h2 id=3-3、Redis挂掉怎么办？><a class=headerlink href=#3-3、Redis挂掉怎么办？ title=3.3、Redis挂掉怎么办？></a>3.3、Redis挂掉怎么办？</h2><p>使用 主从模式 可避免 机器宕机问题。即有一个或多个备用机器，备用机将作为Slave同步Master数据，Redis出现问题时将Slave升级为Master。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629230331075.png><h2 id=3-4、主从可以自动切换吗？><a class=headerlink href=#3-4、主从可以自动切换吗？ title=3.4、主从可以自动切换吗？></a>3.4、主从可以自动切换吗？</h2><p>本身不能，但可通过 脚本 实现，不过考虑的问题较多。Redis解决方案：哨兵模式。<strong>哨兵来监测Redis服务是否正常，异常情况下将由哨兵代理切换。为避免哨兵单点故障问题，哨兵也要多机部署</strong>。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629230456394.png><h2 id=3-5、如果Master挂掉，会选择哪个Slave呢？><a class=headerlink href=#3-5、如果Master挂掉，会选择哪个Slave呢？ title=3.5、如果Master挂掉，会选择哪个Slave呢？></a>3.5、如果Master挂掉，会选择哪个Slave呢？</h2><p>哨兵集群选举出哨兵Leader后，哨兵Leader 会从Redis slave节点中选择一个节点作为主节点：<ol><li><strong>判断 salve 节点与 master 节点断开时间长短，时间超过（down-after-milliseconds * 10）则排除该节点</strong>；<li><strong>判断 slave节点的 slave-priority 值大小，越小优先级越高，如果值为 0 则不参与选举</strong>。如果相同继续。<li><strong>判断 slave 节点的 offset 值大小，值越大数据越新，优先级就越高</strong>。<li><strong>判断 slave 节点的 runid 大小，越小优先级越高</strong>。</ol><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629230808740.png><h2 id=3-6、哨兵Leader是如何选出来的？><a class=headerlink href=#3-6、哨兵Leader是如何选出来的？ title=3.6、哨兵Leader是如何选出来的？></a>3.6、哨兵Leader是如何选出来的？</h2><p>每一个哨兵节点都可以成为Leader，当一个哨兵节点确认Redis集群主节点主观下线后，会请求其他哨兵节点将自己选举为Leader。被请求的哨兵节点如果没有同意过其他哨兵节点的选举请求，则同意该请求，也就是选举票数+1，否则不同意。<p><strong>如果一个哨兵节点获得的选举票数超过节点数的一半，且大于<code>quorum</code>配置的值，则该哨兵节点选举为 Leader；否则重新进行选举</strong>。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629231059635.png><h1 id=4、性能优化><a class=headerlink href=#4、性能优化 title=4、性能优化></a>4、性能优化</h1><h2 id=4-1、Redis性能如何？><a class=headerlink href=#4-1、Redis性能如何？ title=4.1、Redis性能如何？></a>4.1、Redis性能如何？</h2><p>只能说在十万级。使用前要跑BenchMark，实际情况下会受带宽、负载、单个数据大小、是否开启多线程等因素影响，脱离具体场景谈性能没有意义。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629231239734.png><h2 id=4-2、Redis是协程模型，还是多线程模型？><a class=headerlink href=#4-2、Redis是协程模型，还是多线程模型？ title=4.2、Redis是协程模型，还是多线程模型？></a>4.2、Redis是协程模型，还是多线程模型？</h2><p>Redis是单线程Reactor模型，通过高效的IO复用以及内存处理来实现高性能。<p><strong>Redis 6.0之前是单线程，6.0之后还是单线程，但IO解包通过多线程做了优化，而处理逻辑还是单线程</strong>。<p>另外，如果考虑到RDB的Fork 和 一些定时任务处理，那么也可以说Redis是多进程。但要知道 Redis 处理数据 始终都是单线程。<h2 id=4-3、6-0多线程功能><a class=headerlink href=#4-3、6-0多线程功能 title=4.3、6.0多线程功能></a>4.3、6.0多线程功能</h2><p><strong>多线程主要用于提高解包效率</strong>。和Multi Reactor多线程模型不同，<strong>Redis多线程只负责处理网络 IO 解包和协议转换</strong>，一方面是单线程处理足够快，另一方面是为了兼容性考虑。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629231531238.png><h2 id=4-4、数据太大存不下怎么办？><a class=headerlink href=#4-4、数据太大存不下怎么办？ title=4.4、数据太大存不下怎么办？></a>4.4、数据太大存不下怎么办？</h2><p><strong>集群模式将数据分片，不同的 Key 根据 Hash 路由到不同节点</strong>。集群索引通过一致性Hash算法来完成，这种算法可以解决服务器数量发生改变时，所有服务器缓存同一时间失效问题。<p>基于Gossip协议，集群状态变化时，如新节点加入、节点宕机、Slave升为新Master等变化都能传播到整个集群所有节点并达成一致。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629231746172.png><h2 id=4-5、一致性hash><a class=headerlink href=#4-5、一致性hash title=4.5、一致性hash></a>4.5、一致性hash</h2><p><strong>传统Hash分片可以将某个Key落到某个节点。但当节点扩容或者缩容时路由会被打乱。如果是缓存场景，容易造成缓存雪崩问题</strong>。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629232059868.png><p>为了优化这种情况，一致性Hash就应运而生了。<p><strong>一致性 Hash 是将数据和服务器以相同的 Hash 函数映射到同一个 Hash 环上，针对一个对象，在哈希环上顺时针查找距其最近的机器，这个机器就负责处理该对象的相关请求</strong>。<p>这种情况下，增加节点只会分流后面一个节点的数据。减少节点会由后一个节点继承。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629232345450.png><h1 id=5、场景应用><a class=headerlink href=#5、场景应用 title=5、场景应用></a>5、场景应用</h1><h2 id=5-1、Redis数据一致性><a class=headerlink href=#5-1、Redis数据一致性 title=5.1、Redis数据一致性></a>5.1、Redis数据一致性</h2><p>从设计思路来说，有 Cache Aside 和 Read / Write Through 两种模式，前者会把缓存责任交给应用层，后者会把缓存责任交给服务提供方。<h2 id=5-2、两种模式哪个更好？><a class=headerlink href=#5-2、两种模式哪个更好？ title=5.2、两种模式哪个更好？></a>5.2、两种模式哪个更好？</h2><p>两种模式各有优缺点，<strong>从透明性考虑，服务方比较合适；从性能考虑来说，业务方会更有优势</strong>，可以减去服务RPC损耗。<h2 id=5-3、数据变化时如何更新缓存？><a class=headerlink href=#5-3、数据变化时如何更新缓存？ title=5.3、数据变化时如何更新缓存？></a>5.3、数据变化时如何更新缓存？</h2><p>更新方式大概有四种：<ol><li>先保存至缓存，然后再同步至数据库，同步成功后让缓存失效，等到读缓存没有命中时再加载进去；<li>通过消息队列更新缓存；<li>先更新缓存，再更新服务，这种情况相当于把Cache当作Buffer使用；<li>起一个同步服务，作为MySQL一个从节点，通过解析binlog同步重要缓存；</ol><h2 id=5-4、Redis缓存雪崩><a class=headerlink href=#5-4、Redis缓存雪崩 title=5.4、Redis缓存雪崩></a>5.4、Redis缓存雪崩</h2><p>缓存雪崩定义：某一时间段内 缓存集中失效，导致请求全部打到数据库，严重可能会导致整个服务瘫痪。<p>应对方案：让过期时间随机化，避免大量缓存在同一时间过期。同时也可考虑为热点数据使用双缓存。<h2 id=5-5、Redis缓存穿透><a class=headerlink href=#5-5、Redis缓存穿透 title=5.5、Redis缓存穿透></a>5.5、Redis缓存穿透</h2><p>缓存穿透定义：请求了数据库中没有的数据，高频请求不存在的Key，有可能是正常业务逻辑，也可能是黑客攻击。<p>应对方案：通过 布隆过滤器 来避免频繁请求不存在的数据。布隆过滤器是一种比较巧妙的概率型数据结构，特点是高效插入和查询，可以用来告诉我们某样东西一定不存在或者可能存在。<h2 id=5-6、布隆过滤器实现原理><a class=headerlink href=#5-6、布隆过滤器实现原理 title=5.6、布隆过滤器实现原理></a>5.6、布隆过滤器实现原理</h2><p><strong>布隆过滤器底层是一个64位整型，将字符串通过多个Hash函数映射到不同的二进制位上，然后将对应位置设置为1</strong>。<p><font color=red>注意：查询时，如果一个字符串所有Hash函数映射的值都存在，那么数据可能存在。为什么说可能呢，就是因为其他字符可能占据该值，提前点亮。</font><p>优缺点：优点是空间、时间消耗都很小，缺点是结果不是完全准确。<p><img alt=image-20210629233454825 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023%2F08%2F07%2FRedis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629233454825.png><h2 id=5-7、Redis缓存击穿><a class=headerlink href=#5-7、Redis缓存击穿 title=5.7、Redis缓存击穿></a>5.7、Redis缓存击穿</h2><p>缓存击穿定义：要获取的某个高频键值数据在数据库中存在，但缓存中过期了，此时大量请求打到后端数据库就可能导致服务崩溃。<p>应对方案：可以使用 分布式锁 或 分布式令牌桶 来限频。<h2 id=5-8、Redis支持消息队列功能吗？><a class=headerlink href=#5-8、Redis支持消息队列功能吗？ title=5.8、Redis支持消息队列功能吗？></a>5.8、Redis支持消息队列功能吗？</h2><p>支持消息队列，但不建议使用，因为 Redis的消息队列 缺少消息队列相关规范。<h2 id=5-9、Redis在秒杀场景中的应用><a class=headerlink href=#5-9、Redis在秒杀场景中的应用 title=5.9、Redis在秒杀场景中的应用></a>5.9、Redis在秒杀场景中的应用</h2><p>Redis应用场景分析如下：<ol><li>流量控制；<li>分布式锁；</ol><h2 id=5-10、Redis分布式锁><a class=headerlink href=#5-10、Redis分布式锁 title=5.10、Redis分布式锁></a>5.10、Redis分布式锁</h2><p>分布式锁 依赖 存储组件，针对请求量的不同，可以选择Etcd、MySQL、Redis等。前两者可靠性更强，Redis性能更高。<h2 id=5-11、Redis在限流场景中的应用><a class=headerlink href=#5-11、Redis在限流场景中的应用 title=5.11、Redis在限流场景中的应用></a>5.11、Redis在限流场景中的应用</h2><p>微服务架构中，<strong>实现流量控制的方式之一就是Redis令牌桶</strong>。<ul><li><p><strong>令牌获取</strong></p> <p>Redis管理令牌，微服务在执行函数操作前需向Redis申请令牌。若有 剩余令牌 就返回一个令牌给申请者，若没有剩余令牌就阻塞。</p><li><p><strong>令牌生成</strong></p> <p>为提高性能，令牌生成采用懒生成方式。也就是 在获取令牌时生成令牌，获取和生成操作可以在一个Lua脚本中实现，保证了原子性。</p></ul><p><img alt=image-20210629234221317 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023%2F08%2F07%2FRedis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629234221317.png></div><footer class=post-footer><div class=post-tags><a href=/tags/Redis%E9%9D%A2%E8%AF%95/ rel=tag># Redis面试</a></div><div class=post-nav><div class=post-nav-item><a href=/2024/08/21/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/ rel=prev title=Redis系列-Redis集群搭建> <i class="fa fa-angle-left"></i> Redis系列-Redis集群搭建 </a></div><div class=post-nav-item><a href=/2024/08/21/Redis%E5%94%AF%E5%BF%AB%E4%B8%8D%E7%A0%B4%E7%9A%84%E7%A7%98%E5%AF%86/ rel=next title=Redis系列-Redis唯快不破> Redis系列-Redis唯快不破 <i class="fa fa-angle-right"></i> </a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script>