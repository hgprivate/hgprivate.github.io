<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hshz21.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="1、算法算法指同一问题的不同解决方法。算法通常针对特定数据结构。 1.1、排序算法1.1.1、内部排序（使用内存）1.1.1.1、插入排序 直接插入排序：将n个待排序元素看成一个有序表和一个无序表，第一次排序时，有序表中只有一个元素，无序表中有n-1个元素，接下来每次从无序表中拿出第一个元素，将它放入有序表的适当位置，使之依然序表。然后继续，直到排序完毕； 折半插入排序：是对直接插入排序算法的一种" name=description><meta content=article property=og:type><meta content=数据与算法系列-数据结构与算法 property=og:title><meta content=https://hshz21.gitee.io/2024/08/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content="1、算法算法指同一问题的不同解决方法。算法通常针对特定数据结构。 1.1、排序算法1.1.1、内部排序（使用内存）1.1.1.1、插入排序 直接插入排序：将n个待排序元素看成一个有序表和一个无序表，第一次排序时，有序表中只有一个元素，无序表中有n-1个元素，接下来每次从无序表中拿出第一个元素，将它放入有序表的适当位置，使之依然序表。然后继续，直到排序完毕； 折半插入排序：是对直接插入排序算法的一种" property=og:description><meta content=zh_CN property=og:locale><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200921145201640.png?token=AIGEF3L2CI465XXEYEKL7IDEZZWVM property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200919141327620.png?token=AIGEF3JMQBUJFREE6ZNIL5DEZZWXE property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200920084320304.png?token=AIGEF3IZHFXIYNI4L5HLUBLEZZWYU property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200920084352501.png?token=AIGEF3LLQKIYVMKSWL5RUP3EZZWZY property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200920084435924.png?token=AIGEF3OD2D3UJQXOLJPN4MDEZZW3O property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A601.jpg?token=AIGEF3PJUNGHWIOJSSI2YZ3EZZW5K property=og:image><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A601.jpg?token=AIGEF3PCPFPUYKDIWGS3GKLEZZW7E property=og:image><meta content=2024-08-21T13:39:15.021Z property=article:published_time><meta content=2023-10-06T02:25:57.958Z property=article:modified_time><meta content=豪哥 property=article:author><meta content=数据结构 property=article:tag><meta content=算法 property=article:tag><meta content=summary name=twitter:card><meta content=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200921145201640.png?token=AIGEF3L2CI465XXEYEKL7IDEZZWVM name=twitter:image><link href=https://hshz21.gitee.io/2024/08/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hshz21.gitee.io/2024/08/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","path":"2024/08/21/数据结构与算法知识点总结/","title":"数据与算法系列-数据结构与算法"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>数据与算法系列-数据结构与算法 | 豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>豪哥博客</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#1%E3%80%81%E7%AE%97%E6%B3%95><span class=nav-number>1.</span> <span class=nav-text>1、算法</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95><span class=nav-number>1.1.</span> <span class=nav-text>1.1、排序算法</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-1%E3%80%81%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%EF%BC%89><span class=nav-number>1.1.1.</span> <span class=nav-text>1.1.1、内部排序（使用内存）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-1-1%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F><span class=nav-number>1.1.1.1.</span> <span class=nav-text>1.1.1.1、插入排序</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-1-2%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F><span class=nav-number>1.1.1.2.</span> <span class=nav-text>1.1.1.2、选择排序</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-1-3%E3%80%81%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F><span class=nav-number>1.1.1.3.</span> <span class=nav-text>1.1.1.3、交换排序</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-1-4%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F><span class=nav-number>1.1.1.4.</span> <span class=nav-text>1.1.1.4、归并排序</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-1-1-5%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F><span class=nav-number>1.1.1.5.</span> <span class=nav-text>1.1.1.5、基数排序</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-1-2%E3%80%81%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F><span class=nav-number>1.1.2.</span> <span class=nav-text>1.1.2、外部排序</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-2%E3%80%81%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95><span class=nav-number>1.2.</span> <span class=nav-text>1.2、查找算法</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-1%E3%80%81%E9%A1%BA%E5%BA%8F%EF%BC%88%E7%BA%BF%E6%80%A7%EF%BC%89%E6%9F%A5%E6%89%BE><span class=nav-number>1.2.1.</span> <span class=nav-text>1.2.1、顺序（线性）查找</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-2%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE><span class=nav-number>1.2.2.</span> <span class=nav-text>1.2.2、二分查找</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-3%E3%80%81%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE><span class=nav-number>1.2.3.</span> <span class=nav-text>1.2.3、插值查找</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-4%E3%80%81%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE%EF%BC%88%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2%E7%82%B9%E6%9F%A5%E6%89%BE%EF%BC%89><span class=nav-number>1.2.4.</span> <span class=nav-text>1.2.4、斐波那契查找（黄金分割点查找）</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-3%E3%80%81%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95><span class=nav-number>1.3.</span> <span class=nav-text>1.3、常用算法</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-1%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%EF%BC%8C%E5%85%B3%E9%94%AE%E5%AD%97%E5%8C%B9%E9%85%8D%EF%BC%89><span class=nav-number>1.3.1.</span> <span class=nav-text>1.3.1、二分查找算法（非递归，关键字匹配）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-1-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.3.1.1.</span> <span class=nav-text>1.3.1.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-1-2%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0><span class=nav-number>1.3.1.2.</span> <span class=nav-text>1.3.1.2、代码实现</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-2%E3%80%81%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95><span class=nav-number>1.3.2.</span> <span class=nav-text>1.3.2、分治算法</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-2-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.3.2.1.</span> <span class=nav-text>1.3.2.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-2-2%E3%80%81%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4><span class=nav-number>1.3.2.2.</span> <span class=nav-text>1.3.2.2、解题步骤</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-2-3%E3%80%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF><span class=nav-number>1.3.2.3.</span> <span class=nav-text>1.3.2.3、应用场景</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-3%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%EF%BC%88%E6%B1%82%E6%9C%80%E4%BC%98%E5%86%B3%E7%AD%96%EF%BC%89><span class=nav-number>1.3.3.</span> <span class=nav-text>1.3.3、动态规划算法（求最优决策）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#13-3-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.3.3.1.</span> <span class=nav-text>13.3.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-3-2%E3%80%81%E5%B1%80%E9%99%90%E6%80%A7><span class=nav-number>1.3.3.2.</span> <span class=nav-text>1.3.3.2、局限性</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-4%E3%80%81%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%EF%BC%89><span class=nav-number>1.3.4.</span> <span class=nav-text>1.3.4、暴力匹配算法（字符串匹配）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-4-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.3.4.1.</span> <span class=nav-text>1.3.4.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-4-2%E3%80%81%E7%BC%BA%E7%82%B9><span class=nav-number>1.3.4.2.</span> <span class=nav-text>1.3.4.2、缺点</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-5%E3%80%81KMP%E7%AE%97%E6%B3%95%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%EF%BC%89><span class=nav-number>1.3.5.</span> <span class=nav-text>1.3.5、KMP算法（字符串匹配）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-5-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.3.5.1.</span> <span class=nav-text>1.3.5.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-5-2%E3%80%81%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%B1%BB%E5%9E%8B><span class=nav-number>1.3.5.2.</span> <span class=nav-text>1.3.5.2、模式匹配类型</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-5-3%E3%80%81%E9%83%A8%E5%88%86%E5%8C%B9%E9%85%8D%E8%A1%A8><span class=nav-number>1.3.5.3.</span> <span class=nav-text>1.3.5.3、部分匹配表</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-6%E3%80%81%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%EF%BC%88%E5%B1%80%E9%83%A8%E6%9C%80%E4%BC%98%E8%A7%A3%EF%BC%89><span class=nav-number>1.3.6.</span> <span class=nav-text>1.3.6、贪心算法（局部最优解）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-6-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.3.6.1.</span> <span class=nav-text>1.3.6.1、简介</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-7%E3%80%81%E6%99%AE%E5%88%A9%E5%A7%86%E7%AE%97%E6%B3%95%EF%BC%88Prim%EF%BC%8C%E7%A8%A0%E5%AF%86%E5%9B%BE%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89><span class=nav-number>1.3.7.</span> <span class=nav-text>1.3.7、普利姆算法（Prim，稠密图最小生成树）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-7-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.3.7.1.</span> <span class=nav-text>1.3.7.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-7-2%E3%80%81%E6%80%BB%E7%BB%93><span class=nav-number>1.3.7.2.</span> <span class=nav-text>1.3.7.2、总结</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-8%E3%80%81%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95%EF%BC%88Kruskal%EF%BC%8C%E7%A8%80%E7%96%8F%E5%9B%BE%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%89><span class=nav-number>1.3.8.</span> <span class=nav-text>1.3.8、克鲁斯卡尔算法（Kruskal，稀疏图最小生成树）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-8-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.3.8.1.</span> <span class=nav-text>1.3.8.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-8-2%E3%80%81%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3><span class=nav-number>1.3.8.2.</span> <span class=nav-text>1.3.8.2、基本思想</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-9%E3%80%81%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95%EF%BC%88Dijkstra%EF%BC%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%89><span class=nav-number>1.3.9.</span> <span class=nav-text>1.3.9、迪杰斯特拉算法（Dijkstra，最短路径）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-9-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.3.9.1.</span> <span class=nav-text>1.3.9.1、简介</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-10%E3%80%81%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95%EF%BC%88Floyd%EF%BC%8C%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%89><span class=nav-number>1.3.10.</span> <span class=nav-text>1.3.10、弗洛伊德算法（Floyd，最短路径）</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-10-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.3.10.1.</span> <span class=nav-text>1.3.10.1、简介</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-10-2%E3%80%81%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B><span class=nav-number>1.3.10.2.</span> <span class=nav-text>1.3.10.2、算法过程</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-10-3%E3%80%81%E6%97%B6%E9%97%B4-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6><span class=nav-number>1.3.10.3.</span> <span class=nav-text>1.3.10.3、时间/空间复杂度</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-10-4%E3%80%81%E4%BC%98%E7%BC%BA%E7%82%B9><span class=nav-number>1.3.10.4.</span> <span class=nav-text>1.3.10.4、优缺点</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-11%E3%80%81%E9%AA%91%E5%A3%AB%E5%91%A8%E6%B8%B8%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95><span class=nav-number>1.3.11.</span> <span class=nav-text>1.3.11、骑士周游回溯算法</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-3-11-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.3.11.1.</span> <span class=nav-text>1.3.11.1、简介</span></a></ol></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-4%E3%80%81%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6><span class=nav-number>1.4.</span> <span class=nav-text>1.4、算法复杂度</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-1%E3%80%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6><span class=nav-number>1.4.1.</span> <span class=nav-text>1.4.1、时间复杂度</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-4-1-1%E3%80%81%E6%97%B6%E9%97%B4%E9%A2%91%E5%BA%A6><span class=nav-number>1.4.1.1.</span> <span class=nav-text>1.4.1.1、时间频度</span></a><li class="nav-item nav-level-4"><a class=nav-link href=#1-4-1-2%E3%80%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%A1%A8%E7%A4%BA><span class=nav-number>1.4.1.2.</span> <span class=nav-text>1.4.1.2、时间复杂度表示</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-2%E3%80%81%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6><span class=nav-number>1.4.2.</span> <span class=nav-text>1.4.2、空间复杂度</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#1-4-2-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>1.4.2.1.</span> <span class=nav-text>1.4.2.1、简介</span></a></ol><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-3%E3%80%81Big-O><span class=nav-number>1.4.3.</span> <span class=nav-text>1.4.3、Big O</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-4-4%E3%80%81%E6%80%BB%E7%BB%93><span class=nav-number>1.4.4.</span> <span class=nav-text>1.4.4、总结</span></a><ol class=nav-child><li class="nav-item nav-level-4"><a class=nav-link href=#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E6%97%B6%E9%97%B4-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-%E5%AF%B9%E6%AF%94><span class=nav-number>1.4.4.1.</span> <span class=nav-text>排序算法 时间/空间复杂度 对比</span></a></ol></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#2%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84><span class=nav-number>2.</span> <span class=nav-text>2、数据结构</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#2-1%E3%80%81%E7%AE%80%E4%BB%8B><span class=nav-number>2.1.</span> <span class=nav-text>2.1、简介</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-2%E3%80%81%E5%88%86%E7%B1%BB><span class=nav-number>2.2.</span> <span class=nav-text>2.2、分类</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-1%E3%80%81%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84><span class=nav-number>2.2.1.</span> <span class=nav-text>2.2.1、线性结构</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#2-2-2%E3%80%81%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84><span class=nav-number>2.2.2.</span> <span class=nav-text>2.2.2、非线性结构</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#3%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E5%BA%94%E5%AF%B9><span class=nav-number>3.</span> <span class=nav-text>3、常见问题及应对</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#3-1%E3%80%81%E4%BF%AE%E8%B7%AF%E9%97%AE%E9%A2%98><span class=nav-number>3.1.</span> <span class=nav-text>3.1、修路问题</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-2%E3%80%81%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98><span class=nav-number>3.2.</span> <span class=nav-text>3.2、最短路径问题</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-3%E3%80%81%E6%B1%89%E8%AF%BA%E5%A1%94%E9%97%AE%E9%A2%98><span class=nav-number>3.3.</span> <span class=nav-text>3.3、汉诺塔问题</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-4%E3%80%81%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98><span class=nav-number>3.4.</span> <span class=nav-text>3.4、八皇后问题</span></a></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>116</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>36</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>129</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://hshz21.gitee.io/2024/08/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="数据与算法系列-数据结构与算法 | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>数据与算法系列-数据结构与算法</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:15" datetime=2024-08-21T21:39:15+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-06 10:25:57" datetime=2023-10-06T10:25:57+08:00 itemprop=dateModified>2023-10-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%AE%97%E6%B3%95/ itemprop=url rel=index><span itemprop=name>数据与算法</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、算法><a class=headerlink href=#1、算法 title=1、算法></a>1、算法</h1><p>算法指同一问题的不同解决方法。算法通常针对特定数据结构。<h2 id=1-1、排序算法><a class=headerlink href=#1-1、排序算法 title=1.1、排序算法></a>1.1、排序算法</h2><h3 id=1-1-1、内部排序（使用内存）><a class=headerlink href=#1-1-1、内部排序（使用内存） title=1.1.1、内部排序（使用内存）></a>1.1.1、内部排序（使用内存）</h3><h4 id=1-1-1-1、插入排序><a class=headerlink href=#1-1-1-1、插入排序 title=1.1.1.1、插入排序></a>1.1.1.1、插入排序</h4><ul><li>直接插入排序：将n个待排序元素看成一个有序表和一个无序表，第一次排序时，有序表中只有一个元素，无序表中有n-1个元素，接下来每次从无序表中拿出第一个元素，将它放入有序表的适当位置，使之依然序表。然后继续，直到排序完毕；<li>折半插入排序：是对直接插入排序算法的一种改进。与直接插入排序的区别是：在有序表中寻找待排序数据的正确位置时，使用了折半查找/二分查找。<li>希尔排序：希尔排序是将记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</ul><h4 id=1-1-1-2、选择排序><a class=headerlink href=#1-1-1-2、选择排序 title=1.1.1.2、选择排序></a>1.1.1.2、选择排序</h4><p><strong>（1）简单选择排序</strong><p>每一轮只找最小值且放在最前面，下一轮在剩下的元素中再次寻找最小值并放于上一次找到的最小值右边，以此类推，直到全部比较完毕。<p><strong>（2）堆排序</strong><p>堆排序是一种选择排序，最坏，最好的平均时间复杂度均为O(nlogn)，它是不稳定排序。<p>堆是一个完全二叉树，特点是<strong>每个节点的值都大于或等于其左右孩子节点的值，称为大顶堆；或者每个节点的值都小于或等于其左右孩子节点的值，称为小顶堆</strong>。<p>堆排序逻辑如下：<ol><li>将无序序列构建成一个堆，根据 升序/降序 需求 选择 小顶堆或大顶堆；<li>将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端；<li>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序；</ol><p>堆排序时间复杂度：<ul><li>平均时间复杂度：O(nlogn)<li>最好情况：O(nlogn)<li>最坏情况：O(nlogn)<li>空间复杂度：O(1)<li>稳定性：不稳定</ul><h4 id=1-1-1-3、交换排序><a class=headerlink href=#1-1-1-3、交换排序 title=1.1.1.3、交换排序></a>1.1.1.3、交换排序</h4><p><strong>（1）冒泡排序</strong><p>其逻辑是比较相邻的元素。如果第一个比第二个大，就交换他们两个。<p><strong>（2）快速排序</strong><p>快速排序是一种 排序执行效率很高的 排序算法，它利用分治法来对待排序序列进行分治排序。<p>它的思想是：以最后一位数字为关键字，拿待排序数组中的每个元素对比关键字进行一趟排序将待排记录分隔成独立的两部分，其中的一部分比关键字小，后面一部分比关键字大，然后再对这前后的两部分分别采用这种方式进行排序，通过递归的运算最终达到整个序列有序。<blockquote><p>快排之所以被称为“快”排，是因为它的平均时间是最短的，主要原因是硬件方面的，每趟快排需要指定一个“支点”（也就是作为分界点的值），一趟中涉及的所有比较都是与这个“支点”来进行比较的，那么我们可以把这个“支点”放在寄存器里，如此这般，效率自然大大提高。除此之外，快排的高效率与分治思想也是分不开的。</blockquote><h4 id=1-1-1-4、归并排序><a class=headerlink href=#1-1-1-4、归并排序 title=1.1.1.4、归并排序></a>1.1.1.4、归并排序</h4><p><strong>归并排序基于分治法</strong>，其思想是将待排序的元素序列分成两个相等的子序列，然后将子序列再次分割为两个子序列，一直分割到一个序列只有一个元素为止。然后比较相邻两个子序列中数据大小，将小的放左边，大的放右边，并将之合并为一个序列，以此类推，直到合并完成为止。<p><img alt=image-20200921145201640 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200921145201640.png?token=AIGEF3L2CI465XXEYEKL7IDEZZWVM><h4 id=1-1-1-5、基数排序><a class=headerlink href=#1-1-1-5、基数排序 title=1.1.1.5、基数排序></a>1.1.1.5、基数排序</h4><p>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，从而达到排序的作用，基数排序法是属于稳定性的排序。<h3 id=1-1-2、外部排序><a class=headerlink href=#1-1-2、外部排序 title=1.1.2、外部排序></a>1.1.2、外部排序</h3><h2 id=1-2、查找算法><a class=headerlink href=#1-2、查找算法 title=1.2、查找算法></a>1.2、查找算法</h2><p>Java中常用的查找算法有四种。<h3 id=1-2-1、顺序（线性）查找><a class=headerlink href=#1-2-1、顺序（线性）查找 title=1.2.1、顺序（线性）查找></a>1.2.1、顺序（线性）查找</h3><h3 id=1-2-2、二分查找><a class=headerlink href=#1-2-2、二分查找 title=1.2.2、二分查找></a>1.2.2、二分查找</h3><p>每次拿到待查找元素数组的中间元素值且将数组分成两半（左半和右半），然后拿查找值与中间元素值比较，大了就以右半数组为基础做相同操作，小了就以左半数组为基础做相同操作，以此类推，直到找到为止。<h3 id=1-2-3、插值查找><a class=headerlink href=#1-2-3、插值查找 title=1.2.3、插值查找></a>1.2.3、插值查找</h3><p>二分查找的升级版，升级地方为求中间元素值的公式。<ul><li><p>二分查找 获取中间元素值的公式为：int mid = (left + right) / 2;</p><li><p>插值查找 获取中间元素值的公式为：int mid = left + (right - left)*(findVal - arr[left]) / (arr[right] - arr[left]);</p></ul><h3 id=1-2-4、斐波那契查找（黄金分割点查找）><a class=headerlink href=#1-2-4、斐波那契查找（黄金分割点查找） title=1.2.4、斐波那契查找（黄金分割点查找）></a>1.2.4、斐波那契查找（黄金分割点查找）</h3><p>其原理与前两种类似，仅仅<strong>改变了中间元素（mid）的位置</strong>，mid不再是中间或插值得到，而是位于黄金分割点附近，即：mid = low + F(k - 1) - 1; F代表斐波那契数列。<blockquote><p>斐波那契数列：{1,1,2,3,5,8,13,21,34,55}，发现数列的两个相邻数的比例无限接近0.618。</blockquote><h2 id=1-3、常用算法><a class=headerlink href=#1-3、常用算法 title=1.3、常用算法></a>1.3、常用算法</h2><h3 id=1-3-1、二分查找算法（非递归，关键字匹配）><a class=headerlink href=#1-3-1、二分查找算法（非递归，关键字匹配） title=1.3.1、二分查找算法（非递归，关键字匹配）></a>1.3.1、二分查找算法（非递归，关键字匹配）</h3><h4 id=1-3-1-1、简介><a class=headerlink href=#1-3-1-1、简介 title=1.3.1.1、简介></a>1.3.1.1、简介</h4><p><strong>二分查找也称 折半查找（Binary Search），是一种效率较高的查找方法</strong>。折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。该算法时间复杂度可以表示O(h)=O(log2n)。<p>首先，假设表中元素是按升序排列，将表中间位置记录的<a href=https://baike.baidu.com/item/%E5%85%B3%E9%94%AE%E5%AD%97 rel=noopener target=_blank>关键字</a>与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的<a href=https://baike.baidu.com/item/%E8%AE%B0%E5%BD%95/1837758 rel=noopener target=_blank>记录</a>，使查找成功，或直到子表不存在为止，此时查找不成功。<h4 id=1-3-1-2、代码实现><a class=headerlink href=#1-3-1-2、代码实现 title=1.3.1.2、代码实现></a>1.3.1.2、代码实现</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=type>int</span> <span class="title function_">binarySearch</span><span class=params>(Integer[] srcArray, <span class=type>int</span> des)</span> {</span><br><span class=line>    <span class=comment>//定义初始最小、最大索引</span></span><br><span class=line>    <span class=type>int</span> <span class=variable>start</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=type>int</span> <span class=variable>end</span> <span class=operator>=</span> srcArray.length - <span class=number>1</span>;</span><br><span class=line>    <span class=comment>//确保不会出现重复查找，越界</span></span><br><span class=line>    <span class=keyword>while</span> (start <= end) {</span><br><span class=line>        <span class=comment>//计算出中间索引值</span></span><br><span class=line>        <span class=type>int</span> <span class=variable>middle</span> <span class=operator>=</span> (end + start)>>><span class=number>1</span> ;<span class=comment>//防止溢出</span></span><br><span class=line>        <span class=keyword>if</span> (des == srcArray[middle]) {</span><br><span class=line>            <span class=keyword>return</span> middle;</span><br><span class=line>        <span class=comment>//判断下限</span></span><br><span class=line>        } <span class=keyword>else</span> <span class=keyword>if</span> (des < srcArray[middle]) {</span><br><span class=line>            end = middle - <span class=number>1</span>;</span><br><span class=line>        <span class=comment>//判断上限</span></span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            start = middle + <span class=number>1</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>//若没有，则返回-1</span></span><br><span class=line>    <span class=keyword>return</span> -<span class=number>1</span>;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-3-2、分治算法><a class=headerlink href=#1-3-2、分治算法 title=1.3.2、分治算法></a>1.3.2、分治算法</h3><h4 id=1-3-2-1、简介><a class=headerlink href=#1-3-2-1、简介 title=1.3.2.1、简介></a>1.3.2.1、简介</h4><p>分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解就可得到原问题的解。即一种分割目标完成计算的算法，简单问题可用二分法完成。<h4 id=1-3-2-2、解题步骤><a class=headerlink href=#1-3-2-2、解题步骤 title=1.3.2.2、解题步骤></a>1.3.2.2、解题步骤</h4><p>分治法解题的一般步骤：<ol><li>分解，将要解决的问题划分成若干规模较小的同类问题；<li>求解，当子问题划分得足够小时，用较简单的方法解决；<li>合并，按原问题的要求，将子问题的解逐层合并构成原问题的解。</ol><h4 id=1-3-2-3、应用场景><a class=headerlink href=#1-3-2-3、应用场景 title=1.3.2.3、应用场景></a>1.3.2.3、应用场景</h4><p>运用分治策略解决的问题一般来说具有以下特点：<ol><li><p>原问题可以分解为多个子问题：</p> <p>这些子问题与原问题相比，只是问题的规模有所降低，其结构和求解方法与原问题相同或相似。</p><li><p>原问题在分解过程中，递归地求解子问题：</p> <p>由于递归都必须有一个终止条件，因此，当分解后的子问题规模足够小时，应能够直接求解。</p><li><p>在求解并得到各个子问题的解后：</p> <p>应能够采用某种方式、方法合并或构造出原问题的解。</p></ol><p>在分治策略中，由于子问题与原问题在结构和解法上的相似性，用分治方法解决的问题，大都采用了递归的形式。在各种排序方法中，如归并排序、堆排序、快速排序等，都存在有分治的思想。<h3 id=1-3-3、动态规划算法（求最优决策）><a class=headerlink href=#1-3-3、动态规划算法（求最优决策） title=1.3.3、动态规划算法（求最优决策）></a>1.3.3、动态规划算法（求最优决策）</h3><h4 id=13-3-1、简介><a class=headerlink href=#13-3-1、简介 title=13.3.1、简介></a>13.3.1、简介</h4><p>动态规划（Dynamic Programming，DP）是<a href=https://baike.baidu.com/item/%E8%BF%90%E7%AD%B9%E5%AD%A6/1559 rel=noopener target=_blank>运筹学</a>的一个分支，是求解<a href=https://baike.baidu.com/item/%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B/6714639 rel=noopener target=_blank>决策过程</a>最优化的过程。20世纪50年代初，美国数学家<a href=https://baike.baidu.com/item/%E8%B4%9D%E5%B0%94%E6%9B%BC/9239579 rel=noopener target=_blank>贝尔曼</a>（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的 最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等中取得了显著的效果。<p><strong>动态规划算法通常用于求解具有某种最优性质的问题</strong>。动态规划算法与<a href=https://baike.baidu.com/item/%E5%88%86%E6%B2%BB%E6%B3%95 rel=noopener target=_blank>分治法</a>类似，基本思想是 将待求解问题分解成若干个子问题，先求解子问题，然后根据 子问题的解 得到 原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。<h4 id=1-3-3-2、局限性><a class=headerlink href=#1-3-3-2、局限性 title=1.3.3.2、局限性></a>1.3.3.2、局限性</h4><p>动态规划对于解决多阶段决策问题的效果很明显，但是动态规划也有一定的局限性。首先，它没有统一的处理方法，必须根据问题的各种性质并结合一定的技巧来处理；另外当变量的维数增大时，总的计算量及存贮量急剧增大。因而，受计算机的存贮量及计算速度的限制，当今的计算机仍不能用动态规划方法来解决较大规模的问题，这就是“维数障碍”。<h3 id=1-3-4、暴力匹配算法（字符串匹配）><a class=headerlink href=#1-3-4、暴力匹配算法（字符串匹配） title=1.3.4、暴力匹配算法（字符串匹配）></a>1.3.4、暴力匹配算法（字符串匹配）</h3><h4 id=1-3-4-1、简介><a class=headerlink href=#1-3-4-1、简介 title=1.3.4.1、简介></a>1.3.4.1、简介</h4><p>暴力匹配的思想：假设下标<code>i</code>指向字符串<code>str1</code>，下标<code>j</code>指向字符串<code>str2</code>，则有如下规律：<ol><li>如果str1[i] = str2[j]，则i++，j++。<li>如果str1[i] != str2[j]，则令i = i - (j - 1)，j = 0。</ol><h4 id=1-3-4-2、缺点><a class=headerlink href=#1-3-4-2、缺点 title=1.3.4.2、缺点></a>1.3.4.2、缺点</h4><p><strong>暴力破解会有大量的回溯</strong>，每次只移动一位，若不匹配则移动到下一位接着判断，浪费了大量时间。为了优化就诞生了KMP算法。<h3 id=1-3-5、KMP算法（字符串匹配）><a class=headerlink href=#1-3-5、KMP算法（字符串匹配） title=1.3.5、KMP算法（字符串匹配）></a>1.3.5、KMP算法（字符串匹配）</h3><h4 id=1-3-5-1、简介><a class=headerlink href=#1-3-5-1、简介 title=1.3.5.1、简介></a>1.3.5.1、简介</h4><p><strong>KMP算法是一种改进的字符串匹配算法</strong>，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的 时间复杂度为 <code>O(m+n) [1]</code> 。<h4 id=1-3-5-2、模式匹配类型><a class=headerlink href=#1-3-5-2、模式匹配类型 title=1.3.5.2、模式匹配类型></a>1.3.5.2、模式匹配类型</h4><ol><li>精确匹配<li>近似匹配</ol><h4 id=1-3-5-3、部分匹配表><a class=headerlink href=#1-3-5-3、部分匹配表 title=1.3.5.3、部分匹配表></a>1.3.5.3、部分匹配表</h4><p><img alt=image-20200919141327620 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200919141327620.png?token=AIGEF3JMQBUJFREE6ZNIL5DEZZWXE><p>由表可得：移动位数 = 已匹配的字符数 + 对应的部分匹配值。<h3 id=1-3-6、贪心算法（局部最优解）><a class=headerlink href=#1-3-6、贪心算法（局部最优解） title=1.3.6、贪心算法（局部最优解）></a>1.3.6、贪心算法（局部最优解）</h3><h4 id=1-3-6-1、简介><a class=headerlink href=#1-3-6-1、简介 title=1.3.6.1、简介></a>1.3.6.1、简介</h4><p><strong>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解</strong>。<p>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择。也就是说，不从整体最优上加以考虑，做出的只是在某种意义上的局部最优解。<h3 id=1-3-7、普利姆算法（Prim，稠密图最小生成树）><a class=headerlink href=#1-3-7、普利姆算法（Prim，稠密图最小生成树） title=1.3.7、普利姆算法（Prim，稠密图最小生成树）></a>1.3.7、普利姆算法（Prim，稠密图最小生成树）</h3><h4 id=1-3-7-1、简介><a class=headerlink href=#1-3-7-1、简介 title=1.3.7.1、简介></a>1.3.7.1、简介</h4><p>普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图。<p>例如，通过普里姆算法查找下图的最小生成树的步骤为：<ol><li><p>假如从顶点A出发，顶点 B、C、D 到顶点 A 的权值分别为 2、4、2，所以，对于顶点 A 来说，顶点 B 和顶点 D 到 A 的权值最小，假设先找到的顶点 B：</p> <p><img alt=image-20200920084320304 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200920084320304.png?token=AIGEF3IZHFXIYNI4L5HLUBLEZZWYU></p><li><p>继续分析顶点 C 和 D，顶点 C 到 B 的权值为 3，到 A 的权值为 4；顶点 D 到 A 的权值为 2，到 B 的权值为无穷大（如果之间没有直接通路，设定权值为无穷大）。所以顶点 D 到 A 的权值最小：</p> <p><img alt=image-20200920084352501 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200920084352501.png?token=AIGEF3LLQKIYVMKSWL5RUP3EZZWZY></p><li><p>最后，只剩下顶点 C，到 A 的权值为 4，到 B 的权值和到 D 的权值一样大，为 3。所以该连通图有两个最小生成树：</p> <p><img alt=image-20200920084435924 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200920084435924.png?token=AIGEF3OD2D3UJQXOLJPN4MDEZZW3O></p></ol><h4 id=1-3-7-2、总结><a class=headerlink href=#1-3-7-2、总结 title=1.3.7.2、总结></a>1.3.7.2、总结</h4><p>普利姆算法求最小生成树，是从顶点方面考虑，存在两重遍历(已访问顶点集和未访问顶点集)，对应的还有一个克鲁斯卡尔算法求最小生成树，是从边的角度出发考虑的。根据各自算法特性，可以粗略的判断出，把稠密图看作边集相对于点集数量级比较大，稀疏图看作点集相对于边集较大，则普利姆算法适合于计算稠密图，克鲁斯卡尔算法适合于计算稀疏图。<h3 id=1-3-8、克鲁斯卡尔算法（Kruskal，稀疏图最小生成树）><a class=headerlink href=#1-3-8、克鲁斯卡尔算法（Kruskal，稀疏图最小生成树） title=1.3.8、克鲁斯卡尔算法（Kruskal，稀疏图最小生成树）></a>1.3.8、克鲁斯卡尔算法（Kruskal，稀疏图最小生成树）</h3><h4 id=1-3-8-1、简介><a class=headerlink href=#1-3-8-1、简介 title=1.3.8.1、简介></a>1.3.8.1、简介</h4><p><strong>克鲁斯卡尔算法是求连通网的最小生成树的另一种方法</strong>。与普里姆算法不同，它的时间复杂度为O（e loge）（e为网中的边数），所以，适合于求边稀疏的网的最小生成树 [1] 。<h4 id=1-3-8-2、基本思想><a class=headerlink href=#1-3-8-2、基本思想 title=1.3.8.2、基本思想></a>1.3.8.2、基本思想</h4><p>克鲁斯卡尔（Kruskal）算法从另一途径求网的最小生成树。其基本思想是：假设连通网G=（V，E），令最小生成树的初始状态为只有n个顶点而无边的非连通图T=（V，{}），图中每个顶点自成一个连通分量。在E中选择代价最小的边，若该边依附的顶点分别在T中不同的连通分量上，则将此边加入到T中；否则，舍去此边而选择下一条代价最小的边。依此类推，直至T中所有顶点构成一个连通分量为止 [2] 。<h3 id=1-3-9、迪杰斯特拉算法（Dijkstra，最短路径）><a class=headerlink href=#1-3-9、迪杰斯特拉算法（Dijkstra，最短路径） title=1.3.9、迪杰斯特拉算法（Dijkstra，最短路径）></a>1.3.9、迪杰斯特拉算法（Dijkstra，最短路径）</h3><h4 id=1-3-9-1、简介><a class=headerlink href=#1-3-9-1、简介 title=1.3.9.1、简介></a>1.3.9.1、简介</h4><p>迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家<a href=https://baike.baidu.com/item/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89/2828872 rel=noopener target=_blank>狄克斯特拉</a>于1959 年提出，因此又叫<a href=https://baike.baidu.com/item/%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/6764865 rel=noopener target=_blank>狄克斯特拉算法</a>。是从一个顶点到其余各顶点的<a href=https://baike.baidu.com/item/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84 rel=noopener target=_blank>最短路径</a>算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是从起始点开始，采用<a href=https://baike.baidu.com/item/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/5411800 rel=noopener target=_blank>贪心算法</a>的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。<p>Dijkstra算法通常有两种方式，一种用永久和临时标号方式，一种是用OPEN、CLOSE表的方式，这里均采用永久和临时标号方式。注意该算法要求图中不存在负权边。<h3 id=1-3-10、弗洛伊德算法（Floyd，最短路径）><a class=headerlink href=#1-3-10、弗洛伊德算法（Floyd，最短路径） title=1.3.10、弗洛伊德算法（Floyd，最短路径）></a>1.3.10、弗洛伊德算法（Floyd，最短路径）</h3><h4 id=1-3-10-1、简介><a class=headerlink href=#1-3-10-1、简介 title=1.3.10.1、简介></a>1.3.10.1、简介</h4><p><strong>Floyd算法又称为插点法</strong>，是一种利用<a href=https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408 rel=noopener target=_blank>动态规划</a>思想寻找给定<a href=https://baike.baidu.com/item/%E5%8A%A0%E6%9D%83%E5%9B%BE/10579361 rel=noopener target=_blank>加权图</a>中多源点之间<a href=https://baike.baidu.com/item/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/6334920 rel=noopener target=_blank>最短路径</a>的算法，与Dijkstra算法类似。该算法名称以创始人之一、1978年<a href=https://baike.baidu.com/item/%E5%9B%BE%E7%81%B5%E5%A5%96/324645 rel=noopener target=_blank>图灵奖</a>获得者、斯坦福大学计算机科学系教授<a href=https://baike.baidu.com/item/%E7%BD%97%E4%BC%AF%E7%89%B9%C2%B7%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7/4903135 rel=noopener target=_blank>罗伯特·弗洛伊德</a>命名。<p>该算法也称为Floyd算法，Roy-Warshall算法，Roy-Floyd算法或WFI算法。<h4 id=1-3-10-2、算法过程><a class=headerlink href=#1-3-10-2、算法过程 title=1.3.10.2、算法过程></a>1.3.10.2、算法过程</h4><ol><li>从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。<li>对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比已知的路径更短。如果是更新它。</ol><h4 id=1-3-10-3、时间-空间复杂度><a class=headerlink href=#1-3-10-3、时间-空间复杂度 title=1.3.10.3、时间/空间复杂度></a>1.3.10.3、时间/空间复杂度</h4><ul><li>时间复杂度：O(n^3)；<li>空间复杂度：O(n^2)；</ul><h4 id=1-3-10-4、优缺点><a class=headerlink href=#1-3-10-4、优缺点 title=1.3.10.4、优缺点></a>1.3.10.4、优缺点</h4><p>Floyd算法适用于APSP(All Pairs Shortest Paths，多源最短路径)，是一种动态规划算法，稠密图效果最佳，边权可正可负。此算法简单有效，由于三重循环结构紧凑，对于稠密图，效率要高于执行|V|次<a href=https://baike.baidu.com/item/Dijkstra%E7%AE%97%E6%B3%95 rel=noopener target=_blank>Dijkstra算法</a>，也要高于执行|V|次<a href=https://baike.baidu.com/item/SPFA%E7%AE%97%E6%B3%95 rel=noopener target=_blank>SPFA算法</a>。<ul><li>优点：容易理解，可以算出任意两个节点之间的最短距离，代码编写简单。<li>缺点：时间复杂度比较高，不适合计算大量数据。</ul><h3 id=1-3-11、骑士周游回溯算法><a class=headerlink href=#1-3-11、骑士周游回溯算法 title=1.3.11、骑士周游回溯算法></a>1.3.11、骑士周游回溯算法</h3><h4 id=1-3-11-1、简介><a class=headerlink href=#1-3-11-1、简介 title=1.3.11.1、简介></a>1.3.11.1、简介</h4><p>深度优先遍历+回溯+贪心。从初始位置startPoint开始，获取下一步能到达的所有位置，将它们添加到集合ArrayList< Point >中，根据它们下一步所能到达的位置的个数k对ArrayList< Point >中所有位置进行非递减排序，优先对k较小的位置进行遍历，若此路不通，则回溯。<h2 id=1-4、算法复杂度><a class=headerlink href=#1-4、算法复杂度 title=1.4、算法复杂度></a>1.4、算法复杂度</h2><h3 id=1-4-1、时间复杂度><a class=headerlink href=#1-4-1、时间复杂度 title=1.4.1、时间复杂度></a>1.4.1、时间复杂度</h3><p>度量一个程序执行时间的方法有两种：<ol><li>事前估算法<li>事后统计法</ol><h4 id=1-4-1-1、时间频度><a class=headerlink href=#1-4-1-1、时间频度 title=1.4.1.1、时间频度></a>1.4.1.1、时间频度</h4><p>**一个算法中语句执行次数称为 语句频度 或 时间频度，记为T(n)**。<h4 id=1-4-1-2、时间复杂度表示><a class=headerlink href=#1-4-1-2、时间复杂度表示 title=1.4.1.2、时间复杂度表示></a>1.4.1.2、时间复杂度表示</h4><ol><li>O(1)：常数时间，不论输入的数据规模有多大，算法都具有恒定的执行时间。<li>O(log n)：对数阶，二分搜索是一个该复杂度的一个经典例子。<li>O(n)：线性阶：数据的输入与算法的执行时间成正比。<li>O(n*log n)：线性对数阶，常见排序算法（归并、快排）都在该复杂度内。<li>O(n^2)：平方阶，嵌套循环通常会导致该复杂度。<li>O(n^3)：立方阶。<li>O(n^k)：k次方阶。<li>O(2^n)：指数时间。<li>O(n!)：阶乘时间。</ol><p><img alt=算法时间复杂度01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A601.jpg?token=AIGEF3PJUNGHWIOJSSI2YZ3EZZW5K><h3 id=1-4-2、空间复杂度><a class=headerlink href=#1-4-2、空间复杂度 title=1.4.2、空间复杂度></a>1.4.2、空间复杂度</h3><h4 id=1-4-2-1、简介><a class=headerlink href=#1-4-2-1、简介 title=1.4.2.1、简介></a>1.4.2.1、简介</h4><p>空间复杂度描述了算法在执行过程中额外使用的内存空间与输入数据量之间的关系。<p>1.4.2.2、空间复杂度类型<ul><li>O(1)：常量空间。算法使用固定规模的额外空间。<li>O(log n)：递归二分搜索中，堆栈调用深度是log n。<li>O(n)：线性空间。</ul><h3 id=1-4-3、Big-O><a title="1.4.3、Big O" class=headerlink href=#1-4-3、Big-O></a>1.4.3、Big O</h3><p><strong>Big O是描述算法复杂度的标号，通常使用Big O描述最坏情况下的运行时间或所需空间</strong>。<p><strong>Big O表示法的核心思想是关注主要部分，忽略常数、低次项等</strong>。比如，如果一个算法执行时间为 3n^2+4n+15，我们通常会说它的运行时间为O(n^2)，因为当n足够大时，低此项和常数的影响将变得微不足道。<p>Big O表示法为我们提供了一种评估算法效率的高级视角，使得我们能够快速比较不同算法在处理大数据量时的性能。<h3 id=1-4-4、总结><a class=headerlink href=#1-4-4、总结 title=1.4.4、总结></a>1.4.4、总结</h3><h4 id=排序算法-时间-空间复杂度-对比><a title="排序算法 时间/空间复杂度 对比" class=headerlink href=#排序算法-时间-空间复杂度-对比></a>排序算法 时间/空间复杂度 对比</h4><p><img alt=排序算法时间空间复杂度01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A601.jpg?token=AIGEF3PCPFPUYKDIWGS3GKLEZZW7E><h1 id=2、数据结构><a class=headerlink href=#2、数据结构 title=2、数据结构></a>2、数据结构</h1><h2 id=2-1、简介><a class=headerlink href=#2-1、简介 title=2.1、简介></a>2.1、简介</h2><p>其英文称为：Data Structure，其表示存储数据的不同方式。<h2 id=2-2、分类><a class=headerlink href=#2-2、分类 title=2.2、分类></a>2.2、分类</h2><p>数据结构分为 <strong>线性结构 和 非线性结构</strong> 两大类。<h3 id=2-2-1、线性结构><a class=headerlink href=#2-2-1、线性结构 title=2.2.1、线性结构></a>2.2.1、线性结构</h3><p><strong>线性结构的特点是数据元素之间存在一对一的线性关系</strong>。即除了第一个和最后一个元素外，每个元素都有一个前驱和后继。<p>线性结构有两种存储结构：<ol><li><p>顺序存储结构：顺序存储的线性表称为顺序表，其中的元素是连续的：</p><li><p>链式存储结构：链式存储的线性表称为链表，其中的元素不一定是连续的，元素节点存放数据及相邻节点的地址信息：</p></ol><p>线性结构常见实现有：<ul><li><p><font color=orange>数组</font></p><li><p><font color=orange>队列</font>：队列是一个有序列表，遵循FIFO规则，可以用数组或链表来实现。</p> <p>队列是一种特殊操作受限的线性表，它只允许在表的前端（front，队头）执行删除操作，而在表的后端（rear，队尾）执行插入操作。</p> <p>队列中没有元素时，称为空队列。</p> <p>创建顺序队列结构必须为其静态分配或动态申请一片连续的存储空间，并设置两个指针进行管理。一个是队头指针front，它指向队头元素；另一个是队尾指针rear，它指向下一个入队元素的存储位置。</p> <p>队列采用FIFO(first in first out——先进先出)，数据插入到链表尾部，从头部开始读取数据。每次读取一个元素，释放一个元素。所谓的动态创建，动态释放。因而也不存在溢出等问题。由于链表由结构体间接而成，遍历也方便。（先进先出）。</p><li><p><font color=orange>链表</font></p><li><p><font color=orange>栈</font></p></ul><h3 id=2-2-2、非线性结构><a class=headerlink href=#2-2-2、非线性结构 title=2.2.2、非线性结构></a>2.2.2、非线性结构</h3><p><strong>非线性结构的特点是每个元素可能与多个其它元素连接，不仅仅是线性结构中的前驱和后继</strong>。<p>非线性结构通常使用指针或链接来表示元素之间的关系。<p>非线性结构常见实现有：<ol><li><p><font color=orange>树结构</font></p> <ol><li><p>二叉树</p> <ol><li><p>满二叉树：所有叶子节点都在同一层的二叉树称为：满二叉树。</p><li><p>完全二叉树：所有叶子节点在最后一层或者倒数第二层，且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，则我们称这样的二叉树为：完全二叉树。</p></ol><li><p>AVL树</p></ol><li><p><font color=orange>图结构</font></p></ol><h1 id=3、常见问题及应对><a class=headerlink href=#3、常见问题及应对 title=3、常见问题及应对></a>3、常见问题及应对</h1><h2 id=3-1、修路问题><a class=headerlink href=#3-1、修路问题 title=3.1、修路问题></a>3.1、修路问题</h2><p>最小生成树 + 普利姆算法<h2 id=3-2、最短路径问题><a class=headerlink href=#3-2、最短路径问题 title=3.2、最短路径问题></a>3.2、最短路径问题</h2><p>图 + 弗洛伊德算法<h2 id=3-3、汉诺塔问题><a class=headerlink href=#3-3、汉诺塔问题 title=3.3、汉诺塔问题></a>3.3、汉诺塔问题</h2><p>使用<strong>递归法</strong>可解决该问题。<p>汉诺塔问题是一个益智游戏，通常由3个柱子和一系列递减大小的盘子组成。初始时，所有盘子都在一个柱子上，目标是将它们移动到另一个柱子上，移动过程需要遵循两个规则：<ol><li>每次只能移动一个盘子。<li>大盘子不能放在小盘子上面。</ol><h2 id=3-4、八皇后问题><a class=headerlink href=#3-4、八皇后问题 title=3.4、八皇后问题></a>3.4、八皇后问题</h2><p>使用<strong>回溯法</strong>可解决该问题。<p>八皇后问题是一个经典问题，要求在8x8的棋盘上放置8个皇后，规则就是任何两个皇后都不能存在于同一行、同一列、同一对角线上。可以使用回溯法来解决这种问题。</div><footer class=post-footer><div class=post-tags><a href=/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ rel=tag># 数据结构</a><a href=/tags/%E7%AE%97%E6%B3%95/ rel=tag># 算法</a></div><div class=post-nav><div class=post-nav-item><a href=/2024/08/21/%E6%A0%91%E5%9E%8B%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ rel=prev title=数据与算法系列-树结构> <i class="fa fa-angle-left"></i> 数据与算法系列-树结构 </a></div><div class=post-nav-item><a href=/2024/08/21/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93/ rel=next title=消息队列系列-消息队列框架对比> 消息队列系列-消息队列框架对比 <i class="fa fa-angle-right"></i> </a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script>