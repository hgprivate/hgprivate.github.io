<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hgprivate.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content="1、 RabbitMQ概述1.1、何为RabbitMQRabbitMQ是一种开源的消息队列软件，它实现了高级消息队列协议 AMQP 的标准。它是一种可靠、灵活和可扩展的消息队列，用于在应用程序之间进行异步消息传递。 1.2、用户1.2.1、用户角色用户角色有如下几种：  administrator：用户可以做监控所能做的一切，管理用户、vhosts和权限，关闭其他用户的连接，并管理所有vhosts" name=description><meta content=article property=og:type><meta content=RabbitMQ系列-RabbitMQ基础应用 property=og:title><meta content=https://hgprivate.github.io/2024/08/21/RabbitMQ%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content="1、 RabbitMQ概述1.1、何为RabbitMQRabbitMQ是一种开源的消息队列软件，它实现了高级消息队列协议 AMQP 的标准。它是一种可靠、灵活和可扩展的消息队列，用于在应用程序之间进行异步消息传递。 1.2、用户1.2.1、用户角色用户角色有如下几种：  administrator：用户可以做监控所能做的一切，管理用户、vhosts和权限，关闭其他用户的连接，并管理所有vhosts" property=og:description><meta content=zh_CN property=og:locale><meta content=2024-08-21T13:39:14.403Z property=article:published_time><meta content=2023-10-02T13:00:52.603Z property=article:modified_time><meta content=豪哥 property=article:author><meta content=RabbitMQ property=article:tag><meta content=RabbitMQ基础 property=article:tag><meta content=summary name=twitter:card><link href=https://hgprivate.github.io/2024/08/21/RabbitMQ%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://hgprivate.github.io/2024/08/21/RabbitMQ%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/","path":"2024/08/21/RabbitMQ基础入门/","title":"RabbitMQ系列-RabbitMQ基础应用"}</script><script class=next-config data-name=calendar type=application/json>""</script><title>RabbitMQ系列-RabbitMQ基础应用 | 豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <p class=site-title>豪哥博客</p> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#1%E3%80%81-RabbitMQ%E6%A6%82%E8%BF%B0><span class=nav-number>1.</span> <span class=nav-text>1、 RabbitMQ概述</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#1-1%E3%80%81%E4%BD%95%E4%B8%BARabbitMQ><span class=nav-number>1.1.</span> <span class=nav-text>1.1、何为RabbitMQ</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#1-2%E3%80%81%E7%94%A8%E6%88%B7><span class=nav-number>1.2.</span> <span class=nav-text>1.2、用户</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-1%E3%80%81%E7%94%A8%E6%88%B7%E8%A7%92%E8%89%B2><span class=nav-number>1.2.1.</span> <span class=nav-text>1.2.1、用户角色</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-2-2%E3%80%81%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90><span class=nav-number>1.2.2.</span> <span class=nav-text>1.2.2、用户权限</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-3%E3%80%81%E4%BA%A4%E6%8D%A2%E6%9C%BA><span class=nav-number>1.3.</span> <span class=nav-text>1.3、交换机</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-1%E3%80%81%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%B1%BB%E5%9E%8B><span class=nav-number>1.3.1.</span> <span class=nav-text>1.3.1、交换机类型</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-2%E3%80%81%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%8F%82%E6%95%B0><span class=nav-number>1.3.2.</span> <span class=nav-text>1.3.2、交换机参数</span></a></ol><li class="nav-item nav-level-2"><a class=nav-link href=#1-3%E3%80%81%E9%98%9F%E5%88%97><span class=nav-number>1.4.</span> <span class=nav-text>1.3、队列</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#1-3-1%E3%80%81%E9%98%9F%E5%88%97%E5%8F%82%E6%95%B0><span class=nav-number>1.4.1.</span> <span class=nav-text>1.3.1、队列参数</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#2%E3%80%81%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7><span class=nav-number>2.</span> <span class=nav-text>2、高级特性</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#2-1%E3%80%81TTL><span class=nav-number>2.1.</span> <span class=nav-text>2.1、TTL</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-2%E3%80%81%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97><span class=nav-number>2.2.</span> <span class=nav-text>2.2、死信队列</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-3%E3%80%81%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97><span class=nav-number>2.3.</span> <span class=nav-text>2.3、延迟队列</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-4%E3%80%81%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97><span class=nav-number>2.4.</span> <span class=nav-text>2.4、惰性队列</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-5%E3%80%81%E4%BB%B2%E8%A3%81%E9%98%9F%E5%88%97><span class=nav-number>2.5.</span> <span class=nav-text>2.5、仲裁队列</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-6%E3%80%81%E5%A4%87%E4%BB%BD%E4%BA%A4%E6%8D%A2%E6%9C%BA><span class=nav-number>2.6.</span> <span class=nav-text>2.6、备份交换机</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-7%E3%80%81%E6%97%A5%E5%BF%97%E4%B8%8E%E7%9B%91%E6%8E%A7><span class=nav-number>2.7.</span> <span class=nav-text>2.7、日志与监控</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-8%E3%80%81%E6%B6%88%E6%81%AF%E8%BF%BD%E8%B8%AA><span class=nav-number>2.8.</span> <span class=nav-text>2.8、消息追踪</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#2-9%E3%80%81%E7%AE%A1%E7%90%86><span class=nav-number>2.9.</span> <span class=nav-text>2.9、管理</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#3%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8><span class=nav-number>3.</span> <span class=nav-text>3、高可用</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#3-1%E3%80%81%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7><span class=nav-number>3.1.</span> <span class=nav-text>3.1、消息可靠性</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-1%E3%80%81%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96><span class=nav-number>3.1.1.</span> <span class=nav-text>3.1.1、数据持久化</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-2%E3%80%81%E7%94%9F%E4%BA%A7%E7%AB%AF%E7%A1%AE%E8%AE%A4><span class=nav-number>3.1.2.</span> <span class=nav-text>3.1.2、生产端确认</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-3%E3%80%81%E6%B6%88%E8%B4%B9%E7%AB%AF%E7%A1%AE%E8%AE%A4><span class=nav-number>3.1.3.</span> <span class=nav-text>3.1.3、消费端确认</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-4%E3%80%81%E6%B6%88%E8%B4%B9%E7%AB%AF%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95><span class=nav-number>3.1.4.</span> <span class=nav-text>3.1.4、消费端失败重试</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-5%E3%80%81%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%99%90%E6%B5%81><span class=nav-number>3.1.5.</span> <span class=nav-text>3.1.5、消费端限流</span></a><li class="nav-item nav-level-3"><a class=nav-link href=#3-1-6%E3%80%81%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF><span class=nav-number>3.1.6.</span> <span class=nav-text>3.1.6、消息堆积</span></a></ol></ol><li class="nav-item nav-level-1"><a class=nav-link href=#3%E3%80%81%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98><span class=nav-number>4.</span> <span class=nav-text>3、应用问题</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#3-1%E3%80%81%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E9%9A%9C><span class=nav-number>4.1.</span> <span class=nav-text>3.1、消息可靠性保障</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-2%E3%80%81%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89%E6%80%A7%E4%BF%9D%E9%9A%9C><span class=nav-number>4.2.</span> <span class=nav-text>3.2、消息幂等性保障</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#3-3%E3%80%81%E9%9B%86%E7%BE%A4%E9%97%AE%E9%A2%98><span class=nav-number>4.3.</span> <span class=nav-text>3.3、集群问题</span></a><ol class=nav-child><li class="nav-item nav-level-3"><a class=nav-link href=#3-3-1%E3%80%81%E6%99%AE%E9%80%9A%E9%9B%86%E7%BE%A4><span class=nav-number>4.3.1.</span> <span class=nav-text>3.3.1、普通集群</span></a></ol></ol></ol></div></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>117</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>36</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>129</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article lang=zh-CN><link href=https://hgprivate.github.io/2024/08/21/RabbitMQ%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="RabbitMQ系列-RabbitMQ基础应用 | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h1 itemprop="name headline" class=post-title>RabbitMQ系列-RabbitMQ基础应用</h1><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 21:00:52" datetime=2023-10-02T21:00:52+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/RabbitMQ/ itemprop=url rel=index><span itemprop=name>RabbitMQ</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、-RabbitMQ概述><a title="1、 RabbitMQ概述" class=headerlink href=#1、-RabbitMQ概述></a>1、 RabbitMQ概述</h1><h2 id=1-1、何为RabbitMQ><a class=headerlink href=#1-1、何为RabbitMQ title=1.1、何为RabbitMQ></a>1.1、何为RabbitMQ</h2><p><strong>RabbitMQ是一种开源的消息队列软件，它实现了高级消息队列协议 AMQP 的标准。它是一种可靠、灵活和可扩展的消息队列，用于在应用程序之间进行异步消息传递</strong>。<h2 id=1-2、用户><a class=headerlink href=#1-2、用户 title=1.2、用户></a>1.2、用户</h2><h3 id=1-2-1、用户角色><a class=headerlink href=#1-2-1、用户角色 title=1.2.1、用户角色></a>1.2.1、用户角色</h3><p>用户角色有如下几种：<ul><li><strong>administrator</strong>：用户可以做监控所能做的一切，管理用户、vhosts和权限，关闭其他用户的连接，并管理所有vhosts的策略和参数。<li><strong>monitoring</strong>：用户可以访问管理插件，查看所有连接和通道以及节点相关信息。<li><strong>policymaker</strong>：用户可以访问管理插件，并管理他们可以访问的vhosts的策略和参数。<li><strong>management</strong>：用户可以访问管理插件<li><strong>impersonator</strong>：模拟。<li><strong>none</strong>（什么都没有）</ul><h3 id=1-2-2、用户权限><a class=headerlink href=#1-2-2、用户权限 title=1.2.2、用户权限></a>1.2.2、用户权限</h3><p>可以为用户设置的权限有：配置权限、写权限、读权限、路由权限等，设置权限时可以使用通配符。比如，基于通配符形式为用户设置读权限<code>.*</code>和写权限<code>.*</code>，两者都是通过一个点加一个星组成。<h2 id=1-3、交换机><a class=headerlink href=#1-3、交换机 title=1.3、交换机></a>1.3、交换机</h2><h3 id=1-3-1、交换机类型><a class=headerlink href=#1-3-1、交换机类型 title=1.3.1、交换机类型></a>1.3.1、交换机类型</h3><p>常见的交换机类型如下：<ul><li><strong>direct（直接）</strong><li><strong>fanout（扇出）</strong><li><strong>topic（主题）</strong><li><strong>headers（标题）</strong><li><strong>x-delayed-message（延迟交换机，依赖于插件）</strong></ul><p>注意：编码时**如果没有显式指定交换机，那么将使用默认交换机<code>(AMQP default)</code>**。<h3 id=1-3-2、交换机参数><a class=headerlink href=#1-3-2、交换机参数 title=1.3.2、交换机参数></a>1.3.2、交换机参数</h3><p>RabbitMQ 3.9.5版本中存在的交换机参数如下：<ul><li><code>alternate-exchange</code></ul><h2 id=1-3、队列><a class=headerlink href=#1-3、队列 title=1.3、队列></a>1.3、队列</h2><h3 id=1-3-1、队列参数><a class=headerlink href=#1-3-1、队列参数 title=1.3.1、队列参数></a>1.3.1、队列参数</h3><p>RabbitMQ 3.9.5版本中存在的队列参数如下：<ul><li><code>x-message-ttl</code>：发送到队列中的消息能存活多长时间，单位是毫秒。<li><code>x-expires</code>：该队列被删除前可以使用的时长，单位是毫秒。<li><code>x-overflow</code>：当队列中的消息达到最大长度时会发生什么。取值范围：<code>drop-head、reject-publish、reject-publish-dlx</code>。注意的是对于仲裁队列，只有前两个取值有效。<li><code>x-single-active-consumer</code>：一次只能有一个消费者来消费队列中的消息，如果该消费者被取消或死亡时会自动转为另一个消费者来消费消息。<li><code>x-dead-letter-exchange</code>：设置当前队列需要连接的死信交换机。当该队列中的消息成为死信后会被转发到死信交换机。<li><code>x-dead-letter-routing-key</code>：队列中的消息被转发到死信交换机时使用的路由KEY。<li><code>x-max-length</code>：设置该队列中最多可以存储多少条消息。<li><code>x-max-length-bytes</code>：设置该队列中最多可以存储多少字节的内容。<li><code>x-max-priority</code>：设置该队列中的消息可以设置的最大优先级。<li><code>x-queue-mode</code>：设置该队列的模式，默认为<code>lazy</code>。<li><code>x-queue-master-locator</code>：将队列设为主节点模式。</ul><h1 id=2、高级特性><a class=headerlink href=#2、高级特性 title=2、高级特性></a>2、高级特性</h1><h2 id=2-1、TTL><a class=headerlink href=#2-1、TTL title=2.1、TTL></a>2.1、TTL</h2><p><strong>TTL全称 Time To Live（存活时间/过期时间）</strong>。当消息到达存活时间后还没有被消费，那么该消息会被自动清除。<p>RabbitMQ可以对消息设置过期时间，也可以对队列设置过期时间。<ul><li><p>为队列设置过期时间</p> <p>创建队列时，为队列设置参数<code>x-message-ttl</code>，参数值是数值类型，单位毫秒。</p><li><p>为消息设置过期时间</p> <p>创建消息时，为消息本身设置参数。</p></ul><p>注意事项：<ol><li>队列过期后，会将队列中的消息全部移除。<li>队列和消息都设置了过期时间的情况下，以过期时间最短的为准。<li>消息过期后，只有该过期消息在队列顶端时，才会判断是否过期然后再判断是否移除。</ol><h2 id=2-2、死信队列><a class=headerlink href=#2-2、死信队列 title=2.2、死信队列></a>2.2、死信队列</h2><p><strong>死信队列，英文称为 DLX，全称为 Dead Letter Exchange（死信交换机）</strong>。当消息成为死信时，可以被重新发送至另一个交换机，而这个交换机就称为 死信交换机。需要注意的是，RabbitMQ中的死信队列通常指的是 死信交换机。<p>消息成为死信的情况有如下三种：<ul><li><strong>队列消息长度达到限制</strong>。<li><strong>队列存在过期时间设置，消息到达过期时间时没有被消费</strong>。<li><strong>消费端拒绝接收消息（消息被拒收，且没有将消息重新放入队列）</strong></ul><p>如何给队列绑定死信交换机呢？可以通过给队列设置参数<code>x-dead-letter-exchange</code>和<code>x-dead-letter-touting-key</code>来实现。<h2 id=2-3、延迟队列><a class=headerlink href=#2-3、延迟队列 title=2.3、延迟队列></a>2.3、延迟队列</h2><p>延迟队列指的是 <strong>消息进入队列后不会被立即消费，只有到达设定的时间后才会被消费</strong>。<p><font color=red>注意：RabbitMQ中没有提供 延迟队列 的功能，但可以通过 TTL+死信队列 来实现相同的功能和效果，但要注意的是TTL+死信队列实现的延迟队列有一个BUG，就是任务优先级与执行顺序不匹配的问题。</font><p>通过死信队列+TTL来实现的延迟队列功能存在一个 超时优先级错误问题，也就是消息被消费的顺序是由消息在队列中的排列顺序来决定的，而这个排列顺序是由消息被发往死信队列时的时间顺序来决定的。这样一来就会存在一种现象，那就是超时时间短的消息如果排在超时时间长的消息的后边，那么这个超时时间短的消息何时会被消费取决于其前面的超时时间长的消息何时被消费。<p><strong>要解决这个超时优先级错误问题，需要使用 RabbitMQ 提供的插件方式的延迟队列来解决</strong>。<p>要使用插件方式的延迟队列，首先要<strong>通过命令<code>rabbitmq-plugins enable x_delayed_message_exchange</code>开启该插件</strong>功能，然后在**创建交换机时设置其类型为<code>x-delayed-message</code>**即可实现延迟功能，同时也可以解决之前存在的超时优先级错误问题。<h2 id=2-4、惰性队列><a class=headerlink href=#2-4、惰性队列 title=2.4、惰性队列></a>2.4、惰性队列</h2><p><strong>RabbitMQ 3.6.0开始支持惰性队列</strong>。<p>惰性队列的特点如下：<ul><li><strong>接收到消息后直接存入磁盘而非内存</strong>。<li>消费者消费消息时会从磁盘读取消息加载到内存中。<li>支持数百万条消息的存储。</ul><p>设置或配置一个队列是惰性队列的方式如下：<ul><li><p>创建队列时直接配置</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>// 方式1 调用lazy()方法</span></span><br><span class=line><span class=keyword>return</span> QueueBuilder.durable(<span class=string>""</span>).lazy().build();</span><br><span class=line></span><br><span class=line><span class=comment>// 方式2 注解方式来配置属性x-queue-mode为lazy</span></span><br><span class=line><span class=meta>@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class=line><span class=meta>    arguments = @Argument(name = "x-queue-mode", value = "lazy")</span></span><br><span class=line><span class=meta>))</span></span><br></pre></table></figure><li><p>将运行中的队里设为惰性队列</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>rabbitmqctl set_policy Lazy <span class=string>"^lazy-queue$"</span> <span class=string>'{"queue-mode":"lazy"}'</span> --apply-to queues</span><br></pre></table></figure></ul><h2 id=2-5、仲裁队列><a class=headerlink href=#2-5、仲裁队列 title=2.5、仲裁队列></a>2.5、仲裁队列</h2><p><strong>镜像集群虽然支持主从，但主从同步并非强一致。为解决该问题，可以采用 仲裁队列 技术</strong>。<p>RabbitMQ 3.8开始推出了仲裁队列，用来替代镜像集群，该队列底层<strong>采用Raft协议</strong>保证主从同步的一致性。<p>创建仲裁队列的方法很简单，如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>// 通过调用quorum()方法即可</span></span><br><span class=line><span class=keyword>return</span> QueueBuilder.durable(<span class=string>"quorum.queue"</span>).quorum().build();</span><br></pre></table></figure><h2 id=2-6、备份交换机><a class=headerlink href=#2-6、备份交换机 title=2.6、备份交换机></a>2.6、备份交换机</h2><p>备份交换机指的是<strong>一个交换机无法将消息发送到队列时可以将该消息转发到备份交换机</strong>。<p>如何将消息转发至备份交换机呢？只需在创建交换机时为该交换机设置参数<code>alternae-exchange</code>，参数值就是备份交换机的名字。这样就可以实现该交换机无法转发消息到队列时选择将消息转发至备份交换机。<h2 id=2-7、日志与监控><a class=headerlink href=#2-7、日志与监控 title=2.7、日志与监控></a>2.7、日志与监控</h2><p>RabbitMQ日志存放路径默认在 <code>var/log/rabbitmq/rabbit@xxx.log</code>。<h2 id=2-8、消息追踪><a class=headerlink href=#2-8、消息追踪 title=2.8、消息追踪></a>2.8、消息追踪</h2><p>RabbitMQ中可以使用Firehose和rabbitmq_tracing插件功能来实现消息追踪。<h2 id=2-9、管理><a class=headerlink href=#2-9、管理 title=2.9、管理></a>2.9、管理</h2><h1 id=3、高可用><a class=headerlink href=#3、高可用 title=3、高可用></a>3、高可用</h1><h2 id=3-1、消息可靠性><a class=headerlink href=#3-1、消息可靠性 title=3.1、消息可靠性></a>3.1、消息可靠性</h2><p>通过如下配置可以实现 消息可靠性投递。<ul><li><p><strong>confirm模式</strong></p> <p>producer发送的消息无论是否成功到达 exchange 都会执行 confirmCallback。</p><li><p><strong>return模式</strong></p> <p>消息从 exchange 投递到 queue 失败时会执行 returnCallback。</p><li><p><strong>template.mandatory</strong></p> <p>设置消息路由失败时的策略。true表示会调用 returnCallback，false表示直接丢弃消息。</p></ul><h3 id=3-1-1、数据持久化><a class=headerlink href=#3-1-1、数据持久化 title=3.1.1、数据持久化></a>3.1.1、数据持久化</h3><p>交换机持久化实现方式：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>// 第二个参数表示是否持久化；第三个参数表示没有queue与之绑定时是否删除；</span></span><br><span class=line><span class=keyword>new</span> <span class="title class_">DirectExchange</span>(<span class=string>"exchange_name"</span>, <span class=literal>true</span>, <span class=literal>false</span>);</span><br></pre></table></figure><p>队列持久化实现方式：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>// durable()方法表示该队列默认就是持久化</span></span><br><span class=line>QueueBuilder.durable(<span class=string>"queue_name"</span>).build();</span><br></pre></table></figure><p>消息持久化实现方式：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>// 使用Message对象来构建要发送的消息，MessageDeliveryMode.PERSISTENT表示持久化</span></span><br><span class=line>MessageBuilder.withBody(<span class=string>"hello"</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class=line>    .setDeliveryMode(MessageDeliveryMode.PERSISTENT)</span><br><span class=line>    .build();</span><br></pre></table></figure><h3 id=3-1-2、生产端确认><a class=headerlink href=#3-1-2、生产端确认 title=3.1.2、生产端确认></a>3.1.2、生产端确认</h3><p>配置文件：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>rabbitmq:</span></span><br><span class=line>    <span class=attr>addresses:</span> <span class=number>127.0</span><span class=number>.0</span><span class=number>.1</span><span class=string>:5672</span></span><br><span class=line>    <span class=attr>username:</span> <span class=string>test</span></span><br><span class=line>    <span class=attr>password:</span> <span class=string>test</span></span><br><span class=line>    <span class=attr>virtual-host:</span> <span class=string>/test</span></span><br><span class=line>    <span class=comment># 可靠投递：producer发送消息至exchange，无论消息是否成功到达exchange，都会执行confirmCallback。</span></span><br><span class=line>    <span class=comment># 可选值3个：NONE、CORRELATED（异步回调）、SIMPLE（同步等待），默认为NONE</span></span><br><span class=line>    <span class=attr>publisher-confirm-type:</span> <span class=string>correlated</span></span><br><span class=line>    <span class=comment># 可靠投递：exchange转发消息至queue失败时，会执行returnCallback。</span></span><br><span class=line>    <span class=attr>publisher-returns:</span> <span class=literal>true</span></span><br><span class=line>    <span class=comment># 消息路由失败时的处理策略。true表示会调用returnCallback，false表示直接丢弃消息。</span></span><br><span class=line>    <span class=attr>template:</span></span><br><span class=line>      <span class=attr>mandatory:</span> <span class=literal>true</span></span><br></pre></table></figure><p>注意：<strong>需要为 RabbitTemplate 设置 ReturnCallback；需要通过 CorrelationData 设置 ConfirmCallback 并保障每条消息全局唯一</strong>；<h3 id=3-1-3、消费端确认><a class=headerlink href=#3-1-3、消费端确认 title=3.1.3、消费端确认></a>3.1.3、消费端确认</h3><p><strong>ACK指的是 acknowledge，确认，表示消费端收到消息后的处理方式</strong>。<p>消费端收到消息后的处理方式有如下三种：<ul><li><p><strong>自动确认</strong>：acknowledge设为none。</p> <p>消费端收到消息后会自动确认消息已经收到，然后将消息从消息缓存中删除。</p><li><p><strong>手动确认</strong>：acknowledge设为manual。</p> <p>消费端收到消息并处理完业务后需要手动确认消息。手动确认消息可以通过调用<code>basicAck()</code>方法实现。</p><li><p><strong>根据异常情况选择性确认</strong>：acknowledge设为auto。</p> <p>消费端收到消息且在处理业务时出现了异常，会执行<code>basicNack()</code>方法并让生产端重新发送消息。如果没有出现异常，则会调用普通的<code>basicAck()</code>方法。</p></ul><p>配置文件示例如下：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=attr>spring:</span>   </span><br><span class=line>  <span class=attr>rabbitmq:</span></span><br><span class=line>    <span class=attr>addresses:</span> <span class=number>192.168</span><span class=number>.2</span><span class=number>.5</span><span class=string>:5672</span></span><br><span class=line>    <span class=attr>username:</span> <span class=string>test</span></span><br><span class=line>    <span class=attr>password:</span> <span class=string>test</span></span><br><span class=line>    <span class=attr>virtual-host:</span> <span class=string>/test</span></span><br><span class=line>    <span class=comment># 可靠投递：producer发送消息至exchange，无论消息是否成功到达exchange，都会执行confirmCallback。</span></span><br><span class=line>    <span class=comment># 可选值3个：NONE、CORRELATED（异步回调）、SIMPLE（同步等待），默认为NONE</span></span><br><span class=line>    <span class=attr>publisher-confirm-type:</span> <span class=string>correlated</span></span><br><span class=line>    <span class=comment># 可靠投递：exchange转发消息至queue失败时，会执行returnCallback。</span></span><br><span class=line>    <span class=attr>publisher-returns:</span> <span class=literal>true</span></span><br><span class=line>    <span class=comment># 消息路由失败时的处理策略。true表示会调用returnCallback，false表示直接丢弃消息。</span></span><br><span class=line>    <span class=attr>template:</span></span><br><span class=line>      <span class=attr>mandatory:</span> <span class=literal>true</span></span><br><span class=line>    <span class=attr>listener:</span></span><br><span class=line>      <span class=attr>simple:</span></span><br><span class=line>        <span class=attr>prefetch:</span> <span class=number>1</span></span><br><span class=line>        <span class=attr>concurrency:</span> <span class=number>3</span></span><br><span class=line>        <span class=attr>acknowledge-mode:</span> <span class=string>manual</span></span><br></pre></table></figure><h3 id=3-1-4、消费端失败重试><a class=headerlink href=#3-1-4、消费端失败重试 title=3.1.4、消费端失败重试></a>3.1.4、消费端失败重试</h3><p>收到消息后，在处理业务时出现异常会进行重试，那么重试策略可以通过以下几个参数来配置：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>rabbitmq:</span></span><br><span class=line>    <span class=attr>listener:</span></span><br><span class=line>      <span class=attr>simple:</span></span><br><span class=line>        <span class=attr>retry:</span></span><br><span class=line>          <span class=attr>enabled:</span> <span class=literal>true</span>              <span class=comment># 开启消费失败重试</span></span><br><span class=line>          <span class=attr>initial-interval:</span> <span class=number>1000</span>     <span class=comment># 初始失败等待时长1S</span></span><br><span class=line>          <span class=attr>multiplier:</span> <span class=number>2</span>              <span class=comment># 下次失败 等待时长翻倍</span></span><br><span class=line>          <span class=attr>max-attempts:</span> <span class=number>3</span>            <span class=comment># 最大重试次数</span></span><br><span class=line>          <span class=attr>stateless:</span> <span class=literal>true</span>            <span class=comment># true：无状态，false：有状态。若有事务则改为false。</span></span><br></pre></table></figure><p><strong>重试次数耗尽后，如果依然失败，那么需要 MessageRecoverer 接口来处理</strong>。该接口包含三种不同实现：<ul><li>RejectAndDontRequeueRecoverer：重试耗尽后，直接拒绝并丢弃消息。默认策略。<li>ImmediateRequeueMessageRecoverer：重试耗尽后，返回NACK，消息重新入队。<li>RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定交换机。</ul><p>要配置使用其它策略，可以直接创建实例并注入到容器即可。例如：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment>// 第二个参数是交换机名字；第三个参数是路由key；</span></span><br><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class=params>(RabbitTemplate rabbitTemplate)</span>{</span><br><span class=line>    <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class=string>"error.exchange"</span>, <span class=string>"error"</span>);</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-1-5、消费端限流><a class=headerlink href=#3-1-5、消费端限流 title=3.1.5、消费端限流></a>3.1.5、消费端限流</h3><p>消费端限流指的是 <strong>消费端每次只能从MQ中拉取限定数量的消息。这个限定可以通过在消费端配置<code>prefetch</code>属性来实现</strong>。<p><font color=red>注意：想要让消费端限流功能生效，必须将消费端确认消息的模式设为 手动确认，即将acknowledge设为manual。</font><h3 id=3-1-6、消息堆积><a class=headerlink href=#3-1-6、消息堆积 title=3.1.6、消息堆积></a>3.1.6、消息堆积</h3><p><strong>生产者发送消息的速度超过消费者消费的速度时会导致消息在队列中堆积，当达到队列堆积上限时会将最早接收到的消息变为死信，会被丢弃</strong>。这就是消息堆积问题。<p>解决消息堆积问题常见的方法如下：<ul><li><p><strong>增加更多的消费者</strong>，提高消费速度。</p><li><p>在消费者内<strong>开启线程池技术</strong>加快消息处理速度。</p><li><p><strong>扩大队列容量</strong>，提高消息堆积的上限。</p> <p>这种方式不太好，队列中的消息默认保存在内存中，一旦机器出现问题，内存中的数据将会消失。若需要避免这个问题，可以使用惰性队列来避免，因为惰性队列的数据会保存在磁盘中。</p></ul><h1 id=3、应用问题><a class=headerlink href=#3、应用问题 title=3、应用问题></a>3、应用问题</h1><h2 id=3-1、消息可靠性保障><a class=headerlink href=#3-1、消息可靠性保障 title=3.1、消息可靠性保障></a>3.1、消息可靠性保障</h2><p>消息的可靠性 可以通过 消息补偿机制 来实现。也可以通过以下方式来实现：<ul><li>集群 + 镜像队列<li>集群 + haproxy + keepalived<li>消息确认和应答</ul><h2 id=3-2、消息幂等性保障><a class=headerlink href=#3-2、消息幂等性保障 title=3.2、消息幂等性保障></a>3.2、消息幂等性保障</h2><p>消息的幂等性 可以通过 以下几种方式来实现：<ul><li>乐观锁<li>唯一ID<li>redis setnx命令</ul><h2 id=3-3、集群问题><a class=headerlink href=#3-3、集群问题 title=3.3、集群问题></a>3.3、集群问题</h2><h3 id=3-3-1、普通集群><a class=headerlink href=#3-3-1、普通集群 title=3.3.1、普通集群></a>3.3.1、普通集群</h3><p>普通集群存在如下问题：<ul><li>声明队列的节点如果down掉，其它节点中关于该队列也将无法使用。可以使用镜像队列来解决。</ul></div><footer class=post-footer><div class=post-tags><a href=/tags/RabbitMQ/ rel=tag># RabbitMQ</a><a href=/tags/RabbitMQ%E5%9F%BA%E7%A1%80/ rel=tag># RabbitMQ基础</a></div><div class=post-nav><div class=post-nav-item><a href=/2024/08/21/RabbitMQ%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/ rel=prev title=RabbitMQ系列-RabbitMQ常见业务问题> <i class="fa fa-angle-left"></i> RabbitMQ系列-RabbitMQ常见业务问题 </a></div><div class=post-nav-item><a href=/2024/08/21/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB%E5%92%8CAOF/ rel=next title=Redis系列-Redis持久化> Redis系列-Redis持久化 <i class="fa fa-angle-right"></i> </a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script>