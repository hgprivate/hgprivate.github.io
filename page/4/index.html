<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hshz21.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content=豪哥博客 name=description><meta content=website property=og:type><meta content=豪哥博客 property=og:title><meta content=https://hshz21.gitee.io/page/4/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content=豪哥博客 property=og:description><meta content=zh_CN property=og:locale><meta content=豪哥 property=article:author><meta content=HG property=article:tag><meta content=summary name=twitter:card><link href=https://hshz21.gitee.io/page/4/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/4/index.html","title":""}</script><script class=next-config data-name=calendar type=application/json>""</script><title>豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <h1 class=site-title>豪哥博客</h1> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>116</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>36</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>129</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/TCP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/TCP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ itemprop=url>计算机系列-TCP基础知识</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-06 22:54:09" datetime=2023-10-06T22:54:09+08:00 itemprop=dateModified>2023-10-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/ itemprop=url rel=index><span itemprop=name>计算机</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、必备知识><a class=headerlink href=#1、必备知识 title=1、必备知识></a>1、必备知识</h1><h2 id=1-1、协议分类><a class=headerlink href=#1-1、协议分类 title=1.1、协议分类></a>1.1、协议分类</h2><ul><li>IP（Internet Protocol）：⽹络协议。<li>TCP（Transmission Control Protocol）：传输控制协议。</ul><p>四层协议，五层协议和七层协议的关系如下：<ul><li><p>OSI七层协议模型包括：应⽤层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、⽹络层（Network）、数据链路层（Data Link）、物理层（Physical）。</p><li><p>TCP/IP四层体系结构包括：应⽤层、运输层、⽹际层和⽹络接⼝层。</p></ul><p><img alt=image-20200908153007750 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908153007750.png?token=AIGEF3OXKJLRJVGY7BKNGT3EZZSC4><blockquote><p>注：五层协议体系结构只是为了介绍⽹络原理⽽设计，实际应⽤还是 TCP/IP 四层体系结构。</blockquote><h2 id=1-2、OSI七层协议><a class=headerlink href=#1-2、OSI七层协议 title=1.2、OSI七层协议></a>1.2、OSI七层协议</h2><ol><li><font color=orange>物理层（Physical）</font>：网线、网卡、集线器、调制解调器；<li><font color=orange>数据链路层（Data Link）</font>：网桥、交换机、基于mac地址的物理寻址；例如以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP。<li><font color=orange>⽹络层（Network）</font>：路由器；例如IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、 X.25。<li><font color=orange>传输层（Transport）</font>：TLS协议、SSL协议；例如TCP、UDP、RTP、SCTP、SPX、ATP、IL。<li><font color=orange>会话层（Session）</font>：例如ASAP、TLS、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets。<li><font color=orange>表示层（Presentation）</font>：例如XDR、ASN.1、SMB、AFP、NCP。<li><font color=orange>应⽤层（Application）</font>：例如HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP。</ol><blockquote><p>传输层安全性协议（英语：Transport Layer Security，缩写TLS）的前身是安全套接层（Secure Sockets Layer，缩写作SSL）协议。该协议主要为互联网通信提供安全及数据完整性保障。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。<p>TLS协议采用主从式架构模型，用于在两个应用间透过网络创建安全连线，防止在交换数据时被窃听及篡改。</blockquote><h2 id=1-3、TCP-IP四层协议><a class=headerlink href=#1-3、TCP-IP四层协议 title=1.3、TCP/IP四层协议></a>1.3、TCP/IP四层协议</h2><p>TCP/IP 被分为 4 层，每层的 任务 和 ⼯作⽅式 都不同，每层封装上层数据的⽅式也不同：<ol><li>应⽤层：应⽤程序通过该层访问⽹络，该层协议有HTTP、FTP、TFTP、SMTP、SNMP、DNS 和 TELNET；数据格式为数据报文。<li>传输层：TCP协议、UDP协议；数据格式为 数据段。<li>⽹络层：IP协议、ICMP协议、IGMP协议等；数据格式为 数据包。<li>⽹络接⼝层：ARP协议、RARP协议；该层是TCP/IP 协议的基层，负责数据帧的发送和接收。数据格式为 数据帧和bit。</ol><h1 id=2、TCP深度剖析><a class=headerlink href=#2、TCP深度剖析 title=2、TCP深度剖析></a>2、TCP深度剖析</h1><h2 id=2-1、TCP与UDP><a class=headerlink href=#2-1、TCP与UDP title=2.1、TCP与UDP></a>2.1、TCP与UDP</h2><ul><li>TCP（传输控制协议）：提供⾯向连接的，可靠的数据传输服务。<li>UDP（⽤户数据协议）：提供⽆连接的，尽最⼤努⼒的数据传输服务（不保证数据传输的可靠性）。</ul><p><img alt=image-20200908153446067 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908153446067.png?token=AIGEF3MHOACQR3H4HWPIOTLEZZSEQ><h2 id=2-2、TCP-IP数据包结构><a class=headerlink href=#2-2、TCP-IP数据包结构 title=2.2、TCP/IP数据包结构></a>2.2、TCP/IP数据包结构</h2><h3 id=2-2-1、TCP数据包结构><a class=headerlink href=#2-2-1、TCP数据包结构 title=2.2.1、TCP数据包结构></a>2.2.1、TCP数据包结构</h3><p><img alt=image-20200908153709918 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908153709918.png?token=AIGEF3LVR6MEHVKFNPKBES3EZZSFW><ol><li>第一行：源端口2字节，目的端口2字节；</ol><p>表示发送方和接收方的端口号。<ol start=2><li><p>第二、三行：序列号4字节，确认号4字节；</p> <ul><li>序列号是指该报文段在发送方数据字节流中的位置，在TCP字节流中，每个数据字节都被编号；<li>确认号是指本机希望收到的下一个字节的序号；<li>序列号和确认号分别对应报文发送方向和相反方向的数据流；<li>报文被分解成多个报文段时，序列号就是首字节在整个报文中的偏移量，确认号指定下一个期待的字节；<li>序列号和确认号的最大表示范围均为2^32-1=4294967295≈42.9亿；</ul><li><p>第四行：首部长度4位，保留6位，标志位6位，窗口大小16位；</p> <ul><li><p>首部长度：指明首部共有多少行（每行4个字节），则TCP首部的最大长度为（2^4-1)*4=60字节；</p><li><p>标志位：公有6位，每一项含义分别如下：</p> <ol><li><font color=orange>SYN：建立连接 - 同步序号用来发起一个连接。</font><li><font color=orange>FIN：关闭连接 - 发端完成发送任务。</font><li><font color=orange>ACK：响应 - 确认序号有效。</font><li><font color=orange>PSH：有data数据传输 - 接收方尽快将这个报文段交给应用层。</font><li><font color=orange>RST：重建连接。</font><li><font color=orange>URG：紧急指针有效。</font></ol><li><p>窗口大小：即发送数据的窗口大小，告诉对方在不等待确认的情况下，可以发来多大的数据；这里表示的最大长度是2^16-1=65535，如需要使用更大的窗口大小，需要使用选项中的窗口扩大因子选项；</p></ul><li><p>第五行：TCP校验和16位，紧急指针16位；</p> <ul><li>TCP校验和：检查TCP报文段的完整性。TCP报文段咋源主机中被创建时会计算一个校验和，后将该校验和放入TCP头部的校验字段。目标主机收到后也会计算一个校验和，然后与之比较，如何两者相同说明TCP报文段完整，否则标识不完整。<li>紧急指针：当URG标志为1时紧急指针才有效，紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号（即序列号到紧急指针之间的数据为紧急数据，后面的数据才是正常数据）。</ul><li><p>第六行开始是选项部分：每个选项的开头是1字节的kind字段，表示选项类型。</p></ol><h3 id=2-2-2、IP数据包结构><a class=headerlink href=#2-2-2、IP数据包结构 title=2.2.2、IP数据包结构></a>2.2.2、IP数据包结构</h3><p><img alt=image-20200908154657846 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908154657846.png?token=AIGEF3N2N3XRRUWMR5BLBTLEZZSG2><h1 id=3、TCP传输><a class=headerlink href=#3、TCP传输 title=3、TCP传输></a>3、TCP传输</h1><h2 id=3-1、三次握手><a class=headerlink href=#3-1、三次握手 title=3.1、三次握手></a>3.1、三次握手</h2><p><img alt=image-20200908154817025 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908154817025.png?token=AIGEF3LSU3H6CSN4IXYNLEDEZZSIK><p><img alt=image-20200908154934881 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908154934881.png?token=AIGEF3K3BICJ4RAVDA6FX5DEZZSJM><h2 id=3-2、四次挥手><a class=headerlink href=#3-2、四次挥手 title=3.2、四次挥手></a>3.2、四次挥手</h2><p><img alt=image-20200908155442522 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200908155442522.png?token=AIGEF3K7PY4QWVYOGZYWZVTEZZSKO><p><strong>最⼤分段寿命（MSL, Maximum Segment Lifetime）表示⼀个 TCP 分段可以存在于互联⽹系统中的最⼤时间，由 TCP 实现，超出这个寿命的分⽚都会被丢弃</strong>。<p>centOS中被定义为 30s，可通过<code>/proc/sys/net/ipv4/tcp_fin_timeout</code>⽂件查看和修改这个值。<blockquote><p>Socket：套接字，ip + port : ip + port。每台主机可以有65535个连接。</blockquote><h2 id=3-3、总结><a class=headerlink href=#3-3、总结 title=3.3、总结></a>3.3、总结</h2><h3 id=3-3-1、为何需要三次握手？><a class=headerlink href=#3-3-1、为何需要三次握手？ title=3.3.1、为何需要三次握手？></a>3.3.1、为何需要三次握手？</h3><p>A->B —> B->A —> A->B<p>因为需要考虑连接时的丢包问题。<p>如果只握⼿两次，即 B响应A后就开始收发数据。假如此时B响应A的确认包在传送过程中丢失了，且A因为⼀直无法收到B的确认包可能会关掉⾃⼰的socket，而B认为A一直在就会一直发送资源，最终会⽩⽩浪费掉B的资源。如果存在三次握⼿，就可避免上述问题。因为B在⼀段时间内没有收到A的确认ack报⽂，那么就会重发SYN报⽂段给A，A收到重发报⽂段后会再次发送确认ack报⽂给B。<h3 id=3-3-2、为何握手要三次，而挥手要四次？><a class=headerlink href=#3-3-2、为何握手要三次，而挥手要四次？ title=3.3.2、为何握手要三次，而挥手要四次？></a>3.3.2、为何握手要三次，而挥手要四次？</h3><ol><li><p>A -> <em>FIN</em> -> B</p><li><p>B -> <em>ACK</em> -> A</p> <p>……….数据传输………</p><li><p>B -> <em>FIN</em> -> A</p><li><p>A -> <em>ACK</em> -> B</p><li><p>B收到A的回应后立即关闭，A则等待2MSL，若期间无任何动静再立即关闭。</p></ol><p><strong>因为只有在客户端和服务端都没有数据要发送时才能断开TCP</strong>。A发送FIN报⽂时只能证明A没有数据要发了，服务端B是否还有数据发给客户端A是不知道的。⽽服务端B收到客户端A的FIN报⽂后只能先回复客户端A⼀个确认报⽂我已收到，但我服务端B还有⼀些数据没发完，等这些数据发完了服务端B才能给客户端A发FIN报⽂(所以不能⼀次性将确认报⽂和FIN报⽂发给客户端，就是这⾥多出来了⼀次)。<h3 id=3-3-3、为何客户端第四次发送确认报文后还要等2MSL后才关闭？><a class=headerlink href=#3-3-3、为何客户端第四次发送确认报文后还要等2MSL后才关闭？ title=3.3.3、为何客户端第四次发送确认报文后还要等2MSL后才关闭？></a>3.3.3、为何客户端第四次发送确认报文后还要等2MSL后才关闭？</h3><p>因为同样是考虑到丢包问题。<p>第4次挥⼿报⽂发过之后，A并不知道B是否接到⾃⼰的ACK。但是A发送ACK后只有两种结果：<ol><li>如果B没有收到A发送的ACK，B会超时重传FIN，那么A再次接到重传FIN，进而会再次发送ACK。<li>如果B收到了A发送的ACK，被动关闭的B⽆需任何wait time，直接释放资源。也不会再发任何消息，包括ACK。</ol><p>所以A要取这两种情况等待时间的最⼤值，以应对最坏情况发⽣，最坏情况就是第⼀种情况：<strong>去向ACK消息最⼤存活时间（MSL) + 来向FIN消息最⼤存活时间(MSL)，刚好是2MSL( Maximum Segment Life)。等待2MSL时间，A就可以放⼼地释放TCP占⽤的资源、端⼝号，此时可以使⽤该端⼝号连接任何服务器</strong>。<p>还有⼀个重要概念——端⼝重⽤。<blockquote><p>每个MSL是2分钟，2个MSL就是4分钟。MSL是<code>maximium segment lifetime</code>的缩写，意为最长报文寿命。这个时间由官方RFC协议规定。</blockquote><h3 id=3-3-4、若已经建立连接，但客户端突然出现故障，那如何解决？><a class=headerlink href=#3-3-4、若已经建立连接，但客户端突然出现故障，那如何解决？ title=3.3.4、若已经建立连接，但客户端突然出现故障，那如何解决？></a>3.3.4、若已经建立连接，但客户端突然出现故障，那如何解决？</h3><p><strong>因TCP有⼀个保活计时器，故客户端出现故障时不会导致服务器⼀直等下去</strong>。<p>服务器每次收到客户端请求后都会重新复位计时器，时间通常为2⼩时，若两⼩时后依然没有收到客户端任何数据，则服务器就会发送探测报⽂段来进行判断。以每75秒发送⼀次连续发送10次后依然无响应，则服务器就会认为客户端出了故障，然后关闭连接。<h1 id=4、TCP可靠传输><a class=headerlink href=#4、TCP可靠传输 title=4、TCP可靠传输></a>4、TCP可靠传输</h1><p><strong>TCP 是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输</strong>。<h2 id=4-1、重传机制><a class=headerlink href=#4-1、重传机制 title=4.1、重传机制></a>4.1、重传机制</h2><p><strong>TCP 实现 可靠传输 的⽅式之⼀就是 通过序列号与确认应答</strong>。<p>TCP传输中，主机B在收到主机A的请求后会发送响应给主机A。<p><img alt=image-20210417191856726 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417191856726.png?token=AIGEF3JFZ4N7DOLCPI6YDITEZZSL4><p>在错综复杂的⽹络中，顺利进行数据传输是不一定成立的，所以<strong>TCP 针对数据包丢失的情况，会⽤重传机制解决</strong>。<p>常⻅重传机制有：<ol><li>超时重传<li>快速重传<li>SACK<li>D-SACK</ol><h3 id=5-1-1、超时重传><a class=headerlink href=#5-1-1、超时重传 title=5.1.1、超时重传></a>5.1.1、超时重传</h3><h4 id=何为超时重传><a class=headerlink href=#何为超时重传 title=何为超时重传></a>何为超时重传</h4><p><strong>发送数据时设定⼀个定时器，当超过指定时间还没有收到对⽅ ACK 确认应答报⽂时就重发该数据，也就是我们常说的超时重传</strong>。<h4 id=触发超时重传><a class=headerlink href=#触发超时重传 title=触发超时重传></a>触发超时重传</h4><p>TCP 会在以下两种情况中 执行 超时重传操作：<ol><li>数据包丢失<li>确认应答丢失</ol><p><img alt=image-20230805230506940 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805230506940.png?token=AIGEF3NDN664QOJTSGLSWZ3EZZSWA><h4 id=设置超时时间><a class=headerlink href=#设置超时时间 title=设置超时时间></a>设置超时时间</h4><p>何为RTT（Round-Trip Time 往返时延），可从下图中找到答案：<p><img alt=image-20210417192532442 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417192532442.png?token=AIGEF3OWNFJJ37OTKLX7PSTEZZSQW><p><strong>RTT 就是数据从⽹络⼀端传送到另⼀端所需的时间，也就是包的往返时间</strong>。<p>超时重传时间会以 RTO （Retransmission Timeout 超时重传时间）表示。<p>重传环境下，超时时间 RTO 较⻓或较短时，会发⽣什么？<p><img alt=image-20210417192649183 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417192649183.png?token=AIGEF3N7O4DGC7GNOHFY3ZDEZZSXE><p>上图中有两种超时时间不同的情况：<ul><li>当超时时间 RTO 较⼤时，重发就慢，丢了⽼半天才重发，没有效率，性能差；<li>当超时时间 RTO 较⼩时，会导致可能并没有丢就重发，于是重发就快，会增加⽹络拥塞，导致 更多超时，更多超时导致更多重发。</ul><p>精确的测量超时时间 RTO 的值是⾮常重要的，这可让我们的重传机制更⾼效。<p>根据上述的两种情况可得知：<strong>超时重传时间 RTO 的值应该略⼤于报⽂往返 RTT 的值</strong>。<p><img alt=image-20210417192824629 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417192824629.png?token=AIGEF3NGIFIJ6IYJR26U4ITEZZSYA><p>⾄此，可能⼤家觉得超时᯿传时间 RTO 的值计算，也不是很复杂嘛。<p>好像就是在发送端发包时记下 t0 ，然后接收端再把这个 ack 回来时再记⼀个 t1 ，于是 RTT = t1 – t0 。没那么简单，这只是⼀个采样，不能代表普遍情况。<p>实际上「报⽂往返 RTT 的值」是经常变化的，因为我们的⽹络也是时常变化的。也就因为「报⽂往返 RTT 的值」 是经常波动变化的，所以「超时᯿传时间 RTO 的值」应该是⼀个动态变化的值。<p>我们来看看 Linux 是如何计算 RTO 的呢？<p>计算往返时间，需要参考如下两项：<ol><li>TCP 通过采样 RTT 时间，然后进⾏加权平均，算出⼀个平滑 RTT 值，⽽且该值还是要 不断变化的，因为⽹络状况不断地变化。<li>除了采样 RTT，还要采样 RTT 的波动范围，这样就避免了 RTT 若有⼀个⼤波动的话，就会很难被发现的情况。</ol><p>RFC6289 建议使⽤以下的公式计算 RTO：<p><img alt=image-20210417192939108 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417192939108.png?token=AIGEF3MC6M5ADE6ZJVKFGVLEZZSZM><p>其中，SRTT 是计算平滑RTT ， DevRTR 是计算平滑RTT 与 最新 RTT 的差距。<p>在 Linux 下，α = 0.125，β = 0.25， μ = 1，∂ = 4。别问怎么来的，问就是⼤量实验中调出来的。<p><strong>如果超时重发的数据再次超时且⼜需要重传时，TCP 的策略是超时间加倍</strong>。<p>也就是每当遇到⼀次超时重传的时候，都会将下⼀次超时时间间隔设为先前值的两倍。两次超时，就说明⽹络环境差，不宜频繁反复发送。<p>超时重传存在的问题是，超时周期可能相对较⻓。那是不是有更快的⽅式呢？<p>于是就可以⽤「快速重传」机制来解决超时重发的时间等待。<h3 id=5-1-2、快速重传><a class=headerlink href=#5-1-2、快速重传 title=5.1.2、快速重传></a>5.1.2、快速重传</h3><p><strong>快速重传（Fast Retransmit）机制不以时间为驱动，⽽是以数据驱动重传</strong>。<p>快速重传机制，是如何⼯作的呢？其实很简单，⼀图胜千⾔。<p><img alt=image-20210417232739572 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417232739572.png?token=AIGEF3LMMC7SAUWHAW4ESDLEZZS2Q><p>在上图，发送⽅发出了 1，2，3，4，5 份数据：<ol><li>第⼀份 Seq1 先送到了，于是就 Ack 回 2；<li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；<li>后⾯的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；<li>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失 的 Seq2。<li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</ol><p>所以， 快速重传的⼯作⽅式是当收到三个相同 ACK 报⽂时，会在定时器过期之前重传丢失的报⽂段。<p><strong>快速重传机制只解决了超时时间问题，还有重传一个还是重传所有的问题</strong>。<p>⽐如对于上⾯的例⼦，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清 楚这连续的三个 Ack 2 是谁传回来的。<p>因为TCP的不同实现，故以上两种情况都有可能发生。这是⼀把双刃剑。<p><strong>通过 SACK ⽅法可以解决 到底该重传哪些 TCP 报⽂的问题</strong>。<h3 id=5-1-3、SACK><a class=headerlink href=#5-1-3、SACK title=5.1.3、SACK></a>5.1.3、SACK</h3><p><strong>SACK （ Selective Acknowledgment 选择性确认）需要在 TCP 头部「选项」字段中加⼀个 SACK，它可以将缓存的地图送给发送⽅， 发送方可根据该地图来判断哪些收到了哪些没有收到，然后只重发那些没有收到的</strong>。<p>如下图，发送⽅收到了三次同样的 ACK 确认报⽂，于是就会触发快速重发机制，通过 SACK 信息发现 只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进⾏重复。<p><img alt=image-20210417233420965 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417233420965.png?token=AIGEF3OFM47VCTUWQ2PHFSLEZZS3W><p>如果要⽀持 SACK ，必须双⽅都要⽀持。Linux下可通过 net.ipv4.tcp_sack 参数打开这个功能（Linux 2.4 后默认打开）。<h3 id=5-1-4、D-SACK><a class=headerlink href=#5-1-4、D-SACK title=5.1.4、D-SACK></a>5.1.4、D-SACK</h3><p><strong>Duplicate SACK ⼜称 D-SACK ，主要通过 SACK 来告诉「发送⽅」哪些数据被重复接收了</strong>。<p>下⾯举两个栗⼦，来说明 D-SACK 的作⽤。<p><strong>栗⼦⼀号：ACK 丢包</strong><p><img alt=image-20210417233640884 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417233640884.png?token=AIGEF3N7ZKU5MFNTOKTN77TEZZS4W><ul><li>「接收⽅」发给「发送⽅」的两个 ACK 确认应答都丢失了，所以发送⽅超时后，᯿传第⼀个数据 包（3000 ~ 3499）<li>于是「接收⽅」发现数据是重复收到的，于是回了⼀个 SACK = 3000<del>3500，告诉「发送⽅」 3000</del>3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都 已收到，所以这个 SACK 就代表着 D-SACK 。<li>这样「发送⽅」就知道了，数据没有丢，是「接收⽅」的 ACK 确认报⽂丢了。</ul><p><strong>栗子二号：网络延时</strong><p><img alt=image-20210417233800922 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417233800922.png?token=AIGEF3PO4B6SO3FWJ7PH7ZLEZZS7G><ul><li>数据包（1000~1499） 被⽹络延迟了，导致「发送⽅」没有收到 Ack 1500 的确认报⽂。<li>⽽后⾯报⽂到达的三个相同的 ACK 确认报⽂，就触发了快速᯿传机制，但是在᯿传后，被延迟的 数据包（1000~1499）⼜到了「接收⽅」；<li>所以「接收⽅」回了⼀个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 DSACK，表示收到了重复的包。<li>这样发送⽅就知道快速᯿传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，⽽ 是因为⽹络延迟了。</ul><p>可⻅， D-SACK 有这么⼏个好处：<ol><li>可以让「发送⽅」知道，是发出去的包丢了，还是接收⽅回应的 ACK 包丢了；<li>可以知道是不是「发送⽅」的数据包被⽹络延迟了；<li>可以知道⽹络中是不是把「发送⽅」的数据包给复制了;</ol><p><strong>Linux 下可通过参数 net.ipv4.tcp_dsack 开启/关闭这个功能（Linux 2.4 后默认打开）</strong>。<h2 id=4-2、滑动窗口><a class=headerlink href=#4-2、滑动窗口 title=4.2、滑动窗口></a>4.2、滑动窗口</h2><h3 id=4-2-1、窗口作用><a class=headerlink href=#4-2-1、窗口作用 title=4.2.1、窗口作用></a>4.2.1、窗口作用</h3><p>我们都知道 TCP 每发送⼀个数据，都要进⾏⼀次确认应答。当上⼀个数据包收到了应答， 再发送下⼀个。<p><img alt=image-20210417234245342 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417234245342.png?token=AIGEF3LJEO3GN6F43A5XBSTEZZTAU><p>所以，这样的传输⽅式有⼀个缺点：数据包的往返时间越⻓，通信的效率就越低。<p>为解决这个问题，TCP 引⼊了窗⼝这个概念。<p>有了窗⼝，就可以指定窗⼝⼤⼩。窗⼝⼤⼩是指：⽆需等待确认应答就可以继续发送数据的最⼤值。<p><strong>窗⼝的实现实际上是操作系统开辟的⼀个缓存空间，发送⽅主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除</strong>。<p>假设窗⼝⼤⼩为 3 个 TCP 段，那么发送⽅就可以「连续发送」 3 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下⼀个确认应答进⾏确认」。如下图：<p><img alt=image-20210417234516493 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417234516493.png?token=AIGEF3LNHDRZTZB6B3XLCOTEZZTCG><p>图中的 ACK 600 确认应答报⽂丢失，也没关系，因为可以通过下⼀个确认应答进⾏确认，只要发送⽅ 收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收⽅」都收到了。这个模式就叫累计确认或者累计应答。<h3 id=4-2-2、窗口大小谁来决定><a class=headerlink href=#4-2-2、窗口大小谁来决定 title=4.2.2、窗口大小谁来决定></a>4.2.2、窗口大小谁来决定</h3><p>TCP 头⾥有⼀个字段叫 Window ，也就是窗⼝⼤⼩。 这个字段是接收端告诉发送端⾃⼰还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能⼒来发送数据，⽽不会导致接收端处理不过来。 所以，<strong>通常窗⼝的⼤⼩是由接收⽅窗⼝⼤⼩来决定的</strong>。发送⽅发送的数据⼤⼩不能超过接收⽅的窗⼝⼤⼩，否则接收⽅就⽆法正常接收到数据。<h3 id=4-2-3、发送方窗口><a class=headerlink href=#4-2-3、发送方窗口 title=4.2.3、发送方窗口></a>4.2.3、发送方窗口</h3><p>我们先来看看发送⽅窗⼝，下图就是发送⽅缓存数据，根据处理的情况分成四个部分，其中 深蓝⾊⽅框 是发送窗⼝，紫⾊⽅框是可⽤窗⼝：<p><img alt=image-20210417234958826 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417234958826.png?token=AIGEF3JMC6ZT7FSRXEKBN53EZZTD2><ul><li>#1 是已发送并收到 ACK确认的数据：1~31 字节。<li>#2 是已发送但未收到 ACK确认的数据：32~45 字节。<li>#3 是未发送但总⼤⼩在接收⽅处理范围内（接收⽅还有空间）：46~51字节。<li>#4 是未发送但总⼤⼩超过接收⽅处理范围（接收⽅没有空间）：52字节以后。</ul><p>在下图，当发送⽅把数据「全部」都⼀下发送出去后，可⽤窗⼝的⼤⼩就为 0 了，表明可⽤窗⼝耗尽， 在没收到 ACK 确认之前是⽆法继续发送数据了。<p><img alt=image-20210417235253264 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417235253264.png?token=AIGEF3IUVHCAKAB25MIWCRLEZZTE4><p>在下图，当收到之前发送的数据 32<del>36 字节的 ACK 确认应答后，如果发送窗⼝的⼤⼩没有变化，则 滑动窗⼝往右边移动 5 个字节，因为有 5 个字节的数据被应答确认，接下来 52</del>56 字节⼜变成了可⽤ 窗⼝，那么后续也就可以发送 52~56 这 5 个字节的数据了。<p><img alt=image-20210417235319675 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417235319675.png?token=AIGEF3OPAGFASP2EYLYQ53LEZZTF2><p><strong>程序如何表示发送方四个部分呢？</strong><p>TCP 滑动窗⼝⽅案使⽤三个指针来跟踪在四个传输类别中的每⼀个类别中的字节。其中两个指针是绝对 指针（指特定的序列号），⼀个是相对指针（需要做偏移）。<p><img alt=image-20230805102056836 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805102056836.png?token=AIGEF3N2GDJ5NWRU4F4XQYDEZZTIE><ul><li>SND.WND ：表示发送窗⼝的⼤⼩（⼤⼩是由接收⽅指定的）；<li>SND.UNA ：是⼀个绝对指针，它指向的是已发送但未收到确认的第⼀个字节的序列号，也就是 #2 的第⼀个字节。<li>SND.NXT ：也是⼀个绝对指针，它指向未发送但可发送范围的第⼀个字节的序列号，也就是 #3 的 第⼀个字节。<li>指向 #4 的第⼀个字节是个相对指针，它需要 SND.UNA 指针加上 SND.WND ⼤⼩的偏移量，就可以 指向 #4 的第⼀个字节了。</ul><p>那么可⽤窗⼝⼤⼩的计算公式就是： <code>可⽤窗⼝⼤ = SND.WND -（SND.NXT - SND.UNA）</code>。<h3 id=4-2-4、接收方窗口><a class=headerlink href=#4-2-4、接收方窗口 title=4.2.4、接收方窗口></a>4.2.4、接收方窗口</h3><p>接下来我们看看接收⽅窗⼝，接收窗⼝相对简单⼀些，根据处理情况分成三个部分：<ul><li>#1 + #2 是已成功接收并确认的数据（等待应⽤进程读取）；<li>#3 是未收到数据但可以接收的数据；<li>#4 未收到数据并不可以接收的数据；</ul><p><img alt=image-20210417235921203 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210417235921203.png?token=AIGEF3I6C25RFPERRQ7TVFTEZZTJY><p>其中三个接收部分，使⽤两个指针进⾏划分：<ul><li>RCV.WND 表示接收窗⼝的⼤⼩，它会通告给发送⽅。<li>RCV.NXT ：是⼀个指针，它指向期望从发送⽅发送来的下⼀个数据字节的序列号，也就是 #3 的第 ⼀个字节。<li>指向 #4 的第⼀个字节是个相对指针，它需要 RCV.NXT 指针加上 RCV.WND ⼤⼩的偏移量，就可以指向 #4 的第⼀个字节了。</ul><p>接收窗口和发送窗口大小一样吗？<p>并不是完全相等，<strong>接收窗⼝⼤⼩ 约等于 发送窗⼝⼤⼩</strong>。<p>因为滑动窗⼝并不是⼀成不变的。⽐如，当接收⽅的应⽤进程读取数据的速度⾮常快的话，接收窗⼝可以很快的腾出空闲空间。那么新的接收窗⼝⼤⼩，是通过 TCP 报⽂中的 Windows 字段来告诉发送⽅。那么这个传输过程是存在时延的，所以接收窗⼝的大小和发送窗⼝是约等于的关系。<h2 id=4-3、流量控制><a class=headerlink href=#4-3、流量控制 title=4.3、流量控制></a>4.3、流量控制</h2><h3 id=4-3-1、流量控制来源><a class=headerlink href=#4-3-1、流量控制来源 title=4.3.1、流量控制来源></a>4.3.1、流量控制来源</h3><p>发送⽅不能⽆脑的发数据给接收⽅，要考虑接收⽅处理能⼒。<p>如果⼀直⽆脑的发数据给对⽅，但对⽅处理不过来，那么就会导致触发重发机制，从⽽导致⽹络流量的⽆端的浪费。<p>为了解决这种现象发⽣，<strong>TCP 提供⼀种机制可以让「发送⽅」根据「接收⽅」的实际接收能⼒ 控制发送的数据量，这就是流量控制</strong>。<p>下⾯举个栗⼦，为了简单起⻅，假设以下场景：<ul><li>客户端是接收⽅，服务端是发送⽅。<li>假设接收窗⼝和发送窗⼝相同，都为 200。<li>假设两个设备在整个传输过程中都保持相同的窗⼝⼤⼩，不受外界影响。</ul><p><img alt=image-20210418180447932 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418180447932.png?token=AIGEF3P3HVCKSTZZK3AUCBDEZZTLM><p><img alt=image-20210418180514513 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418180514513.png?token=AIGEF3IXPTYRPDYKT6VPVDDEZZTM4><p>根据上图的流量控制，说明下每个过程：<ol><li>客户端向服务端发送请求数据报⽂。这⾥要说明下，本次例⼦是把服务端作为发送⽅，所以没有画 出服务端的接收窗⼝。<li>服务端收到请求报⽂后，发送确认报⽂和 80 字节的数据，于是可⽤窗⼝ Usable 减少为 120 字 节，同时 SND.NXT 指针也向右偏移 80 字节后，指向 321，这意味着下次发送数据的时候，序列号 是 321。<li>客户端收到 80 字节数据后，于是接收窗⼝往右移动 80 字节， RCV.NXT 也就指向 321，这意味着 客户端期望的下⼀个报⽂的序列号是 321，接着发送确认报⽂给服务端。<li>服务端再次发送了 120 字节数据，于是可⽤窗⼝耗尽为 0，服务端⽆法再继续发送数据。<li>客户端收到 120 字节的数据后，于是接收窗⼝往右移动 120 字节， RCV.NXT 也就指向 441，接着 发送确认报⽂给服务端。<li>服务端收到对 80 字节数据的确认报⽂后， SND.UNA 指针往右偏移后指向 321，于是可⽤窗⼝ Usable 增⼤到 80。<li>服务端收到对 120 字节数据的确认报⽂后， SND.UNA 指针往右偏移后指向 441，于是可⽤窗⼝ Usable 增⼤到 200。<li>服务端可以继续发送了，于是发送了 160 字节的数据后， SND.NXT 指向 601，于是可⽤窗⼝ Usable 减少到 40。<li>客户端收到 160 字节后，接收窗⼝往右移动了 160 字节， RCV.NXT 也就是指向了 601，接着发送 确认报⽂给服务端。<li>服务端收到对 160 字节数据的确认报⽂后，发送窗⼝往右移动了 160 字节，于是 SND.UNA 指针偏 移了 160 后指向 601，可⽤窗⼝ Usable 也就增⼤⾄了 200。</ol><h3 id=4-3-2、操作系统缓冲区与滑动窗口的关系><a class=headerlink href=#4-3-2、操作系统缓冲区与滑动窗口的关系 title=4.3.2、操作系统缓冲区与滑动窗口的关系></a>4.3.2、操作系统缓冲区与滑动窗口的关系</h3><p>假定了发送窗⼝和接收窗⼝是不变的，但实际上，发送窗⼝和接收窗⼝中所存放的字节数，都是放在操作系统内存缓冲区中，⽽操作系统的缓冲区，会被操作系统调整。<p>当应⽤进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响。<h4 id=4-3-2-1、缓冲区如何响应发送-接收窗口><a class=headerlink href=#4-3-2-1、缓冲区如何响应发送-接收窗口 title=4.3.2.1、缓冲区如何响应发送/接收窗口></a>4.3.2.1、缓冲区如何响应发送/接收窗口</h4><p><strong>例⼦一</strong><p>当应⽤程序没有及时读取缓存时，发送窗⼝和接收窗⼝的变化。<p>考虑以下场景：<ul><li>客户端作为发送⽅，服务端作为接收⽅，发送窗⼝和接收窗⼝初始⼤⼩为 360 ；<li>服务端⾮常的繁忙，当收到客户端的数据时，应⽤层不能及时读取数据。</ul><p><img alt=image-20210418181534600 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418181534600.png?token=AIGEF3OZCRTI7FAGMHYAVKDEZZTOG><p>根据上图的流量控制，说明下每个过程：<ol><li>客户端发送 140 字节数据后，可⽤窗⼝变为 220 （360 - 140）。<li>服务端收到 140 字节数据，但是服务端⾮常繁忙，应⽤进程只读取了 40 个字节，还有 100 字节占 ⽤着缓冲区，于是接收窗⼝收缩到了 260 （360 - 100），最后发送确认信息时，将窗⼝⼤⼩通告 给客户端。<li>客户端收到确认和窗⼝通告报⽂后，发送窗⼝减少为 260。<li>客户端发送 180 字节数据，此时可⽤窗⼝减少到 80。<li>服务端收到 180 字节数据，但是应⽤程序没有读取任何数据，这 180 字节直接就留在了缓冲区，于 是接收窗⼝收缩到了 80 （260 - 180），并在发送确认信息时，通过窗⼝⼤⼩给客户端。<li>客户端收到确认和窗⼝通告报⽂后，发送窗⼝减少为 80。<li>客户端发送 80 字节数据后，可⽤窗⼝耗尽。<li>服务端收到 80 字节数据，但是应⽤程序依然没有读取任何数据，这 80 字节留在了缓冲区，于是接 收窗⼝收缩到了 0，并在发送确认信息时，通过窗⼝⼤⼩给客户端。<li>客户端收到确认和窗⼝通告报⽂后，发送窗⼝减少为 0。</ol><p>可⻅最后窗⼝都收缩为 0 了，也就是发⽣了窗⼝关闭。当发送⽅可⽤窗⼝变为 0 时，发送⽅实际上会定 时发送窗⼝探测报⽂，以便知道接收⽅的窗⼝是否发⽣了改变，这个内容后⾯会说，这⾥先简单提⼀ 下。<p><strong>例⼦二</strong><p>当服务端系统资源⾮常紧张的时候，操⼼系统可能会直接减少了接收缓冲区⼤⼩，这时应⽤程序⼜⽆法 及时读取缓存数据，那么这时候就有严᯿的事情发⽣了，会出现数据包丢失的现象<p><img alt=image-20210418181843933 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418181843933.png?token=AIGEF3PA4IMXWL5XUJHRXR3EZZTPO><p>说明下每个过程：<ol><li>客户端发送 140 字节的数据，于是可⽤窗⼝减少到了 220。<li>服务端因为现在⾮常的繁忙，操作系统于是就把接收缓存减少了 120 字节，当收到 140 字节数据 后，⼜因为应⽤程序没有读取任何数据，所以 140 字节留在了缓冲区中，于是接收窗⼝⼤⼩从 360 收缩成了 100，最后发送确认信息时，通告窗⼝⼤⼩给对⽅。<li>此时客户端因为还没有收到服务端的通告窗⼝报⽂，所以不知道此时接收窗⼝收缩成了 100，客户 端只会看⾃⼰的可⽤窗⼝还有 220，所以客户端就发送了 180 字节数据，于是可⽤窗⼝减少到 40。<li>服务端收到了 180 字节数据时，发现数据⼤⼩超过了接收窗⼝的⼤⼩，于是就把数据包丢失了。<li>客户端收到第 2 步时，服务端发送的确认报⽂和通告窗⼝报⽂，尝试减少发送窗⼝到 100，把窗⼝ 的右端向左收缩了 80，此时可⽤窗⼝的⼤⼩就会出现诡异的负值。</ol><p>所以，如果发⽣了先减少缓存，再收缩窗⼝，就会出现丢包的现象。<p>为了防⽌这种情况发⽣，TCP 规定是不允许同时减少缓存⼜收缩窗⼝的，⽽是采⽤先收缩窗⼝，过段时 间再减少缓存，这样就可以避免了丢包情况。<h3 id=4-3-3、窗口关闭><a class=headerlink href=#4-3-3、窗口关闭 title=4.3.3、窗口关闭></a>4.3.3、窗口关闭</h3><p>在前⾯我们都看到了，TCP 通过让接收⽅指明希望从发送⽅接收的数据⼤⼩（窗⼝⼤⼩）来进⾏流量控制。<p><strong>窗⼝⼤⼩为 0 时，就会阻⽌发送⽅给接收⽅传递数据，直到窗⼝变为⾮ 0 为⽌，这就是窗⼝关闭</strong>。<h4 id=5-3-3-1、窗口关闭潜在危险><a class=headerlink href=#5-3-3-1、窗口关闭潜在危险 title=5.3.3.1、窗口关闭潜在危险></a>5.3.3.1、窗口关闭潜在危险</h4><p><strong>接收⽅通过 ACK 报⽂来向发送⽅通告窗⼝⼤⼩</strong>。<p>当发⽣窗⼝关闭时，接收⽅处理完数据后会向发送⽅通告⼀个窗⼝⾮ 0 的 ACK 报⽂，如果这个通告窗⼝的 ACK 报⽂在⽹络中丢失了，那麻烦就⼤了。<p><img alt=image-20210418182234840 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418182234840.png?token=AIGEF3NARXVMDYNKWI25NNLEZZTQQ><p>这会导致发送⽅⼀直等待接收⽅的⾮ 0 窗⼝通知，接收⽅也⼀直等待发送⽅的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。<h4 id=5-3-3-2、如何解决窗口关闭时的死锁现象><a class=headerlink href=#5-3-3-2、如何解决窗口关闭时的死锁现象 title=5.3.3.2、如何解决窗口关闭时的死锁现象></a>5.3.3.2、如何解决窗口关闭时的死锁现象</h4><p>为了解决这个问题，TCP 为每个连接设有⼀个持续定时器，只要 TCP 连接⼀⽅收到对⽅的零窗⼝通知，就启动持续计时器。如果持续计时器超时，就会发送窗⼝探测 ( Window probe ) 报⽂，⽽对⽅在确认这个探测报⽂时，给出⾃⼰现在的接收窗⼝⼤⼩。<p><img alt=image-20210418182508676 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418182508676.png?token=AIGEF3JXO2IAKFUPH5NXLZ3EZZTRY><ul><li>如果接收窗⼝仍然为 0，那么收到这个报⽂的⼀⽅就会᯿新启动持续计时器；<li>如果接收窗⼝不是 0，那么死锁的局⾯就可以被打破了。</ul><p><strong>窗⼝探测的次数⼀般为 3 次，每次⼤约 30-60 秒（不同的实现可能会不⼀样）。如果 3 次过后接收窗⼝还是 0 的话，有的 TCP 实现就会发 RST 报⽂来中断连接</strong>。<h3 id=5-3-4、糊涂窗口综合症><a class=headerlink href=#5-3-4、糊涂窗口综合症 title=5.3.4、糊涂窗口综合症></a>5.3.4、糊涂窗口综合症</h3><p>如果接收⽅太忙了，来不及取⾛接收窗⼝⾥的数据，那么就会导致发送⽅的发送窗⼝越来越⼩。<p>到最后，如果接收⽅腾出⼏个字节并告诉发送⽅现在有⼏个字节的窗⼝，⽽发送⽅会义⽆反顾地发送这⼏个字节，这就是糊涂窗⼝综合症。<p>要知道，我们的 TCP + IP 头有 40 个字节，为了传输那⼏个字节的数据，要达上这么⼤的开销，这太不经济了。<p>就好像⼀个可以承载 50 ⼈的⼤巴⻋，每次来了⼀两个⼈，就直接发⻋。除⾮家⾥有矿的⼤巴司机，才敢这样玩，不然迟早破产。要解决这个问题也不难，⼤巴司机等乘客数量超过了 25 个，才认定可以发车。<p>现举个糊涂窗⼝综合症的栗⼦，考虑以下场景：<p>接收⽅的窗⼝⼤⼩是 360 字节，但接收⽅由于某些原因陷⼊困境，假设接收⽅的应⽤层读取的能⼒如下：<ul><li>接收⽅每接收 3 个字节，应⽤程序就只能从缓冲区中读取 1 个字节的数据；<li>在下⼀个发送⽅的 TCP 段到达之前，应⽤程序还从缓冲区中读取了 40 个额外的字节；</ul><p><img alt=image-20210418182907615 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418182907615.png?token=AIGEF3J5YB22J346SPF5US3EZZTTK><p>每个过程的窗⼝⼤⼩的变化，在图中都描述的很清楚了，可以发现窗⼝不断减少了，并且发送的数据都 是⽐较⼩的了。<p>所以，糊涂窗⼝综合症的现象是可以发⽣在发送⽅和接收⽅：<ul><li>接收⽅可以通告⼀个⼩的窗⼝。<li>⽽发送⽅可以发送⼩数据。</ul><p>于是，要解决糊涂窗⼝综合症，就解决上⾯两个问题就可以了<ul><li>让接收⽅不通告⼩窗⼝给发送⽅。<li>让发送⽅避免发送⼩数据。</ul><h4 id=5-3-4-1、如何让接收方不通告小窗口><a class=headerlink href=#5-3-4-1、如何让接收方不通告小窗口 title=5.3.4.1、如何让接收方不通告小窗口></a>5.3.4.1、如何让接收方不通告小窗口</h4><p>接收⽅通常的策略如下：<p><strong>当「窗⼝⼤⼩」⼩于 min( MSS，缓存空间/2 ) ，也就是⼩于 MSS 与 1/2 缓存⼤⼩中的最⼩值时，就会向发送⽅通告窗⼝为 0 ，也就阻⽌了发送⽅再发数据过来</strong>。<p>等到接收⽅处理了⼀些数据后，窗⼝⼤⼩ >= MSS，或者接收⽅缓存空间有⼀半可以使⽤，就可以把窗⼝打开让发送⽅发送数据过来。<h4 id=5-3-4-2、如何让发送方避免发送小数据><a class=headerlink href=#5-3-4-2、如何让发送方避免发送小数据 title=5.3.4.2、如何让发送方避免发送小数据></a>5.3.4.2、如何让发送方避免发送小数据</h4><p>发送⽅通常的策略：<p><strong>使⽤ Nagle 算法，该算法的思路是延时处理，它满⾜以下两个条件中的⼀条才可以发送数据</strong>：<ul><li>要等到窗⼝⼤⼩ >= MSS 或是数据⼤⼩ >= MSS<li>收到之前发送数据的 ack 回包</ul><p><strong>只要没满⾜上⾯条件中的⼀条，发送⽅⼀直在囤积数据，直到满⾜上⾯的发送条件</strong>。<p>另外，<strong>Nagle 算法默认打开</strong>，如果对于⼀些需要⼩数据包交互的场景的程序，⽐如，telnet 或 ssh 这样的交互性⽐较强的程序，则需要关闭 Nagle 算法。<p>可以在 Socket 设置 TCP_NODELAY 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每 个应⽤⾃⼰的特点来关闭）<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (<span class=type>char</span> *)&value, sizeof(<span class=type>int</span>));</span><br></pre></table></figure><h2 id=4-4、拥塞控制><a class=headerlink href=#4-4、拥塞控制 title=4.4、拥塞控制></a>4.4、拥塞控制</h2><h3 id=4-4-1、简介><a class=headerlink href=#4-4-1、简介 title=4.4.1、简介></a>4.4.1、简介</h3><h4 id=4-4-1-1、为何需要拥塞控制><a class=headerlink href=#4-4-1-1、为何需要拥塞控制 title=4.4.1.1、为何需要拥塞控制></a>4.4.1.1、为何需要拥塞控制</h4><p>前⾯的流量控制是避免「发送⽅」的数据填满「接收⽅」的缓存，但是并不知道⽹络中发⽣了什么。<p>⼀般来说，计算机⽹络都处在⼀个共享的环境。因此也有可能会因为其他主机之间的通信使得⽹络拥堵。<p>在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传 数据，但是⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进 ⼊恶性循环被不断地放⼤…. 。<p>所以，TCP 不能忽略⽹络中发⽣的事，它被设计成⼀个⽆私的协议，当⽹络发送拥塞时，TCP 会⾃我 牺牲，降低发送的数据量。<p>于是，就有了<strong>拥塞控制，控制的⽬的就是避免「发送⽅」的数据填满整个⽹络</strong>。<p><strong>为了调节「发送⽅」所要发送数据的量，定义了⼀个叫做「拥塞窗⼝」的概念</strong>。<h4 id=4-4-1-2、何为拥塞窗口，与发送窗口有啥关系？><a class=headerlink href=#4-4-1-2、何为拥塞窗口，与发送窗口有啥关系？ title=4.4.1.2、何为拥塞窗口，与发送窗口有啥关系？></a>4.4.1.2、何为拥塞窗口，与发送窗口有啥关系？</h4><p>拥塞窗⼝ cwnd是发送⽅维护的⼀个状态变量，它会根据⽹络的拥塞程度动态变化。<p>我们在前⾯提到过发送窗⼝ swnd 和接收窗⼝ rwnd 是约等于的关系，那么加⼊拥塞窗⼝的概念后，此时发送窗⼝的值是swnd = min(cwnd, rwnd)，也就是拥塞窗⼝和接收窗⼝中的最⼩值。<p>拥塞窗⼝ cwnd 变化规则：<ul><li>⽹络中没有出现拥塞， cwnd 就会增⼤；<li>⽹络中出现了拥塞， cwnd 就减少；</ul><h4 id=4-4-1-3、如何判断网络拥塞了？><a class=headerlink href=#4-4-1-3、如何判断网络拥塞了？ title=4.4.1.3、如何判断网络拥塞了？></a>4.4.1.3、如何判断网络拥塞了？</h4><p><strong>只要「发送⽅」没有在规定时间内接收到 ACK 应答报⽂，也就是发⽣了超时重传，就会认为⽹络出现了拥塞</strong>。<h4 id=4-4-1-4、拥塞控制算法><a class=headerlink href=#4-4-1-4、拥塞控制算法 title=4.4.1.4、拥塞控制算法></a>4.4.1.4、拥塞控制算法</h4><p>拥塞控制主要四个算法：<ol><li>慢启动<li>拥塞避免<li>拥塞发⽣<li>快速恢复</ol><h3 id=4-4-2、慢启动><a class=headerlink href=#4-4-2、慢启动 title=4.4.2、慢启动></a>4.4.2、慢启动</h3><p><strong>TCP 在刚建⽴连接完成后，⾸先有个慢启动过程，这个慢启动意思就是⼀点⼀点提⾼发送数据包的数量</strong>。如果⼀上来就发⼤量的数据，这不是给⽹络添堵吗？<p><strong>慢启动算法记住⼀个规则就⾏：当发送⽅每收到⼀个 ACK，拥塞窗⼝ cwnd 的⼤⼩就会加 1</strong>。<p>这⾥假定拥塞窗⼝ cwnd 和发送窗⼝ swnd 相等，下⾯举个栗⼦：<ul><li>连接建⽴完成后，⼀开始初始化 cwnd = 1 ，表示可以传⼀个 MSS ⼤⼩的数据。<li>当收到⼀个 ACK 确认应答后，cwnd 增加 1，于是⼀次能够发送 2 个<li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以⽐之前多发2 个，所以这⼀次能够发送 4 个<li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以⽐ 之前多发 4 个，所以这⼀次能够发送 8 个。</ul><p><img alt=image-20210418184842512 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418184842512.png?token=AIGEF3OVHEKLN4G5UWD33ODEZZTVQ><p>可以看出慢启动算法，发包的个数是指数性的增⻓。<h4 id=4-4-2-1、慢启动涨到什么时候结束><a class=headerlink href=#4-4-2-1、慢启动涨到什么时候结束 title=4.4.2.1、慢启动涨到什么时候结束></a>4.4.2.1、慢启动涨到什么时候结束</h4><p>有⼀个叫慢启动⻔限 ssthresh （slow start threshold）状态变量。<ul><li>当 cwnd < ssthresh 时，使⽤慢启动算法。<li>当 cwnd >= ssthresh 时，就会使⽤「拥塞避免算法」。</ul><h3 id=4-4-3、拥塞避免算法><a class=headerlink href=#4-4-3、拥塞避免算法 title=4.4.3、拥塞避免算法></a>4.4.3、拥塞避免算法</h3><p>前⾯说道，当拥塞窗⼝ cwnd 「超过」慢启动⻔限 ssthresh 就会进⼊拥塞避免算法。<p>⼀般来说 ssthresh 的⼤⼩是 65535 字节。<p>那么进⼊拥塞避免算法后，它的规则是：每当收到⼀个 ACK 时，cwnd 增加 1/cwnd。<p>接上前⾯的慢启动的栗⼦，现假定 ssthresh 为 8 ：<ul><li>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd ⼀共增加 1，于是这⼀次 能够发送 9 个 MSS ⼤⼩的数据，变成了线性增⻓。</ul><p><img alt=image-20210418190150299 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418190150299.png?token=AIGEF3KSEBJ2ISXTJSHR5ODEZZTWQ><p>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增⻓变成了线性增⻓，还是增⻓阶 段，但是增⻓速度缓慢了⼀些。<p>就这么⼀直增⻓着后，⽹络就会慢慢进⼊了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失 的数据包进⾏᯿传。<p>当触发了重传机制，也就进⼊了「拥塞发⽣算法」<h3 id=4-4-4、拥塞发生><a class=headerlink href=#4-4-4、拥塞发生 title=4.4.4、拥塞发生></a>4.4.4、拥塞发生</h3><p>当⽹络出现拥塞，也就是会发⽣数据包᯿传，重传机制主要有两种：<ul><li>超时重传<li>快速重传</ul><h4 id=4-4-4-1、超时重传拥塞发生算法><a class=headerlink href=#4-4-4-1、超时重传拥塞发生算法 title=4.4.4.1、超时重传拥塞发生算法></a>4.4.4.1、超时重传拥塞发生算法</h4><p>当发⽣了「超时重传」，则就会使⽤拥塞发⽣算法。<p>这个时候，ssthresh 和 cwnd 的值会发⽣变化：<ul><li>ssthresh 设为 cwnd/2。<li>cwnd ᯿置为 1。</ul><p><img alt=image-20210418190500847 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418190500847.png?token=AIGEF3JQ4TJUE2EKGKDAEYTEZZTXS><p>接着，就᯿新开始慢启动，慢启动是会突然减少数据流的。这真是⼀旦「超时᯿传」，⻢上回到解放 前。但是这种⽅式太激进了，反应也很强烈，会造成⽹络卡顿。<p>就好像本来在秋名⼭⾼速漂移着，突然来个紧急刹⻋，轮胎受得了吗。<h4 id=4-4-4-2、快速重传拥塞发生算法><a class=headerlink href=#4-4-4-2、快速重传拥塞发生算法 title=4.4.4.2、快速重传拥塞发生算法></a>4.4.4.2、快速重传拥塞发生算法</h4><p>还有更好的⽅式，前⾯我们讲过「快速᯿传算法」。当接收⽅发现丢了⼀个中间包的时候，发送三次前⼀个包的 ACK，于是发送端就会快速地᯿传，不必等待超时再᯿传。<p>TCP 认为这种情况不严重，因为⼤部分没丢，只丢了⼀⼩部分，则 ssthresh 和 cwnd 变化如下：<ul><li>cwnd = cwnd/2 ，也就是设置为原来的⼀半;<li>ssthresh = cwnd ;<li>进⼊快速恢复算法</ul><h3 id=4-4-5、快速恢复><a class=headerlink href=#4-4-5、快速恢复 title=4.4.5、快速恢复></a>4.4.5、快速恢复</h3><p>快速重传和快速恢复算法⼀般同时使⽤，快速恢复算法是认为，你还能收到 3 个᯿复 ACK 说明⽹络也 不那么糟糕，所以没有必要像 RTO 超时那么强烈。<p>正如前⾯所说，进⼊快速恢复之前， cwnd 和 ssthresh 已被更新了：<ul><li>cwnd = cwnd/2 ，也就是设置为原来的⼀半;<li>ssthresh = cwnd ;</ul><p>然后，进⼊快速恢复算法如下：<ul><li>拥塞窗⼝ cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；<li>重传丢失的数据包；<li>如果再收到᯿复的 ACK，那么 cwnd 增加 1；<li>如果收到新数据的 ACK 后，把 cwnd 设置为第⼀步中的 ssthresh 的值，原因是该 ACK 确认了新 的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的 状态了，也即再次进⼊拥塞避免状态；</ul><p><img alt=image-20210418190824253 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418190824253.png?token=AIGEF3OMNX6UPRX5HTWPQ4LEZZTYW><p>也就是没有像「超时᯿传」⼀夜回到解放前，⽽是还在⽐较⾼的值，后续呈线性增⻓。<h3 id=4-4-6、拥塞算法示意图><a class=headerlink href=#4-4-6、拥塞算法示意图 title=4.4.6、拥塞算法示意图></a>4.4.6、拥塞算法示意图</h3><p>好了，以上就是拥塞控制的全部内容了，看完后，你再来看下⾯这张图⽚，每个过程我相信你都能明⽩：<p><img alt=image-20210418190933705 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418190933705.png?token=AIGEF3O7Y4XVQBQTANPYGO3EZZTZ2><h1 id=5、TCP性能传输><a class=headerlink href=#5、TCP性能传输 title=5、TCP性能传输></a>5、TCP性能传输</h1><h2 id=5-1、提升TCP三次握手性能><a class=headerlink href=#5-1、提升TCP三次握手性能 title=5.1、提升TCP三次握手性能></a>5.1、提升TCP三次握手性能</h2><p><strong>TCP 是⾯向连接的、可靠的、双向传输的传输层通信协议。在传输数据之前需要经过三次握⼿才能建⽴连接</strong>。<p><img alt=image-20210418200853587 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418200853587.png?token=AIGEF3PKZQ5DN2HYA6BCJCDEZZT2Y><p>那么，三次握⼿时间消耗在⼀个 HTTP 请求的平均时间中占⽐ 10% 以上，在⽹络状态不佳、⾼并发或者遭遇 SYN 攻击等场景中，如果不能有效正确的调节三次握⼿中的参数，就会对性能产⽣很多的影响。<p>如何正确有效的使⽤这些参数，来提⾼ TCP 三次握⼿的性能，这就需要理解「三次握⼿的状态变迁」，<strong>当出现问题时，先⽤ netstat 命令查看是哪个握⼿阶段出现问题，再来对症下药，⽽不是病急乱投医</strong>。<p><img alt=image-20210418200928818 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418200928818.png?token=AIGEF3LE7BG2HJ6Z6QJ6XKDEZZT32><p>客户端和服务端都可以通过三次握⼿优化性能。主动发起连接的客户端优化相对简单些，⽽服务端需要 监听端⼝，属于被动连接⽅，其间保持许多的中间状态，优化⽅法相对复杂⼀些。<p>所以，客户端（主动发起连接⽅）和服务端（被动连接⽅）优化的⽅式是不同的，接下来分别针对客户端和服务端来进行优化。<h3 id=5-1-1、客户端优化><a class=headerlink href=#5-1-1、客户端优化 title=5.1.1、客户端优化></a>5.1.1、客户端优化</h3><p><strong>三次握⼿建⽴连接⾸要⽬的是同步序列号</strong>。<p>SYN 的全称就叫 Synchronize Sequence Numbers（同步序列号）。<p><img alt=image-20210418201102398 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418201102398.png?token=AIGEF3MOTGYQRFXHFW5SSXTEZZT4Y><h4 id=5-1-1-1、SYN-SENT-状态优化><a title="5.1.1.1、SYN_SENT 状态优化" class=headerlink href=#5-1-1-1、SYN-SENT-状态优化></a>5.1.1.1、SYN_SENT 状态优化</h4><p>客户端 先发送 SYN 包，然后进入 SYN_SENT 状态。<p>如果客户端⻓时间没有收到 SYN+ACK 报⽂，则会重发 SYN 包，重发次数由 tcp_syn_retries 参数控制， 默认是 5 次：<p><img alt=image-20210418202018005 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202018005.png?token=AIGEF3PR3UMRW7WSX34RVLDEZZT6S><p>通常，第⼀次超时重传是在 1 秒后，第⼆次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。<strong>每次超时的时间是上⼀次的 2 倍</strong>。当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就会终⽌三次握⼿。<p>所以，<strong>总耗时是 1+2+4+8+16+32=63 秒，⼤约 1 分钟左右</strong>。<p><img alt=image-20210418202153188 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202153188.png?token=AIGEF3JDYMONIYRUTC5QUJ3EZZT7S><p>客户端优化参考如下：<strong>根据 ⽹络稳定性 和 服务器繁忙程度 来修改 SYN 重传次数，调整客户端三次握⼿时间上限</strong>。<h3 id=5-1-2、服务端优化><a class=headerlink href=#5-1-2、服务端优化 title=5.1.2、服务端优化></a>5.1.2、服务端优化</h3><p>服务端收到 SYN 包后会⽴⻢回复 SYN+ACK 包，表明收到了客户端序列号，同时也把⾃⼰的序列号发给对⽅。<p>服务端 收到 新连接 就会 进入SYN_RCV状态，同时 Linux 内核就会建⽴⼀个「半连接队列」来维护「未完成」的握⼿信息，当半连接队列溢出后，服务端就⽆法再建⽴新连接。<p><img alt=image-20210418202233550 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202233550.png?token=AIGEF3JSAG777JY5DJFM5H3EZZUAO><p>SYN 攻击半连接队列。<h4 id=5-1-2-1、如何查看由于-SYN-半连接队列已满⽽被丢弃连接的情况？><a title="5.1.2.1、如何查看由于 SYN 半连接队列已满⽽被丢弃连接的情况？" class=headerlink href=#5-1-2-1、如何查看由于-SYN-半连接队列已满⽽被丢弃连接的情况？></a>5.1.2.1、如何查看由于 SYN 半连接队列已满⽽被丢弃连接的情况？</h4><p>可以从 <code>netstat -s</code> 命令返回的统计结果中得到由于半连接队列已满而引发的失败次数：<p><img alt=image-20210418202341149 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202341149.png?token=AIGEF3NE7TGUGCNVKOK7L7TEZZUBM><p>上⾯输出的数值是累计值，表示共有多少个 TCP 连接因半连接队列溢出⽽被丢弃。隔⼏秒执⾏⼏次，如果有上升趋势，说明当前存在半连接队列溢出现象。<h4 id=5-1-2-2、如何调整-SYN-半连接队列⼤⼩？><a title="5.1.2.2、如何调整 SYN 半连接队列⼤⼩？" class=headerlink href=#5-1-2-2、如何调整-SYN-半连接队列⼤⼩？></a>5.1.2.2、如何调整 SYN 半连接队列⼤⼩？</h4><p><strong>要想增⼤半连接队列，不仅需要增大 <code>tcp_max_syn_backlog</code> 的值，还需增⼤ accept 队列。</strong>两者缺一不可，否则⽆效。<p>增⼤ <code>tcp_max_syn_backlog</code> 和 <code>somaxconn</code> 的⽅法是修改 Linux 内核参数：<p><img alt=image-20210418202433581 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202433581.png?token=AIGEF3LYEPBDR246AOHSDEDEZZUC2><p>增⼤ backlog 的⽅式，每个 Web 服务都不同，⽐如 Nginx 增⼤ backlog 的⽅法如下：<p><img alt=image-20210418202450402 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202450402.png?token=AIGEF3IAGE5H6T7P3G44GKLEZZUDU><p>最后，改变了如上这些参数后，要᯿启 Nginx 服务，因为 SYN 半连接队列和 accept 队列都是在 listen() 初始化的。<h4 id=5-1-2-3、如果-SYN-半连接队列已满，只能丢弃连接吗？><a title="5.1.2.3、如果 SYN 半连接队列已满，只能丢弃连接吗？" class=headerlink href=#5-1-2-3、如果-SYN-半连接队列已满，只能丢弃连接吗？></a>5.1.2.3、如果 SYN 半连接队列已满，只能丢弃连接吗？</h4><p>事实并非如此，开启 syncookies 功能就可实现不使⽤ SYN 半连接队列的情况下成功建⽴连接。<p>syncookies ⼯作原理：服务器根据当前状态计算出⼀个值，放在⼰⽅的 SYN+ACK 报⽂中并发出，当客户端返回 ACK 报⽂时，取出该值验证，如果合法，就认为连接建⽴成功，如下图所示。<p><img alt=image-20210418202537593 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202537593.png?token=AIGEF3KA4HVZAA4VGZDTMADEZZUEQ><p>syncookies 参数主要有以下三个值：<ul><li>0：表示关闭该功能；<li>1：表示仅当 SYN 半连接队列放不下时，再启⽤它；<li>2：表示⽆条件开启功能；</ul><p>在应对 SYN 攻击时，只需设为 1 即可：<p><img alt=image-20210418202615907 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202615907.png?token=AIGEF3LIA34H3VZQALS4XEDEZZUFK><h4 id=5-1-2-4、SYN-RCV-状态优化><a title="5.1.2.4、SYN_RCV 状态优化" class=headerlink href=#5-1-2-4、SYN-RCV-状态优化></a>5.1.2.4、SYN_RCV 状态优化</h4><p>当客户端接收到服务器发来的 SYN+ACK 报⽂后，就会回复 ACK 给服务器，同时客户端连接状态从 SYN_SENT 转换为 ESTABLISHED，表示连接建⽴成功。<p>服务器端连接成功建⽴的时间还要再往后，等到服务端收到客户端的 ACK 后，服务端的连接状态才变 为 ESTABLISHED。<p>如果服务器没有收到 ACK，就会重发 SYN+ACK 报⽂，同时⼀直处于 SYN_RCV 状态。<p>当⽹络繁忙、不稳定时，报⽂丢失就会变严重，此时应该调⼤᯿发次数。反之则可以调⼩重发次数。修改重发次数的⽅法是，调整 tcp_synack_retries 参数：<p><img alt=image-20210418202715040 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202715040.png?token=AIGEF3MST7XUUM4TWEWOZTLEZZUGG><p>tcp_synack_retries 的默认重试次数是 5 次，与客户端重传 SYN 类似，它的重传会经历 1、2、4、8、 16 秒，最后⼀次重传后会继续等待 32 秒，如果服务端仍然没有收到 ACK，才会关闭连接，故共需要等待 63 秒。<p>服务器收到 ACK 后连接建⽴成功，此时，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调⽤ accept 函数时把连接取出来。<p>如果进程不能及时地调⽤ accept 函数，就会造成 accept 队列（也称全连接队列）溢出，最终导致建⽴ 好的 TCP 连接被丢弃。<p><img alt=image-20210418202743734 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202743734.png?token=AIGEF3KFXAKORLXG72225EDEZZUHE><h4 id=5-1-2-5、accept-队列已满，只能丢弃连接吗？><a title="5.1.2.5、accept 队列已满，只能丢弃连接吗？" class=headerlink href=#5-1-2-5、accept-队列已满，只能丢弃连接吗？></a>5.1.2.5、accept 队列已满，只能丢弃连接吗？</h4><p>丢弃连接只是 Linux 的默认⾏为，我们还可以选择向客户端发送 RST 复位报⽂，告诉客户端连接已经 建⽴失败。打开这⼀功能需要将 tcp_abort_on_overflow 参数设置为 1。<p><img alt=image-20210418202819569 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202819569.png?token=AIGEF3IDCHC3R3GHJWZ363DEZZUIC><p>tcp_abort_on_overflow 共有两个值分别是 0 和 1，其分别表示：<ul><li>0 ：如果 accept 队列满了，那么 server 扔掉 client 发过来的 ack ；<li>1 ：如果 accept 队列满了，server 发送⼀个 RST 包给 client，表示废掉这个握⼿过程和这个连接；</ul><p>如果要想知道客户端连接不上服务端，是不是服务端 TCP 全连接队列满的原因，那么可以把 tcp_abort_on_overflow 设置为 1，这时如果在客户端异常中可以看到很多 connection reset by peer 的错误，那么就可以证明是由于服务端 TCP 全连接队列溢出的问题。<p>通常情况下，应当把 tcp_abort_on_overflow 设置为 0，因为这样更有利于应对突发流量。<p>举个例⼦，当 accept 队列满导致服务器丢掉了 ACK，与此同时，客户端的连接状态却是 ESTABLISHED，客户端进程就在建⽴好的连接上发送请求。只要服务器没有为请求回复 ACK，客户端 的请求就会被多次「᯿发」。如果服务器上的进程只是短暂的繁忙造成 accept 队列满，那么当 accept 队列有空位时，再次接收到的请求报⽂由于含有 ACK，仍然会触发服务器端成功建⽴连接。<p><img alt=image-20210418202908422 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418202908422.png?token=AIGEF3J3LN4DYGVK62II6WDEZZUJG><p>所以，tcp_abort_on_overflow 设为 0 可以提⾼连接建⽴的成功率，只有你⾮常肯定 TCP 全连接队列会 ⻓期溢出时，才能设置为 1 以尽快通知客户端。<h4 id=5-1-2-6、如何调整-accept-队列的⻓度？><a title="5.1.2.6、如何调整 accept 队列的⻓度？" class=headerlink href=#5-1-2-6、如何调整-accept-队列的⻓度？></a>5.1.2.6、如何调整 accept 队列的⻓度？</h4><p>可以通过 ss -lnt 命令查看：<p><img alt=image-20230805102847562 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805102847562.png?token=AIGEF3K4IHX6PSTQALISP6TEZZUKI><ul><li>Recv-Q：当前 accept 队列的⼤⼩，也就是当前已完成三次握⼿并等待服务端 accept() 的 TCP 连接；<li>Send-Q：accept 队列最⼤⻓度，上⾯的输出结果说明监听 8088 端⼝的 TCP 服务，accept 队列的 最⼤⻓度为 128；</ul><h4 id=5-1-2-7、如何查看由于-accept-连接队列已满，⽽被丢弃的连接？><a title="5.1.2.7、如何查看由于 accept 连接队列已满，⽽被丢弃的连接？" class=headerlink href=#5-1-2-7、如何查看由于-accept-连接队列已满，⽽被丢弃的连接？></a>5.1.2.7、如何查看由于 accept 连接队列已满，⽽被丢弃的连接？</h4><p>当超过了 accept 连接队列，服务端则会丢掉后续进来的 TCP 连接，丢掉的 TCP 连接个数会被统计，可使⽤ netstat -s 命令来查看：<p><img alt=image-20210418203046836 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418203046836.png?token=AIGEF3JHJ2G323ECIVG3Y4DEZZULS><p>上⾯看到的 41150 times ，表示 accept 队列溢出的次数，注意这个是累计值。可以隔⼏秒钟执⾏下， 如果这个数字⼀直在增加的话，说明 accept 连接队列偶尔满了。<p>如果持续不断地有连接因为 accept 队列溢出被丢弃，就应该调⼤ backlog 以及 somaxconn 参数。<h3 id=5-1-3、如何绕过三次握手><a class=headerlink href=#5-1-3、如何绕过三次握手 title=5.1.3、如何绕过三次握手></a>5.1.3、如何绕过三次握手</h3><p>下面我们看看如何绕过三次握⼿发送数据。<p>三次握⼿建⽴连接造成的后果就是，HTTP 请求必须在⼀个 RTT（客户端到服务器⼀个往返时间） 后才能发送。<p><img alt=image-20210418203159568 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418203159568.png?token=AIGEF3NJGPQKHQAGFYI24ADEZZUNA><p><strong>Linux 3.7内核版本之后提供了 TCP Fast Open 功能，这个功能可以减少 TCP 连接建⽴的时延</strong>。<h4 id=5-1-3-1、TCP-Fast-Open-⼯作⽅式。><a title="5.1.3.1、TCP Fast Open ⼯作⽅式。" class=headerlink href=#5-1-3-1、TCP-Fast-Open-⼯作⽅式。></a>5.1.3.1、TCP Fast Open ⼯作⽅式。</h4><p><img alt=image-20210418203407354 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418203407354.png?token=AIGEF3J3SFLUFVYQIXAAD4DEZZUN4><p>在客户端⾸次建⽴连接时的过程：<ol><li>客户端发送 SYN 报⽂，该报⽂包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie；<li>⽀持 TCP Fast Open 的服务器⽣成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以 发回客户端；<li>客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。</ol><p>所以，第⼀次发起 HTTP GET 请求的时候，还是需要正常的三次握⼿流程。<p>之后，如果客户端再次向服务器建⽴连接时的过程：<ol><li>客户端发送 SYN 报⽂，该报⽂包含「数据」（对于⾮ TFO 的普通 TCP 握⼿过程，SYN 报⽂中不 包含「数据」）以及此前记录的 Cookie；<li>⽀持 TCP Fast Open 的服务器会对收到 Cookie 进⾏校验：如果 Cookie 有效，服务器将在 SYNACK 报⽂中对 SYN 和「数据」进⾏确认，服务器随后将「数据」递送⾄相应的应⽤程序；如果 Cookie ⽆效，服务器将丢弃 SYN 报⽂中包含的「数据」，且其随后发出的 SYN-ACK 报⽂将只确 认 SYN 的对应序列号；<li>如果服务器接受了 SYN 报⽂中的「数据」，服务器可在握⼿完成之前发送「数据」，这就减少了 握⼿带来的 1 个 RTT 的时间消耗；<li>客户端将发送 ACK 确认服务器发回的 SYN 以及「数据」，但如果客户端在初始的 SYN 报⽂中发 送的「数据」没有被确认，则客户端将᯿新发送「数据」；<li>此后的 TCP 连接的数据传输过程和⾮ TFO 的正常情况⼀致。</ol><p>所以，之后发起 HTTP GET 请求的时候，可以绕过三次握⼿，这就减少了握⼿带来的 1 个 RTT 的时间消耗。<p>开启了 TFO 功能，cookie 的值是存放到 TCP option 字段⾥的：<p><img alt=image-20210418203616446 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418203616446.png?token=AIGEF3NTMZYSYP57CGLLTFTEZZUO4><p>注：客户端在请求并存储了 Fast Open Cookie 之后，可以不断᯿复 TCP Fast Open 直⾄服务器认为 Cookie ⽆效（通常为过期）。<h4 id=5-1-3-2、Linux-下如何打开-TCP-Fast-Open-功能><a title="5.1.3.2、Linux 下如何打开 TCP Fast Open 功能" class=headerlink href=#5-1-3-2、Linux-下如何打开-TCP-Fast-Open-功能></a>5.1.3.2、Linux 下如何打开 TCP Fast Open 功能</h4><p><strong>Linux环境中可通过设置 tcp_fastopn 内核参数来打开 Fast Open 功能</strong>：<p><img alt=image-20210418203701456 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418203701456.png?token=AIGEF3O3LKGSZ333JXPZHWTEZZUQA><p>tcp_fastopn 各个值的意义：<ul><li>0 关闭 1 作为客户端使⽤ Fast Open 功能；<li>2 作为服务端使⽤ Fast Open 功能；<li>3 ⽆论作为客户端还是服务器，都可以使⽤ Fast Open 功能；</ul><p>TCP Fast Open 功能需要客户端和服务端同时⽀持，才有效果。<h3 id=5-1-4、小结><a class=headerlink href=#5-1-4、小结 title=5.1.4、小结></a>5.1.4、小结</h3><p>TCP 三次握⼿参数。<p><img alt=image-20210418203828453 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418203828453.png?token=AIGEF3NYDNTGIFJQDUNTOUTEZZURC><h4 id=5-1-4-1、客户端优化><a class=headerlink href=#5-1-4-1、客户端优化 title=5.1.4.1、客户端优化></a>5.1.4.1、客户端优化</h4><p><strong>当客户端发起 SYN 包时，可以通过 <code>tcp_syn_retries</code> 控制其重传次数</strong>。<h4 id=5-1-4-2、服务端优化><a class=headerlink href=#5-1-4-2、服务端优化 title=5.1.4.2、服务端优化></a>5.1.4.2、服务端优化</h4><p>当服务端 SYN 半连接队列溢出后，会导致后续连接被丢弃，可以通过 netstat -s 观察半连接队列溢出的情况，如果 SYN 半连接队列溢出情况⽐较严重，可以通过 <code>tcp_max_syn_backlog</code>、<code>somaxconn</code>、 <code>backlog</code> 参数来调整 SYN 半连接队列的⼤⼩。<p>服务端回复 SYN+ACK 的᯿传次数由 <code>tcp_synack_retries</code> 参数控制。如果遭受 SYN 攻击，应把 <code>tcp_syncookies</code> 参数设置为 1，表示仅在 SYN 队列满后开启 syncookie 功能，可以保证正常的连接 成功建⽴。<p>服务端收到客户端返回的 ACK，会把连接移⼊ accpet 队列，等待进⾏调⽤ accpet() 函数取出连接。<p>可以通过 ss -lnt 查看服务端进程的 accept 队列⻓度，如果 accept 队列溢出，系统默认丢弃 ACK，如果可以把 <code>tcp_abort_on_overflow</code> 设置为 1 ，表示⽤ RST 通知客户端连接建⽴失败。<p>如果 accpet 队列溢出严重，可以通过 listen 函数的 backlog 参数和 somaxconn 系统参数提⾼队列⼤ ⼩，accept 队列⻓度取决于 min(backlog, somaxconn)。<h4 id=5-1-4-3、绕过三次握手><a class=headerlink href=#5-1-4-3、绕过三次握手 title=5.1.4.3、绕过三次握手></a>5.1.4.3、绕过三次握手</h4><p><strong>TCP Fast Open可绕过三次握⼿，使得 HTTP 请求减少 1 个 RTT 时间，Linux 下可通过 <code>tcp_fastopen</code> 开启该功能，同时必须保证服务端和客户端同时⽀持</strong>。<h2 id=5-2、提升TCP四次挥手性能><a class=headerlink href=#5-2、提升TCP四次挥手性能 title=5.2、提升TCP四次挥手性能></a>5.2、提升TCP四次挥手性能</h2><p>开始之前，需要先了解四次挥⼿状态变迁过程。<p>客户端和服务端双⽅都可以主动断开连接，通常先关闭连接的⼀⽅称为主动⽅，后关闭连接的⼀⽅称为被动⽅。<p><img alt=image-20210418204051701 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418204051701.png?token=AIGEF3J335BODYBV3SZHHUDEZZUSI><p>可以看到，四次挥⼿过程只涉及了两种报⽂，分别是 FIN 和 ACK：<ul><li>FIN 就是结束连接的意思，谁发出 FIN 报⽂，就表示它将不会再发送任何数据，关闭这⼀⽅向上的 传输通道；<li>ACK 就是确认的意思，⽤来通知对⽅：你⽅的发送通道已经关闭；</ul><p>四次挥⼿过程：<ol><li>当主动⽅关闭连接时，会发送 FIN 报⽂，此时发送⽅的 TCP 连接将从 ESTABLISHED 变成 FIN_WAIT1。<li>当被动⽅收到 FIN 报⽂后会⾃动回复 ACK 报⽂，连接状态将从 ESTABLISHED 变成 CLOSE_WAIT，表示被动⽅在等待进程调⽤ close 函数关闭连接。<li>当主动⽅收到这个 ACK 后，连接状态由 FIN_WAIT1 变为 FIN_WAIT2，也就是表示主动⽅的发送通 道就关闭了。<li>当被动⽅进⼊ CLOSE_WAIT 时，被动⽅还会继续处理数据，等到进程的 read 函数返回 0 后，应⽤ 程序就会调⽤ close 函数，进⽽触发内核发送 FIN 报⽂，此时被动⽅的连接状态变为 LAST_ACK。<li>当主动⽅收到这个 FIN 报⽂后，内核会回复 ACK 报⽂给被动⽅，同时主动⽅的连接状态由 FIN_WAIT2 变为 TIME_WAIT，在 Linux 系统下⼤约等待 1 分钟后，TIME_WAIT 状态的连接才会 彻底关闭。<li>当被动⽅收到最后的 ACK 报⽂后，被动⽅的连接就会关闭。</ol><p>你可以看到，每个⽅向都需要⼀个 FIN 和⼀个 ACK，因此通常被称为 四次挥⼿。<p><font color=red>注意：主动关闭连接的才有 TIME_WAIT 状态。</font><h3 id=5-2-1、主动方优化><a class=headerlink href=#5-2-1、主动方优化 title=5.2.1、主动方优化></a>5.2.1、主动方优化</h3><p><strong>关闭连接的⽅式通常有两种，分别是 RST报⽂关闭 和 FIN报⽂关闭</strong>。<p>如果进程异常退出了，内核就会发送 RST 报⽂来关闭，它可以不⾛四次挥⼿流程，是⼀个暴⼒关闭连接的⽅式。<p>安全关闭连接的⽅式必须通过四次挥⼿，它由进程调⽤ close 和 shutdown 函数发起 FIN 报⽂ （shutdown 参数须传⼊ <code>SHUT_WR</code> 或者 <code>SHUT_RDWR</code> 才会发送 FIN）。<h4 id=5-2-1-1、-close-函数和-shutdown-函数有什么区别？><a title="5.2.1.1、 close 函数和 shutdown 函数有什么区别？" class=headerlink href=#5-2-1-1、-close-函数和-shutdown-函数有什么区别？></a>5.2.1.1、 close 函数和 shutdown 函数有什么区别？</h4><p>调⽤了 close 函数意味着完全断开连接，完全断开后⽆法传输数据，且也不能发送数据。 此时， 调⽤了 close 函数的⼀⽅的连接叫做「孤⼉连接」，如果你⽤ netstat -p 命令，会发现连接对应的进程名为空。<p>使⽤ close 函数关闭连接是不优雅的。于是，就出现了⼀种优雅关闭连接的 shutdown 函数，它可以控制只关闭⼀个⽅向的连接：<p><img alt=image-20210418204332745 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418204332745.png?token=AIGEF3LI4BBBZGHTKCMH7Y3EZZUTU><p>第⼆个参数决定断开连接的⽅式，主要有以下三种⽅式：<ul><li>SHUT_RD(0)：关闭连接的「读」这个⽅向，如果接收缓冲区有已接收的数据，则将会被丢弃，并 且后续再收到新的数据，会对数据进⾏ ACK，然后悄悄地丢弃。也就是说，对端还是会接收到 ACK，在这种情况下根本不知道数据已经被丢弃了。<li>SHUT_WR(1)：关闭连接的「写」这个⽅向，这就是常被称为「半关闭」的连接。如果发送缓冲区 还有未发送的数据，将被⽴即发送出去，并发送⼀个 FIN 报⽂给对端。<li>SHUT_RDWR(2)：相当于 SHUT_RD 和 SHUT_WR 操作各⼀次，关闭套接字的读和写两个⽅向。</ul><p>close 和 shutdown 函数都可以关闭连接，但这两种⽅式关闭的连接，不仅仅在功能上存在差异，控制它们的 Linux 参数也不相同。<h4 id=5-2-1-2、FIN-WAIT1-状态的优化><a title="5.2.1.2、FIN_WAIT1 状态的优化" class=headerlink href=#5-2-1-2、FIN-WAIT1-状态的优化></a>5.2.1.2、FIN_WAIT1 状态的优化</h4><p>主动⽅发送 FIN 报⽂后，连接就处于 FIN_WAIT1 状态，正常情况下，如果能及时收到被动⽅的 ACK， 则会很快变为 FIN_WAIT2 状态。<p>但是当迟迟收不到对⽅返回的 ACK 时，连接就会⼀直处于 FIN_WAIT1 状态。此时，内核会定时重发 FIN 报⽂，其中重发次数由 <code>tcp_orphan_retries</code> 参数控制（注意，orphan 虽然是孤⼉的意思，该参数 却不只对孤⼉连接有效，事实上，它对所有 FIN_WAIT1 状态下的连接都有效），默认值是 0。<p><img alt=image-20210418204448802 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418204448802.png?token=AIGEF3NJBMGXP7VKHIXI3UDEZZUVY><p>你可能会好奇，这 0 表示⼏次？实际上当为 0 时，特指 8 次，从下⾯的内核源码可知：<p><img alt=image-20210418204505382 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418204505382.png?token=AIGEF3IARNNM3GI3IT34CELEZZUWW><p>如果 FIN_WAIT1 状态连接很多，我们就需要考虑降低 tcp_orphan_retries 的值，当᯿传次数超过 tcp_orphan_retries 时，连接就会直接关闭掉。<p>对于普遍正常情况时，调低 tcp_orphan_retries 就已经可以了。如果遇到恶意攻击，FIN 报⽂根本⽆法 发送出去，这由 TCP 两个特性导致的：<ul><li>⾸先，TCP 必须保证报⽂是有序发送的，FIN 报⽂也不例外，当发送缓冲区还有数据没有发送时， FIN 报⽂也不能提前发送。<li>其次，TCP 有流量控制功能，当接收⽅接收窗⼝为 0 时，发送⽅就不能再发送数据。所以，当攻击 者下载⼤⽂件时，就可以通过接收窗⼝设为 0 ，这就会使得 FIN 报⽂都⽆法发送出去，那么连接会 ⼀直处于 FIN_WAIT1 状态。</ul><p>解决这种问题的⽅法，是调整 tcp_max_orphans 参数，它定义了「孤⼉连接」的最⼤数量：<p><img alt=image-20210418204559635 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418204559635.png?token=AIGEF3MRLKYYVVHK6L3S3Y3EZZUXY><p>当进程调⽤了 close 函数关闭连接，此时连接就会是「孤⼉连接」，因为它⽆法再发送和接收数据。 Linux 系统为了防⽌孤⼉连接过多，导致系统资源⻓时间被占⽤，就提供了 tcp_max_orphans 参数。 如果孤⼉连接数量⼤于它，新增的孤⼉连接将不再⾛四次挥⼿，⽽是直接发送 RST 复位报⽂强制关 闭。<h4 id=5-2-1-3、FIN-WAIT2-状态的优化><a title="5.2.1.3、FIN_WAIT2 状态的优化" class=headerlink href=#5-2-1-3、FIN-WAIT2-状态的优化></a>5.2.1.3、FIN_WAIT2 状态的优化</h4><p>当主动⽅收到 ACK 报⽂后，会处于 FIN_WAIT2 状态，就表示主动⽅的发送通道已经关闭，接下来将等待对⽅发送 FIN 报⽂，关闭对⽅的发送通道。<p>这时，如果连接是⽤ shutdown 函数关闭的，连接可以⼀直处于 FIN_WAIT2 状态，因为它可能还可以 发送或接收数据。但对于 close 函数关闭的孤⼉连接，由于⽆法再发送和接收数据，所以这个状态不可以持续太久，⽽ tcp_fin_timeout 控制了这个状态下连接的持续时⻓，默认值是 60 秒：<p><img alt=image-20210418204818957 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418204818957.png?token=AIGEF3LZ62PJJVNTIUR4BBTEZZUZE><p>它意味着对于孤⼉连接（调⽤ close 关闭的连接），如果在 60 秒后还没有收到 FIN 报⽂，连接就会直 接关闭。<p>这个 60 秒不是随便决定的，它与 TIME_WAIT 状态持续的时间是相同的，后⾯我们再来说说为什么是 60 秒。<h4 id=5-2-1-4、TIME-WAIT-状态的优化><a title="5.2.1.4、TIME_WAIT 状态的优化" class=headerlink href=#5-2-1-4、TIME-WAIT-状态的优化></a>5.2.1.4、TIME_WAIT 状态的优化</h4><p>TIME_WAIT 是主动⽅四次挥⼿的最后⼀个状态，也是最常遇⻅的状态。<p>当收到被动⽅发来的 FIN 报⽂后，主动⽅会⽴刻回复 ACK，表示确认对⽅的发送通道已经关闭，接着 就处于 TIME_WAIT 状态。在 Linux 系统，TIME_WAIT 状态会持续 60 秒后才会进⼊关闭状态。<p>TIME_WAIT 状态的连接，在主动⽅看来确实快已经关闭了。然后，被动⽅没有收到 ACK 报⽂前，还是处于 <code>LAST_ACK</code> 状态。如果这个 ACK 报⽂没有到达被动⽅，被动⽅就会重发 FIN 报⽂。重发次数仍然由前⾯介绍过的 <code>tcp_orphan_retries</code>参数控制。<p>TIME-WAIT 的状态尤其重要，主要是两个原因：<ul><li>防⽌具有相同「四元组」的「旧」数据包被收到；<li>保证「被动关闭连接」的⼀⽅能被正确的关闭，即保证最后的 ACK 能让被动关闭⽅接收，从⽽帮 助其正常关闭；</ul><p><strong>原因⼀：防⽌旧连接的数据包</strong><p>TIME-WAIT 的⼀个作⽤是防⽌收到历史数据，从⽽导致数据错乱的问题。<p>假设 TIME-WAIT 没有等待时间或时间过短，被延迟的数据包抵达后会发⽣什么呢？<p><img alt=image-20210418205021190 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205021190.png?token=AIGEF3MHXN4WBSV26XSBUELEZZU22><ul><li>如上图⻩⾊框框服务端在关闭连接之前发送的 SEQ = 301 报⽂，被⽹络延迟了。<li>这时有相同端⼝的 TCP 连接被复⽤后，被延迟的 SEQ = 301 抵达了客户端，那么客户端是有可能 正常接收这个过期的报⽂，这就会产⽣数据错乱等严᯿的问题。</ul><p>所以，TCP 就设计出了这么⼀个机制，经过 2MSL 这个时间，⾜以让两个⽅向上的数据包都被丢弃， 使得原来连接的数据包在⽹络中都⾃然消失，再出现的数据包⼀定都是新建⽴连接所产⽣的。<p><strong>原因⼆：保证连接正确关闭</strong><p>TIME-WAIT 的另外⼀个作⽤是等待⾜够的时间以确保最后的 ACK 能让被动关闭⽅接收，从⽽帮助其正 常关闭。<p>假设 TIME-WAIT 没有等待时间或时间过短，断开连接会造成什么问题呢？<p><img alt=image-20210418205117533 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205117533.png?token=AIGEF3MFFBYKXCNBGCX3D5LEZZU4A><ul><li>如上图红⾊框框客户端四次挥⼿的最后⼀个 ACK 报⽂如果在⽹络中被丢失了，此时如果客户端 TIME-WAIT 过短或没有，则就直接进⼊了 CLOSE 状态了，那么服务端则会⼀直处在 LAST-ACK 状态。<li>当客户端发起建⽴连接的 SYN 请求报⽂后，服务端会发送 RST 报⽂给客户端，连接建⽴的过程 就会被终⽌。</ul><p>我们再回过头来看看，为什么 TIME_WAIT 状态要保持 60 秒呢？这与孤⼉连接 FIN_WAIT2 状态默认保 留 60 秒的原理是⼀样的，因为这两个状态都需要保持 2MSL 时⻓。MSL 全称是 Maximum Segment Lifetime，它定义了⼀个报⽂在⽹络中的最⻓⽣存时间（报⽂每经过⼀次路由器的转发，IP 头部的 TTL 字段就会减 1，减到 0 时报⽂就被丢弃，这就限制了报⽂的最⻓存活时间）。<p>为什么是 2 MSL 的时⻓呢？这其实是相当于⾄少允许报⽂丢失⼀次。⽐如，若 ACK 在⼀个 MSL 内丢 失，这样被动⽅᯿发的 FIN 会在第 2 个 MSL 内到达，TIME_WAIT 状态的连接可以应对。<p>为什么不是 4 或者 8 MSL 的时⻓呢？你可以想象⼀个丢包率达到百分之⼀的糟糕⽹络，连续两次丢包 的概率只有万分之⼀，这个概率实在是太⼩了，忽略它⽐解决它更具性价⽐。<p>因此，TIME_WAIT 和 FIN_WAIT2 状态的最⼤时⻓都是 2 MSL，由于在 Linux 系统中，MSL 的值固定 为 30 秒，所以它们都是 60 秒。<p>虽然 TIME_WAIT 状态有存在的必要，但它毕竟会消耗系统资源。如果发起连接⼀⽅的 TIME_WAIT 状 态过多，占满了所有端⼝资源，则会导致⽆法创建新连接。<ul><li><p>客户端受端⼝资源限制</p> <p>如果客户端 TIME_WAIT 过多，就会导致端⼝资源被占⽤，因为端⼝就 65536个，被占满就会导致⽆法创建新的连接；</p><li><p>服务端受系统资源限制</p> <p>由于⼀个四元组表示TCP连接，理论上服务端可以建⽴很多连接，服务端 确实只监听⼀个端⼝，但是会把连接扔给处理线程，所以理论上监听的端⼝可以继续监听。但是线 程池处理不了那么多⼀直不断的连接了。所以当服务端出现⼤量 TIME_WAIT 时，系统资源被占满 时，会导致处理不过来新的连接；</p></ul><p>另外，Linux 提供了 tcp_max_tw_buckets 参数，当 TIME_WAIT 的连接数量超过该参数时，新关闭 的连接就不再经历 TIME_WAIT ⽽直接关闭：<p><img alt=image-20210418205305424 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205305424.png?token=AIGEF3MWW57T5KNZR3E4N7TEZZU5I><p>当服务器的并发连接增多时，相应地，同时处于 TIME_WAIT 状态的连接数量也会变多，此时就应当调 ⼤ tcp_max_tw_buckets 参数，减少不同连接间数据错乱的概率。<p>tcp_max_tw_buckets 也不是越⼤越好，毕竟内存和端⼝都是有限的。<p>有⼀种⽅式可以在建⽴新连接时，复⽤处于 TIME_WAIT 状态的连接，那就是打开 tcp_tw_reuse 参 数。但是需要注意，该参数是只⽤于客户端（建⽴连接的发起⽅），因为是在调⽤ connect() 时起作⽤ 的，⽽对于服务端（被动连接⽅）是没有⽤的。<p><img alt=image-20210418205329777 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205329777.png?token=AIGEF3ORD7GOE7HCQEI4Z4TEZZU6K><p>tcp_tw_reuse 从协议⻆度理解是安全可控的，可以复⽤处于 TIME_WAIT 的端⼝为新的连接所⽤。<p>什么是协议⻆度理解的安全可控呢？主要有两点：<ul><li>只适⽤于连接发起⽅，也就是 C/S 模型中的客户端；<li>对应的 TIME_WAIT 状态的连接创建时间超过 1 秒才可以被复⽤。</ul><p>使⽤这个选项，还有⼀个前提，需要打开对 TCP 时间戳的⽀持（对⽅也要打开 ）：<p><img alt=image-20230805103313643 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805103313643.png?token=AIGEF3NSSNDSGZCKRVNFJ4TEZZVAM><p>由于引⼊了时间戳，它能带来了些好处：<ul><li>我们在前⾯提到的 2MSL 问题就不复存在了，因为᯿复的数据包会因为时间戳过期被⾃然丢弃；<li>同时，它还可以防⽌序列号绕回，也是因为᯿复的数据包会由于时间戳过期被⾃然丢弃；</ul><p>时间戳是在 TCP 的选项字段⾥定义的，开启了时间戳功能，在 TCP 报⽂传输的时候会带上发送报⽂的 时间戳。<p><img alt=image-20210418205502767 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205502767.png?token=AIGEF3NJ2QH5KMH6NFUXLH3EZZVBG><p>我们来看看开启了 tcp_tw_reuse 功能，如果四次挥⼿中的最后⼀次 ACK 在⽹络中丢失了，会发⽣什么？<p><img alt=image-20210418205550656 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205550656.png?token=AIGEF3JWSRU23OMVRDXEAVDEZZVCI><p>上图的流程：<ul><li>四次挥⼿中的最后⼀次 ACK 在⽹络中丢失了，服务端⼀直处于 LAST_ACK 状态；<li>客户端由于开启了 tcp_tw_reuse 功能，客户端再次发起新连接的时候，会复⽤超过 1 秒后的 time_wait 状态的连接。但客户端新发的 SYN 包会被忽略（由于时间戳），因为服务端⽐较了客户 端的上⼀个报⽂与 SYN 报⽂的时间戳，过期的报⽂就会被服务端丢弃；<li>服务端 FIN 报⽂迟迟没有收到四次挥⼿的最后⼀次 ACK，于是超时᯿发了 FIN 报⽂给客户端；<li>处于 SYN_SENT 状态的客户端，由于收到了 FIN 报⽂，则会回 RST 给服务端，于是服务端就离开 了 LAST_ACK 状态；<li>最初的客户端 SYN 报⽂超时重发了（ 1 秒钟后），此时就与服务端能正确的三次握⼿了。</ul><p>所以⼤家都会说开启了 tcp_tw_reuse，可以在复⽤了 time_wait 状态的 1 秒过后成功建⽴连接，这 1 秒 主要是花费在 SYN 包᯿传。<p>另外，⽼版本的 Linux 还提供了 tcp_tw_recycle 参数，但是当开启了它，就有两个坑：<ul><li>Linux 会加快客户端和服务端 TIME_WAIT 状态的时间，也就是它会使得 TIME_WAIT 状态会⼩于 60 秒，很容易导致数据错乱；<li>另外，Linux 会丢弃所有来⾃远端时间戳⼩于上次记录的时间戳（由同⼀个远端发送的）的任何数 据包。就是说要使⽤该选项，则必须保证数据包的时间戳是单调递增的。那么，问题在于，此处的 时间戳并不是我们通常意义上⾯的绝对时间，⽽是⼀个相对时间。很多情况下，我们是没法保证时 间戳单调递增的，⽐如使⽤了 NAT、LVS 等情况；</ul><p>所以，不建议设置为 1 ，在 Linux 4.12 版本后，Linux 内核直接取消了这⼀参数，建议关闭它：<p><img alt=image-20210418205726162 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205726162.png?token=AIGEF3MS2IW2ALHPL7GD3TTEZZVDU><p>另外，我们可以在程序中设置 socket 选项，来设置调⽤ close 关闭连接⾏为。<p><img alt=image-20210418205745092 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205745092.png?token=AIGEF3N4L43FUN4U3HXAS4LEZZVEW><p>如果 l_onoff 为⾮ 0， 且 l_linger 值为 0，那么调⽤ close 后，会⽴该发送⼀个 RST 标志给对 端，该 TCP 连接将跳过四次挥⼿，也就跳过了 TIME_WAIT 状态，直接关闭。<p>但这为跨越 TIME_WAIT 状态提供了⼀个可能，不过是⼀个⾮常危险的⾏为，不值得提倡。<h3 id=5-2-2、被动方优化><a class=headerlink href=#5-2-2、被动方优化 title=5.2.2、被动方优化></a>5.2.2、被动方优化</h3><p>当被动⽅收到 FIN 报⽂时，内核会⾃动回复 ACK，同时连接处于 CLOSE_WAIT 状态，顾名思义，它表示等待应⽤进程调⽤ close 函数关闭连接。<p>内核没有权利替代进程去关闭连接，因为如果主动⽅是通过 shutdown 关闭连接，那么它就是想在半关 闭连接上接收数据或发送数据。因此，Linux 并没有限制 CLOSE_WAIT 状态的持续时间。<p>当然，⼤多数应⽤程序并不使⽤ shutdown 函数关闭连接。所以，当你⽤ netstat 命令发现⼤量 CLOSE_WAIT 状态。就需要排查你的应⽤程序，因为可能因为应⽤程序出现了 Bug，read 函数返回 0 时，没有调⽤ close 函数。<p>处于 CLOSE_WAIT 状态时，调⽤了 close 函数，内核就会发出 FIN 报⽂关闭发送通道，同时连接进⼊ LAST_ACK 状态，等待主动⽅返回 ACK 来确认连接关闭。<p>如果迟迟收不到这个 ACK，内核就会重发 FIN 报⽂，᯿发次数仍然由 tcp_orphan_retries 参数控制，这 与主动⽅重发 FIN 报⽂的优化策略⼀致。<p>还有⼀点我们需要注意的，如果被动⽅迅速调⽤ close 函数，那么被动⽅的 ACK 和 FIN 有可能在⼀个 报⽂中发送，这样看起来，四次挥⼿会变成三次挥⼿，这只是⼀种特殊情况，不⽤在意。<h4 id=5-2-2-1、如果连接双⽅同时关闭连接，会怎么样？><a class=headerlink href=#5-2-2-1、如果连接双⽅同时关闭连接，会怎么样？ title=5.2.2.1、如果连接双⽅同时关闭连接，会怎么样？></a>5.2.2.1、如果连接双⽅同时关闭连接，会怎么样？</h4><p>由于 TCP 是双全⼯的协议，所以是会出现两⽅同时关闭连接的现象，也就是同时发送了 FIN 报⽂。<p>此时，上⾯介绍的优化策略仍然适⽤。两⽅发送 FIN 报⽂时，都认为⾃⼰是主动⽅，所以都进⼊了 FIN_WAIT1 状态，FIN 报⽂的᯿发次数仍由 tcp_orphan_retries 参数控制。<p><img alt=image-20210418205925842 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418205925842.png?token=AIGEF3L2IHRNUBIAAQ46BKDEZZVF2><p>接下来，双⽅在等待 ACK 报⽂的过程中，都等来了 FIN 报⽂。这是⼀种新情况，所以连接会进⼊⼀种 叫做 CLOSING 的新状态，它替代了 FIN_WAIT2 状态。接着，双⽅内核回复 ACK 确认对⽅发送通道 的关闭后，进⼊ TIME_WAIT 状态，等待 2MSL 的时间后，连接⾃动关闭。<h3 id=5-2-3、小结><a class=headerlink href=#5-2-3、小结 title=5.2.3、小结></a>5.2.3、小结</h3><p>针对 TCP 四次挥⼿的优化，我们需要根据主动⽅和被动⽅四次挥⼿状态变化来调整系统 TCP 内核参数。<p><img alt=image-20210418210021774 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418210021774.png?token=AIGEF3NILLHJKEH27TJVW6DEZZVG2><h4 id=5-2-3-1、主动方优化><a class=headerlink href=#5-2-3-1、主动方优化 title=5.2.3.1、主动方优化></a>5.2.3.1、主动方优化</h4><p>主动发起 FIN 报⽂断开连接的⼀⽅，如果迟迟没收到对⽅的 ACK 回复，则会重传 FIN 报⽂，重传次数 由 tcp_orphan_retries 参数决定。<p>当主动⽅收到 ACK 报⽂后，连接就进⼊ FIN_WAIT2 状态，根据关闭的⽅式不同，优化的⽅式也不同：<ul><li>如果这是 close 函数关闭的连接，那么它就是孤⼉连接。如果 tcp_fin_timeout 秒内没有收到对 ⽅的 FIN 报⽂，连接就直接关闭。同时，为了应对孤⼉连接占⽤太多的资源， tcp_max_orphans 定义了最⼤孤⼉连接的数量，超过时连接就会直接释放。<li>反之是 shutdown 函数关闭的连接，则不受此参数限制；</ul><p>当主动⽅接收到 FIN 报⽂，并返回 ACK 后，主动⽅的连接进⼊ TIME_WAIT 状态。这⼀状态会持续 1 分钟，为了防⽌ TIME_WAIT 状态占⽤太多的资源， tcp_max_tw_buckets 定义了最⼤数量，超过时连 接也会直接释放。<p>当 TIME_WAIT 状态过多时，还可以通过设置 tcp_tw_reuse 和 tcp_timestamps 为 1 ，将 TIME_WAIT 状态的端⼝复⽤于作为客户端的新连接，注意该参数只适⽤于客户端。<h4 id=5-2-3-2、被动⽅的优化><a class=headerlink href=#5-2-3-2、被动⽅的优化 title=5.2.3.2、被动⽅的优化></a>5.2.3.2、被动⽅的优化</h4><p>被动关闭的连接⽅应对⾮常简单，它在回复 ACK 后就进⼊了 CLOSE_WAIT 状态，等待进程调⽤ close 函数关闭连接。因此，出现⼤量 CLOSE_WAIT 状态的连接时，应当从应⽤程序中找问题。<p>当被动⽅发送 FIN 报⽂后，连接就进⼊ LAST_ACK 状态，在未等到 ACK 时，会在 tcp_orphan_retries 参数的控制下重发 FIN 报⽂。<h2 id=5-3、提升TCP传输数据性能><a class=headerlink href=#5-3、提升TCP传输数据性能 title=5.3、提升TCP传输数据性能></a>5.3、提升TCP传输数据性能</h2><p>在前⾯介绍的是三次握⼿和四次挥⼿的优化策略，接下来主要介绍的是 TCP 传输数据时的优化策略。<p>TCP 连接由内核维护，内核会为每个连接建⽴内存缓冲区：<ul><li>如果连接的内存配置过⼩，就⽆法充分使⽤⽹络带宽，TCP 传输效率就会降低；<li>如果连接的内存配置过⼤，很容易把服务器资源耗尽，这样就会导致新连接⽆法建⽴；</ul><p>因此，我们必须理解 Linux 下 TCP 内存的⽤途，才能正确地配置内存⼤⼩。<h3 id=5-3-1、滑动窗⼝影响传输速度><a class=headerlink href=#5-3-1、滑动窗⼝影响传输速度 title=5.3.1、滑动窗⼝影响传输速度></a>5.3.1、滑动窗⼝影响传输速度</h3><p>TCP 会保证每⼀个报⽂都能够抵达对⽅，它的机制是：报⽂发出去后，必须接收到对⽅返回的确认报⽂ ACK，如果迟迟未收到，就会超时重发该报⽂，直到收到对⽅的 ACK 为⽌。<p>所以，TCP 报⽂发出去后，并不会⽴⻢从内存中删除，因为重传时还需要⽤到它。<p>由于 TCP 是内核维护的，所以报⽂存放在内核缓冲区。如果连接⾮常多，我们可以通过 free 命令观察到 buff/cache 内存是否增⼤。<p>如果 TCP 是每发送⼀个数据，都要进⾏⼀次确认应答。当上⼀个数据包收到了应答了， 再发送下⼀ 个。这个模式就有点像我和你⾯对⾯聊天，你⼀句我⼀句，但这种⽅式的缺点就是 效率很低。<p><img alt=image-20210418210742380 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418210742380.png?token=AIGEF3OFI37WZUHK74FQJ4LEZZVIA><p>所以，这样的传输⽅式有⼀个缺点：<strong>数据包的往返时间越⻓，通信的效率就越低</strong>。<p>要解决这⼀问题不难，并⾏批量发送报⽂，再批量确认报⽂即可。<p><img alt=image-20210418210838615 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418210838615.png?token=AIGEF3JNA7QROZIRJVZKGA3EZZVJI><p>然⽽，这引出了另⼀个问题，发送⽅可以随⼼所欲的发送报⽂吗？当然不行，我们还得考虑接收⽅的处理能⼒。<p>当接收⽅硬件不如发送⽅，或者系统繁忙、资源紧张时，是⽆法瞬间处理这么多报⽂的。于是，这些报 ⽂只能被丢掉，使得⽹络效率⾮常低。<p>为了解决这种现象发⽣，TCP 提供⼀种机制可以让「发送⽅」根据「接收⽅」的实际接收能⼒控制发送 的数据量，这就是滑动窗⼝的由来。<p>接收⽅根据它的缓冲区，可以计算出后续能够接收多少字节的报⽂，这个数字叫做接收窗⼝。当内核接 收到报⽂时，必须⽤缓冲区存放它们，这样剩余缓冲区空间变⼩，接收窗⼝也就变⼩了；当进程调⽤ read 函数后，数据被读⼊了⽤户空间，内核缓冲区就被清空，这意味着主机可以接收更多的报⽂，接收 窗⼝就会变⼤。<p>因此，接收窗⼝并不是恒定不变的，接收⽅会把当前可接收的⼤⼩放在 TCP 报⽂头部中的窗⼝字段， 这样就可以起到窗⼝⼤⼩通知的作⽤。<p>发送⽅的窗⼝等价于接收⽅的窗⼝吗？如果不考虑拥塞控制，发送⽅的窗⼝⼤⼩「约等于」接收⽅的窗⼝⼤⼩，因为窗⼝通知报⽂在⽹络传输是存在时延的，所以是约等于的关系。<p><img alt=image-20210418211048586 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418211048586.png?token=AIGEF3IOPQFQ3WYV3C6BLKDEZZVKO><p>从上图中可以看到，窗⼝字段只有 2 个字节，因此它最多能表达 65535 字节⼤⼩的窗⼝，也就是 64KB ⼤⼩。<p>这个窗⼝⼤⼩最⼤值，在当今⾼速⽹络下，很明显是不够⽤的。所以后续有了扩充窗⼝的⽅法：在 TCP 选项字段定义了窗⼝扩⼤因⼦，⽤于扩⼤ TCP 通告窗⼝，其值⼤⼩是 2^14，这样就使 TCP 的窗⼝⼤ ⼩从 16 位扩⼤为 30 位（2^16 * 2^ 14 = 2^30），所以此时窗⼝的最⼤值可以达到 1GB。<p><img alt=image-20210418211130135 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418211130135.png?token=AIGEF3KM5Z6JBRZWQT46ATLEZZVLS><p>Linux 中打开这⼀功能，需要把 <code>tcp_window_scaling</code> 配置设为 1（默认打开）：<p><img alt=image-20210418211148700 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418211148700.png?token=AIGEF3IJM24JBAGI3R5MYHDEZZVMS><p>要使⽤窗⼝扩⼤选项，通讯双⽅必须在各⾃的 SYN 报⽂中发送这个选项：<ul><li>主动建⽴连接的⼀⽅在 SYN 报⽂中发送这个选项；<li>⽽被动建⽴连接的⼀⽅只有在收到带窗⼝扩⼤选项的 SYN 报⽂之后才能发送这个选项。</ul><p>这样看来，只要进程能及时地调⽤ read 函数读取数据，并且接收缓冲区配置得⾜够⼤，那么接收窗⼝ 就可以⽆限地放⼤，发送⽅也就⽆限地提升发送速度。<p>这是不可能的，因为⽹络的传输能⼒是有限的，当发送⽅依据发送窗⼝，发送超过⽹络处理能⼒的报⽂ 时，路由器会直接丢弃这些报⽂。因此，缓冲区的内存并不是越⼤越好。<h3 id=5-3-2、确定最⼤传输速度><a class=headerlink href=#5-3-2、确定最⼤传输速度 title=5.3.2、确定最⼤传输速度></a>5.3.2、确定最⼤传输速度</h3><p>我们知道 TCP 的传输速度受制于发送窗⼝与接收窗⼝，以及⽹络设备传输能⼒。其中，窗⼝⼤⼩由内核缓冲区⼤⼩决定。如果缓冲区与⽹络传输能⼒匹配，那么缓冲区的利⽤率就达到了最⼤化。<p>问题来了，如何计算⽹络的传输能⼒呢？<p>相信⼤家都知道⽹络是有「带宽」限制的，带宽描述的是⽹络传输能⼒，它与内核缓冲区的计量单位不同：<ul><li>带宽是单位时间内的流量，表达是「速度」，⽐如常⻅的带宽 100 MB/s；<li>缓冲区单位是字节，当⽹络速度乘以时间才能得到字节数；</ul><p>这⾥需要说⼀个概念，就是带宽时延积，它决定⽹络中⻜⾏报⽂的⼤⼩，它的计算⽅式<p><img alt=image-20210418211558531 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418211558531.png?token=AIGEF3LAXJXBB2UQVRVMKZTEZZVN4><p>⽐如最⼤带宽是 100 MB/s，⽹络时延（RTT）是 10ms 时，意味着客户端到服务端的⽹络⼀共可以存 放 100MB/s * 0.01s = 1MB 的字节。<p>这个 1MB 是带宽和时延的乘积，所以它就叫「带宽时延积」（缩写为 BDP，Bandwidth Delay Product）。同时，这 1MB 也表示「⻜⾏中」的 TCP 报⽂⼤⼩，它们就在⽹络线路、路由器等⽹络设 备上。如果⻜⾏报⽂超过了 1 MB，就会导致⽹络过载，容易丢包。<p>由于发送缓冲区⼤⼩决定了发送窗⼝的上限，⽽发送窗⼝⼜决定了「已发送未确认」的⻜⾏报⽂的上 限。因此，发送缓冲区不能超过「带宽时延积」。<p>发送缓冲区与带宽时延积的关系：<ul><li>如果发送缓冲区「超过」带宽时延积，超出的部分就没办法有效的⽹络传输，同时导致⽹络过载， 容易丢包；<li>如果发送缓冲区「⼩于」带宽时延积，就不能很好的发挥出⽹络的传输效率。</ul><p>所以，发送缓冲区的⼤⼩最好是往带宽时延积靠近。<h3 id=5-3-3、调整缓冲区大小><a class=headerlink href=#5-3-3、调整缓冲区大小 title=5.3.3、调整缓冲区大小></a>5.3.3、调整缓冲区大小</h3><p>Linux中发送缓冲区和接收缓冲可⽤参数调节。设置完后，Linux 会根据你设置的缓冲区进⾏动态调节。<h4 id=5-3-3-1、调节发送缓冲区范围><a class=headerlink href=#5-3-3-1、调节发送缓冲区范围 title=5.3.3.1、调节发送缓冲区范围></a>5.3.3.1、调节发送缓冲区范围</h4><p>先来看看发送缓冲区，它的范围通过 <code>tcp_wmem</code> 参数配置；<p><img alt=image-20210418211755905 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418211755905.png?token=AIGEF3LEEIIBZJGXRG66WQLEZZVO6><p>上⾯三个数字单位都是字节，它们分别表示：<ul><li>第⼀个数值是动态范围的最⼩值，4096 byte = 4K；<li>第⼆个数值是初始默认值，87380 byte ≈ 86K；<li>第三个数值是动态范围的最⼤值，4194304 byte = 4096K（4M）；</ul><p>发送缓冲区是⾃⾏调节的，当发送⽅发送的数据被确认后，并且没有新的数据要发送，就会把发送缓冲区的内存释放掉。<h4 id=5-3-3-2、调节接收缓冲区范围><a class=headerlink href=#5-3-3-2、调节接收缓冲区范围 title=5.3.3.2、调节接收缓冲区范围></a>5.3.3.2、调节接收缓冲区范围</h4><p>⽽接收缓冲区的调整就⽐较复杂⼀些，先来看看设置接收缓冲区范围的 tcp_rmem 参数：<p><img alt=image-20230805103619338 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805103619338.png?token=AIGEF3PLZVBEFGJZGDTQLH3EZZVP6><p>上⾯三个数字单位都是字节，它们分别表示：<ul><li>第⼀个数值是动态范围的最⼩值，表示即使在内存压⼒下也可以保证的最⼩接收缓冲区⼤⼩，4096 byte = 4K；<li>第⼆个数值是初始默认值，87380 byte ≈ 86K；<li>第三个数值是动态范围的最⼤值，6291456 byte = 6144K（6M）；</ul><p>接收缓冲区可以根据系统空闲内存的⼤⼩来调节接收窗⼝：<ul><li>如果系统的空闲内存很多，就可以⾃动把缓冲区增⼤⼀些，这样传给对⽅的接收窗⼝也会变⼤，因 ⽽提升发送⽅发送的传输数据数量；<li>反之，如果系统的内存很紧张，就会减少缓冲区，这虽然会降低传输效率，可以保证更多的并发连 接正常⼯作；</ul><p>发送缓冲区的调节功能是⾃动开启的，⽽接收缓冲区则需要配置 <code>tcp_moderate_rcvbuf</code> 为 1 来开启调节功能：<p><img alt=image-20210418212006158 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418212006158.png?token=AIGEF3PV7PYPGEIURYGJ24LEZZVQ4><h4 id=5-3-3-3、调节-TCP-内存范围><a title="5.3.3.3、调节 TCP 内存范围" class=headerlink href=#5-3-3-3、调节-TCP-内存范围></a>5.3.3.3、调节 TCP 内存范围</h4><p>接收缓冲区调节时，怎么知道当前内存是否紧张或充分呢？这是通过 <code>tcp_mem</code> 配置完成的：<p><img alt=image-20210418212037121 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418212037121.png?token=AIGEF3KUWGGEUR7OLOSZG4DEZZVSQ><p>上⾯三个数字单位不是字节，⽽是「⻚⾯⼤⼩」，1 ⻚表示 4KB，它们分别表示：<ul><li>当 TCP 内存⼩于第 1 个值时，不需要进⾏⾃动调节；<li>在第 1 和第 2 个值之间时，内核开始调节接收缓冲区的⼤⼩；<li>⼤于第 3 个值时，内核不再为 TCP 分配新内存，此时新连接是⽆法建⽴的；</ul><p>⼀般情况下这些值是在系统启动时根据系统内存数量计算得到的。根据当前 <code>tcp_mem</code> 最⼤内存⻚⾯数是 177120，当内存为 (177120 * 4) / 1024K ≈ 692M 时，系统将⽆法为新的 TCP 连接分配内存，即 TCP 连接将被拒绝。<h4 id=5-3-3-4、根据实际场景调节的策略><a class=headerlink href=#5-3-3-4、根据实际场景调节的策略 title=5.3.3.4、根据实际场景调节的策略></a>5.3.3.4、根据实际场景调节的策略</h4><p>在⾼并发服务器中，为了兼顾⽹速与⼤量的并发连接，我们应当保证缓冲区的动态调整的最⼤值达到带宽时延积，⽽最⼩值保持默认的 4K 不变即可。⽽对于内存紧张的服务⽽⾔，调低默认值是提⾼并发的 有效⼿段。<p>同时，如果这是⽹络 IO 型服务器，那么，调⼤ <code>tcp_mem</code> 的上限可以让 TCP 连接使⽤更多的系统内存，这有利于提升并发能⼒。需要注意的是，<code>tcp_wmem</code> 和 <code>tcp_rmem</code> 的单位是字节，⽽ <code>tcp_mem</code> 的单位是⻚⾯⼤⼩。⽽且，千万不要在 socket 上直接设置 <code>SO_SNDBUF</code> 或者 <code>SO_RCVBUF</code>，这样会关闭缓冲区的动态调整功能。<h3 id=5-3-4、小结><a class=headerlink href=#5-3-4、小结 title=5.3.4、小结></a>5.3.4、小结</h3><p><img alt=image-20210418212216740 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210418212216740.png?token=AIGEF3KQCLYZSR6Y7FSCUWLEZZVTW><p><strong>TCP 可靠性通过ACK确认报⽂实现，⼜依赖滑动窗⼝提升了发送速度也兼顾了接收⽅的处理能⼒</strong>。<p>可是，默认的滑动窗⼝最⼤值只有 64 KB，不满⾜当今的⾼速⽹络要求，要提升发送速度必须提升滑动窗⼝上限，在 Linux 下是通过设置 <code>tcp_window_scaling</code> 为 1 做到，此时最⼤值可⾼达 1GB。<p>滑动窗⼝定义了⽹络中⻜⾏报⽂的最⼤字节数，当它超过带宽时延积时，⽹络过载，就会发⽣丢包。⽽当它⼩于带宽时延积时，就⽆法充分利⽤⽹络带宽。因此，滑动窗⼝的设置，必须参考带宽时延积。<p>内核缓冲区决定了滑动窗⼝的上限，缓冲区可分为：发送缓冲区 <code>tcp_wmem</code> 和接收缓冲区 <code>tcp_rmem</code>。<p>Linux 会对缓冲区动态调节，我们应该把缓冲区的上限设置为带宽时延积。发送缓冲区的调节功能是⾃ 动打开的，⽽接收缓冲区需要把 <code>tcp_moderate_rcvbuf</code> 设置为 1 来开启。其中，调节的依据是 TCP 内存范围 <code>tcp_mem</code>。<p>但需要注意的是，如果程序中的 socket 设置了 <code>SO_SNDBUF</code> 和 <code>SO_RCVBUF</code>，则会关闭缓冲区的动态调整功能，所以不建议在程序中设置它们，⽽是交给内核⾃动调整⽐较好。<p>有效配置这些参数后，既能够最⼤程度地保持并发性，也能让资源充裕时连接传输速度达到最⼤值。</div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Spring%E4%BA%8B%E5%8A%A1/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Spring%E4%BA%8B%E5%8A%A1/ itemprop=url>Spring系列-Spring事务</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-04 10:26:07" datetime=2023-10-04T10:26:07+08:00 itemprop=dateModified>2023-10-04</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Spring/ itemprop=url rel=index><span itemprop=name>Spring</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=基础知识><a class=headerlink href=#基础知识 title=基础知识></a>基础知识</h1><h2 id=1-1、事务定义><a class=headerlink href=#1-1、事务定义 title=1.1、事务定义></a>1.1、事务定义</h2><p>事务指的是 <strong>通过一系列操作来完成某个功能，这些操作要么全成功要么全失败。这个保证正确完成某个功能的规则称为事务</strong>。<h2 id=1-2、事务控制方式><a class=headerlink href=#1-2、事务控制方式 title=1.2、事务控制方式></a>1.2、事务控制方式</h2><p>Spring事务提供了两种事务控制方式：<ul><li><p><strong>编程式事务</strong></p> <p>使用<strong>事务代码控制业务代码</strong>的正确执行，事务代码和业务代码耦合在一起。这种方式<strong>不常用</strong>。</p><li><p><strong>声明式事务</strong></p> <p>Spring将事务代码进行封装，并通过注解来完成事务控制，实现了事务代码与业务代码的解耦。推荐这种方式。</p></ul><h2 id=1-3、事务相关类><a class=headerlink href=#1-3、事务相关类 title=1.3、事务相关类></a>1.3、事务相关类</h2><ul><li><p><strong>PlatformTransactionManager（平台事务管理器）</strong></p> <p>一个标准接口，具备事务提交、回滚、获取事务对象等功能。不同框架有不同的实现。</p><li><p><strong>TransactionDefinition（事务定义）</strong></p> <p>封装事务的隔离级别、传播行为、过期时间等信息。</p><li><p><strong>TransactionStatus（事务状态）</strong></p> <p>存储事务的状态信息。如事务是否提交、回滚等。</p></ul><h2 id=1-4、事务特性><a class=headerlink href=#1-4、事务特性 title=1.4、事务特性></a>1.4、事务特性</h2><ul><li><strong>原子性（atomicity）</strong>：强调事务不可分割.。<li><strong>一致性（consistency）</strong>：事务执行前后，数据的完整性保持一致.。<li><strong>隔离性（isolation）</strong>：一个事务执行过程中，不应该受到其他事务的干扰。<li><strong>持久性（durability）</strong>：事务一旦结束，数据就持久到数据库。</ul><h2 id=1-5、事务传播行为（propagation）><a class=headerlink href=#1-5、事务传播行为（propagation） title=1.5、事务传播行为（propagation）></a>1.5、事务传播行为（propagation）</h2><p>*<em>PROPAGATION_<em>（REQUIRED、SUPPORTS…）</em></em><ol><li><strong>REQUIRED（默认）</strong>：A调用B，B需要事务，如果A有事务，那么B就加入到A的事务，否则B单独创建一个事务。<li><strong>REQUIRES_NEW</strong>：A调用B，B需要一个新事务，如果A有事务那么就挂起，B单独创建一个新事务。<li><strong>SUPPORTS</strong>：A调用B，A有事务那么B就加入该事务，否则B就以非事务方式执行。<li><strong>NOT_SUPPORTED</strong>：A调用B，B以非事务方式执行，A有事务就挂起。<li><strong>MANDATORY</strong>：A调用B，B要加入A的事务，A没有事务就抛异常。<li><strong>NEVER</strong>：A调用B，B以非事务方式执行，A有事务则抛出异常。<li><strong>NESTED</strong>：A调用B，B新建一个事务，A有事务则以嵌套事务存在，否则就以新的事务执行。</ol><h2 id=1-6、事务隔离级别（isolation）><a class=headerlink href=#1-6、事务隔离级别（isolation） title=1.6、事务隔离级别（isolation）></a>1.6、事务隔离级别（isolation）</h2><p>事务隔离级别主要用于解决如下问题：<ul><li><strong>脏读</strong>：一个事务读到了另一个事务未提交的数据。<li><strong>不可重复读</strong>：一个事务读到了另一个事务已经提交的 update 数据，导致多次查询结果不一致.。<li><strong>幻读</strong>：一个事务读到了另一个事务已经提交的 insert 数据，导致多次查询结果不一致。</ul><p>事务隔离级别有如下几种：<ol><li><strong>DEFAULT</strong>：默认的隔离级别，数据库默认的事务隔离级别；（MySQL默认为可重复读；Oracle默认为读已提交）。<li><strong>Read Uncommitted（读未提交）</strong>：一个事务可以读取 未提交的事务的数据。会发生脏读 、不可重复读、幻读问题。<li><strong>Read Committed（读已提交）</strong>：一个事务可以读取 已提交的事务的数据。解决了脏读，但没有解决不可重复读、幻读问题。<li><strong>Repeatable Read（可重复读）</strong>：可以防止脏读、不可重复读，但幻读问题依然存在。<li><strong>Serializable（串行化）</strong>：代价高但可靠的一种隔离级别。事务顺序执行。可防止脏读、不可重复读、幻读。</ol><blockquote><p>MySQL支持全部4种隔离级别，默认隔离级别是<em><strong>可重复读</strong></em>。<p>Oracle仅支持 <strong>读已提交、串行化</strong> 两种隔离级别，默认是<strong>读已提交</strong>。</blockquote><h2 id=1-7、其它属性><a class=headerlink href=#1-7、其它属性 title=1.7、其它属性></a>1.7、其它属性</h2><ul><li><strong>read-only</strong>：是否只读；<li><strong>timeout</strong>：超时时间；</ul><h1 id=使用事务><a class=headerlink href=#使用事务 title=使用事务></a>使用事务</h1><h2 id=2-1、环境准备><a class=headerlink href=#2-1、环境准备 title=2.1、环境准备></a>2.1、环境准备</h2><p>要使用Spring事务，可选择导入<code>spring-jdbc</code>依赖。其它依赖可根据实际开发环境自行选择。<h2 id=2-2、XML声明式事务><a class=headerlink href=#2-2、XML声明式事务 title=2.2、XML声明式事务></a>2.2、XML声明式事务</h2><p>xml配置文件：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"transactionManager"</span> <span class=attr>class</span>=<span class=string>"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"dataSource"</span> <span class=attr>ref</span>=<span class=string>"dataSource"</span>></span><span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>tx:advice</span> <span class=attr>id</span>=<span class=string>"txAdvice"</span> <span class=attr>transaction-manager</span>=<span class=string>"transactionManager"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>tx:attributes</span>></span></span><br><span class=line>        <span class=tag><<span class=name>tx:method</span> <span class=attr>name</span>=<span class=string>"*"</span> <span class=attr>isolation</span>=<span class=string>"REPEATABLE_READ"</span> <span class=attr>propagation</span>=<span class=string>"REQUIRED"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>tx:attributes</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>tx:advice</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"txPointcut"</span> <span class=attr>expression</span>=<span class=string>"execution(* cn.shh.demo.spring.aop.transaction.*.*(..))"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>aop:advisor</span> <span class=attr>advice-ref</span>=<span class=string>"txAdvice"</span> <span class=attr>pointcut-ref</span>=<span class=string>"txPointcut"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br></pre></table></figure><p>只需以上xml配置，就可以实现事务控制。<h2 id=2-3、注解声明式事务><a class=headerlink href=#2-3、注解声明式事务 title=2.3、注解声明式事务></a>2.3、注解声明式事务</h2><h3 id=2-3-1、方式一><a class=headerlink href=#2-3-1、方式一 title=2.3.1、方式一></a>2.3.1、方式一</h3><p>xml配置文件：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"transactionManager"</span> <span class=attr>class</span>=<span class=string>"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"dataSource"</span> <span class=attr>ref</span>=<span class=string>"dataSource"</span>></span><span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>tx:annotation-driven</span> <span class=attr>transaction-manager</span>=<span class=string>"transactionManager"</span>/></span></span><br></pre></table></figure><p>xml配置完成后，在需要事务控制的业务方法上标注注解 <code>@Transactional</code>即可实现事务控制。<h3 id=2-3-2、方式二><a class=headerlink href=#2-3-2、方式二 title=2.3.2、方式二></a>2.3.2、方式二</h3><p>java配置类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=meta>@ComponentScan("cn.shh.demo.spring.aop.transaction")</span></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableTransactionManagement</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">TransactionConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> DataSource <span class="title function_">dataSource</span><span class=params>()</span>{</span><br><span class=line>        <span class=type>DruidDataSource</span> <span class=variable>dataSource</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class=line>        <span class=type>String</span> <span class=variable>fix</span> <span class=operator>=</span> <span class=string>"?characterEncoding=utf8&useSSL=false&serverTimezone=GMT%2B8"</span>;</span><br><span class=line>        dataSource.setUrl(<span class=string>"jdbc:mysql://localhost:3307/mybatis_plus"</span> + fix);</span><br><span class=line>        dataSource.setDriverClassName(<span class=string>"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class=line>        dataSource.setUsername(<span class=string>"root"</span>);</span><br><span class=line>        dataSource.setPassword(<span class=string>"root666"</span>);</span><br><span class=line>        <span class=keyword>return</span> dataSource;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class=params>(DataSource dataSource)</span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> DataSourceTransactionManager <span class="title function_">dataSourceTransactionManager</span><span class=params>(DataSource dataSource)</span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>然后在需要事务控制的业务方法上标注注解 <code>@Transactional</code>即可实现事务控制。<h1 id=原理解析><a class=headerlink href=#原理解析 title=原理解析></a>原理解析</h1><h2 id=1-1、入口-tx-advice><a title="1.1、入口 tx:advice" class=headerlink href=#1-1、入口-tx-advice></a>1.1、入口 tx:advice</h2><p><strong>（1）向容器中注入TransactionInterceptor</strong><p>通过标签解析器 TxAdviceBeanDefinitionParser 向容器中注入 TransactionInterceptor（名字为txAdvice）。<p><strong>（2）使用TransactionInterceptor拦截方法，开启、提交/回滚事务</strong><p>TransactionInterceptor 实现了AOP的 MethodInterceptor，并重写invoke方法，invoke就是环绕通知。环绕前开启事务，环绕后提交/回滚事务。</div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Spring%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Spring%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/ itemprop=url>Spring系列-基础应用</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-06 15:33:47" datetime=2023-08-06T15:33:47+08:00 itemprop=dateModified>2023-08-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Spring/ itemprop=url rel=index><span itemprop=name>Spring</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、认识Spring><a class=headerlink href=#1、认识Spring title=1、认识Spring></a>1、认识Spring</h1><h2 id=1-1、前言><a class=headerlink href=#1-1、前言 title=1.1、前言></a>1.1、前言</h2><p>Spring框架为任何类型的部署平台上的基于Java的现代企业应用程序提供了全面的编程和配置模型。<p>Spring的一个关键元素是在应用程序级别的基础架构支持：Spring专注于企业应用程序的“管道”，以便团队可以专注于应用程序级别的业务逻辑，而不必与特定的部署环境建立不必要的联系。<h2 id=1-2、啥是Spring><a class=headerlink href=#1-2、啥是Spring title=1.2、啥是Spring></a>1.2、啥是Spring</h2><p>术语“春天”在不同的上下文中表示不同的事物。它可以用来指代Spring Framework项目本身，而这一切都是从这里开始的。随着时间的流逝，其他Spring项目已经在Spring Framework的基础上构建。通常，当人们说“春天”时，它们表示整个项目系列。<p>Spring框架分为多个模块。应用程序可以选择所需的模块。核心容器的模块是核心，包括配置模型和依赖项注入机制。除此之外，Spring框架还为不同的应用程序体系结构提供了基础支持，包括消息传递，事务性数据和持久性以及Web。它还包括基于Servlet的Spring MVC Web框架，以及并行的Spring WebFlux反应式Web框架。<p>Spring使创建Java企业应用程序变得容易。它提供了在企业环境中使用Java语言所需的一切，并支持Groovy和Kotlin作为JVM上的替代语言，并且可以根据应用程序的需求灵活地创建多种体系结构。从Spring Framework 5.1开始，Spring需要JDK 8+（Java SE 8+），并提供对JDK 11 LTS的现成支持。建议将Java SE 8更新60作为Java 8的最低修补程序版本，但通常建议使用最新的修补程序版本。<p>Spring是开源的。它拥有一个庞大而活跃的社区，可以根据各种实际用例提供持续的反馈。<h2 id=1-3、Spring模块><a class=headerlink href=#1-3、Spring模块 title=1.3、Spring模块></a>1.3、Spring模块</h2><ul><li><a href=https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html rel=noopener target=_blank>核心技术</a>：依赖项注入，事件，资源，i18n，验证，数据绑定，类型转换，SpEL，AOP。<li><a href=https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/testing.html rel=noopener target=_blank>测试</a>：模拟对象，TestContext框架，Spring MVC测试，<code>WebTestClient</code>。<li><a href=https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/data-access.html rel=noopener target=_blank>数据访问</a>：事务，DAO支持，JDBC，ORM，封送XML。<li><a href=https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html rel=noopener target=_blank>Spring MVC</a>和 <a href=https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html rel=noopener target=_blank>Spring WebFlux</a> Web框架。<li><a href=https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/integration.html rel=noopener target=_blank>集成</a>：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。<li><a href=https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/languages.html rel=noopener target=_blank>语言</a>：Kotlin，Groovy，动态语言。</ul><h2 id=1-4、支持版本><a class=headerlink href=#1-4、支持版本 title=1.4、支持版本></a>1.4、支持版本</h2><ul><li>5.3.x是第5代产品的最后一个功能分支，也是最新的生产线（截至2020年10月，GA），并将提供长期支持（在JDK 8，JDK 11和即将在2007年发布的JDK 17 LTS版本） 2021年9月）。<li>5.2.x是之前的生产线（GA截至2019年9月），将得到积极支持，直到2021年年底。<li>5.1.x和5.0.x不再受到积极支持，到2020年12月已由5.2.x和5.3.x取代。<li>4.3.x是第四代的最后一个功能分支。<em>4.3.x将于2020年12月31日达到其正式停产（报废）。</em><li><em>截至2016年12月31日，3.2.x属于产品停产（寿命终止）。该产品线中没有计划进一步的维护和安全补丁。</em></ul><p>此时，我们建议从Maven Central升级到最新的Spring Framework 5.3.x版本。<h2 id=1-5、JDK版本范围><a class=headerlink href=#1-5、JDK版本范围 title=1.5、JDK版本范围></a>1.5、JDK版本范围</h2><ul><li>Spring Framework 5.3.x：JDK 8-17（预期）<li>Spring Framework 5.2.x：JDK 8-15<li>Spring Framework 5.1.x：JDK 8-12<li>Spring Framework 5.0.x：JDK 8-10<li>Spring Framework 4.3.x：JDK 6-8</ul><p>我们全面测试并支持JDK的Spring on Long-Term Support（LTS）发行版，即当前的JDK 8和11（两者的有效期至2023年），并期望JDK 17（将于2021年末发布）。此外，它还对中间版本（例如JDK 9/10/12/13/14/15）和即将发布的JDK 16尽最大努力提供了支持，这意味着我们接受错误报告，并将尝试从技术上解决它们。可能，但不会提供任何服务水平保证。<p><em>请升级到支持JDK 11+的Spring Framework 5.1+（和相应的Spring Boot 2.1+），作为从JDK 8开始的常见长期支持迁移路径。JDK11上没有正式支持较早的Spring版本，尤其是不支持JDK 11字节码级别。请注意，第三方组件可能尚未完全支持JDK 11，因此您可能会受到全栈选项的限制。</em><h2 id=1-6、Spring历史><a class=headerlink href=#1-6、Spring历史 title=1.6、Spring历史></a>1.6、Spring历史</h2><p>响应于早期<a href=https://en.wikipedia.org/wiki/Java_Platform,_Enterprise_Edition rel=noopener target=_blank>J2EE</a>规范的复杂性，Spring于2003年应运而生 。尽管有些人认为Java EE和Spring竞争，但Spring实际上是Java EE的补充。Spring编程模型不包含Java EE平台规范。相反，它与J2EE中的各个规范集成在一起：<ul><li>Servlet API（<a href=https://jcp.org/en/jsr/detail?id=340 rel=noopener target=_blank>JSR 340</a>）<li>WebSocket API（<a href=https://www.jcp.org/en/jsr/detail?id=356 rel=noopener target=_blank>JSR 356</a>）<li>并发实用程序（<a href=https://www.jcp.org/en/jsr/detail?id=236 rel=noopener target=_blank>JSR 236</a>）<li>JSON绑定API（<a href=https://jcp.org/en/jsr/detail?id=367 rel=noopener target=_blank>JSR 367</a>）<li>Bean验证（<a href=https://jcp.org/en/jsr/detail?id=303 rel=noopener target=_blank>JSR 303</a>）<li>JPA（<a href=https://jcp.org/en/jsr/detail?id=338 rel=noopener target=_blank>JSR 338</a>）<li>JMS（<a href=https://jcp.org/en/jsr/detail?id=914 rel=noopener target=_blank>JSR 914</a>）<li>以及必要时用于事务协调的JTA / JCA设置。</ul><p>Spring框架还支持依赖注入（<a href=https://www.jcp.org/en/jsr/detail?id=330 rel=noopener target=_blank>JSR 330</a>）和通用注释（<a href=https://jcp.org/en/jsr/detail?id=250 rel=noopener target=_blank>JSR 250</a>）规范，应用程序开发人员可以选择使用这些规范来代替Spring框架提供的特定于Spring的机制。<h1 id=2、核心技术><a class=headerlink href=#2、核心技术 title=2、核心技术></a>2、核心技术</h1><h2 id=2-1、IOC容器><a class=headerlink href=#2-1、IOC容器 title=2.1、IOC容器></a>2.1、IOC容器</h2><h3 id=2-1-1、IOC容器和Bean简介><a class=headerlink href=#2-1-1、IOC容器和Bean简介 title=2.1.1、IOC容器和Bean简介></a>2.1.1、IOC容器和Bean简介</h3><p>IoC也称为依赖注入（DI）。在此过程中，对象仅通过构造函数参数，工厂方法的参数或在构造或从工厂方法返回后在对象实例上设置的属性来定义其依赖项（即，与它们一起使用的其他对象） 。然后，容器在创建bean时注入那些依赖项。此过程从根本上讲是通过使用类的直接构造或诸如服务定位器模式之类的控件来控制其依赖项的实例化或bean本身位置的逆过程（因此称为Control的倒置）。<p><code>org.springframework.beans</code>和<code>org.springframework.context</code>包是Spring框架的IoC容器的基础。该 <a href=https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/beans/factory/BeanFactory.html rel=noopener target=_blank><code>BeanFactory</code></a> 界面提供了一种高级配置机制，能够管理任何类型的对象。 <a href=https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/context/ApplicationContext.html rel=noopener target=_blank><code>ApplicationContext</code></a> 是<code>BeanFactory</code>的子接口。它增加了：<ul><li>与Spring的AOP功能轻松集成<li>消息资源处理（用于国际化）<li>活动发布<li>应用层特定的上下文，例如用于Web应用程序中的<code>WebApplicationContext</code> 。</ul><p>在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。Bean是由Spring IoC容器实例化，组装和管理的对象。否则，bean仅仅是应用程序中许多对象之一。Bean及其之间的依赖关系反映在容器使用的配置元数据中。<h3 id=2-1-2、IOC容器概述><a class=headerlink href=#2-1-2、IOC容器概述 title=2.1.2、IOC容器概述></a>2.1.2、IOC容器概述</h3><p><code>org.springframework.context.ApplicationContext</code>接口代表Spring IoC容器，并负责实例化，配置和组装Bean。<p>Spring提供了<code>ApplicationContext</code>接口的几种实现。在独立应用程序中，通常创建<code>ClassPathXmlApplicationContext</code> 或 <code>FileSystemXmlApplicationContext</code>的实例。尽管XML是定义配置元数据的传统格式，但是您可以通过提供少量XML配置来声明性地启用对这些其他元数据格式的支持，从而指示容器将Java注释或代码用作元数据格式。<p>下图显示了Spring的工作原理。<p><img alt=image-20210107190234847 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210107190234847.png><h4 id=2-1-2-1、配置元数据><a class=headerlink href=#2-1-2-1、配置元数据 title=2.1.2.1、配置元数据></a>2.1.2.1、配置元数据</h4><p>传统上，配置元数据以简单直观的XML实现。 基于XML的元数据不是配置元数据的唯一允许形式。如今，大多数选择基于Java的配置实现。<p>常见的配置元数据方式如下：<ul><li><p>基于注释的配置</p> <p>Spring 2.5 引入了对基于注解的配置元数据的支持。主要体现为：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>       <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>       <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>                           https://www.springframework.org/schema/beans/spring-beans.xsd"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"..."</span> <span class=attr>class</span>=<span class=string>"..."</span>></span>  </span><br><span class=line>        <span class=comment>&LT!-- collaborators and configuration for this bean go here --></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"..."</span> <span class=attr>class</span>=<span class=string>"..."</span>></span></span><br><span class=line>        <span class=comment>&LT!-- collaborators and configuration for this bean go here --></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- more bean definitions go here --></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure><li><p>基于Java的配置</p> <p>从Spring 3.0开始，其底层实现是基于Spring JavaConfig项目提供的许多功能成为Spring核心的一部分。因此，您可以使用 Java 而不是 XML 文件来定义应用程序类外部的 bean。要使用这些新功能，请参见<a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html rel=noopener target=_blank>@Configuration</a>，<a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html rel=noopener target=_blank>@Bean</a>，<a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html rel=noopener target=_blank>@Import</a>和<a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html rel=noopener target=_blank>@DependsOn</a>注解。</p></ul><h4 id=2-1-2-2、实例化容器><a class=headerlink href=#2-1-2-2、实例化容器 title=2.1.2.2、实例化容器></a>2.1.2.2、实例化容器</h4><p>提供给<code>ApplicationContext</code>构造函数的位置路径是资源字符串，这些资源字符串使容器可以从各种外部资源(例如本地文件系统，Java <code>CLASSPATH</code>等)加载配置元数据。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>ApplicationContext</span> <span class=variable>context</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class=string>"services.xml"</span>, <span class=string>"daos.xml"</span>);</span><br></pre></table></figure><p>services.xml 文件内容如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- services --></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"petStore"</span> <span class=attr>class</span>=<span class=string>"org.springframework.samples.jpetstore.services.PetStoreServiceImpl"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"accountDao"</span> <span class=attr>ref</span>=<span class=string>"accountDao"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"itemDao"</span> <span class=attr>ref</span>=<span class=string>"itemDao"</span>/></span></span><br><span class=line>        <span class=comment>&LT!-- additional collaborators and configuration for this bean go here --></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- more bean definitions for services go here --></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure><p>daos.xml 文件内容如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"accountDao"</span></span></span><br><span class=line><span class=tag>        <span class=attr>class</span>=<span class=string>"org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"</span>></span></span><br><span class=line>        <span class=comment>&LT!-- additional collaborators and configuration for this bean go here --></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"itemDao"</span> <span class=attr>class</span>=<span class=string>"org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"</span>></span></span><br><span class=line>        <span class=comment>&LT!-- additional collaborators and configuration for this bean go here --></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- more bean definitions for data access objects go here --></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure><h5 id=构成基于XML配置元数据><a class=headerlink href=#构成基于XML配置元数据 title=构成基于XML配置元数据></a>构成基于XML配置元数据</h5><p>使bean定义跨越多个XML文件可能很有用。通常，每个单独的XML配置文件都代表体系结构中的逻辑层或模块。<p>您可以使用应用程序上下文构造函数从所有这些 XML 片段中加载 bean 定义。该构造函数具有多个<code>Resource</code>位置，如<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-instantiation rel=noopener target=_blank>previous section</a>所示。或者，使用一个或多个<code>&LTimport/></code>元素从另一个文件中加载 bean 定义。以下示例显示了如何执行此操作：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>import</span> <span class=attr>resource</span>=<span class=string>"services.xml"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>import</span> <span class=attr>resource</span>=<span class=string>"resources/messageSource.xml"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>import</span> <span class=attr>resource</span>=<span class=string>"/resources/themeSource.xml"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"bean1"</span> <span class=attr>class</span>=<span class=string>"..."</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"bean2"</span> <span class=attr>class</span>=<span class=string>"..."</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure><p>在前面的示例中，从三个文件<code>services.xml</code>，<code>messageSource.xml</code>和<code>themeSource.xml</code>加载了外部 bean 定义。所有位置路径都相对于进行导入的定义文件，因此<code>services.xml</code>必须与进行导入的文件位于同一目录或 Classpath 位置，而<code>messageSource.xml</code>和<code>themeSource.xml</code>必须位于导入文件位置下方的<code>resources</code>位置。如您所见，斜杠被忽略。但是，鉴于这些路径是相对的，最好不要使用任何斜线。根据 Spring Schema，导入的文件的内容(包括顶级<code>&LTbeans/></code>元素)必须是有效的 XML bean 定义。<blockquote><p>可以但不建议使用相对的“ ../”路径引用父目录中的文件。这样做会创建对当前应用程序外部文件的依赖。特别是，不建议对<code>classpath:</code>URL（例如<code>classpath:../services.xml</code>）使用此引用，在URL中，运行时解析过程会选择“最近的”类路径根，然后查看其父目录。类路径配置的更改可能导致选择其他错误的目录。</blockquote><h5 id=Groovy-Bean-定义-DSL><a title="Groovy Bean 定义 DSL" class=headerlink href=#Groovy-Bean-定义-DSL></a>Groovy Bean 定义 DSL</h5><p>作为外部化配置元数据的另一个示例，Bean 定义也可以在 Spring 的 Groovy Bean 定义 DSL 中表达，如 Grails 框架所知。通常，这种配置位于“ .groovy”文件中，其结构如以下示例所示：<figure class="highlight groovy"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line>beans {</span><br><span class=line>    dataSource(BasicDataSource) {</span><br><span class=line>        driverClassName = <span class=string>"org.hsqldb.jdbcDriver"</span></span><br><span class=line>        url = <span class=string>"jdbc:hsqldb:mem:grailsDB"</span></span><br><span class=line>        username = <span class=string>"sa"</span></span><br><span class=line>        password = <span class=string>""</span></span><br><span class=line>        settings = [<span class=attr>mynew:</span><span class=string>"setting"</span>]</span><br><span class=line>    }</span><br><span class=line>    sessionFactory(SessionFactory) {</span><br><span class=line>        dataSource = dataSource</span><br><span class=line>    }</span><br><span class=line>    myService(MyService) {</span><br><span class=line>        nestedBean = { AnotherBean bean -></span><br><span class=line>            dataSource = dataSource</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>这种配置样式在很大程度上等同于XML bean定义，甚至支持Spring的XML配置名称空间。它还允许通过<code>importBeans</code>指令导入XML bean定义文件。<h4 id=2-1-2-3、使用容器><a class=headerlink href=#2-1-2-3、使用容器 title=2.1.2.3、使用容器></a>2.1.2.3、使用容器</h4><ul><li><p>基于 XML 使用容器</p> <p><code>ApplicationContext</code>是高级工厂的界面，该工厂能够维护不同 bean 及其依赖关系的注册表。通过使用方法<code>T getBean(String name, Class&LTT> requiredType)</code>，您可以检索 bean 的实例。</p> <p><code>ApplicationContext</code>允许您读取 bean 定义并访问它们，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// create and configure beans</span></span><br><span class=line><span class=type>ApplicationContext</span> <span class=variable>context</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class=string>"services.xml"</span>, <span class=string>"daos.xml"</span>);</span><br><span class=line><span class=comment>// retrieve configured instance</span></span><br><span class=line><span class=type>PetStoreService</span> <span class=variable>service</span> <span class=operator>=</span> context.getBean(<span class=string>"petStore"</span>, PetStoreService.class);</span><br><span class=line><span class=comment>// use configured instance</span></span><br><span class=line>List&LTString> userList = service.getUsernameList();</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>GenericApplicationContext</span> <span class=variable>context</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class=line><span class=keyword>new</span> <span class="title class_">XmlBeanDefinitionReader</span>(context).loadBeanDefinitions(<span class=string>"services.xml"</span>, <span class=string>"daos.xml"</span>);</span><br><span class=line>context.refresh();</span><br></pre></table></figure><li><p>基于 Groovy 使用容器</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>ApplicationContext</span> <span class=variable>context</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">GenericGroovyApplicationContext</span>(<span class=string>"services.groovy"</span>, <span class=string>"daos.groovy"</span>);</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>GenericApplicationContext</span> <span class=variable>context</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class=line><span class=keyword>new</span> <span class="title class_">GroovyBeanDefinitionReader</span>(context).loadBeanDefinitions(<span class=string>"services.groovy"</span>, <span class=string>"daos.groovy"</span>);</span><br><span class=line>context.refresh();</span><br></pre></table></figure></ul><h3 id=2-1-3、Bean总览><a class=headerlink href=#2-1-3、Bean总览 title=2.1.3、Bean总览></a>2.1.3、Bean总览</h3><p>Spring IoC容器管理一个或多个bean。在容器本身内，这些bean定义表示为<code>BeanDefinition</code> 对象，这些对象包含（除其他信息外）以下元数据：<ul><li>包限定的类名称：通常，定义了Bean的实际实现类。<li>Bean行为配置元素，用于声明Bean在容器中的行为（作用域，生命周期回调等）。<li>引用该bean完成其工作所需的其他bean。这些引用也称为协作者或依赖项。<li>要在新创建的对象中设置的其他配置设置-例如，池的大小限制或要在管理连接池的bean中使用的连接数。</ul><p>该元数据转换为构成每个bean定义的一组属性。下表描述了这些属性：<p><em>表 1. bean 定义</em><table><thead><tr><th>Property<th>Explained in…<tbody><tr><td>Class<td><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-class rel=noopener target=_blank>Instantiating Beans</a><tr><td>Name<td><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-beanname rel=noopener target=_blank>Naming Beans</a><tr><td>Scope<td><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes rel=noopener target=_blank>Bean Scopes</a><tr><td>Constructor arguments<td><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-collaborators rel=noopener target=_blank>Dependency Injection</a><tr><td>Properties<td><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-collaborators rel=noopener target=_blank>Dependency Injection</a><tr><td>Autowiring mode<td><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-autowire rel=noopener target=_blank>Autowiring Collaborators</a><tr><td>延迟初始化模式<td><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lazy-init rel=noopener target=_blank>Lazy-initialized Beans</a><tr><td>Initialization method<td><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean rel=noopener target=_blank>Initialization Callbacks</a><tr><td>Destruction method<td><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-disposablebean rel=noopener target=_blank>Destruction Callbacks</a></table><p>除了包含有关如何创建特定 bean 的信息的 bean 定义之外，<code>ApplicationContext</code>实现还允许注册在容器外部(由用户)创建的现有对象。这是通过<code>getBeanFactory()</code>方法访问 ApplicationContext 的 BeanFactory 来完成的，该方法返回 BeanFactory <code>DefaultListableBeanFactory</code>的实现。 <code>DefaultListableBeanFactory</code>通过<code>registerSingleton(..)</code>和<code>registerBeanDefinition(..)</code>方法支持此注册。但是，典型的应用程序只能与通过常规 bean 定义元数据定义的 bean 一起使用。<h4 id=2-1-3-1、命名Bean><a class=headerlink href=#2-1-3-1、命名Bean title=2.1.3.1、命名Bean></a>2.1.3.1、命名Bean</h4><h5 id=简介><a class=headerlink href=#简介 title=简介></a>简介</h5><p>每个 Bean 具有一个或多个标识符，这些标识符必须唯一。一个 bean 通常只有一个标识符。但是，如果需要多个，则可以将多余的别名视为别名。<p>在 XML 文件中，可以使用 id 和 name 属性指定标识符。id 属性代表bena的唯一性，通常 id 属性的名字构成可以是字母、数字，也可以使用特殊字符。如果要为 bean 设置别名，可以在 name 属性中设定，并用逗号、分号或空格隔开。<p>Spring 3.1 之前，id 属性被定义为一种 xsd:ID 类型，该类型限制了可能的字符。从 3.1 开始，它被定义为 xsd:string 类型。bena 的 id 属性仍然由容器强制执行。<p>如果不显式设定 id 和 name 属性，则容器会为该 bean 生成一个唯一的名称。但是，如果通过该名称获取该 bean，则必须通过使用 ref 元素或服务定位器样式来提供名称。<blockquote><p>Bean 命名约定：约定是在命名bean时将标准Java约定用于实例字段名称。也就是说，bean名称以小写字母开头，并从那里用驼峰式大小写。</blockquote><h5 id=基于XML起别名><a class=headerlink href=#基于XML起别名 title=基于XML起别名></a>基于XML起别名</h5><p>基于XML起别名的方式如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>alias</span> <span class=attr>name</span>=<span class=string>"myApp-dataSource"</span> <span class=attr>alias</span>=<span class=string>"subsystemA-dataSource"</span>/></span></span><br><span class=line><span class=tag><<span class=name>alias</span> <span class=attr>name</span>=<span class=string>"myApp-dataSource"</span> <span class=attr>alias</span>=<span class=string>"subsystemB-dataSource"</span>/></span></span><br></pre></table></figure><h5 id=基于注解起别名><a class=headerlink href=#基于注解起别名 title=基于注解起别名></a>基于注解起别名</h5><p>如果使用Java配置，则<code>@Bean</code>注释可用于提供别名。<h4 id=2-1-3-2、实例化-Bean><a title="2.1.3.2、实例化 Bean" class=headerlink href=#2-1-3-2、实例化-Bean></a>2.1.3.2、实例化 Bean</h4><h5 id=简介-1><a class=headerlink href=#简介-1 title=简介></a>简介</h5><p>Bean 定义实质上是创建一个或多个对象的方法。当被询问时，容器将查看命名 bean 的配方，并使用该 bean 定义封装的配置元数据来创建(或获取)实际对象。<p>如果使用基于 XML 的配置元数据，则可以在<code>&LTbean/></code>元素的<code>class</code>属性中指定要实例化的对象的类型(或类)。通常，此<code>class</code>属性(在内部是<code>BeanDefinition</code>实例上的<code>Class</code>属性)。可以通过以下两种方式之一使用<code>Class</code>属性：<ol><li>通常，在容器本身通过反射性地调用其构造函数直接创建 Bean 的情况下，指定要构造的 Bean 类，这在某种程度上等效于<code>new</code>运算符的 Java 代码。<li>要指定包含被调用以创建对象的<code>static</code>工厂方法的实际类，在不太常见的情况下，容器将在类上调用<code>static</code>工厂方法以创建 Bean。从<code>static</code>工厂方法的调用返回的对象类型可以是同一类，也可以是完全不同的另一类。</ol><blockquote><p>定义内部类：如果要为 静态内部类 配置Bean定义，则必须使用嵌套类的二进制名称。定义静态内部类方式如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>< bean id="" name="" class="com.example.SomeThing$OtherThing" /></span><br></pre></table></figure><p>请注意，名称中使用了<code>$</code>字符以将嵌套的类名与外部类名分开。</blockquote><h5 id=基于构造函数实例化><a class=headerlink href=#基于构造函数实例化 title=基于构造函数实例化></a>基于构造函数实例化</h5><p>当通过构造方法创建一个bean时，所有普通类都可以被Spring使用并兼容。也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式进行编码。只需指定bean类就足够了。但是，根据您用于该特定bean的IoC的类型，您可能需要一个默认（空）构造函数。<p>Spring IoC 容器几乎可以 Management 您要 Management 的任何类。它不仅限于 Managementtrue 的 JavaBean。大多数 Spring 用户更喜欢实际的 JavaBean，它仅具有默认(无参数)构造函数，并具有根据容器中的属性建模的适当的 setter 和 getter。您还可以在容器中具有更多奇特的非 bean 样式类。<p>使用基于 XML 的配置元数据，您可以如下指定 bean 类：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"examples.ExampleBean"</span>/></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>name</span>=<span class=string>"anotherExample"</span> <span class=attr>class</span>=<span class=string>"examples.ExampleBeanTwo"</span>/></span></span><br></pre></table></figure><p>有关向构造函数提供参数(如果需要)并在构造对象之后设置对象实例属性的机制的详细信息，请参见<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-collaborators rel=noopener target=_blank>Injecting Dependencies</a>。<h5 id=基于静态工厂方法实例化><a class=headerlink href=#基于静态工厂方法实例化 title=基于静态工厂方法实例化></a>基于静态工厂方法实例化</h5><p>定义使用静态工厂方法创建的 bean 时，请使用<code>class</code>属性来指定包含<code>static</code>工厂方法的类，并使用名为<code>factory-method</code>的属性来指定工厂方法本身的名称。您应该能够调用此方法(带有可选参数，如稍后所述)并返回一个活动对象，该对象随后将被视为已通过构造函数创建。这种 bean 定义的一种用法是在旧代码中调用<code>static</code>工厂。<p>以下bean定义指定通过调用工厂方法来创建bean。该定义不指定返回对象的类型（类），而仅指定包含工厂方法的类。在此示例中，该<code>createInstance()</code> 方法必须是静态方法。以下示例显示如何指定工厂方法：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"clientService"</span> <span class=attr>class</span>=<span class=string>"examples.ClientService"</span> <span class=attr>factory-method</span>=<span class=string>"createInstance"</span>/></span></span><br></pre></table></figure><p>以下示例显示了可与前面的bean定义一起使用的类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ClientService</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>ClientService</span> <span class=variable>clientService</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClientService</span>();</span><br><span class=line>    <span class=keyword>private</span> <span class="title function_">ClientService</span><span class=params>()</span> {}</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> ClientService <span class="title function_">createInstance</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> clientService;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h5 id=基于实例工厂方法实例化><a class=headerlink href=#基于实例工厂方法实例化 title=基于实例工厂方法实例化></a>基于实例工厂方法实例化</h5><p>似于通过静态工厂方法进行实例化，使用实例工厂方法进行实例化会从容器中调用现有bean的非静态方法来创建新bean。要使用此机制，请将<code>class</code>属性留空，并在<code>factory-bean</code>属性中，在当前(或父容器或祖先容器)中指定包含要创建该对象的实例方法的 bean 的名称。使用<code>factory-method</code>属性设置工厂方法本身的名称。以下示例显示了如何配置此类 Bean：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"serviceLocator"</span> <span class=attr>class</span>=<span class=string>"examples.DefaultServiceLocator"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- inject any dependencies required by this locator bean --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"clientService"</span></span></span><br><span class=line><span class=tag>    <span class=attr>factory-bean</span>=<span class=string>"serviceLocator"</span></span></span><br><span class=line><span class=tag>    <span class=attr>factory-method</span>=<span class=string>"createClientServiceInstance"</span>/></span></span><br></pre></table></figure><p>相关的类如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DefaultServiceLocator</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>ClientService</span> <span class=variable>clientService</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class=line>    <span class=keyword>public</span> ClientService <span class="title function_">createClientServiceInstance</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> clientService;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>一个工厂类也可以包含一个以上的工厂方法，如以下示例所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"serviceLocator"</span> <span class=attr>class</span>=<span class=string>"examples.DefaultServiceLocator"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- inject any dependencies required by this locator bean --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"clientService"</span> <span class=attr>factory-bean</span>=<span class=string>"serviceLocator"</span> <span class=attr>factory-method</span>=<span class=string>"createClientServiceInstance"</span>/></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"accountService"</span> <span class=attr>factory-bean</span>=<span class=string>"serviceLocator"</span> <span class=attr>factory-method</span>=<span class=string>"createAccountServiceInstance"</span>/></span></span><br></pre></table></figure><p>相关类如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DefaultServiceLocator</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>ClientService</span> <span class=variable>clientService</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>AccountService</span> <span class=variable>accountService</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AccountServiceImpl</span>();</span><br><span class=line>    <span class=keyword>public</span> ClientService <span class="title function_">createClientServiceInstance</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> clientService;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> AccountService <span class="title function_">createAccountServiceInstance</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> accountService;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>这种方法表明，工厂Bean本身可以通过依赖项注入（DI）进行管理和配置。<h5 id=确定Bean的运行时类型><a class=headerlink href=#确定Bean的运行时类型 title=确定Bean的运行时类型></a>确定Bean的运行时类型</h5><p>找出特定bean的实际运行时类型的推荐方法是<code>BeanFactory.getType</code>调用指定的bean名称。并返回了<code>BeanFactory.getBean</code>针对相同bean名称的调用将要返回的对象的类型。<h3 id=2-1-4、Dependencies><a class=headerlink href=#2-1-4、Dependencies title=2.1.4、Dependencies></a>2.1.4、Dependencies</h3><h4 id=2-1-4-1、依赖注入><a class=headerlink href=#2-1-4-1、依赖注入 title=2.1.4.1、依赖注入></a>2.1.4.1、依赖注入</h4><p>依赖注入(DI)是一个过程，通过该过程，对象只能通过构造函数参数，工厂方法的参数或在构造或创建对象实例后在对象实例上设置的属性来定义其依赖关系(即，与它们一起工作的其他对象)。从工厂方法返回。然后，容器在创建 bean 时注入那些依赖项。从根本上讲，此过程是通过使用类的直接构造或服务定位器模式来自己控制其依赖关系的实例化或位置的 Bean 本身的逆过程(因此称为 Control Inversion)。<p>DI存在两个主要变体：基于构造函数的依赖注入和基于Setter的依赖注入。<h5 id=基于构造函数的依赖注入><a class=headerlink href=#基于构造函数的依赖注入 title=基于构造函数的依赖注入></a>基于构造函数的依赖注入</h5><p>基于构造函数的 DI 是通过容器调用具有多个参数(每个参数代表一个依赖项)的构造函数来完成的。调用带有特定参数的<code>static</code>工厂方法来构造 Bean 几乎是等效的。<p>以下示例显示了只能通过构造函数注入进行依赖项注入的类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">SimpleMovieLister</span><span class=params>(MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>注意，该类没有什么特别的。它是一个 POJO，不依赖于特定于容器的接口，Base Class 或 注解。<h6 id=构造函数参数解析><a class=headerlink href=#构造函数参数解析 title=构造函数参数解析></a>构造函数参数解析</h6><p>构造函数参数解析匹配通过使用参数的类型进行。如果Bean定义的构造函数参数中不存在潜在的歧义，则在实例化Bean时，在Bean定义中定义构造函数参数的顺序就是将这些参数提供给适当的构造函数的顺序。考虑以下情况：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> x.y;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ThingOne</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ThingOne</span><span class=params>(ThingTwo thingTwo, ThingThree thingThree)</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>假设<code>ThingTwo</code>和<code>ThingThree</code>类不是通过继承关联的，则不存在潜在的歧义。因此，以下配置可以正常工作，并且您无需在<code>&LTconstructor-arg/></code> 元素中显式指定构造函数参数索引或类型。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"beanOne"</span> <span class=attr>class</span>=<span class=string>"x.y.ThingOne"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>constructor-arg</span> <span class=attr>ref</span>=<span class=string>"beanTwo"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>constructor-arg</span> <span class=attr>ref</span>=<span class=string>"beanThree"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"beanTwo"</span> <span class=attr>class</span>=<span class=string>"x.y.ThingTwo"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"beanThree"</span> <span class=attr>class</span>=<span class=string>"x.y.ThingThree"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure><p>当引用另一个bean时，类型是已知的，并且可以发生匹配（与前面的示例一样）。当使用简单类型(例如<code>&LTvalue>true&LT/value></code>)时，Spring 无法确定值的类型，因此在没有帮助的情况下无法按类型进行匹配。考虑以下类别：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> examples;</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleBean</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> years;</span><br><span class=line>    <span class=keyword>private</span> String ultimateAnswer;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ExampleBean</span><span class=params>(<span class=type>int</span> years, String ultimateAnswer)</span> {</span><br><span class=line>        <span class=built_in>this</span>.years = years;</span><br><span class=line>        <span class=built_in>this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><ul><li><p>构造函数参数类型匹配</p> <p>在上述情况下，如果通过使用<code>type</code>属性显式指定构造函数参数的类型，则容器可以使用简单类型的类型匹配。如下例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"examples.ExampleBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>type</span>=<span class=string>"int"</span> <span class=attr>value</span>=<span class=string>"7500000"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>type</span>=<span class=string>"java.lang.String"</span> <span class=attr>value</span>=<span class=string>"42"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure><li><p>构造函数参数索引</p> <p>您可以使用该<code>index</code>属性来明确指定构造函数参数的索引，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"examples.ExampleBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>index</span>=<span class=string>"0"</span> <span class=attr>value</span>=<span class=string>"7500000"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>index</span>=<span class=string>"1"</span> <span class=attr>value</span>=<span class=string>"42"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>除了解决多个简单值的歧义性之外，指定索引还可以解决歧义，其中构造函数具有两个相同类型的参数。</p><li><p>构造函数参数名称</p> <p>您还可以使用构造函数参数名称来消除歧义，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"examples.ExampleBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>name</span>=<span class=string>"years"</span> <span class=attr>value</span>=<span class=string>"7500000"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>name</span>=<span class=string>"ultimateAnswer"</span> <span class=attr>value</span>=<span class=string>"42"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>请记住，要立即使用该功能，必须在启用调试标志的情况下编译代码，以便 Spring 可以从构造函数中查找参数名称。如果您不能或不想使用 debug 标志编译代码，则可以使用<a href=https://download.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html rel=noopener target=_blank>@ConstructorProperties</a> JDK注解 显式命名构造函数参数。然后，该示例类必须如下所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> examples;</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleBean</span> {</span><br><span class=line>    <span class=meta>@ConstructorProperties({"years", "ultimateAnswer"})</span></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ExampleBean</span><span class=params>(<span class=type>int</span> years, String ultimateAnswer)</span> {</span><br><span class=line>        <span class=built_in>this</span>.years = years;</span><br><span class=line>        <span class=built_in>this</span>.ultimateAnswer = ultimateAnswer;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure></ul><h5 id=基于Setter的依赖注入><a class=headerlink href=#基于Setter的依赖注入 title=基于Setter的依赖注入></a>基于Setter的依赖注入</h5><p>基于Setter的DI是通过在调用无参数构造函数或无参数<code>static</code>工厂方法以实例化您的bean之后，在您的bean上调用setter方法来完成的。<p>下面的示例显示只能通过Setter来注入的一种情况。此类是常规的 Java。它是一个 POJO，不依赖于容器特定的接口，Base Class 或 注解。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>//...</span></span><br><span class=line>}</span><br></pre></table></figure><p><code>ApplicationContext</code>支持其 Management 的 bean 的基于构造函数和基于 setter 的 DI。在已经通过构造函数方法注入了某些依赖项之后，它还支持基于 setter 的 DI。您可以以<code>BeanDefinition</code>的形式配置依赖项，并与<code>PropertyEditor</code>实例结合使用以将属性从一种格式转换为另一种格式。但是，大多数 Spring 用户不是直接(即以编程方式)使用这些类，而是使用 XML <code>bean</code>定义，带注解的组件(即以<code>@Component</code>，<code>@Controller</code>等进行注解的类)或基于 Java 的<code>@Bean</code>方法。 <code>@Configuration</code>个类。然后将这些源在内部转换为<code>BeanDefinition</code>的实例，并用于加载整个 Spring IoC 容器实例。<blockquote><p>两种注入方式该如何选择呢？<p>由于可以混合使用基于构造函数的DI和基于设定值的DI，因此将构造函数用于强制性依赖项并将setter方法或配置方法用于可选的依赖项是一个很好的经验法则。注意， 在setter方法上使用<code>@Required</code>批注可以使该属性成为必需的依赖项。但是，最好使用带有参数的程序验证的构造函数注入。<p>Spring团队通常提倡使用构造函数注入，因为它可以让您将应用程序组件实现为不可变对象，并确保不存在必需的依赖项<code>null</code>。此外，注入构造函数的组件始终以完全初始化的状态返回到客户端（调用）代码。附带说明一下，大量的构造函数自变量是一种不好的代码味，这表明该类可能承担了太多的职责，应该对其进行重构以更好地解决关注点分离问题。<p>Setter注入主要应仅用于可以在类中分配合理的默认值的可选依赖项。否则，必须在代码使用依赖项的任何地方执行非空检查。setter注入的一个好处是，setter方法使该类的对象在以后可以重新配置或重新注入。因此，通过<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#jmx rel=noopener target=_blank>JMX MBean进行</a>管理是用于setter注入的引人注目的用例。</blockquote><h5 id=依赖性解析过程><a class=headerlink href=#依赖性解析过程 title=依赖性解析过程></a>依赖性解析过程</h5><p>容器执行bean依赖项解析，如下所示：<ul><li><code>ApplicationContext</code>使用描述所有bean的配置元数据创建和初始化。可以通过XML，Java代码或注释指定配置元数据。<li>对于每个bean，其依赖关系都以属性，构造函数参数或static-factory方法的参数的形式表示（如果使用它而不是普通的构造函数）。实际创建Bean时，会将这些依赖项提供给Bean。<li>每个属性或构造函数参数都是要设置的值的实际定义，或者是对容器中另一个bean的引用。<li>作为值的每个属性或构造函数参数都将从其指定的格式转换为该属性或构造函数参数的实际类型。默认情况下，Spring能够以String类型提供值转换成所有内置类型，比如<code>int</code>， <code>long</code>，<code>String</code>，<code>boolean</code>，等等。</ul><p>在创建容器时，Spring容器会验证每个bean的配置。但是，在实际创建Bean之前，不会设置Bean属性本身。创建容器时，将创建具有单例作用域并设置为预先实例化（默认）的Bean。范围在<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes rel=noopener target=_blank>Bean范围</a>中定义。否则，仅在请求时才创建Bean。创建和分配bean的依赖关系及其依赖关系（依此类推）时，创建bean可能会导致创建一个bean图。请注意，这些依赖项之间的分辨率不匹配可能会显示得较晚-即在第一次创建受影响的bean时。<blockquote><p>循环依赖问题<p>如果主要使用构造函数注入，则可能会创建无法解决的循环依赖方案。<p>例如：A类通过构造函数注入需要B类的实例，而B类通过构造函数注入需要A类的实例。如果您将A类和B类的bean配置为相互注入，则Spring IoC容器会在运行时检测到此循环引用，并抛出 <code>BeanCurrentlyInCreationException</code>。<p>一种可能的解决方案是编辑某些类的源代码，这些类的源代码由设置者而不是构造函数来配置。或者，避免构造函数注入，而仅使用setter注入。换句话说，尽管不建议这样做，但是您可以使用setter注入配置循环依赖项。<p>典型情况（没有循环依赖关系）不同，Bean A和Bean B之间的循环依赖关系迫使其中一个Bean在完全完全初始化之前被注入另一个Bean（经典的“鸡与蛋”场景）。</blockquote><p>如果不存在循环依赖关系，则在将一个或多个协作Bean注入到从属Bean中时，每个协作Bean都将被完全配置，然后再注入到从属Bean中。这意味着，如果bean A依赖于bean B，则Spring IoC容器会在对bean A调用setter方法之前完全配置beanB。换句话说，bean被实例化（如果不是预先实例化的singleton）。 ），设置其依赖项，并调用相关的生命周期方法（例如已[配置的 init 方法或 InitializingBean 回调方法）。<h5 id=依赖注入示例><a class=headerlink href=#依赖注入示例 title=依赖注入示例></a>依赖注入示例</h5><h6 id=基于XML的Setter注入><a class=headerlink href=#基于XML的Setter注入 title=基于XML的Setter注入></a>基于XML的Setter注入</h6><p>以下示例基于XML来实现 Setter注入。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"examples.ExampleBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"beanOne"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>ref</span> <span class=attr>bean</span>=<span class=string>"anotherExampleBean"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"beanTwo"</span> <span class=attr>ref</span>=<span class=string>"yetAnotherBean"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"integerProperty"</span> <span class=attr>value</span>=<span class=string>"1"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"anotherExampleBean"</span> <span class=attr>class</span>=<span class=string>"examples.AnotherBean"</span>/></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"yetAnotherBean"</span> <span class=attr>class</span>=<span class=string>"examples.YetAnotherBean"</span>/></span></span><br></pre></table></figure><p>类ExampleBean如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleBean</span> {</span><br><span class=line>    <span class=keyword>private</span> AnotherBean beanOne;</span><br><span class=line>    <span class=keyword>private</span> YetAnotherBean beanTwo;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> i;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setBeanOne</span><span class=params>(AnotherBean beanOne)</span> {</span><br><span class=line>        <span class=built_in>this</span>.beanOne = beanOne;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setBeanTwo</span><span class=params>(YetAnotherBean beanTwo)</span> {</span><br><span class=line>        <span class=built_in>this</span>.beanTwo = beanTwo;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setIntegerProperty</span><span class=params>(<span class=type>int</span> i)</span> {</span><br><span class=line>        <span class=built_in>this</span>.i = i;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h6 id=基于XML的构造注入><a class=headerlink href=#基于XML的构造注入 title=基于XML的构造注入></a>基于XML的构造注入</h6><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"examples.ExampleBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span>></span></span><br><span class=line>        <span class=tag><<span class=name>ref</span> <span class=attr>bean</span>=<span class=string>"anotherExampleBean"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>constructor-arg</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>ref</span>=<span class=string>"yetAnotherBean"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>type</span>=<span class=string>"int"</span> <span class=attr>value</span>=<span class=string>"1"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"anotherExampleBean"</span> <span class=attr>class</span>=<span class=string>"examples.AnotherBean"</span>/></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"yetAnotherBean"</span> <span class=attr>class</span>=<span class=string>"examples.YetAnotherBean"</span>/></span></span><br></pre></table></figure><p>类 ExampleBean 如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleBean</span> {</span><br><span class=line>    <span class=keyword>private</span> AnotherBean beanOne;</span><br><span class=line>    <span class=keyword>private</span> YetAnotherBean beanTwo;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> i;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ExampleBean</span><span class=params>(</span></span><br><span class=line><span class=params>        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class=type>int</span> i)</span> {</span><br><span class=line>        <span class=built_in>this</span>.beanOne = anotherBean;</span><br><span class=line>        <span class=built_in>this</span>.beanTwo = yetAnotherBean;</span><br><span class=line>        <span class=built_in>this</span>.i = i;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>现在考虑该示例的一个变体，在该变体中，不是使用构造函数，而是告诉Spring调用<code>static</code>工厂方法以返回对象的实例：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleBean"</span> <span class=attr>class</span>=<span class=string>"examples.ExampleBean"</span> <span class=attr>factory-method</span>=<span class=string>"createInstance"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>ref</span>=<span class=string>"anotherExampleBean"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>ref</span>=<span class=string>"yetAnotherBean"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>value</span>=<span class=string>"1"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"anotherExampleBean"</span> <span class=attr>class</span>=<span class=string>"examples.AnotherBean"</span>/></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"yetAnotherBean"</span> <span class=attr>class</span>=<span class=string>"examples.YetAnotherBean"</span>/></span></span><br></pre></table></figure><p>以下示例显示了相应的<code>ExampleBean</code>类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleBean</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class="title function_">ExampleBean</span><span class=params>(...)</span> {</span><br><span class=line>        <span class=comment>//...</span></span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> ExampleBean <span class="title function_">createInstance</span> <span class=params>(</span></span><br><span class=line><span class=params>        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class=type>int</span> i)</span> {</span><br><span class=line>        <span class=type>ExampleBean</span> <span class=variable>eb</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ExampleBean</span> (...);</span><br><span class=line>        <span class=comment>//...</span></span><br><span class=line>        <span class=keyword>return</span> eb;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><code>static</code>工厂方法的参数由<code>&LTconstructor-arg/></code>元素提供，与实际使用构造函数的情况完全相同。 factory 方法返回的类的类型不必与包含<code>static</code> factory 方法的类的类型相同(尽管在此示例中为)。实例(非静态)工厂方法可以以基本上相同的方式使用(除了使用<code>factory-bean</code>属性而不是<code>class</code>属性)，因此在此不讨论这些细节。<h4 id=2-1-4-2、依赖性和详细配置><a class=headerlink href=#2-1-4-2、依赖性和详细配置 title=2.1.4.2、依赖性和详细配置></a>2.1.4.2、依赖性和详细配置</h4><h5 id=straight-values（原语、字符串等）><a title="straight values（原语、字符串等）" class=headerlink href=#straight-values（原语、字符串等）></a>straight values（原语、字符串等）</h5><p><code>&LTproperty/></code>元素的<code>value</code>属性将属性或构造函数参数指定为人类可读的字符串表示形式。 Spring 的<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#core-convert-ConversionService-API rel=noopener target=_blank>conversion service</a>用于将这些值从<code>String</code>转换为属性或参数的实际类型。以下示例显示了设置的各种值：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"myDataSource"</span> <span class=attr>class</span>=<span class=string>"org.apache.commons.dbcp.BasicDataSource"</span> <span class=attr>destroy-method</span>=<span class=string>"close"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"driverClassName"</span> <span class=attr>value</span>=<span class=string>"com.mysql.jdbc.Driver"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"url"</span> <span class=attr>value</span>=<span class=string>"jdbc:mysql://localhost:3306/mydb"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"username"</span> <span class=attr>value</span>=<span class=string>"root"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"password"</span> <span class=attr>value</span>=<span class=string>"misterkaoli"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure><p>以下示例使用<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-p-namespace rel=noopener target=_blank>p-namespace</a>进行更简洁的XML配置：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:p</span>=<span class=string>"http://www.springframework.org/schema/p"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>    https://www.springframework.org/schema/beans/spring-beans.xsd"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"myDataSource"</span> <span class=attr>class</span>=<span class=string>"org.apache.commons.dbcp.BasicDataSource"</span></span></span><br><span class=line><span class=tag>        <span class=attr>destroy-method</span>=<span class=string>"close"</span></span></span><br><span class=line><span class=tag>        <span class=attr>p:driverClassName</span>=<span class=string>"com.mysql.jdbc.Driver"</span></span></span><br><span class=line><span class=tag>        <span class=attr>p:url</span>=<span class=string>"jdbc:mysql://localhost:3306/mydb"</span></span></span><br><span class=line><span class=tag>        <span class=attr>p:username</span>=<span class=string>"root"</span></span></span><br><span class=line><span class=tag>        <span class=attr>p:password</span>=<span class=string>"misterkaoli"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure><p>前面的XML更简洁。但是，除非在创建bean定义时使用支持自动属性完成的IDE，否则错误是在运行时而不是设计时发现的。<p>您还可以配置<code>java.util.Properties</code>实例，如下所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"mappings"</span> <span class=attr>class</span>=<span class=string>"org.springframework.context.support.PropertySourcesPlaceholderConfigurer"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"properties"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>value</span>></span></span><br><span class=line>            jdbc.driver.className=com.mysql.jdbc.Driver</span><br><span class=line>            jdbc.url=jdbc:mysql://localhost:3306/mydb</span><br><span class=line>        <span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure><p>Spring 容器使用 JavaBeans <code>PropertyEditor</code>机制将<code>&LTvalue/></code>元素内的文本转换为<code>java.util.Properties</code>实例。这是一个不错的捷径，并且是 Spring 团队偏爱使用嵌套<code>&LTvalue/></code>元素而不是<code>value</code>属性样式的几个地方之一。<ul><li><p>idref元素</p> <p><code>idref</code>元素只是将容器中另一个 bean 的<code>id</code>(字符串值-不是引用)传递给<code>&LTconstructor-arg/></code>或<code>&LTproperty/></code>元素的一种防错方法。以下示例显示了如何使用它：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"theTargetBean"</span> <span class=attr>class</span>=<span class=string>"..."</span>/></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"theClientBean"</span> <span class=attr>class</span>=<span class=string>"..."</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"targetName"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>idref</span> <span class=attr>bean</span>=<span class=string>"theTargetBean"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure></ul><p>前面的bean定义片段（在运行时）与下面的片段完全等效：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"theTargetBean"</span> <span class=attr>class</span>=<span class=string>"..."</span> /></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"client"</span> <span class=attr>class</span>=<span class=string>"..."</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"targetName"</span> <span class=attr>value</span>=<span class=string>"theTargetBean"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure><p>第一种形式优于第二种形式，因为使用<code>idref</code>标签可以使容器在部署时验证所引用的命名 Bean 实际上是否存在。在第二个变体中，不对传递给<code>client</code> bean 的<code>targetName</code>属性的值执行验证。仅在实际实例化<code>client</code> bean 时才发现拼写错误(极有可能导致致命的结果)。如果<code>client</code> bean 是<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes rel=noopener target=_blank>prototype</a> bean，则只能在部署容器很长时间之后发现此错字和所产生的异常。<h5 id=对其他Bean的引用（协作者）><a class=headerlink href=#对其他Bean的引用（协作者） title=对其他Bean的引用（协作者）></a>对其他Bean的引用（协作者）</h5><p>通过<code>&LTref/></code>标签的<code>bean</code>属性指定目标 bean 是最通用的形式，并且允许创建对同一容器或父容器中任何 bean 的引用，而不管它是否在同一 XML 文件中。 <code>bean</code>属性的值可以与目标 Bean 的<code>id</code>属性相同，也可以与目标 Bean 的<code>name</code>属性中的值之一相同。下面的示例演示如何使用<code>ref</code>元素：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>ref</span> <span class=attr>bean</span>=<span class=string>"someBean"</span>/></span></span><br></pre></table></figure><p>通过<code>parent</code>属性指定目标 bean 将创建对当前容器的父容器中的 bean 的引用。 <code>parent</code>属性的值可以与目标 Bean 的<code>id</code>属性或目标 Bean 的<code>name</code>属性中的值相同。目标 Bean 必须位于当前容器的父容器中。主要在具有容器层次结构并且要使用与父 bean 名称相同的代理将现有 bean 封装在父容器中时，才应使用此 bean 参考变量。以下一对清单显示了如何使用<code>parent</code>属性：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- in the parent context --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"accountService"</span> <span class=attr>class</span>=<span class=string>"com.something.SimpleAccountService"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- insert dependencies as required as here --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- in the child (descendant) context --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"accountService"</span> &LT!<span class=attr>--</span> <span class=attr>bean</span> <span class=attr>name</span> <span class=attr>is</span> <span class=attr>the</span> <span class=attr>same</span> <span class=attr>as</span> <span class=attr>the</span> <span class=attr>parent</span> <span class=attr>bean</span> <span class=attr>--</span>></span></span><br><span class=line>    class="org.springframework.aop.framework.ProxyFactoryBean"></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"target"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>ref</span> <span class=attr>parent</span>=<span class=string>"accountService"</span>/></span> </span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure><blockquote><p><code>ref</code>元素上的<code>local</code>属性在 4.0 bean XSD 中不再受支持，因为它不再提供常规<code>bean</code>引用上的值。升级到 4.0 模式时，将现有的<code>ref local</code>引用更改为<code>ref bean</code>。</blockquote><h5 id=内部Bean><a class=headerlink href=#内部Bean title=内部Bean></a>内部Bean</h5><p><code>&LTproperty/></code>或<code>&LTconstructor-arg/></code>元素内的<code>&LTbean/></code>元素定义了一个内部 bean，如以下示例所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"outer"</span> <span class=attr>class</span>=<span class=string>"..."</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"target"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"com.example.Person"</span>></span> <span class=comment>&LT!-- this is the inner bean --></span></span><br><span class=line>            <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"Fiona Apple"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"age"</span> <span class=attr>value</span>=<span class=string>"25"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure><p>内部 bean 定义不需要定义的 ID 或名称。如果指定，则容器不使用该值作为标识符。容器在创建时也将忽略<code>scope</code>标志，因为内部 Bean 始终是匿名的，并且始终与外部 Bean 一起创建。不可能独立地访问内部 bean 或将其注入到协作 bean 中而不是封装到封闭 bean 中。<h5 id=集合><a class=headerlink href=#集合 title=集合></a>集合</h5><p><code>&LTlist/></code>，<code>&LTset/></code>，<code>&LTmap/></code>和<code>&LTprops/></code>元素分别设置 Java <code>Collection</code>类型<code>List</code>，<code>Set</code>，<code>Map</code>和<code>Properties</code>的属性和参数。以下示例显示了如何使用它们：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"moreComplexObject"</span> <span class=attr>class</span>=<span class=string>"example.ComplexObject"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- results in a setAdminEmails(java.util.Properties) call --></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"adminEmails"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>props</span>></span></span><br><span class=line>            <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"administrator"</span>></span>administrator@example.org<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>            <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"support"</span>></span>support@example.org<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>            <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"development"</span>></span>development@example.org<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>props</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=comment>&LT!-- results in a setSomeList(java.util.List) call --></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"someList"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>list</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>a list element followed by a reference<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>ref</span> <span class=attr>bean</span>=<span class=string>"myDataSource"</span> /></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>list</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=comment>&LT!-- results in a setSomeMap(java.util.Map) call --></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"someMap"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>map</span>></span></span><br><span class=line>            <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"an entry"</span> <span class=attr>value</span>=<span class=string>"just some string"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>entry</span> <span class=attr>key</span> =<span class=string>"a ref"</span> <span class=attr>value-ref</span>=<span class=string>"myDataSource"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>map</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=comment>&LT!-- results in a setSomeSet(java.util.Set) call --></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"someSet"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>set</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>just some string<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>ref</span> <span class=attr>bean</span>=<span class=string>"myDataSource"</span> /></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>set</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure><p>Map 键或值的值或设置值也可以是以下任意元素：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>bean | ref | idref | list | set | map | props | value | null</span><br></pre></table></figure><h6 id=集合合并><a class=headerlink href=#集合合并 title=集合合并></a>集合合并</h6><p>Spring 容器还支持合并集合。应用程序开发人员可以定义父级<list>，<map>，<set>或<props>元素，并使子级<list>，<map>，<set>或<props>元素继承并覆盖父级集合中的值。也就是说，子集合的值是合并父集合和子集合的元素的结果，子集合的元素将覆盖父集合中指定的值。 <p>下面的示例演示了集合合并：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"parent"</span> <span class=attr>abstract</span>=<span class=string>"true"</span> <span class=attr>class</span>=<span class=string>"example.ComplexObject"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"adminEmails"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>props</span>></span></span><br><span class=line>                <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"administrator"</span>></span>administrator@example.com<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>                <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"support"</span>></span>support@example.com<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>props</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"child"</span> <span class=attr>parent</span>=<span class=string>"parent"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"adminEmails"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>props</span> <span class=attr>merge</span>=<span class=string>"true"</span>></span></span><br><span class=line>                <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"sales"</span>></span>sales@example.com<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>                <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"support"</span>></span>support@example.co.uk<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>props</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag><<span class=name>beans</span>></span></span><br></pre></table></figure> <h6 id=集合合并的局限><a class=headerlink href=#集合合并的局限 title=集合合并的局限></a>集合合并的局限</h6><p>您不能合并不同的集合类型(例如<code>Map</code>和<code>List</code>)。如果尝试这样做，则会抛出一个适当的<code>Exception</code>。 <code>merge</code>属性必须在较低的继承的子定义中指定。在父集合定义上指定<code>merge</code>属性是多余的，不会导致所需的合并。</p> <h6 id=强类型集合><a class=headerlink href=#强类型集合 title=强类型集合></a>强类型集合</h6><p>随着 Java 5 中泛型类型的引入，您可以使用强类型集合。也就是说，可以声明<code>Collection</code>类型，使其只能包含(例如)<code>String</code>元素。如果使用 Spring 将强类型的<code>Collection</code>依赖项注入到 bean 中，则可以利用 Spring 的类型转换支持，以便将强类型<code>Collection</code>实例的元素转换为适当的类型，然后再添加到<code>Collection</code>。以下 Java 类和 bean 定义显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SomeClass</span> {</span><br><span class=line>    <span class=keyword>private</span> Map&LTString, Float> accounts;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setAccounts</span><span class=params>(Map&LTString, Float> accounts)</span> {</span><br><span class=line>        <span class=built_in>this</span>.accounts = accounts;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"something"</span> <span class=attr>class</span>=<span class=string>"x.y.SomeClass"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"accounts"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>map</span>></span></span><br><span class=line>                <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"one"</span> <span class=attr>value</span>=<span class=string>"9.99"</span>/></span></span><br><span class=line>                <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"two"</span> <span class=attr>value</span>=<span class=string>"2.75"</span>/></span></span><br><span class=line>                <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"six"</span> <span class=attr>value</span>=<span class=string>"3.99"</span>/></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>map</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>当准备注入<code>something</code> bean 的<code>accounts</code>属性时，可以通过反射获得有关强类型<code>Map&LTString, Float></code>的元素类型的泛型信息。因此，Spring 的类型转换基础结构将各种值元素识别为<code>Float</code>类型，并且字符串值(<code>9.99, 2.75</code>和<code>3.99</code>)被转换为实际的<code>Float</code>类型。</p> <h5 id=空字符串值和空字符串><a class=headerlink href=#空字符串值和空字符串 title=空字符串值和空字符串></a>空字符串值和空字符串</h5><p>Spring将属性等的空参数视为空 <code>Strings</code>。以下基于XML的配置元数据片段将<code>email</code>属性设置为空 <code>String</code>值（“”）。</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"ExampleBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"email"</span> <span class=attr>value</span>=<span class=string>""</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>前面的示例等效于以下Java代码：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>exampleBean.setEmail(<span class=string>""</span>);</span><br></pre></table></figure> <p><code>&LTnull/></code>元素处理<code>null</code>的值。以下清单显示了一个示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"ExampleBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"email"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>null</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>前面的配置等效于下面的Java代码：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>exampleBean.setEmail(<span class=literal>null</span>);</span><br></pre></table></figure> <h5 id=具有P-命名空间的XML快捷方式><a class=headerlink href=#具有P-命名空间的XML快捷方式 title=具有P-命名空间的XML快捷方式></a>具有P-命名空间的XML快捷方式</h5><p>p-namespace 允许您使用<code>bean</code>元素的属性(而不是嵌套的<code>&LTproperty/></code>元素)来描述协作 Bean 的属性值，或同时使用这两者。</p> <p>Spring 支持基于 XML Schema 定义的可扩展配置格式<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-schemas rel=noopener target=_blank>with namespaces</a>。</p> <p>以下示例显示了两个XML代码段（第一个使用标准XML格式，第二个使用p-命名空间），它们可以解析为相同的结果：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:p</span>=<span class=string>"http://www.springframework.org/schema/p"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>name</span>=<span class=string>"classic"</span> <span class=attr>class</span>=<span class=string>"com.example.ExampleBean"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"email"</span> <span class=attr>value</span>=<span class=string>"someone@somewhere.com"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>name</span>=<span class=string>"p-namespace"</span> <span class=attr>class</span>=<span class=string>"com.example.ExampleBean"</span></span></span><br><span class=line><span class=tag>        <span class=attr>p:email</span>=<span class=string>"someone@somewhere.com"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>该示例显示了 p 命名空间中 Bean 定义中名为<code>email</code>的属性。这告诉 Spring 包含一个属性声明。如前所述，p 名称空间没有架构定义，因此可以将属性名称设置为属性名称。</p> <p>下一个示例包括另外两个bean定义，它们都引用了另一个bean：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:p</span>=<span class=string>"http://www.springframework.org/schema/p"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>name</span>=<span class=string>"john-classic"</span> <span class=attr>class</span>=<span class=string>"com.example.Person"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"John Doe"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"spouse"</span> <span class=attr>ref</span>=<span class=string>"jane"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>name</span>=<span class=string>"john-modern"</span> <span class=attr>class</span>=<span class=string>"com.example.Person"</span></span></span><br><span class=line><span class=tag>          <span class=attr>p:name</span>=<span class=string>"John Doe"</span></span></span><br><span class=line><span class=tag>          <span class=attr>p:spouse-ref</span>=<span class=string>"jane"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>name</span>=<span class=string>"jane"</span> <span class=attr>class</span>=<span class=string>"com.example.Person"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"Jane Doe"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>此示例不仅包括使用 p-namespace 的属性值，还使用特殊格式声明属性引用。第一个 bean 定义使用<code>&LTproperty name="spouse" ref="jane"/></code>创建从 bean <code>john</code>到 Bean <code>jane</code>的引用，而第二个 bean 定义使用<code>p:spouse-ref="jane"</code>作为属性来执行完全相同的操作。在这种情况下，<code>spouse</code>是属性名称，而<code>-ref</code>部分表示这不是一个直接值，而是对另一个 bean 的引用。</p> <h5 id=具有C-命名空间的XML快捷方式><a class=headerlink href=#具有C-命名空间的XML快捷方式 title=具有C-命名空间的XML快捷方式></a>具有C-命名空间的XML快捷方式</h5><p>在Spring 3.1中引入的c-namespace允许使用内联属性来配置构造函数参数，而不是嵌套<code>constructor-arg</code>元素。</p> <p>下面的示例使用<code>c:</code>名称空间执行与 基于构造函数的依赖注入相同的操作：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:c</span>=<span class=string>"http://www.springframework.org/schema/c"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"beanTwo"</span> <span class=attr>class</span>=<span class=string>"x.y.ThingTwo"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"beanThree"</span> <span class=attr>class</span>=<span class=string>"x.y.ThingThree"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- traditional declaration with optional argument names --></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"beanOne"</span> <span class=attr>class</span>=<span class=string>"x.y.ThingOne"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>constructor-arg</span> <span class=attr>name</span>=<span class=string>"thingTwo"</span> <span class=attr>ref</span>=<span class=string>"beanTwo"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>constructor-arg</span> <span class=attr>name</span>=<span class=string>"thingThree"</span> <span class=attr>ref</span>=<span class=string>"beanThree"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>constructor-arg</span> <span class=attr>name</span>=<span class=string>"email"</span> <span class=attr>value</span>=<span class=string>"something@somewhere.com"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- c-namespace declaration with argument names --></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"beanOne"</span> <span class=attr>class</span>=<span class=string>"x.y.ThingOne"</span> <span class=attr>c:thingTwo-ref</span>=<span class=string>"beanTwo"</span></span></span><br><span class=line><span class=tag>        <span class=attr>c:thingThree-ref</span>=<span class=string>"beanThree"</span> <span class=attr>c:email</span>=<span class=string>"something@somewhere.com"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p><code>c:</code>名称空间使用与<code>p:</code>相同的约定(对于 Bean 引用，尾随<code>-ref</code>)以其名称设置构造函数参数。同样，即使未在 XSD 模式中定义它(也存在于 Spring 内核中)也需要声明它。</p> <p>对于极少数情况下无法使用构造函数自变量名称的情况(通常，如果字节码是在没有调试信息的情况下编译的)，可以对参数索引使用后备，如下所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- c-namespace index declaration --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"beanOne"</span> <span class=attr>class</span>=<span class=string>"x.y.ThingOne"</span> <span class=attr>c:_0-ref</span>=<span class=string>"beanTwo"</span> <span class=attr>c:_1-ref</span>=<span class=string>"beanThree"</span> <span class=attr>c:_2</span>=<span class=string>"something@somewhere.com"</span>/></span></span><br></pre></table></figure> <blockquote><p>由于XML语法的原因，索引表示法要求使用前导<code>_</code>，因为XML属性名称不能以数字开头（即使某些IDE允许）。相应的索引符号也可用于<code>&LTconstructor-arg></code>元素，但并不常用，因为声明的简单顺序通常就足够了。</blockquote> <h5 id=复合属性名称><a class=headerlink href=#复合属性名称 title=复合属性名称></a>复合属性名称</h5><p>设置bean属性时，可以使用复合属性名称或嵌套属性名称，只要路径中除最终属性名称之外的所有组件都不是<code>null</code>即可。考虑以下bean定义：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"something"</span> <span class=attr>class</span>=<span class=string>"things.ThingOne"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"fred.bob.sammy"</span> <span class=attr>value</span>=<span class=string>"123"</span> /></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p><code>something</code> bean 具有<code>fred</code>属性，该属性具有<code>bob</code>属性，该属性具有<code>sammy</code>属性，并且最终的<code>sammy</code>属性被设置为<code>123</code>的值。为了使它起作用，在构造 bean 之后，<code>something</code>的<code>fred</code>属性和<code>fred</code>的<code>bob</code>属性一定不能为<code>null</code>。否则，将抛出<code>NullPointerException</code>。</p> <h4 id=2-1-4-3、使用-depends-on><a title="2.1.4.3、使用 depends-on" class=headerlink href=#2-1-4-3、使用-depends-on></a>2.1.4.3、使用 depends-on</h4><p>以下示例使用该<code>depends-on</code>属性表示对单个bean的依赖关系：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"beanOne"</span> <span class=attr>class</span>=<span class=string>"ExampleBean"</span> <span class=attr>depends-on</span>=<span class=string>"manager"</span>/></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"manager"</span> <span class=attr>class</span>=<span class=string>"ManagerBean"</span> /></span></span><br></pre></table></figure> <p>要表达对多个bean的依赖性，请提供一个bean名称列表作为<code>depends-on</code>属性值（逗号，空格和分号是有效的分隔符）：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"beanOne"</span> <span class=attr>class</span>=<span class=string>"ExampleBean"</span> <span class=attr>depends-on</span>=<span class=string>"manager,accountDao"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"manager"</span> <span class=attr>ref</span>=<span class=string>"manager"</span> /></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"manager"</span> <span class=attr>class</span>=<span class=string>"ManagerBean"</span> /></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"accountDao"</span> <span class=attr>class</span>=<span class=string>"x.y.jdbc.JdbcAccountDao"</span> /></span></span><br></pre></table></figure> <blockquote><p>该<code>depends-on</code>属性既可以指定初始化时间相关性，也可以指定单例情况 。</blockquote> <h4 id=2-1-4-4、延迟初始化Bean><a class=headerlink href=#2-1-4-4、延迟初始化Bean title=2.1.4.4、延迟初始化Bean></a>2.1.4.4、延迟初始化Bean</h4><p>在XML中，此行为由元素上的lazy-init属性控制，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"lazy"</span> <span class=attr>class</span>=<span class=string>"com.something.ExpensiveToCreateBean"</span> <span class=attr>lazy-init</span>=<span class=string>"true"</span>/></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>name</span>=<span class=string>"not.lazy"</span> <span class=attr>class</span>=<span class=string>"com.something.AnotherBean"</span>/></span></span><br></pre></table></figure> <p>当<code>ApplicationContext</code>消耗了前面的配置时，<code>ApplicationContext</code>启动时就不会急于预先实例化<code>lazy</code> bean，而<code>not.lazy</code> Bean 则会急于预先实例化。</p> <p>但是，当延迟初始化的 bean 是未延迟初始化的单例 bean 的依赖项时，<code>ApplicationContext</code>将在启动时创建延迟初始化的 bean，因为它必须满足单例的依赖关系。延迟初始化的 bean 被注入到其他未延迟初始化的单例 bean 中。</p> <p>您还可以使用<code>&LTbeans/></code>元素上的<code>default-lazy-init</code>属性在容器级别控制延迟初始化，以下示例显示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>default-lazy-init</span>=<span class=string>"true"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- no beans will be pre-instantiated... --></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h4 id=2-1-4-5、自动装配协作器><a class=headerlink href=#2-1-4-5、自动装配协作器 title=2.1.4.5、自动装配协作器></a>2.1.4.5、自动装配协作器</h4><p>自动装配具有以下优点：</p> <ul><li>自动装配可以大大减少指定属性或构造函数参数的需要。<li>随着对象的发展，自动装配可以更新配置。例如，如果需要将依赖项添加到类中，则无需修改配置即可自动满足该依赖项。因此，自动装配在开发过程中特别有用，而不必担心在代码库变得更稳定时切换到显式接线的选择。</ul> <p>使用基于 XML 的配置元数据时，可以使用<code>&LTbean/></code>元素的<code>autowire</code>属性为 bean 定义指定自动装配模式。自动装配功能具有四种模式。您可以为每个 bean 指定自动装配，因此可以选择要自动装配的装配。下表描述了四种自动装配模式：</p> <table><thead><tr><th align=left>模式<th align=left>说明<tbody><tr><td align=left><code>no</code><td align=left>（默认）无自动装配。Bean引用必须由<code>ref</code>元素定义。对于较大的部署，建议不要更改默认设置，因为明确指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了系统的结构。<tr><td align=left><code>byName</code><td align=left>按属性名称自动布线。Spring查找与需要自动装配的属性同名的bean。例如，如果一个bean定义被设置为按名称自动装配并且包含一个<code>master</code>属性（即它具有一个 <code>setMaster(..)</code>方法），那么Spring将查找一个名为的bean定义，<code>master</code>并使用它来设置该属性。<tr><td align=left><code>byType</code><td align=left>如果容器中恰好存在一个属性类型的bean，则使该属性自动连接。如果存在多个错误，则会引发致命异常，这表明您可能无法<code>byType</code>对该bean使用自动装配。如果没有匹配的bean，则什么都不会发生（未设置该属性）。<tr><td align=left><code>constructor</code><td align=left>类似于<code>byType</code>但适用于构造函数参数。如果容器中不存在构造函数参数类型的一个bean，则将引发致命错误。</table> <p>使用<code>byType</code>或<code>constructor</code>自动装配模式，您可以连接阵列和键入的集合。在这种情况下，将提供容器中与预期类型匹配的所有自动装配候选，以满足相关性。如果预期的密钥类型为<code>String</code>，则可以自动连接强类型的<code>Map</code>实例。自动连接的<code>Map</code>实例的值包含与期望的类型匹配的所有 bean 实例，并且<code>Map</code>实例的键包含相应的 Bean 名称。</p> <h5 id=自动装配的局限性和缺点><a class=headerlink href=#自动装配的局限性和缺点 title=自动装配的局限性和缺点></a>自动装配的局限性和缺点</h5><p>自动装配的缺点和局限：</p> <ul><li><code>property</code>和<code>constructor-arg</code>设置中的显式依赖项始终会覆盖自动装配。您不能自动连接简单属性，例如基元，<code>Strings</code>和<code>Classes</code>(以及此类简单属性的数组)。此限制是设计使然。<li>自动装配不如显式装配精确。<li>装配信息可能不适用于从Spring容器生成文档的工具。<li>容器内的多个bean定义可能与要自动装配的setter方法或构造函数参数指定的类型匹配。对于数组，集合或 <code>Map</code>实例，这不一定是问题。但是，对于需要单个值的依赖项，不会任意解决此歧义。如果没有唯一的bean定义可用，则会引发异常。</ul> <p>在后一种情况下，您有几种选择：</p> <ul><li>放弃自动装配，转而使用显式装配。<li>如<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-autowire-candidate rel=noopener target=_blank>next section</a>中所述，通过将其<code>autowire-candidate</code>属性设置为<code>false</code>来避免自动装配 bean 定义。<li>通过将其<code>&LTbean/></code>元素的<code>primary</code>属性设置为<code>true</code>，将单个 bean 定义指定为主要候选对象。<li>如<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-annotation-config rel=noopener target=_blank>基于注解的容器配置</a>中所述，通过基于注解的配置实现更细粒度的控件。</ul> <h5 id=从自动装配中排除Bean><a class=headerlink href=#从自动装配中排除Bean title=从自动装配中排除Bean></a>从自动装配中排除Bean</h5><p>在每个bean的基础上，您可以从自动装配中排除一个bean。使用Spring的XML格式，将元素的<code>autowire-candidate</code>属性设置<code>&LTbean/></code>为<code>false</code>。容器使特定的 bean 定义对于自动装配基础结构不可用(包括注解样式配置，例如<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-autowired-annotation rel=noopener target=_blank>@Autowired</a>)。</p> <blockquote><p><code>autowire-candidate</code>属性旨在仅影响基于类型的自动装配。它不会影响按名称显示的显式引用，即使未将指定的 Bean 标记为自动装配候选，该名称也可得到解析。因此，如果名称匹配，按名称自动装配仍会注入 Bean。</blockquote> <h4 id=2-1-4-6、方法注入><a class=headerlink href=#2-1-4-6、方法注入 title=2.1.4.6、方法注入></a>2.1.4.6、方法注入</h4><p>在大多数应用场景中，容器中的大多数bean是 <a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton rel=noopener target=_blank>singletons</a>。当一个单例Bean需要与另一个单例Bean协作或一个非单例Bean需要与另一个非单例Bean协作时，通常可以通过将一个Bean定义为另一个Bean的属性来处理依赖关系。当bean的生命周期不同时会出现问题。假设单例bean A需要使用非单例（原型）bean B，也许在A的每个方法调用上都使用。容器仅创建一次单例bean A，因此只有一次机会来设置属性。每次需要一个容器时，容器都无法为bean A提供一个新的bean B实例。</p> <p>一个解决方案是放弃某些控制反转。您可以通过实现<code>ApplicationContextAware</code>接口来<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-aware rel=noopener target=_blank>使 bean A 知道容器</a>，并在每次 bean A 需要它时<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-client rel=noopener target=_blank>对容器进行 getBean(“ B”)调用</a>询问(通常是新的)bean B 实例。以下示例显示了此方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> fiona.apple;</span><br><span class=line><span class=comment>// Spring-API imports</span></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.BeansException;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.ApplicationContext;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.ApplicationContextAware;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CommandManager</span> <span class=keyword>implements</span> <span class="title class_">ApplicationContextAware</span> {</span><br><span class=line>    <span class=keyword>private</span> ApplicationContext applicationContext;</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">process</span><span class=params>(Map commandState)</span> {</span><br><span class=line>        <span class=comment>// grab a new instance of the appropriate Command</span></span><br><span class=line>        <span class=type>Command</span> <span class=variable>command</span> <span class=operator>=</span> createCommand();</span><br><span class=line>        <span class=comment>// set the state on the (hopefully brand new) Command instance</span></span><br><span class=line>        command.setState(commandState);</span><br><span class=line>        <span class=keyword>return</span> command.execute();</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>protected</span> Command <span class="title function_">createCommand</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// notice the Spring API dependency!</span></span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.applicationContext.getBean(<span class=string>"command"</span>, Command.class);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setApplicationContext</span><span class=params>(</span></span><br><span class=line><span class=params>            ApplicationContext applicationContext)</span> <span class=keyword>throws</span> BeansException {</span><br><span class=line>        <span class=built_in>this</span>.applicationContext = applicationContext;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>前面的内容是不理想的，因为业务代码知道并耦合到Spring框架。方法注入是Spring IoC容器的一项高级功能，使您可以干净地处理此用例。</p> <h5 id=查找方法注入><a class=headerlink href=#查找方法注入 title=查找方法注入></a>查找方法注入</h5><p>查找方法注入是容器重写容器管理的Bean上的方法并返回容器中另一个命名Bean的查找结果的能力。查找通常涉及原型bean。Spring框架通过使用CGLIB库中的字节码生成来动态生成覆盖该方法的子类，从而实现此方法的注入。</p> <blockquote><ul><li>为了使此动态子类起作用，Spring Bean容器子类的类也不能为<code>final</code>，要覆盖的方法也不能为<code>final</code>。<li>对具有<code>abstract</code>方法的类进行单元测试需要您自己对该类进行子类化，并提供该<code>abstract</code>方法的存根实现。<li>组件扫描也需要具体的方法，这需要具体的类。<li>另一个关键限制是，查找方法不适用于工厂方法，尤其不适用于配置类中的<code>@Bean</code>方法，因为在这种情况下，容器不负责创建实例，因此无法创建运行时生成的子类。</ul></blockquote> <p>对于前面的代码片段中的<code>CommandManager</code>类，Spring 容器将动态覆盖<code>createCommand()</code>方法的实现。 <code>CommandManager</code>类没有任何 Spring 依赖项，如重做的示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> fiona.apple;</span><br><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">CommandManager</span> {</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">process</span><span class=params>(Object commandState)</span> {</span><br><span class=line>        <span class=comment>// grab a new instance of the appropriate Command interface</span></span><br><span class=line>        <span class=type>Command</span> <span class=variable>command</span> <span class=operator>=</span> createCommand();</span><br><span class=line>        <span class=comment>// set the state on the (hopefully brand new) Command instance</span></span><br><span class=line>        command.setState(commandState);</span><br><span class=line>        <span class=keyword>return</span> command.execute();</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// okay... but where is the implementation of this method?</span></span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>abstract</span> Command <span class="title function_">createCommand</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>在包含要注入的方法的客户端类（<code>CommandManager</code>在本例中为）中，要注入的方法需要以下形式的签名：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>&LTpublic|protected> [abstract] <span class=tag><<span class=name>return-type</span>></span> theMethodName(no-arguments);</span><br></pre></table></figure> <p>如果方法为<code>abstract</code>，则动态生成的子类将实现该方法。否则，动态生成的子类将覆盖原始类中定义的具体方法。考虑以下示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- a stateful bean deployed as a prototype (non-singleton) --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"myCommand"</span> <span class=attr>class</span>=<span class=string>"fiona.apple.AsyncCommand"</span> <span class=attr>scope</span>=<span class=string>"prototype"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- inject dependencies here as required --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=comment>&LT!-- commandProcessor uses statefulCommandHelper --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"commandManager"</span> <span class=attr>class</span>=<span class=string>"fiona.apple.CommandManager"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>lookup-method</span> <span class=attr>name</span>=<span class=string>"createCommand"</span> <span class=attr>bean</span>=<span class=string>"myCommand"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>每当需要<code>myCommand</code> bean 的新实例时，标识为<code>commandManager</code>的 bean 就会调用其自己的<code>createCommand()</code>方法。如果确实需要<code>myCommand</code> bean 作为原型，则必须小心。如果它是<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-singleton rel=noopener target=_blank>singleton</a>，则每次都返回<code>myCommand</code> bean 的相同实例。</p> <p>另外，在基于注解的组件模型中，您可以通过<code>@Lookup</code>注解 声明一个查找方法，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">CommandManager</span> {</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">process</span><span class=params>(Object commandState)</span> {</span><br><span class=line>        <span class=type>Command</span> <span class=variable>command</span> <span class=operator>=</span> createCommand();</span><br><span class=line>        command.setState(commandState);</span><br><span class=line>        <span class=keyword>return</span> command.execute();</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Lookup("myCommand")</span></span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>abstract</span> Command <span class="title function_">createCommand</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>或者，更惯用的是，您可以依赖于目标bean根据lookup方法的声明的返回类型来解析：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">CommandManager</span> {</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">process</span><span class=params>(Object commandState)</span> {</span><br><span class=line>        <span class=type>MyCommand</span> <span class=variable>command</span> <span class=operator>=</span> createCommand();</span><br><span class=line>        command.setState(commandState);</span><br><span class=line>        <span class=keyword>return</span> command.execute();</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Lookup</span></span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>abstract</span> MyCommand <span class="title function_">createCommand</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=任意方法替换><a class=headerlink href=#任意方法替换 title=任意方法替换></a>任意方法替换</h5><p>与查找方法注入相比，方法注入的一种不太有用的形式是能够用另一种方法实现替换托管bean中的任意方法。</p> <h3 id=2-1-5、Bean作用域><a class=headerlink href=#2-1-5、Bean作用域 title=2.1.5、Bean作用域></a>2.1.5、Bean作用域</h3><p>下表描述了受支持的范围：</p> <table><thead><tr><th align=left>范围<th align=left>描述<tbody><tr><td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton rel=noopener target=_blank>singleton</a><td align=left>（默认值）将每个Spring IoC容器的单个bean定义范围限定为单个对象实例。<tr><td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-prototype rel=noopener target=_blank>prototype</a><td align=left>将单个bean定义的作用域限定为任意数量的对象实例。<tr><td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-request rel=noopener target=_blank>request</a><td align=left>将单个bean定义的范围限定为单个HTTP请求的生命周期。也就是说，每个HTTP请求都有一个自己的bean实例，它是在单个bean定义的后面创建的。仅在可感知网络的Spring上下文中有效<code>ApplicationContext</code>。<tr><td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-session rel=noopener target=_blank>session</a><td align=left>将单个bean定义的范围限定为HTTP的生命周期<code>Session</code>。仅在基于Web的Spring上下文中有效<code>ApplicationContext</code>.<tr><td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-application rel=noopener target=_blank>application</a><td align=left>将单个bean定义的作用域限定为的生命周期<code>ServletContext</code>。仅在可感知网络的Spring上下文中有效<code>ApplicationContext</code>。<tr><td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-websocket-scope rel=noopener target=_blank>websocket</a><td align=left>将单个bean定义的作用域限定为的生命周期<code>WebSocket</code>。仅在可感知网络的Spring上下文中有效<code>ApplicationContext</code>。</table> <blockquote><p>从Spring 3.0开始，线程作用域可用，但默认情况下未注册。</blockquote> <h4 id=2-1-5-1、singleton-scope><a title="2.1.5.1、singleton scope" class=headerlink href=#2-1-5-1、singleton-scope></a>2.1.5.1、singleton scope</h4><p>当您定义一个bean定义并且其作用域为单例时，Spring IoC容器将为该bean定义所定义的对象创建一个实例。该单个实例存储在此类单例bean的高速缓存中，并且对该命名bean的所有后续请求和引用都返回该高速缓存的对象。下图显示了单例作用域的工作方式：</p> <p><img alt=singleton src=C:\Users\shihao\Desktop\图片\工作\Spring\单例Bean工作方式01></p> <p>要将bean定义为XML中的单例，可以定义bean，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"accountService"</span> <span class=attr>class</span>=<span class=string>"com.something.DefaultAccountService"</span>/></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"accountService"</span> <span class=attr>class</span>=<span class=string>"com.something.DefaultAccountService"</span> <span class=attr>scope</span>=<span class=string>"singleton"</span>/></span></span><br></pre></table></figure> <h4 id=2-1-5-2、prototype-scope><a title="2.1.5.2、prototype scope" class=headerlink href=#2-1-5-2、prototype-scope></a>2.1.5.2、prototype scope</h4><p>每次对特定 bean 提出请求时，bean 部署的非单一原型范围都会导致创建一个新 bean 实例。也就是说，将 Bean 注入到另一个 Bean 中，或者您可以通过容器上的<code>getBean()</code>方法调用来请求它。通常，应将原型作用域用于所有有状态 Bean，将单例作用域用于 StatelessBean。</p> <p>以下示例将bean定义为XML原型：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"accountService"</span> <span class=attr>class</span>=<span class=string>"com.something.DefaultAccountService"</span> <span class=attr>scope</span>=<span class=string>"prototype"</span>/></span></span><br></pre></table></figure> <h4 id=2-1-5-3、具有原型bean依赖关系的singleton-bena><a title="2.1.5.3、具有原型bean依赖关系的singleton bena" class=headerlink href=#2-1-5-3、具有原型bean依赖关系的singleton-bena></a>2.1.5.3、具有原型bean依赖关系的singleton bena</h4><p>当您使用对原型 bean 有依赖性的单例作用域 Bean 时，请注意，依赖关系在实例化时已解决。因此，如果将依赖项原型的 bean 依赖项注入到单例范围的 bean 中，则将实例化新的原型 bean，然后将依赖项注入到单例 bean 中。原型实例是曾经提供给单例范围的 bean 的唯一实例。</p> <p>但是，假设您希望单例作用域的 bean 在运行时重复获取原型作用域的 bean 的新实例。您不能将原型作用域的 bean 依赖项注入到您的单例 bean 中，因为当 Spring 容器实例化单例 bean 并解析并注入其依赖项时，该注入仅发生一次。</p> <h4 id=2-1-5-4、request、session、application、websocket-scope><a title="2.1.5.4、request、session、application、websocket scope" class=headerlink href=#2-1-5-4、request、session、application、websocket-scope></a>2.1.5.4、request、session、application、websocket scope</h4><p><code>request</code>，<code>session</code>，<code>application</code>和<code>websocket</code>范围仅在使用 Web 感知的 Spring <code>ApplicationContext</code>实现(例如<code>XmlWebApplicationContext</code>)时可用。如果将这些作用域与常规的 Spring IoC 容器(例如<code>ClassPathXmlApplicationContext</code>)一起使用，则会引发未知 bean 作用域的<code>IllegalStateException</code>。</p> <h5 id=初始Web配置><a class=headerlink href=#初始Web配置 title=初始Web配置></a>初始Web配置</h5><p>如何完成此初始设置取决于您的特定Servlet环境。</p> <p>如果实际上在 Spring <code>DispatcherServlet</code>处理的请求中访问 Spring Web MVC 中的作用域 Bean，则不需要特殊的设置。 <code>DispatcherServlet</code>已经公开了所有相关状态。</p> <p>如果您使用 Servlet 2.5 Web 容器，并且在 Spring 的<code>DispatcherServlet</code>之外处理请求(例如，当使用 JSF 或 Struts 时)，则需要注册<code>org.springframework.web.context.request.RequestContextListener</code> <code>ServletRequestListener</code>。对于 Servlet 3.0，可以使用<code>WebApplicationInitializer</code>接口以编程方式完成此操作。或者，或者对于较旧的容器，将以下声明添加到 Web 应用程序的<code>web.xml</code>文件中：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>web-app</span>></span></span><br><span class=line>    ...</span><br><span class=line>    <span class=tag><<span class=name>listener</span>></span></span><br><span class=line>        <span class=tag><<span class=name>listener-class</span>></span></span><br><span class=line>            org.springframework.web.context.request.RequestContextListener</span><br><span class=line>        <span class=tag>&LT/<span class=name>listener-class</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>listener</span>></span></span><br><span class=line>    ...</span><br><span class=line><span class=tag>&LT/<span class=name>web-app</span>></span></span><br></pre></table></figure> <p>另外，如果您的监听器设置存在问题，请考虑使用 Spring 的<code>RequestContextFilter</code>。过滤器 Map 取决于周围的 Web 应用程序配置，因此您必须适当地对其进行更改。以下清单显示了 Web 应用程序的过滤器部分：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>web-app</span>></span></span><br><span class=line>    ...</span><br><span class=line>    <span class=tag><<span class=name>filter</span>></span></span><br><span class=line>        <span class=tag><<span class=name>filter-name</span>></span>requestContextFilter<span class=tag>&LT/<span class=name>filter-name</span>></span></span><br><span class=line>        <span class=tag><<span class=name>filter-class</span>></span>org.springframework.web.filter.RequestContextFilter<span class=tag>&LT/<span class=name>filter-class</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>filter</span>></span></span><br><span class=line>    <span class=tag><<span class=name>filter-mapping</span>></span></span><br><span class=line>        <span class=tag><<span class=name>filter-name</span>></span>requestContextFilter<span class=tag>&LT/<span class=name>filter-name</span>></span></span><br><span class=line>        <span class=tag><<span class=name>url-pattern</span>></span>/*<span class=tag>&LT/<span class=name>url-pattern</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>filter-mapping</span>></span></span><br><span class=line>    ...</span><br><span class=line><span class=tag>&LT/<span class=name>web-app</span>></span></span><br></pre></table></figure> <p><code>DispatcherServlet</code>，<code>RequestContextListener</code>和<code>RequestContextFilter</code>都做完全相同的事情，即将 HTTP 请求对象绑定到正在为该请求提供服务的<code>Thread</code>上。这使得在请求链和会话范围内的 Bean 可以在调用链的更下游使用。</p> <h5 id=request-scope><a title="request scope" class=headerlink href=#request-scope></a>request scope</h5><p>考虑以下XML配置来定义bean：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"loginAction"</span> <span class=attr>class</span>=<span class=string>"com.something.LoginAction"</span> <span class=attr>scope</span>=<span class=string>"request"</span>/></span></span><br></pre></table></figure> <p>Spring 容器通过为每个 HTTP 请求使用<code>loginAction</code> bean 定义来创建<code>LoginAction</code> bean 的新实例。也就是说，<code>loginAction</code> bean 的作用域是 HTTP 请求级别。您可以根据需要更改创建实例的内部状态，因为从同一<code>loginAction</code> bean 定义创建的其他实例看不到这些状态更改。它们特定于单个请求。当请求完成处理时，将限制作用于该请求的 Bean。</p> <p>使用注解驱动的组件或 Java 配置时，可以使用<code>@RequestScope</code>注解 将组件分配给<code>request</code>范围。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@RequestScope</span></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">LoginAction</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <h5 id=session-scope><a title="session scope" class=headerlink href=#session-scope></a>session scope</h5><p>考虑以下XML配置来定义bean：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"userPreferences"</span> <span class=attr>class</span>=<span class=string>"com.something.UserPreferences"</span> <span class=attr>scope</span>=<span class=string>"session"</span>/></span></span><br></pre></table></figure> <p>在单个 HTTP <code>Session</code>的生存期内，Spring 容器通过使用<code>userPreferences</code> bean 定义来创建<code>UserPreferences</code> bean 的新实例。换句话说，<code>userPreferences</code> bean 的作用域实际上是 HTTP <code>Session</code>级别。与请求范围的 Bean 一样，您可以根据需要任意更改所创建实例的内部状态，因为知道其他 HTTP <code>Session</code>实例(也使用从相同<code>userPreferences</code> Bean 定义创建的实例)不会看到这些状态更改，因为它们特定于单个 HTTP <code>Session</code>。当最终丢弃 HTTP <code>Session</code>时，也将丢弃作用于该特定 HTTP <code>Session</code>的 bean。</p> <p>使用注解驱动的组件或 Java 配置时，可以使用<code>@SessionScope</code>注解 将组件分配给<code>session</code>范围。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@SessionScope</span></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">UserPreferences</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <h5 id=application-scope><a title="application scope" class=headerlink href=#application-scope></a>application scope</h5><p>考虑以下XML配置来定义bean：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"appPreferences"</span> <span class=attr>class</span>=<span class=string>"com.something.AppPreferences"</span> <span class=attr>scope</span>=<span class=string>"application"</span>/></span></span><br></pre></table></figure> <p>Spring 容器通过对整个 Web 应用程序使用<code>appPreferences</code> bean 定义来创建<code>AppPreferences</code> bean 的新实例。也就是说，<code>appPreferences</code> bean 的作用域为<code>ServletContext</code>级别，并存储为常规<code>ServletContext</code>属性。这有点类似于 Spring 单例 bean，但是有两个重要的区别：它是每个<code>ServletContext</code>而不是每个 Spring’ApplicationContext’(在任何给定的 Web 应用程序中可能都有多个)，并且实际上是公开的，因此可见为<code>ServletContext</code>属性。</p> <p>使用注解驱动的组件或 Java 配置时，可以使用<code>@ApplicationScope</code>注解 将组件分配给<code>application</code>范围。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@ApplicationScope</span></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppPreferences</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <h5 id=作用域bean作为依赖项><a class=headerlink href=#作用域bean作为依赖项 title=作用域bean作为依赖项></a>作用域bean作为依赖项</h5><p>Spring IoC 容器不仅管理 对象(bean)的实例化，而且还 Management 协作者(或依赖项)的连接。如果要将(例如)HTTP 请求范围的 Bean 注入(例如)另一个作用域更长的 Bean，则可以选择注入 AOP 代理来代替已定义范围的 Bean。也就是说，您需要注入一个代理对象，该对象公开与范围对象相同的公共接口，但也可以从相关范围(例如 HTTP 请求)中检索实际目标对象，并将方法调用委托给该真实对象。</p> <h6 id=选择要创建的代理类型><a class=headerlink href=#选择要创建的代理类型 title=选择要创建的代理类型></a>选择要创建的代理类型</h6><p>默认情况下，当Spring容器为使用<code>&LTaop:scoped-proxy/></code>元素标记的bean创建代理时，将创建基于CGLIB的类代理。</p> <blockquote><p>CGLIB代理仅拦截公共方法调用！不要在此类代理上调用非公共方法。它们没有被委派给实际的作用域目标对象。</blockquote> <p>另外，您可以通过将<code>&LTaop:scoped-proxy/></code>元素的<code>proxy-target-class</code>属性的值指定为<code>false</code>来配置 Spring 容器为此类作用域的 bean 创建基于标准 JDK 接口的代理。使用基于 JDK 接口的代理意味着您不需要应用程序 Classpath 中的其他库即可影响此类代理。但是，这也意味着作用域 bean 的类必须实现至少一个接口，并且作用域 bean 注入到其中的所有协作者都必须通过其接口之一引用该 bean。</p> <p>以下示例显示了基于接口的代理：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- DefaultUserPreferences implements the UserPreferences interface --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"userPreferences"</span> <span class=attr>class</span>=<span class=string>"com.stuff.DefaultUserPreferences"</span> <span class=attr>scope</span>=<span class=string>"session"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:scoped-proxy</span> <span class=attr>proxy-target-class</span>=<span class=string>"false"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"userManager"</span> <span class=attr>class</span>=<span class=string>"com.stuff.UserManager"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"userPreferences"</span> <span class=attr>ref</span>=<span class=string>"userPreferences"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <h4 id=2-1-5-5、自定义范围><a class=headerlink href=#2-1-5-5、自定义范围 title=2.1.5.5、自定义范围></a>2.1.5.5、自定义范围</h4><p>Bean作用域机制是可扩展的。您可以定义自己的作用域，甚至重新定义现有作用域，尽管后者被认为是不好的做法，您不能覆盖内置作用域<code>singleton</code>和<code>prototype</code>作用域。</p> <h5 id=创建自定义范围><a class=headerlink href=#创建自定义范围 title=创建自定义范围></a>创建自定义范围</h5><p>要将自定义范围集成到Spring容器中，您需要实现<code>org.springframework.beans.factory.config.Scope</code>接口。</p> <p>该<code>Scope</code>接口有四种方法可以从作用域中获取对象，将它们从作用域中删除，然后将其销毁。</p> <p>以下方法从基础范围返回对象：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>Object <span class="title function_">get</span><span class=params>(String name, ObjectFactory&LT?> objectFactory)</span>;</span><br></pre></table></figure> <p>以下方法从基础范围中删除该对象：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>Object <span class="title function_">remove</span><span class=params>(String name)</span>;</span><br></pre></table></figure> <p>以下方法注册一个回调，当销毁作用域或销毁作用域中的指定对象时，作用域应调用该回调：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> <span class="title function_">registerDestructionCallback</span><span class=params>(String name, Runnable destructionCallback)</span>;</span><br></pre></table></figure> <p>以下方法获取基础范围的会话标识符：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>String <span class="title function_">getConversationId</span><span class=params>()</span>;</span><br></pre></table></figure> <p>每个范围的标识符都不相同。对于会话范围的实现，此标识符可以是会话标识符。</p> <h5 id=使用自定义范围><a class=headerlink href=#使用自定义范围 title=使用自定义范围></a>使用自定义范围</h5><p>以下方法是在 Spring 容器中注册新的<code>Scope</code>的中心方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> <span class="title function_">registerScope</span><span class=params>(String scopeName, Scope scope)</span>;</span><br></pre></table></figure> <p>此方法在<code>ConfigurableBeanFactory</code>接口上声明，该接口可通过 Spring 附带的大多数具体<code>ApplicationContext</code>实现上的<code>BeanFactory</code>属性使用。</p> <p><code>registerScope(..)</code>方法的第一个参数是与范围关联的唯一名称。 Spring 容器本身中的此类名称示例为<code>singleton</code>和<code>prototype</code>。 <code>registerScope(..)</code>方法的第二个参数是您希望注册和使用的自定义<code>Scope</code>实现的实际实例。</p> <p>假设您编写了自定义<code>Scope</code>实现，然后注册它，如下面的示例所示。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>Scope</span> <span class=variable>threadScope</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SimpleThreadScope</span>();</span><br><span class=line>beanFactory.registerScope(<span class=string>"thread"</span>, threadScope);</span><br></pre></table></figure> <p>然后，您可以创建符合自定义<code>Scope</code>范围规则的 bean 定义，如下所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"..."</span> <span class=attr>class</span>=<span class=string>"..."</span> <span class=attr>scope</span>=<span class=string>"thread"</span>></span></span><br></pre></table></figure> <p>使用自定义<code>Scope</code>实现，您不仅可以通过程序注册该范围。您还可以通过使用<code>CustomScopeConfigurer</code>类以声明方式进行<code>Scope</code>注册，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:aop</span>=<span class=string>"http://www.springframework.org/schema/aop"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/aop</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/aop/spring-aop.xsd"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.config.CustomScopeConfigurer"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"scopes"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>map</span>></span></span><br><span class=line>                <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"thread"</span>></span></span><br><span class=line>                    <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.context.support.SimpleThreadScope"</span>/></span></span><br><span class=line>                <span class=tag>&LT/<span class=name>entry</span>></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>map</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"thing2"</span> <span class=attr>class</span>=<span class=string>"x.y.Thing2"</span> <span class=attr>scope</span>=<span class=string>"thread"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"Rick"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>aop:scoped-proxy</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"thing1"</span> <span class=attr>class</span>=<span class=string>"x.y.Thing1"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"thing2"</span> <span class=attr>ref</span>=<span class=string>"thing2"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h3 id=2-1-6、自定义Bean性质><a class=headerlink href=#2-1-6、自定义Bean性质 title=2.1.6、自定义Bean性质></a>2.1.6、自定义Bean性质</h3><h4 id=2-1-6-1、生命周期回调><a class=headerlink href=#2-1-6-1、生命周期回调 title=2.1.6.1、生命周期回调></a>2.1.6.1、生命周期回调</h4><p>为了与容器对bean生命周期的管理进行交互，可以实现Spring<code>InitializingBean</code>和<code>DisposableBean</code>接口。容器对前者调用<code>afterPropertiesSet()</code>，对后者调用<code>destroy()</code>，使 Bean 在初始化和销毁时执行某些操作。</p> <p>除了初始化和销毁回调外，Spring托管的对象还可以实现<code>Lifecycle</code>接口，以便这些对象可以在容器自身生命周期的驱动下参与启动和关闭过程。</p> <h5 id=初始化回调><a class=headerlink href=#初始化回调 title=初始化回调></a>初始化回调</h5><p><code>org.springframework.beans.factory.InitializingBean</code>接口允许容器在容器上设置了所有必需的属性后，bean 可以执行初始化工作。 <code>InitializingBean</code>接口指定一个方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> <span class="title function_">afterPropertiesSet</span><span class=params>()</span> <span class=keyword>throws</span> Exception;</span><br></pre></table></figure> <p>我们建议您不要使用<code>InitializingBean</code>接口，因为它不必要地将代码耦合到Spring。另外，我们建议使用<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-postconstruct-and-predestroy-annotations rel=noopener target=_blank><code>@PostConstruct</code></a>注释或指定POJO初始化方法。对于基于XML的配置元数据，可以使用<code>init-method</code>属性指定具有无效无参数签名的方法的名称。通过Java配置，您可以使用的<code>initMethod</code>属性 <code>@Bean</code>。考虑以下示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleInitBean"</span> <span class=attr>class</span>=<span class=string>"examples.ExampleBean"</span> <span class=attr>init-method</span>=<span class=string>"init"</span>/></span></span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleBean</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">init</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// do some initialization work</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>前面的示例与下面的示例（包含两个清单）几乎具有完全相同的效果：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleInitBean"</span> <span class=attr>class</span>=<span class=string>"examples.AnotherExampleBean"</span>/></span></span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AnotherExampleBean</span> <span class=keyword>implements</span> <span class="title class_">InitializingBean</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">afterPropertiesSet</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// do some initialization work</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>但是，前面两个示例中的第一个示例并未将代码耦合到 Spring。</p> <h5 id=销毁回调><a class=headerlink href=#销毁回调 title=销毁回调></a>销毁回调</h5><p>实现<code>org.springframework.beans.factory.DisposableBean</code>接口后，当包含 bean 的容器被销毁时，bean 可以获取回调。 <code>DisposableBean</code>接口指定一个方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> <span class="title function_">destroy</span><span class=params>()</span> <span class=keyword>throws</span> Exception;</span><br></pre></table></figure> <p>我们建议您不要使用<code>DisposableBean</code>回调接口，因为它不必要地将代码耦合到 Spring。另外，我们建议使用<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-postconstruct-and-predestroy-annotations rel=noopener target=_blank>@PreDestroy</a>注解或指定 bean 定义支持的通用方法。使用基于 XML 的配置元数据时，可以在<code>&LTbean/></code>上使用<code>destroy-method</code>属性。通过 Java 配置，可以使用<code>@Bean</code>的<code>destroy-method</code>属性。考虑以下定义：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleInitBean"</span> <span class=attr>class</span>=<span class=string>"examples.ExampleBean"</span> <span class=attr>destroy-method</span>=<span class=string>"cleanup"</span>/></span></span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleBean</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">cleanup</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// do some destruction work (like releasing pooled connections)</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>前面的定义与下面的定义几乎具有完全相同的效果：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"exampleInitBean"</span> <span class=attr>class</span>=<span class=string>"examples.AnotherExampleBean"</span>/></span></span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AnotherExampleBean</span> <span class=keyword>implements</span> <span class="title class_">DisposableBean</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">destroy</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// do some destruction work (like releasing pooled connections)</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>但是，前面两个定义中的第一个没有将代码耦合到 Spring。</p> <h5 id=默认初始化和销毁方法><a class=headerlink href=#默认初始化和销毁方法 title=默认初始化和销毁方法></a>默认初始化和销毁方法</h5><p>您可以将Spring容器配置为“寻找”命名的初始化，并销毁每个bean上的回调方法名称。</p> <p>假设您的初始化回调方法命名为<code>init()</code>，而 destroy 回调方法命名为<code>destroy()</code>。然后，您的类类似于以下示例中的类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DefaultBlogService</span> <span class=keyword>implements</span> <span class="title class_">BlogService</span> {</span><br><span class=line>    <span class=keyword>private</span> BlogDao blogDao;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setBlogDao</span><span class=params>(BlogDao blogDao)</span> {</span><br><span class=line>        <span class=built_in>this</span>.blogDao = blogDao;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// this is (unsurprisingly) the initialization callback method</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">init</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>this</span>.blogDao == <span class=literal>null</span>) {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalStateException</span>(<span class=string>"The [blogDao] property must be set."</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>然后，您可以在类似于以下内容的Bean中使用该类：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>default-init-method</span>=<span class=string>"init"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"blogService"</span> <span class=attr>class</span>=<span class=string>"com.something.DefaultBlogService"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"blogDao"</span> <span class=attr>ref</span>=<span class=string>"blogDao"</span> /></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>顶层<code>&LTbeans/></code>元素属性上<code>default-init-method</code>属性的存在会导致 Spring IoC 容器将 Bean 类上称为<code>init</code>的方法识别为初始化方法回调。创建和组装 bean 时，如果 bean 类具有此类方法，则会在适当的时间调用它。</p> <p>您可以通过使用顶级<code>&LTbeans/></code>元素上的<code>default-destroy-method</code>属性类似地(在 XML 中)配置 destroy 方法回调。</p> <p>Spring 容器保证在为 bean 提供所有依赖项后立即调用配置的初始化回调。因此，在原始 bean 引用上调用了初始化回调，这意味着 AOP 拦截器等尚未应用于 bean。首先完全创建目标 bean，然后应用带有其拦截器链的 AOP 代理(例如)。如果目标 Bean 和代理分别定义，则您的代码甚至可以绕过代理与原始目标 Bean 进行交互。因此，将拦截器应用于<code>init</code>方法将是不一致的，因为这样做会将目标 Bean 的生命周期耦合到其代理或拦截器，并在代码直接与原始目标 Bean 交互时留下奇怪的语义。</p> <h5 id=组合生命周期机制><a class=headerlink href=#组合生命周期机制 title=组合生命周期机制></a>组合生命周期机制</h5><p>从Spring 2.5开始，您可以使用三个选项来控制Bean生命周期行为：</p> <ul><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean rel=noopener target=_blank><code>InitializingBean</code></a>和 <a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-disposablebean rel=noopener target=_blank><code>DisposableBean</code></a>回调接口。<li>自定义 init()<code>和</code>destroy()`方法<li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-postconstruct-and-predestroy-annotations rel=noopener target=_blank><code>@PostConstruct</code>和<code>@PreDestroy</code> 注解</a>。您可以结合使用这些机制来控制给定的bean。</ul> <p>为同一个bean配置的具有不同初始化方法的多种生命周期机制如下：</p> <ol><li>用<code>@PostConstruct</code>注解 的方法<li><code>InitializingBean</code>回调接口定义的<code>afterPropertiesSet()</code><li>自定义配置的<code>init()</code>方法</ol> <p>销毁方法的调用顺序相同：</p> <ol><li>用<code>@PreDestroy</code>注解 的方法<li><code>DisposableBean</code>回调接口定义的<code>destroy()</code><li>自定义配置的<code>destroy()</code>方法</ol> <h5 id=启动和关闭回调><a class=headerlink href=#启动和关闭回调 title=启动和关闭回调></a>启动和关闭回调</h5><p><code>Lifecycle</code>接口为具有自己的生命周期要求(例如启动和停止某些后台进程)的任何对象定义基本方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Lifecycle</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">start</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">stop</span><span class=params>()</span>;</span><br><span class=line>    <span class=type>boolean</span> <span class="title function_">isRunning</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>任何Spring管理的对象都可以实现该<code>Lifecycle</code>接口。然后，当 <code>ApplicationContext</code>自身接收到启动和停止信号时（例如，对于运行时的停止/重新启动场景），它将把这些调用级联到在该上下文中定义的所有<code>Lifecycle</code>实现。它通过委托<code>LifecycleProcessor</code>来完成此任务，如以下清单所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">LifecycleProcessor</span> <span class=keyword>extends</span> <span class="title class_">Lifecycle</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">onRefresh</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">onClose</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>请注意，<code>LifecycleProcessor</code>本身是<code>Lifecycle</code> 接口的扩展。它还添加了两种其他方法来对刷新和关闭的上下文做出反应。</p> <p>启动和关闭调用的顺序可能很重要。如果任何两个对象之间存在“依赖”关系，则依赖方在其依赖之后开始，而在依赖之前停止。但是，有时直接依赖项是未知的。您可能只知道某种类型的对象应该先于另一种类型的对象开始。在这些情况下，<code>SmartLifecycle</code>接口定义了另一个选项，即在超级接口<code>Phased</code>上定义的<code>getPhase()</code>方法。以下清单显示了<code>Phased</code>接口的定义：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Phased</span> {</span><br><span class=line>    <span class=type>int</span> <span class="title function_">getPhase</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>以下清单显示了<code>SmartLifecycle</code>接口的定义：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">SmartLifecycle</span> <span class=keyword>extends</span> <span class="title class_">Lifecycle</span>, Phased {</span><br><span class=line>    <span class=type>boolean</span> <span class="title function_">isAutoStartup</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">stop</span><span class=params>(Runnable callback)</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>启动时，相位最低的对象首先启动。停止时，遵循相反的 Sequences。因此，实现<code>SmartLifecycle</code>且其<code>getPhase()</code>方法返回<code>Integer.MIN_VALUE</code>的对象将是第一个启动且最后一个停止的对象。在频谱的另一端，相位值<code>Integer.MAX_VALUE</code>表示该对象应最后启动并首先停止(可能是因为它取决于正在运行的其他进程)。考虑相位值时，重要的是要知道，任何未实现<code>SmartLifecycle</code>的“正常” <code>Lifecycle</code>对象的默认相位是<code>0</code>。因此，任何负相位值都表明对象应在这些标准组件之前开始(并在它们之后停止)。对于任何正相位值，反之亦然。</p> <h5 id=非Web应用中正常关闭Spring-IOC容器><a title="非Web应用中正常关闭Spring IOC容器" class=headerlink href=#非Web应用中正常关闭Spring-IOC容器></a>非Web应用中正常关闭Spring IOC容器</h5><p>要注册关闭钩子，请调用在<code>ConfigurableApplicationContext</code>接口上声明的<code>registerShutdownHook()</code>方法，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.context.ConfigurableApplicationContext;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>class</span> <span class="title class_">Boot</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(<span class=keyword>final</span> String[] args)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>ConfigurableApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class=string>"beans.xml"</span>);</span><br><span class=line>        <span class=comment>// add a shutdown hook for the above context...</span></span><br><span class=line>        ctx.registerShutdownHook();</span><br><span class=line>        <span class=comment>// app runs here...</span></span><br><span class=line>        <span class=comment>// main method exits, hook is called prior to the app shutting down...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=2-1-6-2、ApplicationContextAware和BeanNameAware><a class=headerlink href=#2-1-6-2、ApplicationContextAware和BeanNameAware title=2.1.6.2、ApplicationContextAware和BeanNameAware></a>2.1.6.2、ApplicationContextAware和BeanNameAware</h4><p>当<code>ApplicationContext</code>创建实现<code>org.springframework.context.ApplicationContextAware</code>接口的对象实例时，该实例将获得对该<code>ApplicationContext</code>的引用。以下清单显示了<code>ApplicationContextAware</code>接口的定义：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">ApplicationContextAware</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">setApplicationContext</span><span class=params>(ApplicationContext applicationContext)</span> <span class=keyword>throws</span> BeansException;</span><br><span class=line>}</span><br></pre></table></figure> <p>因此，bean 可以通过<code>ApplicationContext</code>接口或通过将引用转换为该接口的已知子类(例如<code>ConfigurableApplicationContext</code>，以公开其他功能)来以编程方式操纵创建它们的<code>ApplicationContext</code>。一种用途是通过编程方式检索其他 bean。有时，此功能很有用。但是，通常应避免使用它，因为它将代码耦合到 Spring，并且不遵循控制反转样式，在该样式中，将协作者作为属性提供给 bean。 <code>ApplicationContext</code>的其他方法提供对文件资源的访问，发布应用程序事件以及对<code>MessageSource</code>的访问。这些附加功能在<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#context-introduction rel=noopener target=_blank>ApplicationContext 的其他功能</a>中描述。</p> <p>当<code>ApplicationContext</code>创建一个实现该 <code>org.springframework.beans.factory.BeanNameAware</code>接口的类时，该类将获得对在其关联的对象定义中定义的名称的引用。以下清单显示了BeanNameAware接口的定义：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">BeanNameAware</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">setBeanName</span><span class=params>(String name)</span> <span class=keyword>throws</span> BeansException;</span><br><span class=line>}</span><br></pre></table></figure> <p>在填充常规 bean 属性之后但在初始化回调(例如<code>InitializingBean</code>，<code>afterPropertiesSet</code>或自定义 init-method)之前调用该回调。</p> <h4 id=2-1-6-3、其它Aware接口><a class=headerlink href=#2-1-6-3、其它Aware接口 title=2.1.6.3、其它Aware接口></a>2.1.6.3、其它Aware接口</h4><p>除了<code>ApplicationContextAware</code>和<code>BeanNameAware</code>（前面<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware rel=noopener target=_blank>已经</a>讨论<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware rel=noopener target=_blank>过</a>），Spring还提供了其它各种各样的<code>Aware</code>回调接口，这些接口使bean可以向容器指示它们需要某种基础结构依赖性。通常，名称表示依赖项类型。下表总结了最重要的<code>Aware</code>接口：</p> <table><thead><tr><th align=left>名称<th align=left>注入依赖<th align=left>在…中解释<tbody><tr><td align=left><code>ApplicationContextAware</code><td align=left>宣告<code>ApplicationContext</code>。<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware rel=noopener target=_blank><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a><tr><td align=left><code>ApplicationEventPublisherAware</code><td align=left>附件的事件发布者<code>ApplicationContext</code>。<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-introduction rel=noopener target=_blank>的其他功能 <code>ApplicationContext</code></a><tr><td align=left><code>BeanClassLoaderAware</code><td align=left>类加载器，用于加载Bean类。<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-class rel=noopener target=_blank>Instantiating Beans</a><tr><td align=left><code>BeanFactoryAware</code><td align=left>宣告<code>BeanFactory</code>。<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware rel=noopener target=_blank><code>ApplicationContextAware</code> 和 <code>BeanNameAware</code></a><tr><td align=left><code>BeanNameAware</code><td align=left>声明bean的名称。<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware rel=noopener target=_blank><code>ApplicationContextAware</code> 和 <code>BeanNameAware</code></a><tr><td align=left><code>LoadTimeWeaverAware</code><td align=left>定义的编织器，用于在加载时处理类定义。<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-aj-ltw rel=noopener target=_blank>在Spring Framework中使用AspectJ进行加载时编织</a><tr><td align=left><code>MessageSourceAware</code><td align=left>Configured strategy for resolving messages (with support for parametrization and internationalization).<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-introduction rel=noopener target=_blank>的其他功能 <code>ApplicationContext</code></a><tr><td align=left><code>NotificationPublisherAware</code><td align=left>Spring JMX通知发布者。<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#jmx-notifications rel=noopener target=_blank>通知事项</a><tr><td align=left><code>ResourceLoaderAware</code><td align=left>配置的加载程序，用于对资源的低级访问。<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources rel=noopener target=_blank>资源资源</a><tr><td align=left><code>ServletConfigAware</code><td align=left>当前<code>ServletConfig</code>容器在其中运行。仅在可感知网络的Spring中有效 <code>ApplicationContext</code>。<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc rel=noopener target=_blank>春季MVC</a><tr><td align=left><code>ServletContextAware</code><td align=left>当前<code>ServletContext</code>容器在其中运行。仅在可感知网络的Spring中有效 <code>ApplicationContext</code>。<td align=left><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc rel=noopener target=_blank>春季MVC</a></table> <p>再次注意，使用这些接口会将您的代码与 Spring API 绑定在一起，并且不遵循“控制反转”样式。因此，我们建议将它们用于需要以编程方式访问容器的基础结构 Bean。</p> <h3 id=2-1-7、Bean定义继承><a class=headerlink href=#2-1-7、Bean定义继承 title=2.1.7、Bean定义继承></a>2.1.7、Bean定义继承</h3><p>Bean定义可以包含许多配置信息，包括构造函数参数，属性值和特定于容器的信息，例如初始化方法，静态工厂方法名称等。子bean定义从父定义继承配置数据。子定义可以覆盖某些值或根据需要添加其他值。使用父bean和子bean定义可以节省很多输入。实际上，这是一种模板形式。</p> <p>如果您以编程方式使用<code>ApplicationContext</code>接口，则子 Bean 定义由<code>ChildBeanDefinition</code>类表示。大多数用户不在此级别上与他们合作。相反，它们在<code>ClassPathXmlApplicationContext</code>之类的类中声明性地配置 bean 定义。使用基于 XML 的配置元数据时，可以通过使用<code>parent</code>属性(将父 bean 指定为该属性的值)来指示子 bean 定义。以下示例显示了如何执行此操作：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"inheritedTestBean"</span> <span class=attr>abstract</span>=<span class=string>"true"</span></span></span><br><span class=line><span class=tag>        <span class=attr>class</span>=<span class=string>"org.springframework.beans.TestBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"parent"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"age"</span> <span class=attr>value</span>=<span class=string>"1"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"inheritsWithDifferentClass"</span></span></span><br><span class=line><span class=tag>        <span class=attr>class</span>=<span class=string>"org.springframework.beans.DerivedTestBean"</span></span></span><br><span class=line><span class=tag>        <span class=attr>parent</span>=<span class=string>"inheritedTestBean"</span> <span class=attr>init-method</span>=<span class=string>"initialize"</span>></span>  </span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"override"</span>/></span></span><br><span class=line>    <span class=comment>&LT!-- the age property value of 1 will be inherited from parent --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>如果未指定子bean定义，则使用父定义中的bean类，但也可以覆盖它。在后一种情况下，子bean类必须与父类兼容（也就是说，它必须接受父类的属性值）。</p> <p>子 bean 定义从父对象继承范围，构造函数参数值，属性值和方法替代，并可以选择添加新值。您指定的任何范围，初始化方法，destroy 方法或<code>static</code>工厂方法设置都会覆盖相应的父设置。</p> <p>其余设置始终从子定义中获取：依赖项，自动装配模式，依赖项检查，单例和惰性初始化。</p> <p>前面的示例通过使用<code>abstract</code>属性将父 bean 定义显式标记为抽象。如果父定义未指定类，则需要将父 bean 定义显式标记为<code>abstract</code>，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"inheritedTestBeanWithoutClass"</span> <span class=attr>abstract</span>=<span class=string>"true"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"parent"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"age"</span> <span class=attr>value</span>=<span class=string>"1"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"inheritsWithClass"</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.DerivedTestBean"</span></span></span><br><span class=line><span class=tag>        <span class=attr>parent</span>=<span class=string>"inheritedTestBeanWithoutClass"</span> <span class=attr>init-method</span>=<span class=string>"initialize"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"override"</span>/></span></span><br><span class=line>    <span class=comment>&LT!-- age will inherit the value of 1 from the parent bean definition--></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>父 bean 不能单独实例化，因为它是不完整的，并且还被明确标记为<code>abstract</code>。当定义为<code>abstract</code>时，它只能用作纯模板 bean 定义，用作子定义的父定义。尝试单独使用此类<code>abstract</code>父 Bean(将其称为另一个 bean 的 ref 属性)或使用父 Bean ID 进行显式<code>getBean()</code>调用会返回错误。同样，容器的内部<code>preInstantiateSingletons()</code>方法将忽略定义为抽象的 bean 定义。</p> <blockquote><p><code>ApplicationContext</code>默认情况下预先实例化所有单例。因此，重要的是(至少对于单例 bean)，如果您有一个(父)bean 定义仅打算用作模板，并且此定义指定了一个类，则必须确保设置* abstract <em>属性为</em> true *，否则应用程序上下文将实际(尝试)预先实例化<code>abstract</code> bean。</blockquote> <h3 id=2-1-8、容器延伸><a class=headerlink href=#2-1-8、容器延伸 title=2.1.8、容器延伸></a>2.1.8、容器延伸</h3><h4 id=2-1-8-1、使用BeanPostProcessor定义Bean><a class=headerlink href=#2-1-8-1、使用BeanPostProcessor定义Bean title=2.1.8.1、使用BeanPostProcessor定义Bean></a>2.1.8.1、使用BeanPostProcessor定义Bean</h4><p><code>BeanPostProcessor</code>接口定义了回调方法，您可以实现这些回调方法，以提供自己的(或覆盖容器的默认值)实例化逻辑，依赖项解析逻辑等。如果您想在 Spring 容器完成实例化，配置和初始化 bean 之后实现一些自定义逻辑，则可以插入一个或多个<code>BeanPostProcessor</code>实现。</p> <p>您可以配置多个<code>BeanPostProcessor</code>实例，并且可以通过设置<code>order</code>属性来控制这些<code>BeanPostProcessor</code>实例的执行 Sequences。仅当<code>BeanPostProcessor</code>实现<code>Ordered</code>接口时，才可以设置此属性。如果您编写自己的<code>BeanPostProcessor</code>，则也应该考虑实现<code>Ordered</code>接口。有关更多详细信息，请参见<a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html rel=noopener target=_blank>BeanPostProcessor</a>和<a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/Ordered.html rel=noopener target=_blank>Ordered</a>接口的 javadoc。另请参见<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-programmatically-registering-beanpostprocessors rel=noopener target=_blank>BeanPostProcessor 实例的编程注册</a>上的 注解。</p> <p><code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口恰好由两个回调方法组成。当此类被注册为容器的后处理器时，对于容器创建的每个 bean 实例，后处理器都会在容器初始化方法(例如<code>InitializingBean.afterPropertiesSet()</code>，任何已声明的<code>init</code>之后)之前从容器获取回调。方法)，并在任何 bean 初始化回调之后调用。后处理器可以对 bean 实例执行任何操作，包括完全忽略回调。 Bean 后处理器通常检查回调接口，或者可以用代理包装 Bean。一些 Spring AOP 基础结构类被实现为 bean 后处理器，以提供代理包装逻辑。</p> <p><code>ApplicationContext</code>自动检测实现<code>BeanPostProcessor</code>接口的配置元数据中定义的所有 bean。 <code>ApplicationContext</code>将这些 bean 注册为后处理器，以便以后在 bean 创建时可以调用它们。 Bean 后处理器可以以与其他任何 Bean 相同的方式部署在容器中。</p> <p>请注意，在配置类上使用<code>@Bean</code>工厂方法声明<code>BeanPostProcessor</code>时，工厂方法的返回类型应该是实现类本身或至少是<code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口，从而清楚地表明该 bean 的后处理器性质。否则，<code>ApplicationContext</code>无法在完全创建之前按类型自动检测它。由于<code>BeanPostProcessor</code>需要提早实例化以便应用于上下文中其他 bean 的初始化，因此这种提早类型检测至关重要。</p> <blockquote><ul><li>以编程方式注册<code>BeanPostProcessor</code>实例</ul><p>虽然推荐的<code>BeanPostProcessor</code>注册方法是通过 <code>ApplicationContext</code>自动检测（如前所述），但是您可以<code>ConfigurableBeanFactory</code>使用<code>addBeanPostProcessor</code> 方法通过编程方式将它们注册。当您需要在注册之前评估条件逻辑，甚至需要跨层次结构的上下文复制Bean后处理器时，这将非常有用。但是请注意，以<code>BeanPostProcessor</code>编程方式添加的实例不遵守该<code>Ordered</code>接口。在这里，注册的顺序决定了执行的顺序。还要注意，以<code>BeanPostProcessor</code>编程方式注册的实例总是在通过自动检测注册的实例之前进行处理，而不考虑任何明确的顺序。<ul><li><p><code>BeanPostProcessor</code> 实例和AOP自动代理</p> <p>如果您<code>BeanPostProcessor</code>使用自动装配或<code>@Resource</code>（可能会退回到自动装配）将bean连接到您的 bean ，Spring在搜索类型匹配的依赖项候选对象时可能会访问意外的bean，因此使它们不符合自动代理或其他类型的bean的要求。处理。例如，如果您有一个依赖项，其注释<code>@Resource</code>的字段或设置器名称不直接与bean的声明名称相对应，并且不使用name属性，那么Spring将访问其他bean以按类型匹配它们。</p></ul></blockquote> <h5 id=示例：Hello-world，BeanPostProcessor><a title="示例：Hello world，BeanPostProcessor" class=headerlink href=#示例：Hello-world，BeanPostProcessor></a>示例：Hello world，BeanPostProcessor</h5><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> scripting;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">InstantiationTracingBeanPostProcessor</span> <span class=keyword>implements</span> <span class="title class_">BeanPostProcessor</span> {</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class=params>(Object bean, String beanName)</span> {</span><br><span class=line>        <span class=keyword>return</span> bean;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class=params>(Object bean, String beanName)</span> {</span><br><span class=line>        System.out.println(<span class=string>"Bean '"</span> + beanName + <span class=string>"' created : "</span> + bean.toString());</span><br><span class=line>        <span class=keyword>return</span> bean;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>以下<code>beans</code>元素使用<code>InstantiationTracingBeanPostProcessor</code>：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:lang</span>=<span class=string>"http://www.springframework.org/schema/lang"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/lang</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/lang/spring-lang.xsd"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>lang:groovy</span> <span class=attr>id</span>=<span class=string>"messenger"</span> <span class=attr>script-source</span>=<span class=string>"classpath:org/springframework/scripting/groovy/Messenger.groovy"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>lang:property</span> <span class=attr>name</span>=<span class=string>"message"</span> <span class=attr>value</span>=<span class=string>"Fiona Apple Is Just So Dreamy."</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>lang:groovy</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"scripting.InstantiationTracingBeanPostProcessor"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>注意<code>InstantiationTracingBeanPostProcessor</code>是如何定义的。它甚至没有名称，并且因为它是 Bean，所以可以像注入其他任何 Bean 一样对其进行依赖注入。</p> <p>以下Java应用程序运行上述代码和配置：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.context.ApplicationContext;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class=line><span class=keyword>import</span> org.springframework.scripting.Messenger;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>class</span> <span class="title class_">Boot</span> {</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(<span class=keyword>final</span> String[] args)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>ApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class=string>"scripting/beans.xml"</span>);</span><br><span class=line>        <span class=type>Messenger</span> <span class=variable>messenger</span> <span class=operator>=</span> ctx.getBean(<span class=string>"messenger"</span>, Messenger.class);</span><br><span class=line>        System.out.println(messenger);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure> <p>前面的应用程序的输出类似于以下内容：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>Bean 'messenger' created : org.springframework.scripting.groovy.GroovyMessenger@272961</span><br><span class=line>org.springframework.scripting.groovy.GroovyMessenger@272961</span><br></pre></table></figure> <h5 id=示例：-RequiredAnnotationBeanPostProcessor><a title="示例： RequiredAnnotationBeanPostProcessor" class=headerlink href=#示例：-RequiredAnnotationBeanPostProcessor></a>示例： RequiredAnnotationBeanPostProcessor</h5><p>将回调接口或注释与自定义<code>BeanPostProcessor</code>实现结合使用 是扩展Spring IoC容器的常用方法。一个例子是Spring的<code>RequiredAnnotationBeanPostProcessor</code> -一个<code>BeanPostProcessor</code>Spring发行版附带的 实现，它确保标记了（任意）批注的bean上的JavaBean属性实际上（配置为）依赖注入了一个值。</p> <h4 id=2-1-8-2、使用BeanFactoryPostProcessor自定义配置元数据><a class=headerlink href=#2-1-8-2、使用BeanFactoryPostProcessor自定义配置元数据 title=2.1.8.2、使用BeanFactoryPostProcessor自定义配置元数据></a>2.1.8.2、使用BeanFactoryPostProcessor自定义配置元数据</h4><h5 id=示例：类名替换-PropertySourcesPlaceholderConfigurer><a title="示例：类名替换 PropertySourcesPlaceholderConfigurer" class=headerlink href=#示例：类名替换-PropertySourcesPlaceholderConfigurer></a>示例：类名替换 PropertySourcesPlaceholderConfigurer</h5><p>考虑以下基于 XML 的配置元数据片段，其中定义了带有占位符值的<code>DataSource</code>：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.context.support.PropertySourcesPlaceholderConfigurer"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"locations"</span> <span class=attr>value</span>=<span class=string>"classpath:com/something/jdbc.properties"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"dataSource"</span> <span class=attr>destroy-method</span>=<span class=string>"close"</span> <span class=attr>class</span>=<span class=string>"org.apache.commons.dbcp.BasicDataSource"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"driverClassName"</span> <span class=attr>value</span>=<span class=string>"${jdbc.driverClassName}"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"url"</span> <span class=attr>value</span>=<span class=string>"${jdbc.url}"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"username"</span> <span class=attr>value</span>=<span class=string>"${jdbc.username}"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"password"</span> <span class=attr>value</span>=<span class=string>"${jdbc.password}"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>该示例显示了从外部<code>Properties</code>文件配置的属性。在运行时，将<code>PropertyPlaceholderConfigurer</code>应用于替换数据源的某些属性的元数据。将要替换的值指定为<code>${property-name}</code>形式的占位符，该形式遵循 Ant 和 log4j 和 JSP EL 样式。</p> <p>实际值来自标准Java<code>Properties</code>格式的另一个文件：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>jdbc.driverClassName = org.hsqldb.jdbcDriver</span><br><span class=line>jdbc.url = jdbc：hsqldb：hsql：// production：9002</span><br><span class=line>jdbc.username = sa</span><br><span class=line>jdbc.password =根</span><br></pre></table></figure> <p>因此，在运行时将<code>${jdbc.username}</code>字符串替换为值“ sa”，并且其他与属性文件中的键匹配的占位符值也是如此。 <code>PropertyPlaceholderConfigurer</code>检查 bean 定义的大多数属性和属性中的占位符。此外，您可以自定义占位符前缀和后缀。</p> <p>使用 Spring 2.5 中引入的<code>context</code>名称空间，您可以使用专用配置元素配置属性占位符。您可以在<code>location</code>属性中以逗号分隔列表的形式提供一个或多个位置，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>context:property-placeholder</span> <span class=attr>location</span>=<span class=string>"classpath:com/something/jdbc.properties"</span>/></span></span><br></pre></table></figure> <p><code>PropertyPlaceholderConfigurer</code>不仅在您指定的<code>Properties</code>文件中查找属性。默认情况下，如果无法在指定的属性文件中找到属性，则还会检查 Java <code>System</code>属性。您可以通过使用以下三个受支持的整数值之一设置配置程序的<code>systemPropertiesMode</code>属性来自定义此行为：</p> <ul><li><code>never</code>(0)：从不检查系统属性。<li><code>fallback</code>(1)：检查系统属性是否在指定的属性文件中不可解析。这是默认值。<li><code>override</code>(2)：在尝试指定的属性文件之前，请先检查系统属性。这使系统属性可以覆盖任何其他属性源。</ul> <h5 id=示例：-PropertyOverrideConfigurer><a title="示例： PropertyOverrideConfigurer" class=headerlink href=#示例：-PropertyOverrideConfigurer></a>示例： PropertyOverrideConfigurer</h5><p><code>PropertyOverrideConfigurer</code>是另一个 Bean 工厂后处理程序，类似于<code>PropertyPlaceholderConfigurer</code>，但是与后者不同，原始定义对于 Bean 属性可以具有默认值或完全没有值。如果覆盖的<code>Properties</code>文件没有某个 bean 属性的条目，则使用默认的上下文定义。</p> <p>bean定义不知道会被覆盖，因此从XML定义文件中不能立即看出正在使用覆盖配置器。如果有多个<code>PropertyOverrideConfigurer</code>实例为同一个bean属性定义了不同的值，则由于覆盖机制，最后一个实例将获胜。</p> <p>属性文件配置行采用以下格式：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>beanName.property =值</span><br></pre></table></figure> <p>下面的清单显示了格式的示例：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>dataSource.driverClassName = com.mysql.jdbc.Driver</span><br><span class=line>dataSource.url = jdbc：mysql：mydb</span><br></pre></table></figure> <p>此示例文件可与包含定义为<code>dataSource</code>具有<code>driver</code>和<code>url</code>属性的bean的容器定义一起使用 。</p> <p>使用<code>context</code>Spring 2.5中引入的名称空间，可以使用专用的配置元素配置属性覆盖，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>context:property-override</span> <span class=attr>location</span>=<span class=string>"classpath:override.properties"</span>/></span></span><br></pre></table></figure> <h4 id=2-1-8-3、使用FactoryBean自定义实例化><a class=headerlink href=#2-1-8-3、使用FactoryBean自定义实例化 title=2.1.8.3、使用FactoryBean自定义实例化></a>2.1.8.3、使用FactoryBean自定义实例化</h4><p>您可以为本身就是工厂的对象实现<code>org.springframework.beans.factory.FactoryBean</code>接口。</p> <p>该<code>FactoryBean</code>界面提供了三种方法：</p> <ul><li><code>Object getObject()</code>：返回此工厂创建的对象的实例。实例可以共享，具体取决于该工厂是否返回单例或原型。<li><code>boolean isSingleton()</code>：如果此<code>FactoryBean</code>返回单例，则返回<code>true</code>，否则返回<code>false</code>。<li><code>Class getObjectType()</code>：返回由<code>getObject()</code>方法或<code>null</code>返回的对象类型(如果事先未知)。</ul> <p><code>FactoryBean</code>概念和界面在 Spring Framework 中的许多地方都使用过。 Spring 本身附带了<code>FactoryBean</code>接口的 50 多种实现。</p> <p>当您需要向容器请求一个实际的<code>FactoryBean</code>实例本身而不是它生成的 bean 时，请在调用<code>ApplicationContext</code>的<code>getBean()</code>方法时在 bean 的<code>id</code>前面加上一个＆符号(<code>&</code>)。因此，对于给定的<code>id</code> <code>myBean</code>的<code>FactoryBean</code>，在容器上调用<code>getBean("myBean")</code>返回<code>FactoryBean</code>的乘积，而调用<code>getBean("&myBean")</code>则返回<code>FactoryBean</code>实例本身。</p> <h3 id=2-1-9、基于注释的容器配置><a class=headerlink href=#2-1-9、基于注释的容器配置 title=2.1.9、基于注释的容器配置></a>2.1.9、基于注释的容器配置</h3><p>基于注解的配置提供了 XML 设置的替代方法，该配置依赖字节码元数据来连接组件，而不是尖括号声明。通过使用相关类，方法或字段声明上的 注解，开发人员无需使用 XML 来描述 bean 的连接，而是将配置移入组件类本身。</p> <h4 id=2-1-9-1、-Required><a class=headerlink href=#2-1-9-1、-Required title=2.1.9.1、@Required></a>2.1.9.1、@Required</h4><p>该注解适用于bean属性setter方法，如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=meta>@Required</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <blockquote><p><code>@Required</code>从Spring Framework 5.1开始，正式弃用了该批注，以支持对必需的设置（或<code>InitializingBean.afterPropertiesSet()</code>Bean属性setter方法的自定义实现）使用构造函数注入 。</blockquote> <h4 id=2-1-9-2、使用-Autowired><a class=headerlink href=#2-1-9-2、使用-Autowired title=2.1.9.2、使用@Autowired></a>2.1.9.2、使用@Autowired</h4><p>您可以将<code>@Autowired</code>注释应用于构造函数，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MovieRecommender</span><span class=params>(CustomerPreferenceDao customerPreferenceDao)</span> {</span><br><span class=line>        <span class=built_in>this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <blockquote><p>从 Spring Framework 4.3 开始，如果目标 bean 仅定义一个构造函数作为开始，则不再需要在此类构造函数上使用<code>@Autowired</code>注解。但是，如果有几个构造函数可用，则必须至少注解一个，以告诉容器使用哪个构造函数。</blockquote> <p>您还可以将<code>@Autowired</code>注释应用于<em>传统的</em>setter方法，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>您还可以将注释应用于具有任意名称和多个参数的方法，如下示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieCatalog movieCatalog;</span><br><span class=line>    <span class=keyword>private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">prepare</span><span class=params>(MovieCatalog movieCatalog,</span></span><br><span class=line><span class=params>            CustomerPreferenceDao customerPreferenceDao)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieCatalog = movieCatalog;</span><br><span class=line>        <span class=built_in>this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>您也可以将<code>@Autowired</code>应用于字段，甚至将其与构造函数混合使用，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> MovieCatalog movieCatalog;</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MovieRecommender</span><span class=params>(CustomerPreferenceDao customerPreferenceDao)</span> {</span><br><span class=line>        <span class=built_in>this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <h4 id=2-1-9-3、使用-Primary><a class=headerlink href=#2-1-9-3、使用-Primary title=2.1.9.3、使用@Primary></a>2.1.9.3、使用@Primary</h4><p><code>@Primary</code>表示当多个 bean 可以自动连接到单值依赖项的候选对象时，应优先考虑特定的 bean。如果候选中恰好存在一个主 bean，则它将成为自动装配的值。</p> <p>考虑以下将<code>firstMovieCatalog</code>定义为主<code>MovieCatalog</code>的配置：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieConfiguration</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=meta>@Primary</span></span><br><span class=line>    <span class=keyword>public</span> MovieCatalog <span class="title function_">firstMovieCatalog</span><span class=params>()</span> { ... }</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> MovieCatalog <span class="title function_">secondMovieCatalog</span><span class=params>()</span> { ... }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>使用前面的配置，下面的<code>MovieRecommender</code>与<code>firstMovieCatalog</code>自动连接：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> MovieCatalog movieCatalog;</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>相应的bean定义如下：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:context</span>=<span class=string>"http://www.springframework.org/schema/context"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/context</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/context/spring-context.xsd"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>context:annotation-config</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"example.SimpleMovieCatalog"</span> <span class=attr>primary</span>=<span class=string>"true"</span>></span></span><br><span class=line>        <span class=comment>&LT!-- inject any dependencies required by this bean --></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"example.SimpleMovieCatalog"</span>></span></span><br><span class=line>        <span class=comment>&LT!-- inject any dependencies required by this bean --></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"movieRecommender"</span> <span class=attr>class</span>=<span class=string>"example.MovieRecommender"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h4 id=2-1-9-4、使用限定符><a class=headerlink href=#2-1-9-4、使用限定符 title=2.1.9.4、使用限定符></a>2.1.9.4、使用限定符</h4><p>当可以确定一个主要候选对象时，<code>@Primary</code>是在几种情况下按类型使用自动装配的有效方法。当您需要对选择过程进行更多控制时，可以使用 Spring 的<code>@Qualifier</code>注解。您可以将限定符值与特定的参数相关联，从而缩小类型匹配的范围，以便为每个参数选择特定的 bean。在最简单的情况下，这可以是简单的描述性值，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=meta>@Qualifier("main")</span></span><br><span class=line>    <span class=keyword>private</span> MovieCatalog movieCatalog;</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>您还可以在各个构造函数参数或方法参数上指定<code>@Qualifier</code>注解，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieCatalog movieCatalog;</span><br><span class=line>    <span class=keyword>private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">prepare</span><span class=params>(<span class=meta>@Qualifier("main")</span> MovieCatalog movieCatalog,</span></span><br><span class=line><span class=params>            CustomerPreferenceDao customerPreferenceDao)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieCatalog = movieCatalog;</span><br><span class=line>        <span class=built_in>this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>以下示例显示了相应的bean定义。</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:context</span>=<span class=string>"http://www.springframework.org/schema/context"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/context</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/context/spring-context.xsd"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>context:annotation-config</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"example.SimpleMovieCatalog"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>qualifier</span> <span class=attr>value</span>=<span class=string>"main"</span>/></span> </span><br><span class=line>        <span class=comment>&LT!-- inject any dependencies required by this bean --></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"example.SimpleMovieCatalog"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>qualifier</span> <span class=attr>value</span>=<span class=string>"action"</span>/></span> </span><br><span class=line>        <span class=comment>&LT!-- inject any dependencies required by this bean --></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"movieRecommender"</span> <span class=attr>class</span>=<span class=string>"example.MovieRecommender"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <ol><li>具有<code>main</code>限定符值的Bean与限定有相同值的构造函数参数连接。<li>具有<code>action</code>限定符值的Bean与限定有相同值的构造函数参数连接。</ol> <h4 id=2-1-9-5、将泛型用作自动装配限定符><a class=headerlink href=#2-1-9-5、将泛型用作自动装配限定符 title=2.1.9.5、将泛型用作自动装配限定符></a>2.1.9.5、将泛型用作自动装配限定符</h4><p>除了<code>@Qualifier</code>注释之外，您还可以将Java泛型类型用作资格的隐式形式。例如，假设您具有以下配置：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyConfiguration</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> StringStore <span class="title function_">stringStore</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">StringStore</span>();</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> IntegerStore <span class="title function_">integerStore</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">IntegerStore</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>假设前面的 bean 实现了通用接口(即<code>Store&LTString></code>和<code>Store&LTInteger></code>)，则可以<code>@Autowire</code> <code>Store</code>接口，并且通用接口用作限定符，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Autowired</span></span><br><span class=line><span class=keyword>private</span> Store&LTString> s1; <span class=comment>// &LTString> qualifier, injects the stringStore bean</span></span><br><span class=line><span class=meta>@Autowired</span></span><br><span class=line><span class=keyword>private</span> Store&LTInteger> s2; <span class=comment>// &LTInteger> qualifier, injects the integerStore bean</span></span><br></pre></table></figure> <p>当自动装配列表，<code>Map</code>实例和数组时，通用限定符也适用。下面的示例自动连接泛型<code>List</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>// Inject all Store beans as long as they have an &LTInteger> generic</span></span><br><span class=line><span class=comment>// Store&LTString> beans will not appear in this list</span></span><br><span class=line><span class=meta>@Autowired</span></span><br><span class=line><span class=keyword>private</span> List&LTStore&LTInteger>> s;</span><br></pre></table></figure> <h4 id=2-1-9-6、使用CustomAutowireConfigurer><a class=headerlink href=#2-1-9-6、使用CustomAutowireConfigurer title=2.1.9.6、使用CustomAutowireConfigurer></a>2.1.9.6、使用CustomAutowireConfigurer</h4><p><a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html rel=noopener target=_blank>CustomAutowireConfigurer</a>是<code>BeanFactoryPostProcessor</code>，即使您没有使用 Spring 的<code>@Qualifier</code>注解 对您自己的自定义限定符注解类型进行注册，您也可以使用它们。以下示例显示了如何使用<code>CustomAutowireConfigurer</code>：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"customAutowireConfigurer"</span></span></span><br><span class=line><span class=tag>  <span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.annotation.CustomAutowireConfigurer"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"customQualifierTypes"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>set</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>example.CustomQualifier<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>set</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p><code>AutowireCandidateResolver</code>通过以下方式确定自动装配的候选对象：</p> <ul><li>每个 bean 定义的<code>autowire-candidate</code>值。<li><code>&LTbeans/></code>元素上可用的任何<code>default-autowire-candidates</code>模式。<li><code>@Qualifier</code>注解 和在<code>CustomAutowireConfigurer</code>中注册的所有自定义注解的存在。</ul> <p>当多个 bean 可以作为自动装配候选者时，确定“主要”的步骤如下：如果候选者中恰好有一个 bean 定义具有<code>primary</code>属性设置为<code>true</code>，则将其选中。</p> <h4 id=2-1-9-7、使用-Resource注入><a class=headerlink href=#2-1-9-7、使用-Resource注入 title=2.1.9.7、使用@Resource注入></a>2.1.9.7、使用@Resource注入</h4><p>Spring 还通过在字段或 bean 属性设置器方法上使用 JSR-250 <code>@Resource</code>注解 来支持注入。这是 Java EE 5 和 6 中的常见模式(例如，在 JSF 1.2 托管 Bean 或 JAX-WS 2.0 端点中)。 Spring 也为 SpringManagement 的对象支持此模式。</p> <p><code>@Resource</code>具有名称属性。默认情况下，Spring将该值解释为要注入的Bean名称。换句话说，它遵循名称语义，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=meta>@Resource(name="myMovieFinder")</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>下面的示例将名为bean<code>movieFinder</code>的setter方法注入：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=meta>@Resource</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure> <p>在未使用<code>@Resource</code>且未指定显式名称且与<code>@Autowired</code>类似的特殊情况下，<code>@Resource</code>查找主类型匹配而不是特定的命名 bean，并解析众所周知的可解决依赖项：<code>BeanFactory</code>，<code>ApplicationContext</code>，<code>ResourceLoader</code>，<code>ApplicationEventPublisher</code>和<code>MessageSource</code>接口。</p> <p>在下面的示例中，<code>customerPreferenceDao</code>字段首先查找名为 customerPreferenceDao 的 bean，然后回退到类型<code>CustomerPreferenceDao</code>的主类型匹配：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=meta>@Resource</span></span><br><span class=line>    <span class=keyword>private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class=line>    <span class=meta>@Resource</span></span><br><span class=line>    <span class=keyword>private</span> ApplicationContext context; </span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MovieRecommender</span><span class=params>()</span> {</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <h4 id=2-1-9-8、使用-Value><a class=headerlink href=#2-1-9-8、使用-Value title=2.1.9.8、使用@Value></a>2.1.9.8、使用@Value</h4><p><code>@Value</code> 通常用于注入外部属性：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> String catalog;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MovieRecommender</span><span class=params>(<span class=meta>@Value("${catalog.name}")</span> String catalog)</span> {</span><br><span class=line>        <span class=built_in>this</span>.catalog = catalog;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>使用以下配置：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@PropertySource("classpath:application.properties")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> { }</span><br></pre></table></figure> <p>和以下<code>application.properties</code>文件：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>catalog.name=MovieCatalog</span><br></pre></table></figure> <p>在这种情况下，<code>catalog</code>参数和字段将等于<code>MovieCatalog</code>值。</p> <p>Spring提供了一个默认的宽松内嵌值解析器。它将尝试解析属性值，如果无法解析，<code>${catalog.name}</code>则将注入属性名称（例如）作为值。如果要严格控制不存在的值，则应声明一个<code>PropertySourcesPlaceholderConfigurer</code>bean，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>     <span class=meta>@Bean</span></span><br><span class=line>     <span class=keyword>public</span> <span class=keyword>static</span> PropertySourcesPlaceholderConfigurer <span class="title function_">propertyPlaceholderConfigurer</span><span class=params>()</span> {</span><br><span class=line>           <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">PropertySourcesPlaceholderConfigurer</span>();</span><br><span class=line>     }</span><br><span class=line>}</span><br></pre></table></figure> <blockquote><p>当配置<code>PropertySourcesPlaceholderConfigurer</code>使用JavaConfig，该 <code>@Bean</code>方法必须是<code>static</code>。</blockquote> <p>如果<code>${}</code> 无法解析任何占位符，则使用上述配置可确保Spring初始化失败。也可以使用<code>setPlaceholderPrefix</code>、<code>setPlaceholderSuffix</code>、<code>setValueSeparator</code>之类的方法自定义占位符。</p> <blockquote><p>默认情况下，Spring Boot配置一个<code>PropertySourcesPlaceholderConfigurer</code>Bean，它将从<code>application.properties</code>和<code>application.yml</code>文件中获取属性。</blockquote> <p>当<code>@Value</code>包含<code>Spring EL</code>表达式时该值将在运行时动态计算，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> String catalog;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MovieRecommender</span><span class=params>(<span class=meta>@Value("#{systemProperties['user.catalog'] + 'Catalog' }")</span> String catalog)</span> {</span><br><span class=line>        <span class=built_in>this</span>.catalog = catalog;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>Spring EL还支持使用更复杂的数据结构：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> Map&LTString, Integer> countOfMoviesPerCatalog;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MovieRecommender</span><span class=params>(</span></span><br><span class=line><span class=params>            <span class=meta>@Value("#{{'Thriller': 100, 'Comedy': 300}}")</span> Map&LTString, Integer> countOfMoviesPerCatalog)</span> {</span><br><span class=line>        <span class=built_in>this</span>.countOfMoviesPerCatalog = countOfMoviesPerCatalog;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=2-1-9-9、使用-PostConstruct和-PreDestroy><a class=headerlink href=#2-1-9-9、使用-PostConstruct和-PreDestroy title=2.1.9.9、使用@PostConstruct和@PreDestroy></a>2.1.9.9、使用@PostConstruct和@PreDestroy</h4><p><code>CommonAnnotationBeanPostProcessor</code>不仅可以识别<code>@Resource</code>注解，还可以识别 JSR-250 生命周期 注解。在 Spring 2.5 中引入了对这些注解的支持，为<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean rel=noopener target=_blank>initialization callbacks</a>和<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-disposablebean rel=noopener target=_blank>destruction callbacks</a>中描述的注解提供了另一种选择。假设<code>CommonAnnotationBeanPostProcessor</code>已在 Spring <code>ApplicationContext</code>中注册，则在生命周期的同一点与相应的 Spring 生命周期接口方法或显式声明的回调方法一起调用带有这些注解之一的方法。</p> <p>在以下示例中，缓存在初始化时预先填充，并在销毁时清除：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CachingMovieLister</span> {</span><br><span class=line>    <span class=meta>@PostConstruct</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">populateMovieCache</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// populates the movie cache upon initialization...</span></span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@PreDestroy</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">clearMovieCache</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// clears the movie cache upon destruction...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <blockquote><p>和<code>@Resource</code>一样，<code>@PostConstruct</code>和<code>@PreDestroy</code>注释类型是JDK 6到8的标准Java库的一部分。但是，整个<code>javax.annotation</code> 包都与JDK 9中的核心Java模块分开，并最终在JDK 11中删除。如果需要，需要将<code>javax.annotation-api</code>工件现在可以通过Maven Central获得，只需像其他任何库一样将其添加到应用程序的类路径中即可。</blockquote> <h3 id=2-1-10、类路径扫描和托管组件><a class=headerlink href=#2-1-10、类路径扫描和托管组件 title=2.1.10、类路径扫描和托管组件></a>2.1.10、类路径扫描和托管组件</h3><h4 id=2-1-10-1、-Component和其它注解><a class=headerlink href=#2-1-10-1、-Component和其它注解 title=2.1.10.1、@Component和其它注解></a>2.1.10.1、@Component和其它注解</h4><p>Spring提供进一步典型化注解：<code>@Component</code>，<code>@Service</code>，和 <code>@Controller</code>。<code>@Component</code>是任何Spring托管组件的通用构造型。 <code>@Repository</code>，<code>@Service</code>和<code>@Controller</code>分别是<code>@Component</code>针对特定用例的专业化（分别在持久性，服务和表示层）。</p> <p><code>@Repository</code>，<code>@Service</code>和<code>@Controller</code>在 Spring 框架的 Future 发行版中还可包含其他语义。因此，如果在服务层使用<code>@Component</code>或<code>@Service</code>之间进行选择，则<code>@Service</code>显然是更好的选择。同样，如前所述，<code>@Repository</code>已被支持作为持久层中自动异常转换的标记。</p> <h4 id=2-1-10-2、使用元注释和组合注释><a class=headerlink href=#2-1-10-2、使用元注释和组合注释 title=2.1.10.2、使用元注释和组合注释></a>2.1.10.2、使用元注释和组合注释</h4><p>Spring提供的许多注释都可以在您自己的代码中用作元注释。元注释是可以应用于另一个注释的注释。如下面的示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Target(ElementType.TYPE)</span></span><br><span class=line><span class=meta>@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=line><span class=meta>@Documented</span></span><br><span class=line><span class=meta>@Component</span> </span><br><span class=line><span class=keyword>public</span> <span class=meta>@interface</span> Service {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p><code>Component</code>导致<code>@Service</code>的处理方式与<code>@Component</code>相同。</p> <p>您还可以结合使用元注解来创建“组合 注解”。例如，Spring MVC 的<code>@RestController</code>注解 由<code>@Controller</code>和<code>@ResponseBody</code>组成。</p> <p>此外，组合注释可以选择从元注释中重新声明属性，以允许自定义。以下清单显示了<code>SessionScope</code>注释的定义 ：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>@Target({ElementType.TYPE, ElementType.METHOD})</span></span><br><span class=line><span class=meta>@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=line><span class=meta>@Documented</span></span><br><span class=line><span class=meta>@Scope(WebApplicationContext.SCOPE_SESSION)</span></span><br><span class=line><span class=keyword>public</span> <span class=meta>@interface</span> SessionScope {</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * Alias for {<span class=doctag>@link</span> Scope#proxyMode}.</span></span><br><span class=line><span class=comment>     * &LTp>Defaults to {<span class=doctag>@link</span> ScopedProxyMode#TARGET_CLASS}.</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=meta>@AliasFor(annotation = Scope.class)</span></span><br><span class=line>    ScopedProxyMode <span class="title function_">proxyMode</span><span class=params>()</span> <span class=keyword>default</span> ScopedProxyMode.TARGET_CLASS;</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure> <p>然后，您可以使用<code>@SessionScope</code>而不用声明<code>proxyMode</code>，如下所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=meta>@SessionScope</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SessionScopedService</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>您还可以覆盖<code>proxyMode</code>的值，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=meta>@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SessionScopedUserService</span> <span class=keyword>implements</span> <span class="title class_">UserService</span> {</span><br><span class=line>    <span class=comment>// ..</span></span><br><span class=line>}</span><br></pre></table></figure> <h4 id=2-1-10-3、自动检测类并注册Bean定义><a class=headerlink href=#2-1-10-3、自动检测类并注册Bean定义 title=2.1.10.3、自动检测类并注册Bean定义></a>2.1.10.3、自动检测类并注册Bean定义</h4><p>Spring 可以自动检测构造型类，并向<code>ApplicationContext</code>注册相应的<code>BeanDefinition</code>实例。例如，以下两个类别有资格进行这种自动检测：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">SimpleMovieLister</span><span class=params>(MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Repository</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">JpaMovieFinder</span> <span class=keyword>implements</span> <span class="title class_">MovieFinder</span> {</span><br><span class=line>    <span class=comment>// implementation elided for clarity</span></span><br><span class=line>}</span><br></pre></table></figure> <p>要自动检测这些类并注册相应的bean，您需要添加 <code>@ComponentScan</code>到<code>@Configuration</code>类中，其中<code>basePackages</code>属性是两个类的公共父包。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@ComponentScan(basePackages = "org.example")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span>  {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>以下替代方法使用XML：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:context</span>=<span class=string>"http://www.springframework.org/schema/context"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/context</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/context/spring-context.xsd"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>context:component-scan</span> <span class=attr>base-package</span>=<span class=string>"org.example"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>此外，当您使用component-scan元素时，<code>AutowiredAnnotationBeanPostProcessor</code>和 <code>CommonAnnotationBeanPostProcessor</code>都隐式包括在内。这意味着将自动检测这两个组件并将它们连接在一起，而这一切都不需要XML中提供的任何bean配置元数据。</p> <blockquote><p>您可以通过包含注解<code>annotation-config</code>设置属性<code>false</code>来禁用<code>AutowiredAnnotationBeanPostProcessor</code>和<code>CommonAnnotationBeanPostProcessor</code>的注册。</blockquote> <h4 id=2-1-10-4、使用过滤器自定义扫描><a class=headerlink href=#2-1-10-4、使用过滤器自定义扫描 title=2.1.10.4、使用过滤器自定义扫描></a>2.1.10.4、使用过滤器自定义扫描</h4><p>默认情况下，唯一检测到的候选组件是用<code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code>注解 的类或本身用<code>@Component</code>注解 的定制 注解。但是，您可以通过应用自定义过滤器来修改和扩展此行为。将它们添加为<code>@ComponentScan</code>注解的<code>includeFilters</code>或<code>excludeFilters</code>参数(或<code>component-scan</code>元素的<code>include-filter</code>或<code>exclude-filter</code>子元素)。每个过滤器元素都需要<code>type</code>和<code>expression</code>属性。下表描述了过滤选项：</p> <table><thead><tr><th align=left>过滤器类型<th align=left>范例表达<th align=left>描述<tbody><tr><td align=left>annotation（default）<td align=left><code>org.example.SomeAnnotation</code><td align=left>在目标组件中的类型级别上要<em>存在</em>或<em>元存在</em>的注释。<tr><td align=left>assignable<td align=left><code>org.example.SomeClass</code><td align=left>目标组件可分配给（扩展或实现）的类（或接口）。<tr><td align=left>aspectj<td align=left><code>org.example..*Service+</code><td align=left>目标组件要匹配的AspectJ类型表达式。<tr><td align=left>regex<td align=left><code>org\.example\.Default.*</code><td align=left>要与目标组件的类名匹配的正则表达式。<tr><td align=left>custom<td align=left><code>org.example.MyTypeFilter</code><td align=left><code>org.springframework.core.type.TypeFilter</code>接口的自定义实现。</table> <p>以下示例显示了忽略所有<code>@Repository</code>注释并改为使用“存根”存储库的配置：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@ComponentScan(basePackages = "org.example",</span></span><br><span class=line><span class=meta>        includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"),</span></span><br><span class=line><span class=meta>        excludeFilters = @Filter(Repository.class))</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    ...</span><br><span class=line>}</span><br></pre></table></figure> <p>以下清单显示了等效的XML：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>context:component-scan</span> <span class=attr>base-package</span>=<span class=string>"org.example"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>context:include-filter</span> <span class=attr>type</span>=<span class=string>"regex"</span></span></span><br><span class=line><span class=tag>                <span class=attr>expression</span>=<span class=string>".*Stub.*Repository"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>context:exclude-filter</span> <span class=attr>type</span>=<span class=string>"annotation"</span></span></span><br><span class=line><span class=tag>                <span class=attr>expression</span>=<span class=string>"org.springframework.stereotype.Repository"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>context:component-scan</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <blockquote><p>您还可以通过在注解上设置<code>useDefaultFilters=false</code>或通过提供<code>use-default-filters="false"</code>作为<code>&LTcomponent-scan/></code>元素的属性来禁用默认过滤器。实际上，这将禁用对带有<code>@Component</code>，<code>@Repository</code>，<code>@Service</code>，<code>@Controller</code>或<code>@Configuration</code>注解 的类的自动检测。</blockquote> <h4 id=2-1-10-5、在组件中定义Bean元数据><a class=headerlink href=#2-1-10-5、在组件中定义Bean元数据 title=2.1.10.5、在组件中定义Bean元数据></a>2.1.10.5、在组件中定义Bean元数据</h4><p>Spring 组件还可以将 bean 定义元数据贡献给容器。您可以使用与<code>@Configuration</code>带注解的类中定义 Bean 元数据相同的<code>@Bean</code>注解 来执行此操作。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>Component</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">FactoryMethodComponent</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=meta>@Qualifier("public")</span></span><br><span class=line>    <span class=keyword>public</span> TestBean <span class="title function_">publicInstance</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">TestBean</span>(<span class=string>"publicInstance"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doWork</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// Component method implementation omitted</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>上一类是Spring组件，其<code>doWork()</code>方法中具有特定于应用程序的代码 。但是，它也提供了具有工厂方法的bean定义，该方法引用了方法 <code>publicInstance()</code>。该<code>@Bean</code>注释标识工厂方法和其它bean定义特性，例如通过<code>@Qualifier</code>注解 的限定符值。可以指定的其他方法级别注解是<code>@Scope</code>，<code>@Lazy</code>和自定义限定符 注解。</p> <h4 id=2-1-10-6、命名自动检测的组件><a class=headerlink href=#2-1-10-6、命名自动检测的组件 title=2.1.10.6、命名自动检测的组件></a>2.1.10.6、命名自动检测的组件</h4><p>在扫描过程中自动检测到某个组件时，其 bean 名称由该扫描器已知的<code>BeanNameGenerator</code>策略生成。默认情况下，任何包含名称<code>value</code>的 Spring 构造型 注解(<code>@Component</code>，<code>@Repository</code>，<code>@Service</code>和<code>@Controller</code>)都会将该名称提供给相应的 bean 定义。</p> <p>如果这样的注解不包含名称<code>value</code>或任何其他检测到的组件(例如，由自定义过滤器发现的组件)，则缺省 bean 名称生成器将返回不使用大写字母的非限定类名称。例如，如果检测到以下组件类，则名称将为<code>myMovieLister</code>和<code>movieFinderImpl</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service("myMovieLister")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Repository</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieFinderImpl</span> <span class=keyword>implements</span> <span class="title class_">MovieFinder</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>如果不想依赖默认的Bean命名策略，则可以提供自定义Bean命名策略。首先，实现 <a href=https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html rel=noopener target=_blank><code>BeanNameGenerator</code></a> 接口，并确保包括默认的no-arg构造函数。然后，在配置扫描程序时提供完全限定的类名，如以下示例注释和Bean定义所示。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@ComponentScan(basePackages = "org.example", nameGenerator = MyNameGenerator.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>context:component-scan</span> <span class=attr>base-package</span>=<span class=string>"org.example"</span></span></span><br><span class=line><span class=tag>        <span class=attr>name-generator</span>=<span class=string>"org.example.MyNameGenerator"</span> /></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>通常，请考虑在其他组件可能对其进行显式引用时，使用注解指定名称。另一方面，只要容器负责接线，自动生成的名称就足够了。</p> <h4 id=2-1-10-7、提供自动检测组件的范围><a class=headerlink href=#2-1-10-7、提供自动检测组件的范围 title=2.1.10.7、提供自动检测组件的范围></a>2.1.10.7、提供自动检测组件的范围</h4><p>一般而言，与Spring管理的组件一样，自动检测到的组件的默认范围也是最常见的范围是<code>singleton</code>。但是，有时您需要由<code>@Scope</code>注释指定其他范围。您可以在批注中提供范围的名称，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Scope("prototype")</span></span><br><span class=line><span class=meta>@Repository</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieFinderImpl</span> <span class=keyword>implements</span> <span class="title class_">MovieFinder</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <blockquote><p><code>@Scope</code>注解 仅在具体的 bean 类(对于带注解的组件)或工厂方法(对于<code>@Bean</code>方法)上进行内省。与 XML bean 定义相反，没有 bean 定义继承的概念，并且在类级别的继承层次结构与元数据目的无关。</blockquote> <p>使用某些非单作用域时，可能有必要为作用域对象生成代理。在<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-other-injection rel=noopener target=_blank>范围Bean中将</a>推理描述<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-other-injection rel=noopener target=_blank>为依赖项</a>。为此，在component-scan元素上可以使用scoped-proxy属性。三个可能的值是：<code>no</code>，<code>interfaces</code>，和<code>targetClass</code>。例如，以下配置产生标准的JDK动态代理：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@ComponentScan(basePackages = "org.example", scopedProxy = ScopedProxyMode.INTERFACES)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>context:component-scan</span> <span class=attr>base-package</span>=<span class=string>"org.example"</span> <span class=attr>scoped-proxy</span>=<span class=string>"interfaces"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h4 id=2-1-10-8、提供带注释的限定符元数据><a class=headerlink href=#2-1-10-8、提供带注释的限定符元数据 title=2.1.10.8、提供带注释的限定符元数据></a>2.1.10.8、提供带注释的限定符元数据</h4><p>当依靠类路径扫描来自动检测组件时，可以在候选类上为限定符元数据提供类型级别的注释。下面的三个示例演示了此技术：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Qualifier("Action")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ActionMovieCatalog</span> <span class=keyword>implements</span> <span class="title class_">MovieCatalog</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Genre("Action")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ActionMovieCatalog</span> <span class=keyword>implements</span> <span class="title class_">MovieCatalog</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Offline</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CachingMovieCatalog</span> <span class=keyword>implements</span> <span class="title class_">MovieCatalog</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <h4 id=2-1-10-9、生成候选组件的索引><a class=headerlink href=#2-1-10-9、生成候选组件的索引 title=2.1.10.9、生成候选组件的索引></a>2.1.10.9、生成候选组件的索引</h4><p>尽管类路径扫描非常快，但可以通过在编译时创建静态候选列表来提高大型应用程序的启动性能。在这种模式下，作为组件扫描目标的所有模块都必须使用此机制，因为当<code>ApplicationContext</code>检测到这样的索引时，它将自动使用它而不是扫描 Classpath。</p> <p>要生成索引，请向每个包含组件的模块添加附加依赖关系，这些组件是组件扫描指令的目标。以下示例显示了如何使用Maven进行操作：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>    <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>        <span class=tag><<span class=name>groupId</span>></span>org.springframework<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>artifactId</span>></span>spring-context-indexer<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>version</span>></span>5.3.2<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>        <span class=tag><<span class=name>optional</span>></span>true<span class=tag>&LT/<span class=name>optional</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencies</span>></span></span><br></pre></table></figure> <blockquote><p>在IDE中使用此模式时，<code>spring-context-indexer</code>必须将其注册为注释处理器，以确保在更新候选组件时索引是最新的。<p><code>META-INF/spring.components</code>在类路径上找到 a时，索引将自动启用。如果某个索引对于某些库（或用例）部分可用，但无法为整个应用程序构建，则可以通过将设置<code>spring.index.ignore</code>为 <code>true</code>，来回退到常规的类路径安排（好像根本没有索引）属性或<code>spring.properties</code>类路径根目录下的文件中。</blockquote> <h3 id=2-1-11、使用-JSR330-标准注释><a title="2.1.11、使用 JSR330 标准注释" class=headerlink href=#2-1-11、使用-JSR330-标准注释></a>2.1.11、使用 JSR330 标准注释</h3><p>从Spring 3.0开始，Spring提供对JSR-330标准注释（依赖注入）的支持。这些注释的扫描方式与Spring注释的扫描方式相同。要使用它们，您需要在类路径中有相关的jar。</p> <p>如果使用Maven，您可以将以下依赖项添加到文件pom.xml中：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>javax.inject<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>javax.inject<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>1<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure> <h4 id=2-1-11-1、-Inject和-Named的依赖注入><a class=headerlink href=#2-1-11-1、-Inject和-Named的依赖注入 title=2.1.11.1、@Inject和@Named的依赖注入></a>2.1.11.1、@Inject和@Named的依赖注入</h4><p>除了<code>@Autowired</code>，您可以使用<code>@javax.inject.Inject</code>代替<code>@Autowired</code>，如下所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> javax.inject.Inject;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=meta>@Inject</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">listMovies</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder.findMovies(...);</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>与一样<code>@Autowired</code>，您可以在字段级别，方法级别和构造函数参数级别使用<code>@Inject</code>。此外，您可以将注入点声明为<code>Provider</code>，以允许按需访问范围较小的 bean，或者通过<code>Provider.get()</code>调用来懒惰地访问其他 bean。以下示例提供了前面示例的变体：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> javax.inject.Inject;</span><br><span class=line><span class=keyword>import</span> javax.inject.Provider;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> Provider&LTMovieFinder> movieFinder;</span><br><span class=line>    <span class=meta>@Inject</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(Provider&LTMovieFinder> movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">listMovies</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder.get().findMovies(...);</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>如果要为应该注入的依赖项使用限定名称，则应使用<code>@Named</code>批注，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> javax.inject.Inject;</span><br><span class=line><span class=keyword>import</span> javax.inject.Named;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=meta>@Inject</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(<span class=meta>@Named("main")</span> MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>与一样<code>@Autowired</code>，<code>@Inject</code>也可以与<code>java.util.Optional</code>或 @Nullable<code>一起使用</code>。这在这里更为适用，因为<code>@Inject</code>没有<code>required</code>属性。以下示例展示了如何使用<code>@Inject</code>和 <code>@Nullable</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=meta>@Inject</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(Optional&LTMovieFinder> movieFinder)</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=meta>@Inject</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(<span class=meta>@Nullable</span> MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=2-1-11-2、-Named和-ManagedBean：-Component注释的标准等效项><a class=headerlink href=#2-1-11-2、-Named和-ManagedBean：-Component注释的标准等效项 title=2.1.11.2、@Named和@ManagedBean：@Component注释的标准等效项></a>2.1.11.2、<code>@Named</code>和<code>@ManagedBean</code>：<code>@Component</code>注释的标准等效项</h4><p>代替<code>@Component</code>，您可以使用<code>@javax.inject.Named</code>或<code>javax.annotation.ManagedBean</code>，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> javax.inject.Inject;</span><br><span class=line><span class=keyword>import</span> javax.inject.Named;</span><br><span class=line></span><br><span class=line><span class=meta>@Named("movieListener")</span>  <span class=comment>// @ManagedBean("movieListener") could be used as well</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=meta>@Inject</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>在不指定组件名称的情况下使用<code>@Component</code>是很常见的。 <code>@Named</code>可以类似的方式使用，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> javax.inject.Inject;</span><br><span class=line><span class=keyword>import</span> javax.inject.Named;</span><br><span class=line></span><br><span class=line><span class=meta>@Named</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=meta>@Inject</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMovieFinder</span><span class=params>(MovieFinder movieFinder)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>使用<code>@Named</code>或<code>@ManagedBean</code>时，可以使用与使用 Spring注解 完全相同的方式来使用组件扫描，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@ComponentScan(basePackages = "org.example")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span>  {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <blockquote><p>与<code>@Component</code>相反，JSR-330 <code>@Named</code>和 JSR-250 <code>ManagedBean</code>注解 是不可组合的。您应该使用 Spring 的构造型模型来构建自定义组件 注解。</blockquote> <h4 id=2-1-11-3、JSR-330标准注释的局限性><a class=headerlink href=#2-1-11-3、JSR-330标准注释的局限性 title=2.1.11.3、JSR-330标准注释的局限性></a>2.1.11.3、JSR-330标准注释的局限性</h4><p>当使用标准注释时，您应该知道某些重要功能不可用，如下表所示：</p> <table><thead><tr><th align=left>Spring<th align=left>javax.inject。*<th align=left>javax.inject限制/注释<tbody><tr><td align=left>@Autowired<td align=left>@inject<td align=left><code>@Inject</code>没有“必填”属性。可以与Java 8一起使用<code>Optional</code>。<tr><td align=left>@Component<td align=left>@Named / @ManagedBean<td align=left>JSR-330不提供可组合的模型，仅提供一种识别命名组件的方法。<tr><td align=left>@Scope（“ singleton”）<td align=left>@Singleton<td align=left>JSR-330的默认范围类似于Spring的<code>prototype</code>。但是，为了使其与Spring的默认默认值保持一致，默认情况下，在Spring容器中声明的JSR-330 bean是a <code>singleton</code>。为了使用之外的范围<code>singleton</code>，您应该使用Spring的<code>@Scope</code>注释。<code>javax.inject</code>还提供了 <a href=https://download.oracle.com/javaee/6/api/javax/inject/Scope.html rel=noopener target=_blank>@Scope</a>批注。不过，此仅用于创建自己的注释。<tr><td align=left>@Qualifier<td align=left>@Qualifier / @Named<td align=left><code>javax.inject.Qualifier</code>只是用于构建自定义限定符的元注释。具体<code>String</code>限定词（例如<code>@Qualifier</code>带有值的Spring的限定词）可以通过关联<code>javax.inject.Named</code>。<tr><td align=left>@Value<td align=left>–<td align=left>没有等效<tr><td align=left>@Required<td align=left>–<td align=left>没有等效<tr><td align=left>@Lazy<td align=left>–<td align=left>没有等效<tr><td align=left>ObjectFactory<td align=left>Provider<td align=left><code>javax.inject.Provider</code>是Spring的直接替代方法<code>ObjectFactory</code>，只是<code>get()</code>方法名称较短。它也可以与Spring<code>@Autowired</code>或非注释构造函数和setter方法结合使用。</table> <h3 id=2-1-12、基于Java的容器配置><a class=headerlink href=#2-1-12、基于Java的容器配置 title=2.1.12、基于Java的容器配置></a>2.1.12、基于Java的容器配置</h3><p>本节介绍如何在Java代码中使用注释来配置Spring容器。它包括以下主题：</p> <ul><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-basic-concepts rel=noopener target=_blank>基本概念：<code>@Bean</code>和<code>@Configuration</code></a><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-instantiating-container rel=noopener target=_blank>使用实例化Spring容器 <code>AnnotationConfigApplicationContext</code></a><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-bean-annotation rel=noopener target=_blank>使用<code>@Bean</code>注释</a><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-configuration-annotation rel=noopener target=_blank>使用<code>@Configuration</code>注释</a><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-composing-configuration-classes rel=noopener target=_blank>组成基于Java的配置</a><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-definition-profiles rel=noopener target=_blank>Bean定义配置文件</a><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-property-source-abstraction rel=noopener target=_blank><code>PropertySource</code> 抽象化</a><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-using-propertysource rel=noopener target=_blank>使用 <code>@PropertySource</code></a><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-placeholder-resolution-in-statements rel=noopener target=_blank>声明中的占位符解析</a></ul> <h4 id=2-1-12-1、基本概念：-Bean和-Configuration><a class=headerlink href=#2-1-12-1、基本概念：-Bean和-Configuration title=2.1.12.1、基本概念：@Bean和@Configuration></a>2.1.12.1、基本概念：@Bean和@Configuration</h4><p>Spring的新Java配置支持中的主要工件是 <code>@Configuration</code>注释的类和<code>@Bean</code>注释的方法。</p> <p><code>@Configuration</code>注解 类表示该类的主要目的是作为 Bean 定义的来源。此外，<code>@Configuration</code>类通过调用同一类中的其他<code>@Bean</code>方法来定义 Bean 间的依赖关系。最简单的<code>@Configuration</code>类的内容如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> MyService <span class="title function_">myService</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">MyServiceImpl</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>上一<code>AppConfig</code>类等效于以下XML：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"myService"</span> <span class=attr>class</span>=<span class=string>"com.acme.services.MyServiceImpl"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h4 id=2-1-12-2、使用AnnotationConfigApplicationContext实例化Spring容器><a class=headerlink href=#2-1-12-2、使用AnnotationConfigApplicationContext实例化Spring容器 title=2.1.12.2、使用AnnotationConfigApplicationContext实例化Spring容器></a>2.1.12.2、使用AnnotationConfigApplicationContext实例化Spring容器</h4><h5 id=Simple-Construction><a title="Simple Construction" class=headerlink href=#Simple-Construction></a>Simple Construction</h5><p>与实例化<code>ClassPathXmlApplicationContext</code>时将 Spring XML 文件用作 Importing 的方式几乎相同，实例化<code>AnnotationConfigApplicationContext</code>时可以将<code>@Configuration</code>类用作 Importing。</p> <p>如下面的示例所示，这允许完全不使用XML来使用Spring容器：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=type>ApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class=line>    <span class=type>MyService</span> <span class=variable>myService</span> <span class=operator>=</span> ctx.getBean(MyService.class);</span><br><span class=line>    myService.doStuff();</span><br><span class=line>}</span><br></pre></table></figure> <p>如前所述，<code>AnnotationConfigApplicationContext</code>不仅限于仅使用<code>@Configuration</code>类。``可以将任何@Component或带有JSR-330注释的类作为 输入 提供给构造函数，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=type>ApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyServiceImpl.class, Dependency1.class, Dependency2.class);</span><br><span class=line>    <span class=type>MyService</span> <span class=variable>myService</span> <span class=operator>=</span> ctx.getBean(MyService.class);</span><br><span class=line>    myService.doStuff();</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=通过使用register-Class…-以编程方式构建容器><a title="通过使用register(Class<?>…)以编程方式构建容器" class=headerlink href=#通过使用register-Class…-以编程方式构建容器></a>通过使用register(Class&LT?>…)以编程方式构建容器</h5><p>您可以使用 no-arg 构造函数实例化<code>AnnotationConfigApplicationContext</code>，然后使用<code>register()</code>方法对其进行配置。以编程方式构建<code>AnnotationConfigApplicationContext</code>时，此方法特别有用。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=type>AnnotationConfigApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class=line>    ctx.register(AppConfig.class, OtherConfig.class);</span><br><span class=line>    ctx.register(AdditionalConfig.class);</span><br><span class=line>    ctx.refresh();</span><br><span class=line>    <span class=type>MyService</span> <span class=variable>myService</span> <span class=operator>=</span> ctx.getBean(MyService.class);</span><br><span class=line>    myService.doStuff();</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=使用scan-String…-启用组件扫描><a class=headerlink href=#使用scan-String…-启用组件扫描 title=使用scan(String…)启用组件扫描></a>使用scan(String…)启用组件扫描</h5><p>要启用组件扫描，您可以按如下方式注释您的<code>@Configuration</code>类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@ComponentScan(basePackages = "com.acme")</span> </span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span>  {</span><br><span class=line>    ...</span><br><span class=line>}</span><br></pre></table></figure> <p><code>AnnotationConfigApplicationContext</code>公开此 <code>scan(String…)</code>方法以允许相同的组件扫描功能，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=type>AnnotationConfigApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class=line>    ctx.scan(<span class=string>"com.acme"</span>);</span><br><span class=line>    ctx.refresh();</span><br><span class=line>    <span class=type>MyService</span> <span class=variable>myService</span> <span class=operator>=</span> ctx.getBean(MyService.class);</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=通过AnnotationConfigWebApplicationContext支持Web应用程序><a class=headerlink href=#通过AnnotationConfigWebApplicationContext支持Web应用程序 title=通过AnnotationConfigWebApplicationContext支持Web应用程序></a>通过AnnotationConfigWebApplicationContext支持Web应用程序</h5><p><code>AnnotationConfigWebApplicationContext</code>可提供<code>AnnotationConfigApplicationContext</code>的<code>WebApplicationContext</code>变体。在配置 Spring <code>ContextLoaderListener</code> servlet 侦听器，Spring MVC <code>DispatcherServlet</code>等时，可以使用此实现。以下<code>web.xml</code>片段配置了典型的 Spring MVC Web 应用程序(请注意<code>contextClass</code> context-param 和 init-param 的使用)：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>web-app</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>context-param</span>></span></span><br><span class=line>        <span class=tag><<span class=name>param-name</span>></span>contextClass<span class=tag>&LT/<span class=name>param-name</span>></span></span><br><span class=line>        <span class=tag><<span class=name>param-value</span>></span> org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class=line>        <span class=tag>&LT/<span class=name>param-value</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>context-param</span>></span></span><br><span class=line>    </span><br><span class=line>    <span class=tag><<span class=name>context-param</span>></span></span><br><span class=line>        <span class=tag><<span class=name>param-name</span>></span>contextConfigLocation<span class=tag>&LT/<span class=name>param-name</span>></span></span><br><span class=line>        <span class=tag><<span class=name>param-value</span>></span>com.acme.AppConfig<span class=tag>&LT/<span class=name>param-value</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>context-param</span>></span></span><br><span class=line>    </span><br><span class=line>    <span class=tag><<span class=name>listener</span>></span></span><br><span class=line>        <span class=tag><<span class=name>listener-class</span>></span>org.springframework.web.context.ContextLoaderListener<span class=tag>&LT/<span class=name>listener-class</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>listener</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- Declare a Spring MVC DispatcherServlet as usual --></span></span><br><span class=line>    <span class=tag><<span class=name>servlet</span>></span></span><br><span class=line>        <span class=tag><<span class=name>servlet-name</span>></span>dispatcher<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>        <span class=tag><<span class=name>servlet-class</span>></span>org.springframework.web.servlet.DispatcherServlet<span class=tag>&LT/<span class=name>servlet-class</span>></span></span><br><span class=line>        <span class=tag><<span class=name>init-param</span>></span></span><br><span class=line>            <span class=tag><<span class=name>param-name</span>></span>contextClass<span class=tag>&LT/<span class=name>param-name</span>></span></span><br><span class=line>            <span class=tag><<span class=name>param-value</span>></span>       org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class=line>            <span class=tag>&LT/<span class=name>param-value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>init-param</span>></span></span><br><span class=line>        <span class=tag><<span class=name>init-param</span>></span></span><br><span class=line>            <span class=tag><<span class=name>param-name</span>></span>contextConfigLocation<span class=tag>&LT/<span class=name>param-name</span>></span></span><br><span class=line>            <span class=tag><<span class=name>param-value</span>></span>com.acme.web.MvcConfig<span class=tag>&LT/<span class=name>param-value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>init-param</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>servlet</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>servlet-mapping</span>></span></span><br><span class=line>        <span class=tag><<span class=name>servlet-name</span>></span>dispatcher<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>        <span class=tag><<span class=name>url-pattern</span>></span>/app/*<span class=tag>&LT/<span class=name>url-pattern</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>servlet-mapping</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>web-app</span>></span></span><br></pre></table></figure> <h4 id=2-1-12-3、使用-Bean注释><a class=headerlink href=#2-1-12-3、使用-Bean注释 title=2.1.12.3、使用@Bean注释></a>2.1.12.3、使用@Bean注释</h4><p><code>@Bean</code>是方法级别的注释，是XML<code>&LTbean/></code>元素的直接类似物。注解 支持<code>&LTbean/></code>提供的某些属性，例如：* <a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-initializingbean rel=noopener target=_blank>init-method</a> * <a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-lifecycle-disposablebean rel=noopener target=_blank>destroy-method</a> * <a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-autowire rel=noopener target=_blank>autowiring</a> * <code>name</code>。</p> <h5 id=声明一个Bean><a class=headerlink href=#声明一个Bean title=声明一个Bean></a>声明一个Bean</h5><p>要声明 bean，可以使用<code>@Bean</code>注解 对方法进行 注解。您可以使用此方法在指定为该方法的返回值的类型的<code>ApplicationContext</code>内注册 bean 定义。默认情况下，Bean 名称与方法名称相同。以下示例显示了<code>@Bean</code>方法声明：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> TransferServiceImpl <span class="title function_">transferService</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">TransferServiceImpl</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>前面的配置与下面的Spring XML完全等效：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"transferService"</span> <span class=attr>class</span>=<span class=string>"com.acme.TransferServiceImpl"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>这两个声明使一个名为<code>transferService</code>的 bean 在<code>ApplicationContext</code>中可用，并绑定到<code>TransferServiceImpl</code>类型的对象实例，如以下文本图像所示：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>transferService-> com.acme.TransferServiceImpl</span><br></pre></table></figure> <p>您还可以使用接口(或 Base Class)返回类型声明<code>@Bean</code>方法，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> TransferService <span class="title function_">transferService</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">TransferServiceImpl</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>但是，这将提前类型预测的可见性限制为指定的接口类型(<code>TransferService</code>)。然后，使用只对容器知道一次的完整类型(<code>TransferServiceImpl</code>)，实例化受影响的单例 bean。非惰性单例 bean 根据其声明 Sequences 实例化，因此您可能会看到不同的类型匹配结果，具体取决于另一个组件何时尝试通过未声明的类型进行匹配(例如<code>@Autowired TransferServiceImpl</code>，该实例仅在实例化<code>transferService</code> bean 时才解析.)。</p> <h5 id=Bean依赖><a class=headerlink href=#Bean依赖 title=Bean依赖></a>Bean依赖</h5><p>带<code>@Bean</code>注释的方法可以具有任意数量的参数，这些参数描述了构建该bean所需的依赖关系。例如，如果我们<code>TransferService</code> 需要一个<code>AccountRepository</code>，我们可以使用方法参数来实现该依赖关系，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> TransferService <span class="title function_">transferService</span><span class=params>(AccountRepository accountRepository)</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">TransferServiceImpl</span>(accountRepository);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>解析机制与基于构造函数的依赖注入几乎相同。</p> <h5 id=接收生命周期回调><a class=headerlink href=#接收生命周期回调 title=接收生命周期回调></a>接收生命周期回调</h5><p>使用<code>@Bean</code>注释定义的任何类都支持常规的生命周期回调，并且可以使用JSR-250中的<code>@PostConstruct</code>和<code>@PreDestroy</code>注释。</p> <p>该<code>@Bean</code>注释支持指定任意初始化和销毁回调方法，就像Spring XML中<code>bean</code>元素的<code>init-method</code>和<code>destroy-method</code>属性一样，如下面的示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BeanOne</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">init</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// initialization logic</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BeanTwo</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">cleanup</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// destruction logic</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean(initMethod = "init")</span></span><br><span class=line>    <span class=keyword>public</span> BeanOne <span class="title function_">beanOne</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">BeanOne</span>();</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Bean(destroyMethod = "cleanup")</span></span><br><span class=line>    <span class=keyword>public</span> BeanTwo <span class="title function_">beanTwo</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">BeanTwo</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>对于<code>BeanOne</code>前面注释中的示例，在构造期间直接调用<code>init()</code> 方法同样有效，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> BeanOne <span class="title function_">beanOne</span><span class=params>()</span> {</span><br><span class=line>        <span class=type>BeanOne</span> <span class=variable>beanOne</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">BeanOne</span>();</span><br><span class=line>        beanOne.init();</span><br><span class=line>        <span class=keyword>return</span> beanOne;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <h5 id=指定Bean范围><a class=headerlink href=#指定Bean范围 title=指定Bean范围></a>指定Bean范围</h5><p>Spring包含<code>@Scope</code>注释，以便您可以指定bean的范围。</p> <h6 id=使用-Scope注释><a class=headerlink href=#使用-Scope注释 title=使用@Scope注释></a>使用@Scope注释</h6><p>默认范围是<code>singleton</code>，但是您可以使用<code>@Scope</code>注释覆盖它，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyConfiguration</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=meta>@Scope("prototype")</span></span><br><span class=line>    <span class=keyword>public</span> Encryptor <span class="title function_">encryptor</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h6 id=Scope和-scoped-proxy><a title="@Scope和 scoped-proxy" class=headerlink href=#Scope和-scoped-proxy></a>@Scope和 scoped-proxy</h6><p>Spring提供了一种通过<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-other-injection rel=noopener target=_blank>作用域代理</a>处理作用域依赖性的便捷方法 。使用XML配置时创建此类代理的最简单方法是<code>&LTaop:scoped-proxy/></code>元素。使用<code>@Scope</code>注释在Java中配置bean可以为该<code>proxyMode</code>属性提供同等的支持。默认值为no proxy（<code>ScopedProxyMode.NO</code>），但是您可以指定<code>ScopedProxyMode.TARGET_CLASS</code>或<code>ScopedProxyMode.INTERFACES</code>。</p> <p>如果使用 Java 从 XML 参考文档(请参阅<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes-other-injection rel=noopener target=_blank>scoped proxies</a>)将作用域代理示例移植到我们的<code>@Bean</code>，则它类似于以下内容：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=comment>// an HTTP Session-scoped bean exposed as a proxy</span></span><br><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=meta>@SessionScope</span></span><br><span class=line><span class=keyword>public</span> UserPreferences <span class="title function_">userPreferences</span><span class=params>()</span> {</span><br><span class=line>    <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">UserPreferences</span>();</span><br><span class=line>}</span><br><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> Service <span class="title function_">userService</span><span class=params>()</span> {</span><br><span class=line>    <span class=type>UserService</span> <span class=variable>service</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SimpleUserService</span>();</span><br><span class=line>    <span class=comment>// a reference to the proxied userPreferences bean</span></span><br><span class=line>    service.setUserPreferences(userPreferences());</span><br><span class=line>    <span class=keyword>return</span> service;</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=自定义Bean命名><a class=headerlink href=#自定义Bean命名 title=自定义Bean命名></a>自定义Bean命名</h5><p>默认情况下，配置类使用<code>@Bean</code>方法的名称作为结果bean的名称。但是，可以使用<code>name</code>属性覆盖此功能，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean(name = "myThing")</span></span><br><span class=line>    <span class=keyword>public</span> Thing <span class="title function_">thing</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">Thing</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=Bean别名><a class=headerlink href=#Bean别名 title=Bean别名></a>Bean别名</h5><p>如<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beanname rel=noopener target=_blank>Naming Beans中</a>讨论的，有时希望为单个Bean提供多个名称，否则称为Bean别名。 为此<code>name</code>，<code>@Bean</code>注释的属性接受String数组。以下示例显示了如何为bean设置多个别名：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean({"dataSource", "subsystemA-dataSource", "subsystemB-dataSource"})</span></span><br><span class=line>    <span class=keyword>public</span> DataSource <span class="title function_">dataSource</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// instantiate, configure and return DataSource bean...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=Bean描述><a class=headerlink href=#Bean描述 title=Bean描述></a>Bean描述</h5><p>有时，提供有关 bean 的更详细的文本描述会很有帮助。当出于监视目的而暴露(可能通过 JMX)bean 时，这尤其有用。</p> <p>要将说明添加到<code>@Bean</code>，可以使用 <a href=https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/context/annotation/Description.html rel=noopener target=_blank><code>@Description</code></a> 批注，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=meta>@Description("Provides a basic example of a bean")</span></span><br><span class=line>    <span class=keyword>public</span> Thing <span class="title function_">thing</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">Thing</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=2-1-12-4、使用-Configuration注释><a class=headerlink href=#2-1-12-4、使用-Configuration注释 title=2.1.12.4、使用@Configuration注释></a>2.1.12.4、使用<code>@Configuration</code>注释</h4><p><code>@Configuration</code>是类级别的注释，指示对象是Bean定义的源。<code>@Configuration</code>类通过公共<code>@Bean</code>注释方法声明bean 。对<code>@Configuration</code>类的<code>@Bean</code>方法的调用也可以用于定义Bean之间的依赖关系。</p> <h5 id=注入bean间的依赖关系><a class=headerlink href=#注入bean间的依赖关系 title=注入bean间的依赖关系></a>注入bean间的依赖关系</h5><p>当bean彼此依赖时，表达这种依赖就像让一个bean方法调用另一个一样简单，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> BeanOne <span class="title function_">beanOne</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">BeanOne</span>(beanTwo());</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> BeanTwo <span class="title function_">beanTwo</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">BeanTwo</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>在前面的示例中，<code>beanOne</code>通过构造函数注入接收对<code>beanTwo</code>的引用。</p> <blockquote><p>仅当在<code>@Configuration</code>类中声明<code>@Bean</code>方法时，此声明 bean 间依赖性的方法才有效。您不能通过使用普通<code>@Component</code>类来声明 Bean 间的依赖关系。</blockquote> <h5 id=查找方法注入-1><a class=headerlink href=#查找方法注入-1 title=查找方法注入></a>查找方法注入</h5><p><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-method-injection rel=noopener target=_blank>查找方法注入</a>是一项高级功能，您应该很少使用。在单例作用域的bean依赖于原型作用域的bean的情况下，这很有用。将Java用于这种类型的配置为实现此模式提供了自然的方法。下面的示例演示如何使用查找方法注入：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">CommandManager</span> {</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">process</span><span class=params>(Object commandState)</span> {</span><br><span class=line>        <span class=comment>// grab a new instance of the appropriate Command interface</span></span><br><span class=line>        <span class=type>Command</span> <span class=variable>command</span> <span class=operator>=</span> createCommand();</span><br><span class=line>        <span class=comment>// set the state on the (hopefully brand new) Command instance</span></span><br><span class=line>        command.setState(commandState);</span><br><span class=line>        <span class=keyword>return</span> command.execute();</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// okay... but where is the implementation of this method?</span></span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>abstract</span> Command <span class="title function_">createCommand</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>通过使用 Java 配置，您可以创建<code>CommandManager</code>的子类，在该子类中，抽象<code>createCommand()</code>方法被覆盖，从而可以查找新的(原型)命令对象。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=meta>@Scope("prototype")</span></span><br><span class=line><span class=keyword>public</span> AsyncCommand <span class="title function_">asyncCommand</span><span class=params>()</span> {</span><br><span class=line>    <span class=type>AsyncCommand</span> <span class=variable>command</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AsyncCommand</span>();</span><br><span class=line>    <span class=comment>// inject dependencies here as required</span></span><br><span class=line>    <span class=keyword>return</span> command;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> CommandManager <span class="title function_">commandManager</span><span class=params>()</span> {</span><br><span class=line>    <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">CommandManager</span>() {</span><br><span class=line>        <span class=keyword>protected</span> Command <span class="title function_">createCommand</span><span class=params>()</span> {</span><br><span class=line>            <span class=keyword>return</span> asyncCommand();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=有关基于Java的配置如何在内部工作的更多信息><a class=headerlink href=#有关基于Java的配置如何在内部工作的更多信息 title=有关基于Java的配置如何在内部工作的更多信息></a>有关基于Java的配置如何在内部工作的更多信息</h5><p>该示例显示了一个带<code>@Bean</code>注释的方法被调用两次：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> ClientService <span class="title function_">clientService1</span><span class=params>()</span> {</span><br><span class=line>        <span class=type>ClientServiceImpl</span> <span class=variable>clientService</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class=line>        clientService.setClientDao(clientDao());</span><br><span class=line>        <span class=keyword>return</span> clientService;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> ClientService <span class="title function_">clientService2</span><span class=params>()</span> {</span><br><span class=line>        <span class=type>ClientServiceImpl</span> <span class=variable>clientService</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class=line>        clientService.setClientDao(clientDao());</span><br><span class=line>        <span class=keyword>return</span> clientService;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> ClientDao <span class="title function_">clientDao</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">ClientDaoImpl</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p><code>clientDao()</code>在<code>clientService1()</code>中被调用过一次，在<code>clientService2()</code>中被调用过一次。由于此方法创建了<code>ClientDaoImpl</code>的新实例并返回它，因此通常希望有两个实例(每个服务一个)。那绝对是有问题的：在 Spring 中，实例化的 bean 默认具有<code>singleton</code>范围。这就是神奇的地方：所有<code>@Configuration</code>类在启动时都使用<code>CGLIB</code>子类化。在子类中，子方法在调用父方法并创建新实例之前，首先检查容器中是否有任何缓存(作用域)的 bean。</p> <h4 id=2-1-12-5、组成基于Java的配置><a class=headerlink href=#2-1-12-5、组成基于Java的配置 title=2.1.12.5、组成基于Java的配置></a>2.1.12.5、组成基于Java的配置</h4><h5 id=使用-Import注释><a class=headerlink href=#使用-Import注释 title=使用@Import注释></a>使用<code>@Import</code>注释</h5><p>就像 Spring XML 文件中使用<code>&LTimport/></code>元素来帮助模块化配置一样，<code>@Import</code>注解 允许从另一个配置类中加载<code>@Bean</code>定义，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ConfigA</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> A <span class="title function_">a</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">A</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@Import(ConfigA.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ConfigB</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> B <span class="title function_">b</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">B</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>现在，无需在实例化上下文时同时指定<code>ConfigA.class</code>和<code>ConfigB.class</code>，只需显式提供<code>ConfigB</code>，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=type>ApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ConfigB.class);</span><br><span class=line>    <span class=comment>// now both beans A and B will be available...</span></span><br><span class=line>    <span class=type>A</span> <span class=variable>a</span> <span class=operator>=</span> ctx.getBean(A.class);</span><br><span class=line>    <span class=type>B</span> <span class=variable>b</span> <span class=operator>=</span> ctx.getBean(B.class);</span><br><span class=line>}</span><br></pre></table></figure> <p>这种方法简化了容器的实例化，因为只需要处理一个类，而不是要求您在构造过程中记住大量的<code>@Configuration</code>类。</p> <blockquote><p>从Spring Framework 4.2开始，<code>@Import</code>还支持对常规组件类的引用，类似于该<code>AnnotationConfigApplicationContext.register</code>方法。如果要通过使用一些配置类作为入口点来显式定义所有组件，从而避免组件扫描，则此功能特别有用。</blockquote> <h6 id=注入对导入-Bean定义的依赖><a class=headerlink href=#注入对导入-Bean定义的依赖 title=注入对导入@Bean定义的依赖></a>注入对导入<code>@Bean</code>定义的依赖</h6><p>考虑以下具有多个<code>@Configuration</code> 类的更真实的场景，每个类都取决于其他类中声明的bean：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ServiceConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> TransferService <span class="title function_">transferService</span><span class=params>(AccountRepository accountRepository)</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">TransferServiceImpl</span>(accountRepository);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RepositoryConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> AccountRepository <span class="title function_">accountRepository</span><span class=params>(DataSource dataSource)</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">JdbcAccountRepository</span>(dataSource);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@Import({ServiceConfig.class, RepositoryConfig.class})</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SystemTestConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> DataSource <span class="title function_">dataSource</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// return new DataSource</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=type>ApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SystemTestConfig.class);</span><br><span class=line>    <span class=comment>// everything wires up across configuration classes...</span></span><br><span class=line>    <span class=type>TransferService</span> <span class=variable>transferService</span> <span class=operator>=</span> ctx.getBean(TransferService.class);</span><br><span class=line>    transferService.transfer(<span class=number>100.00</span>, <span class=string>"A123"</span>, <span class=string>"C456"</span>);</span><br><span class=line>}</span><br></pre></table></figure> <p>还有另一种方法可以达到相同的结果。请记住，<code>@Configuration</code>类最终仅是容器中的另一个 bean：这意味着它们可以利用<code>@Autowired</code>和<code>@Value</code>注入以及与任何其他 bean 相同的其他功能。</p> <p>以下示例说明如何将一个bean自动连接到另一个bean：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ServiceConfig</span> {</span><br><span class=line></span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> AccountRepository accountRepository;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> TransferService <span class="title function_">transferService</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">TransferServiceImpl</span>(accountRepository);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RepositoryConfig</span> {</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> DataSource dataSource;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RepositoryConfig</span><span class=params>(DataSource dataSource)</span> {</span><br><span class=line>        <span class=built_in>this</span>.dataSource = dataSource;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> AccountRepository <span class="title function_">accountRepository</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">JdbcAccountRepository</span>(dataSource);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@Import({ServiceConfig.class, RepositoryConfig.class})</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SystemTestConfig</span> {</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> DataSource <span class="title function_">dataSource</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// return new DataSource</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=type>ApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SystemTestConfig.class);</span><br><span class=line>    <span class=comment>// everything wires up across configuration classes...</span></span><br><span class=line>    <span class=type>TransferService</span> <span class=variable>transferService</span> <span class=operator>=</span> ctx.getBean(TransferService.class);</span><br><span class=line>    transferService.transfer(<span class=number>100.00</span>, <span class=string>"A123"</span>, <span class=string>"C456"</span>);</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=有条件地包含-Configuration类或-Bean方法><a class=headerlink href=#有条件地包含-Configuration类或-Bean方法 title=有条件地包含@Configuration类或@Bean方法></a>有条件地包含@Configuration类或@Bean方法</h5><p>基于某些任意系统状态，有条件地启用或禁用完整的<code>@Configuration</code>类甚至单个<code>@Bean</code>方法通常很有用。一个常见的示例是仅在 Spring <code>Environment</code>中启用了特定概要文件时才使用<code>@Profile</code>注解 来激活 bean(有关详细信息，请参见<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-definition-profiles rel=noopener target=_blank>Bean 定义配置文件</a>)。</p> <p><code>Condition</code>接口的实现提供了一个<code>matches(…)</code>方法，该方法返回<code>true</code>或<code>false</code>。例如，以下清单显示了用于<code>@Profile</code>的实际<code>Condition</code>实现：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">matches</span><span class=params>(ConditionContext context, AnnotatedTypeMetadata metadata)</span> {</span><br><span class=line>    <span class=comment>// Read the @Profile annotation attributes</span></span><br><span class=line>    MultiValueMap&LTString, Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());</span><br><span class=line>    <span class=keyword>if</span> (attrs != <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>for</span> (Object value : attrs.get(<span class=string>"value"</span>)) {</span><br><span class=line>            <span class=keyword>if</span> (context.getEnvironment().acceptsProfiles(((String[]) value))) {</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=结合Java和XML配置><a class=headerlink href=#结合Java和XML配置 title=结合Java和XML配置></a>结合Java和XML配置</h5><p>pring的<code>@Configuration</code>类支持并不旨在100％完全替代Spring XML。某些工具（例如Spring XML名称空间）仍然是配置容器的理想方法。在使用XML方便或必要的情况下，您可以选择：通过使用<code>ClassPathXmlApplicationContext</code>以“以 XML 为中心”的方式实例化容器，或通过使用<code>AnnotationConfigApplicationContext</code>和以“以 Java 为中心”的方式实例化容器。 <code>@ImportResource</code>注解 以根据需要导入 XML。</p> <h6 id=以XML为中心的-Configuration类使用><a class=headerlink href=#以XML为中心的-Configuration类使用 title=以XML为中心的@Configuration类使用></a>以XML为中心的<code>@Configuration</code>类使用</h6><ul><li><p>将<code>@Configuration</code>类声明为纯Spring<code>&LTbean/></code>元素</p> <p>请记住，<code>@Configuration</code>类最终是容器中的 bean 定义。在本系列示例中，我们创建一个名为<code>AppConfig</code>的<code>@Configuration</code>类，并将其作为<code>&LTbean/></code>定义包含在<code>system-test-config.xml</code>中。由于<code>&LTcontext:annotation-config/></code>已打开，因此容器会识别<code>@Configuration</code>注解并正确处理<code>AppConfig</code>中声明的<code>@Bean</code>方法。</p> <p>以下示例显示了Java中的普通配置类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> DataSource dataSource;</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> AccountRepository <span class="title function_">accountRepository</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">JdbcAccountRepository</span>(dataSource);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> TransferService <span class="title function_">transferService</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">TransferService</span>(accountRepository());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>以下示例显示了示例<code>system-test-config.xml</code>文件的一部分：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=comment>&LT!-- enable processing of annotations such as @Autowired and @Configuration --></span></span><br><span class=line>    <span class=tag><<span class=name>context:annotation-config</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>context:property-placeholder</span> <span class=attr>location</span>=<span class=string>"classpath:/com/acme/jdbc.properties"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"com.acme.AppConfig"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"url"</span> <span class=attr>value</span>=<span class=string>"${jdbc.url}"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"username"</span> <span class=attr>value</span>=<span class=string>"${jdbc.username}"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"password"</span> <span class=attr>value</span>=<span class=string>"${jdbc.password}"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>以下示例显示了一个可能的<code>jdbc.properties</code>文件：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>jdbc.url = jdbc：hsqldb：hsql：// localhost / xdb </span><br><span class=line>jdbc.username = sa </span><br><span class=line>jdbc.password =</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=type>ApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class=string>"classpath:/com/acme/system-test-config.xml"</span>);</span><br><span class=line>    <span class=type>TransferService</span> <span class=variable>transferService</span> <span class=operator>=</span> ctx.getBean(TransferService.class);</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><li><p>使用&LTcontext：component-scan />拾取<code>@Configuration</code>类</p> <p>因为<code>@Configuration</code>使用<code>@Component</code>进行元 注解，所以<code>@Configuration</code>注解 的类自动成为组件扫描的候选对象。使用与上一个示例中描述的场景相同的场景，我们可以重新定义<code>system-test-config.xml</code>以利用组件扫描的优势。请注意，在这种情况下，我们无需显式声明<code>&LTcontext:annotation-config/></code>，因为<code>&LTcontext:component-scan/></code>启用相同的功能。</p> <p>以下示例显示了修改后的<code>system-test-config.xml</code>文件：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=comment>&LT!-- picks up and registers AppConfig as a bean definition --></span></span><br><span class=line>    <span class=tag><<span class=name>context:component-scan</span> <span class=attr>base-package</span>=<span class=string>"com.acme"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>context:property-placeholder</span> <span class=attr>location</span>=<span class=string>"classpath:/com/acme/jdbc.properties"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"url"</span> <span class=attr>value</span>=<span class=string>"${jdbc.url}"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"username"</span> <span class=attr>value</span>=<span class=string>"${jdbc.username}"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"password"</span> <span class=attr>value</span>=<span class=string>"${jdbc.password}"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure><li><p>@Configuration 以类为中心的XML与使用 @ImportResource</p> <p>在<code>@Configuration</code>类是配置容器的主要机制的应用程序中，仍然有必要至少使用一些XML。在这些情况下，您可以使用<code>@ImportResource</code>并仅定义所需的 XML。这样做实现了“以 Java 为中心”的方法来配置容器，并将 XML 保持在最低限度。以下示例(包括配置类，定义 Bean 的 XML 文件，属性文件和<code>main</code>类)显示了如何使用<code>@ImportResource</code>注解 来实现按需使用 XML 的“以 Java 为中心”的配置：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@ImportResource("classpath:/com/acme/properties-config.xml")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Value("${jdbc.url}")</span></span><br><span class=line>    <span class=keyword>private</span> String url;</span><br><span class=line>    <span class=meta>@Value("${jdbc.username}")</span></span><br><span class=line>    <span class=keyword>private</span> String username;</span><br><span class=line>    <span class=meta>@Value("${jdbc.password}")</span></span><br><span class=line>    <span class=keyword>private</span> String password;</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> DataSource <span class="title function_">dataSource</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">DriverManagerDataSource</span>(url, username, password);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>----properties-config.xml----</span><br><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>context:property-placeholder</span> <span class=attr>location</span>=<span class=string>"classpath:/com/acme/jdbc.properties"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=attr>----jdbc.properties----</span></span><br><span class=line><span class=attr>jdbc.url</span> = <span class=string>jdbc：hsqldb：hsql：// localhost / xdb </span></span><br><span class=line><span class=attr>jdbc.username</span> = <span class=string>sa </span></span><br><span class=line><span class=attr>jdbc.password</span> =<span class=string></span></span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=type>ApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class=line>    <span class=type>TransferService</span> <span class=variable>transferService</span> <span class=operator>=</span> ctx.getBean(TransferService.class);</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure></ul> <h3 id=2-1-13、抽象环境><a class=headerlink href=#2-1-13、抽象环境 title=2.1.13、抽象环境></a>2.1.13、抽象环境</h3><p><a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/env/Environment.html rel=noopener target=_blank>Environment</a>接口是集成在容器中的抽象，用于对应用程序环境的两个关键方面进行建模：<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-definition-profiles rel=noopener target=_blank>profiles</a>和<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-property-source-abstraction rel=noopener target=_blank>properties</a>。</p> <h4 id=2-1-13-1、Bean定义配置文件><a class=headerlink href=#2-1-13-1、Bean定义配置文件 title=2.1.13.1、Bean定义配置文件></a>2.1.13.1、Bean定义配置文件</h4><p>Bean定义配置文件在核心容器中提供了一种机制，该机制允许在不同环境中注册不同的Bean。“环境”一词对不同的用户而言可能意味着不同的含义，并且此功能可以在许多用例中提供帮助，包括：</p> <ul><li>在开发中针对内存中的数据源进行工作，而不是在进行QA或生产时从JNDI查找相同的数据源。<li>仅在将应用程序部署到性能环境中时注册监视基础结构。<li>为客户A和客户B部署注册bean的自定义实现。</ul> <p>考虑实际应用中需要<code>DataSource</code>的第一个用例。在测试环境中，配置可能类似于以下内容：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> DataSource <span class="title function_">dataSource</span><span class=params>()</span> {</span><br><span class=line>    <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">EmbeddedDatabaseBuilder</span>()</span><br><span class=line>        .setType(EmbeddedDatabaseType.HSQL)</span><br><span class=line>        .addScript(<span class=string>"my-schema.sql"</span>)</span><br><span class=line>        .addScript(<span class=string>"my-test-data.sql"</span>)</span><br><span class=line>        .build();</span><br><span class=line>}</span><br></pre></table></figure> <p>现在，假设该应用程序的数据源已在生产应用程序服务器的JNDI目录中注册，请考虑如何将该应用程序部署到QA或生产环境中。现在，我们的<code>dataSource</code> bean 看起来像下面的清单：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean(destroyMethod="")</span></span><br><span class=line><span class=keyword>public</span> DataSource <span class="title function_">dataSource</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>    <span class=type>Context</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">InitialContext</span>();</span><br><span class=line>    <span class=keyword>return</span> (DataSource) ctx.lookup(<span class=string>"java:comp/env/jdbc/datasource"</span>);</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=使用-Profile><a title="使用 @Profile" class=headerlink href=#使用-Profile></a>使用 @Profile</h5><p><a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/annotation/Profile.html rel=noopener target=_blank>@Profile</a>注解 使您可以指示一个或多个指定配置文件处于活动状态时有资格注册的组件。使用前面的示例，我们可以如下重写<code>dataSource</code>配置：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>@Configuration</span><br><span class=line>@Profile("development")</span><br><span class=line>public class StandaloneDataConfig {</span><br><span class=line>    @Bean</span><br><span class=line>    public DataSource dataSource() {</span><br><span class=line>        return new EmbeddedDatabaseBuilder()</span><br><span class=line>            .setType(EmbeddedDatabaseType.HSQL)</span><br><span class=line>            .addScript("classpath:com/bank/config/sql/schema.sql")</span><br><span class=line>            .addScript("classpath:com/bank/config/sql/test-data.sql")</span><br><span class=line>            .build();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@Profile("production")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">JndiDataConfig</span> {</span><br><span class=line>    <span class=meta>@Bean(destroyMethod="")</span></span><br><span class=line>    <span class=keyword>public</span> DataSource <span class="title function_">dataSource</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>Context</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">InitialContext</span>();</span><br><span class=line>        <span class=keyword>return</span> (DataSource) ctx.lookup(<span class=string>"java:comp/env/jdbc/datasource"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>配置文件字符串可以包含简单的配置文件名称（例如<code>production</code>）或配置文件表达式。配置文件表达式允许表达更复杂的配置文件逻辑（例如<code>production & us-east</code>）。概要文件表达式中支持以下运算符：</p> <ul><li><code>!</code>：配置文件的逻辑“非”<li><code>&</code>：配置文件的逻辑“与”<li><code>|</code>：配置文件的逻辑“或”</ul> <p>您可以将其<code>@Profile</code>用作<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-meta-annotations rel=noopener target=_blank>元注释</a>，以创建自定义的组合注释。以下示例定义了一个自定义 <code>@Production</code>批注，您可以将其用作 <code>@Profile("production")</code>的替代品：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Target(ElementType.TYPE)</span></span><br><span class=line><span class=meta>@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=line><span class=meta>@Profile("production")</span></span><br><span class=line><span class=keyword>public</span> <span class=meta>@interface</span> Production {</span><br><span class=line>}</span><br></pre></table></figure> <p><code>@Profile</code> 也可以在方法级别声明为仅包含配置类的一个特定Bean（例如，特定Bean的替代变体），如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean("dataSource")</span></span><br><span class=line>    <span class=meta>@Profile("development")</span> </span><br><span class=line>    <span class=keyword>public</span> DataSource <span class="title function_">standaloneDataSource</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">EmbeddedDatabaseBuilder</span>()</span><br><span class=line>            .setType(EmbeddedDatabaseType.HSQL)</span><br><span class=line>            .addScript(<span class=string>"classpath:com/bank/config/sql/schema.sql"</span>)</span><br><span class=line>            .addScript(<span class=string>"classpath:com/bank/config/sql/test-data.sql"</span>)</span><br><span class=line>            .build();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Bean("dataSource")</span></span><br><span class=line>    <span class=meta>@Profile("production")</span> </span><br><span class=line>    <span class=keyword>public</span> DataSource <span class="title function_">jndiDataSource</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>Context</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">InitialContext</span>();</span><br><span class=line>        <span class=keyword>return</span> (DataSource) ctx.lookup(<span class=string>"java:comp/env/jdbc/datasource"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <ul><li><strong>(1)</strong> <code>standaloneDataSource</code>方法仅在<code>development</code>Profile 中可用。<li><strong>(2)</strong> <code>jndiDataSource</code>方法仅在<code>production</code>Profile 中可用。</ul> <h5 id=XML-Bean定义配置文件><a title="XML Bean定义配置文件" class=headerlink href=#XML-Bean定义配置文件></a>XML Bean定义配置文件</h5><p>XML 对应项是<code>&LTbeans></code>元素的<code>profile</code>属性。我们前面的示例配置可以用两个 XML 文件重写，如下所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>profile</span>=<span class=string>"development"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:jdbc</span>=<span class=string>"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"..."</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>jdbc:embedded-database</span> <span class=attr>id</span>=<span class=string>"dataSource"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>jdbc:script</span> <span class=attr>location</span>=<span class=string>"classpath:com/bank/config/sql/schema.sql"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>jdbc:script</span> <span class=attr>location</span>=<span class=string>"classpath:com/bank/config/sql/test-data.sql"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>jdbc:embedded-database</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>profile</span>=<span class=string>"production"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:jee</span>=<span class=string>"http://www.springframework.org/schema/jee"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"..."</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>jee:jndi-lookup</span> <span class=attr>id</span>=<span class=string>"dataSource"</span> <span class=attr>jndi-name</span>=<span class=string>"java:comp/env/jdbc/datasource"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>也可以避免在同一文件中拆分和嵌套<code>&LTbeans/></code>元素，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:jdbc</span>=<span class=string>"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:jee</span>=<span class=string>"http://www.springframework.org/schema/jee"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"..."</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- other bean definitions --></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>beans</span> <span class=attr>profile</span>=<span class=string>"development"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>jdbc:embedded-database</span> <span class=attr>id</span>=<span class=string>"dataSource"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>jdbc:script</span> <span class=attr>location</span>=<span class=string>"classpath:com/bank/config/sql/schema.sql"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>jdbc:script</span> <span class=attr>location</span>=<span class=string>"classpath:com/bank/config/sql/test-data.sql"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>jdbc:embedded-database</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>beans</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>beans</span> <span class=attr>profile</span>=<span class=string>"production"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>jee:jndi-lookup</span> <span class=attr>id</span>=<span class=string>"dataSource"</span> <span class=attr>jndi-name</span>=<span class=string>"java:comp/env/jdbc/datasource"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>beans</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p><code>spring-bean.xsd</code>已被限制为仅允许这些元素作为文件中的最后一个元素。这应该有助于提供灵 Active，而不会引起 XML 文件混乱。</p> <h5 id=激活Profile><a class=headerlink href=#激活Profile title=激活Profile></a>激活Profile</h5><p>可以通过多种方式来激活配置文件，但是最直接的方法是针对通过<code>ApplicationContext</code>可用的<code>Environment</code> API 以编程方式进行配置。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=type>AnnotationConfigApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class=line>ctx.getEnvironment().setActiveProfiles(<span class=string>"development"</span>);</span><br><span class=line>ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);</span><br><span class=line>ctx.refresh();</span><br></pre></table></figure> <p>此外，您还可以通过<code>spring.profiles.active</code>属性以声明方式激活概要文件，该属性可以通过系统环境变量，JVM 系统属性，<code>web.xml</code>中的 servlet 上下文参数来指定，甚至可以作为 JNDI 中的条目来指定(请参阅<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-property-source-abstraction rel=noopener target=_blank>PropertySource Abstraction</a>)。在集成测试中，可以使用<code>spring-test</code>模块中的<code>@ActiveProfiles</code>注解来声明活动配置文件(请参阅<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/testing.html#testcontext-ctx-management-env-profiles rel=noopener target=_blank>使用环境配置文件进行上下文配置</a>)。</p> <p>请注意，配置文件不是“非此即彼”的命题。您可以一次激活多个配置文件。您可以通过编程方式为<code>setActiveProfiles()</code>方法提供多个配置文件名称，该方法接受<code>String…</code> varargs。以下示例激活多个配置文件：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>ctx.getEnvironment().setActiveProfiles(<span class=string>"profile1"</span>, <span class=string>"profile2"</span>);</span><br></pre></table></figure> <p>以声明方式，<code>spring.profiles.active</code>可以接受以逗号分隔的配置文件名称列表，如以下示例所示：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-Dspring.profiles.active=<span class=string>"profile1,profile2"</span></span><br></pre></table></figure> <h5 id=默认配置文件><a class=headerlink href=#默认配置文件 title=默认配置文件></a>默认配置文件</h5><p>默认配置文件表示默认情况下启用的配置文件。考虑以下示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@Profile("default")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DefaultDataConfig</span> {</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> DataSource <span class="title function_">dataSource</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">EmbeddedDatabaseBuilder</span>()</span><br><span class=line>            .setType(EmbeddedDatabaseType.HSQL)</span><br><span class=line>            .addScript(<span class=string>"classpath:com/bank/config/sql/schema.sql"</span>)</span><br><span class=line>            .build();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>如果没有配置文件处于活动状态，则将<code>dataSource</code>创建。您可以看到这是为一个或多个bean提供默认定义的一种方法。如果启用了任何配置文件，则默认配置文件不适用。</p> <p>您可以通过在<code>Environment</code>上使用<code>setDefaultProfiles()</code>或pass 语句<code>spring.profiles.default</code>属性来更改默认配置文件的名称。</p> <h4 id=2-1-13-2、PropertySource抽象><a class=headerlink href=#2-1-13-2、PropertySource抽象 title=2.1.13.2、PropertySource抽象></a>2.1.13.2、<code>PropertySource</code>抽象</h4><p>Spring的<code>Environment</code>抽象提供了可配置属性源层次结构上的搜索操作。考虑以下清单：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=type>ApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">GenericApplicationContext</span>();</span><br><span class=line><span class=type>Environment</span> <span class=variable>env</span> <span class=operator>=</span> ctx.getEnvironment();</span><br><span class=line><span class=type>boolean</span> <span class=variable>containsMyProperty</span> <span class=operator>=</span> env.containsProperty(<span class=string>"my-property"</span>);</span><br><span class=line>System.out.println(<span class=string>"Does my environment contain the 'my-property' property? "</span> + containsMyProperty);</span><br></pre></table></figure> <p>在前面的代码片段中，我们看到了一种询问 Spring 是否为当前环境定义<code>my-property</code>属性的高级方法。为了回答这个问题，<code>Environment</code>对象对一组<a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/env/PropertySource.html rel=noopener target=_blank>PropertySource</a>对象执行搜索。 <code>PropertySource</code>是对任何键-值对源的简单抽象，而 Spring 的<a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/core/env/StandardEnvironment.html rel=noopener target=_blank>StandardEnvironment</a>配置了两个 PropertySource 对象-一个代表 JVM 系统属性集(<code>System.getProperties()</code>)和一个代表系统环境变量集(<code>System.getenv()</code>)。</p> <p>具体来说，当您使用<code>StandardEnvironment</code>时，如果在运行时存在<code>my-property</code>系统属性或<code>my-propertyi</code>环境变量，则对<code>env.containsProperty("my-property")</code>的调用将返回 true。</p> <h4 id=2-1-13-3。使用-PropertySource><a class=headerlink href=#2-1-13-3。使用-PropertySource title=2.1.13.3。使用@PropertySource></a>2.1.13.3。使用<code>@PropertySource</code></h4><p><a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html rel=noopener target=_blank>@PropertySource</a>注解 为将<code>PropertySource</code>添加到 Spring 的<code>Environment</code>提供了一种方便的声明性机制。</p> <p>给定名为<code>app.properties</code>的文件，其中包含键值对<code>testbean.name=myTestBean</code>，以下<code>@Configuration</code>类使用<code>@PropertySource</code>，从而对<code>testBean.getName()</code>的调用返回<code>myTestBean</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@PropertySource("classpath:/com/myco/app.properties")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    Environment env;</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> TestBean <span class="title function_">testBean</span><span class=params>()</span> {</span><br><span class=line>        <span class=type>TestBean</span> <span class=variable>testBean</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TestBean</span>();</span><br><span class=line>        testBean.setName(env.getProperty(<span class=string>"testbean.name"</span>));</span><br><span class=line>        <span class=keyword>return</span> testBean;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>资源位置中<code>${…}</code>存在的所有占位符<code>@PropertySource</code>都是根据已经针对环境注册的一组属性源来解析的，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@PropertySource("classpath:/com/${my.placeholder:default/path}/app.properties")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    Environment env;</span><br><span class=line>    <span class=meta>@Bean</span></span><br><span class=line>    <span class=keyword>public</span> TestBean <span class="title function_">testBean</span><span class=params>()</span> {</span><br><span class=line>        <span class=type>TestBean</span> <span class=variable>testBean</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TestBean</span>();</span><br><span class=line>        testBean.setName(env.getProperty(<span class=string>"testbean.name"</span>));</span><br><span class=line>        <span class=keyword>return</span> testBean;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>假定<code>my.placeholder</code>存在于已注册的属性源之一（例如，系统属性或环境变量）中，则占位符将解析为相应的值。如果不是，则<code>default/path</code>用作默认值。如果未指定默认值并且无法解析属性， 则会引发<code>IllegalArgumentException</code>。</p> <h4 id=2-1-13-4。声明中的占位符解析><a class=headerlink href=#2-1-13-4。声明中的占位符解析 title=2.1.13.4。声明中的占位符解析></a>2.1.13.4。声明中的占位符解析</h4><p>从历史上看，元素中占位符的值只能根据 JVM 系统属性或环境变量来解析。这已不再是这种情况。由于<code>Environment</code>抽象集成在整个容器中，因此很容易通过它路由占位符的解析。这意味着您可以按照自己喜欢的任何方式配置解析过程。您可以更改搜索系统属性和环境变量的优先级，也可以完全删除它们。您还可以根据需要将自己的属性源添加到组合中。</p> <p>具体来说，只要在<code>Environment</code>中可用，以下语句无论在<code>customer</code>属性的定义位置如何都有效：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>import</span> <span class=attr>resource</span>=<span class=string>"com/bank/service/${customer}-config.xml"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h3 id=2-1-14、注册一个LoadTimeWeaver><a class=headerlink href=#2-1-14、注册一个LoadTimeWeaver title=2.1.14、注册一个LoadTimeWeaver></a>2.1.14、注册一个LoadTimeWeaver</h3><p><code>LoadTimeWeaver</code>被 Spring 使用，以在将类加载到 Java 虚拟机(JVM)中时对其进行动态转换。</p> <p>要启用加载时编织，可以将<code>@EnableLoadTimeWeaving</code>添加到<code>@Configuration</code>类之一，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableLoadTimeWeaving</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>}</span><br></pre></table></figure> <p>另外，对于XML配置，可以使用<code>context:load-time-weaver</code>元素：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>context:load-time-weaver</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>一旦为<code>ApplicationContext</code>配置，该<code>ApplicationContext</code>内的任何 bean 都可以实现<code>LoadTimeWeaverAware</code>，从而接收到对加载时编织器实例的引用。</p> <h3 id=2-1-15、ApplicationContext的其它功能><a class=headerlink href=#2-1-15、ApplicationContext的其它功能 title=2.1.15、ApplicationContext的其它功能></a>2.1.15、ApplicationContext的其它功能</h3><ul><li>为了以更面向框架的方式增强<code>BeanFactory</code>功能，上下文包还提供以下功能：<ul><li>通过<code>MessageSource</code>界面访问 i18n 样式的消息。<li>通过<code>ResourceLoader</code>界面访问资源，例如 URL 和文件。<li>事件发布，即通过使用<code>ApplicationEventPublisher</code>接口发布给实现<code>ApplicationListener</code>接口的 bean。<li>加载多个(分层)上下文，使每个上下文都通过<code>HierarchicalBeanFactory</code>接口集中在一个特定的层上，例如应用程序的 Web 层。</ul></ul> <h4 id=2-1-15-1、使用MessageSource进行国际化><a class=headerlink href=#2-1-15-1、使用MessageSource进行国际化 title=2.1.15.1、使用MessageSource进行国际化></a>2.1.15.1、使用MessageSource进行国际化</h4><p><code>plicationContext</code>接口扩展了名为<code>MessageSource</code>的接口，因此提供了国际化(“ i18n”)功能。 Spring 还提供了<code>HierarchicalMessageSource</code>接口，该接口可以分层解析消息。这些接口一起提供了 Spring 影响消息解析的基础。这些接口上定义的方法包括：</p> <ul><li><code>String getMessage(String code, Object[] args, String default, Locale loc)</code>：用于从<code>MessageSource</code>检索消息的基本方法。如果找不到针对指定语言环境的消息，则使用默认消息。使用标准库提供的<code>MessageFormat</code>功能，传入的所有参数都将成为替换值。<li><code>String getMessage(String code, Object[] args, Locale loc)</code>：与以前的方法基本相同，但有一个区别：不能指定默认消息。如果找不到该消息，则抛出<code>NoSuchMessageException</code>。<li><code>String getMessage(MessageSourceResolvable resolvable, Locale locale)</code>：前面方法中使用的所有属性也都包装在名为<code>MessageSourceResolvable</code>的类中，您可以将其与该方法一起使用。</ul> <p>Spring提供了两种<code>MessageSource</code>实现，<code>ResourceBundleMessageSource</code>和 <code>StaticMessageSource</code>。两者都实现<code>HierarchicalMessageSource</code>以便进行嵌套消息传递。 <code>StaticMessageSource</code>很少使用，但提供了将消息添加到源中的编程方式。以下示例显示<code>ResourceBundleMessageSource</code>：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"messageSource"</span> <span class=attr>class</span>=<span class=string>"org.springframework.context.support.ResourceBundleMessageSource"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"basenames"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>list</span>></span></span><br><span class=line>                <span class=tag><<span class=name>value</span>></span>format<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>                <span class=tag><<span class=name>value</span>></span>exceptions<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>                <span class=tag><<span class=name>value</span>></span>windows<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>list</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>该示例假定您在 Classpath 中定义了三个名为<code>format</code>，<code>exceptions</code>和<code>windows</code>的资源包。任何解析消息的请求都通过 JDK 标准的<code>ResourceBundle</code>对象解析消息来处理。就本示例而言，假定上述两个资源束文件的内容如下：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line># in format.properties</span><br><span class=line>message=Alligators rock!</span><br><span class=line></span><br><span class=line># in exceptions.properties</span><br><span class=line>argument.required=The {0} argument is required.</span><br></pre></table></figure> <p>下一个示例显示了执行<code>MessageSource</code>功能的程序。请记住，所有<code>ApplicationContext</code>实现也是<code>MessageSource</code>实现，因此可以转换为<code>MessageSource</code>接口。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>    <span class=type>MessageSource</span> <span class=variable>resources</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class=string>"beans.xml"</span>);</span><br><span class=line>    <span class=type>String</span> <span class=variable>message</span> <span class=operator>=</span> resources.getMessage(<span class=string>"message"</span>, <span class=literal>null</span>, <span class=string>"Default"</span>, <span class=literal>null</span>);</span><br><span class=line>    System.out.println(message);</span><br><span class=line>}</span><br></pre></table></figure> <p>下一个示例显示了传递给消息查找的参数。这些参数将转换为<code>String</code>对象，并插入到查找消息中的占位符中。</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span>></span></span><br><span class=line>    <span class=comment>&LT!-- this MessageSource is being used in a web application --></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"messageSource"</span> <span class=attr>class</span>=<span class=string>"org.springframework.context.support.ResourceBundleMessageSource"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"basename"</span> <span class=attr>value</span>=<span class=string>"exceptions"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=comment>&LT!-- lets inject the above MessageSource into this POJO --></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"example"</span> <span class=attr>class</span>=<span class=string>"com.something.Example"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"messages"</span> <span class=attr>ref</span>=<span class=string>"messageSource"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>在以下示例中，手动指定了针对其解析（英国）消息的语言环境：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>＃在exceptions_en_GB.properties </span><br><span class=line>parameter.required = Ebagum lad中，“ {0}”自变量是必需的，我说是必需的。</span><br></pre></table></figure> <p>您还可以使用<code>MessageSourceAware</code>界面获取对已定义的任何<code>MessageSource</code>的引用。创建和配置 Bean 时，在实现<code>MessageSourceAware</code>接口的<code>ApplicationContext</code>中定义的任何 Bean 都会被注入应用程序上下文的<code>MessageSource</code>。</p> <h4 id=2-1-15-2、标准和自定义事件><a class=headerlink href=#2-1-15-2、标准和自定义事件 title=2.1.15.2、标准和自定义事件></a>2.1.15.2、标准和自定义事件</h4><p><code>ApplicationContext</code>中的事件处理是通过<code>ApplicationEvent</code>类和<code>ApplicationListener</code>接口提供的。如果将实现<code>ApplicationListener</code>接口的 bean 部署到上下文中，则每次将<code>ApplicationEvent</code>发布到<code>ApplicationContext</code>时，都会通知该 bean。本质上，这是标准的 Observer 设计模式。</p> <p>下表描述了Spring提供的标准事件：</p> <table><thead><tr><th align=left>事件<th align=left>说明<tbody><tr><td align=left><code>ContextRefreshedEvent</code><td align=left>在<code>ApplicationContext</code>初始化或刷新时发布（例如，通过使用接口<code>refresh()</code>上的方法<code>ConfigurableApplicationContext</code>）。在这里，“已初始化”表示已加载所有bean，检测到并激活了后处理器bean，预先实例化了单例，并且<code>ApplicationContext</code>可以使用该对象。只要尚未关闭上下文，就可以多次触发刷新，前提是所选对象<code>ApplicationContext</code>实际上支持这种“热”刷新。例如，<code>XmlWebApplicationContext</code>支持热刷新，但<code>GenericApplicationContext</code>不支持 。<tr><td align=left><code>ContextStartedEvent</code><td align=left><code>ApplicationContext</code>使用界面<code>start()</code>上的方法 启动时发布<code>ConfigurableApplicationContext</code>。在这里，“启动”意味着所有<code>Lifecycle</code> bean都收到一个明确的启动信号。通常，此信号用于在显式停止后重新启动Bean，但也可以用于启动尚未配置为自动启动的组件（例如，尚未在初始化时启动的组件）。<tr><td align=left><code>ContextStoppedEvent</code><td align=left><code>ApplicationContext</code>使用界面<code>stop()</code>上的方法 停止时发布<code>ConfigurableApplicationContext</code>。此处，“已停止”表示所有<code>Lifecycle</code> bean均收到明确的停止信号。停止的上下文可以通过<code>start()</code>调用重新启动 。<tr><td align=left><code>ContextClosedEvent</code><td align=left>当发布时间<code>ApplicationContext</code>是由使用封闭<code>close()</code>方法的上<code>ConfigurableApplicationContext</code>接口或经由JVM关闭挂钩。在这里，“封闭”意味着所有单例豆将被销毁。关闭上下文后，它将达到使用寿命，无法刷新或重新启动。<tr><td align=left><code>RequestHandledEvent</code><td align=left>一个特定于Web的事件，告诉所有Bean HTTP请求已得到服务。请求完成后，将发布此事件。此事件仅适用于使用Spring的Web应用程序<code>DispatcherServlet</code>。<tr><td align=left><code>ServletRequestHandledEvent</code><td align=left>它的子类<code>RequestHandledEvent</code>添加了特定于Servlet的上下文信息。</table> <p>您还可以创建和发布自己的自定义事件。下面的示例显示了一个简单的类，该类扩展了Spring的<code>ApplicationEvent</code>基类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BlockedListEvent</span> <span class=keyword>extends</span> <span class="title class_">ApplicationEvent</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> String address;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> String content;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">BlockedListEvent</span><span class=params>(Object source, String address, String content)</span>{</span><br><span class=line>        <span class=built_in>super</span>(source);</span><br><span class=line>        <span class=built_in>this</span>.address = address;</span><br><span class=line>        <span class=built_in>this</span>.content = content;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// accessor and other methods...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>要发布自定义<code>ApplicationEvent</code>，请在<code>ApplicationEventPublisher</code>上调用<code>publishEvent()</code>方法。通常，这是通过创建一个实现<code>ApplicationEventPublisherAware</code>的类并将其注册为 Spring bean 来完成的。以下示例显示了此类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">EmailService</span> <span class=keyword>implements</span> <span class="title class_">ApplicationEventPublisherAware</span> {</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> List&LTString> blockedList;</span><br><span class=line>    <span class=keyword>private</span> ApplicationEventPublisher publisher;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setBlockedList</span><span class=params>(List&LTString> blockedList)</span> {</span><br><span class=line>        <span class=built_in>this</span>.blockedList = blockedList;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setApplicationEventPublisher</span><span class=params>(ApplicationEventPublisher publisher)</span> {</span><br><span class=line>        <span class=built_in>this</span>.publisher = publisher;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">sendEmail</span><span class=params>(String address, String content)</span> {</span><br><span class=line>        <span class=keyword>if</span> (blockedList.contains(address)) {</span><br><span class=line>            publisher.publishEvent(<span class=keyword>new</span> <span class="title class_">BlockedListEvent</span>(<span class=built_in>this</span>, address, content));</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// send email...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>在配置时，Spring容器检测到该<code>EmailService</code>实现 <code>ApplicationEventPublisherAware</code>并自动调用 <code>setApplicationEventPublisher()</code>。实际上，传入的参数是Spring容器本身。您正在通过其<code>ApplicationEventPublisher</code>界面与应用程序上下文进行 交互。</p> <p>要接收自定义<code>ApplicationEvent</code>，您可以创建一个实现 <code>ApplicationListener</code>并注册为Spring bean的类。以下示例显示了此类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BlockedListNotifier</span> <span class=keyword>implements</span> <span class="title class_">ApplicationListener</span>&LTBlockedListEvent> {</span><br><span class=line>    <span class=keyword>private</span> String notificationAddress;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setNotificationAddress</span><span class=params>(String notificationAddress)</span> {</span><br><span class=line>        <span class=built_in>this</span>.notificationAddress = notificationAddress;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">onApplicationEvent</span><span class=params>(BlockedListEvent event)</span> {</span><br><span class=line>        <span class=comment>// notify appropriate parties via notificationAddress...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>注意，<code>ApplicationListener</code>通常用您的自定义事件的类型(上一示例中的<code>BlackListEvent</code>)进行参数化。这意味着<code>onApplicationEvent()</code>方法可以保持类型安全，从而避免了向下转换的任何需要。您可以根据需要注册任意数量的事件侦听器，但是请注意，默认情况下，事件侦听器会同步接收事件。这意味着<code>publishEvent()</code>方法将阻塞，直到所有侦听器都已完成对事件的处理为止。这种同步和单线程方法的一个优点是，当侦听器收到事件时，如果有可用的事务上下文，它将在发布者的事务上下文内部进行操作。</p> <p>以下示例显示了用于注册和配置上述每个类的Bean定义：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"emailService"</span> <span class=attr>class</span>=<span class=string>"example.EmailService"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"blockedList"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>list</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>known.spammer@example.org<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>known.hacker@example.org<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>john.doe@example.org<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>list</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"blockedListNotifier"</span> <span class=attr>class</span>=<span class=string>"example.BlockedListNotifier"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"notificationAddress"</span> <span class=attr>value</span>=<span class=string>"blockedlist@example.org"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>将所有内容放在一起，当调用<code>emailService</code> bean 的<code>sendEmail()</code>方法时，如果有任何电子邮件消息应列入黑名单，则会发布<code>BlackListEvent</code>类型的自定义事件。 <code>blackListNotifier</code> bean 注册为<code>ApplicationListener</code>并接收<code>BlackListEvent</code>，此时它可以通知适当的参与者。</p> <h5 id=基于注释的事件侦听器><a class=headerlink href=#基于注释的事件侦听器 title=基于注释的事件侦听器></a>基于注释的事件侦听器</h5><p>从Spring 4.2开始，您可以使用<code>@EventListener</code>注释在托管Bean的任何公共方法上注册事件侦听器。该<code>BlockedListNotifier</code>可改写如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BlockedListNotifier</span> {</span><br><span class=line>    <span class=keyword>private</span> String notificationAddress;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setNotificationAddress</span><span class=params>(String notificationAddress)</span> {</span><br><span class=line>        <span class=built_in>this</span>.notificationAddress = notificationAddress;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@EventListener</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">processBlockedListEvent</span><span class=params>(BlockedListEvent event)</span> {</span><br><span class=line>        <span class=comment>// notify appropriate parties via notificationAddress...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>方法签名再次声明其侦听的事件类型，但是这次使用灵活的名称并且没有实现特定的侦听器接口。只要实际事件类型在其实现层次结构中解析您的通用参数，也可以通过通用类型来缩小事件类型。</p> <p>如果您的方法应该侦听多个事件，或者您要完全不使用任何参数来定义它，则事件类型也可以在注解本身上指定。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">handleContextStart</span><span class=params>()</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>也可以通过使用定义<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions rel=noopener target=_blank>SpEL expression</a>的注解的<code>condition</code>属性来添加其他运行时过滤，该属性应匹配以针对特定事件实际调用该方法。</p> <p>以下示例显示了仅当事件的<code>content</code>属性等于<code>my-event</code>时，才可以重写我们的通知程序以进行调用：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@EventListener(condition = "#blEvent.content == 'my-event'")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">processBlockedListEvent</span><span class=params>(BlockedListEvent blockedListEvent)</span> {</span><br><span class=line>    <span class=comment>// notify appropriate parties via notificationAddress...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>每个<code>SpEL</code>表达式针对专用上下文进行评估。下表列出了可用于上下文的项目，以便您可以将它们用于条件事件处理：</p> <table><thead><tr><th align=left>名称<th align=left>位置<th align=left>描述<th align=left>例<tbody><tr><td align=left>Event<td align=left>root object<td align=left>实际的<code>ApplicationEvent</code>。<td align=left><code>#root.event</code> 要么 <code>event</code><tr><td align=left>Arguments array<td align=left>root object<td align=left>用于调用方法的参数（作为对象数组）。<td align=left><code>#root.args</code>或<code>args</code>; <code>args[0]</code>访问第一个参数，等等。<tr><td align=left>Argument name<td align=left>evaluation context<td align=left>任何方法参数的名称。如果由于某种原因这些名称不可用（例如，由于在编译的字节码中没有调试信息），则还可以使用<code>#a<#arg></code>其中<code><#arg></code>参数代表参数索引（从0开始）的语法提供各个参数。<td align=left><code>#blEvent</code>或<code>#a0</code>（您也可以使用<code>#p0</code>或<code>#p<#arg></code>参数符号作为别名）</table> <p>请注意，即使您的方法签名实际上引用了已发布的任意对象，<code>#root.event</code>也使您可以访问基础事件。</p> <p>如果由于处理另一个事件而需要发布一个事件，则可以更改方法签名以返回应发布的事件，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@EventListener</span></span><br><span class=line><span class=keyword>public</span> ListUpdateEvent <span class="title function_">handleBlockedListEvent</span><span class=params>(BlockedListEvent event)</span> {</span><br><span class=line>    <span class=comment>// notify appropriate parties via notificationAddress and</span></span><br><span class=line>    <span class=comment>// then publish a ListUpdateEvent...</span></span><br><span class=line>}</span><br></pre></table></figure> <blockquote><p><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-functionality-events-async rel=noopener target=_blank>异步侦听</a> 器不支持此功能 。</blockquote> <h5 id=异步侦听器><a class=headerlink href=#异步侦听器 title=异步侦听器></a>异步侦听器</h5><p>果希望特定的侦听器异步处理事件，则可以重用<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#scheduling-annotation-support-async rel=noopener target=_blank>常规@Async 支持</a>。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@EventListener</span></span><br><span class=line><span class=meta>@Async</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">processBlockedListEvent</span><span class=params>(BlockedListEvent event)</span> {</span><br><span class=line>    <span class=comment>// BlockedListEvent is processed in a separate thread</span></span><br><span class=line>}</span><br></pre></table></figure> <p>使用异步事件时，请注意以下限制：</p> <ul><li>如果事件监听器抛出<code>Exception</code>，则它不会传播到调用者。有关更多详细信息，请参见<code>AsyncUncaughtExceptionHandler</code>。<li>此类事件侦听器无法发送答复。如果您需要发送另一个事件作为处理结果，请注入<a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.html rel=noopener target=_blank>ApplicationEventPublisher</a>以手动发送事件。</ul> <h5 id=一般事件><a class=headerlink href=#一般事件 title=一般事件></a>一般事件</h5><p>您还可以使用泛型来进一步定义事件的结构。考虑使用 <code>EntityCreatedEvent&LTT></code>where<code>T</code>是创建的实际实体的类型。例如，您可以创建以下侦听器定义只接收<code>EntityCreatedEvent</code>了 <code>Person</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@EventListener</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">onPersonCreated</span><span class=params>(EntityCreatedEvent&LTPerson> event)</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>由于类型擦除，只有在触发的事件解析了事件侦听器所依据的通用参数(即诸如<code>class PersonCreatedEvent extends EntityCreatedEvent&LTPerson> { … }</code>)时，此方法才起作用。</p> <p>在某些情况下，如果所有事件都遵循相同的结构，这可能会变得很乏味(就像前面示例中的事件一样)。在这种情况下，您可以实现<code>ResolvableTypeProvider</code>以指导框架超出运行时环境提供的范围。以下事件显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">EntityCreatedEvent</span>&LTT> <span class=keyword>extends</span> <span class="title class_">ApplicationEvent</span> <span class=keyword>implements</span> <span class="title class_">ResolvableTypeProvider</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">EntityCreatedEvent</span><span class=params>(T entity)</span> {</span><br><span class=line>        <span class=built_in>super</span>(entity);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> ResolvableType <span class="title function_">getResolvableType</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource()));</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=2-1-15-3、方便地访问资源><a class=headerlink href=#2-1-15-3、方便地访问资源 title=2.1.15.3、方便地访问资源></a>2.1.15.3、方便地访问资源</h4><p>应用程序上下文是<code>ResourceLoader</code>，可用于加载<code>Resource</code>个对象。 <code>Resource</code>本质上是 JDK <code>java.net.URL</code>类的功能更丰富的版本。实际上，<code>Resource</code>的实现在适当的地方包装了<code>java.net.URL</code>的实例。 <code>Resource</code>可以从几乎任何位置以透明方式获取低级资源，包括从 Classpath，文件系统位置，可使用标准 URL 描述的任何位置以及其他一些变体。如果资源位置字符串是没有任何特殊前缀的简单路径，则这些资源的来源是特定的，并且适合于实际的应用程序上下文类型。</p> <h4 id=2-1-15-4、应用程序启动跟踪><a class=headerlink href=#2-1-15-4、应用程序启动跟踪 title=2.1.15.4、应用程序启动跟踪></a>2.1.15.4、应用程序启动跟踪</h4><p>该<code>ApplicationContext</code>管理器管理Spring应用程序的生命周期，并围绕组件提供丰富的编程模型。结果，复杂的应用程序可能具有同样复杂的组件图和启动阶段。</p> <p>使用特定的指标跟踪应用程序的启动步骤可以帮助您了解启动阶段所花的时间，但是它也可以用作更好地了解整个上下文生命周期的一种方式。</p> <p>的<code>AbstractApplicationContext</code>（及其子类）的仪表用 <code>ApplicationStartup</code>，它收集<code>StartupStep</code>有关各种启动阶段数据：</p> <ul><li>应用程序上下文生命周期（基本软件包扫描，配置类管理）<li>bean生命周期（实例化，智能初始化，后处理）<li>应用程序事件处理</ul> <p>这是在中的检测示例<code>AnnotationConfigApplicationContext</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment>// create a startup step and start recording</span></span><br><span class=line><span class=type>StartupStep</span> <span class=variable>scanPackages</span> <span class=operator>=</span> <span class=built_in>this</span>.getApplicationStartup().start(<span class=string>"spring.context.base-packages.scan"</span>);</span><br><span class=line><span class=comment>// add tagging information to the current step</span></span><br><span class=line>scanPackages.tag(<span class=string>"packages"</span>, () -> Arrays.toString(basePackages));</span><br><span class=line><span class=comment>// perform the actual phase we're instrumenting</span></span><br><span class=line><span class=built_in>this</span>.scanner.scan(basePackages);</span><br><span class=line><span class=comment>// end the current step</span></span><br><span class=line>scanPackages.end();</span><br></pre></table></figure> <p>应用程序上下文已通过多个步骤进行了检测。记录后，可以使用特定工具收集，显示和分析这些启动步骤。</p> <p>默认<code>ApplicationStartup</code>实现是无操作变体，以减少开销。这意味着默认情况下在应用程序启动期间不会收集任何指标。Spring Framework附带了一个用于使用Java Flight Recorder跟踪启动步骤的实现： <code>FlightRecorderApplicationStartup</code>。要使用此变体，必须<code>ApplicationContext</code>在创建后立即将其实例配置为。</p> <p>如果开发人员<code>ApplicationStartup</code>提供了自己的<code>AbstractApplicationContext</code>子类，或者希望收集更精确的数据，则也可以使用基础结构 。</p> <h4 id=2-1-15-5、Web应用程序的便捷><a class=headerlink href=#2-1-15-5、Web应用程序的便捷 title=2.1.15.5、Web应用程序的便捷></a>2.1.15.5、Web应用程序的便捷</h4><p>您可以使用<code>ContextLoader</code>声明性地创建<code>ApplicationContext</code>实例。当然，您也可以使用<code>ApplicationContext</code>实现之一以编程方式创建<code>ApplicationContext</code>实例。</p> <p>您可以使用<code>ContextLoaderListener</code>注册<code>ApplicationContext</code>，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>context-param</span>></span></span><br><span class=line>    <span class=tag><<span class=name>param-name</span>></span>contextConfigLocation<span class=tag>&LT/<span class=name>param-name</span>></span></span><br><span class=line>    <span class=tag><<span class=name>param-value</span>></span>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml<span class=tag>&LT/<span class=name>param-value</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>context-param</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>listener</span>></span></span><br><span class=line>    <span class=tag><<span class=name>listener-class</span>></span>org.springframework.web.context.ContextLoaderListener<span class=tag>&LT/<span class=name>listener-class</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>listener</span>></span></span><br></pre></table></figure> <p>侦听器检查<code>contextConfigLocation</code>参数。如果参数不存在，那么侦听器将使用<code>/WEB-INF/applicationContext.xml</code>作为默认值。当参数确实存在时，侦听器将使用 sched 义的定界符(逗号，分号和空格)来分隔<code>String</code>，并将这些值用作搜索应用程序上下文的位置。还支持 Ant 风格的路径模式。示例为<code>/WEB-INF/*Context.xml</code>(对于名称以<code>Context.xml</code>结尾并且位于<code>WEB-INF</code>目录中的所有文件)和<code>/WEB-INF/**/*Context.xml</code>(对于<code>WEB-INF</code>的任何子目录中的所有此类文件)。</p> <h4 id=2-1-15-6、将SpringApplicationContext部署为Java-EE-RAR文件><a title="2.1.15.6、将SpringApplicationContext部署为Java EE RAR文件" class=headerlink href=#2-1-15-6、将SpringApplicationContext部署为Java-EE-RAR文件></a>2.1.15.6、将SpringApplicationContext部署为Java EE RAR文件</h4><p>可以将 Spring <code>ApplicationContext</code>部署为 RAR 文件，并将上下文及其所有必需的 Bean 类和库 JAR 封装在 Java EE RAR 部署单元中。这等效于引导独立的<code>ApplicationContext</code>(仅托管在 Java EE 环境中)能够访问 Java EE 服务器功能。对于部署无头 WAR 文件的情况，RAR 部署是一种更自然的选择-实际上，这种 WAR 文件没有任何 HTTP 入口点，仅用于在 Java EE 环境中引导 Spring <code>ApplicationContext</code>。</p> <p>对于将 Spring ApplicationContext 作为 Java EE RAR 文件的简单部署：</p> <ol><li>将所有应用程序类打包到 RAR 文件(这是具有不同文件 extensions 的标准 JAR 文件)中。将所有必需的库 JAR 添加到 RAR 归档文件的根目录中。添加一个<code>META-INF/ra.xml</code>部署 Descriptors(如<a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html rel=noopener target=_blank>SpringContextResourceAdapter 的 javadoc</a>所示)和相应的 Spring XML bean 定义文件(通常为 META-INF/applicationContext.xml)。<li>将生成的 RAR 文件拖放到应用程序服务器的部署目录中。</ol> <h3 id=2-1-16、BeanFactory><a class=headerlink href=#2-1-16、BeanFactory title=2.1.16、BeanFactory></a>2.1.16、BeanFactory</h3><p><code>BeanFactory</code> API 为 Spring 的 IoC 功能提供了基础。它的特定 Contract 主要用于与 Spring 的其他部分以及相关的第三方框架集成，并且其<code>DefaultListableBeanFactory</code>实现是更高级别<code>GenericApplicationContext</code>容器中的关键委托。</p> <p>注意，核心<code>BeanFactory</code> API 级别及其<code>DefaultListableBeanFactory</code>实现不对配置格式或要使用的任何组件注解进行假设。所有这些风味都是通过 extensions(例如<code>XmlBeanDefinitionReader</code>和<code>AutowiredAnnotationBeanPostProcessor</code>)引入的，并以共享的<code>BeanDefinition</code>对象作为核心元数据表示形式进行操作。这就是使 Spring 的容器如此灵活和可扩展的本质。</p> <h4 id=2-1-16-1、BeanFactory还是ApplicationContext><a class=headerlink href=#2-1-16-1、BeanFactory还是ApplicationContext title=2.1.16.1、BeanFactory还是ApplicationContext></a>2.1.16.1、BeanFactory还是ApplicationContext</h4><p>除非有充分的理由，否则应使用<code>ApplicationContext</code>，除非<code>GenericApplicationContext</code>及其子类<code>AnnotationConfigApplicationContext</code>作为自定义引导的常见实现，否则应使用它们。对于所有常见目的，这些都是 Spring 核心容器的主要入口点：加载配置文件，触发 Classpath 扫描，以编程方式注册 Bean 定义和带注解的类，以及(从 5.0 版本开始)注册功能性 Bean 定义。</p> <p>因为<code>ApplicationContext</code>包含<code>BeanFactory</code>的所有功能，所以通常建议在纯<code>BeanFactory</code>上使用，除非需要完全控制 Bean 处理的情况。在<code>ApplicationContext</code>(例如<code>GenericApplicationContext</code>实现)内，按惯例(即，按 Bean 名称或 Bean 类型(尤其是后处理器))检测到几种 Bean，而普通的<code>DefaultListableBeanFactory</code>则与任何特殊的 Bean 无关。</p> <p>对于许多扩展的容器功能(例如注解处理和 AOP 代理)，<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-extension-bpp rel=noopener target=_blank>BeanPostProcessor 扩展点</a>是必不可少的。如果仅使用普通<code>DefaultListableBeanFactory</code>，则默认情况下不会检测到此类后处理器并将其激活。这种情况可能令人困惑，因为您的 bean 配置实际上并没有错。而是在这种情况下，需要通过其他设置完全引导容器。</p> <p>下表列出了<code>BeanFactory</code>and <code>ApplicationContext</code>接口和实现所提供的功能。</p> <table><thead><tr><th align=left>特征<th align=left><code>BeanFactory</code><th align=left><code>ApplicationContext</code><tbody><tr><td align=left>Bean实例化/接线<td align=left>是<td align=left>是<tr><td align=left>集成生命周期管理<td align=left>没有<td align=left>是<tr><td align=left>自动<code>BeanPostProcessor</code>注册<td align=left>没有<td align=left>是<tr><td align=left>自动<code>BeanFactoryPostProcessor</code>注册<td align=left>没有<td align=left>是<tr><td align=left>便捷<code>MessageSource</code>访问（用于内部化）<td align=left>没有<td align=left>是<tr><td align=left>内置<code>ApplicationEvent</code>发布机制<td align=left>没有<td align=left>是</table> <p>要使用<code>DefaultListableBeanFactory</code>显式注册 bean 后处理器，您需要以编程方式调用<code>addBeanPostProcessor</code>，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>DefaultListableBeanFactory</span> <span class=variable>factory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class=line>factory.addBeanPostProcessor(<span class=keyword>new</span> <span class="title class_">AutowiredAnnotationBeanPostProcessor</span>());</span><br><span class=line>factory.addBeanPostProcessor(<span class=keyword>new</span> <span class="title class_">MyBeanPostProcessor</span>());</span><br></pre></table></figure> <p>要将<code>BeanFactoryPostProcessor</code>应用于普通<code>DefaultListableBeanFactory</code>，需要调用其<code>postProcessBeanFactory</code>方法，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=type>DefaultListableBeanFactory</span> <span class=variable>factory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class=line><span class=type>XmlBeanDefinitionReader</span> <span class=variable>reader</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">XmlBeanDefinitionReader</span>(factory);</span><br><span class=line>reader.loadBeanDefinitions(<span class=keyword>new</span> <span class="title class_">FileSystemResource</span>(<span class=string>"beans.xml"</span>));</span><br><span class=line></span><br><span class=line><span class=type>PropertySourcesPlaceholderConfigurer</span> <span class=variable>cfg</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">PropertySourcesPlaceholderConfigurer</span>();</span><br><span class=line>cfg.setLocation(<span class=keyword>new</span> <span class="title class_">FileSystemResource</span>(<span class=string>"jdbc.properties"</span>));</span><br><span class=line></span><br><span class=line>cfg.postProcessBeanFactory(factory);</span><br></pre></table></figure> <p>在这两种情况下，显式的注册步骤都是不方便的，这就是为什么在 Spring 支持的应用程序中，各种<code>ApplicationContext</code>变体优于普通<code>DefaultListableBeanFactory</code>的原因，尤其是在典型企业设置中依靠<code>BeanFactoryPostProcessor</code>和<code>BeanPostProcessor</code>实例扩展容器功能时。</p> <blockquote><p><code>AnnotationConfigApplicationContext</code>已注册了所有通用注解后处理器，并且可以通过诸如<code>@EnableTransactionManagement</code>之类的配置注解在幕后引入其他处理器。在 Spring 基于注解的配置模型的抽象级别上，bean 后处理器的概念仅是内部容器详细信息。</blockquote> <h2 id=2-2、AOP-API><a title="2.2、AOP API" class=headerlink href=#2-2、AOP-API></a>2.2、AOP API</h2><h3 id=2-2-1、Spring中的Pointcut-API><a title="2.2.1、Spring中的Pointcut API" class=headerlink href=#2-2-1、Spring中的Pointcut-API></a>2.2.1、Spring中的Pointcut API</h3><h4 id=2-2-1-1、概念><a class=headerlink href=#2-2-1-1、概念 title=2.2.1.1、概念></a>2.2.1.1、概念</h4><p>Spring的切入点模型使切入点重用不受通知类型的影响。您可以使用相同的切入点来定位不同的建议。</p> <p>该<code>org.springframework.aop.Pointcut</code>接口是中央接口，用于将建议定向到特定的类和方法。完整的界面如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Pointcut</span> {</span><br><span class=line>    ClassFilter <span class="title function_">getClassFilter</span><span class=params>()</span>;</span><br><span class=line>    MethodMatcher <span class="title function_">getMethodMatcher</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>将<code>Pointcut</code>接口分为两部分，可以重用类和方法匹配的部分以及细粒度的合成操作（例如与另一个方法匹配器执行“联合”）。</p> <p>该<code>ClassFilter</code>接口用于将切入点限制为给定的一组目标类。如果该<code>matches()</code>方法始终返回true，则匹配所有目标类。以下清单显示了<code>ClassFilter</code>接口定义：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">ClassFilter</span> {</span><br><span class=line>    <span class=type>boolean</span> <span class="title function_">matches</span><span class=params>(Class clazz)</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>该<code>MethodMatcher</code>接口通常更重要。完整的界面如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">MethodMatcher</span> {</span><br><span class=line>    <span class=type>boolean</span> <span class="title function_">matches</span><span class=params>(Method m, Class targetClass)</span>;</span><br><span class=line>    <span class=type>boolean</span> <span class="title function_">isRuntime</span><span class=params>()</span>;</span><br><span class=line>    <span class=type>boolean</span> <span class="title function_">matches</span><span class=params>(Method m, Class targetClass, Object[] args)</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>该<code>matches(Method, Class)</code>方法用于测试此切入点是否与目标类上的给定方法匹配。创建AOP代理时可以执行此评估，以避免需要对每个方法调用进行测试。如果针对一个给定<code>matches</code>方法返回了两个参数的方法<code>true</code>，并且<code>isRuntime()</code> 返回了MethodMatcher的<code>true</code>方法，则每次调用方法时都会调用三个参数的match方法。这使切入点可以在目标建议开始之前立即查看传递给方法调用的参数。</p> <p>大多数<code>MethodMatcher</code>实现都是静态的，这意味着它们的<code>isRuntime()</code>方法将返回<code>false</code>。在这种情况下，<code>matches</code>永远不会调用三参数方法。</p> <blockquote><p>如果可能，请尝试使切入点成为静态，从而允许AOP框架在创建AOP代理时缓存切入点评估的结果。</blockquote> <h4 id=2-2-1-2、切入点操作><a class=headerlink href=#2-2-1-2、切入点操作 title=2.2.1.2、切入点操作></a>2.2.1.2、切入点操作</h4><p>spring支持切入点上的操作（特别是联合和相交）。</p> <p>联合表示两个切入点都匹配的方法。交集是指两个切入点都匹配的方法。联合通常更有用。您可以通过使用类中的静态方法<code>org.springframework.aop.support.Pointcuts</code>或使用<code>ComposablePointcut</code>同一包中的类 来编写切入点 。但是，使用AspectJ切入点表达式通常是一种更简单的方法。</p> <h4 id=2-2-1-3、AspectJ切入点表达式><a class=headerlink href=#2-2-1-3、AspectJ切入点表达式 title=2.2.1.3、AspectJ切入点表达式></a>2.2.1.3、AspectJ切入点表达式</h4><p>从2.0开始，Spring使用的最重要的切入点类型是 <code>org.springframework.aop.aspectj.AspectJExpressionPointcut</code>。这是一个切入点，该切入点使用AspectJ提供的库来解析AspectJ切入点表达式字符串。</p> <h4 id=2-2-1-4、便捷切入点实现><a class=headerlink href=#2-2-1-4、便捷切入点实现 title=2.2.1.4、便捷切入点实现></a>2.2.1.4、便捷切入点实现</h4><p>Spring提供了几种方便的切入点实现。您可以直接使用其中一些。其他的则打算在特定于应用程序的切入点中子类化。</p> <h5 id=静态切入点><a class=headerlink href=#静态切入点 title=静态切入点></a>静态切入点</h5><p>静态切入点基于方法和目标类，并且不能考虑方法的参数。静态切入点对于大多数用途来说是足够的，也是最好的。首次调用方法时，Spring只能评估一次静态切入点。之后，无需在每次方法调用时再次评估切入点。</p> <h6 id=正则表达式切入点><a class=headerlink href=#正则表达式切入点 title=正则表达式切入点></a>正则表达式切入点</h6><p>指定静态切入点的一种明显方法是正则表达式。除了Spring之外，还有几个AOP框架使之成为可能。 <code>org.springframework.aop.support.JdkRegexpMethodPointcut</code>是通用的正则表达式切入点，它使用JDK中的正则表达式支持。</p> <p>通过<code>JdkRegexpMethodPointcut</code>该类，您可以提供模式字符串的列表。如果其中任何一个匹配，则切入点的计算结果为<code>true</code>。（因此，结果切入点实际上是指定模式的并集。）</p> <p>以下示例显示如何使用<code>JdkRegexpMethodPointcut</code>：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"settersAndAbsquatulatePointcut"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.support.JdkRegexpMethodPointcut"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"patterns"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>list</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>.*set.*<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>.*absquatulate<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>list</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>Spring提供了一个名为<code>RegexpMethodPointcutAdvisor</code>的便捷类，它使我们也可以引用<code>Advice</code>。如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"settersAndAbsquatulateAdvisor"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.support.RegexpMethodPointcutAdvisor"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"advice"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>ref</span> <span class=attr>bean</span>=<span class=string>"beanNameOfAopAllianceInterceptor"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"patterns"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>list</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>.*set.*<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>.*absquatulate<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>list</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>您可以使用<code>RegexpMethodPointcutAdvisor</code>任何<code>Advice</code>类型。</p> <h6 id=属性驱动切入点><a class=headerlink href=#属性驱动切入点 title=属性驱动切入点></a>属性驱动切入点</h6><p>静态切入点的一种重要类型是元数据驱动的切入点。这将使用元数据属性的值（通常是源级别的元数据）。</p> <h5 id=动态切入点><a class=headerlink href=#动态切入点 title=动态切入点></a>动态切入点</h5><p>动态切入点比静态切入点更昂贵。它们考虑了方法参数以及静态信息。这意味着必须在每次方法调用时对它们进行评估，并且由于参数会有所不同，因此无法缓存结果。</p> <p>主要示例是<code>control flow</code>切入点。</p> <h6 id=控制流切入点><a class=headerlink href=#控制流切入点 title=控制流切入点></a>控制流切入点</h6><p>弹簧控制流切入点在概念上类似于AspectJ<code>cflow</code>切入点，尽管功能不那么强大。（当前无法指定切入点在与另一个切入点匹配的连接点下运行。）控制流切入点与当前调用堆栈匹配。例如，如果连接点是由<code>com.mycompany.web</code>包中的方法或由<code>SomeCaller</code>类调用的，则可能会触发。使用<code>org.springframework.aop.support.ControlFlowPointcut</code>类指定控制流切入点。</p> <blockquote><p>与其他动态切入点相比，控制流切入点在运行时进行评估要昂贵得多。在Java 1.4中，成本大约是其他动态切入点的五倍。</blockquote> <h4 id=2-2-1-5、切入点超类><a class=headerlink href=#2-2-1-5、切入点超类 title=2.2.1.5、切入点超类></a>2.2.1.5、切入点超类</h4><p>Spring提供了有用的切入点超类，以帮助您实现自己的切入点。</p> <p>因为静态切入点最有用，所以你可以继承 <code>StaticMethodMatcherPointcut</code>来实现。这仅需要实现一个抽象方法（尽管您可以覆盖其他方法以自定义行为）。以下示例显示了如何继承<code>StaticMethodMatcherPointcut</code>来实现静态切入点：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">TestStaticPointcut</span> <span class=keyword>extends</span> <span class="title class_">StaticMethodMatcherPointcut</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">matches</span><span class=params>(Method m, Class targetClass)</span> {</span><br><span class=line>        <span class=comment>// return true if custom criteria match</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>还有动态切入点的超类。您可以将自定义切入点与任何通知类型一起使用。</p> <h4 id=2-2-1-6、自定义切入点><a class=headerlink href=#2-2-1-6、自定义切入点 title=2.2.1.6、自定义切入点></a>2.2.1.6、自定义切入点</h4><p>由于Spring AOP中的切入点是Java类，因此可以声明自定义切入点，无论是静态还是动态。Spring中的自定义切入点可以很复杂。但是，建议使用AspectJ切入点。</p> <blockquote><p>更高版本的Spring可能提供对JAC提供的“语义切入点”的支持，例如，“更改目标对象中实例变量的所有方法”。</blockquote> <h3 id=2-2-2、Spring-Advice-API><a title="2.2.2、Spring Advice API" class=headerlink href=#2-2-2、Spring-Advice-API></a>2.2.2、Spring Advice API</h3><h4 id=2-2-2-1、Advice生命周期><a class=headerlink href=#2-2-2-1、Advice生命周期 title=2.2.2.1、Advice生命周期></a>2.2.2.1、Advice生命周期</h4><p>每个通知都是一个Spring bean。通知实例可以在所有通知对象之间共享，或者对于每个通知对象都是唯一的。这对应于每个class或每个实例的通知。</p> <p>每个class通知最常用。适用于一般通知，例如交易顾问。这些不依赖于代理对象的状态或添加新状态。它们仅作用于方法和参数。</p> <p>每个实例的通知都适合引入，以支持混合。在这种情况下，建议将状态添加到代理对象。</p> <p>您可以在同一AOP代理中混合使用共享和基于实例的建议。</p> <h4 id=2-2-2-2、Advice类型><a class=headerlink href=#2-2-2-2、Advice类型 title=2.2.2.2、Advice类型></a>2.2.2.2、Advice类型</h4><p>spring提供了几种通知类型，并且可以扩展以支持任意通知类型。</p> <h5 id=拦截环绕通知><a class=headerlink href=#拦截环绕通知 title=拦截环绕通知></a>拦截环绕通知</h5><p>Spring中最基本的通知类型是环绕通知。</p> <p><code>Alliance</code>对于使用方法拦截的建议，Spring符合AOP接口。实现<code>MethodInterceptor</code>和环绕通知实施的类还应该实现以下接口：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">MethodInterceptor</span> <span class=keyword>extends</span> <span class="title class_">Interceptor</span> {</span><br><span class=line>    Object <span class="title function_">invoke</span><span class=params>(MethodInvocation invocation)</span> <span class=keyword>throws</span> Throwable;</span><br><span class=line>}</span><br></pre></table></figure> <p>方法<code>invoke()</code>的参数<code>MethodInvocation</code>公开了要调用的方法，目标连接点，AOP代理以及方法的参数。该 <code>invoke()</code>方法应返回调用的结果：连接点的返回值。</p> <p>以下示例显示了一个简单的<code>MethodInterceptor</code>实现：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DebugInterceptor</span> <span class=keyword>implements</span> <span class="title class_">MethodInterceptor</span> {</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">invoke</span><span class=params>(MethodInvocation invocation)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        System.out.println(<span class=string>"Before: invocation=["</span> + invocation + <span class=string>"]"</span>);</span><br><span class=line>        <span class=type>Object</span> <span class=variable>rval</span> <span class=operator>=</span> invocation.proceed();</span><br><span class=line>        System.out.println(<span class=string>"Invocation returned"</span>);</span><br><span class=line>        <span class=keyword>return</span> rval;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>请注意对<code>MethodInvocation</code>的<code>proceed()</code>方法的调用。这沿着拦截器链向下到达连接点。大多数拦截器调用此方法并返回其返回值。但是，a<code>MethodInterceptor</code>像任何环绕通知一样，可以返回不同的值或引发异常，而不是调用proceed方法。但是，您没有充分的理由就不要这样做。</p> <h5 id=前置通知><a class=headerlink href=#前置通知 title=前置通知></a>前置通知</h5><p>一种更简单的通知类型是前置通知。这不需要<code>MethodInvocation</code> 对象，因为它仅在进入方法之前被调用。</p> <p>前置通知的主要优点在于，无需调用该<code>proceed()</code> 方法，因此，不会无意中导致无法沿拦截器链继续进行下去。</p> <p>以下清单显示了该<code>MethodBeforeAdvice</code>接口：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">MethodBeforeAdvice</span> <span class=keyword>extends</span> <span class="title class_">BeforeAdvice</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">before</span><span class=params>(Method m, Object[] args, Object target)</span> <span class=keyword>throws</span> Throwable;</span><br><span class=line>}</span><br></pre></table></figure> <p>（尽管通常的对象适用于字段拦截，并且Spring不太可能实现它，但Spring的API设计允许先于字段咨询。）</p> <p>请注意，返回类型为<code>void</code>。通知可以在联接点运行之前插入自定义行为，但不能更改返回值。如果前置通知引发异常，它将停止进一步执行拦截器链。异常会传播回拦截器链。如果未显式捕获它或抛出它，则会将其直接传递给客户端。否则，它将由AOP代理包装在未经检查的异常中。</p> <p>以下示例显示了Spring中的前置通知，该通知计算所有方法调用：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CountingBeforeAdvice</span> <span class=keyword>implements</span> <span class="title class_">MethodBeforeAdvice</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> count;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">before</span><span class=params>(Method m, Object[] args, Object target)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        ++count;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">getCount</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> count;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=异常通知><a class=headerlink href=#异常通知 title=异常通知></a>异常通知</h5><p>如果联接点引发异常，则在联接点返回之后调用引发通知。Spring提供类型化的抛出建议。请注意，这意味着该 <code>org.springframework.aop.ThrowsAdvice</code>接口不包含任何方法。它是一个标签接口，用于标识给定对象实现了一个或多个类型化的throws通知方法。这些应采用以下形式：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>afterThrowing([Method, args, target], subclassOfThrowable)</span><br></pre></table></figure> <p>仅最后一个参数是必需的。方法签名可以具有一个或四个参数，具体取决于建议方法是否对该方法和参数感兴趣。接下来的两个清单显示了类，它们是引发建议的示例。</p> <p>如果<code>RemoteException</code>抛出a（包括从子类），则调用以下建议：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoteThrowsAdvice</span> <span class=keyword>implements</span> <span class="title class_">ThrowsAdvice</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">afterThrowing</span><span class=params>(RemoteException ex)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        <span class=comment>// Do something with remote exception</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>与前面的通知不同，下一个示例声明了四个参数，以便可以访问被调用的方法，方法参数和目标对象。如果<code>ServletException</code>抛出a，则调用以下建议：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ServletThrowsAdviceWithArguments</span> <span class=keyword>implements</span> <span class="title class_">ThrowsAdvice</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">afterThrowing</span><span class=params>(Method m, Object[] args, Object target, ServletException ex)</span> {</span><br><span class=line>        <span class=comment>// Do something with all arguments</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>最后一个示例说明了如何在处理<code>RemoteException</code>和的单个类中使用这两种方法<code>ServletException</code>。可以将任意数量的异常通知方法组合到一个类中。以下清单显示了最后一个示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">CombinedThrowsAdvice</span> <span class=keyword>implements</span> <span class="title class_">ThrowsAdvice</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">afterThrowing</span><span class=params>(RemoteException ex)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        <span class=comment>// Do something with remote exception</span></span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">afterThrowing</span><span class=params>(Method m, Object[] args, Object target, ServletException ex)</span> {</span><br><span class=line>        <span class=comment>// Do something with all arguments</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <blockquote><p>如果throws-advice方法本身引发异常，则它将覆盖原始异常（也就是说，它将更改引发给用户的异常）。重写异常通常是RuntimeException，它与任何方法签名都兼容。但是，如果throws-advice方法抛出一个检查异常，则它必须与目标方法的已声明异常匹配，因此在某种程度上与特定的目标方法签名耦合。<em>不要抛出与目标方法签名不兼容的未声明检查异常！</em></blockquote> <h5 id=返回后通知><a class=headerlink href=#返回后通知 title=返回后通知></a>返回后通知</h5><p>在Spring中返回一个After通知后，必须实现该<code>org.springframework.aop.AfterReturningAdvice</code>接口，以下清单显示了该 接口：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">AfterReturningAdvice</span> <span class=keyword>extends</span> <span class="title class_">Advice</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">afterReturning</span><span class=params>(Object returnValue, Method m, Object[] args, Object target)</span> <span class=keyword>throws</span> Throwable;</span><br><span class=line>}</span><br></pre></table></figure> <p>后置通知可以访问返回值（它不能修改），调用的方法，方法的参数和目标。</p> <p>返回建议后的以下内容将计数所有未引发异常的成功方法调用：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CountingAfterReturningAdvice</span> <span class=keyword>implements</span> <span class="title class_">AfterReturningAdvice</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> count;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">afterReturning</span><span class=params>(Object returnValue, Method m, Object[] args, Object target)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        ++count;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">getCount</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> count;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>该建议不会更改执行路径。如果抛出异常，则会将其抛出拦截器链，而不是返回值。</p> <h5 id=引入通知><a class=headerlink href=#引入通知 title=引入通知></a>引入通知</h5><p>Spring将介绍建议视为一种特殊的拦截建议。</p> <p>简介需要<code>IntroductionAdvisor</code>and<code>IntroductionInterceptor</code>来实现以下接口：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">IntroductionInterceptor</span> <span class=keyword>extends</span> <span class="title class_">MethodInterceptor</span> {</span><br><span class=line>    <span class=type>boolean</span> <span class="title function_">implementsInterface</span><span class=params>(Class intf)</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p><code>invoke()</code>从AOP Alliance<code>MethodInterceptor</code>接口继承的方法必须实现介绍。也就是说，如果被调用的方法在引入的接口上，则引入拦截器负责处理方法调用-它不能调用<code>proceed()</code>。</p> <p>简介建议不能与任何切入点一起使用，因为它仅适用于类，而不适用于方法级别。您只能将引入建议与一起使用<code>IntroductionAdvisor</code>，该建议具有 以下方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">IntroductionAdvisor</span> <span class=keyword>extends</span> <span class="title class_">Advisor</span>, IntroductionInfo {</span><br><span class=line>    ClassFilter <span class="title function_">getClassFilter</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">validateInterfaces</span><span class=params>()</span> <span class=keyword>throws</span> IllegalArgumentException;</span><br><span class=line>}</span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">IntroductionInfo</span> {</span><br><span class=line>    Class&LT?>[] getInterfaces();</span><br><span class=line>}</span><br></pre></table></figure> <p>没有<code>MethodMatcher</code>任何<code>Pointcut</code>介绍建议，因此也没有。只有类过滤是合乎逻辑的。</p> <p>该<code>getInterfaces()</code>方法返回此顾问程序引入的接口。</p> <p>该<code>validateInterfaces()</code>方法在内部使用，以查看引入的接口是否可以由configure的接口实现<code>IntroductionInterceptor</code>。</p> <p>假设我们想为一个或多个对象引入以下接口：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Lockable</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">lock</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">unlock</span><span class=params>()</span>;</span><br><span class=line>    <span class=type>boolean</span> <span class="title function_">locked</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>这说明了混合。我们希望能够将建议对象强制转换为<code>Lockable</code>，无论它们的类型是什么，并调用锁定和解锁方法。如果调用该<code>lock()</code>方法，则希望所有的setter方法都抛出一个<code>LockedException</code>。因此，我们可以添加一个方面，使对象在不了解对象的情况下不可变：AOP的一个很好的例子。</p> <p>首先，我们需要一个<code>IntroductionInterceptor</code>繁重的工作。在这种情况下，我们扩展了<code>org.springframework.aop.support.DelegatingIntroductionInterceptor</code> 便利类。我们可以<code>IntroductionInterceptor</code>直接实现，但是<code>DelegatingIntroductionInterceptor</code>在大多数情况下使用 是最好的。</p> <p>该<code>DelegatingIntroductionInterceptor</code>设计将导入委托到真正实现导入接口，隐藏拦截的使用来做到这一点。您可以使用构造函数参数将委托设置为任何对象。默认委托（使用无参数构造函数时）为<code>this</code>。因此，在下一个示例中，委托是的<code>LockMixin</code>子类<code>DelegatingIntroductionInterceptor</code>。给定一个委托（默认情况下为本身），<code>DelegatingIntroductionInterceptor</code>实例将查找由委托实现的所有接口（除外 <code>IntroductionInterceptor</code>），并支持针对其中任何一个的介绍。诸如的子类<code>LockMixin</code>可以调用该<code>suppressInterface(Class intf)</code> 方法来抑制不应公开的接口。但是，无论<code>IntroductionInterceptor</code>准备支持多少个接口， <code>IntroductionAdvisor</code>用于控制实际公开哪些接口。引入的接口隐藏了目标对同一接口的任何实现。</p> <p>因此，<code>LockMixin</code>扩展<code>DelegatingIntroductionInterceptor</code>并实现<code>Lockable</code> 自己。超类会自动选择<code>Lockable</code>可以支持引入的超类，因此我们不需要指定它。我们可以通过这种方式引入任意数量的接口。</p> <p>注意<code>locked</code>实例变量的使用。这有效地将附加状态添加到目标对象中保存的状态。</p> <p>以下示例显示了示例<code>LockMixin</code>类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">LockMixin</span> <span class=keyword>extends</span> <span class="title class_">DelegatingIntroductionInterceptor</span> <span class=keyword>implements</span> <span class="title class_">Lockable</span> {</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=type>boolean</span> locked;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">lock</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>this</span>.locked = <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">unlock</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>this</span>.locked = <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">locked</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.locked;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">invoke</span><span class=params>(MethodInvocation invocation)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        <span class=keyword>if</span> (locked() && invocation.getMethod().getName().indexOf(<span class=string>"set"</span>) == <span class=number>0</span>) {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">LockedException</span>();</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>super</span>.invoke(invocation);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure> <p>通常，您无需重写该<code>invoke()</code>方法。的 <code>DelegatingIntroductionInterceptor</code>实现（它调用<code>delegate</code>如果引入的方法的方法，否则进行指向连接点），通常就足够了。在当前情况下，我们需要添加一个检查：如果处于锁定模式，则不能调用任何setter方法。</p> <p>所需的简介仅需要保存一个不同的 <code>LockMixin</code>实例并指定所引入的接口（在这种情况下，仅 <code>Lockable</code>）。一个更复杂的示例可能引用了引入拦截器（将被定义为原型）。在这种情况下，没有与a相关的配置<code>LockMixin</code>，因此我们使用来创建它<code>new</code>。以下示例显示了我们的<code>LockMixinAdvisor</code>课程：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">LockMixinAdvisor</span> <span class=keyword>extends</span> <span class="title class_">DefaultIntroductionAdvisor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">LockMixinAdvisor</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>super</span>(<span class=keyword>new</span> <span class="title class_">LockMixin</span>(), Lockable.class);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>我们可以非常简单地应用此顾问程序，因为它不需要配置。（但是，如果<code>IntroductionInterceptor</code>不带 ，就无法使用<code>IntroductionAdvisor</code>。）像通常的介绍中一样，顾问程序必须是基于实例的，因为它是有状态的。对于每个建议的对象<code>LockMixinAdvisor</code>，我们需要一个实例，因此 需要一个实例<code>LockMixin</code>。顾问程序包含建议对象状态的一部分。</p> <p>我们可以<code>Advised.addAdvisor()</code>像其他任何顾问一样，通过使用XML配置中的方法或（推荐方式）以编程方式应用此顾问。下文讨论的所有代理创建选择，包括“自动代理创建器”，都可以正确处理介绍和有状态的混合。</p> <h3 id=2-2-3、Spring-Advisor-API><a title="2.2.3、Spring Advisor API" class=headerlink href=#2-2-3、Spring-Advisor-API></a>2.2.3、Spring Advisor API</h3><p>除了介绍的特殊情况外，任何顾问都可以使用任何建议。 <code>org.springframework.aop.support.DefaultPointcutAdvisor</code>是最常用的顾问类。它可以与使用<code>MethodInterceptor</code>，<code>BeforeAdvice</code>或 <code>ThrowsAdvice</code>。</p> <p>可以在同一AOP代理中的Spring中混合使用顾问和建议类型。例如，您可以在一个代理配置中使用对建议的拦截，抛出建议以及在建议之前。Spring自动创建必要的拦截器链。</p> <h3 id=2-2-4、使用ProxyFactoryBean创建AOP代理><a class=headerlink href=#2-2-4、使用ProxyFactoryBean创建AOP代理 title=2.2.4、使用ProxyFactoryBean创建AOP代理></a>2.2.4、使用<code>ProxyFactoryBean</code>创建AOP代理</h3><p>如果将Spring IoC容器（<code>ApplicationContext</code>或<code>BeanFactory</code>）用于业务对象（应该是！），则要使用Spring的AOP <code>FactoryBean</code>实现之一。（请记住，工厂bean引入了一个间接层，允许它创建不同类型的对象。）</p> <blockquote><p>Spring AOP支持还在后台使用了工厂bean。</blockquote> <p>在Spring中创建AOP代理的基本方法是使用 <code>org.springframework.aop.framework.ProxyFactoryBean</code>。这样可以完全控制切入点，任何适用的建议及其顺序。但是，如果不需要这样的控制，则有一些更简单的选项是可取的。</p> <h4 id=2-2-4-1、Base><a class=headerlink href=#2-2-4-1、Base title=2.2.4.1、Base></a>2.2.4.1、Base</h4><p><code>roxyFactoryBean</code>，像其它的<code>FactoryBean</code>实现中，引入了一个间接的水平。如果您定义一个<code>ProxyFactoryBean</code>named <code>foo</code>，则引用的对象将<code>foo</code>看不到<code>ProxyFactoryBean</code>实例本身，而是一个由实现中的<code>getObject()</code>方法创建的对象<code>ProxyFactoryBean</code>。此方法创建一个包装目标对象的AOP代理。</p> <p>使用一个<code>ProxyFactoryBean</code>或另一个IoC感知类创建AOP代理的最重要好处之一是，建议和切入点也可以由IoC管理。这是一项强大的功能，可以实现某些其他AOP框架难以实现的方法。例如，受益于依赖注入提供的所有可插入性，建议本身可以引用应用程序对象（目标之外，目标应该在任何AOP框架中可用）。</p> <h4 id=2-2-4-2、Java-Bean属性><a title="2.2.4.2、Java Bean属性" class=headerlink href=#2-2-4-2、Java-Bean属性></a>2.2.4.2、Java Bean属性</h4><p><code>FactoryBean</code>与Spring提供的大多数实现一样， <code>ProxyFactoryBean</code>该类本身就是JavaBean。其属性用于：</p> <ul><li>指定要代理的目标。<li>指定是否使用CGLIB（稍后介绍，另请参见<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-pfb-proxy-types rel=noopener target=_blank>基于JDK和CGLIB的代理</a>）。</ul> <p>继承了一些关键属性<code>org.springframework.aop.framework.ProxyConfig</code> （Spring中所有AOP代理工厂的超类）。这些关键属性包括：</p> <ul><li><code>proxyTargetClass</code>：<code>true</code>如果要代理目标类，而不是目标类的接口。如果将此属性值设置为<code>true</code>，则将创建CGLIB代理（另请参见<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-pfb-proxy-types rel=noopener target=_blank>基于JDK和CGLIB的代理</a>）。<li><code>optimize</code>：控制是否将积极的优化应用于通过CGLIB创建的代理。除非您完全了解相关的AOP代理如何处理优化，否则不要随意使用此设置。当前仅用于CGLIB代理。它对JDK动态代理无效。<li><code>frozen</code>：如果代理配置为<code>frozen</code>，则不再允许更改配置。这对于进行轻微的优化是有用的，对于在您不希望调用者<code>Advised</code> 在创建代理后能够通过该接口操纵代理的情况下，这是有用的。此属性的默认值为 <code>false</code>，因此允许进行更改（例如添加其他建议）。<li><code>exposeProxy</code>：确定是否应将当前代理公开在中， <code>ThreadLocal</code>以便目标可以访问它。如果目标需要获取代理并将<code>exposeProxy</code>属性设置为<code>true</code>，则目标可以使用该 <code>AopContext.currentProxy()</code>方法。</ul> <p>其他特定的属性<code>ProxyFactoryBean</code>包括：</p> <ul><li><p><code>proxyInterfaces</code>：<code>String</code>接口名称数组。如果未提供，则使用目标类的CGLIB代理（另请参见<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-pfb-proxy-types rel=noopener target=_blank>基于JDK和CGLIB的代理</a>）。</p><li><p><code>interceptorNames</code>：要套用<code>String</code>的<code>Advisor</code>，拦截器或其他建议名称的数组。顺序很重要，先到先得。也就是说，列表中的第一个拦截器是第一个能够拦截调用的拦截器。</p> <p>名称是当前工厂中的Bean名称，包括祖先工厂中的Bean名称。您不能在此提及bean引用，因为这样做会导致 <code>ProxyFactoryBean</code>忽略建议的单例设置。</p> <p>您可以在拦截器名称后加上星号（<code>*</code>）。这样做将导致应用所有顾问Bean，其名称以要应用星号的部分开头。您可以在<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-global-advisors rel=noopener target=_blank>使用“全局”顾问中</a>找到使用此功能的示例。</p><li><p>单例：无论<code>getObject()</code>调用该方法的频率如何，工厂是否应返回单个对象。几种<code>FactoryBean</code>实现提供了这种方法。默认值为<code>true</code>。如果要使用有状态的建议（例如，对于有状态的混合），请使用原型建议以及单例值 <code>false</code>。</p></ul> <h4 id=2-2-4-3、JDK和CGLIB代理><a class=headerlink href=#2-2-4-3、JDK和CGLIB代理 title=2.2.4.3、JDK和CGLIB代理></a>2.2.4.3、JDK和CGLIB代理</h4><p>本节是有关如何<code>ProxyFactoryBean</code> 选择为特定目标对象（将被代理）创建基于JDK的代理或基于CGLIB的代理的权威性文档。</p> <blockquote><p>在<code>ProxyFactoryBean</code>Spring的1.2.x版和2.0版之间，关于创建基于JDK或CGLIB的代理的行为发生了变化。在<code>ProxyFactoryBean</code>现在表现关于与上述的自动检测接口相似的语义 <code>TransactionProxyFactoryBean</code>类。</blockquote> <p>如果要代理的目标对象的类（以下简称为目标类）没有实现任何接口，则将创建基于CGLIB的代理。这是最简单的情况，因为JDK代理是基于接口的，并且没有接口意味着甚至无法进行JDK代理。您可以插入目标bean并通过设置<code>interceptorNames</code>属性来指定拦截器列表。请注意，即使的<code>proxyTargetClass</code>属性 <code>ProxyFactoryBean</code>已设置为，也会创建基于CGLIB的代理<code>false</code>。（这样做没有任何意义，最好将其从bean定义中删除，因为它充其量是多余的，并且在最糟的情况下会造成混淆。）</p> <p>如果目标类实现一个（或多个）接口，则创建的代理类型取决于的配置<code>ProxyFactoryBean</code>。</p> <p>如果的<code>proxyTargetClass</code>属性<code>ProxyFactoryBean</code>已设置为<code>true</code>，则会创建一个基于CGLIB的代理。这是有道理的，并且符合最小惊讶原则。即使的<code>proxyInterfaces</code>属性 <code>ProxyFactoryBean</code>已设置为一个或多个完全限定的接口名称，该<code>proxyTargetClass</code>属性设置为的事实也会<code>true</code>导致基于CGLIB的代理生效。</p> <p>如果的<code>proxyInterfaces</code>属性<code>ProxyFactoryBean</code>已设置为一个或多个标准接口名称，则将创建一个基于JDK的代理。创建的代理实现<code>proxyInterfaces</code> 属性中指定的所有接口。如果目标类恰好实现了比该<code>proxyInterfaces</code>属性中指定的接口更多的接口，那很好，但是返回的代理不会实现这些其他接口。</p> <p>如果尚未设置的<code>proxyInterfaces</code>属性<code>ProxyFactoryBean</code>，但是目标类确实实现了一个（或多个）接口，则 <code>ProxyFactoryBean</code>自动检测到目标类实际上确实实现了至少一个接口，并创建了基于JDK的代理。实际代理的接口是目标类实现的所有接口。实际上，这与为目标类提供该<code>proxyInterfaces</code>属性实现的每个接口的列表相同。但是，它的工作量大大减少，而且不容易出现印刷错误。</p> <h4 id=2-2-4-4、代理接口><a class=headerlink href=#2-2-4-4、代理接口 title=2.2.4.4、代理接口></a>2.2.4.4、代理接口</h4><p>考虑一个简单的实际例子<code>ProxyFactoryBean</code>。此示例涉及：</p> <ul><li>代理的目标bean。这是<code>personTarget</code>示例中的bean定义。<li>一个<code>Advisor</code>和<code>Interceptor</code>使用提供建议。<li>AOP代理bean定义，用于指定目标对象（<code>personTarget</code>bean），代理接口以及要应用的建议。</ul> <p>以下清单显示了示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"personTarget"</span> <span class=attr>class</span>=<span class=string>"com.mycompany.PersonImpl"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"Tony"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"age"</span> <span class=attr>value</span>=<span class=string>"51"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"myAdvisor"</span> <span class=attr>class</span>=<span class=string>"com.mycompany.MyAdvisor"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"someProperty"</span> <span class=attr>value</span>=<span class=string>"Custom string property value"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"debugInterceptor"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.interceptor.DebugInterceptor"</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"person"</span></span></span><br><span class=line><span class=tag>    <span class=attr>class</span>=<span class=string>"org.springframework.aop.framework.ProxyFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"proxyInterfaces"</span> <span class=attr>value</span>=<span class=string>"com.mycompany.Person"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"target"</span> <span class=attr>ref</span>=<span class=string>"personTarget"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"interceptorNames"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>list</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>myAdvisor<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>debugInterceptor<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>list</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>请注意，该<code>interceptorNames</code>属性采用的列表<code>String</code>，其中包含当前工厂中的拦截器或顾问程序的Bean名称。您可以在返回之前，之后使用顾问程序，拦截器并引发建议对象。顾问的顺序很重要。</p> <blockquote><p>您可能想知道为什么列表不包含bean引用。原因是，如果将的singleton属性<code>ProxyFactoryBean</code>设置为<code>false</code>，则它必须能够返回独立的代理实例。如果任何顾问本身就是原型，则需要返回一个独立的实例，因此必须能够从工厂获得原型的实例。保持引用是不够的。</blockquote> <p><code>person</code>可以使用前面显示的bean定义代替<code>Person</code>实现，如下所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>Person</span> <span class=variable>person</span> <span class=operator>=</span> (Person) factory.getBean(<span class=string>"person"</span>);</span><br></pre></table></figure> <p>与普通Java对象一样，在同一IoC上下文中的其他bean可以表达对此的强类型依赖性。以下示例显示了如何执行此操作：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"personUser"</span> <span class=attr>class</span>=<span class=string>"com.mycompany.PersonUser"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"person"</span>></span><span class=tag><<span class=name>ref</span> <span class=attr>bean</span>=<span class=string>"person"</span>/></span><span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p><code>PersonUser</code>本示例中的类公开了type属性<code>Person</code>。就其而言，可以透明地使用AOP代理代替“真实”人的实现。但是，其类将是动态代理类。可以将其强制转换为<code>Advised</code>接口（稍后讨论）。</p> <p>您可以使用匿名内部bean隐藏目标和代理之间的区别。只有<code>ProxyFactoryBean</code>定义不同。该建议仅出于完整性考虑。以下示例显示如何使用匿名内部Bean：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"myAdvisor"</span> <span class=attr>class</span>=<span class=string>"com.mycompany.MyAdvisor"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"someProperty"</span> <span class=attr>value</span>=<span class=string>"Custom string property value"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"debugInterceptor"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.interceptor.DebugInterceptor"</span>/></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"person"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.framework.ProxyFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"proxyInterfaces"</span> <span class=attr>value</span>=<span class=string>"com.mycompany.Person"</span>/></span></span><br><span class=line>    <span class=comment>&LT!-- Use inner bean, not local reference to target --></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"target"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"com.mycompany.PersonImpl"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"Tony"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"age"</span> <span class=attr>value</span>=<span class=string>"51"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"interceptorNames"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>list</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>myAdvisor<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>debugInterceptor<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>list</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>使用匿名内部bean的优点是只有一个类型的对象<code>Person</code>。如果我们要防止应用程序上下文的用户获取对未建议对象的引用，或者需要避免使用Spring IoC自动装配的任何歧义，这将非常有用。可以说，还有一个优点是<code>ProxyFactoryBean</code>定义是独立的。但是，有时能够从工厂获得未经建议的目标实际上可能是一个优势（例如，在某些测试方案中）。</p> <h4 id=2-2-4-5、代理Class><a class=headerlink href=#2-2-4-5、代理Class title=2.2.4.5、代理Class></a>2.2.4.5、代理Class</h4><p>如果您需要代理一类，而不是一个或多个接口，该怎么办？</p> <p>想象一下，在我们之前的示例中，没有<code>Person</code>接口。我们需要建议一个<code>Person</code>没有实现任何业务接口的类。在这种情况下，可以将Spring配置为使用CGLIB代理而不是动态代理。为此，请将前面显示的<code>proxyTargetClass</code>属性设置 <code>ProxyFactoryBean</code>为<code>true</code>。尽管最好对接口而不是对类进行编程，但是在处理遗留代码时，建议未实现接口的类的功能可能会很有用。（通常，Spring并不是强制性的。虽然可以轻松地应用良好实践，但可以避免强制采用特定方法。）</p> <p>如果需要，即使您有接口，也可以在任何情况下强制使用CGLIB。</p> <p>CGLIB代理通过在运行时生成目标类的子类来工作。Spring配置此生成的子类以将方法调用委托给原始目标。子类用于实现Decorator模式，并编织在建议中。</p> <p>CGLIB代理通常应对用户透明。但是，有一些问题要考虑：</p> <ul><li><code>Final</code> 不能建议使用方法，因为它们不能被覆盖。<li>无需将CGLIB添加到您的类路径中。从Spring 3.2开始，CGLIB被重新打包并包含在spring-core JAR中。换句话说，基于CGLIB的AOP就像JDK动态代理一样“开箱即用”。</ul> <p>CGLIB代理和动态代理之间几乎没有性能差异。在这种情况下，性能不应作为决定性的考虑因素。</p> <h4 id=2-2-4-6、使用全局通知><a class=headerlink href=#2-2-4-6、使用全局通知 title=2.2.4.6、使用全局通知></a>2.2.4.6、使用全局通知</h4><p>通过在拦截器名称后附加星号，所有具有与该星号之前的部分匹配的Bean名称的顾问程序都将添加到顾问程序链中。如果您需要添加标准的“全局”顾问程序集，这可能会派上用场。以下示例定义了两个全局顾问程序：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"proxy"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.framework.ProxyFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"target"</span> <span class=attr>ref</span>=<span class=string>"service"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"interceptorNames"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>list</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>global*<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>list</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"global_debug"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.interceptor.DebugInterceptor"</span>/></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"global_performance"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.interceptor.PerformanceMonitorInterceptor"</span>/></span></span><br></pre></table></figure> <h3 id=2-2-5、简洁代理定义><a class=headerlink href=#2-2-5、简洁代理定义 title=2.2.5、简洁代理定义></a>2.2.5、简洁代理定义</h3><p>特别是在定义事务代理时，您可能会得到许多类似的代理定义。使用父子bean定义和子bean定义以及内部bean定义可以使代理定义更加简洁明了。</p> <p>首先，我们为代理创建父模板，bean定义，如下所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"txProxyTemplate"</span> <span class=attr>abstract</span>=<span class=string>"true"</span> <span class=attr>class</span>=<span class=string>"org.springframework.transaction.interceptor.TransactionProxyFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"transactionManager"</span> <span class=attr>ref</span>=<span class=string>"transactionManager"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"transactionAttributes"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>props</span>></span></span><br><span class=line>            <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"*"</span>></span>PROPAGATION_REQUIRED<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>props</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>它本身从未实例化，因此实际上可能是不完整的。然后，每个需要创建的代理都是一个子bean定义，它将代理的目标包装为内部bean定义，因为无论如何该目标都不会单独使用。以下示例显示了这样的子bean：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"myService"</span> <span class=attr>parent</span>=<span class=string>"txProxyTemplate"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"target"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.samples.MyServiceImpl"</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>您可以从父模板覆盖属性。在以下示例中，我们将覆盖事务传播设置：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"mySpecialService"</span> <span class=attr>parent</span>=<span class=string>"txProxyTemplate"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"target"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.samples.MySpecialServiceImpl"</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"transactionAttributes"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>props</span>></span></span><br><span class=line>            <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"get*"</span>></span>PROPAGATION_REQUIRED,readOnly<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>            <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"find*"</span>></span>PROPAGATION_REQUIRED,readOnly<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>            <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"load*"</span>></span>PROPAGATION_REQUIRED,readOnly<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>            <span class=tag><<span class=name>prop</span> <span class=attr>key</span>=<span class=string>"store*"</span>></span>PROPAGATION_REQUIRED<span class=tag>&LT/<span class=name>prop</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>props</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>请注意，在父bean的示例中，我们通过将<code>abstract</code>属性设置为来将父bean定义显式标记为抽象<code>true</code>， <a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-child-bean-definitions rel=noopener target=_blank>如前所述</a>，因此实际上可能不会实例化它。默认情况下，应用程序上下文（但不是简单的bean工厂）会预先实例化所有单例。因此，重要的是（至少对于单例bean而言），如果您有一个（父）bean定义仅打算用作模板，并且此定义指定了一个类，则必须确保将<code>abstract</code> 属性设置为<code>true</code>。否则，应用程序上下文实际上会尝试对其进行实例化。</p> <h3 id=2-2-6、使用ProxyFactory以编程方式实现AOP代理><a class=headerlink href=#2-2-6、使用ProxyFactory以编程方式实现AOP代理 title=2.2.6、使用ProxyFactory以编程方式实现AOP代理></a>2.2.6、使用ProxyFactory以编程方式实现AOP代理</h3><p>使用Spring以编程方式创建AOP代理很容易。这使您可以在不依赖Spring IoC的情况下使用Spring AOP。</p> <p>由目标对象实现的接口将被自动代理。以下清单显示了使用一个拦截器和一个顾问程序为目标对象创建代理的过程：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=type>ProxyFactory</span> <span class=variable>factory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ProxyFactory</span>(myBusinessInterfaceImpl);</span><br><span class=line>factory.addAdvice(myMethodInterceptor);</span><br><span class=line>factory.addAdvisor(myAdvisor);</span><br><span class=line><span class=type>MyBusinessInterface</span> <span class=variable>tb</span> <span class=operator>=</span> (MyBusinessInterface) factory.getProxy();</span><br></pre></table></figure> <p>第一步是构造类型的对象 <code>org.springframework.aop.framework.ProxyFactory</code>。您可以使用目标对象创建此对象，如前面的示例中所述，或指定要在替代构造函数中代理的接口。</p> <p>您可以添加建议（使用拦截器作为一种特殊的建议），顾问，或同时添加两者，并在的生命周期内对其进行操作<code>ProxyFactory</code>。如果添加 <code>IntroductionInterceptionAroundAdvisor</code>，则可以使代理实现其他接口。</p> <p><code>ProxyFactory</code>（继承自<code>AdvisedSupport</code>）上还有便捷的方法，可让您添加其他建议类型，例如before和throw通知。 <code>AdvisedSupport</code>既是超<code>ProxyFactory</code>和<code>ProxyFactoryBean</code>。</p> <h3 id=2-2-7、操作通知对象><a class=headerlink href=#2-2-7、操作通知对象 title=2.2.7、操作通知对象></a>2.2.7、操作通知对象</h3><p>无论创建AOP代理，都可以通过使用<code>org.springframework.aop.framework.Advised</code>接口来操作它们 。任何AOP代理都可以强制转换为该接口，无论它实现了哪个其他接口。该界面包括以下方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line>Advisor[] getAdvisors();</span><br><span class=line></span><br><span class=line><span class=keyword>void</span> <span class="title function_">addAdvice</span><span class=params>(Advice advice)</span> <span class=keyword>throws</span> AopConfigException;</span><br><span class=line></span><br><span class=line><span class=keyword>void</span> <span class="title function_">addAdvice</span><span class=params>(<span class=type>int</span> pos, Advice advice)</span> <span class=keyword>throws</span> AopConfigException;</span><br><span class=line></span><br><span class=line><span class=keyword>void</span> <span class="title function_">addAdvisor</span><span class=params>(Advisor advisor)</span> <span class=keyword>throws</span> AopConfigException;</span><br><span class=line></span><br><span class=line><span class=keyword>void</span> <span class="title function_">addAdvisor</span><span class=params>(<span class=type>int</span> pos, Advisor advisor)</span> <span class=keyword>throws</span> AopConfigException;</span><br><span class=line></span><br><span class=line><span class=type>int</span> <span class="title function_">indexOf</span><span class=params>(Advisor advisor)</span>;</span><br><span class=line></span><br><span class=line><span class=type>boolean</span> <span class="title function_">removeAdvisor</span><span class=params>(Advisor advisor)</span> <span class=keyword>throws</span> AopConfigException;</span><br><span class=line></span><br><span class=line><span class=keyword>void</span> <span class="title function_">removeAdvisor</span><span class=params>(<span class=type>int</span> index)</span> <span class=keyword>throws</span> AopConfigException;</span><br><span class=line></span><br><span class=line><span class=type>boolean</span> <span class="title function_">replaceAdvisor</span><span class=params>(Advisor a, Advisor b)</span> <span class=keyword>throws</span> AopConfigException;</span><br><span class=line></span><br><span class=line><span class=type>boolean</span> <span class="title function_">isFrozen</span><span class=params>()</span>;</span><br></pre></table></figure> <p>该<code>getAdvisors()</code>方法<code>Advisor</code>针对已添加到工厂的每个顾问程序，拦截器或其他建议类型返回一个。如果添加<code>Advisor</code>，则在此索引处返回的顾问程序就是您添加的对象。如果您添加了拦截器或其他建议类型，Spring会将其包装在带有始终返回的切入点的顾问中<code>true</code>。因此，如果您添加了<code>MethodInterceptor</code>，则为此索引返回的顾问<code>DefaultPointcutAdvisor</code>程序将返回您的， <code>MethodInterceptor</code>并且指向所有类和方法都匹配的切入点。</p> <p>该<code>addAdvisor()</code>方法可用于添加任何<code>Advisor</code>。通常，拥有切入点和建议的顾问是通用的<code>DefaultPointcutAdvisor</code>，您可以将其与任何建议或切入点一起使用（但不能用于介绍）。</p> <p>默认情况下，即使已创建代理，也可以添加或删除顾问程序或拦截器。唯一的限制是不可能添加或删除介绍顾问，因为工厂中的现有代理不会显示界面更改。（您可以从工厂获取新的代理来避免此问题。）</p> <p>以下示例显示了将AOP代理投射到<code>Advised</code>接口并检查和处理其建议：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=type>Advised</span> <span class=variable>advised</span> <span class=operator>=</span> (Advised) myObject;</span><br><span class=line>Advisor[] advisors = advised.getAdvisors();</span><br><span class=line><span class=type>int</span> <span class=variable>oldAdvisorCount</span> <span class=operator>=</span> advisors.length;</span><br><span class=line>System.out.println(oldAdvisorCount + <span class=string>" advisors"</span>);</span><br><span class=line></span><br><span class=line><span class=comment>// Add an advice like an interceptor without a pointcut</span></span><br><span class=line><span class=comment>// Will match all proxied methods</span></span><br><span class=line><span class=comment>// Can use for interceptors, before, after returning or throws advice</span></span><br><span class=line>advised.addAdvice(<span class=keyword>new</span> <span class="title class_">DebugInterceptor</span>());</span><br><span class=line></span><br><span class=line><span class=comment>// Add selective advice using a pointcut</span></span><br><span class=line>advised.addAdvisor(<span class=keyword>new</span> <span class="title class_">DefaultPointcutAdvisor</span>(mySpecialPointcut, myAdvice));</span><br><span class=line></span><br><span class=line>assertEquals(<span class=string>"Added two advisors"</span>, oldAdvisorCount + <span class=number>2</span>, advised.getAdvisors().length);</span><br></pre></table></figure> <p>根据创建代理的方式，通常可以设置一个<code>frozen</code>标志。在这种情况下，该<code>Advised</code> <code>isFrozen()</code>方法会返回<code>true</code>，并且通过添加或删除来修改建议的任何尝试都会导致<code>AopConfigException</code>。冻结建议对象状态的功能在某些情况下很有用（例如，防止调用代码删除安全拦截器）。</p> <h3 id=2-2-8、使用自动代理功能><a class=headerlink href=#2-2-8、使用自动代理功能 title=2.2.8、使用自动代理功能></a>2.2.8、使用自动代理功能</h3><p>Spring还允许我们使用“自动代理” Bean定义，该定义可以自动代理选定的Bean定义。它建立在Spring的“ bean后处理器”基础结构上，该基础结构允许在容器加载时修改任何bean定义。</p> <p>在此模型中，您在XML bean定义文件中设置了一些特殊的bean定义，以配置自动代理基础结构。这使您可以声明有资格进行自动代理的目标。您不需要使用<code>ProxyFactoryBean</code>。</p> <p>有两种方法可以做到这一点：</p> <ul><li>通过使用在当前上下文中引用特定bean的自动代理创建器。<li>自动代理创建的一种特殊情况，值得单独考虑：由源级元数据属性驱动的自动代理创建。</ul> <h4 id=2-2-8-1、自动代理Bean定义><a class=headerlink href=#2-2-8-1、自动代理Bean定义 title=2.2.8.1、自动代理Bean定义></a>2.2.8.1、自动代理Bean定义</h4><h5 id=BeanNameAutoProxyCreator><a class=headerlink href=#BeanNameAutoProxyCreator title=BeanNameAutoProxyCreator></a>BeanNameAutoProxyCreator</h5><p>该<code>BeanNameAutoProxyCreator</code>班是一个<code>BeanPostProcessor</code>能够自动创建一个用于匹配字符串或者通配符名称豆类AOP代理。以下示例显示了如何创建<code>BeanNameAutoProxyCreator</code>bean：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"beanNames"</span> <span class=attr>value</span>=<span class=string>"jdk*,onlyJdk"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"interceptorNames"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>list</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>myInterceptor<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>list</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>与一样<code>ProxyFactoryBean</code>，有一个<code>interceptorNames</code>属性而不是拦截器列表，以允许原型顾问程序具有正确的行为。名为“拦截器”的可以是顾问或任何建议类型。</p> <p>通常，与自动代理一样，使用的要点<code>BeanNameAutoProxyCreator</code>是将相同的配置一致地应用于多个对象，并且配置量最少。将声明式事务应用于多个对象是一种流行的选择。</p> <p>名称匹配的Bean定义，例如<code>jdkMyBean</code>和<code>onlyJdk</code>在前面的示例中，是带有目标类的普通旧Bean定义。会自动创建AOP代理<code>BeanNameAutoProxyCreator</code>。相同的建议适用于所有匹配的bean。注意，如果使用了顾问程序（而不是前面的示例中的拦截器），则切入点可能会不同地应用于不同的bean。</p> <h5 id=DefaultAdvisorAutoProxyCreator><a class=headerlink href=#DefaultAdvisorAutoProxyCreator title=DefaultAdvisorAutoProxyCreator></a>DefaultAdvisorAutoProxyCreator</h5><p>一个更通用，功能极其强大的自动代理创建者是 <code>DefaultAdvisorAutoProxyCreator</code>。这会自动在当前上下文中应用合格的顾问程序，而无需在自动代理顾问程序的Bean定义中包括特定的Bean名称。它具有与一致的配置和避免重复的优点<code>BeanNameAutoProxyCreator</code>。</p> <p>使用此机制涉及：</p> <ul><li>指定<code>DefaultAdvisorAutoProxyCreator</code>bean定义。<li>在相同或相关的上下文中指定任意数量的顾问。请注意，这些必须是顾问程序，而不是拦截器或其他建议。这是必要的，因为必须有一个评估的切入点，以检查每个建议是否符合候选bean定义。</ul> <p>该<code>DefaultAdvisorAutoProxyCreator</code>自动评估包括在每个advisor中的切入点，看看有什么（如果有的话）的建议，应该适用于每个业务对象（比如<code>businessObject1</code>和<code>businessObject2</code>在本例中）。</p> <p>这意味着可以将任意数量的顾问程序自动应用于每个业务对象。如果在任何顾问程序中没有切入点与业务对象中的任何方法匹配，则该对象不会被代理。当为新的业务对象添加Bean定义时，如有必要，它们会自动被代理。</p> <p>通常，自动代理的优点是使调用者或依赖项无法获得未建议的对象。调用<code>getBean("businessObject1")</code>此方法 <code>ApplicationContext</code>将返回AOP代理，而不是目标业务对象。（前面显示的“ inner bean”成语也提供了这一好处。）</p> <p>以下示例创建一个<code>DefaultAdvisorAutoProxyCreator</code>bean和本节中讨论的其他元素：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"</span>/></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"transactionInterceptor"</span> <span class=attr>ref</span>=<span class=string>"transactionInterceptor"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"customAdvisor"</span> <span class=attr>class</span>=<span class=string>"com.mycompany.MyAdvisor"</span>/></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"businessObject1"</span> <span class=attr>class</span>=<span class=string>"com.mycompany.BusinessObject1"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- Properties omitted --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"businessObject2"</span> <span class=attr>class</span>=<span class=string>"com.mycompany.BusinessObject2"</span>/></span></span><br></pre></table></figure> <p><code>DefaultAdvisorAutoProxyCreator</code>如果您希望将相同的建议一致地应用于许多业务对象，则很有用。基础结构定义到位后，您可以添加新的业务对象，而无需包括特定的代理配置。您也可以轻松地添加其他方面（例如，跟踪或性能监视方面），而对配置的更改最少。</p> <p>该<code>DefaultAdvisorAutoProxyCreator</code>支持过滤（通过使用一种命名约定，使得只有特定的顾问进行评估，其允许使用多个不同配置，在同一个工厂AdvisorAutoProxyCreators）和订货。<code>org.springframework.core.Ordered</code>如果有问题，顾问可以实现该接口以确保正确的排序。在<code>TransactionAttributeSourceAdvisor</code>前述实施例中使用具有可配置的顺序值。默认设置为无序。</p> <h3 id=2-2-9、使用TargetSource实施><a class=headerlink href=#2-2-9、使用TargetSource实施 title=2.2.9、使用TargetSource实施></a>2.2.9、使用<code>TargetSource</code>实施</h3><p>Spring提供了<code>TargetSource</code>在<code>org.springframework.aop.TargetSource</code>接口中表达 的概念。该接口负责返回实现连接点的“目标对象”。在<code>TargetSource</code> 每一个AOP代理处理一个方法调用时实现请求一个目标实例。</p> <p>使用Spring AOP的开发人员通常不需要直接与<code>TargetSource</code>实现一起工作，但这提供了一种强大的手段来支持池化，热插拔和其他复杂的目标。例如，<code>TargetSource</code>通过使用池来管理实例，池可以为每个调用返回不同的目标实例。</p> <p>如果未指定<code>TargetSource</code>，则使用默认实现包装本地对象。每次调用都会返回相同的目标（与您期望的一样）。</p> <p>本节的其余部分描述了Spring随附的标准目标源以及如何使用它们。</p> <blockquote><p>使用自定义目标源时，目标通常需要是原型而不是单例bean定义。这样，Spring可以在需要时创建一个新的目标实例。</blockquote> <h4 id=2-2-9-1、热插拔目标源><a class=headerlink href=#2-2-9-1、热插拔目标源 title=2.2.9.1、热插拔目标源></a>2.2.9.1、热插拔目标源</h4><p>的<code>org.springframework.aop.target.HotSwappableTargetSource</code>存在让一个AOP代理的目标进行切换，同时让来电者保持自己对它的引用。</p> <p>更改目标源的目标会立即生效。该 <code>HotSwappableTargetSource</code>是线程安全的。</p> <p>您可以使用<code>swap()</code>HotSwappableTargetSource上的方法更改目标，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>HotSwappableTargetSource</span> <span class=variable>swapper</span> <span class=operator>=</span> (HotSwappableTargetSource) beanFactory.getBean(<span class=string>"swapper"</span>);</span><br><span class=line><span class=type>Object</span> <span class=variable>oldTarget</span> <span class=operator>=</span> swapper.swap(newTarget);</span><br></pre></table></figure> <p>以下示例显示了必需的XML定义：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"initialTarget"</span> <span class=attr>class</span>=<span class=string>"mycompany.OldTarget"</span>/></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"swapper"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.target.HotSwappableTargetSource"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>ref</span>=<span class=string>"initialTarget"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"swappable"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.framework.ProxyFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"targetSource"</span> <span class=attr>ref</span>=<span class=string>"swapper"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>前面的<code>swap()</code>调用更改了可交换bean的目标。拥有对该bean的引用的客户端不知道更改，但立即开始达到新目标。</p> <p>尽管此示例未添加任何建议（不必添加建议以使用<code>TargetSource</code>），但任何建议<code>TargetSource</code>都可以与任意建议结合使用。</p> <h4 id=2-2-9-2、汇集目标源><a class=headerlink href=#2-2-9-2、汇集目标源 title=2.2.9.2、汇集目标源></a>2.2.9.2、汇集目标源</h4><p>使用池目标源提供了与无状态会话EJB相似的编程模型，在无状态会话EJB中，维护了相同实例的池，方法调用将释放池中的对象。</p> <p>Spring池和SLSB池之间的关键区别在于，Spring池可以应用于任何POJO。通常，与Spring一样，可以以非侵入性方式应用此服务。</p> <p>Spring提供对Commons Pool 2.2的支持，该池提供了相当有效的池实现。您需要在<code>commons-pool</code>应用程序的类路径上使用Jar才能使用此功能。您也可以子类化 <code>org.springframework.aop.target.AbstractPoolingTargetSource</code>以支持任何其他池化API。</p> <p>以下清单显示了一个示例配置：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"businessObjectTarget"</span> <span class=attr>class</span>=<span class=string>"com.mycompany.MyBusinessObject"</span></span></span><br><span class=line><span class=tag>        <span class=attr>scope</span>=<span class=string>"prototype"</span>></span></span><br><span class=line>    ... properties omitted</span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"poolTargetSource"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.target.CommonsPool2TargetSource"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"targetBeanName"</span> <span class=attr>value</span>=<span class=string>"businessObjectTarget"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"maxSize"</span> <span class=attr>value</span>=<span class=string>"25"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"businessObject"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.framework.ProxyFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"targetSource"</span> <span class=attr>ref</span>=<span class=string>"poolTargetSource"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"interceptorNames"</span> <span class=attr>value</span>=<span class=string>"myInterceptor"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>请注意，目标对象（<code>businessObjectTarget</code>在前面的示例中）必须是原型。这使<code>PoolingTargetSource</code>实现可以创建目标的新实例，以根据需要扩展池。有关其属性的信息，请参见您要使用的<a href=https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframeworkaop/target/AbstractPoolingTargetSource.html rel=noopener target=_blank>javadoc <code>AbstractPoolingTargetSource</code></a>和具体的子类。<code>maxSize</code>是最基本的，并且始终保证存在。</p> <p>在这种情况下，<code>myInterceptor</code>是需要在同一IoC上下文中定义的拦截器的名称。但是，您无需指定拦截器即可使用池。如果只希望池化而没有其他建议，则根本不要设置该 <code>interceptorNames</code>属性。</p> <p>您可以将Spring配置为能够将任何池对象强制转换为 <code>org.springframework.aop.target.PoolingConfig</code>接口，该接口通过介绍来公开有关池的配置和当前大小的信息。您需要定义类似于以下内容的顾问程序：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"poolConfigAdvisor"</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.config.MethodInvokingFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"targetObject"</span> <span class=attr>ref</span>=<span class=string>"poolTargetSource"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"targetMethod"</span> <span class=attr>value</span>=<span class=string>"getPoolingConfigMixin"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>该顾问程序是通过在<code>AbstractPoolingTargetSource</code>类上调用便捷方法而获得的 ，因此可以使用<code>MethodInvokingFactoryBean</code>。该顾问的名称（<code>poolConfigAdvisor</code>，此处）必须在<code>ProxyFactoryBean</code>公开池对象的拦截器名称列表中。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>PoolingConfig</span> <span class=variable>conf</span> <span class=operator>=</span> (PoolingConfig) beanFactory.getBean(<span class=string>"businessObject"</span>);</span><br><span class=line>System.out.println(<span class=string>"Max pool size is "</span> + conf.getMaxSize());</span><br></pre></table></figure> <p>通过使用自动代理，可以实现更简单的池化。您可以设置<code>TargetSource</code>任何自动代理创建者使用的实现。</p> <h4 id=2-2-9-3、原型目标源><a class=headerlink href=#2-2-9-3、原型目标源 title=2.2.9.3、原型目标源></a>2.2.9.3、原型目标源</h4><p>设置“原型”目标源类似于设置池<code>TargetSource</code>。在这种情况下，每次方法调用都会创建目标的新实例。尽管在现代JVM中创建新对象的成本并不高，但是连接新对象（满足其IoC依赖性）的成本可能会更高。因此，没有充分的理由就不应使用此方法。</p> <p>为此，您可以<code>poolTargetSource</code>按如下所示修改前面显示的定义（为清楚起见，我们也更改了名称）：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"prototypeTargetSource"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.target.PrototypeTargetSource"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"targetBeanName"</span> <span class=attr>ref</span>=<span class=string>"businessObjectTarget"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>唯一的属性是目标Bean的名称。在<code>TargetSource</code>实现中使用继承 以确保命名一致。与池化目标源一样，目标Bean必须是原型Bean定义。</p> <h4 id=2-2-9-4、ThreadLocal目标来源><a class=headerlink href=#2-2-9-4、ThreadLocal目标来源 title=2.2.9.4、ThreadLocal目标来源></a>2.2.9.4、ThreadLocal目标来源</h4><p><code>ThreadLocal</code>如果您需要为每个传入请求（每个线程）创建一个对象，则目标源很有用。的概念<code>ThreadLocal</code>提供了一个JDK范围的功能，可以透明地将资源与线程一起存储。设置a <code>ThreadLocalTargetSource</code>几乎与其他类型的目标源所说明的相同，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"threadlocalTargetSource"</span> <span class=attr>class</span>=<span class=string>"org.springframework.aop.target.ThreadLocalTargetSource"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"targetBeanName"</span> <span class=attr>value</span>=<span class=string>"businessObjectTarget"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <blockquote><p><code>ThreadLocal</code>在多线程和多类加载器环境中错误使用实例时，实例会带来严重问题（可能导致内存泄漏）。您应该始终考虑将threadlocal包装在其他一些类中，并且切勿直接使用其<code>ThreadLocal</code>本身（包装类中除外）。另外，您应该始终记住正确设置和取消设置<code>ThreadLocal.set(null)</code>线程本地资源（在后者只是涉及到的调用 ）。在任何情况下都应进行取消设置，因为不取消设置可能会导致出现问题。Spring的 <code>ThreadLocal</code>支持为您做到了这一点，应该始终考虑使用 <code>ThreadLocal</code>不带其他适当处理代码的实例。</blockquote> <h3 id=2-2-10、定义新的建议类型><a class=headerlink href=#2-2-10、定义新的建议类型 title=2.2.10、定义新的建议类型></a>2.2.10、定义新的建议类型</h3><p>Spring AOP被设计为可扩展的。尽管目前在内部使用拦截实现策略，但是除了在建议周围，在建议之前，抛出建议和返回建议之后进行拦截之外，还可以支持任意建议类型。</p> <p>该<code>org.springframework.aop.framework.adapter</code>软件包是一个SPI软件包，可以在不更改核心框架的情况下添加对新的自定义建议类型的支持。对自定义<code>Advice</code>类型的唯一限制是它必须实现 <code>org.aopalliance.aop.Advice</code>标记接口。</p> <p>See the <a href=https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/aop/framework/adapter/package-frame.html rel=noopener target=_blank><code>org.springframework.aop.framework.adapter</code></a> javadoc for further information.</p> <h2 id=2-3、AOP><a class=headerlink href=#2-3、AOP title=2.3、AOP></a>2.3、AOP</h2><p>面向方面的编程（AOP）通过提供另一种思考程序结构的方式来补充面向对象的编程（OOP）。OOP中模块化的关键单元是类，而在AOP中模块化是方面。方面支持跨多种类型和对象的关注点（例如事务管理）的模块化。（这种关注在AOP文献中通常被称为“跨领域”关注。）</p> <p>Spring的关键组件之一是AOP框架。尽管Spring IoC容器不依赖于AOP（这意味着您不需要的话就不需要使用AOP），但是AOP对Spring IoC进行了补充，以提供功能强大的中间件解决方案。</p> <blockquote><p>具有AspectJ切入点的Spring AOP<p>Spring通过使用<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-schema rel=noopener target=_blank>基于模式的方法</a>或<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj rel=noopener target=_blank>@AspectJ批注样式，</a>提供了编写自定义方面的简单而强大的方法 。这两种样式都提供了完全类型化的建议，并使用了AspectJ切入点语言，同时仍使用Spring AOP进行编织。</blockquote> <p>AOP在Spring框架中用于：</p> <ul><li>提供声明式企业服务。最重要的服务是 <a href=https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction-declarative rel=noopener target=_blank>声明式事务管理</a>。<li>让用户实现自定义方面，以AOP补充其对OOP的使用。</ul> <h3 id=2-3-1、AOP概念><a class=headerlink href=#2-3-1、AOP概念 title=2.3.1、AOP概念></a>2.3.1、AOP概念</h3><p>首先定义一些主要的AOP概念和术语。这些术语不是特定于Spring的。不幸的是，AOP术语并不是特别直观。但是，如果使用Spring自己的术语，将会更加令人困惑。</p> <ul><li>方面：涉及多个类别的关注点的模块化。在Spring AOP中，方面是通过使用常规类（<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-schema rel=noopener target=_blank>基于模式的方法</a>）或使用注释进行<code>@Aspect</code>注释的常规类 （<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj rel=noopener target=_blank>@AspectJ样式</a>）来实现的。<li>连接点：在程序执行过程中的一点，例如方法的执行或异常的处理。在Spring AOP中，连接点始终代表方法的执行。<li>通知：方面在特定的连接点处采取的操作。<li>切入点：与连接点匹配的谓词。建议与切入点表达式关联，并在与该切入点匹配的任何连接点处运行（例如，执行具有特定名称的方法）。切入点表达式匹配的连接点的概念是AOP的核心，默认情况下，Spring使用AspectJ切入点表达语言。<li>简介：代表类型声明其他方法或字段。Spring AOP允许您向任何建议对象引入新接口（和相应的实现）。例如，您可以使用简介使Bean实现 <code>IsModified</code>接口，以简化缓存。（在AspectJ社区中，介绍被称为类型间声明。）<li>目标对象：一个或多个方面建议的对象。也称为“建议对象”。由于Spring AOP是使用运行时代理实现的，因此该对象始终是代理对象。<li>AOP代理：由AOP框架创建的一个对象，用于实现方面合同（建议方法执行等）。在Spring中，AOP代理是JDK动态代理或CGLIB代理。<li>编织：将方面与其他应用程序类型或对象链接以创建建议的对象。这可以在编译时（例如，使用AspectJ编译器），加载时或在运行时完成。像其他纯Java AOP框架一样，Spring AOP在运行时执行编织。</ul> <p>Spring AOP包括以下类型的通知：</p> <ul><li>前置通知：在连接点之前运行的建议，但是它不能阻止执行流程继续进行到连接点（除非它引发异常）。<li>返回后通知：在连接点正常完成之后要运行的建议（例如，如果方法返回而没有引发异常）。<li>异常通知：如果方法因引发异常而退出，则运行建议。<li>后置通知：无论连接点退出的方式如何（正常或特殊收益），均应执行建议。<li>环绕通知：围绕连接点的建议，例如方法调用。这是最有力的建议。环绕通知可以在方法调用之前和之后执行自定义行为。它还负责选择是返回连接点还是通过返回其自身的返回值或引发异常来捷径建议的方法执行。</ul> <p>环绕通知是最通用的通知。由于Spring AOP与AspectJ一样，提供了各种建议类型，因此我们建议您使用功能最弱的建议类型，以实现所需的行为。使用最具体的通知类型可以提供更简单的编程模型，并减少出错的可能性。</p> <p>所有通知参数都是静态的，因此您可以使用适当类型（例如，方法执行的返回值的类型）而不是<code>Object</code>数组的通知参数。</p> <p>切入点匹配的连接点的概念是AOP的关键，它与仅提供拦截功能的旧技术有所不同。切入点使通知的目标独立于面向对象的层次结构。</p> <h3 id=2-3-2、Spring-AOP能力和目标><a title="2.3.2、Spring AOP能力和目标" class=headerlink href=#2-3-2、Spring-AOP能力和目标></a>2.3.2、Spring AOP能力和目标</h3><p>Spring AOP是用纯Java实现的。不需要特殊的编译过程。Spring AOP不需要控制类加载器的层次结构，因此适合在Servlet容器或应用程序服务器中使用。</p> <p>Spring AOP当前仅支持方法执行连接点（建议在Spring Bean上执行方法）。尽管可以在不破坏核心Spring AOP API的情况下添加对字段拦截的支持，但并未实现字段拦截。如果需要通知字段访问和更新连接点，请考虑使用诸如AspectJ之类的语言。</p> <p>Spring AOP的目的是在AOP实现和Spring IoC之间提供紧密的集成，以帮助解决企业应用程序中的常见问题。</p> <p>Spring无缝地将Spring AOP和IoC与AspectJ集成在一起，以在基于Spring的一致应用程序架构中支持AOP的所有使用。</p> <h3 id=2-3-3、AOP代理><a class=headerlink href=#2-3-3、AOP代理 title=2.3.3、AOP代理></a>2.3.3、AOP代理</h3><p>Spring AOP默认将JDK动态代理用于AOP代理。</p> <p>Spring AOP也可以使用CGLIB代理。默认情况下，如果业务对象未实现接口，则使用CGLIB。由于最好是对接口而不是对类进行编程，因此业务类通常实现一个或多个业务接口。</p> <h3 id=2-3-4、-AspectJ支持><a class=headerlink href=#2-3-4、-AspectJ支持 title=2.3.4、@AspectJ支持></a>2.3.4、@AspectJ支持</h3><p>@AspectJ是一种将方面声明为带有注释的常规Java类的样式。Spring使用AspectJ提供的用于切入点解析和匹配的库来解释与AspectJ 5相同的注释。但是，AOP运行时仍然是纯Spring AOP，并且不依赖于AspectJ编译器或编织器。</p> <h4 id=2-3-4-1、启用-AspectJ支持><a class=headerlink href=#2-3-4-1、启用-AspectJ支持 title=2.3.4.1、启用@AspectJ支持></a>2.3.4.1、启用@AspectJ支持</h4><p>可以使用XML或Java样式的配置来启用@AspectJ支持。无论哪种情况，您都需要确保AspectJ的<code>aspectj-weaver.jar</code>库位于应用程序的类路径（版本1.8或更高版本）上。</p> <h5 id=通过Java配置启用-AspectJ支持><a class=headerlink href=#通过Java配置启用-AspectJ支持 title=通过Java配置启用@AspectJ支持></a>通过Java配置启用@AspectJ支持</h5><p>要使用Java<code>@Configuration</code>启用@AspectJ支持，请添加<code>@EnableAspectJAutoProxy</code> 注释，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableAspectJAutoProxy</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=通过XML配置启用-AspectJ支持><a class=headerlink href=#通过XML配置启用-AspectJ支持 title=通过XML配置启用@AspectJ支持></a>通过XML配置启用@AspectJ支持</h5><p>要使用基于XML的配置启用@AspectJ支持，请使用<code>aop:aspectj-autoproxy</code> 元素，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspectj-autoproxy</span>/></span></span><br></pre></table></figure> <h4 id=2-3-4-2、声明一个方面><a class=headerlink href=#2-3-4-2、声明一个方面 title=2.3.4.2、声明一个方面></a>2.3.4.2、声明一个方面</h4><p>启用@AspectJ支持后，<code>@Aspect</code>Spring会自动检测到在应用程序上下文中使用@AspectJ方面（具有注释）的类定义的任何bean，并用于配置Spring AOP。接下来的两个示例显示了一个不太有用的方面所需的最小定义。</p> <p>这两个示例中的第一个示例显示了应用程序上下文中的常规bean定义，该定义指向具有<code>@Aspect</code>注释的bean类：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"myAspect"</span> <span class=attr>class</span>=<span class=string>"org.xyz.NotVeryUsefulAspect"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- configure properties of the aspect here --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>这两个示例中的第二个示例显示了<code>NotVeryUsefulAspect</code>类定义，该类定义带有<code>org.aspectj.lang.annotation.Aspect</code>批注；</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> org.xyz;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">NotVeryUsefulAspect</span> {</span><br><span class=line>}</span><br></pre></table></figure> <p>方面（带有<code>@Aspect</code>注释的类）可以具有方法和字段，与任何其他类相同。它们还可以包含切入点，通知和介绍（类型间）声明。</p> <blockquote><ul><li><p>通过组件扫描自动检测方面</p> <p>您可以将方面类注册为Spring XML配置中的常规bean，也可以通过类路径扫描自动检测它们-与其他任何Spring管理的bean一样。但是，请注意，<code>@Aspect</code>注释不足以在类路径中进行自动检测。为此，您需要添加一个单独的<code>@Component</code>注释（或者，或者，按照Spring的组件扫描程序的规则，一个合格的自定义原型注释）。</p><li><p>向其他方面提供建议？</p> <p>在Spring AOP中，方面本身不能成为其他方面的建议目标。<code>@Aspect</code>类上的注释将其标记为一个方面，因此将其从自动代理中排除。</p></ul></blockquote> <h4 id=2-3-4-3、声明切入点><a class=headerlink href=#2-3-4-3、声明切入点 title=2.3.4.3、声明切入点></a>2.3.4.3、声明切入点</h4><p>切入点声明由两部分组成：一个包含名称和任何参数的签名以及一个切入点表达式，该切入点表达式精确确定我们感兴趣的方法执行。在AOP的@AspectJ批注样式中，常规方法定义提供了切入点签名，并通过使用<code>@Pointcut</code>注释指示切入点表达式（用作切入点签名的方法必须具有<code>void</code>返回类型）。</p> <p>一个示例可能有助于使切入点签名和切入点表达式之间的区别变得清晰。以下示例定义了一个名为pointpoint的切入点<code>anyOldTransfer</code>，该切入点与任何名为<code>transfer</code>d的方法的执行相匹配：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta>@Pointcut("execution(* transfer(..))")</span> <span class=comment>// the pointcut expression</span></span><br><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">anyOldTransfer</span><span class=params>()</span> {} <span class=comment>// the pointcut signature</span></span><br></pre></table></figure> <p>形成<code>@Pointcut</code>注释值的切入点表达式是一个常规的AspectJ 5切入点表达式。</p> <h5 id=支持的切入点指示符><a class=headerlink href=#支持的切入点指示符 title=支持的切入点指示符></a>支持的切入点指示符</h5><p>Spring AOP支持以下在切入点表达式中使用的AspectJ切入点指示符（PCD）：</p> <ul><li><code>execution</code>：用于匹配方法执行的连接点。这是使用Spring AOP时要使用的主要切入点指示符。<li><code>within</code>：将匹配限制为某些类型内的连接点（使用Spring AOP时，在匹配类型内声明的方法的执行）。<li><code>this</code>：将匹配限制为连接点（使用Spring AOP时方法的执行），其中bean引用（Spring AOP代理）是给定类型的实例。<li><code>target</code>：在目标对象（代理的应用程序对象）是给定类型的实例的情况下，将匹配限制为连接点（使用Spring AOP时方法的执行）。<li><code>args</code>：将匹配限制为连接点（使用Spring AOP时方法的执行），其中参数是给定类型的实例。<li><code>@target</code>：在执行对象的类具有给定类型的注释的情况下，将匹配限制为连接点（使用Spring AOP时方法的执行）。<li><code>@args</code>：限制匹配的连接点（使用Spring AOP时方法的执行），其中传递的实际参数的运行时类型具有给定类型的注释。<li><code>@within</code>：将匹配限制为具有给定注释的类型内的连接点（使用Spring AOP时，使用给定注释的类型中声明的方法的执行）。<li><code>@annotation</code>：将匹配点限制为连接点的主题（在Spring AOP中运行的方法）具有给定注释的连接点。</ul> <blockquote><p>其他切入点类型?<p>完整的AspectJ切入点语言支持未在Spring支持额外的切入点指示符：<code>call</code>，<code>get</code>，<code>set</code>，<code>preinitialization</code>， <code>staticinitialization</code>，<code>initialization</code>，<code>handler</code>，<code>adviceexecution</code>，<code>withincode</code>，<code>cflow</code>， <code>cflowbelow</code>，<code>if</code>，<code>@this</code>，和<code>@withincode</code>。在Spring AOP解释的切入点表达式中使用这些切入点指示符会导致<code>IllegalArgumentException</code>抛出异常。<p>Spring AOP支持的切入点指示符集合可能会在将来的版本中扩展，以支持更多的AspectJ切入点指示符。</blockquote> <p>因为Spring AOP将匹配限制为仅方法执行连接点，所以前面对切入点指示符的讨论所给出的定义比AspectJ编程指南中的定义要窄。除此之外，AspectJ本身具有基于类型的语义和，在执行的连接点，无论是<code>this</code>和<code>target</code>指的是相同的对象：对象执行方法。Spring AOP是基于代理的系统，可区分代理对象本身（绑定到<code>this</code>）和代理后面的目标对象（绑定到<code>target</code>）。</p> <p>Spring AOP还支持一个名为的附加PCD <code>bean</code>。使用PCD，可以将连接点的匹配限制为特定的命名Spring Bean或一组命名Spring Bean（使用通配符时）。该<code>bean</code>PCD形式如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>bean(idOrNameOfBean)</span><br></pre></table></figure> <p>该<code>idOrNameOfBean</code>令牌可以是任何Spring bean的名字。提供了使用<code>*</code>字符的有限通配符支持，因此，如果为Spring bean建立了一些命名约定，则可以编写<code>bean</code>PCD表达式来选择它们。与其他切入点指示符一样，<code>bean</code>PCD也可以与<code>&&</code>（和），<code>||</code>（或）和<code>!</code>（取反）运算符一起使用。</p> <h5 id=组合切入点表达式><a class=headerlink href=#组合切入点表达式 title=组合切入点表达式></a>组合切入点表达式</h5><p>您可以使用<code>&&,</code> <code>||</code>和组合切入点表达式<code>!</code>。您也可以按名称引用切入点表达式。以下示例显示了三个切入点表达式：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Pointcut("execution(public * *(..))")</span></span><br><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">anyPublicOperation</span><span class=params>()</span> {} </span><br><span class=line></span><br><span class=line><span class=meta>@Pointcut("within(com.xyz.myapp.trading..*)")</span></span><br><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">inTrading</span><span class=params>()</span> {} </span><br><span class=line></span><br><span class=line><span class=meta>@Pointcut("anyPublicOperation() && inTrading()")</span></span><br><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">tradingOperation</span><span class=params>()</span> {} </span><br></pre></table></figure> <ol><li><code>anyPublicOperation</code> 如果方法执行连接点表示任何公共方法的执行，则匹配。<li><code>inTrading</code> 如果交易模块中有方法执行，则匹配。<li><code>tradingOperation</code> 如果方法执行代表交易模块中的任何公共方法，则匹配。</ol> <p>最佳实践是从较小的命名组件中构建更复杂的切入点表达式，如先前所示。当按名称引用切入点时，将应用常规的Java可见性规则（您可以看到相同类型的私有切入点，层次结构中受保护的切入点，任何位置的公共切入点，等等）。可见性不影响切入点匹配。</p> <h5 id=共享通用切入点定义><a class=headerlink href=#共享通用切入点定义 title=共享通用切入点定义></a>共享通用切入点定义</h5><p>在使用企业应用程序时，开发人员通常希望从多个方面引用应用程序的模块和特定的操作集。我们建议<code>CommonPointcuts</code>为此定义一个方面，以捕获常见的切入点表达式。这样的方面通常类似于以下示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.xyz.myapp;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CommonPointcuts</span> {</span><br><span class=line>    <span class=meta>@Pointcut("within(com.xyz.myapp.web..*)")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">inWebLayer</span><span class=params>()</span> {}</span><br><span class=line></span><br><span class=line>    <span class=meta>@Pointcut("within(com.xyz.myapp.service..*)")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">inServiceLayer</span><span class=params>()</span> {}</span><br><span class=line></span><br><span class=line>    <span class=meta>@Pointcut("within(com.xyz.myapp.dao..*)")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">inDataAccessLayer</span><span class=params>()</span> {}</span><br><span class=line></span><br><span class=line>    <span class=meta>@Pointcut("execution(* com.xyz.myapp..service.*.*(..))")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">businessService</span><span class=params>()</span> {}</span><br><span class=line></span><br><span class=line>    <span class=meta>@Pointcut("execution(* com.xyz.myapp.dao.*.*(..))")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">dataAccessOperation</span><span class=params>()</span> {}</span><br><span class=line>}</span><br></pre></table></figure> <p>您可以在需要切入点表达式的任何地方引用在这样的方面中定义的切入点。例如，要使服务层具有事务性，您可以编写以下内容：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:advisor</span></span></span><br><span class=line><span class=tag>        <span class=attr>pointcut</span>=<span class=string>"com.xyz.myapp.CommonPointcuts.businessService()"</span></span></span><br><span class=line><span class=tag>        <span class=attr>advice-ref</span>=<span class=string>"tx-advice"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>tx:advice</span> <span class=attr>id</span>=<span class=string>"tx-advice"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>tx:attributes</span>></span></span><br><span class=line>        <span class=tag><<span class=name>tx:method</span> <span class=attr>name</span>=<span class=string>"*"</span> <span class=attr>propagation</span>=<span class=string>"REQUIRED"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>tx:attributes</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>tx:advice</span>></span></span><br></pre></table></figure> <p>的<code>&LTaop:config></code>和<code>&LTaop:advisor></code>元件在讨论<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-schema rel=noopener target=_blank>基于Schema的AOP支持</a>。<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction rel=noopener target=_blank>事务管理</a>中讨论了<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction rel=noopener target=_blank>事务</a>元素。</p> <h5 id=编写好的切入点><a class=headerlink href=#编写好的切入点 title=编写好的切入点></a>编写好的切入点</h5><p>现有的指示符自然会属于以下三类之一：同类，作用域和上下文：</p> <ul><li>Kinded代号选择特定类型的连接点： <code>execution</code>，<code>get</code>，<code>set</code>，<code>call</code>，和<code>handler</code>。<li>作用域指定者选择一组感兴趣的连接点（可能有多种）：<code>within</code>和<code>withincode</code><li>语境指示符基于上下文匹配（和任选的绑定）： ， <code>this</code>，<code>target</code>和<code>@annotation</code></ul> <p>编写正确的切入点至少应包括前两种类型（种类和作用域）。您可以包括上下文指示符以根据连接点上下文进行匹配，也可以绑定该上下文以在建议中使用。仅提供同类的标识符或仅提供上下文的标识符是可行的，但是由于额外的处理和分析，可能会影响编织性能（使用的时间和内存）。范围指定符的匹配非常快，使用它们的使用意味着AspectJ可以非常迅速地消除不应进一步处理的连接点组。一个好的切入点应该始终包括一个切入点。</p> <h4 id=2-3-4-4、声明通知><a class=headerlink href=#2-3-4-4、声明通知 title=2.3.4.4、声明通知></a>2.3.4.4、声明通知</h4><h5 id=before通知><a class=headerlink href=#before通知 title=before通知></a>before通知</h5><p>您可以使用<code>@Before</code>注释在方面之前声明通知：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Before;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BeforeExample</span> {</span><br><span class=line>    <span class=meta>@Before("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doAccessCheck</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>如果使用就地切入点表达式，则可以将前面的示例重写为以下示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Before;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BeforeExample</span> {</span><br><span class=line>    <span class=meta>@Before("execution(* com.xyz.myapp.dao.*.*(..))")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doAccessCheck</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=after通知><a class=headerlink href=#after通知 title=after通知></a>after通知</h5><p>当匹配的方法执行退出时，建议（最终）运行。通过使用<code>@After</code>注释声明它。之后必须准备处理正常和异常返回条件的建议。它通常用于释放资源和类似目的。以下示例显示了最终通知后的用法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.After;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AfterFinallyExample</span> {</span><br><span class=line>    <span class=meta>@After("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doReleaseLock</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <blockquote><p>请注意，<code>@After</code>AspectJ中的通知被定义为“ after finally通知”，类似于try-catch语句中的finally块。它将针对从连接点（用户声明的目标方法）抛出的任何结果，正常返回或异常（<code>@AfterReturning</code>仅适用于成功的正常返回）进行调用。</blockquote> <h5 id=返回后通知-1><a class=headerlink href=#返回后通知-1 title=返回后通知></a>返回后通知</h5><p>返回通知后，当匹配的方法执行正常返回时运行建议。您可以使用<code>@AfterReturning</code>批注进行声明：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AfterReturningExample</span> {</span><br><span class=line>    <span class=meta>@AfterReturning("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doAccessCheck</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>有时，您需要在通知正文中访问返回的实际值。您可以使用<code>@AfterReturning</code>绑定返回值的形式来获得该访问权限，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.AfterReturning;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AfterReturningExample</span> {</span><br><span class=line></span><br><span class=line>    <span class=meta>@AfterReturning(</span></span><br><span class=line><span class=meta>        pointcut="com.xyz.myapp.CommonPointcuts.dataAccessOperation()",</span></span><br><span class=line><span class=meta>        returning="retVal")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doAccessCheck</span><span class=params>(Object retVal)</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p><code>returning</code>属性中使用的名称必须与advice方法中的参数名称相对应。当方法执行返回时，返回值将作为相应的参数值传递到通知方法。甲<code>returning</code>子句也限制了只能匹配到返回指定类型的值（在这种情况下，那些方法执行<code>Object</code>，它匹配任何返回值）。</p> <h5 id=异常后通知><a class=headerlink href=#异常后通知 title=异常后通知></a>异常后通知</h5><p>抛出通知后，当匹配的方法执行通过抛出异常退出时，运行通知。您可以使用<code>@AfterThrowing</code>批注进行声明，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AfterThrowingExample</span> {</span><br><span class=line>    <span class=meta>@AfterThrowing("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doRecoveryActions</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>通常，您希望通知仅在引发给定类型的异常时才运行，并且您通常还需要访问通知正文中的引发异常。您可以使用该<code>throwing</code>属性来限制匹配（如果需要-<code>Throwable</code> 否则请用作异常类型），并将抛出的异常绑定到advice参数。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.AfterThrowing;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AfterThrowingExample</span> {</span><br><span class=line>    <span class=meta>@AfterThrowing(</span></span><br><span class=line><span class=meta>        pointcut="com.xyz.myapp.CommonPointcuts.dataAccessOperation()",</span></span><br><span class=line><span class=meta>        throwing="ex")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doRecoveryActions</span><span class=params>(DataAccessException ex)</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p><code>throwing</code>属性中使用的名称必须与advice方法中的参数名称相对应。当通过抛出异常退出方法执行时，该异常将作为相应的参数值传递给通知方法。甲<code>throwing</code>子句也限制了只能匹配到抛出指定类型的异常（那些方法执行<code>DataAccessException</code>，在这种情况下）。</p> <h5 id=环绕通知><a class=headerlink href=#环绕通知 title=环绕通知></a>环绕通知</h5><p>环绕通知在匹配方法的执行过程中“环绕”运行。它有机会在方法运行之前和之后进行工作，并确定何时，如何以及甚至实际上该方法可以运行。如果需要以线程安全的方式（例如，启动和停止计时器）在方法执行之前和之后共享状态，则通常使用绕行通知。</p> <p>通过使用<code>@Around</code>注释来声明环绕通知。咨询方法的第一个参数必须为类型<code>ProceedingJoinPoint</code>。在通知的主体，要求<code>proceed()</code>对<code>ProceedingJoinPoint</code>导致运行基本方法。该<code>proceed</code>方法还可以传递<code>Object[]</code>。数组中的值用作方法执行时的参数。</p> <p>以下示例显示了如何使用环绕通知：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Around;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AroundExample</span> {</span><br><span class=line>    <span class=meta>@Around("com.xyz.myapp.CommonPointcuts.businessService()")</span></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">doBasicProfiling</span><span class=params>(ProceedingJoinPoint pjp)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        <span class=comment>// start stopwatch</span></span><br><span class=line>        <span class=type>Object</span> <span class=variable>retVal</span> <span class=operator>=</span> pjp.proceed();</span><br><span class=line>        <span class=comment>// stop stopwatch</span></span><br><span class=line>        <span class=keyword>return</span> retVal;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>环绕通知返回的值是该方法的调用者看到的返回值。例如，如果一个简单的缓存方面有一个值，则可以从缓存中返回一个值，如果没有则调用<code>proceed()</code>。请注意，<code>proceed</code>在周围建议的正文中可能调用一次，多次调用或根本不调用该调用。所有这些都是合法的。</p> <h5 id=通知参数><a class=headerlink href=#通知参数 title=通知参数></a>通知参数</h5><p>Spring提供了完全类型化的建议，这意味着您可以在建议签名中声明所需的参数（如我们先前在返回和抛出示例中所看到的），而不是一直使用<code>Object[]</code>数组。我们将在本节的后面部分介绍如何使参数和其他上下文值可用于建议主体。首先，我们看一下如何编写通用建议，以了解该建议当前建议的方法。</p> <h6 id=访问当前JoinPoint><a class=headerlink href=#访问当前JoinPoint title=访问当前JoinPoint></a>访问当前JoinPoint</h6><p>任何通知方法都可以将类型的参数声明为它的第一个参数 <code>org.aspectj.lang.JoinPoint</code>（请注意，在通知周围需要声明类型的第一个参数<code>ProceedingJoinPoint</code>，它是的子类<code>JoinPoint</code>。<code>JoinPoint</code>接口提供了许多有用的方法：</p> <ul><li><code>getArgs()</code>：返回方法参数。<li><code>getThis()</code>：返回代理对象。<li><code>getTarget()</code>：返回目标对象。<li><code>getSignature()</code>：返回建议使用的方法的描述。<li><code>toString()</code>：打印有关所建议方法的有用描述。</ul> <h6 id=将参数传递给通知><a class=headerlink href=#将参数传递给通知 title=将参数传递给通知></a>将参数传递给通知</h6><p>假设您要通知执行以<code>Account</code> 对象为第一个参数的DAO操作，并且需要访问通知正文中的帐户。您可以编写以下内容：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Before("com.xyz.myapp.CommonPointcuts.dataAccessOperation() && args(account,..)")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">validateAccount</span><span class=params>(Account account)</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p><code>args(account,..)</code>切入点表达式的一部分有两个目的。首先，它将匹配限制为仅方法采用至少一个参数且传递给该参数的参数为的实例的方法执行<code>Account</code>。其次，它<code>Account</code>通过<code>account</code> 参数使实际对象可用于通知。</p> <p>编写此内容的另一种方法是声明一个切入点，<code>Account</code> 当切入点与连接点匹配时“提供”对象值，然后从通知中引用命名的切入点。如下所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Pointcut("com.xyz.myapp.CommonPointcuts.dataAccessOperation() && args(account,..)")</span></span><br><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">accountDataAccessOperation</span><span class=params>(Account account)</span> {}</span><br><span class=line></span><br><span class=line><span class=meta>@Before("accountDataAccessOperation(account)")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">validateAccount</span><span class=params>(Account account)</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>代理对象（<code>this</code>），目标对象（<code>target</code>），和说明（<code>@within</code>， <code>@target</code>，<code>@annotation</code>，和<code>@args</code>）都可以以类似的方式结合。接下来的两个示例展示了如何匹配使用注释进行<code>@Auditable</code>注释的方法的执行 并提取审计代码：</p> <p>这两个示例中的第一个示例显示了<code>@Auditable</code>注释的定义：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=line><span class=meta>@Target(ElementType.METHOD)</span></span><br><span class=line><span class=keyword>public</span> <span class=meta>@interface</span> Auditable {</span><br><span class=line>    AuditCode <span class="title function_">value</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>这两个示例中的第二个示例显示了与<code>@Auditable</code>方法执行相匹配的建议：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Before("com.xyz.lib.Pointcuts.anyPublicMethod() && @annotation(auditable)")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">audit</span><span class=params>(Auditable auditable)</span> {</span><br><span class=line>    <span class=type>AuditCode</span> <span class=variable>code</span> <span class=operator>=</span> auditable.value();</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <h6 id=通知参数和泛型><a class=headerlink href=#通知参数和泛型 title=通知参数和泛型></a>通知参数和泛型</h6><p>Spring AOP可以处理类声明和方法参数中使用的泛型。假设您具有如下通用类型：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Sample</span>&LTT> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">sampleGenericMethod</span><span class=params>(T param)</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">sampleGenericCollectionMethod</span><span class=params>(Collection&LTT> param)</span>;</span><br><span class=line>}</span><br></pre></table></figure> <p>您可以通过在要拦截方法的参数类型中键入advice参数，将方法类型的侦听限制为某些参数类型：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Before("execution(* ..Sample+.sampleGenericMethod(*)) && args(param)")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">beforeSampleMethod</span><span class=params>(MyType param)</span> {</span><br><span class=line>    <span class=comment>// Advice implementation</span></span><br><span class=line>}</span><br></pre></table></figure> <p>这种方法不适用于通用集合。因此，您不能按以下方式定义切入点：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Before("execution(* ..Sample+.sampleGenericCollectionMethod(*)) && args(param)")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">beforeSampleMethod</span><span class=params>(Collection&LTMyType> param)</span> {</span><br><span class=line>    <span class=comment>// Advice implementation</span></span><br><span class=line>}</span><br></pre></table></figure> <p>为了使这项工作有效，我们将不得不检查集合中的每个元素，这是不合理的，因为我们也无法决定<code>null</code>总体上如何对待价值。要实现与此类似的功能，您必须在上键入参数<code>Collection&LT?></code>并手动检查元素的类型。</p> <h6 id=确定参数命名称><a class=headerlink href=#确定参数命名称 title=确定参数命名称></a>确定参数命名称</h6><p>通知调用中的参数绑定依赖于切入点表达式中使用的名称与通知和切入点方法签名中声明的参数名称的匹配。通过Java反射无法获得参数名称，因此Spring AOP使用以下策略来确定参数名称：</p> <ul><li>如果用户已明确指定参数名称，则使用指定的参数名称。建议和切入点注释都具有可选<code>argNames</code>属性，您可以使用该属性指定带注释方法的参数名称。这些参数名称在运行时可用。以下示例显示如何使用<code>argNames</code>属性：</ul> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)", argNames="bean,auditable")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">audit</span><span class=params>(Object bean, Auditable auditable)</span> {</span><br><span class=line>    <span class=type>AuditCode</span> <span class=variable>code</span> <span class=operator>=</span> auditable.value();</span><br><span class=line>    <span class=comment>// ... use code and bean</span></span><br><span class=line>}</span><br></pre></table></figure> <p>如果第一个参数是的<code>JoinPoint</code>，<code>ProceedingJoinPoint</code>或 <code>JoinPoint.StaticPart</code>类型，你可以从价值离开了参数的名称<code>argNames</code>属性。例如，如果您修改前面的建议以接收连接点对象，则该<code>argNames</code>属性不需要包括它：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)", argNames="bean,auditable")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">audit</span><span class=params>(JoinPoint jp, Object bean, Auditable auditable)</span> {</span><br><span class=line>    <span class=type>AuditCode</span> <span class=variable>code</span> <span class=operator>=</span> auditable.value();</span><br><span class=line>    <span class=comment>// ... use code, bean, and jp</span></span><br><span class=line>}</span><br></pre></table></figure> <p>给出的第一个参数的特殊待遇<code>JoinPoint</code>， <code>ProceedingJoinPoint</code>和<code>JoinPoint.StaticPart</code>类型是不收取任何其它连接上下文的通知情况下，特别方便。在这种情况下，您可以忽略该<code>argNames</code>属性。例如，以下建议无需声明<code>argNames</code>属性：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Before("com.xyz.lib.Pointcuts.anyPublicMethod()")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">audit</span><span class=params>(JoinPoint jp)</span> {</span><br><span class=line>    <span class=comment>// ... use jp</span></span><br><span class=line>}</span><br></pre></table></figure> <ul><li>使用该<code>'argNames'</code>属性有点笨拙，因此，如果<code>'argNames'</code>未指定该属性，Spring AOP将查看该类的调试信息，并尝试从局部变量表中确定参数名称。只要已使用调试信息编译了类（<code>'-g:vars'</code>至少），此信息就存在。启用此标志时进行编译的结果是：（1）您的代码稍微易于理解（反向工程），（2）类文件的大小非常大（通常无关紧要），（3）删除未使用的本地代码的优化变量不适用于您的编译器。换句话说，通过启用该标志，您应该不会遇到任何困难。<li>如果在没有必要调试信息的情况下编译了代码，Spring AOP会尝试推断绑定变量与参数的配对（例如，如果切入点表达式中仅绑定了一个变量，并且advice方法仅接受一个参数，则配对很明显）。如果在给定可用信息的情况下变量的绑定不明确，<code>AmbiguousBindingException</code>则会引发an 。<li>如果以上所有策略均失败，<code>IllegalArgumentException</code>则抛出。</ul> <h6 id=进行论证><a class=headerlink href=#进行论证 title=进行论证></a>进行论证</h6><p>前面我们提到过，我们将描述如何编写一个<code>proceed</code>在Spring AOP和AspectJ中始终有效的参数调用。解决方案是确保建议签名按顺序绑定每个方法参数。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Around("execution(List&LTAccount> find*(..)) && " +</span></span><br><span class=line><span class=meta>        "com.xyz.myapp.CommonPointcuts.inDataAccessLayer() && " +</span></span><br><span class=line><span class=meta>        "args(accountHolderNamePattern)")</span></span><br><span class=line><span class=keyword>public</span> Object <span class="title function_">preProcessQueryPattern</span><span class=params>(ProceedingJoinPoint pjp, String accountHolderNamePattern)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=type>String</span> <span class=variable>newPattern</span> <span class=operator>=</span> preProcess(accountHolderNamePattern);</span><br><span class=line>    <span class=keyword>return</span> pjp.proceed(<span class=keyword>new</span> <span class="title class_">Object</span>[] {newPattern});</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=订购通知><a class=headerlink href=#订购通知 title=订购通知></a>订购通知</h5><p>当多条建议都希望在同一连接点上运行时会发生什么？Spring AOP遵循与AspectJ相同的优先级规则来确定建议执行的顺序。优先级最高的建议首先“在途中”运行（因此，给定两条优先建议，则优先级最高的建议首先运行）。从连接点“出路”中，优先级最高的建议将最后运行（因此，给定两条后置通知，优先级最高的建议将第二次运行）。</p> <p>当在不同方面定义的两条建议都需要在同一连接点上运行时，除非另行指定，否则执行顺序是不确定的。您可以通过指定优先级来控制执行顺序。通过<code>org.springframework.core.Ordered</code>在方面类中实现接口或使用注释对其进行<code>@Order</code>注释，可以以正常的Spring方式完成此操作。给定两个方面，从<code>Ordered.getOrder()</code>（或注释值）返回较低值的方面具有较高的优先级。</p> <blockquote><p>特定方面的每种不同建议类型在概念上均应直接应用于连接点。因此，<code>@AfterThrowing</code>建议方法不应从随附的<code>@After</code>/<code>@AfterReturning</code>方法接收异常。由于Spring框架5.2.7的，在同一个定义的通知方法<code>@Aspect</code>的类，需要在同一连接点运行基于分配优先级上按以下顺序他们的意见类型，从最高到最低的优先级：<code>@Around</code>，<code>@Before</code>，<code>@After</code>， <code>@AfterReturning</code>，<code>@AfterThrowing</code>。但是，请注意，<code>@After</code>将遵循AspectJ的“之后最终建议”语义，在相同方面的任何<code>@AfterReturning</code>或<code>@AfterThrowing</code>建议方法之后有效地调用建议方法<code>@After</code>。当在同一类中<code>@After</code>定义的两个相同类型的建议（例如，两个建议方法）<code>@Aspect</code>都需要在同一连接点上运行时，其顺序是未定义的（因为无法通过以下方式检索源代码声明顺序） Javac编译类的反射）。请考虑将此类建议方法折叠为每个<code>@Aspect</code>类中每个连接点的一个建议方法，或将这些建议重构为单独的<code>@Aspect</code>类，您可以通过<code>Ordered</code>或在方面级别进行排序<code>@Order</code>。</blockquote> <h4 id=2-3-4-5、引言><a class=headerlink href=#2-3-4-5、引言 title=2.3.4.5、引言></a>2.3.4.5、引言</h4><p>您可以使用<code>@DeclareParents</code>注释进行介绍。此批注用于声明匹配类型具有新的父代（因此具有名称）。例如，给定名为<code>UsageTracked</code>的接口和名为的接口的实现 <code>DefaultUsageTracked</code>，以下方面声明服务接口的所有实现者也都实现该<code>UsageTracked</code>接口（例如，通过JMX进行统计）：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">UsageTracking</span> {</span><br><span class=line>    <span class=meta>@DeclareParents(value="com.xzy.myapp.service.*+", defaultImpl=DefaultUsageTracked.class)</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> UsageTracked mixin;</span><br><span class=line>    <span class=meta>@Before("com.xyz.myapp.CommonPointcuts.businessService() && this(usageTracked)")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">recordUsage</span><span class=params>(UsageTracked usageTracked)</span> {</span><br><span class=line>        usageTracked.incrementUseCount();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>要实现的接口由带注释的字段的类型确定。注释的 <code>value</code>属性<code>@DeclareParents</code>是AspectJ类型的模式。任何匹配类型的bean都该实现<code>UsageTracked</code>接口。请注意，在前面示例的通知中，服务Bean可以直接用作<code>UsageTracked</code>接口的实现。如果以编程方式访问bean，则应编写以下内容：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>UsageTracked</span> <span class=variable>usageTracked</span> <span class=operator>=</span> (UsageTracked) context.getBean(<span class=string>"myService"</span>);</span><br></pre></table></figure> <h4 id=2-3-4-6、方面实例化模型><a class=headerlink href=#2-3-4-6、方面实例化模型 title=2.3.4.6、方面实例化模型></a>2.3.4.6、方面实例化模型</h4><p>默认情况下，应用程序上下文中每个方面都有一个实例。AspectJ将此称为单例实例化模型。可以使用备用生命周期来定义方面。Spring支持AspectJ的<code>perthis</code>和<code>pertarget</code> 实例化模型; <code>percflow</code>，<code>percflowbelow</code>和<code>pertypewithin</code>，目前不受支持。</p> <p>您可以通过在<code>@Aspect</code> 注释中指定<code>perthis</code>子句来声明方面。考虑以下示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Aspect("perthis(com.xyz.myapp.CommonPointcuts.businessService())")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyAspect</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> someState;</span><br><span class=line>    <span class=meta>@Before("com.xyz.myapp.CommonPointcuts.businessService()")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">recordServiceUsage</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// ...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>在前面的示例中，<code>perthis</code>子句的作用是为每个执行业务服务的唯一服务对象（每个唯一对象绑定到<code>this</code>与切入点表达式匹配的连接点处）创建一个方面实例。方面实例是在服务对象上首次调用方法时创建的。当服务对象超出范围时，方面将超出范围。在创建方面实例之前，其中的任何建议都不会运行。创建方面实例后，在其中声明的建议将在匹配的连接点处运行，但仅当服务对象是与此方面相关联的对象时才运行。</p> <p>该<code>pertarget</code>实例化样板工程完全相同的方式<code>perthis</code>，但在匹配的连接点，每个独立目标对象创建一个切面实例。</p> <h4 id=2-3-4-7、AOP示例><a class=headerlink href=#2-3-4-7、AOP示例 title=2.3.4.7、AOP示例></a>2.3.4.7、AOP示例</h4><p>因为我们想重试该操作，所以我们需要使用周围建议，以便可以<code>proceed</code>多次调用。以下清单显示了基本方面的实现：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ConcurrentOperationExecutor</span> <span class=keyword>implements</span> <span class="title class_">Ordered</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>final</span> <span class=type>int</span> <span class=variable>DEFAULT_MAX_RETRIES</span> <span class=operator>=</span> <span class=number>2</span>;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>maxRetries</span> <span class=operator>=</span> DEFAULT_MAX_RETRIES;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>order</span> <span class=operator>=</span> <span class=number>1</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMaxRetries</span><span class=params>(<span class=type>int</span> maxRetries)</span> {</span><br><span class=line>        <span class=built_in>this</span>.maxRetries = maxRetries;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">getOrder</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.order;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setOrder</span><span class=params>(<span class=type>int</span> order)</span> {</span><br><span class=line>        <span class=built_in>this</span>.order = order;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Around("com.xyz.myapp.CommonPointcuts.businessService()")</span></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">doConcurrentOperation</span><span class=params>(ProceedingJoinPoint pjp)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        <span class=type>int</span> <span class=variable>numAttempts</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>        PessimisticLockingFailureException lockFailureException;</span><br><span class=line>        <span class=keyword>do</span> {</span><br><span class=line>            numAttempts++;</span><br><span class=line>            <span class=keyword>try</span> {</span><br><span class=line>                <span class=keyword>return</span> pjp.proceed();</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>catch</span>(PessimisticLockingFailureException ex) {</span><br><span class=line>                lockFailureException = ex;</span><br><span class=line>            }</span><br><span class=line>        } <span class=keyword>while</span>(numAttempts <= <span class=built_in>this</span>.maxRetries);</span><br><span class=line>        <span class=keyword>throw</span> lockFailureException;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>请注意，方面实现了<code>Ordered</code>接口，因此我们可以将方面的优先级设置为高于事务建议（每次重试时都希望有新的事务）。该<code>maxRetries</code>和<code>order</code>性能都Spring配置。主要动作发生在<code>doConcurrentOperation</code>周围建议中。请注意，目前，我们将重试逻辑应用于每个<code>businessService()</code>。我们尝试继续，如果失败了<code>PessimisticLockingFailureException</code>，我们将再次尝试，除非我们用尽了所有的重试尝试。</p> <p>相应的Spring配置如下：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspectj-autoproxy</span>/></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"concurrentOperationExecutor"</span> <span class=attr>class</span>=<span class=string>"com.xyz.myapp.service.impl.ConcurrentOperationExecutor"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"maxRetries"</span> <span class=attr>value</span>=<span class=string>"3"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"order"</span> <span class=attr>value</span>=<span class=string>"100"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>为了改进方面，使其仅重试幂等操作，我们可以定义以下 <code>Idempotent</code>注释：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=line><span class=keyword>public</span> <span class=meta>@interface</span> Idempotent {</span><br><span class=line>    <span class=comment>// marker annotation</span></span><br><span class=line>}</span><br></pre></table></figure> <p>然后，我们可以使用注释来注释服务操作的实现。方面更改为仅重试幂等操作涉及到修改切入点表达式，以便仅<code>@Idempotent</code>操作匹配，如下所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Around("com.xyz.myapp.CommonPointcuts.businessService() && " +</span></span><br><span class=line><span class=meta>        "@annotation(com.xyz.myapp.service.Idempotent)")</span></span><br><span class=line><span class=keyword>public</span> Object <span class="title function_">doConcurrentOperation</span><span class=params>(ProceedingJoinPoint pjp)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <h3 id=2-3-5、基于架构的AOP支持><a class=headerlink href=#2-3-5、基于架构的AOP支持 title=2.3.5、基于架构的AOP支持></a>2.3.5、基于架构的AOP支持</h3><p>如果您更喜欢基于XML的格式，Spring还提供了使用<code>aop</code>命名空间标签定义方面的支持。支持与使用@AspectJ样式时完全相同的切入点表达式和建议类型。</p> <p>要使用aop命名空间标签，您需要导入 <code>spring-aop</code>模式，如<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#xsd-schemas rel=noopener target=_blank>基于XML Schema的配置中所述</a>。</p> <p>在您的Spring配置中，所有Aspect和Advisor元素必须放置在一个<code>&LTaop:config></code>元素内（<code>&LTaop:config></code>在应用程序上下文配置中可以有多个元素）。一个<code>&LTaop:config></code>元素可以包含切入点，顾问和纵横元件（注意这些必须按照这个顺序进行声明）。</p> <h4 id=2-3-5-1、声明一个方面><a class=headerlink href=#2-3-5-1、声明一个方面 title=2.3.5.1、声明一个方面></a>2.3.5.1、声明一个方面</h4><p>使用模式支持时，方面是在Spring应用程序上下文中定义为Bean的常规Java对象。状态和行为在对象的字段和方法中捕获，切入点和建议信息在XML中捕获。</p> <p>您可以使用<code>&LTaop:aspect></code>元素声明一个方面，并使用<code>ref</code>属性来引用支持bean ，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"myAspect"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>        ...</span><br><span class=line>    <span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"aBean"</span> <span class=attr>class</span>=<span class=string>"..."</span>></span></span><br><span class=line>    ...</span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>支持方面的Bean（<code>aBean</code>在这种情况下）当然可以像配置任何其他Spring Bean一样进行配置并注入依赖项。</p> <h4 id=2-3-5-2、声明切入点><a class=headerlink href=#2-3-5-2、声明切入点 title=2.3.5.2、声明切入点></a>2.3.5.2、声明切入点</h4><p>您可以在<code>&LTaop:config></code>元素内声明命名的切入点，从而使切入点定义在多个方面和顾问程序之间共享。</p> <p>可以定义代表服务层中任何业务服务的执行的切入点：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"businessService"</span></span></span><br><span class=line><span class=tag>        <span class=attr>expression</span>=<span class=string>"execution(* com.xyz.myapp.service.*.*(..))"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br></pre></table></figure> <p>请注意，切入点表达式本身使用的是<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj rel=noopener target=_blank>@AspectJ support中</a>所述的AspectJ切入点表达式语言。如果使用基于架构的声明样式，则可以引用在切入点表达式中的类型（@Aspects）中定义的命名切入点。定义上述切入点的另一种方法如下：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"businessService"</span></span></span><br><span class=line><span class=tag>        <span class=attr>expression</span>=<span class=string>"com.xyz.myapp.CommonPointcuts.businessService()"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br></pre></table></figure> <p>假定您具有“<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-common-pointcuts rel=noopener target=_blank>共享公共切入点定义”中</a><code>CommonPointcuts</code>描述的方面。</p> <p>然后，在方面中声明切入点与声明顶级切入点非常相似，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"myAspect"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"businessService"</span> <span class=attr>expression</span>=<span class=string>"execution(* com.xyz.myapp.service.*.*(..))"</span>/></span></span><br><span class=line></span><br><span class=line>        ...</span><br><span class=line>    <span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br></pre></table></figure> <p>与@AspectJ方面几乎相同，使用基于架构的定义样式声明的切入点可以收集连接点上下文。例如，以下切入点将<code>this</code>对象收集为连接点上下文，并将其传递给建议：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"myAspect"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"businessService"</span></span></span><br><span class=line><span class=tag>            <span class=attr>expression</span>=<span class=string>"execution(* com.xyz.myapp.service.*.*(..)) <span class=symbol>&ampamp;</span><span class=symbol>&ampamp;</span> this(service)"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>aop:before</span> <span class=attr>pointcut-ref</span>=<span class=string>"businessService"</span> <span class=attr>method</span>=<span class=string>"monitor"</span>/></span></span><br><span class=line>        ...</span><br><span class=line>    <span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br></pre></table></figure> <p>必须声明通知，以通过包含匹配名称的参数来接收收集的连接点上下文，如下所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">monitor</span><span class=params>(Object service)</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>当需要连接子表达式，<code>&&</code>是一个XML文档中的尴尬，这样你就可以使用<code>and</code>，<code>or</code>以及<code>not</code>到位的关键字<code>&&</code>， <code>||</code>和<code>!</code>分别。例如，上一个切入点可以更好地编写如下：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"myAspect"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"businessService"</span></span></span><br><span class=line><span class=tag>            <span class=attr>expression</span>=<span class=string>"execution(* com.xyz.myapp.service.*.*(..)) and this(service)"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>aop:before</span> <span class=attr>pointcut-ref</span>=<span class=string>"businessService"</span> <span class=attr>method</span>=<span class=string>"monitor"</span>/></span></span><br><span class=line></span><br><span class=line>        ...</span><br><span class=line>    <span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br></pre></table></figure> <p>请注意，以这种方式定义的切入点由其XML引用，<code>id</code>不能用作命名切入点以形成复合切入点。因此，基于架构的定义样式中的命名切入点支持比@AspectJ样式所提供的更受限制。</p> <h4 id=2-3-5-3、宣告通知><a class=headerlink href=#2-3-5-3、宣告通知 title=2.3.5.3、宣告通知></a>2.3.5.3、宣告通知</h4><p>基于模式的AOP支持使用与@AspectJ样式相同的五种建议，并且它们具有完全相同的语义。</p> <h5 id=前置通知-1><a class=headerlink href=#前置通知-1 title=前置通知></a>前置通知</h5><p>在执行匹配的方法之前，先运行建议。<code>&LTaop:aspect></code>使用<code>&LTaop:before></code>元素在里面声明它 ，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"beforeExample"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:before</span> <span class=attr>pointcut-ref</span>=<span class=string>"dataAccessOperation"</span> <span class=attr>method</span>=<span class=string>"doAccessCheck"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br></pre></table></figure> <p>这<code>dataAccessOperation</code>是<code>id</code>在顶层（<code>&LTaop:config></code>）定义的切入点的。要改为内联定义切入点，请按如下所示<code>pointcut-ref</code>用<code>pointcut</code>属性替换属性：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"beforeExample"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:before</span> <span class=attr>pointcut</span>=<span class=string>"execution(* com.xyz.myapp.dao.*.*(..))"</span> <span class=attr>method</span>=<span class=string>"doAccessCheck"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br></pre></table></figure> <p>正如我们在@AspectJ样式的讨论中所指出的那样，使用命名的切入点可以显着提高代码的可读性。</p> <p>该<code>method</code>属性标识<code>doAccessCheck</code>提供建议正文的方法（）。必须为包含建议的Aspect元素所引用的bean定义此方法。在执行数据访问操作（与切入点表达式匹配的方法执行连接点）之前，将<code>doAccessCheck</code>调用Aspect Bean上的方法。</p> <h5 id=返回后通知-2><a class=headerlink href=#返回后通知-2 title=返回后通知></a>返回后通知</h5><p>返回的建议在匹配的方法执行正常完成时运行。在内部以<code>&LTaop:aspect></code>与之前建议相同的方式声明它。以下示例显示了如何声明它：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"afterReturningExample"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:after-returning</span> <span class=attr>pointcut-ref</span>=<span class=string>"dataAccessOperation"</span> <span class=attr>method</span>=<span class=string>"doAccessCheck"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br></pre></table></figure> <p>与@AspectJ样式一样，您可以在建议正文中获取返回值。为此，使用<code>returning</code>属性指定返回值应传递到的参数的名称，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"afterReturningExample"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:after-returning</span> <span class=attr>pointcut-ref</span>=<span class=string>"dataAccessOperation"</span> <span class=attr>returning</span>=<span class=string>"retVal"</span> <span class=attr>method</span>=<span class=string>"doAccessCheck"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br></pre></table></figure> <p>该<code>doAccessCheck</code>方法必须声明一个名为的参数<code>retVal</code>。该参数的类型以与所述相同的方式约束匹配<code>@AfterReturning</code>。例如，您可以按以下方式声明方法签名：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doAccessCheck</span><span class=params>(Object retVal)</span> {...}</span><br></pre></table></figure> <h5 id=异常通知-1><a class=headerlink href=#异常通知-1 title=异常通知></a>异常通知</h5><p>抛出建议后，当匹配的方法执行通过抛出异常退出时，运行建议。<code>&LTaop:aspect></code>使用<code>after-throwing</code>元素在里面声明它，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"afterThrowingExample"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:after-throwing</span></span></span><br><span class=line><span class=tag>        <span class=attr>pointcut-ref</span>=<span class=string>"dataAccessOperation"</span></span></span><br><span class=line><span class=tag>        <span class=attr>method</span>=<span class=string>"doRecoveryActions"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br></pre></table></figure> <p>与@AspectJ样式一样，您可以在通知正文中获取引发的异常。为此，使用<code>throwing</code>属性指定异常应传递到的参数的名称，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"afterThrowingExample"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:after-throwing</span></span></span><br><span class=line><span class=tag>        <span class=attr>pointcut-ref</span>=<span class=string>"dataAccessOperation"</span></span></span><br><span class=line><span class=tag>        <span class=attr>throwing</span>=<span class=string>"dataAccessEx"</span></span></span><br><span class=line><span class=tag>        <span class=attr>method</span>=<span class=string>"doRecoveryActions"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br></pre></table></figure> <p>该<code>doRecoveryActions</code>方法必须声明一个名为的参数<code>dataAccessEx</code>。该参数的类型以与所述相同的方式约束匹配 <code>@AfterThrowing</code>。例如，方法签名可以声明如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doRecoveryActions</span><span class=params>(DataAccessException dataAccessEx)</span> {...}</span><br></pre></table></figure> <h5 id=后置通知><a class=headerlink href=#后置通知 title=后置通知></a>后置通知</h5><p>无论最终如何执行匹配的方法，建议（最终）都会运行。您可以使用<code>after</code>元素声明它，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"afterFinallyExample"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:after</span></span></span><br><span class=line><span class=tag>        <span class=attr>pointcut-ref</span>=<span class=string>"dataAccessOperation"</span></span></span><br><span class=line><span class=tag>        <span class=attr>method</span>=<span class=string>"doReleaseLock"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br></pre></table></figure> <h5 id=环绕通知-1><a class=headerlink href=#环绕通知-1 title=环绕通知></a>环绕通知</h5><p>最后一种建议是围绕建议。围绕建议在匹配的方法执行过程中“围绕”运行。它有机会在方法运行之前和之后进行工作，并确定何时，如何以及什至实际上该方法可以运行。周围建议通常用于以线程安全的方式（例如，启动和停止计时器）在方法执行之前和之后共享状态。始终使用最不强大的建议形式，以满足您的要求。如果建议可以完成这项工作，请不要在建议周围使用。</p> <p>您可以使用<code>aop:around</code>元素在建议周围声明。咨询方法的第一个参数必须为类型<code>ProceedingJoinPoint</code>。在通知的主体，要求<code>proceed()</code>对<code>ProceedingJoinPoint</code>导致运行基本方法。<code>proceed</code>也可以使用调用该方法<code>Object[]</code>。数组中的值用作方法执行时的参数。见<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj-around-advice rel=noopener target=_blank>around通知</a>的注意事项调用<code>proceed</code>有<code>Object[]</code>。以下示例显示了如何在XML中围绕建议进行声明：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"aroundExample"</span> <span class=attr>ref</span>=<span class=string>"aBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:around</span></span></span><br><span class=line><span class=tag>        <span class=attr>pointcut-ref</span>=<span class=string>"businessService"</span></span></span><br><span class=line><span class=tag>        <span class=attr>method</span>=<span class=string>"doBasicProfiling"</span> /></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br></pre></table></figure> <p><code>doBasicProfiling</code>建议的实现可以与@AspectJ示例完全相同（当然要减去注释），如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> Object <span class="title function_">doBasicProfiling</span><span class=params>(ProceedingJoinPoint pjp)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=comment>// start stopwatch</span></span><br><span class=line>    <span class=type>Object</span> <span class=variable>retVal</span> <span class=operator>=</span> pjp.proceed();</span><br><span class=line>    <span class=comment>// stop stopwatch</span></span><br><span class=line>    <span class=keyword>return</span> retVal;</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=通知参数-1><a class=headerlink href=#通知参数-1 title=通知参数></a>通知参数</h5><p>基于架构的声明样式以与@AspectJ支持相同的方式支持完全类型的建议，即按名称将切入点参数与建议方法参数进行匹配。有关详细信息，请参见<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj-advice-params rel=noopener target=_blank>建议参数</a>。如果您希望显式指定建议方法的参数名称（不依赖于先前描述的检测策略），则可以通过使用<code>arg-names</code> 建议元素的属性来实现，该属性的使用方式与<code>argNames</code> 建议注释中的属性相同（如<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj-advice-params-names rel=noopener target=_blank>确定参数名称中所述</a>）。以下示例显示如何在XML中指定参数名称：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:before</span></span></span><br><span class=line><span class=tag>    <span class=attr>pointcut</span>=<span class=string>"com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)"</span></span></span><br><span class=line><span class=tag>    <span class=attr>method</span>=<span class=string>"audit"</span></span></span><br><span class=line><span class=tag>    <span class=attr>arg-names</span>=<span class=string>"auditable"</span>/></span></span><br></pre></table></figure> <p>该<code>arg-names</code>属性接受以逗号分隔的参数名称列表。</p> <p>以下是基于XSD的方法中涉及程度稍高的示例，显示了一些与一些强类型参数结合使用的建议：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> x.y.service;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">PersonService</span> {</span><br><span class=line>    Person <span class="title function_">getPerson</span><span class=params>(String personName, <span class=type>int</span> age)</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DefaultPersonService</span> <span class=keyword>implements</span> <span class="title class_">PersonService</span> {</span><br><span class=line>    <span class=keyword>public</span> Person <span class="title function_">getPerson</span><span class=params>(String name, <span class=type>int</span> age)</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">Person</span>(name, age);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>接下来是方面。注意，该<code>profile(..)</code>方法接受许多强类型参数，这一事实恰好是用于进行方法调用的连接点。该参数的存在表明 <code>profile(..)</code>将使用用作<code>around</code>建议，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> x.y;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class=line><span class=keyword>import</span> org.springframework.util.StopWatch;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleProfiler</span> {</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">profile</span><span class=params>(ProceedingJoinPoint call, String name, <span class=type>int</span> age)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        <span class=type>StopWatch</span> <span class=variable>clock</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StopWatch</span>(<span class=string>"Profiling for '"</span> + name + <span class=string>"' and '"</span> + age + <span class=string>"'"</span>);</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            clock.start(call.toShortString());</span><br><span class=line>            <span class=keyword>return</span> call.proceed();</span><br><span class=line>        } <span class=keyword>finally</span> {</span><br><span class=line>            clock.stop();</span><br><span class=line>            System.out.println(clock.prettyPrint());</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>最后，以下示例XML配置影响了特定连接点的上述建议的执行：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:aop</span>=<span class=string>"http://www.springframework.org/schema/aop"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- this is the object that will be proxied by Spring's AOP infrastructure --></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"personService"</span> <span class=attr>class</span>=<span class=string>"x.y.service.DefaultPersonService"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- this is the actual advice itself --></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"profiler"</span> <span class=attr>class</span>=<span class=string>"x.y.SimpleProfiler"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>        <span class=tag><<span class=name>aop:aspect</span> <span class=attr>ref</span>=<span class=string>"profiler"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"theExecutionOfSomePersonServiceMethod"</span> <span class=attr>expression</span>=<span class=string>"execution(* x.y.service.PersonService.getPerson(String,int)) and args(name, age)"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>aop:around</span> <span class=attr>pointcut</span> <span class=attr>ref</span>=<span class=string>"theExecutionOfSomePersonServiceMethod"</span></span></span><br><span class=line><span class=tag>                <span class=attr>method</span>=<span class=string>"profile"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>aop:config</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>考虑以下驱动程序脚本：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.beans.factory.BeanFactory;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class=line><span class=keyword>import</span> x.y.service.PersonService;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>class</span> <span class="title class_">Boot</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(<span class=keyword>final</span> String[] args)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>BeanFactory</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class=string>"x/y/plain.xml"</span>);</span><br><span class=line>        <span class=type>PersonService</span> <span class=variable>person</span> <span class=operator>=</span> (PersonService) ctx.getBean(<span class=string>"personService"</span>);</span><br><span class=line>        person.getPerson(<span class=string>"Pengo"</span>, <span class=number>12</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h5 id=订购通知-1><a class=headerlink href=#订购通知-1 title=订购通知></a>订购通知</h5><p>当需要在同一连接点（执行方法）上运行多个建议时，排序规则如“<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-ataspectj-advice-ordering rel=noopener target=_blank>建议排序”中所述</a>。方面之间的优先级是通过元素中的<code>order</code>属性确定的，<code>&LTaop:aspect></code>或者是通过将<code>@Order</code>注释添加到支持方面的Bean中，或者是由Bean实现<code>Ordered</code>接口来确定的。</p> <blockquote><p>与在同一<code>@Aspect</code> 类中定义的通知方法的优先规则相反，当在同一<code>&LTaop:aspect></code>元素中定义的两条建议都需要在同一连接点上运行时，优先级由在其中声明建议元素的顺序确定。包围<code>&LTaop:aspect></code>元素，从最高优先级到最低优先级。<p>例如，给定一个<code>around</code>建议和一个<code>before</code>建议，该建议和在同一<code>&LTaop:aspect></code>元素中定义的建议 适用于同一连接点，以确保<code>around</code> 建议的优先级高于<code>before</code>建议，<code>&LTaop:around></code>必须在该<code>&LTaop:before></code>元素之前声明该元素。<p>作为一般经验法则，如果发现在同一<code>&LTaop:aspect></code>元素中定义了多个适用于同一连接点的建议，请考虑将这些建议方法折叠为每个<code>&LTaop:aspect></code>元素中每个连接点的一个建议方法，或重构这些建议方法。建议<code>&LTaop:aspect></code>，您可以在方面级别订购单独的元素。</blockquote> <h4 id=2-3-5-4、引言><a class=headerlink href=#2-3-5-4、引言 title=2.3.5.4、引言></a>2.3.5.4、引言</h4><p>简介（在AspectJ中称为类型间声明）使方面可以声明建议的对象实现给定的接口，并代表那些对象提供该接口的实现。</p> <p>您可以通过使用中的<code>aop:declare-parents</code>元素进行介绍<code>aop:aspect</code>。您可以使用<code>aop:declare-parents</code>元素声明匹配类型具有新的父对象（因此为名称）。例如，给定一个名为的接口<code>UsageTracked</code>以及该名为的接口的实现 <code>DefaultUsageTracked</code>，以下方面声明服务接口的所有实现者也都实现该<code>UsageTracked</code>接口。（例如，为了通过JMX公开统计信息。）</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"usageTrackerAspect"</span> <span class=attr>ref</span>=<span class=string>"usageTracking"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:declare-parents</span></span></span><br><span class=line><span class=tag>        <span class=attr>types-matching</span>=<span class=string>"com.xzy.myapp.service.*+"</span></span></span><br><span class=line><span class=tag>        <span class=attr>implement-interface</span>=<span class=string>"com.xyz.myapp.service.tracking.UsageTracked"</span></span></span><br><span class=line><span class=tag>        <span class=attr>default-impl</span>=<span class=string>"com.xyz.myapp.service.tracking.DefaultUsageTracked"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>aop:before</span></span></span><br><span class=line><span class=tag>        <span class=attr>pointcut</span>=<span class=string>"com.xyz.myapp.CommonPointcuts.businessService()</span></span></span><br><span class=line><span class=string><span class=tag>            and this(usageTracked)"</span></span></span><br><span class=line><span class=tag>            <span class=attr>method</span>=<span class=string>"recordUsage"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br></pre></table></figure> <p>支持<code>usageTracking</code>bean的类将包含以下方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">recordUsage</span><span class=params>(UsageTracked usageTracked)</span> {</span><br><span class=line>    usageTracked.incrementUseCount();</span><br><span class=line>}</span><br></pre></table></figure> <p>要实现的接口由<code>implement-interface</code>属性确定。该<code>types-matching</code>属性的值是AspectJ类型的模式。任何匹配类型的bean都实现该<code>UsageTracked</code>接口。请注意，在前面示例的建议中，服务Bean可以直接用作<code>UsageTracked</code>接口的实现。要以编程方式访问bean，可以编写以下代码：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>UsageTracked</span> <span class=variable>usageTracked</span> <span class=operator>=</span> (UsageTracked) context.getBean(<span class=string>"myService"</span>);</span><br></pre></table></figure> <h4 id=2-3-5-5、方面实例化模型><a class=headerlink href=#2-3-5-5、方面实例化模型 title=2.3.5.5、方面实例化模型></a>2.3.5.5、方面实例化模型</h4><p>模式定义方面唯一受支持的实例化模型是单例模型。将来的版本中可能会支持其他实例化模型。</p> <h4 id=2-3-5-6、通知><a class=headerlink href=#2-3-5-6、通知 title=2.3.5.6、通知></a>2.3.5.6、通知</h4><p>Spring支持带有<code>&LTaop:advisor></code>元素的顾问程序概念。您通常会看到它与事务建议结合使用，事务建议在Spring中也有其自己的名称空间支持。以下示例显示顾问程序：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"businessService"</span></span></span><br><span class=line><span class=tag>        <span class=attr>expression</span>=<span class=string>"execution(* com.xyz.myapp.service.*.*(..))"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>aop:advisor</span></span></span><br><span class=line><span class=tag>        <span class=attr>pointcut-ref</span>=<span class=string>"businessService"</span></span></span><br><span class=line><span class=tag>        <span class=attr>advice-ref</span>=<span class=string>"tx-advice"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>tx:advice</span> <span class=attr>id</span>=<span class=string>"tx-advice"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>tx:attributes</span>></span></span><br><span class=line>        <span class=tag><<span class=name>tx:method</span> <span class=attr>name</span>=<span class=string>"*"</span> <span class=attr>propagation</span>=<span class=string>"REQUIRED"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>tx:attributes</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>tx:advice</span>></span></span><br></pre></table></figure> <p>除了<code>pointcut-ref</code>前面的示例中使用的<code>pointcut</code>属性外，还可以使用该 属性来内联定义切入点表达式。</p> <p>要定义顾问程序的优先级，以便该建议书可以参与订购，请使用该<code>order</code>属性来定义<code>Ordered</code>顾问程序的值。</p> <h4 id=2-3-5-7、AOP模式示例><a class=headerlink href=#2-3-5-7、AOP模式示例 title=2.3.5.7、AOP模式示例></a>2.3.5.7、AOP模式示例</h4><p>以下清单显示了基本方面的实现（这是使用模式支持的常规Java类）：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ConcurrentOperationExecutor</span> <span class=keyword>implements</span> <span class="title class_">Ordered</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>final</span> <span class=type>int</span> <span class=variable>DEFAULT_MAX_RETRIES</span> <span class=operator>=</span> <span class=number>2</span>;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>maxRetries</span> <span class=operator>=</span> DEFAULT_MAX_RETRIES;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>order</span> <span class=operator>=</span> <span class=number>1</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMaxRetries</span><span class=params>(<span class=type>int</span> maxRetries)</span> {</span><br><span class=line>        <span class=built_in>this</span>.maxRetries = maxRetries;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">getOrder</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.order;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setOrder</span><span class=params>(<span class=type>int</span> order)</span> {</span><br><span class=line>        <span class=built_in>this</span>.order = order;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">doConcurrentOperation</span><span class=params>(ProceedingJoinPoint pjp)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        <span class=type>int</span> <span class=variable>numAttempts</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>        PessimisticLockingFailureException lockFailureException;</span><br><span class=line>        <span class=keyword>do</span> {</span><br><span class=line>            numAttempts++;</span><br><span class=line>            <span class=keyword>try</span> {</span><br><span class=line>                <span class=keyword>return</span> pjp.proceed();</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>catch</span>(PessimisticLockingFailureException ex) {</span><br><span class=line>                lockFailureException = ex;</span><br><span class=line>            }</span><br><span class=line>        } <span class=keyword>while</span>(numAttempts <= <span class=built_in>this</span>.maxRetries);</span><br><span class=line>        <span class=keyword>throw</span> lockFailureException;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>请注意，方面实现了<code>Ordered</code>接口，因此我们可以将方面的优先级设置为高于事务建议（每次重试时都希望有新的事务）。该<code>maxRetries</code>和<code>order</code>性能都Spring配置。主要操作发生在“<code>doConcurrentOperation</code>周围建议”方法中。我们尝试继续。如果我们失败了<code>PessimisticLockingFailureException</code>，我们将重试，除非我们用尽了所有的重试尝试。</p> <p>相应的Spring配置如下：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:config</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"concurrentOperationRetry"</span> <span class=attr>ref</span>=<span class=string>"concurrentOperationExecutor"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"idempotentOperation"</span></span></span><br><span class=line><span class=tag>            <span class=attr>expression</span>=<span class=string>"execution(* com.xyz.myapp.service.*.*(..))"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>aop:around</span></span></span><br><span class=line><span class=tag>            <span class=attr>pointcut-ref</span>=<span class=string>"idempotentOperation"</span></span></span><br><span class=line><span class=tag>            <span class=attr>method</span>=<span class=string>"doConcurrentOperation"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"concurrentOperationExecutor"</span></span></span><br><span class=line><span class=tag>    <span class=attr>class</span>=<span class=string>"com.xyz.myapp.service.impl.ConcurrentOperationExecutor"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"maxRetries"</span> <span class=attr>value</span>=<span class=string>"3"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"order"</span> <span class=attr>value</span>=<span class=string>"100"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>请注意，目前我们假设所有业务服务都是幂等的。如果不是这种情况，我们可以通过引入一个<code>Idempotent</code>注释并使用该注释来注释服务操作的实现，来改进方面，使其仅重试真正的幂等操作，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=line><span class=keyword>public</span> <span class=meta>@interface</span> Idempotent {</span><br><span class=line>    <span class=comment>// marker annotation</span></span><br><span class=line>}</span><br></pre></table></figure> <p>方面更改为仅重试幂等操作涉及到修改切入点表达式，以便仅<code>@Idempotent</code>操作匹配，如下所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"idempotentOperation"</span></span></span><br><span class=line><span class=tag>        <span class=attr>expression</span>=<span class=string>"execution(* com.xyz.myapp.service.*.*(..)) and</span></span></span><br><span class=line><span class=string><span class=tag>        @annotation(com.xyz.myapp.service.Idempotent)"</span>/></span></span><br></pre></table></figure> <h3 id=2-3-6、选择要使用的AOP声明样式><a class=headerlink href=#2-3-6、选择要使用的AOP声明样式 title=2.3.6、选择要使用的AOP声明样式></a>2.3.6、选择要使用的AOP声明样式</h3><h4 id=2-3-6-1、Spring-AOP还是-Full-AspectJ？><a title="2.3.6.1、Spring AOP还是 Full AspectJ？" class=headerlink href=#2-3-6-1、Spring-AOP还是-Full-AspectJ？></a>2.3.6.1、Spring AOP还是 Full AspectJ？</h4><p>使用最简单的方法即可。Spring AOP比使用完整的AspectJ更简单，因为不需要在开发和构建过程中引入AspectJ编译器/编织器。如果您只需要建议在Spring Bean上执行操作，则Spring AOP是正确的选择。如果您需要建议不受Spring容器管理的对象（通常是域对象），则需要使用AspectJ。如果您希望建议除简单方法执行之外的连接点（例如，字段获取或设置连接点等），则还需要使用AspectJ。</p> <p>使用AspectJ时，可以选择AspectJ语言语法（也称为“代码样式”）或@AspectJ注释样式。显然，如果您不使用Java 5+，则可以为您做出选择：使用代码样式。如果方面在您的设计中起着重要作用，并且您能够将<a href=https://www.eclipse.org/ajdt/ rel=noopener target=_blank>AspectJ开发工具（AJDT）</a>插件用于Eclipse，则AspectJ语言语法是首选。它更干净，更简单，因为该语言是专为编写方面而设计的。如果您不使用Eclipse或只有少数几个方面在您的应用程序中不起作用，那么您可能要考虑使用@AspectJ样式，在IDE中坚持常规Java编译，并向其中添加方面编织阶段您的构建脚本。</p> <h4 id=2-3-6-2、-AspectJ或Spring-AOP的XML？><a title="2.3.6.2、@AspectJ或Spring AOP的XML？" class=headerlink href=#2-3-6-2、-AspectJ或Spring-AOP的XML？></a>2.3.6.2、@AspectJ或Spring AOP的XML？</h4><p>如果选择使用Spring AOP，则可以选择@AspectJ或XML样式。有各种折衷考虑。</p> <p>XML样式可能是现有Spring用户最熟悉的，并且得到了真正的POJO的支持。将AOP用作配置企业服务的工具时，XML可能是一个不错的选择（一个很好的测试是您是否将切入点表达式视为配置的一部分，而您可能希望独立更改）。使用XML样式，可以说从您的配置中可以更清楚地了解系统中存在哪些方面。</p> <p>XML样式有两个缺点。首先，它没有完全将要解决的需求的实现封装在一个地方。DRY原则说，系统中的任何知识都应该有一个单一，明确，权威的表示形式。当使用XML样式时，关于如何实现需求的知识会在配置文件中的后备bean类的声明和XML中分散。当您使用@AspectJ样式时，此信息将封装在一个模块中：方面。其次，与@AspectJ样式相比，XML样式在表达能力上有更多限制：仅支持“单例”方面实例化模型，并且无法组合以XML声明的命名切入点。例如，使用@AspectJ样式，您可以编写如下内容：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Pointcut("execution(* get*())")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">propertyAccess</span><span class=params>()</span> {}</span><br><span class=line></span><br><span class=line><span class=meta>@Pointcut("execution(org.xyz.Account+ *(..))")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">operationReturningAnAccount</span><span class=params>()</span> {}</span><br><span class=line></span><br><span class=line><span class=meta>@Pointcut("propertyAccess() && operationReturningAnAccount()")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">accountPropertyAccess</span><span class=params>()</span> {}</span><br></pre></table></figure> <p>在XML样式中，您可以声明前两个切入点：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"propertyAccess"</span></span></span><br><span class=line><span class=tag>        <span class=attr>expression</span>=<span class=string>"execution(* get*())"</span>/></span></span><br><span class=line><span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"operationReturningAnAccount"</span></span></span><br><span class=line><span class=tag>        <span class=attr>expression</span>=<span class=string>"execution(org.xyz.Account+ *(..))"</span>/></span></span><br></pre></table></figure> <p>XML方法的缺点是您无法 <code>accountPropertyAccess</code>通过组合这些定义来定义切入点。</p> <p>@AspectJ样式支持其他实例化模型和更丰富的切入点组合。它具有将方面保持为模块化单元的优势。它还具有的优点是，Spring AOP和AspectJ都可以理解@AspectJ方面。因此，如果您以后决定需要AspectJ的功能来实现其他要求，则可以轻松地迁移到经典的AspectJ设置。总而言之，Spring团队在自定义方面更喜欢@AspectJ样式，而不是简单地配置企业服务。</p> <h3 id=2-3-7、混合通知类型><a class=headerlink href=#2-3-7、混合通知类型 title=2.3.7、混合通知类型></a>2.3.7、混合通知类型</h3><p>通过使用自动代理支持，模式定义的<code>&LTaop:aspect></code>方面，<code>&LTaop:advisor></code>声明的顾问程序，甚至是同一配置中其他样式的代理和拦截器，完全可以混合@AspectJ样式的方面。所有这些都是通过使用相同的基础支持机制实现的，并且可以毫无困难地共存。</p> <h3 id=2-3-8、代理机制><a class=headerlink href=#2-3-8、代理机制 title=2.3.8、代理机制></a>2.3.8、代理机制</h3><p>Spring AOP使用JDK动态代理或CGLIB创建给定目标对象的代理。JDK内置了JDK动态代理，而CGLIB是一个通用的开源类定义库（重新打包为<code>spring-core</code>）。</p> <p>如果要代理的目标对象实现至少一个接口，则使用JDK动态代理。代理了由目标类型实现的所有接口。如果目标对象未实现任何接口，则将创建CGLIB代理。</p> <p>如果要强制使用CGLIB代理（例如，代理为目标对象定义的每个方法，而不仅是由其接口实现的方法），都可以这样做。但是，您应该考虑以下问题：</p> <ul><li>使用CGLIB，<code>final</code>不能通知方法，因为不能在运行时生成的子类中覆盖方法。<li>从Spring 4.0开始，由于CGLIB代理实例是通过Objenesis创建的，因此不再调用代理对象的构造函数两次。仅当您的JVM不允许绕过构造函数时，您才可以从Spring的AOP支持中看到两次调用和相应的调试日志条目。</ul> <p>要强制使用CGLIB代理，请将<code>&LTaop:config></code>元素的<code>proxy-target-class</code>属性值设置为true，如下所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:config</span> <span class=attr>proxy-target-class</span>=<span class=string>"true"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- other beans defined here... --></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br></pre></table></figure> <p>要在使用@AspectJ自动代理支持时强制CGLIB代理，请将 <code>&LTaop:aspectj-autoproxy></code>元素的<code>proxy-target-class</code>属性设置为<code>true</code>，如下所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspectj-autoproxy</span> <span class=attr>proxy-target-class</span>=<span class=string>"true"</span>/></span></span><br></pre></table></figure> <blockquote><p>多个<code>&LTaop:config/></code>部分在运行时折叠到一个统一的自动代理创建器中，该创建器将应用任何部分（通常来自不同XML Bean定义文件）指定的<em>最强</em>代理设置 <code>&LTaop:config/></code>。这也适用于<code>&LTtx:annotation-driven/></code>和<code>&LTaop:aspectj-autoproxy/></code> 元素。明确地说，<code>proxy-target-class="true"</code>在<code>&LTtx:annotation-driven/></code>， <code>&LTaop:aspectj-autoproxy/></code>或<code>&LTaop:config/></code>元素上使用会强制<em>对所有三个</em>元素使用CGLIB代理。</blockquote> <h4 id=2-3-8-1、了解AOP代理><a class=headerlink href=#2-3-8-1、了解AOP代理 title=2.3.8.1、了解AOP代理></a>2.3.8.1、了解AOP代理</h4><p>Spring AOP是基于代理的。在编写自己的方面或使用Spring框架随附的任何基于Spring AOP的方面之前，掌握最后一条语句实际含义的语义至关重要。</p> <p>首先考虑您有一个普通的，未经代理的，没有什么特别的，直接的对象引用的情况，如以下代码片段所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimplePojo</span> <span class=keyword>implements</span> <span class="title class_">Pojo</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">foo</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// this next method invocation is a direct call on the 'this' reference</span></span><br><span class=line>        <span class=built_in>this</span>.bar();</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">bar</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// some logic...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>如果在对象引用上调用方法，则直接在该对象引用上调用该方法，如下图和清单所示：</p> <p><img alt=aop代理普通pojo电话 src=https://docs.spring.io/spring-framework/docs/current/reference/html/images/aop-proxy-plain-pojo-call.png></p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>Pojo</span> <span class=variable>pojo</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SimplePojo</span>();</span><br><span class=line>        <span class=comment>// this is a direct method call on the 'pojo' reference</span></span><br><span class=line>        pojo.foo();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>当客户端代码具有的引用是代理时，情况会稍有变化。考虑以下图表和代码片段：</p> <p><img alt=aop代理呼叫 src=https://docs.spring.io/spring-framework/docs/current/reference/html/images/aop-proxy-call.png></p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>ProxyFactory</span> <span class=variable>factory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ProxyFactory</span>(<span class=keyword>new</span> <span class="title class_">SimplePojo</span>());</span><br><span class=line>        factory.addInterface(Pojo.class);</span><br><span class=line>        factory.addAdvice(<span class=keyword>new</span> <span class="title class_">RetryAdvice</span>());</span><br><span class=line></span><br><span class=line>        <span class=type>Pojo</span> <span class=variable>pojo</span> <span class=operator>=</span> (Pojo) factory.getProxy();</span><br><span class=line>        <span class=comment>// this is a method call on the proxy!</span></span><br><span class=line>        pojo.foo();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>创建代理时，还需要一些其他配置，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>ProxyFactory</span> <span class=variable>factory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ProxyFactory</span>(<span class=keyword>new</span> <span class="title class_">SimplePojo</span>());</span><br><span class=line>        factory.addInterface(Pojo.class);</span><br><span class=line>        factory.addAdvice(<span class=keyword>new</span> <span class="title class_">RetryAdvice</span>());</span><br><span class=line>        factory.setExposeProxy(<span class=literal>true</span>);</span><br><span class=line></span><br><span class=line>        <span class=type>Pojo</span> <span class=variable>pojo</span> <span class=operator>=</span> (Pojo) factory.getProxy();</span><br><span class=line>        <span class=comment>// this is a method call on the proxy!</span></span><br><span class=line>        pojo.foo();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>最后，必须指出，AspectJ没有此自调用问题，因为它不是基于代理的AOP框架。</p> <h3 id=2-3-9、以编程方式创建-AspectJ代理><a class=headerlink href=#2-3-9、以编程方式创建-AspectJ代理 title=2.3.9、以编程方式创建@AspectJ代理></a>2.3.9、以编程方式创建@AspectJ代理</h3><p>除了使用<code>&LTaop:config></code> 或来声明配置中的各个方面外，<code>&LTaop:aspectj-autoproxy></code>还可以通过编程方式创建通知目标对象的代理。</p> <p>您可以使用<code>org.springframework.aop.aspectj.annotation.AspectJProxyFactory</code>为一个或多个@AspectJ方面通知的目标对象创建代理。此类的基本用法非常简单，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=type>AspectJProxyFactory</span> <span class=variable>factory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AspectJProxyFactory</span>(targetObject);</span><br><span class=line>factory.addAspect(SecurityManager.class);</span><br><span class=line>factory.addAspect(usageTracker);</span><br><span class=line><span class=type>MyInterfaceType</span> <span class=variable>proxy</span> <span class=operator>=</span> factory.getProxy();</span><br></pre></table></figure> <h3 id=2-3-10、在Spring应用程序中使用AspectJ><a class=headerlink href=#2-3-10、在Spring应用程序中使用AspectJ title=2.3.10、在Spring应用程序中使用AspectJ></a>2.3.10、在Spring应用程序中使用AspectJ</h3><p>到目前为止，本章介绍的所有内容都是纯Spring AOP。在本节中，我们将研究如果您的需求超出了Spring AOP所提供的功能，那么如何使用AspectJ编译器或weaver代替Spring AOP或除Spring AOP之外使用。</p> <p>Spring附带了一个小的AspectJ方面库，可以在您的发行版中独立使用<code>spring-aspects.jar</code>。您需要将其添加到类路径中才能使用其中的方面。</p> <h4 id=2-3-10-1、使用AspectJ通过Spring依赖注入域对象><a class=headerlink href=#2-3-10-1、使用AspectJ通过Spring依赖注入域对象 title=2.3.10.1、使用AspectJ通过Spring依赖注入域对象></a>2.3.10.1、使用AspectJ通过Spring依赖注入域对象</h4><p>Spring容器实例化定义的bean并配置在您的应用程序上下文中。给定包含要应用的配置的Bean定义的名称，也可以要求Bean工厂配置预先存在的对象。 <code>spring-aspects.jar</code>包含注释驱动的方面，该方面利用此功能允许依赖项注入任何对象。该支撑旨在用于在任何容器的控制范围之外创建的对象。域对象通常属于此类，因为它们通常是<code>new</code>通过数据库查询的结果由操作员或ORM工具以编程方式创建的 。</p> <p>该<code>@Configurable</code>注释标记一个类为通过Spring驱动的配置。在最简单的情况下，您可以将其纯粹用作标记注释，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.xyz.myapp.domain;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Configurable;</span><br><span class=line></span><br><span class=line><span class=meta>@Configurable</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Account</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>当以这种方式用作标记接口时，Spring<code>Account</code>通过使用具有与完全限定的类型名称（<code>com.xyz.myapp.domain.Account</code>）同名的bean定义（通常为原型作用域）来配置带注释类型的新实例（在本例中为）。由于Bean的默认名称是其类型的完全限定名称，因此声明原型定义的简便方法是忽略该<code>id</code>属性，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"com.xyz.myapp.domain.Account"</span> <span class=attr>scope</span>=<span class=string>"prototype"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"fundsTransferService"</span> <span class=attr>ref</span>=<span class=string>"fundsTransferService"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>如果要显式指定要使用的原型bean定义的名称，则可以直接在批注中这样做，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.xyz.myapp.domain;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Configurable;</span><br><span class=line></span><br><span class=line><span class=meta>@Configurable("account")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Account</span> {</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <p>现在，Spring查找一个名为的bean定义<code>account</code>，并将其用作配置新<code>Account</code>实例的定义。</p> <p>您也可以使用自动装配来避免完全指定专用的bean定义。要让Spring应用自动装配，请使用 批注的<code>autowire</code>属性<code>@Configurable</code>。您可以分别通过类型或名称指定<code>@Configurable(autowire=Autowire.BY_TYPE)</code>或 <code>@Configurable(autowire=Autowire.BY_NAME</code>用于自动布线。作为替代方案，优选的是指定明确，注解驱动依赖注入为您的<code>@Configurable</code>豆通过<code>@Autowired</code>或<code>@Inject</code> 在外地或方法级（见<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config rel=noopener target=_blank>基于注解的容器配置</a>用于进一步的详细信息）。</p> <p>最后，您可以使用<code>dependencyCheck</code>属性（例如， <code>@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)</code>）来为新创建和配置的对象中的对象引用启用Spring依赖项检查。如果将此属性设置为<code>true</code>，Spring将在配置后验证是否已设置所有属性（不是基元或集合）。</p> <p>请注意，单独使用注释不会执行任何操作。注释的存在是通过 <code>AnnotationBeanConfigurerAspect</code>in<code>spring-aspects.jar</code>起作用的。从本质上讲，方面说：“从带有<code>@Configurable</code>注释类型的新对象的初始化返回之后，根据注释的属性使用Spring配置新创建的对象”。在这种情况下，“初始化”是指新实例化的对象（例如，用<code>new</code>运算符实例化的对象）以及<code>Serializable</code>正在进行反序列化的对象（例如，通过 <a href=https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html rel=noopener target=_blank>readResolve（）</a>）。</p> <p>为此，必须将带注释的类型与AspectJ编织器编织在一起。如果使用基于Java的配置，如下所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableSpringConfigured</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>}</span><br></pre></table></figure> <p>如果您更喜欢基于XML的配置，Spring <a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#xsd-schemas-context rel=noopener target=_blank><code>context</code>名称空间</a> 定义了一个方便的<code>context:spring-configured</code>元素，您可以按如下方式使用它：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>context:spring-configured</span>/></span></span><br></pre></table></figure> <p><code>@Configurable</code>在配置方面之前创建的对象实例会导致向调试日志发出消息，并且未进行对象配置。一个示例可能是Spring配置中的一个bean，当它由Spring初始化时会创建域对象。在这种情况下，您可以使用bean属性 <code>depends-on</code>来手动指定bean取决于配置方面。以下示例显示如何使用<code>depends-on</code>属性：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"myService"</span> <span class=attr>class</span>=<span class=string>"com.xzy.myapp.service.MyService"</span> <span class=attr>depends-on</span>=<span class=string>"org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect"</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <h5 id=单元测试-Configurable对象><a class=headerlink href=#单元测试-Configurable对象 title=单元测试@Configurable对象></a>单元测试<code>@Configurable</code>对象</h5><p><code>@Configurable</code>支持的目标之一是实现域对象的独立单元测试，而不会遇到与硬编码查找相关的困难。如果<code>@Configurable</code>AspectJ尚未编织类型，则注释在单元测试期间不起作用。您可以在被测对象中设置模拟或存根属性引用，然后照常进行。如果<code>@Configurable</code>AspectJ编织了类型，您仍然可以像往常一样在容器外部进行单元测试，但是每次构造<code>@Configurable</code>对象时，都会看到一条警告消息，指示该对象尚未由Spring进行配置。</p> <h5 id=使用多个应用程序上下文><a class=headerlink href=#使用多个应用程序上下文 title=使用多个应用程序上下文></a>使用多个应用程序上下文</h5><p>的<code>AnnotationBeanConfigurerAspect</code>是，用于实现<code>@Configurable</code>支持是一个AspectJ singleton切面。单例方面的范围与<code>static</code>成员的范围相同：每个类加载器都有一个方面实例来定义类型。这意味着，如果您在同一个类加载器层次结构中定义多个应用程序上下文，则需要考虑在何处定义<code>@EnableSpringConfigured</code>Bean以及将其放置<code>spring-aspects.jar</code>在类路径上。</p> <p>考虑一个典型的Spring Web应用程序配置，该配置具有一个共享的父应用程序上下文，该上下文定义了通用的业务服务，支持那些服务所需的一切，以及每个Servlet的一个子应用程序上下文（其中包含该Servlet的特定定义）。所有这些上下文共存于相同的类加载器层次结构中，因此<code>AnnotationBeanConfigurerAspect</code>只能保留对其中一个的引用。在这种情况下，我们建议<code>@EnableSpringConfigured</code>在共享（父）应用程序上下文中定义bean。这定义了您可能想注入域对象的服务。结果是，您无法使用@Configurable机制来配置域对象，而该域对象将引用在子（特定于servlet的）上下文中定义的bean的引用（无论如何，这都不是您想做的事情）。</p> <p>在同一容器中部署多个Web应用程序时，请确保每个Web应用程序都<code>spring-aspects.jar</code>使用自己的类加载器（例如，放置<code>spring-aspects.jar</code>在中<code>'WEB-INF/lib'</code>）来加载类型。如果<code>spring-aspects.jar</code> 仅将其添加到容器范围的类路径中（并因此由共享的父类加载器加载），则所有Web应用程序共享相同的方面实例（这可能不是您想要的）。</p> <h4 id=2-3-10-2、AspectJ的其他Spring方面><a class=headerlink href=#2-3-10-2、AspectJ的其他Spring方面 title=2.3.10.2、AspectJ的其他Spring方面></a>2.3.10.2、AspectJ的其他Spring方面</h4><p>除了<code>@Configurable</code>方面，还<code>spring-aspects.jar</code>包含一个AspectJ方面，您可以使用它来驱动对带有<code>@Transactional</code>注释的类型和方法进行Spring的事务管理。这主要适用于希望在Spring容器之外使用Spring Framework的事务支持的用户。</p> <p>解释<code>@Transactional</code>注释的方面是 <code>AnnotationTransactionAspect</code>。使用此方面时，必须注释实现类（或该类中的方法或两者），而不是注释该类所实现的接口（如果有）。AspectJ遵循Java的规则，即不继承接口上的注释。</p> <p>一<code>@Transactional</code>类上注解指定任何公开操作的类执行默认事务语义。</p> <p><code>@Transactional</code>类内方法的注释会覆盖类注释（如果存在）给出的默认事务语义。可以注释任何可见性的方法，包括私有方法。直接注释非公共方法是执行此类方法而获得事务划分的唯一方法。</p> <p>对于希望使用Spring配置和事务管理支持但又不想（或不能）使用注释的AspectJ程序员，它们<code>spring-aspects.jar</code> 还包含<code>abstract</code>可以扩展以提供自己的切入点定义的方面。有关更多信息，请参见<code>AbstractBeanConfigurerAspect</code>和 <code>AbstractTransactionAspect</code>方面的资源。作为示例，以下摘录显示了如何编写方面来使用与完全限定的类名匹配的原型Bean定义来配置域模型中定义的对象的所有实例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> aspect DomainObjectConfiguration <span class=keyword>extends</span> <span class="title class_">AbstractBeanConfigurerAspect</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">DomainObjectConfiguration</span><span class=params>()</span> {</span><br><span class=line>        setBeanWiringInfoResolver(<span class=keyword>new</span> <span class="title class_">ClassNameBeanWiringInfoResolver</span>());</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// the creation of a new bean (any object in the domain model)</span></span><br><span class=line>    <span class=keyword>protected</span> pointcut <span class="title function_">beanCreation</span><span class=params>(Object beanInstance)</span> :</span><br><span class=line>        initialization(<span class=keyword>new</span>(..)) &&</span><br><span class=line>        CommonPointcuts.inDomainModel() &&</span><br><span class=line>        <span class=built_in>this</span>(beanInstance);</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=2-3-10-3、使用Spring-IoC配置AspectJ-Aspects><a title="2.3.10.3、使用Spring IoC配置AspectJ Aspects" class=headerlink href=#2-3-10-3、使用Spring-IoC配置AspectJ-Aspects></a>2.3.10.3、使用Spring IoC配置AspectJ Aspects</h4><p>当您将AspectJ方面与Spring应用程序一起使用时，既自然又希望能够使用Spring配置此类方面。AspectJ运行时本身负责方面的创建，并且通过Spring配置AspectJ创建的方面的方法取决于方面所使用的AspectJ实例化模型（<code>per-xxx</code>子句）。</p> <p>AspectJ的大多数方面都是单例方面。这些方面的配置很容易。您可以创建一个bean定义，该bean定义照常引用方面类型并包含<code>factory-method="aspectOf"</code>bean属性。这样可以确保Spring通过向AspectJ索要长宽比实例，而不是尝试自己创建实例来获取长宽比实例。以下示例显示如何使用<code>factory-method="aspectOf"</code>属性：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"profiler"</span> <span class=attr>class</span>=<span class=string>"com.xyz.profiler.Profiler"</span></span></span><br><span class=line><span class=tag>        <span class=attr>factory-method</span>=<span class=string>"aspectOf"</span>></span> </span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"profilingStrategy"</span> <span class=attr>ref</span>=<span class=string>"jamonProfilingStrategy"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>非单一方面更难配置。然而，可以通过bean原型定义和使用这样做<code>@Configurable</code>从支持 <code>spring-aspects.jar</code>配置方面情况，一旦他们由AspectJ runtime创建。</p> <p>如果您有一些要与AspectJ编织的@AspectJ方面（例如，对域模型类型使用加载时编织）以及要与Spring AOP一起使用的其他@AspectJ方面，那么这些方面都已在Spring中配置，您需要告诉Spring AOP @AspectJ自动代理支持，应使用配置中定义的@AspectJ方面的确切子集进行自动代理。您可以通过<code>&LTinclude/></code>在<code>&LTaop:aspectj-autoproxy/></code> 声明中使用一个或多个元素来执行此操作。每个<code>&LTinclude/></code>元素都指定一个名称模式，只有名称与至少一个模式匹配的bean才可用于Spring AOP自动代理配置。以下示例显示了如何使用<code>&LTinclude/></code>元素：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>aop:aspectj-autoproxy</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:include</span> <span class=attr>name</span>=<span class=string>"thisBean"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>aop:include</span> <span class=attr>name</span>=<span class=string>"thatBean"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:aspectj-autoproxy</span>></span></span><br></pre></table></figure> <h4 id=2-3-10-4、在Spring-Framework中使用AspectJ进行加载时编织><a title="2.3.10.4、在Spring Framework中使用AspectJ进行加载时编织" class=headerlink href=#2-3-10-4、在Spring-Framework中使用AspectJ进行加载时编织></a>2.3.10.4、在Spring Framework中使用AspectJ进行加载时编织</h4><p>加载时编织（LTW）是指将AspectJ方面加载到应用程序的类文件中时将其编织到Java虚拟机（JVM）中的过程。本节的重点是在Spring框架的特定上下文中配置和使用LTW。本节不是LTW的一般介绍。有关LTW的详细信息以及仅使用AspectJ配置LTW（完全不涉及Spring）的详细信息，请参阅<a href=https://www.eclipse.org/aspectj/doc/released/devguide/ltw.html rel=noopener target=_blank>《 AspectJ开发环境指南》</a>的 <a href=https://www.eclipse.org/aspectj/doc/released/devguide/ltw.html rel=noopener target=_blank>LTW部分</a>。</p> <p>Spring框架为AspectJ LTW带来的价值在于能够对编织过程进行更精细的控制。“ Vanilla” AspectJ LTW是通过使用Java（5+）代理实现的，该代理在启动JVM时通过指定VM参数来打开。因此，它是JVM范围的设置，在某些情况下可能很好，但通常有点过于粗糙。启用了Spring的LTW允许您<code>ClassLoader</code>逐个打开LTW ，它的粒度更细，并且在“单个JVM-多应用程序”环境中（例如在典型的应用程序服务器环境中可以找到）更有意义。 ）。</p> <p>此外，<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-aj-ltw-environments rel=noopener target=_blank>在某些环境中</a>，此支持可实现加载时编织，而无需对添加<code>-javaagent:path/to/aspectjweaver.jar</code>或所需的应用程序服务器的启动脚本进行任何修改（如本节稍后所述）<code>-javaagent:path/to/spring-instrument.jar</code>。开发人员将应用程序上下文配置为启用加载时编织，而不是依赖通常负责部署配置（例如启动脚本）的管理员。</p> <p>现在，销售工作已经结束，让我们首先浏览一个使用Spring的AspectJ LTW的快速示例，然后详细介绍该示例中引入的元素。</p> <h5 id=第一个例子><a class=headerlink href=#第一个例子 title=第一个例子></a>第一个例子</h5><p>下面的示例显示了配置方面的信息，这并不理想。这是一个基于时间的探查器，它使用@AspectJ样式的方面声明：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> foo;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Around;</span><br><span class=line><span class=keyword>import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class=line><span class=keyword>import</span> org.springframework.util.StopWatch;</span><br><span class=line><span class=keyword>import</span> org.springframework.core.annotation.Order;</span><br><span class=line></span><br><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ProfilingAspect</span> {</span><br><span class=line>    <span class=meta>@Around("methodsToBeProfiled()")</span></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">profile</span><span class=params>(ProceedingJoinPoint pjp)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        <span class=type>StopWatch</span> <span class=variable>sw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StopWatch</span>(getClass().getSimpleName());</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            sw.start(pjp.getSignature().getName());</span><br><span class=line>            <span class=keyword>return</span> pjp.proceed();</span><br><span class=line>        } <span class=keyword>finally</span> {</span><br><span class=line>            sw.stop();</span><br><span class=line>            System.out.println(sw.prettyPrint());</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Pointcut("execution(public * foo..*.*(..))")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">methodsToBeProfiled</span><span class=params>()</span>{}</span><br><span class=line>}</span><br></pre></table></figure> <p>我们还需要创建一个<code>META-INF/aop.xml</code>文件，以通知AspectJ编织器我们要将其编织<code>ProfilingAspect</code>到类中。这个文件约定，即在Java类路径上存在一个或多个文件（称为<code>META-INF/aop.xml</code>标准AspectJ）。以下示例显示了该<code>aop.xml</code>文件：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT!DOCTYPE <span class=keyword>aspectj</span> <span class=keyword>PUBLIC</span> <span class=string>"-//AspectJ//DTD//EN"</span> <span class=string>"https://www.eclipse.org/aspectj/dtd/aspectj.dtd"</span>></span></span><br><span class=line><span class=tag><<span class=name>aspectj</span>></span></span><br><span class=line>    <span class=tag><<span class=name>weaver</span>></span></span><br><span class=line>        <span class=comment>&LT!-- only weave classes in our application-specific packages --></span></span><br><span class=line>        <span class=tag><<span class=name>include</span> <span class=attr>within</span>=<span class=string>"foo.*"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>weaver</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aspects</span>></span></span><br><span class=line>        <span class=comment>&LT!-- weave in just this aspect --></span></span><br><span class=line>        <span class=tag><<span class=name>aspect</span> <span class=attr>name</span>=<span class=string>"foo.ProfilingAspect"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>aspects</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>aspectj</span>></span></span><br></pre></table></figure> <p>现在，我们可以继续进行配置中特定于Spring的部分。我们需要配置一个<code>LoadTimeWeaver</code>（稍后说明）。该加载时织布器是必不可少的组件，负责将一个或多个<code>META-INF/aop.xml</code>文件中的方面配置编织到应用程序的类中。好处是，它不需要很多配置（您可以指定一些其他选项，但是稍后会详细介绍），如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:context</span>=<span class=string>"http://www.springframework.org/schema/context"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/context</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/context/spring-context.xsd"</span>></span></span><br><span class=line>    <span class=comment>&LT!-- a service object; we will be profiling its methods --></span></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"entitlementCalculationService"</span></span></span><br><span class=line><span class=tag>            <span class=attr>class</span>=<span class=string>"foo.StubEntitlementCalculationService"</span>/></span></span><br><span class=line>    <span class=comment>&LT!-- this switches on the load-time weaving --></span></span><br><span class=line>    <span class=tag><<span class=name>context:load-time-weaver</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>现在，所有必需的工件（方面，<code>META-INF/aop.xml</code> 文件和Spring配置）都就位了，我们可以使用<code>main(..)</code>方法来演示下面的LTW来创建以下驱动程序类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> foo;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>ApplicationContext</span> <span class=variable>ctx</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class=string>"beans.xml"</span>, Main.class);</span><br><span class=line>        <span class=type>EntitlementCalculationService</span> <span class=variable>entitlementCalculationService</span> <span class=operator>=</span></span><br><span class=line>                (EntitlementCalculationService) ctx.getBean(<span class=string>"entitlementCalculationService"</span>);</span><br><span class=line>        <span class=comment>// the profiling aspect is 'woven' around this method execution</span></span><br><span class=line>        entitlementCalculationService.calculateEntitlement();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>我们还有最后一件事要做。本节的引言确实说过，可以<code>ClassLoader</code>使用Spring选择性地打开LTW ，这是事实。但是，对于此示例，我们使用Java代理（Spring随附）打开LTW。我们使用以下命令来运行<code>Main</code>前面显示的类：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -javaagent：C：/projects/foo/lib/global/spring-instrument.jar foo.Main</span><br></pre></table></figure> <p>该<code>-javaagent</code>标志用于指定<a href=https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html rel=noopener target=_blank>代理</a>并使 <a href=https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html rel=noopener target=_blank>代理能够对在JVM上运行的程序进行检测</a>。Spring Framework附带了这样的代理，该代理<code>InstrumentationSavingAgent</code>打包在中，该 代理<code>spring-instrument.jar</code>作为<code>-javaagent</code>上一示例中的参数值提供。</p> <p><code>Main</code>程序执行的输出类似于下一个示例。（我<code>Thread.sleep(..)</code>在<code>calculateEntitlement()</code> 实现中引入了一条语句，以便探查器实际上捕获的不是0毫秒（<code>01234</code>毫秒不是AOP引入的开销）。以下清单显示了运行探查器时得到的输出：</p> <p>由于此LTW是通过使用成熟的AspectJ来实现的，因此我们不仅限于建议Spring Bean。在<code>Main</code>程序上进行以下细微改动会产生相同的结果：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> foo;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>class</span> <span class="title class_">Main</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=keyword>new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class=string>"beans.xml"</span>, Main.class);</span><br><span class=line>        <span class=type>EntitlementCalculationService</span> <span class=variable>entitlementCalculationService</span> <span class=operator>=</span></span><br><span class=line>                <span class=keyword>new</span> <span class="title class_">StubEntitlementCalculationService</span>();</span><br><span class=line>        <span class=comment>// the profiling aspect will be 'woven' around this method execution</span></span><br><span class=line>        entitlementCalculationService.calculateEntitlement();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>请注意，在前面的程序中，我们如何引导Spring容器，然后创建<code>StubEntitlementCalculationService</code>完全不在Spring上下文外部的新实例。剖析建议仍会被应用。</p> <p>诚然，这个例子很简单。但是，在前面的示例中，已经介绍了Spring对LTW支持的基础，本节的其余部分详细解释了每个配置和用法背后的“原因”。</p> <h5 id=方面><a class=headerlink href=#方面 title=方面></a>方面</h5><p>您在LTW中使用的方面必须是AspectJ方面。您可以使用AspectJ语言本身来编写它们，也可以使用@AspectJ风格来编写方面。这样，您的方面就是有效的AspectJ和Spring AOP方面。此外，编译的方面类需要在类路径上可用。</p> <h5 id=META-INF-aop-xml’><a title="META-INF / aop.xml’" class=headerlink href=#META-INF-aop-xml’></a>META-INF / aop.xml’</h5><p>通过使用<code>META-INF/aop.xml</code> Java类路径上的一个或多个文件（直接或通常在jar文件中）来配置AspectJ LTW基础结构。</p> <p>该文件的结构和内容在<a href=https://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html rel=noopener target=_blank>AspectJ参考文档</a>的LTW部分中进行了详细 <a href=https://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html rel=noopener target=_blank>说明</a>。由于该<code>aop.xml</code>文件是100％AspectJ，因此在此不再赘述。</p> <h5 id=所需的库（JARS）><a class=headerlink href=#所需的库（JARS） title=所需的库（JARS）></a>所需的库（JARS）</h5><p>至少，您需要以下库来使用Spring Framework对AspectJ LTW的支持：</p> <ul><li><code>spring-aop.jar</code><li><code>aspectjweaver.jar</code></ul> <p>如果使用<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-aj-ltw-environments-generic rel=noopener target=_blank>Spring提供的代理来启用检测</a>，则还需要：</p> <ul><li><code>spring-instrument.jar</code></ul> <h5 id=弹簧配置><a class=headerlink href=#弹簧配置 title=弹簧配置></a>弹簧配置</h5><p>Spring的LTW支持中的关键组件是<code>LoadTimeWeaver</code>接口（在 <code>org.springframework.instrument.classloading</code>包装中），以及Spring发行版附带的众多实现。A<code>LoadTimeWeaver</code>负责在运行时<code>java.lang.instrument.ClassFileTransformers</code>向a<code>ClassLoader</code>中添加一个或多个，这为各种有趣的应用程序打开了大门，其中之一恰好是方面的LTW。</p> <p><code>LoadTimeWeaver</code>为一个特定的配置a<code>ApplicationContext</code>就像添加一行一样容易。（请注意，您几乎可以肯定需要使用a <code>ApplicationContext</code>作为您的Spring容器-通常，a<code>BeanFactory</code>是不够的，因为LTW支持使用<code>BeanFactoryPostProcessors</code>。）</p> <p>要启用Spring Framework的LTW支持，您需要配置<code>LoadTimeWeaver</code>，通常通过使用<code>@EnableLoadTimeWeaving</code>批注来完成，如下所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableLoadTimeWeaving</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> {</span><br><span class=line>}</span><br></pre></table></figure> <p>另外，如果您更喜欢基于XML的配置，请使用 <code>&LTcontext:load-time-weaver/></code>元素。请注意，元素是在<code>context</code>名称空间中定义的 。以下示例显示如何使用<code>&LTcontext:load-time-weaver/></code>：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:context</span>=<span class=string>"http://www.springframework.org/schema/context"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/context</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/context/spring-context.xsd"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>context:load-time-weaver</span>/></span></span><br><span class=line></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>前面的配置会自动为您定义并注册许多LTW特定的基础结构Bean，例如a<code>LoadTimeWeaver</code>和an <code>AspectJWeavingEnabler</code>。默认<code>LoadTimeWeaver</code>值为<code>DefaultContextLoadTimeWeaver</code>class，它尝试装饰自动检测到的<code>LoadTimeWeaver</code>。<code>LoadTimeWeaver</code> “自动检测”的确切类型取决于您的运行时环境。下表总结了各种<code>LoadTimeWeaver</code>实现：</p> <table><thead><tr><th align=left>运行环境<th align=left><code>LoadTimeWeaver</code> 实作<tbody><tr><td align=left>在<a href=https://tomcat.apache.org/ rel=noopener target=_blank>Apache Tomcat中</a>运行<td align=left><code>TomcatLoadTimeWeaver</code><tr><td align=left>在<a href=https://eclipse-ee4j.github.io/glassfish/ rel=noopener target=_blank>GlassFish中</a>运行（仅限EAR部署）<td align=left><code>GlassFishLoadTimeWeaver</code><tr><td align=left>在Red Hat的<a href=https://www.jboss.org/jbossas/ rel=noopener target=_blank>JBoss AS</a>或<a href=https://www.wildfly.org/ rel=noopener target=_blank>WildFly中运行</a><td align=left><code>JBossLoadTimeWeaver</code><tr><td align=left>在IBM的<a href=https://www-01.ibm.com/software/webservers/appserv/was/ rel=noopener target=_blank>WebSphere中</a>运行<td align=left><code>WebSphereLoadTimeWeaver</code><tr><td align=left>在Oracle的<a href=https://www.oracle.com/technetwork/middleware/weblogic/overview/index-085209.html rel=noopener target=_blank>WebLogic中</a>运行<td align=left><code>WebLogicLoadTimeWeaver</code><tr><td align=left>JVM从Spring <code>InstrumentationSavingAgent</code> （<code>java -javaagent:path/to/spring-instrument.jar</code>）开始<td align=left><code>InstrumentationLoadTimeWeaver</code><tr><td align=left>回退，期望基础ClassLoader遵循通用约定（即方法<code>addTransformer</code>，可选地<code>getThrowawayClassLoader</code>）<td align=left><code>ReflectiveLoadTimeWeaver</code></table> <p>请注意，该表仅列出<code>LoadTimeWeavers</code>使用时自动检测到的<code>DefaultContextLoadTimeWeaver</code>。您可以确切指定<code>LoadTimeWeaver</code> 要使用的实现。</p> <p>要指定特定<code>LoadTimeWeaver</code>的Java配置，请实现该 <code>LoadTimeWeavingConfigurer</code>接口并覆盖该<code>getLoadTimeWeaver()</code>方法。以下示例指定一个<code>ReflectiveLoadTimeWeaver</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableLoadTimeWeaving</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppConfig</span> <span class=keyword>implements</span> <span class="title class_">LoadTimeWeavingConfigurer</span> {</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> LoadTimeWeaver <span class="title function_">getLoadTimeWeaver</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">ReflectiveLoadTimeWeaver</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>如果使用基于XML的配置，则可以将完全限定的类名指定为 元素<code>weaver-class</code>上属性的值<code>&LTcontext:load-time-weaver/></code>。同样，以下示例指定了<code>ReflectiveLoadTimeWeaver</code>：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:context</span>=<span class=string>"http://www.springframework.org/schema/context"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/context</span></span></span><br><span class=line><span class=string><span class=tag>        https://www.springframework.org/schema/context/spring-context.xsd"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>context:load-time-weaver</span></span></span><br><span class=line><span class=tag>            <span class=attr>weaver-class</span>=<span class=string>"org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"</span>/></span></span><br><span class=line></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>该<code>LoadTimeWeaver</code>中定义并且由配置注册可从Spring容器通过使用公知的名称以后检索<code>loadTimeWeaver</code>。请记住，<code>LoadTimeWeaver</code>存在仅作为Spring LTW基础结构添加一个或多个的机制<code>ClassFileTransformers</code>。实际 <code>ClassFileTransformer</code>执行LTW的是<code>ClassPreProcessorAgentAdapter</code>（从<code>org.aspectj.weaver.loadtime</code>包中）类。有关<code>ClassPreProcessorAgentAdapter</code>更多详细信息，请参见该类的类级javadoc ，因为实际上如何实现编织的细节不在本文档的讨论范围之内。</p> <p>剩下要讨论的配置的最后一个属性：该<code>aspectjWeaving</code> 属性（或者，<code>aspectj-weaving</code>如果您使用XML）。此属性控制是否启用LTW。它接受三个可能值之一，默认值 <code>autodetect</code>是不存在该属性的情况。下表总结了三个可能的值：</p> <table><thead><tr><th align=left>注释值<th align=left>XML值<th align=left>说明<tbody><tr><td align=left><code>ENABLED</code><td align=left><code>on</code><td align=left>AspectJ正在编织，并且在加载时适当地编织了方面。<tr><td align=left><code>DISABLED</code><td align=left><code>off</code><td align=left>LTW已关闭。加载时不会编织任何方面。<tr><td align=left><code>AUTODETECT</code><td align=left><code>autodetect</code><td align=left>如果Spring LTW基础结构可以找到至少一个<code>META-INF/aop.xml</code>文件，则AspectJ编织已开始。否则，它关闭。这是默认值。</table> <h5 id=特定于环境的配置><a class=headerlink href=#特定于环境的配置 title=特定于环境的配置></a>特定于环境的配置</h5><p>最后一部分包含在应用程序服务器和Web容器等环境中使用Spring的LTW支持时所需的所有其他设置和配置。</p> <h6 id=Tomcat，JBoss，WebSphere，WebLogic><a class=headerlink href=#Tomcat，JBoss，WebSphere，WebLogic title=Tomcat，JBoss，WebSphere，WebLogic></a>Tomcat，JBoss，WebSphere，WebLogic</h6><p>Tomcat，JBoss / WildFly，IBM WebSphere Application Server和Oracle WebLogic Server均提供了<code>ClassLoader</code>能够进行本地检测的通用应用程序。Spring的本地LTW可以利用这些ClassLoader实现来提供AspectJ编织。您可以简单地启用加载时编织，<a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-using-aspectj rel=noopener target=_blank>如前所述</a>。具体而言，您无需修改JVM启动脚本即可添加 <code>-javaagent:path/to/spring-instrument.jar</code>。</p> <p>请注意，在JBoss上，您可能需要禁用应用程序服务器扫描，以防止它在应用程序实际启动之前加载类。一个快速的解决方法是将一个<code>WEB-INF/jboss-scanning.xml</code>具有以下内容的文件添加到您的工件中：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>scanning</span> <span class=attr>xmlns</span>=<span class=string>"urn:jboss:scanning:1.0"</span>/></span></span><br></pre></table></figure> <h6 id=通用Java应用程序><a class=headerlink href=#通用Java应用程序 title=通用Java应用程序></a>通用Java应用程序</h6><p>在特定<code>LoadTimeWeaver</code>实现不支持的环境中需要类检测时，JVM代理是通用解决方案。对于这种情况，Spring提供了<code>InstrumentationLoadTimeWeaver</code>一个需要Spring特定（但非常通用）的JVM代理的程序，该JVM代理<code>spring-instrument.jar</code>可以通过common<code>@EnableLoadTimeWeaving</code>和<code>&LTcontext:load-time-weaver/></code>setups自动检测。</p> <p>要使用它，必须通过提供以下JVM选项来使用Spring代理启动虚拟机：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-javaagent：/path/to/spring-instrument.jar</span><br></pre></table></figure> <p>请注意，这需要修改JVM启动脚本，这可能会阻止您在应用程序服务器环境中使用它（取决于您的服务器和您的操作策略）。也就是说，对于每个JVM一个应用程序的部署（例如独立的Spring Boot应用程序），无论如何，您通常都可以控制整个JVM的设置。</p> <h3 id=2-3-11、更多资源><a class=headerlink href=#2-3-11、更多资源 title=2.3.11、更多资源></a>2.3.11、更多资源</h3><p>可以在<a href=https://www.eclipse.org/aspectj rel=noopener target=_blank>AspectJ网站</a>上找到有关<a href=https://www.eclipse.org/aspectj rel=noopener target=_blank>AspectJ的</a>更多信息。</p> <p><em>Eclipse AspectJ</em>，作者：Adrian Colyer等。等 （Addison-Wesley，2005年）为AspectJ语言提供了全面的介绍和参考。</p> <p>强烈推荐Ramnivas Laddad撰写的<em>《 AspectJ in Action》</em>第二版（Manning，2009年）。本书的2重点是AspectJ，但在一定程度上探讨了许多通用的AOP主题。</p> <h2 id=2-4、Spring表达式语言><a class=headerlink href=#2-4、Spring表达式语言 title=2.4、Spring表达式语言></a>2.4、Spring表达式语言</h2><p>Spring 表达式语言(简称“ SpEL”)是一种功能强大的表达式语言，支持在运行时查询和操作对象图。语言语法类似于 Unified EL，但提供了其他功能，最著名的是方法调用和基本的字符串模板功能。</p> <p>虽然 SpEL 是 Spring 产品组合中表达评估的基础，但它并不直接与 Spring 绑定，可以独立使用。</p> <p>表达式语言支持以下功能：</p> <ul><li>Literal expressions<li>布尔运算符和关系运算符<li>Regular expressions<li>Class expressions<li>访问属性，数组，列表和 Map<li>Method invocation<li>Relational operators<li>Assignment<li>Calling constructors<li>Bean references<li>Array construction<li>Inline lists<li>Inline maps<li>Ternary operator<li>Variables<li>User-defined functions<li>Collection projection<li>Collection selection<li>Templated expressions</ul> <h3 id=2-4-1、Evaluation><a class=headerlink href=#2-4-1、Evaluation title=2.4.1、Evaluation></a>2.4.1、Evaluation</h3><p>以下代码介绍了 SpEL API 来评估 Literals 字符串表达式<code>Hello World</code>。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line><span class=type>Expression</span> <span class=variable>exp</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"'Hello World'"</span>); (<span class=number>1</span>)</span><br><span class=line><span class=type>String</span> <span class=variable>message</span> <span class=operator>=</span> (String) exp.getValue();</span><br></pre></table></figure> <p>您最可能使用的 SpEL 类和接口位于<code>org.springframework.expression</code>包及其子包中，例如<code>spel.support</code>。</p> <p><code>ExpressionParser</code>接口负责解析表达式字符串。在前面的示例中，表达式字符串是由周围的单引号表示的字符串 Literals。 <code>Expression</code>接口负责评估先前定义的表达式字符串。分别调用<code>parser.parseExpression</code>和<code>exp.getValue</code>时，可以引发两个异常<code>ParseException</code>和<code>EvaluationException</code>。</p> <p>pEL 支持多种功能，例如调用方法，访问属性和调用构造函数。</p> <p>在以下方法调用示例中，我们在字符串 Literals 上调用<code>concat</code>方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line><span class=type>Expression</span> <span class=variable>exp</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"'Hello World'.concat('!')"</span>); (<span class=number>1</span>)</span><br><span class=line><span class=type>String</span> <span class=variable>message</span> <span class=operator>=</span> (String) exp.getValue();</span><br></pre></table></figure> <ul><li>(1) message 的值现在是 “Hello World！”。</ul> <p>以下调用 JavaBean 属性的示例将调用<code>String</code>属性<code>Bytes</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line></span><br><span class=line><span class=comment>// invokes 'getBytes()'</span></span><br><span class=line><span class=type>Expression</span> <span class=variable>exp</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"'Hello World'.bytes"</span>); (<span class=number>1</span>)</span><br><span class=line><span class=type>byte</span>[] bytes = (<span class=type>byte</span>[]) exp.getValue();</span><br></pre></table></figure> <p>SpEL 还通过使用标准的点符号(例如<code>prop1.prop2.prop3</code>)和属性值的设置来支持嵌套属性。也可以访问公共字段。下面的示例演示如何使用点表示法获取 Literals 的长度：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line></span><br><span class=line><span class=comment>// invokes 'getBytes().length'</span></span><br><span class=line><span class=type>Expression</span> <span class=variable>exp</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"'Hello World'.bytes.length"</span>); (<span class=number>1</span>)</span><br><span class=line><span class=type>int</span> <span class=variable>length</span> <span class=operator>=</span> (Integer) exp.getValue();</span><br></pre></table></figure> <p>可以调用 String 的构造函数，而不是使用字符串 Literals，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line><span class=type>Expression</span> <span class=variable>exp</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"new String('hello world').toUpperCase()"</span>); (<span class=number>1</span>)</span><br><span class=line><span class=type>String</span> <span class=variable>message</span> <span class=operator>=</span> exp.getValue(String.class);</span><br></pre></table></figure> <p>注意使用通用方法：<code>public &LTT> T getValue(Class&LTT> desiredResultType)</code>。使用此方法无需将表达式的值强制转换为所需的结果类型。如果无法将值强制转换为<code>T</code>类型或无法使用已注册的类型转换器进行转换，则将引发<code>EvaluationException</code>。</p> <p>SpEL 的更常见用法是提供一个表达式字符串，该字符串针对特定对象实例(称为根对象)进行评估。下面的示例演示如何从<code>Inventor</code>类的实例检索<code>name</code>属性或创建布尔条件：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=type>GregorianCalendar</span> <span class=variable>c</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">GregorianCalendar</span>();</span><br><span class=line>c.set(<span class=number>1856</span>, <span class=number>7</span>, <span class=number>9</span>);</span><br><span class=line></span><br><span class=line><span class=type>Inventor</span> <span class=variable>tesla</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Inventor</span>(<span class=string>"Nikola Tesla"</span>, c.getTime(), <span class=string>"Serbian"</span>);</span><br><span class=line></span><br><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line></span><br><span class=line><span class=type>Expression</span> <span class=variable>exp</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"name"</span>); (<span class=number>1</span>)</span><br><span class=line><span class=type>String</span> <span class=variable>name</span> <span class=operator>=</span> (String) exp.getValue(tesla);</span><br><span class=line><span class=comment>// name == "Nikola Tesla"</span></span><br><span class=line></span><br><span class=line>exp = parser.parseExpression(<span class=string>"name == 'Nikola Tesla'"</span>);</span><br><span class=line><span class=type>boolean</span> <span class=variable>result</span> <span class=operator>=</span> exp.getValue(tesla, Boolean.class);</span><br><span class=line><span class=comment>// result == true</span></span><br></pre></table></figure> <ul><li>将 name 解析为表达式。</ul> <h4 id=2-4-1-1、了解评估上下文><a class=headerlink href=#2-4-1-1、了解评估上下文 title=2.4.1.1、了解评估上下文></a>2.4.1.1、了解评估上下文</h4><p>评估表达式以解析属性，方法或字段并帮助执行类型转换时，使用<code>EvaluationContext</code>接口。 Spring 提供了两种实现。</p> <ul><li><code>SimpleEvaluationContext</code>：针对不需要全部 SpEL 语言语法范围且应受到有意义限制的表达式类别，公开了 SpEL 基本语言功能和配置选项的子集。示例包括但不限于数据绑定表达式和基于属性的过滤器。<li><code>StandardEvaluationContext</code>：公开 SpEL 语言功能和配置选项的全部集合。您可以使用它来指定默认的根对象，并配置每个可用的评估相关策略。</ul> <p><code>SimpleEvaluationContext</code>设计为仅支持 SpEL 语言语法的一部分。它不包括 Java 类型引用，构造函数和 Bean 引用。它还要求您明确选择对表达式中的属性和方法的支持级别。默认情况下，<code>create()</code>静态工厂方法仅启用对属性的读取访问。您还可以获取构建器来配置所需的确切支持级别，并针对以下一种或某些组合：</p> <ul><li>仅自定义<code>PropertyAccessor</code>(无反射)<li>只读访问的数据绑定属性<li>读写的数据绑定属性</ul> <h5 id=Type-Conversion><a title="Type Conversion" class=headerlink href=#Type-Conversion></a>Type Conversion</h5><p>默认情况下，SpEL 使用 Spring core(<code>org.springframework.core.convert.ConversionService</code>)中可用的转换服务。此转换服务随附有许多用于常见转换的内置转换器，但它也是完全可扩展的，因此您可以在类型之间添加自定义转换。此外，它是泛型感知的。这意味着，当您在表达式中使用泛型类型时，SpEL 会尝试进行转换以维护遇到的任何对象的类型正确性。</p> <p>在实践中这意味着什么？假设使用<code>setValue()</code>的赋值被用来设置<code>List</code>属性。该属性的类型实际上是<code>List&LTBoolean></code>。 SpEL 意识到列表中的元素需要先转换为<code>Boolean</code>，然后才能放入其中。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">Simple</span> {</span><br><span class=line>    <span class=keyword>public</span> List&LTBoolean> booleanList = <span class=keyword>new</span> <span class="title class_">ArrayList</span>&LTBoolean>();</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=type>Simple</span> <span class=variable>simple</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Simple</span>();</span><br><span class=line>simple.booleanList.add(<span class=literal>true</span>);</span><br><span class=line></span><br><span class=line><span class=type>EvaluationContext</span> <span class=variable>context</span> <span class=operator>=</span> SimpleEvaluationContext().forReadOnlyDataBinding().build();</span><br><span class=line></span><br><span class=line><span class=comment>// false is passed in here as a string. SpEL and the conversion service</span></span><br><span class=line><span class=comment>// correctly recognize that it needs to be a Boolean and convert it</span></span><br><span class=line>parser.parseExpression(<span class=string>"booleanList[0]"</span>).setValue(context, simple, <span class=string>"false"</span>);</span><br><span class=line></span><br><span class=line><span class=comment>// b is false</span></span><br><span class=line><span class=type>Boolean</span> <span class=variable>b</span> <span class=operator>=</span> simple.booleanList.get(<span class=number>0</span>);</span><br></pre></table></figure> <h4 id=2-4-1-2、解析器配置><a class=headerlink href=#2-4-1-2、解析器配置 title=2.4.1.2、解析器配置></a>2.4.1.2、解析器配置</h4><p>可以使用解析器配置对象(<code>org.springframework.expression.spel.SpelParserConfiguration</code>)配置 SpEL 表达式解析器。配置对象控制某些表达式组件的行为。例如，如果您索引到数组或集合中并且指定索引处的元素是<code>null</code>，则可以自动创建该元素。当使用由属性引用链组成的表达式时，这很有用。如果索引到数组或列表中并指定的索引超出了数组或列表当前大小的末尾，则可以自动增长数组或列表以容纳该索引。下面的示例演示如何自动增加列表：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">Demo</span> {</span><br><span class=line>    <span class=keyword>public</span> List&LTString> list;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// Turn on:</span></span><br><span class=line><span class=comment>// - auto null reference initialization</span></span><br><span class=line><span class=comment>// - auto collection growing</span></span><br><span class=line><span class=type>SpelParserConfiguration</span> <span class=variable>config</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelParserConfiguration</span>(<span class=literal>true</span>, <span class=literal>true</span>);</span><br><span class=line></span><br><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>(config);</span><br><span class=line></span><br><span class=line><span class=type>Expression</span> <span class=variable>expression</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"list[3]"</span>);</span><br><span class=line></span><br><span class=line><span class=type>Demo</span> <span class=variable>demo</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Demo</span>();</span><br><span class=line></span><br><span class=line><span class=type>Object</span> <span class=variable>o</span> <span class=operator>=</span> expression.getValue(demo);</span><br><span class=line></span><br><span class=line><span class=comment>// demo.list will now be a real collection of 4 entries</span></span><br><span class=line><span class=comment>// Each entry is a new empty String</span></span><br></pre></table></figure> <h4 id=2-4-1-3、SpEL编译><a class=headerlink href=#2-4-1-3、SpEL编译 title=2.4.1.3、SpEL编译></a>2.4.1.3、SpEL编译</h4><p>Spring Framework 4.1 包含一个基本的表达式编译器。通常对表达式进行解释，这样可以在评估过程中提供很大的动态灵活性，但不能提供最佳性能。对于偶尔使用表达式，这很好，但是，当与其他组件(如 Spring Integration)一起使用时，性能可能非常重要，并且不需要动态性。</p> <p>SpEL 编译器旨在满足这一需求。在评估期间，编译器会生成一个真实的 Java 类，该类体现了表达式行为，并使用该类来实现更快的表达式评估。由于缺少在表达式周围 Importing 内容的信息，因此编译器在执行编译时会使用在表达式的解释求值过程中收集的信息。例如，它不仅仅从表达式中就知道属性引用的类型，而是在第一次解释求值时就知道它是什么。当然，如果各种表达式元素的类型随时间变化，则基于此信息进行编译可能会在以后引起麻烦。因此，编译最适合类型信息在重复求值时不会改变的表达式。</p> <p>考虑以下基本表达式：</p> <figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>someArray[0].someProperty.someOtherProperty < 0.1</span><br></pre></table></figure> <p>因为前面的表达式涉及数组访问，一些属性取消引用和数字运算，所以性能提升可能非常明显。在一个示例中，进行了 50000 次迭代的微基准测试，使用解释器评估需要 75 毫秒，而使用表达式的编译版本仅需要 3 毫秒。</p> <h5 id=Compiler-Configuration><a title="Compiler Configuration" class=headerlink href=#Compiler-Configuration></a>Compiler Configuration</h5><p>默认情况下不打开编译器，但是您可以通过两种不同的方式之一来打开它。当 SpEL 用法嵌入到另一个组件中时，可以使用解析器配置过程(<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-parser-configuration rel=noopener target=_blank>discussed earlier</a>)或使用系统属性来将其打开。</p> <p>编译器可以在<code>org.springframework.expression.spel.SpelCompilerMode</code>枚举中捕获的三种模式之一进行操作。模式如下：</p> <ul><li><code>OFF</code>(默认)：编译器已关闭。<li><code>IMMEDIATE</code>：在立即模式下，将尽快编译表达式。通常是在第一次解释评估之后。如果编译的表达式失败(通常是由于类型更改，如前所述)，则表达式求值的调用者将收到异常。<li><code>MIXED</code>：在混合模式下，表达式会随着时间静默在解释模式和编译模式之间切换。经过一定数量的解释运行后，它们会切换到编译形式，如果编译形式出了问题(例如，如前面所述的类型更改)，则表达式会自动再次切换回解释形式。稍后，它可能会生成另一个已编译的表单并切换到该表单。基本上，用户进入<code>IMMEDIATE</code>模式的异常是在内部处理的。</ul> <p>之所以存在<code>IMMEDIATE</code>模式，是因为<code>MIXED</code>模式可能会导致具有副作用的表达式出现问题。如果已编译的表达式在部分成功后就崩溃了，则它可能已经完成了影响系统状态的操作。如果发生这种情况，调用者可能不希望它在解释模式下静默地重新运行，因为表达式的一部分可能运行了两次。</p> <p>选择模式后，使用<code>SpelParserConfiguration</code>配置解析器。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=type>SpelParserConfiguration</span> <span class=variable>config</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelParserConfiguration</span>(SpelCompilerMode.IMMEDIATE, <span class=built_in>this</span>.getClass().getClassLoader());</span><br><span class=line></span><br><span class=line><span class=type>SpelExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>(config);</span><br><span class=line><span class=type>Expression</span> <span class=variable>expr</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"payload"</span>);</span><br><span class=line><span class=type>MyMessage</span> <span class=variable>message</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">MyMessage</span>();</span><br><span class=line><span class=type>Object</span> <span class=variable>payload</span> <span class=operator>=</span> expr.getValue(message);</span><br></pre></table></figure> <p>当指定编译器模式时，还可以指定一个类加载器(允许传递 null)。编译的表达式是在提供的任何子类加载器中定义的。重要的是要确保，如果指定了类加载器，则它可以查看表达式评估过程中涉及的所有类型。如果未指定类加载器，则使用默认的类加载器(通常是在表达式求值期间运行的线程的上下文类加载器)。</p> <p>第二种配置编译器的方法是将 SpEL 嵌入到其他组件中，并且可能无法通过配置对象进行配置。在这些情况下，可以使用系统属性。您可以将<code>spring.expression.compiler.mode</code>属性设置为<code>SpelCompilerMode</code>枚举值之一(<code>off</code>，<code>immediate</code>或<code>mixed</code>)。</p> <h5 id=Compiler-Limitations><a title="Compiler Limitations" class=headerlink href=#Compiler-Limitations></a>Compiler Limitations</h5><p>从 Spring Framework 4.1 开始，已经有了基本的编译框架。但是，该框架尚不支持编译每种表达式。最初的重点是可能在性能关键型上下文中使用的通用表达式。目前无法编译以下类型的表达式：</p> <ul><li>涉及赋值的表达<li>表达式依赖转换服务<li>使用自定义解析器或访问器的表达式<li>使用选择或投影的表达式</ul> <p>将来会编译更多类型的表达。</p> <h3 id=2-4-2、Bean定义中的表达式><a class=headerlink href=#2-4-2、Bean定义中的表达式 title=2.4.2、Bean定义中的表达式></a>2.4.2、Bean定义中的表达式</h3><p>您可以将 SpEL 表达式与基于 XML 或基于注解的配置元数据一起使用，以定义<code>BeanDefinition</code>实例。在这两种情况下，定义表达式的语法均为<code>#{ &LTexpression string> }</code>形式。</p> <h4 id=2-4-2-1、XML配置><a class=headerlink href=#2-4-2-1、XML配置 title=2.4.2.1、XML配置></a>2.4.2.1、XML配置</h4><p>可以使用表达式来设置属性或构造函数的参数值，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"numberGuess"</span> <span class=attr>class</span>=<span class=string>"org.spring.samples.NumberGuess"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"randomNumber"</span> <span class=attr>value</span>=<span class=string>"#{ T(java.lang.Math).random() * 100.0 }"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- other properties --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p><code>systemProperties</code>变量是 sched 义的，因此您可以在表达式中使用它，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"taxCalculator"</span> <span class=attr>class</span>=<span class=string>"org.spring.samples.TaxCalculator"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"defaultLocale"</span> <span class=attr>value</span>=<span class=string>"#{ systemProperties['user.region'] }"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- other properties --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>请注意，在这种情况下，您不必在 sched 义变量前加上<code>#</code>符号。</p> <p>您还可以按名称引用其他 bean 属性，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"numberGuess"</span> <span class=attr>class</span>=<span class=string>"org.spring.samples.NumberGuess"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"randomNumber"</span> <span class=attr>value</span>=<span class=string>"#{ T(java.lang.Math).random() * 100.0 }"</span>/></span></span><br><span class=line>    <span class=comment>&LT!-- other properties --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"shapeGuess"</span> <span class=attr>class</span>=<span class=string>"org.spring.samples.ShapeGuess"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"initialShapeSeed"</span> <span class=attr>value</span>=<span class=string>"#{ numberGuess.randomNumber }"</span>/></span></span><br><span class=line>    <span class=comment>&LT!-- other properties --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <h4 id=2-4-2-2、注解配置><a class=headerlink href=#2-4-2-2、注解配置 title=2.4.2.2、注解配置></a>2.4.2.2、注解配置</h4><p>若要指定默认值，可以在字段，方法以及方法或构造函数参数上放置<code>@Value</code>注解。</p> <p>下面的示例设置字段变量的默认值：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">FieldValueTestBean</span></span><br><span class=line></span><br><span class=line>    <span class=meta>@Value("#{ systemProperties['user.region'] }")</span></span><br><span class=line>    <span class=keyword>private</span> String defaultLocale;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setDefaultLocale</span><span class=params>(String defaultLocale)</span> {</span><br><span class=line>        <span class=built_in>this</span>.defaultLocale = defaultLocale;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getDefaultLocale</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.defaultLocale;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure> <p>以下示例显示了等效的但使用属性设置器方法的示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">PropertyValueTestBean</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> String defaultLocale;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Value("#{ systemProperties['user.region'] }")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setDefaultLocale</span><span class=params>(String defaultLocale)</span> {</span><br><span class=line>        <span class=built_in>this</span>.defaultLocale = defaultLocale;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getDefaultLocale</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.defaultLocale;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure> <p>自动装配的方法和构造函数也可以使用<code>@Value</code>注解，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleMovieLister</span> {</span><br><span class=line>    <span class=keyword>private</span> MovieFinder movieFinder;</span><br><span class=line>    <span class=keyword>private</span> String defaultLocale;</span><br><span class=line>    </span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">configure</span><span class=params>(MovieFinder movieFinder, <span class=meta>@Value("#{ systemProperties['user.region'] }")</span> String defaultLocale)</span> {</span><br><span class=line>        <span class=built_in>this</span>.movieFinder = movieFinder;</span><br><span class=line>        <span class=built_in>this</span>.defaultLocale = defaultLocale;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MovieRecommender</span> {</span><br><span class=line>    <span class=keyword>private</span> String defaultLocale;</span><br><span class=line>    <span class=keyword>private</span> CustomerPreferenceDao customerPreferenceDao;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MovieRecommender</span><span class=params>(CustomerPreferenceDao customerPreferenceDao, <span class=meta>@Value("#{systemProperties['user.country']}")</span> String defaultLocale)</span> {</span><br><span class=line>        <span class=built_in>this</span>.customerPreferenceDao = customerPreferenceDao;</span><br><span class=line>        <span class=built_in>this</span>.defaultLocale = defaultLocale;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure> <h3 id=2-4-3、语言参考><a class=headerlink href=#2-4-3、语言参考 title=2.4.3、语言参考></a>2.4.3、语言参考</h3><p>本节描述了 Spring Expression Language 的工作方式。它涵盖以下主题：</p> <ul><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-ref-literal rel=noopener target=_blank>Literal Expressions</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-properties-arrays rel=noopener target=_blank>属性，数组，列表，Map 和索引器</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-inline-lists rel=noopener target=_blank>Inline Lists</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-inline-maps rel=noopener target=_blank>Inline Maps</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-array-construction rel=noopener target=_blank>Array Construction</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-methods rel=noopener target=_blank>Methods</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operators rel=noopener target=_blank>Operators</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-types rel=noopener target=_blank>Types</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-constructors rel=noopener target=_blank>Constructors</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-ref-variables rel=noopener target=_blank>Variables</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-ref-functions rel=noopener target=_blank>Functions</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-bean-references rel=noopener target=_blank>Bean References</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operator-ternary rel=noopener target=_blank>三元运算符(If-Then-Else)</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operator-elvis rel=noopener target=_blank>Elvisoperator</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operator-safe-navigation rel=noopener target=_blank>安全导航操作员</a></ul> <h4 id=2-4-3-1、Literals表达><a class=headerlink href=#2-4-3-1、Literals表达 title=2.4.3.1、Literals表达></a>2.4.3.1、Literals表达</h4><p>支持的 Literals 表达式的类型为字符串，数值(int，实数，十六进制)，布尔值和 null。字符串由单引号引起来。要将单引号本身放在字符串中，请使用两个单引号字符。</p> <p>以下清单显示了 Literals 的简单用法。通常，它们不是像这样孤立地使用，而是作为更复杂的表达式的一部分使用-例如，在逻辑比较运算符的一侧使用 Literals。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line><span class=comment>// evals to "Hello World"</span></span><br><span class=line><span class=type>String</span> <span class=variable>helloWorld</span> <span class=operator>=</span> (String) parser.parseExpression(<span class=string>"'Hello World'"</span>).getValue();</span><br><span class=line><span class=type>double</span> <span class=variable>avogadrosNumber</span> <span class=operator>=</span> (Double) parser.parseExpression(<span class=string>"6.0221415E+23"</span>).getValue();</span><br><span class=line><span class=comment>// evals to 2147483647</span></span><br><span class=line><span class=type>int</span> <span class=variable>maxValue</span> <span class=operator>=</span> (Integer) parser.parseExpression(<span class=string>"0x7FFFFFFF"</span>).getValue();</span><br><span class=line><span class=type>boolean</span> <span class=variable>trueValue</span> <span class=operator>=</span> (Boolean) parser.parseExpression(<span class=string>"true"</span>).getValue();</span><br><span class=line><span class=type>Object</span> <span class=variable>nullValue</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"null"</span>).getValue();</span><br></pre></table></figure> <p>数字支持使用负号，指数符号和小数点。默认情况下，使用 Double.parseDouble()解析实数。</p> <h4 id=2-4-3-2、属性、数组、列表、Map和索引器><a class=headerlink href=#2-4-3-2、属性、数组、列表、Map和索引器 title=2.4.3.2、属性、数组、列表、Map和索引器></a>2.4.3.2、属性、数组、列表、Map和索引器</h4><p>使用属性引用进行导航很容易。为此，请使用句点来指示嵌套的属性值。 <code>Inventor</code>类的实例<code>pupin</code>和<code>tesla</code>填充了<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-example-classes rel=noopener target=_blank>示例中使用的类</a>部分中列出的数据。要向下导航并获取特斯拉的出生年份和普平的出生城市，我们使用以下表达式：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>// evals to 1856</span></span><br><span class=line><span class=type>int</span> <span class=variable>year</span> <span class=operator>=</span> (Integer) parser.parseExpression(<span class=string>"Birthdate.Year + 1900"</span>).getValue(context);</span><br><span class=line></span><br><span class=line><span class=type>String</span> <span class=variable>city</span> <span class=operator>=</span> (String) parser.parseExpression(<span class=string>"placeOfBirth.City"</span>).getValue(context);</span><br></pre></table></figure> <p>属性名称的首字母允许不区分大小写。数组和列表的内容通过使用方括号表示法获得，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line><span class=type>EvaluationContext</span> <span class=variable>context</span> <span class=operator>=</span> SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class=line></span><br><span class=line><span class=comment>// Inventions Array</span></span><br><span class=line><span class=comment>// evaluates to "Induction motor"</span></span><br><span class=line><span class=type>String</span> <span class=variable>invention</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"inventions[3]"</span>).getValue(</span><br><span class=line>        context, tesla, String.class);</span><br><span class=line></span><br><span class=line><span class=comment>// Members List</span></span><br><span class=line><span class=comment>// evaluates to "Nikola Tesla"</span></span><br><span class=line><span class=type>String</span> <span class=variable>name</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"Members[0].Name"</span>).getValue(</span><br><span class=line>        context, ieee, String.class);</span><br><span class=line></span><br><span class=line><span class=comment>// List and Array navigation</span></span><br><span class=line><span class=comment>// evaluates to "Wireless communication"</span></span><br><span class=line><span class=type>String</span> <span class=variable>invention</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"Members[0].Inventions[6]"</span>).getValue(</span><br><span class=line>        context, ieee, String.class);</span><br></pre></table></figure> <p>通过在方括号内指定 Literals 键值可以获取 Map 的内容。在下面的示例中，由于<code>Officers</code>Map 的键是字符串，因此我们可以指定字符串 Literals：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=comment>// Officer's Dictionary</span></span><br><span class=line><span class=type>Inventor</span> <span class=variable>pupin</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"Officers['president']"</span>).getValue(</span><br><span class=line>        societyContext, Inventor.class);</span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to "Idvor"</span></span><br><span class=line><span class=type>String</span> <span class=variable>city</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"Officers['president'].PlaceOfBirth.City"</span>).getValue(</span><br><span class=line>        societyContext, String.class);</span><br><span class=line></span><br><span class=line><span class=comment>// setting values</span></span><br><span class=line>parser.parseExpression(<span class=string>"Officers['advisors'][0].PlaceOfBirth.Country"</span>).setValue(</span><br><span class=line>        societyContext, <span class=string>"Croatia"</span>);</span><br></pre></table></figure> <h4 id=2-4-3-3、内联列表><a class=headerlink href=#2-4-3-3、内联列表 title=2.4.3.3、内联列表></a>2.4.3.3、内联列表</h4><p>您可以使用<code>{}</code>表示法直接在表达式中表达列表。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>// evaluates to a Java list containing the four numbers</span></span><br><span class=line><span class=type>List</span> <span class=variable>numbers</span> <span class=operator>=</span> (List) parser.parseExpression(<span class=string>"{1,2,3,4}"</span>).getValue(context);</span><br><span class=line></span><br><span class=line><span class=type>List</span> <span class=variable>listOfLists</span> <span class=operator>=</span> (List) parser.parseExpression(<span class=string>"{{'a','b'},{'x','y'}}"</span>).getValue(context);</span><br></pre></table></figure> <p><code>{}</code>本身表示一个空列表。出于性能原因，如果列表本身完全由固定的 Literals 组成，则会创建一个常量列表来表示表达式(而不是在每次求值时都构建一个新列表)。</p> <h4 id=2-4-3-4、内联Map><a class=headerlink href=#2-4-3-4、内联Map title=2.4.3.4、内联Map></a>2.4.3.4、内联Map</h4><p>您也可以使用<code>{key:value}</code>表示法在表达式中直接表达 Map。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>// evaluates to a Java map containing the two entries</span></span><br><span class=line><span class=type>Map</span> <span class=variable>inventorInfo</span> <span class=operator>=</span> (Map) parser.parseExpression(<span class=string>"{name:'Nikola',dob:'10-July-1856'}"</span>).getValue(context);</span><br><span class=line></span><br><span class=line><span class=type>Map</span> <span class=variable>mapOfMaps</span> <span class=operator>=</span> (Map) parser.parseExpression(<span class=string>"{name:{first:'Nikola',last:'Tesla'},dob:{day:10,month:'July',year:1856}}"</span>).getValue(context);</span><br></pre></table></figure> <p><code>{:}</code>本身就是一张空的 Map。出于性能原因，如果 Map 表本身由固定的 Literals 或其他嵌套的常量结构(列表或 Map 表)组成，则会创建一个常量 Map 表来表示该表达式(而不是在每次求值时都构建一个新的 Map 表)。Map 键的引用是可选的。上面的示例不使用带引号的键。</p> <h4 id=2-4-3-5、阵列构造><a class=headerlink href=#2-4-3-5、阵列构造 title=2.4.3.5、阵列构造></a>2.4.3.5、阵列构造</h4><p>您可以使用熟悉的 Java 语法来构建数组，可以选择提供一个初始化程序以在构造时填充该数组。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>int</span>[] numbers1 = (<span class=type>int</span>[]) parser.parseExpression(<span class=string>"new int[4]"</span>).getValue(context);</span><br><span class=line></span><br><span class=line><span class=comment>// Array with initializer</span></span><br><span class=line><span class=type>int</span>[] numbers2 = (<span class=type>int</span>[]) parser.parseExpression(<span class=string>"new int[]{1,2,3}"</span>).getValue(context);</span><br><span class=line></span><br><span class=line><span class=comment>// Multi dimensional array</span></span><br><span class=line><span class=type>int</span>[][] numbers3 = (<span class=type>int</span>[][]) parser.parseExpression(<span class=string>"new int[4][5]"</span>).getValue(context);</span><br></pre></table></figure> <p>构造多维数组时，当前无法提供初始化程序。</p> <h4 id=2-4-3-6、Methods><a class=headerlink href=#2-4-3-6、Methods title=2.4.3.6、Methods></a>2.4.3.6、Methods</h4><p>您可以使用典型的 Java 编程语法来调用方法。您还可以在 Literals 上调用方法。还支持变量参数。下面的示例演示如何调用方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// string literal, evaluates to "bc"</span></span><br><span class=line><span class=type>String</span> <span class=variable>bc</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"'abc'.substring(1, 3)"</span>).getValue(String.class);</span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to true</span></span><br><span class=line><span class=type>boolean</span> <span class=variable>isMember</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"isMember('Mihajlo Pupin')"</span>).getValue(</span><br><span class=line>        societyContext, Boolean.class);</span><br></pre></table></figure> <h4 id=2-4-3-7、Operators><a class=headerlink href=#2-4-3-7、Operators title=2.4.3.7、Operators></a>2.4.3.7、Operators</h4><p>Spring Expression Language 支持以下几种运算符：</p> <ul><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operators-relational rel=noopener target=_blank>Relational Operators</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operators-logical rel=noopener target=_blank>Logical Operators</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-operators-mathematical rel=noopener target=_blank>Mathematical Operators</a><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#expressions-assignment rel=noopener target=_blank>赋值运算符</a></ul> <h5 id=Relational-Operators><a title="Relational Operators" class=headerlink href=#Relational-Operators></a>Relational Operators</h5><p>使用标准运算符表示法支持关系运算符(等于，不等于，小于，小于或等于，大于和大于或等于)。以下清单显示了一些运算符示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment>// evaluates to true</span></span><br><span class=line><span class=type>boolean</span> <span class=variable>trueValue</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"2 == 2"</span>).getValue(Boolean.class);</span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to false</span></span><br><span class=line><span class=type>boolean</span> <span class=variable>falseValue</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"2 < -5.0"</span>).getValue(Boolean.class);</span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to true</span></span><br><span class=line><span class=type>boolean</span> <span class=variable>trueValue</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"'black' < 'block'"</span>).getValue(Boolean.class);</span><br></pre></table></figure> <blockquote><p>与<code>null</code>的大于和小于比较遵循一个简单的规则：<code>null</code>被视为无(不是零)。结果，任何其他值始终大于<code>null</code>(<code>X > null</code>始终为<code>true</code>)，并且其他任何值都不小于零(<code>X < null</code>总是<code>false</code>)。<p>如果您更喜欢数字比较，请避免基于数字的<code>null</code>比较，而反对与零的比较(例如<code>X > 0</code>或<code>X < 0</code>)。</blockquote> <p>除了标准的关系运算符外，SpEL 还支持<code>instanceof</code>和基于正则表达式的<code>matches</code>运算符。以下清单显示了两个示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=comment>// evaluates to false</span></span><br><span class=line><span class=type>boolean</span> <span class=variable>falseValue</span> <span class=operator>=</span> parser.parseExpression(</span><br><span class=line>        <span class=string>"'xyz' instanceof T(Integer)"</span>).getValue(Boolean.class);</span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to true</span></span><br><span class=line><span class=type>boolean</span> <span class=variable>trueValue</span> <span class=operator>=</span> parser.parseExpression(</span><br><span class=line>        <span class=string>"'5.00' matches '^-?\\d+(\\.\\d{2})?$'"</span>).getValue(Boolean.class);</span><br><span class=line></span><br><span class=line><span class=comment>//evaluates to false</span></span><br><span class=line><span class=type>boolean</span> <span class=variable>falseValue</span> <span class=operator>=</span> parser.parseExpression(</span><br><span class=line>        <span class=string>"'5.0067' matches '^-?\\d+(\\.\\d{2})?$'"</span>).getValue(Boolean.class);</span><br></pre></table></figure> <blockquote><p>注意：<p>请注意基本类型，因为它们会立即被包装为包装类型，因此，按预期，<code>1 instanceof T(int)</code>的值为<code>false</code>，而<code>1 instanceof T(Integer)</code>的值为<code>true</code>。</blockquote> <p>每个符号运算符也可以指定为纯字母等效项。这样可以避免使用的符号对于嵌入表达式的文档类型具有特殊含义的问题(例如在 XML 文档中)。等效的 Literals 是：</p> <ul><li><code>lt</code> ( <code><</code> )<li><code>gt</code> ( <code>></code> )<li><code>le</code> ( <code><=</code> )<li><code>ge</code> ( <code>>=</code> )<li><code>eq</code> ( <code>==</code> )<li><code>ne</code> ( <code>!=</code> )<li><code>div</code> ( <code>/</code> )<li><code>mod</code> ( <code>%</code> )<li><code>not</code> ( <code>!</code> ).</ul> <p>所有的文本运算符都不区分大小写。</p> <h5 id=Logical-Operators><a title="Logical Operators" class=headerlink href=#Logical-Operators></a>Logical Operators</h5><p>SpEL 支持以下逻辑运算符：</p> <ul><li><code>and</code><li><code>or</code><li><code>not</code></ul> <p>下面的示例显示如何使用逻辑运算符</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=comment>// -- AND --</span></span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to false</span></span><br><span class=line><span class=type>boolean</span> <span class=variable>falseValue</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"true and false"</span>).getValue(Boolean.class);</span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to true</span></span><br><span class=line><span class=type>String</span> <span class=variable>expression</span> <span class=operator>=</span> <span class=string>"isMember('Nikola Tesla') and isMember('Mihajlo Pupin')"</span>;</span><br><span class=line><span class=type>boolean</span> <span class=variable>trueValue</span> <span class=operator>=</span> parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br><span class=line></span><br><span class=line><span class=comment>// -- OR --</span></span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to true</span></span><br><span class=line><span class=type>boolean</span> <span class=variable>trueValue</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"true or false"</span>).getValue(Boolean.class);</span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to true</span></span><br><span class=line><span class=type>String</span> <span class=variable>expression</span> <span class=operator>=</span> <span class=string>"isMember('Nikola Tesla') or isMember('Albert Einstein')"</span>;</span><br><span class=line><span class=type>boolean</span> <span class=variable>trueValue</span> <span class=operator>=</span> parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br><span class=line></span><br><span class=line><span class=comment>// -- NOT --</span></span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to false</span></span><br><span class=line><span class=type>boolean</span> <span class=variable>falseValue</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"!true"</span>).getValue(Boolean.class);</span><br><span class=line></span><br><span class=line><span class=comment>// -- AND and NOT --</span></span><br><span class=line><span class=type>String</span> <span class=variable>expression</span> <span class=operator>=</span> <span class=string>"isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')"</span>;</span><br><span class=line><span class=type>boolean</span> <span class=variable>falseValue</span> <span class=operator>=</span> parser.parseExpression(expression).getValue(societyContext, Boolean.class);</span><br></pre></table></figure> <h5 id=Mathematical-Operators><a title="Mathematical Operators" class=headerlink href=#Mathematical-Operators></a>Mathematical Operators</h5><p>您可以在数字和字符串上使用加法运算符。您只能对数字使用减法，乘法和除法运算符。您还可以使用模数(％)和指数幂(^)运算符。强制执行标准运算符优先级。以下示例显示了正在使用的 math 运算符：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=comment>// Addition</span></span><br><span class=line><span class=type>int</span> <span class=variable>two</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"1 + 1"</span>).getValue(Integer.class);  <span class=comment>// 2</span></span><br><span class=line></span><br><span class=line><span class=type>String</span> <span class=variable>testString</span> <span class=operator>=</span> parser.parseExpression(</span><br><span class=line>        <span class=string>"'test' + ' ' + 'string'"</span>).getValue(String.class);  <span class=comment>// 'test string'</span></span><br><span class=line></span><br><span class=line><span class=comment>// Subtraction</span></span><br><span class=line><span class=type>int</span> <span class=variable>four</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"1 - -3"</span>).getValue(Integer.class);  <span class=comment>// 4</span></span><br><span class=line></span><br><span class=line><span class=type>double</span> <span class=variable>d</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"1000.00 - 1e4"</span>).getValue(Double.class);  <span class=comment>// -9000</span></span><br><span class=line></span><br><span class=line><span class=comment>// Multiplication</span></span><br><span class=line><span class=type>int</span> <span class=variable>six</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"-2 * -3"</span>).getValue(Integer.class);  <span class=comment>// 6</span></span><br><span class=line></span><br><span class=line><span class=type>double</span> <span class=variable>twentyFour</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"2.0 * 3e0 * 4"</span>).getValue(Double.class);  <span class=comment>// 24.0</span></span><br><span class=line></span><br><span class=line><span class=comment>// Division</span></span><br><span class=line><span class=type>int</span> <span class=variable>minusTwo</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"6 / -3"</span>).getValue(Integer.class);  <span class=comment>// -2</span></span><br><span class=line></span><br><span class=line><span class=type>double</span> <span class=variable>one</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"8.0 / 4e0 / 2"</span>).getValue(Double.class);  <span class=comment>// 1.0</span></span><br><span class=line></span><br><span class=line><span class=comment>// Modulus</span></span><br><span class=line><span class=type>int</span> <span class=variable>three</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"7 % 4"</span>).getValue(Integer.class);  <span class=comment>// 3</span></span><br><span class=line></span><br><span class=line><span class=type>int</span> <span class=variable>one</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"8 / 5 % 2"</span>).getValue(Integer.class);  <span class=comment>// 1</span></span><br><span class=line></span><br><span class=line><span class=comment>// Operator precedence</span></span><br><span class=line><span class=type>int</span> <span class=variable>minusTwentyOne</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"1+2-3*8"</span>).getValue(Integer.class);  <span class=comment>// -21</span></span><br></pre></table></figure> <h5 id=赋值运算符><a class=headerlink href=#赋值运算符 title=赋值运算符></a>赋值运算符</h5><p>要设置属性，请使用赋值运算符(<code>=</code>)。这通常在对<code>setValue</code>的调用中完成，但也可以在对<code>getValue</code>的调用中完成。下面的清单显示了使用赋值运算符的两种方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>Inventor</span> <span class=variable>inventor</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Inventor</span>();</span><br><span class=line><span class=type>EvaluationContext</span> <span class=variable>context</span> <span class=operator>=</span> SimpleEvaluationContext.forReadWriteDataBinding().build();</span><br><span class=line>parser.parseExpression(<span class=string>"Name"</span>).setValue(context, inventor, <span class=string>"Aleksandar Seovic"</span>);</span><br><span class=line></span><br><span class=line><span class=comment>// alternatively</span></span><br><span class=line><span class=type>String</span> <span class=variable>aleks</span> <span class=operator>=</span> parser.parseExpression(</span><br><span class=line>        <span class=string>"Name = 'Aleksandar Seovic'"</span>).getValue(context, inventor, String.class);</span><br></pre></table></figure> <h4 id=2-4-3-8、Types><a class=headerlink href=#2-4-3-8、Types title=2.4.3.8、Types></a>2.4.3.8、Types</h4><p>您可以使用特殊的<code>T</code>运算符来指定<code>java.lang.Class</code>(类型)的实例。静态方法也可以通过使用此运算符来调用。 <code>StandardEvaluationContext</code>使用<code>TypeLocator</code>查找类型，而<code>StandardTypeLocator</code>(可以替换)是在了解<code>java.lang</code>程序包的情况下构建的。这意味着对<code>java.lang</code>中的类型的<code>T()</code>引用不需要完全限定，但所有其他类型引用都必须是完全限定的。下面的示例演示如何使用<code>T</code>运算符：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>Class</span> <span class=variable>dateClass</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"T(java.util.Date)"</span>).getValue(Class.class);</span><br><span class=line></span><br><span class=line><span class=type>Class</span> <span class=variable>stringClass</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"T(String)"</span>).getValue(Class.class);</span><br><span class=line></span><br><span class=line><span class=type>boolean</span> <span class=variable>trueValue</span> <span class=operator>=</span> parser.parseExpression(</span><br><span class=line>        <span class=string>"T(java.math.RoundingMode).CEILING < T(java.math.RoundingMode).FLOOR"</span>)</span><br><span class=line>        .getValue(Boolean.class);</span><br></pre></table></figure> <h4 id=2-4-3-9、Constructors><a class=headerlink href=#2-4-3-9、Constructors title=2.4.3.9、Constructors></a>2.4.3.9、Constructors</h4><p>您可以使用<code>new</code>运算符来调用构造函数。除了基本类型(<code>int</code>，<code>float</code>等等)和 String 之外，您都应使用完全限定的类名。下面的示例演示如何使用<code>new</code>运算符调用构造函数：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=type>Inventor</span> <span class=variable>einstein</span> <span class=operator>=</span> p.parseExpression(<span class=string>"new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')"</span>).getValue(Inventor.class);</span><br><span class=line></span><br><span class=line><span class=comment>//create new inventor instance within add method of List</span></span><br><span class=line>p.parseExpression(<span class=string>"Members.add(new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German'))"</span>).getValue(societyContext);</span><br></pre></table></figure> <h4 id=2-4-3-10、Variables><a class=headerlink href=#2-4-3-10、Variables title=2.4.3.10、Variables></a>2.4.3.10、Variables</h4><p>您可以使用<code>#variableName</code>语法在表达式中引用变量。通过在<code>EvaluationContext</code>实现上使用<code>setVariable</code>方法来设置变量。以下示例显示了如何使用变量：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>Inventor</span> <span class=variable>tesla</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Inventor</span>(<span class=string>"Nikola Tesla"</span>, <span class=string>"Serbian"</span>);</span><br><span class=line></span><br><span class=line><span class=type>EvaluationContext</span> <span class=variable>context</span> <span class=operator>=</span> SimpleEvaluationContext.forReadWriteDataBinding().build();</span><br><span class=line>context.setVariable(<span class=string>"newName"</span>, <span class=string>"Mike Tesla"</span>);</span><br><span class=line></span><br><span class=line>parser.parseExpression(<span class=string>"Name = #newName"</span>).getValue(context, tesla);</span><br><span class=line>System.out.println(tesla.getName())  <span class=comment>// "Mike Tesla"</span></span><br></pre></table></figure> <h5 id=this-和-root-变量><a title="#this 和#root 变量" class=headerlink href=#this-和-root-变量></a>#this 和#root 变量</h5><p>始终定义<code>#this</code>变量，该变量指向当前评估对象(针对不合格的引用，将对其进行解析)。始终定义<code>#root</code>变量，并引用根上下文对象。尽管<code>#this</code>可能随表达式的组成部分的求值而变化，但<code>#root</code>始终引用根。以下示例显示了如何使用<code>#this</code>和<code>#root</code>变量：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=comment>// create an array of integers</span></span><br><span class=line>List&LTInteger> primes = <span class=keyword>new</span> <span class="title class_">ArrayList</span>&LTInteger>();</span><br><span class=line>primes.addAll(Arrays.asList(<span class=number>2</span>,<span class=number>3</span>,<span class=number>5</span>,<span class=number>7</span>,<span class=number>11</span>,<span class=number>13</span>,<span class=number>17</span>));</span><br><span class=line></span><br><span class=line><span class=comment>// create parser and set variable 'primes' as the array of integers</span></span><br><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line><span class=type>EvaluationContext</span> <span class=variable>context</span> <span class=operator>=</span> SimpleEvaluationContext.forReadOnlyDataAccess();</span><br><span class=line>context.setVariable(<span class=string>"primes"</span>, primes);</span><br><span class=line></span><br><span class=line><span class=comment>// all prime numbers > 10 from the list (using selection ?{...})</span></span><br><span class=line><span class=comment>// evaluates to [11, 13, 17]</span></span><br><span class=line>List&LTInteger> primesGreaterThanTen = (List&LTInteger>) parser.parseExpression(</span><br><span class=line>        <span class=string>"#primes.?[#this>10]"</span>).getValue(context);</span><br></pre></table></figure> <h4 id=2-4-3-11、Functions><a class=headerlink href=#2-4-3-11、Functions title=2.4.3.11、Functions></a>2.4.3.11、Functions</h4><p>您可以通过注册可以在表达式字符串中调用的用户定义函数来扩展 SpEL。该功能通过<code>EvaluationContext</code>注册。下面的示例演示如何注册用户定义的函数：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>Method method = ...;</span><br><span class=line></span><br><span class=line>EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class=line>context.setVariable("myFunction", method);</span><br></pre></table></figure> <p>例如，考虑以下用于反转字符串的 Util 方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">StringUtils</span> {</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> String <span class="title function_">reverseString</span><span class=params>(String input)</span> {</span><br><span class=line>        <span class=type>StringBuilder</span> <span class=variable>backwards</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StringBuilder</span>(input.length());</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < input.length(); i++)</span><br><span class=line>            backwards.append(input.charAt(input.length() - <span class=number>1</span> - i));</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> backwards.toString();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>然后，您可以注册并使用前面的方法，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line></span><br><span class=line><span class=type>EvaluationContext</span> <span class=variable>context</span> <span class=operator>=</span> SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class=line>context.setVariable(<span class=string>"reverseString"</span>,</span><br><span class=line>        StringUtils.class.getDeclaredMethod(<span class=string>"reverseString"</span>, String.class));</span><br><span class=line></span><br><span class=line><span class=type>String</span> <span class=variable>helloWorldReversed</span> <span class=operator>=</span> parser.parseExpression(</span><br><span class=line>        <span class=string>"#reverseString('hello')"</span>).getValue(context, String.class);</span><br></pre></table></figure> <h4 id=2-4-3-12-Bean-参考><a title="2.4.3.12. Bean 参考" class=headerlink href=#2-4-3-12-Bean-参考></a>2.4.3.12. Bean 参考</h4><p>如果评估上下文已使用 bean 解析器配置，则可以使用<code>@</code>符号从表达式中查找 bean。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line><span class=type>StandardEvaluationContext</span> <span class=variable>context</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StandardEvaluationContext</span>();</span><br><span class=line>context.setBeanResolver(<span class=keyword>new</span> <span class="title class_">MyBeanResolver</span>());</span><br><span class=line></span><br><span class=line><span class=comment>// This will end up calling resolve(context,"something") on MyBeanResolver during evaluation</span></span><br><span class=line><span class=type>Object</span> <span class=variable>bean</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"@something"</span>).getValue(context);</span><br></pre></table></figure> <p>要访问工厂 bean 本身，应改为在 Bean 名称前加上<code>&</code>符号。以下示例显示了如何执行此操作：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line><span class=type>StandardEvaluationContext</span> <span class=variable>context</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StandardEvaluationContext</span>();</span><br><span class=line>context.setBeanResolver(<span class=keyword>new</span> <span class="title class_">MyBeanResolver</span>());</span><br><span class=line></span><br><span class=line><span class=comment>// This will end up calling resolve(context,"&foo") on MyBeanResolver during evaluation</span></span><br><span class=line><span class=type>Object</span> <span class=variable>bean</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"&foo"</span>).getValue(context);</span><br></pre></table></figure> <h4 id=2-4-3-13、三元运算符（if-then-else）><a class=headerlink href=#2-4-3-13、三元运算符（if-then-else） title=2.4.3.13、三元运算符（if-then-else）></a>2.4.3.13、三元运算符（if-then-else）</h4><p>您可以使用三元运算符在表达式内部执行 if-then-else 条件逻辑。以下清单显示了一个最小的示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>String</span> <span class=variable>falseString</span> <span class=operator>=</span> parser.parseExpression(</span><br><span class=line>        <span class=string>"false ? 'trueExp' : 'falseExp'"</span>).getValue(String.class);</span><br></pre></table></figure> <p>在这种情况下，布尔值<code>false</code>导致返回字符串值<code>'falseExp'</code>。一个更现实的示例如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>parser.parseExpression(<span class=string>"Name"</span>).setValue(societyContext, <span class=string>"IEEE"</span>);</span><br><span class=line>societyContext.setVariable(<span class=string>"queryName"</span>, <span class=string>"Nikola Tesla"</span>);</span><br><span class=line></span><br><span class=line>expression = <span class=string>"isMember(#queryName)? #queryName + ' is a member of the ' "</span> +</span><br><span class=line>        <span class=string>"+ Name + ' Society' : #queryName + ' is not a member of the ' + Name + ' Society'"</span>;</span><br><span class=line></span><br><span class=line><span class=type>String</span> <span class=variable>queryResultString</span> <span class=operator>=</span> parser.parseExpression(expression)</span><br><span class=line>        .getValue(societyContext, String.class);</span><br><span class=line><span class=comment>// queryResultString = "Nikola Tesla is a member of the IEEE Society"</span></span><br></pre></table></figure> <p>有关三元运算符的更短语法，请参阅关于 Elvis 运算符的下一部分。</p> <h4 id=2-4-3-14、Elvisoperator><a class=headerlink href=#2-4-3-14、Elvisoperator title=2.4.3.14、Elvisoperator></a>2.4.3.14、Elvisoperator</h4><p>Elvis 运算符是三元运算符语法的简化，并且以<a href=http://www.groovy-lang.org/operators.html#_elvis_operator rel=noopener target=_blank>Groovy</a>语言使用。使用三元运算符语法，通常必须将变量重复两次，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>String</span> <span class=variable>name</span> <span class=operator>=</span> <span class=string>"Elvis Presley"</span>;</span><br><span class=line><span class=type>String</span> <span class=variable>displayName</span> <span class=operator>=</span> (name != <span class=literal>null</span> ? name : <span class=string>"Unknown"</span>);</span><br></pre></table></figure> <p>取而代之的是，您可以使用 Elvis 运算符(其命名类似于 Elvis 的发型)。以下示例显示了如何使用 Elvis 运算符：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line></span><br><span class=line><span class=type>String</span> <span class=variable>name</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"name?:'Unknown'"</span>).getValue(String.class);</span><br><span class=line>System.out.println(name);  <span class=comment>// 'Unknown'</span></span><br></pre></table></figure> <p>以下清单显示了一个更复杂的示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line><span class=type>EvaluationContext</span> <span class=variable>context</span> <span class=operator>=</span> SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class=line></span><br><span class=line><span class=type>Inventor</span> <span class=variable>tesla</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Inventor</span>(<span class=string>"Nikola Tesla"</span>, <span class=string>"Serbian"</span>);</span><br><span class=line><span class=type>String</span> <span class=variable>name</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"Name?:'Elvis Presley'"</span>).getValue(context, tesla, String.class);</span><br><span class=line>System.out.println(name);  <span class=comment>// Nikola Tesla</span></span><br><span class=line></span><br><span class=line>tesla.setName(<span class=literal>null</span>);</span><br><span class=line>name = parser.parseExpression(<span class=string>"Name?:'Elvis Presley'"</span>).getValue(context, tesla, String.class);</span><br><span class=line>System.out.println(name);  <span class=comment>// Elvis Presley</span></span><br></pre></table></figure> <blockquote><p>您可以使用 Elvis 运算符在表达式中应用默认值。以下示例显示了如何在<code>@Value</code>表达式中使用 Elvis 运算符：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=meta>@Value("#{systemProperties['pop3.port'] ?: 25}")</span></span><br></pre></table></figure><p>如果定义了系统属性<code>pop3.port</code>，否则将注入 25。</blockquote> <h4 id=2-4-3-15、安全导航操作员><a class=headerlink href=#2-4-3-15、安全导航操作员 title=2.4.3.15、安全导航操作员></a>2.4.3.15、安全导航操作员</h4><p>安全导航操作符用于避免<code>NullPointerException</code>，并且来自<a href=http://www.groovy-lang.org/operators.html#_safe_navigation_operator rel=noopener target=_blank>Groovy</a>语言。通常，当您引用一个对象时，可能需要在访问该对象的方法或属性之前验证其是否为 null。为了避免这种情况，安全导航运算符返回 null 而不是引发异常。下面的示例演示如何使用安全导航操作符：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=type>ExpressionParser</span> <span class=variable>parser</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class=line><span class=type>EvaluationContext</span> <span class=variable>context</span> <span class=operator>=</span> SimpleEvaluationContext.forReadOnlyDataBinding().build();</span><br><span class=line></span><br><span class=line><span class=type>Inventor</span> <span class=variable>tesla</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Inventor</span>(<span class=string>"Nikola Tesla"</span>, <span class=string>"Serbian"</span>);</span><br><span class=line>tesla.setPlaceOfBirth(<span class=keyword>new</span> <span class="title class_">PlaceOfBirth</span>(<span class=string>"Smiljan"</span>));</span><br><span class=line></span><br><span class=line><span class=type>String</span> <span class=variable>city</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"PlaceOfBirth?.City"</span>).getValue(context, tesla, String.class);</span><br><span class=line>System.out.println(city);  <span class=comment>// Smiljan</span></span><br><span class=line></span><br><span class=line>tesla.setPlaceOfBirth(<span class=literal>null</span>);</span><br><span class=line>city = parser.parseExpression(<span class=string>"PlaceOfBirth?.City"</span>).getValue(context, tesla, String.class);</span><br><span class=line>System.out.println(city);  <span class=comment>// null - does not throw NullPointerException!!!</span></span><br></pre></table></figure> <h4 id=2-4-3-16、Collections选择><a class=headerlink href=#2-4-3-16、Collections选择 title=2.4.3.16、Collections选择></a>2.4.3.16、Collections选择</h4><p>选择是一种强大的表达语言功能，可让您通过从源集合中选择条目来将其转换为另一个集合。</p> <p>选择使用<code>.?[selectionExpression]</code>的语法。它过滤集合并返回一个包含原始元素子集的新集合。例如，通过选择，我们可以轻松地获得塞尔维亚发明者的列表，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>List&LTInventor> list = (List&LTInventor>) parser.parseExpression(</span><br><span class=line>        <span class=string>"Members.?[Nationality == 'Serbian']"</span>).getValue(societyContext);</span><br></pre></table></figure> <p>在列表和 Map 上都可以选择。对于列表，将针对每个单独的列表元素评估选择标准。针对 Map，针对每个 Map 条目(Java 类型<code>Map.Entry</code>的对象)评估选择标准。每个 Map 条目都有其键和值，可作为属性进行访问以供选择。</p> <p>以下表达式返回一个新 Map，该 Map 由原始 Map 中条目值小于 27 的那些元素组成：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>Map</span> <span class=variable>newMap</span> <span class=operator>=</span> parser.parseExpression(<span class=string>"map.?[value&LT27]"</span>).getValue();</span><br></pre></table></figure> <p>除了返回所有选定的元素外，您只能检索第一个或最后一个值。要获得与选择匹配的第一个条目，语法为<code>.^[selectionExpression]</code>。要获得最后的匹配选择，语法为<code>.$[selectionExpression]</code>。</p> <h4 id=2-4-3-17、集合投影><a class=headerlink href=#2-4-3-17、集合投影 title=2.4.3.17、集合投影></a>2.4.3.17、集合投影</h4><p>投影使集合可以驱动子表达式的求值，结果是一个新的集合。投影的语法为<code>.![projectionExpression]</code>。例如，假设我们有一个发明家列表，但想要他们出生的城市的列表。实际上，我们希望为发明人列表中的每个条目评估“ placeOfBirth.city”。下面的示例使用投影来做到这一点：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>// returns ['Smiljan', 'Idvor' ]</span></span><br><span class=line><span class=type>List</span> <span class=variable>placesOfBirth</span> <span class=operator>=</span> (List)parser.parseExpression(<span class=string>"Members.![placeOfBirth.city]"</span>);</span><br></pre></table></figure> <p>您还可以使用 Map 来驱动投影，在这种情况下，将根据 Map 中的每个条目(以 Java <code>Map.Entry</code>表示)来评估投影表达式。跨 Map 的投影结果是一个列表，其中包含针对每个 Map 条目的投影表达式的评估。</p> <h4 id=2-4-3-18、表达式模板><a class=headerlink href=#2-4-3-18、表达式模板 title=2.4.3.18、表达式模板></a>2.4.3.18、表达式模板</h4><p>表达式模板允许将 Literals 文本与一个或多个评估块混合。每个评估块均以您可以定义的前缀和后缀字符分隔。常见的选择是使用<code>#{ }</code>作为分隔符，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=type>String</span> <span class=variable>randomPhrase</span> <span class=operator>=</span> parser.parseExpression(</span><br><span class=line>        <span class=string>"random number is #{T(java.lang.Math).random()}"</span>,</span><br><span class=line>        <span class=keyword>new</span> <span class="title class_">TemplateParserContext</span>()).getValue(String.class);</span><br><span class=line></span><br><span class=line><span class=comment>// evaluates to "random number is 0.7038186818312008"</span></span><br></pre></table></figure> <p>通过将 Literals 文本<code>'random number is '</code>与计算<code>#{ }</code>定界符内的表达式的结果(在这种情况下，是调用<code>random()</code>方法的结果)进行连接来评估字符串。 <code>parseExpression()</code>方法的第二个参数的类型为<code>ParserContext</code>。 <code>ParserContext</code>接口用于影响表达式的解析方式，以支持表达式模板功能。 <code>TemplateParserContext</code>的定义如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">TemplateParserContext</span> <span class=keyword>implements</span> <span class="title class_">ParserContext</span> {</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getExpressionPrefix</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"#{"</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getExpressionSuffix</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"}"</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">isTemplate</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h3 id=2-4-4、示例中使用的类><a class=headerlink href=#2-4-4、示例中使用的类 title=2.4.4、示例中使用的类></a>2.4.4、示例中使用的类</h3><p>本节列出了本章示例中使用的类。</p> <p>例子 1. Inventor.java</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> org.spring.samples.spel.inventor;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.util.Date;</span><br><span class=line><span class=keyword>import</span> java.util.GregorianCalendar;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Inventor</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> String nationality;</span><br><span class=line>    <span class=keyword>private</span> String[] inventions;</span><br><span class=line>    <span class=keyword>private</span> Date birthdate;</span><br><span class=line>    <span class=keyword>private</span> PlaceOfBirth placeOfBirth;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Inventor</span><span class=params>(String name, String nationality)</span> {</span><br><span class=line>        GregorianCalendar c= <span class=keyword>new</span> <span class="title class_">GregorianCalendar</span>();</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>        <span class=built_in>this</span>.nationality = nationality;</span><br><span class=line>        <span class=built_in>this</span>.birthdate = c.getTime();</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Inventor</span><span class=params>(String name, Date birthdate, String nationality)</span> {</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>        <span class=built_in>this</span>.nationality = nationality;</span><br><span class=line>        <span class=built_in>this</span>.birthdate = birthdate;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Inventor</span><span class=params>()</span> {</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getName</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> name;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setName</span><span class=params>(String name)</span> {</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getNationality</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> nationality;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setNationality</span><span class=params>(String nationality)</span> {</span><br><span class=line>        <span class=built_in>this</span>.nationality = nationality;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> Date <span class="title function_">getBirthdate</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> birthdate;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setBirthdate</span><span class=params>(Date birthdate)</span> {</span><br><span class=line>        <span class=built_in>this</span>.birthdate = birthdate;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> PlaceOfBirth <span class="title function_">getPlaceOfBirth</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> placeOfBirth;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setPlaceOfBirth</span><span class=params>(PlaceOfBirth placeOfBirth)</span> {</span><br><span class=line>        <span class=built_in>this</span>.placeOfBirth = placeOfBirth;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setInventions</span><span class=params>(String[] inventions)</span> {</span><br><span class=line>        <span class=built_in>this</span>.inventions = inventions;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> String[] getInventions() {</span><br><span class=line>        <span class=keyword>return</span> inventions;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>例子 2. PlaceOfBirth.java</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> org.spring.samples.spel.inventor;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">PlaceOfBirth</span> {</span><br><span class=line>    <span class=keyword>private</span> String city;</span><br><span class=line>    <span class=keyword>private</span> String country;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">PlaceOfBirth</span><span class=params>(String city)</span> {</span><br><span class=line>        <span class=built_in>this</span>.city=city;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">PlaceOfBirth</span><span class=params>(String city, String country)</span> {</span><br><span class=line>        <span class=built_in>this</span>(city);</span><br><span class=line>        <span class=built_in>this</span>.country = country;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getCity</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> city;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setCity</span><span class=params>(String s)</span> {</span><br><span class=line>        <span class=built_in>this</span>.city = s;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getCountry</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> country;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setCountry</span><span class=params>(String country)</span> {</span><br><span class=line>        <span class=built_in>this</span>.country = country;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>例子 3. Society.java</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> org.spring.samples.spel.inventor;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.util.*;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Society</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=type>String</span> <span class=variable>Advisors</span> <span class=operator>=</span> <span class=string>"advisors"</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=type>String</span> <span class=variable>President</span> <span class=operator>=</span> <span class=string>"president"</span>;</span><br><span class=line>    <span class=keyword>private</span> List&LTInventor> members = <span class=keyword>new</span> <span class="title class_">ArrayList</span>&LTInventor>();</span><br><span class=line>    <span class=keyword>private</span> <span class=type>Map</span> <span class=variable>officers</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">HashMap</span>();</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> List <span class="title function_">getMembers</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> members;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> Map <span class="title function_">getOfficers</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> officers;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getName</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> name;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setName</span><span class=params>(String name)</span> {</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">isMember</span><span class=params>(String name)</span> {</span><br><span class=line>        <span class=keyword>for</span> (Inventor inventor : members) {</span><br><span class=line>            <span class=keyword>if</span> (inventor.getName().equals(name)) {</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h2 id=2-5、空安全><a class=headerlink href=#2-5、空安全 title=2.5、空安全></a>2.5、空安全</h2><p>尽管Java不允许您使用其类型系统来表示空安全性，但Spring Framework现在在<code>org.springframework.lang</code>包中提供了以下注释，以使您可以声明API和字段的空性：</p> <ul><li><a href=https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/lang/Nullable.html rel=noopener target=_blank><code>@Nullable</code></a>：表示特定参数，返回值或字段可以为的注释<code>null</code>。<li><a href=https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/lang/NonNull.html rel=noopener target=_blank><code>@NonNull</code></a>：表示不能指定特定参数，返回值或字段的注释<code>null</code>（分别不需要在参数/返回值和字段<code>@NonNullApi</code>以及<code>@NonNullFields</code>应用的字段上）。<li><a href=https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/lang/NonNullApi.html rel=noopener target=_blank><code>@NonNullApi</code></a>：程序包级别的注释，它声明非null为参数和返回值的默认语义。<li><a href=https://docs.spring.io/spring-framework/docs/5.3.2/javadoc-api/org/springframework/lang/NonNullFields.html rel=noopener target=_blank><code>@NonNullFields</code></a>：程序包级别的注释，它声明非null作为字段的默认语义。</ul> <p>Spring框架本身利用了这些注释，但是它们也可以在任何基于Spring的Java项目中使用，以声明null安全的API和可选的null安全的字段。尚不支持泛型类型参数，varargs和数组元素的可空性，但应在即将发布的版本<a href=https://jira.spring.io/browse/SPR-15942 rel=noopener target=_blank>中将其</a> 支持，有关最新信息，请参见<a href=https://jira.spring.io/browse/SPR-15942 rel=noopener target=_blank>SPR-15942</a>。可空性声明有望在Spring Framework版本之间进行微调，包括次要版本。在方法主体内部使用的类型的可空性超出了此功能的范围。</p> <h3 id=2-5-1、用例><a class=headerlink href=#2-5-1、用例 title=2.5.1、用例></a>2.5.1、用例</h3><p>除了为Spring Framework API可空性提供显式声明外，IDE（例如IDEA或Eclipse）还可以使用这些注释来提供与空安全性相关的有用警告，从而避免<code>NullPointerException</code>在运行时出现警告。</p> <h3 id=2-5-2、JSR-305元注释><a class=headerlink href=#2-5-2、JSR-305元注释 title=2.5.2、JSR-305元注释></a>2.5.2、JSR-305元注释</h3><p>Spring注释使用<a href=https://jcp.org/en/jsr/detail?id=305 rel=noopener target=_blank>JSR 305</a> 注释（休眠但广泛使用的JSR）进行元注释。JSR-305元注释使工具供应商（如IDEA或Kotlin）以通用方式提供了空安全支持，而无需对Spring注释进行硬编码支持。</p> <p>既不需要也不建议向项目类路径中添加JSR-305依赖项以利用Spring空安全API。只有项目，如基于Spring的库，在他们的代码库使用空安全注解应该增加<code>com.google.code.findbugs:jsr305:3.0.2</code> 与<code>compileOnly</code>摇篮配置或Maven<code>provided</code>范围，以避免编译警告。</p> <h2 id=2-6、Appendix><a class=headerlink href=#2-6、Appendix title=2.6、Appendix></a>2.6、Appendix</h2><h3 id=2-6-1、XML模式><a class=headerlink href=#2-6-1、XML模式 title=2.6.1、XML模式></a>2.6.1、XML模式</h3><h4 id=2-6-1-1、实用模式><a class=headerlink href=#2-6-1-1、实用模式 title=2.6.1.1、实用模式></a>2.6.1.1、实用模式</h4><p>顾名思义，<code>util</code>标签处理常见的 Util 配置问题，例如配置集合，引用常量等。要在<code>util</code>模式中使用标签，您需要在 Spring XML 配置文件的顶部具有以下序言(代码段中的文本引用了正确的模式，以便您可以使用<code>util</code>名称空间中的标签)：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:util</span>=<span class=string>"http://www.springframework.org/schema/util"</span> <span class=attr>xsi:schemaLocation</span>=<span class=string>"</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd"</span>></span></span><br><span class=line></span><br><span class=line>        <span class=comment>&LT!-- bean definitions here --></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h5 id=使用util-constant><a class=headerlink href=#使用util-constant title=使用util:constant/></a>使用<a href=util:constant/>util:constant/</a></h5><p>考虑以下 bean 定义：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"..."</span> <span class=attr>class</span>=<span class=string>"..."</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"isolation"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"java.sql.Connection.TRANSACTION_SERIALIZABLE"</span></span></span><br><span class=line><span class=tag> <span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.config.FieldRetrievingFactoryBean"</span> /></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span>l</span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>前面的配置使用 Spring <code>FactoryBean</code>实现(<code>FieldRetrievingFactoryBean</code>)将 Bean 上<code>isolation</code>属性的值设置为<code>java.sql.Connection.TRANSACTION_SERIALIZABLE</code>常量的值。这一切都很好，但是很冗长，并且(不必要地)将 Spring 的内部管道暴露给最终用户。</p> <p>以下基于 XML Schema 的版本更加简洁，清楚地表达了开发人员的意图(“注入此常量值”)，并且读起来更好：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"..."</span> <span class=attr>class</span>=<span class=string>"..."</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"isolation"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>util:constant</span> <span class=attr>static-field</span>=<span class=string>"java.sql.Connection.TRANSACTION_SERIALIZABLE"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <h6 id=根据字段值设置-Bean-属性或构造函数参数><a title="根据字段值设置 Bean 属性或构造函数参数" class=headerlink href=#根据字段值设置-Bean-属性或构造函数参数></a>根据字段值设置 Bean 属性或构造函数参数</h6><p><a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html rel=noopener target=_blank>FieldRetrievingFactoryBean</a>是<code>FactoryBean</code>，它检索<code>static</code>或非静态字段值。它通常用于检索<code>public</code> <code>static</code> <code>final</code>常量，然后可用于为另一个 bean 设置属性值或构造函数参数。</p> <p>下面的示例显示如何通过使用<a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html#setStaticField(java.lang.String) rel=noopener target=_blank>staticField</a>属性来显示<code>static</code>字段：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"myField"</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.config.FieldRetrievingFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"staticField"</span> <span class=attr>lvalue</span>=<span class=string>"java.sql.Connection.TRANSACTION_SERIALIZABLE"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>还有一个便利用法表格，其中将<code>static</code>字段指定为 bean 名称，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"java.sql.Connection.TRANSACTION_SERIALIZABLE"</span></span></span><br><span class=line><span class=tag> <span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.config.FieldRetrievingFactoryBean"</span>/></span></span><br></pre></table></figure> <p>这的确意味着 Bean <code>id</code>不再是任何选择(因此，引用它的其他任何 Bean 也必须使用这个较长的名称)，但是这种形式的定义非常简洁，可以很方便地用作内部对象。 bean，因为不必为 bean 引用指定<code>id</code>，如以l下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"..."</span> <span class=attr>class</span>=<span class=string>"..."</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"isolation"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"java.sql.Connection.TRANSACTION_SERIALIZABLE"</span></span></span><br><span class=line><span class=tag><span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.config.FieldRetrievingFactoryBean"</span> /></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>您还可以访问另一个 bean 的非静态(实例)字段，如<a href=https://docs.spring.io/spring-framework/docs/5.1.3.RELEASE/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html rel=noopener target=_blank>FieldRetrievingFactoryBean</a>类的 API 文档中所述。</p> <p>在 Spring 中，很容易将枚举值作为属性或构造函数参数注入到 bean 中。实际上，您不必做任何事情或不了解 Spring 内部知识(甚至不必了解诸如<code>FieldRetrievingFactoryBean</code>之类的类)。以下示例枚举显示了注入枚举值的难易程度：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> javax.persistence;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>enum</span> <span class="title class_">PersistenceContextType</span> {</span><br><span class=line>    TRANSACTION,</span><br><span class=line>    EXTENDED</span><br><span class=line>}</span><br></pre></table></figure> <p>现在考虑以下类型为<code>PersistenceContextType</code>的 setter 和相应的 bean 定义：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> example;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Client</span> {</span><br><span class=line>    <span class=keyword>private</span> PersistenceContextType persistenceContextType;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setPersistenceContextType</span><span class=params>(PersistenceContextType type)</span> {</span><br><span class=line>        <span class=built_in>this</span>.persistenceContextType = type;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"example.Client"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"persistenceContextType"</span> <span class=attr>value</span>=<span class=string>"TRANSACTION"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <h5 id=使用util-property-path><a class=headerlink href=#使用util-property-path title=使用util:property-path/></a>使用<a href=util:property-path/>util:property-path/</a></h5><p>考虑以下示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- target bean to be referenced by name --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"testBean"</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.TestBean"</span> <span class=attr>scope</span>=<span class=string>"prototype"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"age"</span> <span class=attr>value</span>=<span class=string>"10"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"spouse"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.TestBean"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"age"</span> <span class=attr>value</span>=<span class=string>"11"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=comment>&LT!-- results in 10, which is the value of property 'age' of bean 'testBean' --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"testBean.age"</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.config.PropertyPathFactoryBean"</span>/></span></span><br></pre></table></figure> <p>前面的配置使用 Spring <code>FactoryBean</code>实现(<code>PropertyPathFactoryBean</code>)创建一个名为<code>testBean.age</code>的 Bean(类型<code>int</code>)，该 Bean 的值等于<code>testBean</code> bean 的<code>age</code>属性。</p> <p>现在考虑以下示例，该示例添l加了一个<code>&LTutil:property-path/></code>元素：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- target bean to be referenced by name --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"testBean"</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.TestBean"</span> <span class=attr>scope</span>=<span class=string>"prototype"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"age"</span> <span class=attr>value</span>=<span class=string>"10"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"spouse"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>bean</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.TestBean"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"age"</span> <span class=attr>value</span>=<span class=string>"11"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line></span><br><span class=line><span class=comment>&LT!-- results in 10, which is the value of property 'age' of bean 'testBean' --></span></span><br><span class=line><span class=tag><<span class=name>util:property-path</span> <span class=attr>id</span>=<span class=string>"name"</span> <span class=attr>path</span>=<span class=string>"testBean.age"</span>/></span></span><br></pre></table></figure> <p><code>&LTproperty-path/></code>元素的<code>path</code>属性的值遵循<code>beanName.beanProperty</code>的形式。在这种情况下，它将获取名为<code>testBean</code>的 bean 的l<code>age</code>属性。该<code>age</code>属性的值为<code>10</code>。</p> <h5 id=使用util-properties><a class=headerlink href=#使用util-properties title=使用util:properties/></a>使用<a href=util:properties/>util:properties/</a></h5><p>考虑以下示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- creates a java.util.Properties instance with values loaded from the supplied location --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"jdbcConfiguration"</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.config.PropertiesFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"location"</span> <span class=attr>value</span>=<span class=string>"classpath:com/foo/jdbc-production.properties"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>前面的配置使用 Spring <code>FactoryBean</code>实现(<code>PropertiesFactoryBean</code>)来实例化具有从提供的<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources rel=noopener target=_blank>Resource</a>位置加载的值的<code>java.util.Properties</code>实例)。</p> <p>以下示例使用<code>util:properties</code>元素进行更简洁的表示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- creates a java.util.Properties instance with values loaded from the supplied location --></span></span><br><span class=line><span class=tag><<span class=name>util:properties</span> <span class=attr>id</span>=<span class=string>"jdbcConfiguration"</span> <span class=attr>location</span>=<span class=string>"classpath:clom/foo/jdbc-production.properties"</span>/></span></span><br></pre></table></figure> <h5 id=使用util-list><a class=headerlink href=#使用util-list title=使用util:list/></a>使用<a href=util:list/>util:list/</a></h5><p>考虑以下示例：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>&LT!-- creates a java.util.List instance with values loaded from the supplied 'sourceList' --></span><br><span class=line>&LTbean id="emails" class="org.springframework.beans.factory.config.ListFactoryBean"></span><br><span class=line>    &LTproperty name="sourceList"></span><br><span class=line>        &LTlist></span><br><span class=line>            &LTvalue>[emailprotected]&LT/value></span><br><span class=line>            &LTvalue>[emailprotected]&LT/value></span><br><span class=line>            &LTvalue>[emailprotected]&LT/value></span><br><span class=line>            &LTvalue>[emailprotected]&LT/value></span><br><span class=line>        &LT/list></span><br><span class=line>    &LT/property></span><br><span class=line>&LT/bean></span><br></pre></table></figure> <p>前面的配置使用 Spring <code>FactoryBean</code>实现(<code>ListFactoryBean</code>)创建<code>java.util.List</code>实例，并使用从提供的<code>sourceList</code>中获取的值对其进行初始化。</p> <p>以下示例使用<code>&LTutil:list/></code>元素进行更简洁的表示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- creates a java.util.List instance with the supplied values --></span></span><br><span class=line><span class=tag><<span class=name>util:list</span> <span class=attr>id</span>=<span class=string>"emails"</span>></span>l</span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>util:list</span>></span></span><br></pre></table></figure> <p>您还可以使用<code>&LTutil:list/></code>元素上的<code>list-class</code>属性来显式控制实例化和填充的<code>List</code>的确切类型。例如，如果我们确实需要实例化<code>java.util.LinkedList</code>，则可以使用以下配置：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>util:list</span> <span class=attr>id</span>=<span class=string>"emails"</span> <span class=attr>list-class</span>=<span class=string>"java.util.LinkedList"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>d'[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>util:list</span>></span></span><br></pre></table></figure> <p>如果没有提供<code>list-class</code>属性，则容器选择<code>List</code>实现。</p> <h5 id=使用util-map><a class=headerlink href=#使用util-map title=使用util:map/></a>使用<a href=util:map/>util:map/</a></h5><p>考虑以下示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- creates a java.util.Map instance with values loaded from the supplied 'sourceMap' --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"emails"</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.config.MapFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"sourceMap"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>map</span>></span></span><br><span class=line>            <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"pechorin"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"raskolnikov"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"stavrogin"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"porfiry"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>map</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>前面的配置使用 Spring <code>FactoryBean</code>实现(<code>MapFactoryBean</code>)来创建<code>java.util.Map</code>实例，该实例使用从提供的<code>'sourceMap'</code>中获取的键值对进行初始化。</p> <p>以下示例使用<code>&LTutil:map/></code>元素进行更简洁的表示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- creates a java.util.Map instance with the supplied key-value pairs --></span></span><br><span class=line><span class=tag><<span class=name>util:map</span> <span class=attr>id</span>=<span class=string>"emails"</span>></span>l</span><br><span class=line>    <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"pechorin"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"raskolnikov"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"stavrogin"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"porfiry"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>util:map</span>></span></span><br></pre></table></figure> <p>您还可以使用<code>&LTutil:map/></code>元素上的<code>'map-class'</code>属性来显式控制实例化和填充的<code>Map</code>的确切类型。例如，如果我们确实需要实例化<code>java.util.TreeMap</code>，则可以使用以下配置：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>util:map</span> <span class=attr>id</span>=<span class=string>"emails"</span> <span class=attr>map-class</span>=<span class=string>"java.util.TreeMap"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"pechorin"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"raskolnikov"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"stavrogin"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>entry</span> <span class=attr>key</span>=<span class=string>"porfiry"</span> <span class=attr>value</span>=<span class=string>"[emailprotected]"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>util:map</span>></span></span><br></pre></table></figure> <p>如果没有提供<code>'map-class'</code>属性，则容器选择<code>Map</code>实现。</p> <h5 id=使用util-set><a class=headerlink href=#使用util-set title=使用util:set/></a>使用<a href=util:set/>util:set/</a></h5><p>考虑以下示例：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- creates a java.util.Set instance with values loaded from the supplied 'sourceSet' --></span></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"emails"</span> <span class=attr>class</span>=<span class=string>"org.springframework.beans.factory.config.SetFactoryBean"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"sourceSet"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>set</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>            <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>set</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>前面的配置使用 Spring <code>FactoryBean</code>实现(<code>SetFactoryBean</code>)来创建<code>java.util.Set</code>实例，该实例使用从提供的<code>sourceSet</code>中获取的值进行初始化。</p> <p>以下示例使用<code>&LTutil:set/></code>元素进行更简洁的表示：l</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- creates a java.util.Set instance with the supplied values --></span></span><br><span class=line><span class=tag><<span class=name>util:set</span> <span class=attr>id</span>=<span class=string>"emails"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>util:set</span>></span></span><br></pre></table></figure> <p>您还可以使用<code>&LTutil:set/></code>元素上的<code>set-class</code>属性来显式控制实例化和填充的<code>Set</code>的确切类型。例如，如果我们确实需要实例化<code>java.util.TreeSet</code>，则可以使用以下配置：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>util:set</span> <span class=attr>id</span>=<span class=string>"emails"</span> <span class=attr>set-class</span>=<span class=string>"java.util.TreeSet"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span>l</span><br><span class=line>    <span class=tag><<span class=name>value</span>></span>[emailprotected]<span class=tag>&LT/<span class=name>value</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>util:set</span>></span></span><br></pre></table></figure> <p>如果没有提供<code>set-class</code>属性，则容器选择<code>Set</code>实现。</p> <h4 id=2-6-1-2、aop模式><a class=headerlink href=#2-6-1-2、aop模式 title=2.6.1.2、aop模式></a>2.6.1.2、aop模式</h4><p>要在<code>aop</code>模式中使用标签，您需要在 Spring XML 配置文件的顶部具有以下前导(代码段中的文本引用了正确的模式，以便<code>aop</code>名称空间中的标签为提供给您)：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:aop</span>=<span class=string>"http://www.springframework.org/schema/aop"</span> <span class=attr>xsi:schemaLocation</span>=<span class=string>"</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- bean definitions here --></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h4 id=2-6-1-3、上下文模式><a class=headerlink href=#2-6-1-3、上下文模式 title=2.6.1.3、上下文模式></a>2.6.1.3、上下文模式</h4><p>以下代码段引用了正确的架构，以便您可以使用<code>context</code>名称空间中的元素：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:context</span>=<span class=string>"http://www.springframework.org/schema/context"</span> <span class=attr>xsi:schemaLocation</span>=<span class=string>"</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- bean definitions here --></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h5 id=使用><a title="使用<property-placeholder/>" class=headerlink href=#使用></a>使用<code>&LTproperty-placeholder/></code></h5><p>此元素激活<code>${…}</code>占位符的替换，这些占位符针对指定的属性文件(作为<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#resources rel=noopener target=_blank>Spring 资源位置</a>)解析。此元素是为您设置<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-placeholderconfigurer rel=noopener target=_blank>PropertyPlaceholderConfigurer</a>的便捷机制。如果您需要对<code>PropertyPlaceholderConfigurer</code>的更多控制，则可以自己明确定义。</p> <h5 id=使用-1><a title="使用<annotation-config/>" class=headerlink href=#使用-1></a>使用<code>&LTannotation-config/></code></h5><p>此元素激活 Spring 基础结构以检测 Bean 类中的 注解：</p> <ul><li>Spring 的<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-required-annotation rel=noopener target=_blank>@Required</a>和<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-annotation-config rel=noopener target=_blank>@Autowired</a><li>JSR 250 的<code>@PostConstruct</code>，<code>@PreDestroy</code>和<code>@Resource</code>(如果有)<li>JPA 的<code>@PersistenceContext</code>和<code>@PersistenceUnit</code>(如果有)。</ul> <p>或者，您可以选择为这些注解显式激活单独的<code>BeanPostProcessors</code>。</p> <blockquote><p>该元素不会激活对 Spring 的<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/data-access.html#transaction-declarative-annotations rel=noopener target=_blank>@Transactional</a>注解 的处理。您可以为此使用<a href=tx:annotation-driven/>tx:annotation-driven/</a>元素。</blockquote> <h5 id=使用-2><a title="使用<component-scan/>" class=headerlink href=#使用-2></a>使用<code>&LTcomponent-scan/></code></h5><p><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-annotation-config rel=noopener target=_blank>基于注解的容器配置</a>中对此元素进行了详细说明。</p> <h5 id=使用-3><a title="使用<load-time-weaver/>" class=headerlink href=#使用-3></a>使用<code>&LTload-time-weaver/></code></h5><p><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-aj-ltw rel=noopener target=_blank>在 Spring Framework 中使用 AspectJ 进行加载时编织</a>中对此元素进行了详细说明。</p> <h5 id=使用-4><a title="使用<spring-configured/>" class=headerlink href=#使用-4></a>使用<code>&LTspring-configured/></code></h5><p><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#aop-atconfigurable rel=noopener target=_blank>使用 AspectJ 通过 Spring 依赖注入域对象</a>中对此元素进行了详细说明。</p> <h5 id=使用-5><a title="使用<mbean-export/>" class=headerlink href=#使用-5></a>使用<code>&LTmbean-export/></code></h5><p><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/integration.html#jmx-context-mbeanexport rel=noopener target=_blank>配置基于注解的 MBean 导出</a>中对此元素进行了详细说明。</p> <h4 id=2-6-1-4、Bean模式><a class=headerlink href=#2-6-1-4、Bean模式 title=2.6.1.4、Bean模式></a>2.6.1.4、Bean模式</h4><p>以下示例在周围的<code>&LTbean/></code>上下文中显示了<code>&LTmeta/></code>元素(请注意，由于没有任何逻辑来解释它，因此元数据实际上是毫无用处的)。</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"foo"</span> <span class=attr>class</span>=<span class=string>"x.y.Foo"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>meta</span> <span class=attr>key</span>=<span class=string>"cacheName"</span> <span class=attr>value</span>=<span class=string>"foo"</span>/></span> (1)</span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>value</span>=<span class=string>"Rick"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h3 id=2-6-2、XML模式创作><a class=headerlink href=#2-6-2、XML模式创作 title=2.6.2、XML模式创作></a>2.6.2、XML模式创作</h3><p>从 2.0 版开始，Spring 提供了一种机制，可以将基于架构的扩展添加到基本 Spring XML 格式中，以定义和配置 bean。</p> <p>为了方便使用架构感知的 XML 编辑器编写配置文件，Spring 的可扩展 XML 配置机制基于 XML Schema。如果您不熟悉标准 Spring 发行版随附的 Spring 当前的 XML 配置扩展，则应首先阅读名为[<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-config rel=noopener target=_blank>xsd-config]</a>的附录。</p> <p>要创建新的 XML 配置扩展，请执行以下操作：</p> <ul><li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-custom-schema rel=noopener target=_blank>Author</a> XML 模式，用于描述您的自定义元素。<li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-custom-namespacehandler rel=noopener target=_blank>Code</a>自定义<code>NamespaceHandler</code>实现。<li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-custom-parser rel=noopener target=_blank>Code</a>个或多个<code>BeanDefinitionParser</code>个实现(这是完成实际工作的地方)。<li><a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-custom-registration rel=noopener target=_blank>Register</a>使用 Spring 的新工件。</ul> <p>对于一个统一的示例，我们创建一个 XML 扩展(一个自定义 XML 元素)，该扩展使我们可以配置<code>SimpleDateFormat</code>类型的对象(来自<code>java.text</code>包)。完成后，我们将能够如下定义<code>SimpleDateFormat</code>类型的 bean 定义：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>&LTmyns:dateformat id="dateFormat"</span><br><span class=line>    pattern="yyyy-MM-dd HH:mm"</span><br><span class=line>    lenient="true"/></span><br></pre></table></figure> <h4 id=2-6-2-1、编写架构><a class=headerlink href=#2-6-2-1、编写架构 title=2.6.2.1、编写架构></a>2.6.2.1、编写架构</h4><p>创建用于 Spring 的 IoC 容器的 XML 配置扩展首先要编写 XML Schema 来描述扩展。对于我们的示例，我们使用以下架构来配置<code>SimpleDateFormat</code>对象：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- myns.xsd (inside package org/springframework/samples/xml) --></span></span><br><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>xsd:schema</span> <span class=attr>xmlns</span>=<span class=string>"http://www.mycompany.com/schema/myns"</span></span></span><br><span class=line><span class=tag>        <span class=attr>xmlns:xsd</span>=<span class=string>"http://www.w3.org/2001/XMLSchema"</span></span></span><br><span class=line><span class=tag>        <span class=attr>xmlns:beans</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>        <span class=attr>targetNamespace</span>=<span class=string>"http://www.mycompany.com/schema/myns"</span></span></span><br><span class=line><span class=tag>        <span class=attr>elementFormDefault</span>=<span class=string>"qualified"</span></span></span><br><span class=line><span class=tag>        <span class=attr>attributeFormDefault</span>=<span class=string>"unqualified"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>xsd:import</span> <span class=attr>namespace</span>=<span class=string>"http://www.springframework.org/schema/beans"</span>/></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>xsd:element</span> <span class=attr>name</span>=<span class=string>"dateformat"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>xsd:complexType</span>></span></span><br><span class=line>            <span class=tag><<span class=name>xsd:complexContent</span>></span></span><br><span class=line>                <span class=tag><<span class=name>xsd:extension</span> <span class=attr>base</span>=<span class=string>"beans:identifiedType"</span>></span> (1)</span><br><span class=line>                    <span class=tag><<span class=name>xsd:attribute</span> <span class=attr>name</span>=<span class=string>"lenient"</span> <span class=attr>type</span>=<span class=string>"xsd:boolean"</span>/></span></span><br><span class=line>                    <span class=tag><<span class=name>xsd:attribute</span> <span class=attr>name</span>=<span class=string>"pattern"</span> <span class=attr>type</span>=<span class=string>"xsd:string"</span> <span class=attr>use</span>=<span class=string>"required"</span>/></span></span><br><span class=line>                <span class=tag>&LT/<span class=name>xsd:extension</span>></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>xsd:complexContent</span>></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>xsd:complexType</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>xsd:element</span>></span>l</span><br><span class=line><span class=tag>&LT/<span class=name>xsd:schema</span>></span></span><br></pre></table></figure> <ul><li><strong>(1)</strong> 所指示的行包含所有可识别标签的扩展基础(这意味着它们具有<code>id</code>属性，我们可以将其用作容器中的 bean 标识符)。我们可以使用此属性，因为我们导入了 Spring 提供的<code>beans</code>名称空间。</ul> <p>前面的架构使我们可以使用<code>&LTmyns:dateformat/></code>元素直接在 XML 应用程序上下文文件中配置<code>SimpleDateFormat</code>对象，如以下示例所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>myns:dateformat</span> <span class=attr>id</span>=<span class=string>"dateFormat"</span></span></span><br><span class=line><span class=tag>    <span class=attr>pattern</span>=<span class=string>"yyyy-MM-dd HH:mm"</span></span></span><br><span class=line><span class=tag>    <span class=attr>lenient</span>=<span class=string>"true"</span>/></span></span><br></pre></table></figure> <p>请注意，在创建基础结构类之后，上述 XML 片段与以下 XML 片段基本相同：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"dateFormat"</span> <span class=attr>class</span>=<span class=string>"java.text.SimpleDateFormat"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>constructor-arg</span> <span class=attr>value</span>=<span class=string>"yyyy-HH-dd HH:mm"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"lenient"</span> <span class=attr>value</span>=<span class=string>"true"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span>l</span><br></pre></table></figure> <p>前面两个片段中的第二个片段在容器中创建了一个 bean(以类型<code>SimpleDateFormat</code>的名称<code>dateFormat</code>标识)，并设置了两个属性。</p> <h4 id=2-6-2-2、编码-NamespaceHandler><a title="2.6.2.2、编码 NamespaceHandler" class=headerlink href=#2-6-2-2、编码-NamespaceHandler></a>2.6.2.2、编码 NamespaceHandler</h4><p>除了模式，我们还需要一个<code>NamespaceHandler</code>来解析 Spring 在解析配置文件时遇到的该特定名称空间的所有元素。对于此示例，<code>NamespaceHandler</code>应该负责<code>myns:dateformat</code>元素的解析。</p> <p><code>NamespaceHandler</code>界面具有三种方法：</p> <ul><li><code>init()</code>：允许<code>NamespaceHandler</code>初始化，并且在使用处理程序之前由 Spring 调用。<li><code>BeanDefinition parse(Element, ParserContext)</code>：当 Spring 遇到顶级元素(未嵌套在 bean 定义或其他命名空间中)时调用。此方法本身可以注册 Bean 定义，返回 Bean 定义或两者。<li><code>BeanDefinitionHolder decorate(Node, BeanDefinitionHolder, ParserContext)</code>：当 Spring 遇到另一个名称空间的属性或嵌套元素时调用。例如，一个或多个 bean 定义的修饰与<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#beans-factory-scopes rel=noopener target=_blank>Spring 支持的范围</a>一起使用。我们首先突出显示一个简单的示例，而不使用装饰，然后在一个更高级的示例中显示装饰。</ul> <p>尽管您可以为整个名称空间编写自己的<code>NamespaceHandler</code>(并因此提供解析名称空间中每个元素的代码)，但是通常情况下，Spring XML 配置文件中的每个顶级 XML 元素都产生一个 bean 定义(例如在我们的示例中，单个<code>&LTmyns:dateformat/></code>元素导致单个<code>SimpleDateFormat</code> bean 定义)。 Spring 提供了许多支持这种情况的便利类。在下面的示例中，我们使用<code>NamespaceHandlerSupport</code>类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> org.springframework.samples.xml;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.xml.NamespaceHandlerSupport;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyNamespaceHandler</span> <span class=keyword>extends</span> <span class="title class_">NamespaceHandlerSupport</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">init</span><span class=params>()</span> {</span><br><span class=line>        registerBeanDefinitionParser(<span class=string>"dateformat"</span>, <span class=keyword>new</span> <span class="title class_">SimpleDateFormatBeanDefinitionParser</span>());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>您可能会注意到，此类中实际上没有很多解析逻辑。的确，<code>NamespaceHandlerSupport</code>类具有内置的委托概念。它支持注册任意数量的<code>BeanDefinitionParser</code>实例，当需要解析其命名空间中的元素时，可以委托该实例注册。这种清晰的关注点分离使<code>NamespaceHandler</code>处理其命名空间中所有自定义元素的解析编排，同时委派<code>BeanDefinitionParsers</code>来完成 XML 解析的繁琐工作。这意味着每个<code>BeanDefinitionParser</code>仅包含解析单个自定义元素的逻辑，正如我们在下一步中看到的那样。</p> <h4 id=2-6-2-3、使用BeanDefinitionParser><a class=headerlink href=#2-6-2-3、使用BeanDefinitionParser title=2.6.2.3、使用BeanDefinitionParser></a>2.6.2.3、使用BeanDefinitionParser</h4><p>如果<code>NamespaceHandler</code>遇到 Map 到特定 bean 定义解析器(在这种情况下为<code>dateformat</code>)的 XML 元素，则使用<code>BeanDefinitionParser</code>。换句话说，<code>BeanDefinitionParser</code>负责解析模式中定义的一个不同的顶级 XML 元素。在解析器中，我们可以访问 XML 元素(因此也可以访问其子元素)，以便我们可以解析自定义 XML 内容，如以下示例所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> org.springframework.samples.xml;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.support.BeanDefinitionBuilder;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;</span><br><span class=line><span class=keyword>import</span> org.springframework.util.StringUtils;</span><br><span class=line><span class=keyword>import</span> org.w3c.dom.Element;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.text.SimpleDateFormat;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleDateFormatBeanDefinitionParser</span> <span class=keyword>extends</span> <span class="title class_">AbstractSingleBeanDefinitionParser</span> { (<span class=number>1</span>)</span><br><span class=line>    <span class=keyword>protected</span> Class <span class="title function_">getBeanClass</span><span class=params>(Element element)</span> {</span><br><span class=line>        <span class=keyword>return</span> SimpleDateFormat.class; (<span class=number>2</span>)</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>void</span> <span class="title function_">doParse</span><span class=params>(Element element, BeanDefinitionBuilder bean)</span> {</span><br><span class=line>        <span class=comment>// this will never be null since the schema explicitly requires that a value be supplied</span></span><br><span class=line>        <span class=type>String</span> <span class=variable>pattern</span> <span class=operator>=</span> element.getAttribute(<span class=string>"pattern"</span>);</span><br><span class=line>        bean.addConstructorArg(pattern);</span><br><span class=line></span><br><span class=line>        <span class=comment>// this however is an optional property</span></span><br><span class=line>        <span class=type>String</span> <span class=variable>lenient</span> <span class=operator>=</span> element.getAttribute(<span class=string>"lenient"</span>);</span><br><span class=line>        <span class=keyword>if</span> (StringUtils.hasText(lenient)) {</span><br><span class=line>            bean.addPropertyValue(<span class=string>"lenient"</span>, Boolean.valueOf(lenient));</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <ul><li><strong>(1)</strong> 我们使用 Spring 提供的<code>AbstractSingleBeanDefinitionParser</code>来处理创建单个<code>BeanDefinition</code>的许多基本工作。<li><strong>(2)</strong> 我们为<code>AbstractSingleBeanDefinitionParser</code>超类提供了我们的单个<code>BeanDefinition</code>表示的类型。</ul> <p>在这种简单的情况下，这就是我们要做的全部。 <code>BeanDefinition</code>的创建由<code>AbstractSingleBeanDefinitionParser</code>超类处理，bean 定义的唯一标识符的提取和设置也是如此。</p> <h4 id=2-6-2-4、注册处理程序和架构><a class=headerlink href=#2-6-2-4、注册处理程序和架构 title=2.6.2.4、注册处理程序和架构></a>2.6.2.4、注册处理程序和架构</h4><p>编码完成。剩下要做的就是让 Spring XML 解析基础结构了解我们的自定义元素。为此，我们在两个特殊用途的属性文件中注册了自定义<code>namespaceHandler</code>和自定义 XSD 文件。这些属性文件都放置在应用程序的<code>META-INF</code>目录中，例如，可以与二进制类一起分发到 JAR 文件中。 Spring XML 解析基础结构通过使用这些特殊的属性文件来自动选择您的新扩展，以下两部分将详细介绍其格式。</p> <h5 id=Writing-META-INF-spring-handlers><a title="Writing META-INF/spring.handlers" class=headerlink href=#Writing-META-INF-spring-handlers></a>Writing META-INF/spring.handlers</h5><p>名为<code>spring.handlers</code>的属性文件包含 XML 模式 URI 到名称空间处理程序类的 Map。对于我们的示例，我们需要编写以下内容：</p> <figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>http\://www.mycompany.com/schema/myns=org.springframework.samples.xml.MyNamespaceHandler</span><br></pre></table></figure> <p>(<code>:</code>字符是 Java 属性格式的有效分隔符，因此 URI 中的<code>:</code>字符需要用反斜杠转义.)</p> <p>键值对的第一部分(键)是与您的自定义名称空间扩展关联的 URI，并且需要与您的自定义 XSD 架构中指定的<code>targetNamespace</code>属性值完全匹配。</p> <h5 id=Writing-‘META-INF-spring-schemas’><a title="Writing ‘META-INF/spring.schemas’" class=headerlink href=#Writing-‘META-INF-spring-schemas’></a>Writing ‘META-INF/spring.schemas’</h5><p>名为<code>spring.schemas</code>的属性文件包含 XML 架构位置(与架构声明一起引用，在使用该架构作为<code>xsi:schemaLocation</code>属性的一部分的 XML 文件中)到 Classpath 资源。需要该文件来防止 Spring 绝对使用默认的<code>EntityResolver</code>，该默认<code>EntityResolver</code>需要 Internet 访问才能检索架构文件。如果您在此属性文件中指定 Map，Spring 将在 Classpath 上搜索架构(在本例中为<code>org.springframework.samples.xml</code>包中的<code>myns.xsd</code>)。以下代码段显示了我们需要为自定义架构添加的行：</p> <figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>http\://www.mycompany.com/schema/myns/myns.xsd=org/springframework/samples/xml/myns.xsd</span><br></pre></table></figure> <p>(请记住，必须对<code>:</code>字符进行转义.)</p> <p>鼓励您在 Classpath 上的<code>NamespaceHandler</code>和<code>BeanDefinitionParser</code>类旁边部署 XSD 文件。</p> <h4 id=2-6-2-5、在-Spring-XML-配置中使用自定义扩展><a title="2.6.2.5、在 Spring XML 配置中使用自定义扩展" class=headerlink href=#2-6-2-5、在-Spring-XML-配置中使用自定义扩展></a>2.6.2.5、在 Spring XML 配置中使用自定义扩展</h4><p>使用您自己实现的定制扩展与使用 Spring 提供的“定制”扩展之一没有什么不同。以下示例在 Spring XML 配置文件中使用前面步骤中开发的自定义<code>&LTdateformat/></code>元素：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:myns</span>=<span class=string>"http://www.mycompany.com/schema/myns"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.mycompany.com/schema/myns http://www.mycompany.com/schema/myns/myns.xsd"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=comment>&LT!-- as a top-level bean --></span></span><br><span class=line>    <span class=tag><<span class=name>myns:dateformat</span> <span class=attr>id</span>=<span class=string>"defaultDateFormat"</span> <span class=attr>pattern</span>=<span class=string>"yyyy-MM-dd HH:mm"</span> <span class=attr>lenient</span>=<span class=string>"true"</span>/></span> (1)</span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"jobDetailTemplate"</span> <span class=attr>abstract</span>=<span class=string>"true"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"dateFormat"</span>></span></span><br><span class=line>            <span class=comment>&LT!-- as an inner bean --></span></span><br><span class=line>            <span class=tag><<span class=name>myns:dateformat</span> <span class=attr>pattern</span>=<span class=string>"HH:mm MM-dd-yyyy"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>property</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>bean</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <h4 id=2-6-2-6、更详细的例子><a class=headerlink href=#2-6-2-6、更详细的例子 title=2.6.2.6、更详细的例子></a>2.6.2.6、更详细的例子</h4><h5 id=在自定义元素中嵌套自定义元素><a class=headerlink href=#在自定义元素中嵌套自定义元素 title=在自定义元素中嵌套自定义元素></a>在自定义元素中嵌套自定义元素</h5><p>本节中的示例显示如何编写满足以下配置目标所需的各种工件：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xmlns:foo</span>=<span class=string>"http://www.foo.com/schema/component"</span></span></span><br><span class=line><span class=tag>    <span class=attr>xsi:schemaLocation</span>=<span class=string>"</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>        http://www.foo.com/schema/component http://www.foo.com/schema/component/component.xsd"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>foo:component</span> <span class=attr>id</span>=<span class=string>"bionic-family"</span> <span class=attr>name</span>=<span class=string>"Bionic-1"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>foo:component</span> <span class=attr>name</span>=<span class=string>"Mother-1"</span>></span></span><br><span class=line>            <span class=tag><<span class=name>foo:component</span> <span class=attr>name</span>=<span class=string>"Karate-1"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>foo:component</span> <span class=attr>name</span>=<span class=string>"Sport-1"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>foo:component</span>></span></span><br><span class=line>        <span class=tag><<span class=name>foo:component</span> <span class=attr>name</span>=<span class=string>"Rock-1"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>foo:component</span>></span></span><br><span class=line></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure> <p>前面的配置将自定义扩展相互嵌套。 <code>&LTfoo:component/></code>元素实际配置的类是<code>Component</code>类(在下一个示例中显示)。注意<code>Component</code>类如何不公开<code>components</code>属性的 setter 方法。这使得很难(或几乎不可能)通过使用 setter 注入为<code>Component</code>类配置 bean 定义。以下清单显示了<code>Component</code>类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.foo;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.util.ArrayList;</span><br><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Component</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> List&LTComponent> components = <span class=keyword>new</span> <span class="title class_">ArrayList</span>&LTComponent> ();</span><br><span class=line></span><br><span class=line>    <span class=comment>// mmm, there is no setter method for the 'components'</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">addComponent</span><span class=params>(Component component)</span> {</span><br><span class=line>        <span class=built_in>this</span>.components.add(component);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> List&LTComponent> <span class="title function_">getComponents</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> components;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getName</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> name;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setName</span><span class=params>(String name)</span> {</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>解决此问题的典型方法是创建一个自定义<code>FactoryBean</code>，该自定义<code>FactoryBean</code>公开<code>components</code>属性的 setter 属性。以下清单显示了这样的自定义<code>FactoryBean</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.foo;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ComponentFactoryBean</span> <span class=keyword>implements</span> <span class="title class_">FactoryBean</span>&LTComponent> {</span><br><span class=line>    <span class=keyword>private</span> Component parent;</span><br><span class=line>    <span class=keyword>private</span> List&LTComponent> children;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setParent</span><span class=params>(Component parent)</span> {</span><br><span class=line>        <span class=built_in>this</span>.parent = parent;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setChildren</span><span class=params>(List&LTComponent> children)</span> {</span><br><span class=line>        <span class=built_in>this</span>.children = children;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> Component <span class="title function_">getObject</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>this</span>.children != <span class=literal>null</span> && <span class=built_in>this</span>.children.size() > <span class=number>0</span>) {</span><br><span class=line>            <span class=keyword>for</span> (Component child : children) {</span><br><span class=line>                <span class=built_in>this</span>.parent.addComponent(child);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.parent;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> Class&LTComponent> <span class="title function_">getObjectType</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> Component.class;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">isSingleton</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>这很好用，但是向最终用户暴露了很多 Spring 管道。我们要做的是编写一个自定义 extensions，以隐藏所有此 Spring 管道。如果我们坚持使用<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-custom-introduction rel=noopener target=_blank>前面描述的步骤</a>，那么我们首先创建 XSD 模式以定义自定义标记的结构，如以下清单所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span> standalone=<span class=string>"no"</span>?></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>xsd:schema</span> <span class=attr>xmlns</span>=<span class=string>"http://www.foo.com/schema/component"</span></span></span><br><span class=line><span class=tag>        <span class=attr>xmlns:xsd</span>=<span class=string>"http://www.w3.org/2001/XMLSchema"</span></span></span><br><span class=line><span class=tag>        <span class=attr>targetNamespace</span>=<span class=string>"http://www.foo.com/schema/component"</span></span></span><br><span class=line><span class=tag>        <span class=attr>elementFormDefault</span>=<span class=string>"qualified"</span></span></span><br><span class=line><span class=tag>        <span class=attr>attributeFormDefault</span>=<span class=string>"unqualified"</span>></span></span><br><span class=line>    </span><br><span class=line>    <span class=tag><<span class=name>xsd:element</span> <span class=attr>name</span>=<span class=string>"component"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>xsd:complexType</span>></span></span><br><span class=line>            <span class=tag><<span class=name>xsd:choice</span> <span class=attr>minOccurs</span>=<span class=string>"0"</span> <span class=attr>maxOccurs</span>=<span class=string>"unbounded"</span>></span></span><br><span class=line>                <span class=tag><<span class=name>xsd:element</span> <span class=attr>ref</span>=<span class=string>"component"</span>/></span></span><br><span class=line>            <span class=tag>&LT/<span class=name>xsd:choice</span>></span></span><br><span class=line>            <span class=tag><<span class=name>xsd:attribute</span> <span class=attr>name</span>=<span class=string>"id"</span> <span class=attr>type</span>=<span class=string>"xsd:ID"</span>/></span></span><br><span class=line>            <span class=tag><<span class=name>xsd:attribute</span> <span class=attr>name</span>=<span class=string>"name"</span> <span class=attr>use</span>=<span class=string>"required"</span> <span class=attr>type</span>=<span class=string>"xsd:string"</span>/></span></span><br><span class=line>        <span class=tag>&LT/<span class=name>xsd:complexType</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>xsd:element</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>xsd:schema</span>></span></span><br></pre></table></figure> <p>在<a href=https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference/core.html#xsd-custom-introduction rel=noopener target=_blank>前面描述的过程</a>之后，我们再创建一个自定义<code>NamespaceHandler</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.foo;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.xml.NamespaceHandlerSupport;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ComponentNamespaceHandler</span> <span class=keyword>extends</span> <span class="title class_">NamespaceHandlerSupport</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">init</span><span class=params>()</span> {</span><br><span class=line>        registerBeanDefinitionParser(<span class=string>"component"</span>, <span class=keyword>new</span> <span class="title class_">ComponentBeanDefinitionParser</span>());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>接下来是自定义<code>BeanDefinitionParser</code>。请记住，我们正在创建<code>BeanDefinition</code>来描述<code>ComponentFactoryBean</code>。以下清单显示了我们的自定义<code>BeanDefinitionParser</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.foo;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.config.BeanDefinition;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.support.AbstractBeanDefinition;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.support.BeanDefinitionBuilder;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.support.ManagedList;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.xml.AbstractBeanDefinitionParser;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.xml.ParserContext;</span><br><span class=line><span class=keyword>import</span> org.springframework.util.xml.DomUtils;</span><br><span class=line><span class=keyword>import</span> org.w3c.dom.Element;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ComponentBeanDefinitionParser</span> <span class=keyword>extends</span> <span class="title class_">AbstractBeanDefinitionParser</span> {</span><br><span class=line>    <span class=keyword>protected</span> AbstractBeanDefinition <span class="title function_">parseInternal</span><span class=params>(Element element, ParserContext parserContext)</span> {</span><br><span class=line>        <span class=keyword>return</span> parseComponentElement(element);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> AbstractBeanDefinition <span class="title function_">parseComponentElement</span><span class=params>(Element element)</span> {</span><br><span class=line>        <span class=type>BeanDefinitionBuilder</span> <span class=variable>factory</span> <span class=operator>=</span> BeanDefinitionBuilder.rootBeanDefinition(ComponentFactoryBean.class);</span><br><span class=line>        factory.addPropertyValue(<span class=string>"parent"</span>, parseComponent(element));</span><br><span class=line></span><br><span class=line>        List&LTElement> childElements = DomUtils.getChildElementsByTagName(element, <span class=string>"component"</span>);</span><br><span class=line>        <span class=keyword>if</span> (childElements != <span class=literal>null</span> && childElements.size() > <span class=number>0</span>) {</span><br><span class=line>            parseChildComponents(childElements, factory);</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=keyword>return</span> factory.getBeanDefinition();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> BeanDefinition <span class="title function_">parseComponent</span><span class=params>(Element element)</span> {</span><br><span class=line>        <span class=type>BeanDefinitionBuilder</span> <span class=variable>component</span> <span class=operator>=</span> BeanDefinitionBuilder.rootBeanDefinition(Component.class);</span><br><span class=line>        component.addPropertyValue(<span class=string>"name"</span>, element.getAttribute(<span class=string>"name"</span>));</span><br><span class=line>        <span class=keyword>return</span> component.getBeanDefinition();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">parseChildComponents</span><span class=params>(List&LTElement> childElements, BeanDefinitionBuilder factory)</span> {</span><br><span class=line>        ManagedList&LTBeanDefinition> children = <span class=keyword>new</span> <span class="title class_">ManagedList</span>&LTBeanDefinition>(childElements.size());</span><br><span class=line>        <span class=keyword>for</span> (Element element : childElements) {</span><br><span class=line>            children.add(parseComponentElement(element));</span><br><span class=line>        }</span><br><span class=line>        factory.addPropertyValue(<span class=string>"children"</span>, children);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>最后，需要通过修改<code>META-INF/spring.handlers</code>和<code>META-INF/spring.schemas</code>文件，将各种工件注册到 Spring XML 基础结构中，如下所示：</p> <figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_"># </span><span class=language-bash><span class=keyword>in</span> <span class=string>'META-INF/spring.handlers'</span></span></span><br><span class=line>http\://www.foo.com/schema/component=com.foo.ComponentNamespaceHandler</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash><span class=keyword>in</span> <span class=string>'META-INF/spring.schemas'</span></span></span><br><span class=line>http\://www.foo.com/schema/component/component.xsd=com/foo/component.xsd</span><br></pre></table></figure> <h5 id=“常规”元素上的自定义属性><a class=headerlink href=#“常规”元素上的自定义属性 title=“常规”元素上的自定义属性></a>“常规”元素上的自定义属性</h5><p>编写自己的自定义解析器和关联的工件并不难。但是，有时这不是正确的选择。考虑一个需要将元数据添加到已经存在的 bean 定义的场景。在这种情况下，您当然不需要编写自己的整个自定义扩展。相反，您只想向现有的 bean 定义元素添加一个附加属性。</p> <p>作为另一个示例，假设您为访问集群<a href=https://jcp.org/en/jsr/detail?id=107 rel=noopener target=_blank>JCache</a>的服务对象(它不知道)定义了一个 bean 定义，并且您想确保在周围的集群中急切启动命名的 JCache 实例。以下清单显示了这样的定义：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"checkingAccountService"</span> <span class=attr>class</span>=<span class=string>"com.foo.DefaultCheckingAccountService"</span></span></span><br><span class=line><span class=tag>        <span class=attr>jcache:cache-name</span>=<span class=string>"checking.account"</span>></span>l</span><br><span class=line>    <span class=comment>&LT!-- other dependencies here... --></span></span><br><span class=line><span class=tag>&LT/<span class=name>bean</span>></span></span><br></pre></table></figure> <p>然后，当解析<code>'jcache:cache-name'</code>属性时，我们可以创建另一个<code>BeanDefinition</code>。然后，此<code>BeanDefinition</code>为我们初始化命名的 JCache。我们还可以为<code>'checkingAccountService'</code>修改现有的<code>BeanDefinition</code>，以便它依赖于此新的 JCache 初始化<code>BeanDefinition</code>。以下清单显示了我们的<code>JCacheInitializer</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.foo;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">JCacheInitializer</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">JCacheInitializer</span><span class=params>(String name)</span> {</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">initialize</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// lots of JCache API calls to initialize the named cache...</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>现在我们可以进入自定义扩展了。首先，我们需要编写描述自定义属性的 XSD 架构，如下所示：</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span> standalone=<span class=string>"no"</span>?></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>xsd:schema</span> <span class=attr>xmlns</span>=<span class=string>"http://www.foo.com/schema/jcache"</span></span></span><br><span class=line><span class=tag>        <span class=attr>xmlns:xsd</span>=<span class=string>"http://www.w3.org/2001/XMLSchema"</span></span></span><br><span class=line><span class=tag>        <span class=attr>targetNamespace</span>=<span class=string>"http://www.foo.com/schema/jcache"</span></span></span><br><span class=line><span class=tag>        <span class=attr>elementFormDefault</span>=<span class=string>"qualified"</span>></span></span><br><span class=line></span><br><span class=line>    <span class=tag><<span class=name>xsd:attribute</span> <span class=attr>name</span>=<span class=string>"cache-name"</span> <span class=attr>type</span>=<span class=string>"xsd:string"</span>/></span></span><br><span class=line></span><br><span class=line><span class=tag>&LT/<span class=name>xsd:schema</span>></span></span><br></pre></table></figure> <p>接下来，我们需要创建关联的<code>NamespaceHandler</code>，如下所示：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.foo;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.xml.NamespaceHandlerSupport;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">JCacheNalmespaceHandler</span> <span class=keyword>extends</span> <span class="title class_">NamespaceHandlerSupport</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">init</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>super</span>.registerBeanDefinitionDecoratorForAttribute(<span class=string>"cache-name"</span>,</span><br><span class=line>            <span class=keyword>new</span> <span class="title class_">JCacheInitializingBeanDefinitionDecorator</span>());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>接下来，我们需要创建解析器。请注意，在这种情况下，因为我们要解析 XML 属性，所以我们编写<code>BeanDefinitionDecorator</code>而不是<code>BeanDefinitionParser</code>。以下清单显示了我们的<code>BeanDefinitionDecorator</code>：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.foo;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.config.BeanDefinitionHolder;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.support.AbstractBeanDefinition;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.support.BeanDefinitionBuilder;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.xml.BeanDefinitionDecorator;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.xml.ParserContext;</span><br><span class=line><span class=keyword>import</span> org.w3c.dom.Attr;</span><br><span class=line><span class=keyword>import</span> org.w3c.dom.Node;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.util.ArrayList;</span><br><span class=line><span class=keyword>import</span> java.util.Arrays;</span><br><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">JCacheInitializingBeanDefinitionDecorator</span> <span class=keyword>implements</span> <span class="title class_">BeanDefinitionDecorator</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>final</span> String[] EMPTY_STRING_ARRAY = <span class=keyword>new</span> <span class="title class_">String</span>[<span class=number>0</span>];</span><br><span class=line>    </span><br><span class=line>    <span class=keyword>public</span> BeanDefinitionHolder <span class="title function_">decorate</span><span class=params>(Node source, BeanDefinitionHolder holder, ParserContext ctx)</span> {</span><br><span class=line>        <span class=type>String</span> <span class=variable>initializerBeanName</span> <span class=operator>=</span> registerJCacheInitializer(source, ctx);</span><br><span class=line>        createDependencyOnJCacheInitializer(holder, initializerBeanName);</span><br><span class=line>        <span class=keyword>return</span> holder;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">createDependencyOnJCacheInitializer</span><span class=params>(BeanDefinitionHolder holder,String initializerBeanName)</span> {</span><br><span class=line>        <span class=type>AbstractBeanDefinition</span> <span class=variable>definition</span> <span class=operator>=</span> ((AbstractBeanDefinition) holder.getBeanDefinition());</span><br><span class=line>        String[] dependsOn = definition.getDependsOn();</span><br><span class=line>        <span class=keyword>if</span> (dependsOn == <span class=literal>null</span>) {</span><br><span class=line>            dependsOn = <span class=keyword>new</span> <span class="title class_">String</span>[]{initializerBeanName};</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=type>List</span> <span class=variable>dependencies</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ArrayList</span>(Arrays.asList(dependsOn));</span><br><span class=line>            dependencies.add(initializerBeanName);</span><br><span class=line>            dependsOn = (String[]) dependencies.toArray(EMPTY_STRING_ARRAY);</span><br><span class=line>        }</span><br><span class=line>        definition.setDependsOn(dependsOn);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> String <span class="title function_">registerJCacheInitializer</span><span class=params>(Node source, ParserContext ctx)</span> {</span><br><span class=line>        <span class=type>String</span> <span class=variable>cacheName</span> <span class=operator>=</span> ((Attr) source).getValue();</span><br><span class=line>        <span class=type>String</span> <span class=variable>beanName</span> <span class=operator>=</span> cacheName + <span class=string>"-initializer"</span>;</span><br><span class=line>        <span class=keyword>if</span> (!ctx.getRegistry().containsBeanDefinition(beanName)) {</span><br><span class=line>            <span class=type>BeanDefinitionBuilder</span> <span class=variable>initializer</span> <span class=operator>=</span> BeanDefinitionBuilder.rootBeanDefinition(JCacheInitializer.class);</span><br><span class=line>            initializer.addConstructorArg(cacheName);</span><br><span class=line>            ctx.getRegistry().registerBeanDefinition(beanName, initializer.getBeanDefinition());</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> beanName;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <p>最后，我们需要通过修改<code>META-INF/spring.handlers</code>和<code>META-INF/spring.schemas</code>文件，在 Spring XML 基础结构中注册各种工件，如下所示：</p> <figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_"># </span><span class=language-bash><span class=keyword>in</span> <span class=string>'META-INF/spring.handlers'</span></span></span><br><span class=line>http\://www.foo.com/schema/jcache=com.foo.JCacheNamespaceHandler</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash><span class=keyword>in</span> <span class=string>'META-INF/spring.schemas'</span></span></span><br><span class=line>http\://www.foo.com/schema/jcache/jcache.xsd=com/foo/jcache.xsd</span><br></pre></table></figure> <footer class=post-footer><div class=post-eof></div></footer> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/SpringMVC/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/SpringMVC/ itemprop=url>Spring系列-SpringMVC</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-04 15:45:18" datetime=2023-10-04T15:45:18+08:00 itemprop=dateModified>2023-10-04</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Spring/ itemprop=url rel=index><span itemprop=name>Spring</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、前言><a class=headerlink href=#1、前言 title=1、前言></a>1、前言</h1><h2 id=1-1、Java-Web组件><a title="1.1、Java Web组件" class=headerlink href=#1-1、Java-Web组件></a>1.1、Java Web组件</h2><p>Java中的web框架都是基于Java Web基础组件来实现。这些基础组件如下：<ul><li><p><strong>Servlet</strong>：服务端小程序，负责<strong>接收请求并响应</strong>。</p><li><p><strong>Filter</strong>：过滤器，负责<strong>对请求进行过滤</strong>。</p><li><p><strong>Listener</strong>：监听器，负责<strong>监听域对象的创建、属性变化</strong>。</p></ul><h2 id=1-2、Servlet四大作用域><a class=headerlink href=#1-2、Servlet四大作用域 title=1.2、Servlet四大作用域></a>1.2、Servlet四大作用域</h2><table><thead><tr><th align=center><th align=center>生命周期<th align=center>作用范围<th align=center>作用<tbody><tr><td align=center><strong>application</strong><td align=center>当Web应用被加载到容器中时创建代表整个web应用的application对象，当服务器关闭或Web应用被移除时，application对象也会被销毁。<td align=center>整个web应用。<td align=center>存储公共数据。<tr><td align=center><strong>session</strong><td align=center>第一次调用request.getSession()方法时，服务器会检查是否已经有对应的session，如果没有则在内存中创建一个session并返回。<td align=center>一次会话。<td align=center>保存登录用户、购物车等信息。<tr><td align=center><strong>request</strong><td align=center>service方法调用前由服务器创建，传入service方法。整个请求结束，request生命结束。<td align=center>整个请求URL中。<td align=center>整个请求url中共享数据。参数可以放在Request域中带过去。<tr><td align=center><strong>pageContext</strong><td align=center>请求时开始，响应结束时销毁。<td align=center>整个页面，四大作用域中最小的一个。<td align=center></table><h1 id=2、基础知识><a class=headerlink href=#2、基础知识 title=2、基础知识></a>2、基础知识</h1><h2 id=2-1、SpringMVC定义><a class=headerlink href=#2-1、SpringMVC定义 title=2.1、SpringMVC定义></a>2.1、SpringMVC定义</h2><p><strong>SpringMVC 是 Spring 3.0 发布的一个基于Spring的MVC轻量级框架。使用DispatcherServlet作为前端控制器，其内部提供了处理器映射器、处理器适配器、视图解析器等组件，可以简化开发。</strong><h2 id=2-2、DispatcherServlet><a class=headerlink href=#2-2、DispatcherServlet title=2.2、DispatcherServlet></a>2.2、DispatcherServlet</h2><p><strong>DispatcherServlet 是 SpringMVC 的入口，本质是一个Servlet，配置了load-on-startup时，会在服务器启动时完成创建和初始化操作，每次请求都会执行service方法</strong>。<p>DispatcherServlet 初始化主要做了两件事：<strong>创建一个Spring MVC容器、注册了 SpringMVC 九大组件</strong>。<h2 id=2-3、转发和重定向><a class=headerlink href=#2-3、转发和重定向 title=2.3、转发和重定向></a>2.3、转发和重定向</h2><h3 id=2-3-1、语法特点><a class=headerlink href=#2-3-1、语法特点 title=2.3.1、语法特点></a>2.3.1、语法特点</h3><p><strong>（1）转发</strong><p>转发语法：<code>return "forward:/index.jsp";</code>；<p>特点：浏览器中的请求地址不会变。<p><strong>（2）重定向</strong><p>重定向语法：<code>return "redirect:/index.jsp";</code>；<p>特点：浏览器中的请求地址会变为转发后的地址。<h1 id=3、快速入门><a class=headerlink href=#3、快速入门 title=3、快速入门></a>3、快速入门</h1><h2 id=3-1、环境准备><a class=headerlink href=#3-1、环境准备 title=3.1、环境准备></a>3.1、环境准备</h2><p>导入<code>spring-webbmvc</code>依赖。<h2 id=3-2、基于XML实现><a class=headerlink href=#3-2、基于XML实现 title=3.2、基于XML实现></a>3.2、基于XML实现</h2><p>web.xml文件内容：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!--配置SpringMVC--></span></span><br><span class=line><span class=tag><<span class=name>servlet</span>></span></span><br><span class=line>    <span class=tag><<span class=name>servlet-name</span>></span>springmvc<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>    <span class=tag><<span class=name>servlet-class</span>></span>org.springframework.web.servlet.DispatcherServlet<span class=tag>&LT/<span class=name>servlet-class</span>></span></span><br><span class=line>    <span class=tag><<span class=name>init-param</span>></span></span><br><span class=line>        <span class=tag><<span class=name>param-name</span>></span>contextConfigLocation<span class=tag>&LT/<span class=name>param-name</span>></span></span><br><span class=line>        <span class=tag><<span class=name>param-value</span>></span>classpath:springmvc.xml<span class=tag>&LT/<span class=name>param-value</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>init-param</span>></span></span><br><span class=line>    <span class=tag><<span class=name>load-on-startup</span>></span>1<span class=tag>&LT/<span class=name>load-on-startup</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet</span>></span></span><br><span class=line><span class=tag><<span class=name>servlet-mapping</span>></span></span><br><span class=line>    <span class=tag><<span class=name>servlet-name</span>></span>springmvc<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>    <span class=tag><<span class=name>url-pattern</span>></span>/<span class=tag>&LT/<span class=name>url-pattern</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet-mapping</span>></span></span><br></pre></table></figure><p>spring-mvc.xml文件内容：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!--扫描控制器组件，并将之放入sring mvc容器中--></span></span><br><span class=line><span class=tag><<span class=name>context:component-scan</span> <span class=attr>base-package</span>=<span class=string>"cn.shh.ssm.template.controller"</span>/></span></span><br><span class=line></span><br><span class=line><span class=comment>&LT!--</span></span><br><span class=line><span class=comment>    开启注解驱动。</span></span><br><span class=line><span class=comment>    作用：请求首先由DisptcherServlet处理，无法处理时再交给普通的Servlet来处理。</span></span><br><span class=line><span class=comment>--></span></span><br><span class=line><span class=tag><<span class=name>mvc:annotation-driven</span>/></span></span><br><span class=line></span><br><span class=line><span class=comment>&LT!--</span></span><br><span class=line><span class=comment>    配置默认的servlet处理器。</span></span><br><span class=line><span class=comment>    作用：没有DispatcherServlet时，所有请求都会被当前处理器处理，但却处理不了，</span></span><br><span class=line><span class=comment>         故一般配合DispatcherServlet来一起处理（配置&LTmvc:annotation-driven/>即可）。</span></span><br><span class=line><span class=comment>--></span></span><br><span class=line><span class=tag><<span class=name>mvc:default-servlet-handler</span>/></span></span><br></pre></table></figure><p>到此，配置完成。<h2 id=3-3、基于注解实现><a class=headerlink href=#3-3、基于注解实现 title=3.3、基于注解实现></a>3.3、基于注解实现</h2><h3 id=3-3-1、原理解析><a class=headerlink href=#3-3-1、原理解析 title=3.3.1、原理解析></a>3.3.1、原理解析</h3><p><strong>（1）替换<code>&LTmvc:annotation-driven/></code>和<code>&LTmvc:default-servlet-handler/></code></strong><p><code>&LTmvc:annotation-driven/></code>和<code>&LTmvc:default-servlet-handler/></code>两个标签可以被一个注解<code>@EnableWebMvc</code>替换。<p>该注解导入了一个类<code>DelegatingWebMvcConfiguration</code>，该类中有一个方法<code>setConfigurers(List&LTWebMvcConfigurer> configs)</code>可以实现添加自定义配置。只需实现WebMvcConfigurer接口并实现相关方法，然后在方法中编写自定义配置逻辑即可，比如添加自定义拦截器、配置默认的ServletHandling等。此外，该类继承了类<code>WebMvcConfigurationSupport</code>，类<code>WebMvcConfigurationSupport</code>的作用等同于标签<code>&LTmvc:annotation-driven/></code>。<p><strong>（2）替换spring-mvc.xml文件</strong><p>起初，通过在web.xml中配置参数属性<code>contextConfigLocation</code>指定spring.xml文件来实现spring mvc配置的加载。<p>现在我们要替换这种形式，选择通过一个实现了接口<code>AnnotationConfigWebApplicationContext</code>的Java类来实现Spring mvc配置的加载，方法与起初类似，在web.xml文件中通过参数属性<code>contextClass</code>来指定这个Java类即可。<p>优化的结果如下：<p>web.xml文件：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>servlet</span>></span></span><br><span class=line>    <span class=tag><<span class=name>servlet-name</span>></span>springmvc<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>    <span class=tag><<span class=name>servlet-class</span>></span>org.springframework.web.servlet.DispatcherServlet<span class=tag>&LT/<span class=name>servlet-class</span>></span></span><br><span class=line>    <span class=comment>&LT!--&LTinit-param></span></span><br><span class=line><span class=comment>            &LTparam-name>contextConfigLocation&LT/param-name></span></span><br><span class=line><span class=comment>            &LTparam-value>classpath:springmvc.xml&LT/param-value></span></span><br><span class=line><span class=comment>        &LT/init-param>--></span></span><br><span class=line>    <span class=tag><<span class=name>init-param</span>></span></span><br><span class=line>        <span class=tag><<span class=name>param-name</span>></span>contextClass<span class=tag>&LT/<span class=name>param-name</span>></span></span><br><span class=line>        <span class=tag><<span class=name>param-value</span>></span>cn.shh.ssm.template.config.MyAnnotationConfigWebApplicationContext<span class=tag>&LT/<span class=name>param-value</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>init-param</span>></span></span><br><span class=line>    <span class=tag><<span class=name>load-on-startup</span>></span>1<span class=tag>&LT/<span class=name>load-on-startup</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet</span>></span></span><br><span class=line><span class=tag><<span class=name>servlet-mapping</span>></span></span><br><span class=line>    <span class=tag><<span class=name>servlet-name</span>></span>springmvc<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>    <span class=tag><<span class=name>url-pattern</span>></span>/<span class=tag>&LT/<span class=name>url-pattern</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet-mapping</span>></span></span><br></pre></table></figure><p>SpringMVC配置类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=meta>@ComponentScan("cn.shh.ssm.template.controller")</span></span><br><span class=line><span class=meta>@EnableWebMvc</span></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SpringMvcConfig</span> {</span><br><span class=line>    <span class=comment>//...</span></span><br><span class=line>}</span><br></pre></table></figure><p>注册SpringMVC配置类的工具类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyAnnotationConfigWebApplicationContext</span> <span class=keyword>extends</span> <span class="title class_">AnnotationConfigWebApplicationContext</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MyAnnotationConfigWebApplicationContext</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>super</span>.register(SpringMvcConfig.class);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>如上配置实现了从加载配置文件到加载配置类的转变，但有一点要注意，那就是web.xml文件还没有舍弃，依然存在。<p>要想舍弃web.xml文件，做到彻底的全注解开发，这需要Sevlet 3.0技术的支持。<p><strong>（3）借助 Servlet 3.0 来舍弃 web.xml 文件</strong><p>servlet 3.0中提供了一个接口<code>javax.servlet.ServletContainerInitialize</code>，实现该接口，并在类加载路径的<code>META-INF/services</code>目录下创建一个名为<code>javax.servlet.ServletContainerInitializer</code>的文件，文件内容就是该接口实现类的全类名。这样，web容器启动时就会执行这个初始化器来做一些初始化工作。<p>基于该接口，Spring提供了一个该接口的实现<code>SpringServletContainerInitializer</code>，该实现会查找<code>WebApplicationInitializer</code>的实现类，而Spring提供了一个<code>WebApplicationInitializer</code>的基础实现类<code>AbstractAnnotationConfigDispatcherServletInitializer</code>，我们可以通过继承该基础实现类，来指定Spring和SpringMVC配置的入口，进而实现全注解开发。<h3 id=3-3-2、代码实现><a class=headerlink href=#3-3-2、代码实现 title=3.3.2、代码实现></a>3.3.2、代码实现</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br></pre><td class=code><pre><span class=line><span class=meta>@Import({JDBCConfig.class, MyBatisConfig.class})</span></span><br><span class=line><span class=meta>@ComponentScan(basePackages = {"cn.shh.ssm.template.service"})</span></span><br><span class=line><span class=meta>@EnableTransactionManagement</span></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SpringConfig</span> {</span><br><span class=line>    <span class=comment>//...</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line>---</span><br><span class=line></span><br><span class=line><span class=meta>@ComponentScan("cn.shh.ssm.template.controller")</span></span><br><span class=line><span class=meta>@EnableWebMvc</span></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SpringMVCConfig</span> {</span><br><span class=line>    <span class=comment>//...</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line>---</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ServletConfig</span> <span class=keyword>extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> Class&LT?>[] getRootConfigClasses() {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">Class</span>[]{SpringConfig.class};</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> Class&LT?>[] getServletConfigClasses() {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">Class</span>[]{SpringMVCConfig.class};</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> String[] getServletMappings() {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">String</span>[]{<span class=string>"/"</span>};</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h1 id=请求和响应><a class=headerlink href=#请求和响应 title=请求和响应></a>请求和响应</h1><h2 id=1-1、数据传输><a class=headerlink href=#1-1、数据传输 title=1.1、数据传输></a>1.1、数据传输</h2><h3 id=1-1-1、前端数据传后端><a class=headerlink href=#1-1-1、前端数据传后端 title=1.1.1、前端数据传后端></a>1.1.1、前端数据传后端</h3><h4 id=1-1-1-1、普通数据类型><a class=headerlink href=#1-1-1-1、普通数据类型 title=1.1.1.1、普通数据类型></a>1.1.1.1、普通数据类型</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testBaseDT</span><span class=params>(String name, <span class=type>int</span> age)</span>{</span><br><span class=line>    System.out.println(name + <span class=string>"/"</span> + age);</span><br><span class=line>}</span><br></pre></table></figure><h4 id=1-1-1-2、实体类类型><a class=headerlink href=#1-1-1-2、实体类类型 title=1.1.1.2、实体类类型></a>1.1.1.2、实体类类型</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">User</span>{</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> Integer age;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testInstanceDT</span><span class=params>(User user)</span>{</span><br><span class=line>    System.out.println(user.getName() + <span class=string>"/"</span> + user.getAge());</span><br><span class=line>}</span><br></pre></table></figure><h4 id=1-1-1-3、数组类型><a class=headerlink href=#1-1-1-3、数组类型 title=1.1.1.3、数组类型></a>1.1.1.3、数组类型</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// GET请求URL</span></span><br><span class=line>http:<span class=comment>//localhost:8090/test/dt?like=敲代码&like=看电影&like=旅游</span></span><br><span class=line><span class=comment>// java代码</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testArrayDT</span><span class=params>(String[] like)</span>{</span><br><span class=line>    <span class=keyword>for</span>(String k : like){System.out.println(k);}</span><br><span class=line>}</span><br></pre></table></figure><h4 id=1-1-1-4、集合类型><a class=headerlink href=#1-1-1-4、集合类型 title=1.1.1.4、集合类型></a>1.1.1.4、集合类型</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// GET请求URL</span></span><br><span class=line>http:<span class=comment>//localhost:8090/test/dt?like=敲代码&like=看电影&like=旅游</span></span><br><span class=line><span class=comment>// Java代码</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testArrayDT</span><span class=params>(<span class=meta>@RequestParam</span> List&LTString> like)</span>{</span><br><span class=line>    <span class=keyword>for</span>(String k : like){System.out.println(k);}</span><br><span class=line>}</span><br></pre></table></figure><h4 id=1-1-1-5、JSON数据><a class=headerlink href=#1-1-1-5、JSON数据 title=1.1.1.5、JSON数据></a>1.1.1.5、JSON数据</h4><p><strong>1）集合类型</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment>// GET请求URL</span></span><br><span class=line>http:<span class=comment>//localhost:8090/test/dt</span></span><br><span class=line><span class=comment>// 请求体</span></span><br><span class=line>[<span class=string>"敲代码"</span>, <span class=string>"看电影"</span>, <span class=string>"旅游"</span>]</span><br><span class=line></span><br><span class=line><span class=comment>// Java代码</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testArrayDT</span><span class=params>(<span class=meta>@RequestBody</span> List&LTString> like)</span>{</span><br><span class=line>    <span class=keyword>for</span>(String k : like){System.out.println(k);}</span><br><span class=line>}</span><br></pre></table></figure><p><strong>2）实体类型</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>// 请求体</span></span><br><span class=line>{<span class=string>"name"</span>:<span class=string>"张三"</span>, <span class=string>"age"</span>:<span class=string>"18"</span>}</span><br><span class=line></span><br><span class=line><span class=comment>// Java代码</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testInstanceDT</span><span class=params>(<span class=meta>@RequestBody</span> User user)</span>{</span><br><span class=line>    System.out.println(user.getName() + <span class=string>"/"</span> + user.getAge());</span><br><span class=line>}</span><br></pre></table></figure><p><strong>3）集合+实体</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>// 请求体</span></span><br><span class=line>[{<span class=string>"name"</span>:<span class=string>"张三"</span>, <span class=string>"age"</span>:<span class=string>"18"</span>}, {<span class=string>"name"</span>:<span class=string>"李四"</span>, <span class=string>"age"</span>:<span class=string>"19"</span>}]</span><br><span class=line></span><br><span class=line><span class=comment>// Java代码</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testArrayDT</span><span class=params>(<span class=meta>@RequestBody</span> List&LTUser> users)</span>{</span><br><span class=line>    <span class=keyword>for</span>(String k : like){System.out.println(k);}</span><br><span class=line>}</span><br></pre></table></figure><h4 id=1-1-1-6、日期类型><a class=headerlink href=#1-1-1-6、日期类型 title=1.1.1.6、日期类型></a>1.1.1.6、日期类型</h4><p><strong>1）类型1：2022/10/01</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment>// 请求Uri</span></span><br><span class=line>http:<span class=comment>//localhost:8090/test?date=2022/10/01</span></span><br><span class=line></span><br><span class=line><span class=comment>// java代码</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testData</span><span class=params>(Date date)</span>{System.out.println(<span class=string>"date: "</span> + data);}</span><br></pre></table></figure><p><strong>2）类型2：2022-10-01</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>// 请求Uri</span></span><br><span class=line>http:<span class=comment>//localhost:8090/test?date=2022-10-01</span></span><br><span class=line></span><br><span class=line><span class=comment>// java代码</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testData</span><span class=params>(<span class=meta>@DateTimeFormat(pattern="yyyy-MM-dd")</span> Date date)</span>{</span><br><span class=line>    System.out.println(<span class=string>"date: "</span> + data);</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-1-2、后端数据传前端><a class=headerlink href=#1-1-2、后端数据传前端 title=1.1.2、后端数据传前端></a>1.1.2、后端数据传前端</h3><h4 id=1-1-2-1、Servlet-API><a title="1.1.2.1、Servlet API" class=headerlink href=#1-1-2-1、Servlet-API></a>1.1.2.1、Servlet API</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>HttpServletRequest.setAttribute(<span class=string>"name"</span>, <span class=string>"张三"</span>);</span><br></pre></table></figure><h4 id=1-1-2-2、ModelAndView><a class=headerlink href=#1-1-2-2、ModelAndView title=1.1.2.2、ModelAndView></a>1.1.2.2、ModelAndView</h4><p>后端代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=type>ModelAndView</span> <span class=variable>mav</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ModelAndView</span>();</span><br><span class=line>mav.addObject(<span class=string>"name"</span>, <span class=string>"张三"</span>);</span><br><span class=line>mav.setViewName(<span class=string>"index"</span>);</span><br><span class=line><span class=keyword>return</span> mav;</span><br></pre></table></figure><p>前端代码：<figure class="highlight html"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>p</span> <span class=attr>th:text</span>=<span class=string>"${name}"</span>></span><span class=tag>&LT/<span class=name>p</span>></span></span><br></pre></table></figure><h4 id=1-1-2-3、Model><a class=headerlink href=#1-1-2-3、Model title=1.1.2.3、Model></a>1.1.2.3、Model</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> String <span class="title function_">testModel</span><span class=params>(Model model)</span>{</span><br><span class=line>    model.addAttribute(<span class=string>"name"</span>, <span class=string>"Model"</span>);</span><br><span class=line>    <span class=keyword>return</span> <span class=string>"index"</span>;</span><br><span class=line>}</span><br></pre></table></figure><h4 id=1-1-2-4、ModelMap><a class=headerlink href=#1-1-2-4、ModelMap title=1.1.2.4、ModelMap></a>1.1.2.4、ModelMap</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> String <span class="title function_">testModelMap</span><span class=params>(ModelMap modelMap)</span>{</span><br><span class=line>    modelMap.addAttribute(<span class=string>"name"</span>, <span class=string>"ModelMap"</span>);</span><br><span class=line>    <span class=keyword>return</span> <span class=string>"index"</span>;</span><br><span class=line>}</span><br></pre></table></figure><h4 id=1-1-2-5、Map><a class=headerlink href=#1-1-2-5、Map title=1.1.2.5、Map></a>1.1.2.5、Map</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> String <span class="title function_">testMap</span><span class=params>(Map&LTString, Object> map)</span>{</span><br><span class=line>    map.put(<span class=string>"name"</span>, <span class=string>"Map"</span>);</span><br><span class=line>    <span class=keyword>return</span> <span class=string>"index"</span>;</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>Model、ModelMap底层都使用BindingAwareModelMap来创建。</blockquote><h4 id=1-1-2-6、Session域><a class=headerlink href=#1-1-2-6、Session域 title=1.1.2.6、Session域></a>1.1.2.6、Session域</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> String <span class="title function_">testSession</span><span class=params>(HttpSession session)</span>{</span><br><span class=line>    session.setAttribute(<span class=string>"name"</span>, <span class=string>"testSession"</span>);</span><br><span class=line>    <span class=keyword>return</span> <span class=string>"index"</span>;</span><br><span class=line>}</span><br></pre></table></figure><h4 id=1-1-2-7、Application域><a class=headerlink href=#1-1-2-7、Application域 title=1.1.2.7、Application域></a>1.1.2.7、Application域</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> String <span class="title function_">testApplication</span><span class=params>(HttpSession session)</span>{</span><br><span class=line>    <span class=type>ServletContext</span> <span class=variable>context</span> <span class=operator>=</span> session.getServletContext();</span><br><span class=line>    context.setAttribute(<span class=string>"name"</span>, <span class=string>"testApplication"</span>);</span><br><span class=line>    <span class=keyword>return</span> <span class=string>"index"</span>;</span><br><span class=line>}</span><br></pre></table></figure><h2 id=1-2、HTTP请求和响应><a class=headerlink href=#1-2、HTTP请求和响应 title=1.2、HTTP请求和响应></a>1.2、HTTP请求和响应</h2><h3 id=1-2-1、概述><a class=headerlink href=#1-2-1、概述 title=1.2.1、概述></a>1.2.1、概述</h3><p><strong>（1）一个http请求包含以下几个组成部分</strong>：<ul><li><p>请求行：包含请求方式、请求地址、协议版本三项。</p> <figure class="highlight http"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>POST /index.php　HTTP/1.1</span><br></pre></table></figure><li><p>请求头</p><li><p>空行</p><li><p>请求数据</p></ul><p><strong>（2）一个http响应包含以下几个组成部分</strong>：<ul><li><p>状态行：包含协议版本、状态码、响应信息三项。</p> <figure class="highlight http"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=meta>HTTP/1.1</span> <span class=number>200</span> OK</span><br></pre></table></figure><li><p>响应头</p><li><p>空行</p><li><p>响应数据</p></ul><h3 id=1-2-2、获取请求头数据><a class=headerlink href=#1-2-2、获取请求头数据 title=1.2.2、获取请求头数据></a>1.2.2、获取请求头数据</h3><p><strong>（1）获取请求头中的所有数据</strong><p>使用注解<code>@RequestHeader</code>修饰控制器方法的形参即可。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta>@GetMapping("/m1")</span></span><br><span class=line><span class=keyword>public</span> String <span class="title function_">m1</span><span class=params>(<span class=meta>@RequestHeader</span> Map&LTString> map)</span>{}</span><br></pre></table></figure><p><strong>（2）获取Cookie</strong><p>使用注解<code>@CookieValue</code>修饰控制器方法的形参即可。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta>@GetMapping("/m1")</span></span><br><span class=line><span class=keyword>public</span> String <span class="title function_">m1</span><span class=params>(<span class=meta>@CookieValue(value="JSESSIONID", default="")</span> String jsessionId)</span>{}</span><br></pre></table></figure><h2 id=1-3、HTTP状态码><a class=headerlink href=#1-3、HTTP状态码 title=1.3、HTTP状态码></a>1.3、HTTP状态码</h2><h3 id=1-3-1、1xx：信息状态码><a class=headerlink href=#1-3-1、1xx：信息状态码 title=1.3.1、1xx：信息状态码></a>1.3.1、1xx：信息状态码</h3><p>1开头的状态码表示 <strong>请求已经被接收且服务器正在处理</strong>。<p>常见的1开头的状态码如下：<ul><li>100：<strong>服务器已经收到请求的初始部分，客户端应该继续发送剩余的部分请求</strong>。<li>101：<strong>服务器已经理解了客户端的请求，正在切换到不同的协议</strong>。<li>102：<strong>服务器正在处理请求，但需要更长的时间</strong>。</ul><h3 id=1-3-2、2xxx：成功状态码><a class=headerlink href=#1-3-2、2xxx：成功状态码 title=1.3.2、2xxx：成功状态码></a>1.3.2、2xxx：成功状态码</h3><p>2开头的状态码表示 <strong>请求已经被服务器接收、理解和处理</strong>。<p>常见状态码如下：<ul><li>200：<strong>请求已成功</strong>。<li>201：<strong>请求已经成功，且在服务器上创建了新的资源</strong>。<li>202：<strong>已接收</strong>。<li>203：非权威性信息。<li>204：<strong>服务器成功处理了请求，但没有返回任何内容</strong>。<li>205：充值内容。<li>206：部分内容。表明已部分下载了一个文件，可以续传损坏的下载或者将下载拆分为多个并发的流。<li>207：多状态（WebDAV）。此消息之前应该还有一条XML消息，其中可能包含几个单独的响应代码，具体取决于发出了多少个子请求。</ul><h3 id=1-3-3、3xxx：重定向状态码><a class=headerlink href=#1-3-3、3xxx：重定向状态码 title=1.3.3、3xxx：重定向状态码></a>1.3.3、3xxx：重定向状态码</h3><p>3开头的状态码表示 <strong>客户端需要采取附加操作才能完成请求</strong>。<p>常见状态码如下：<ul><li>301：<strong>被请求的资源已经永久移动到了新位置</strong>。<li>302：<strong>被请求的资源临时移动到了新位置</strong>。对于基于表单的身份验证，此消息通常表示为“对象已移动”。请求的资源临时驻留在不同的URI。由于重定向有时可能会改变，客户端将来在请求时应该继续使用 RequestURI。只有在 CacheControl 或 Expires 标题字段中指示，此响应才能够缓存。<li>304：<strong>资源未修改，可以使用缓存的版本</strong>。客户端请求的文档已在其缓存中，文档自缓存以来尚未被修改过。客户端使用文档的缓存副本，而不从服务器下载文档。<li>307：<strong>临时重定向</strong>。</ul><h3 id=1-3-4、4xxx：客户端错误><a class=headerlink href=#1-3-4、4xxx：客户端错误 title=1.3.4、4xxx：客户端错误></a>1.3.4、4xxx：客户端错误</h3><p>4开头的状态码表示 <strong>客户端发生错误导致服务器无法处理请求</strong>。<p>常见状态码如下：<ul><li>400：<strong>请求无效或错误，服务器无法理解请求的语法</strong>。<li>401：<strong>请求需要身份验证</strong>。IIS 定义了几个不同的401错误，用于指示更为具体的错误原因。这些具体的错误代码在浏览器中显示，但不在 IIS 日志中显示。<li>403：<strong>服务器拒绝请求</strong>。可以理解为没有权限访问此网站，服务器能够收到请求但拒绝提供服务。IIS 定义了几个不同的403错误，用于指示更为具体的错误原因。<li>404：<strong>没有找到请求的资源</strong>。例如，访问网站中不存在的页面，或者原有页面被移走或删除，则可能会出现该状态码。IIS 定义了几个不同的404错误，用于指示更为具体的错误原因。<li>405：用来访问本页面的 HTTP 谓词不被允许（方法不被允许）。当客户端向运行 IIS 的服务器发送一个 HTTP 请求，并且该请求包含服务器无法识别的 HTTP 动词时，就会发生此错误。若要解决此问题，请确保客户端的请求使用与 HTTP rfc 兼容的 HTTP 动词。<li>406：客户端浏览器不接受所请求页面的 MIME 类型<li>407：要求进行代理身份验证<li>412：前提条件失败<li>413：请求实体太大<li>414：请求URI太长<li>415：不支持的媒体类型<li>416：无法满足请求的范围<li>417：执行失败<li>423：锁定的错误</ul><p><strong>401 状态码：</strong><ul><li>401.1：用户名或密码无效导致登陆失败。<li>401.2：服务器配置导致登陆失败。<li>401.3：由于 ACL 对资源的限制而未获得授权。表示存在 NTFS 权限问题。即使您对试图访问的文件具备相应的权限，也可能发生此错误。例如，如果 IUSR 帐户无权访问 C:WinntSystem32Inetsrv 目录，您会看到这个错误。<li>401.4：筛选器授权失败<li>401.5：ISAPI/CGI 应用程序授权失败<li>401.7：由 Web 服务器上的 URL 验证策略拒绝访问。这个错误代码为 IIS 6.0 所专用。</ul><p><strong>403 状态码：</strong><ul><li>403.1：执行访问被禁止。可能原因：<ul><li>您没有足够的执行许可。例如，如果试图访问的 ASP 页所在的目录权限设为 “无”，或者，试图执行的 CGI 脚本所在的目录权限为 “只允许脚本”，将出现此错误消息。若要修改执行权限，请在 Microsoft 管理控制台（MMC）中右击目录，然后依次单击 “属性” 和 “目录” 选项卡，确保为试图访问的内容设置适当的执行权限。<li>您没有将试图执行的文件类型的脚本映射设置为识别所使用的谓词（例如，GET 或 POST）。若要验证这一点，请在 Microsoft 管理控制台中右键单击目录，依次单击 “属性”、“目录” 选项卡和 “配置”，然后验证相应文件类型的脚本映射是否设置为允许所使用的谓词。</ul><li>403.2：读访问被禁止。验证是否已将 IIS 设置为允许对目录进行读访问。另外，如果您正在使用默认文件，请验证该文件是否存在。<li>403.3：写访问被禁止。验证 IIS 权限和 NTFS 权限是否已设置以便向该目录授予写访问权。<li>403.4：要求 SSL。禁用要求安全通道选项，或使用 HTTPS 代替 HTTP 来访问该页面。<li>403.5：要求 SSL 128。禁用要求128位加密选项，或使用支持128位加密的浏览器以查看该页面。<li>403.6：IP 地址被拒绝。您已经将服务器配置为拒绝访问您当前的 IP 地址。<li>403.7：要求客户端证书。您已经将服务器配置为要求提供证书进行客户端身份验证，但是您没有安装有效的客户端证书。<li>403.8：站点访问被拒绝。您已经为用来访问服务器的域设置了域名限制。<li>403.9：用户数过多。与该服务器连接的用户数量超过了您设置的连接限制。注意：Microsoft Windows 2000 Professional 和 Windows XP Professional 自动设置了在 IIS 上最多10个连接的限制。您无法更改此限制。<li>403.10：配置无效<li>403.11：密码更改<li>403.12：拒绝访问映射表。您要访问的页面要求提供客户端证书。但是，映射到该客户端证书的用户 ID 已经拒绝访问该文件。<li>403.13：客户端证书被吊销<li>403.14：拒绝目录列表<li>403.15：超出客户端访问许可<li>403.16：客户端证书不受信任或无效<li>403.17：客户端证书已过期或尚未生效<li>403.18：在当前的应用程序池中不能执行所请求的URL。这个错误代码为 IIS 6.0 所专用。<li>403.19：不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。<li>403.20：Passport 登录失败。这个错误代码为 IIS 6.0 所专用。</ul><p><strong>404 状态码：</strong><ul><li>404.0：没有找到文件或目录<li>404.1：无法通过请求的端口访问网站。此错误消息表明，试图访问的网站的 IP 地址不接受来自此请求所用端口的请求。<li>404.2：Web 服务扩展锁定策略阻止本请求。在 IIS 6.0 中，表示 Web 服务扩展列表中已经阻止了该请求。<li>404.3：MIME 映射策略阻止了此请求。 如果存在下列情况，将出现此问题：<ul><li>未配置请求的文件扩展名的处理程序映射。<li>没有为网站或应用程序配置相应的 MIME 类型。</ul></ul><h3 id=1-3-5、5xxx：服务器错误><a class=headerlink href=#1-3-5、5xxx：服务器错误 title=1.3.5、5xxx：服务器错误></a>1.3.5、5xxx：服务器错误</h3><p>5开头的状态码表示 <strong>服务器在处理请求时发生了错误</strong>。<p>常见状态码如下：<ul><li>500：<strong>内部服务器错误</strong>。很多服务器端错误都可能导致此错误消息。事件查看器日志包含更详细的错误原因。此外，您可以禁用友好 HTTP 错误消息以便收到详细的错误说明。IIS 定义了几个不同的500错误，用于指示更为具体的错误原因。<li>501：<strong>页眉指定了未实现的配置</strong>。<li>502：作为代理或网关的服务器从上游服务器收到了无效响应。此类错误一般与服务器本身有关（与请求无关）。IIS 定义了几个不同的502错误，用于指示更为具体的错误原因。<li>503：<strong>服务器暂时无法处理请求</strong>。<li>504：网关超时。<li>505：HTTP版本不受支持。</ul><p><strong>500状态码：</strong><ul><li>500.12：应用程序正忙于在 Web 服务器上重新启动。这表示您在 IIS 重新启动应用程序的过程中试图加载 ASP 页。刷新页面后，此消息即会消失。如果刷新页面后，此消息再次出现，可能是防病毒软件正在扫描 Global.asa 文件。<li>500.13：web服务器繁忙。<li>500.15：不允许直接请求 Global.asa。<li>500.16：UNC 授权凭据不正确。这个错误代码为 IIS 6.0 所专用。<li>500.18：无法打开 URL 授权存储库。这个错误代码为 IIS 6.0 所专用。<li>500.19：此文件的数据在元数据库中配置不正确。如果 XML 元数据库在您尝试访问的内容类型中包含无效的配置信息，您就会收到此错误。要解决此问题，请删除或更正无效的配置。此问题通常表示 ScriptMap 元数据库键中存在问题。<li>500.100：内部 ASP 错误。 如果试图加载的 ASP 页中含有错误代码，将出现此错误消息。若要获得更确切的错误消息，请禁用友好 HTTP 错误消息。默认情况下，只会在默认网站上启用此错误消息。</ul><p><strong>502 状态码：</strong><ul><li>502.1：CGI应用程序超时。<li>502.2：CGI 应用程序出错。</ul><h1 id=原理解析><a class=headerlink href=#原理解析 title=原理解析></a>原理解析</h1><h2 id=1-1、静态资源处理><a class=headerlink href=#1-1、静态资源处理 title=1.1、静态资源处理></a>1.1、静态资源处理</h2><p>静态资源的处理方式有如下几种：<ul><li>Tomcat的<code>DefaultServlet</code>；<li>Spring MVC标签<code>&LTmvc:resources /></code>；<li>Spring MVC标签<code>&LTmvc:default-servlet-handler /></code></ul><h3 id=1-1-1、DefaultServlet><a class=headerlink href=#1-1-1、DefaultServlet title=1.1.1、DefaultServlet></a>1.1.1、DefaultServlet</h3><p>如果配置了<code>DispatcherServlet</code>处理器，那么默认使用该处理器；<p>如果没有配置<code>DispatcherServlet</code>处理器，那么会使用Tomcat的<code>DefaultServlet</code>拦截并处理。<code>DefaultServlet</code>的名字是<code>default</code>，拦截路径为<code>/</code>，且具备搜索静态资源的功能，而<code>DispatcherServlet</code>默认没有该功能。<p>如果显式配置了<code>DispatcherServlet</code>，还想使用<code>DefaultServlet</code>来处理，那么可以在<code>web.xml</code>文件中添加如下配置：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- default会映射到Tomcat的DefaultServlet --></span></span><br><span class=line><span class=tag><<span class=name>servlet-mapping</span>></span></span><br><span class=line>    <span class=tag><<span class=name>servlet-name</span>></span>default<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>    <span class=tag><<span class=name>servlet-pattern</span>></span>*.html<span class=tag>&LT/<span class=name>servlet-pattern</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet-mapping</span>></span></span><br><span class=line><span class=tag><<span class=name>servlet-mapping</span>></span></span><br><span class=line>    <span class=tag><<span class=name>servlet-name</span>></span>default<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>    <span class=tag><<span class=name>servlet-pattern</span>></span>/img/*<span class=tag>&LT/<span class=name>servlet-pattern</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet-mapping</span>></span></span><br></pre></table></figure><h3 id=1-1-2、mvc-resouces><a class=headerlink href=#1-1-2、mvc-resouces title=1.1.2、mvc:resouces></a>1.1.2、mvc:resouces</h3><p>在Spring MVC配置文件中添加如下配置内容：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>mvc:resources</span> <span class=attr>mapping</span>=<span class=string>"/img/*"</span> <span class=attr>location</span>=<span class=string>"/img/*"</span> /></span></span><br></pre></table></figure><h3 id=1-1-3、mvc-default-servlet-handler><a class=headerlink href=#1-1-3、mvc-default-servlet-handler title=1.1.3、mvc:default-servlet-handler></a>1.1.3、mvc:default-servlet-handler</h3><p>在Spring MVC配置文件中添加如下配置内容：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>mvc:default-servlet-handler</span> /></span></span><br></pre></table></figure><p>该标签会向容器中注入一个<code>DefaultServletHttpRequestHandler</code>，<h2 id=1-2、DispatcherServlet初始化><a class=headerlink href=#1-2、DispatcherServlet初始化 title=1.2、DispatcherServlet初始化></a>1.2、DispatcherServlet初始化</h2><h3 id=1-2-1、初始化流程><a class=headerlink href=#1-2-1、初始化流程 title=1.2.1、初始化流程></a>1.2.1、初始化流程</h3><p>DispatcherServlet的初始化流程如下：<p><strong>（1）调用<code>HttpServletBean</code>的<code>init()</code>方法开始初始化</strong>；<p><strong>（2）调用<code>FrameworkServlet</code>的<code>initServletBean()</code>方法</strong>；<p>**（3）调用<code>FrameworkServlet</code>的<code>initWebApplicationContext()</code>方法来初始化<code>WebApplicationContext</code>**；<p>如果<code>this.webApplicationContext</code>不为null，且没有被激活时，为当前<code>webApplicationContext</code>设置父容器，并通过调用<code>AbstractApplicationContext</code>的<code>refresh</code>方法来刷新当前<code>webApplicationContext</code>。刷新完毕后会发布<code>ContextRefreshedEvent</code>事件。<p>如果<code>this.webApplicationContext</code>为null，先检查<code>ServletContext</code>中是否存在，如果也不存在，那么主动创建<code>WebApplicationContext</code>，并为该<code>WebApplicationContext</code>设置父容器，然后调用<code>AbstractApplicationContext</code>的<code>refresh</code>方法来刷新该<code>webApplicationContext</code>，同样，刷新完毕后会发布<code>ContextRefreshedEvent</code>事件。<p>如果<code>FrameworkServlet</code>没有收到<code>ContextRefreshedEvent</code>事件，那么会主动调用<code>DispatcherServlet</code>的<code>initSrategies</code>方法来初始化9大组件。如果收到了那就会基于事件通知的方式来初始化9大组件。<p><strong>（4）<code>FrameworkServlet</code>会监听<code>ContextRefreshedEvent</code>事件，然后初始化9大组件</strong><p><code>FrameworkServlet</code>的内部类<code>ContextRefreshListener</code>会监听<code>ContextRefreshedEvent</code>事件，然后调用<code>DispatcherServlet</code>的<code>initSrategies</code>方法来初始化9大组件。<h3 id=1-2-2、默认初始化组件><a class=headerlink href=#1-2-2、默认初始化组件 title=1.2.2、默认初始化组件></a>1.2.2、默认初始化组件</h3><p>默认会加载<code>DispatcherServlet.properties</code>文件，并初始化文件中已经编写的组件。如果显式配置了相关组件，那么以显式配置的为主，而不会加载和初始化默认的组件。以下是默认加载的组件：<ul><li><strong>LocaleResolver</strong><ul><li>AcceptHeaderLocaleResolver</ul><li><strong>ThemeResolver</strong><ul><li>FixedThemeResolver</ul><li><strong>HandlerMapping</strong><ul><li>BeanNameUrlHandlerMapping<li>RequestMappingHandlerMapping<li>RouterFunctionMapping</ul><li><strong>HandlerAdapter</strong><ul><li>HttpRequestHandlerAdapter<li>SimpleControllerHandlerAdapter<li>RequestMappingHandlerAdapter<li>HandlerFunctionAdapter</ul><li><strong>HandlerExceptionResolver</strong><ul><li>ExceptionHandlerExceptionResolver<li>ResponseStatusExceptionResolver<li>DefaultHandlerExceptionResolver</ul><li><strong>RequestToViewNameTranslator</strong><ul><li>DefaultRequestToViewNameTranslator</ul><li><strong>ViewResolver</strong><ul><li>InternalResourceViewResolver</ul><li><strong>FlashMapManager</strong><ul><li>SessionFlashMapManager</ul></ul><h3 id=1-2-3、mvc-default-servlet-handler><a class=headerlink href=#1-2-3、mvc-default-servlet-handler title=1.2.3、mvc:default-servlet-handler></a>1.2.3、mvc:default-servlet-handler</h3><p>该标签作用如下：<ul><li>使用<code>DefaultServletHandlerBeanDefinitionParser</code>向容器中注入<code>SimpleUrlHandlerMapping</code>。<li><code>SimpleUrlHandlerMapping</code>注入容器后，默认的<code>RequestMappingHandlerMapping</code>就不再注入。<li><code>mvc:resources</code>标签也会向容器中注入一个<code>SimpleUrlHandlerMapping</code>。<li>处理<code>@RequestMapping</code>注解需要<code>RequestMappingHandlerMapping</code>，所以以上两个标签不能解决这个问题。</ul><h3 id=1-2-4、mvc-annotation-driven><a class=headerlink href=#1-2-4、mvc-annotation-driven title=1.2.4、mvc:annotation-driven></a>1.2.4、mvc:annotation-driven</h3><p>该标签的作用如下：<ul><li>Spring 3.0.x版本会注入<code>DefaultAnnotationHandlerMapping、AnnotationMethodHandlerAdapter</code>。<li>Spring 3.1.x版本开始会注入<code>RequestMappingHandlerMapping、RequestMappingHandlerAdapter</code>。<li>会为<code>RequestMappingHandlerAdapter</code>设置消息转化器等。</ul><h2 id=1-3、-EnableWebMvc><a class=headerlink href=#1-3、-EnableWebMvc title=1.3、@EnableWebMvc></a>1.3、@EnableWebMvc</h2><p>该注解通过<code>@import</code>注解导入一个配置类<code>DelegatingWebMvcConfiguration</code>，该类继承了<code>WebMvcConfigurationSupport</code>。<p><strong>（1）<code>DelegatingWebMvcConfiguration</code>的<code>setConfigurers</code>方法会收集接口<code>WebMvcConfigurer</code>的所有实现类</strong><p>通过注解<code>Autowired</code>修饰方法<code>setConfigurers(List&LTWebMvcConfigurer> configurers)</code>来收集接口<code>WebMvcConfigurer</code>的所有实现类，这些实现类其实就是配置类，包括系统已经存在的和自定义的。<p>将这些收集到的配置类放入配置组合类<code>WebMvcConfigurerComposite</code>中，后期<code>WebMvcConfigurationSupport</code>在初始化默认组件时可以遍历这些系统配置类或自定义配置类，将我们自定义的功能应用到这些默认组件中，比如：自定义参数解析器、自定义返回值处理器、自定义消息转换器等，后期这些默认组件在工作时就会使用到我们的自定义功能来进行相关处理。<p><strong>（2）<code>WebMvcConfigurationSupport</code>会初始化多个默认组件并注入到容器中</strong>，详情见1.2.2中的内容。<p>这里以<code>RequestMappingHandlerAdapter</code>为例进行分析。<p>在创建<code>RequestMappingHandlerAdapter</code>实例并注入到容器前会对其进行初始化，比如为其设置消息转换器、参数解析器、返回值处理器等工具，使得<code>RequestMappingHandlerAdapter</code>在执行处理器方法时进行相关操作。<h2 id=1-4、HTTP请求处理流程><a class=headerlink href=#1-4、HTTP请求处理流程 title=1.4、HTTP请求处理流程></a>1.4、HTTP请求处理流程</h2><p>一个Http请求处理的流程如下：<p><strong>（1）<code>HttpServlet</code>将<code>ServletRequest、ServletResponse</code>转为<code>HttpServletRequest、HttpServletResponse</code></strong><p>在<code>HttpServlet</code>的<code>service</code>方法中将<code>ServletRequest、ServletResponse</code>转为<code>HttpServletRequest、HttpServletResponse</code>，然后根据不同的请求方式将请求转发给<code>FrameworkServlet</code><p><strong>（2）<code>FrameworkServlet</code>做一些初始化和记录后将请求转发给<code>DispatcherServlet</code></strong><p><code>FrameworkServlet</code>在方法<code>processRequest</code>中进行相关初始化和记录后将请求转发给<code>DispatcherServlet</code>的<code>doService</code>方法。<p><strong>（3）<code>DispatcherServlet</code>处理请求并发布请求处理完毕事件</strong><p>在<code>DispatcherServlet</code>的<code>doService</code>方法中对请求对象<code>HttpServletRequest</code>做一些初始化，然后调用<code>doDispatch</code>方法来处理这个请求。请求处理期间会调用拦截器的方法，请求处理完成后会发布<code>ServletRequestHandledEvent</code>事件。</div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/SpringIOC/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/SpringIOC/ itemprop=url>Spring系列-SpringIOC</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-04 11:28:57" datetime=2023-10-04T11:28:57+08:00 itemprop=dateModified>2023-10-04</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Spring/ itemprop=url rel=index><span itemprop=name>Spring</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、IOC容器><a class=headerlink href=#1、IOC容器 title=1、IOC容器></a>1、IOC容器</h1><h2 id=1-1、概述><a class=headerlink href=#1-1、概述 title=1.1、概述></a>1.1、概述</h2><p><strong>org.springframework.beans 和 org.springframework.context 是 Spring IOC 容器的基础</strong>。<p><strong>BeanFactory是IOC容器的基础类，提供了框架配置和基本功能，ApplicationContext实现并扩展了BeanFactory，提供了国际化、环境配置、资源读取、事件监听等功能</strong>。<p>Spring关于IOC的特点总结如下：<ul><li>Spring 利用Java反射实例化Bean并管理Bean之间的依赖关系。<li>基础环境下，bean的scope只能设置single、prototype两个属性值。web环境下可以设置request、session两个属性。<li>IOC容器中bean的名字取值优先级为：<strong>id属性值 > name属性值 > class类路径全名</strong>。</ul><blockquote><p>Spring发布时就可以支持XML配置，Spring 2.5支持注解配置，Spring 3.0开始支持Java类配置。<p>注解注入先于XML执行，故XML配置会覆盖注解注入。</blockquote><h2 id=1-2、BeanFactory><a class=headerlink href=#1-2、BeanFactory title=1.2、BeanFactory></a>1.2、BeanFactory</h2><p><strong>BeanFactory是Spring IOC的基础</strong>。<p>通过<code>BeanFactory</code>和<code>BeanFactoryAware</code>、<code>InitializingBean</code>、<code>DisposableBean</code>等接口可<strong>实现容器和组件间的有效交互</strong>。<p><code>BeanFactory</code>会缓存单例Bean实例，第二次获取 Bean 时将直接从缓存中获取。其原理是在<code>DefaultSingletonBeanRegistry</code>类中设计了一个单实例 Bean 缓存，该缓存基于<code>HashMap</code>实现，键就是单实例Bean的<code>beanName</code>。<h2 id=1-3、ApplicationContext><a class=headerlink href=#1-3、ApplicationContext title=1.3、ApplicationContext></a>1.3、ApplicationContext</h2><h3 id=1-3-1、简介><a class=headerlink href=#1-3-1、简介 title=1.3.1、简介></a>1.3.1、简介</h3><p><strong>org.springframework.context.ApplicationContext 接口代表Spring IOC容器，负责配置、组装、实例化 Bean</strong>。<p><code>BeanFactory</code>大多功能需要通过编程方式实现，能管理任何类型对象。<code>ApplicationContext</code>继承了<code>BeanFactory</code>并扩展了很多功能：<ul><li><strong>与 Spring AOP 轻松集成</strong>。<li><strong>消息资源处理（用于国际化）</strong><li><strong>事件发布</strong><li><strong>特定于应用程序层的上下文</strong>，例如，用于 Web 应用程序的<code>WebApplicationContext</code>。</ul><p><code>ApplicationContext</code>常见实现有：<code>ClassPathXmlApplicationContext</code> 和<code>FileSystemXmlApplicationContext</code>等。<h3 id=1-3-2、BeanFactory-VS-ApplicationContext><a title="1.3.2、BeanFactory VS ApplicationContext" class=headerlink href=#1-3-2、BeanFactory-VS-ApplicationContext></a>1.3.2、BeanFactory VS ApplicationContext</h3><ol><li>BeanFactory 是Spring的早期接口，称为Spring Bean工厂。ApplicationContext是后期的高级接口，称为Sprng容器。<li>ApplicationContext 在 BeanFactory 基础上对功能进行了扩展，例如：<strong>监听、资源访问、国际化</strong>等。BeanFactory的API更底层，ApplicatinContext的API大多是对底层API的封装。<li><strong>ApplicatinContext 继承了 BeanFactory，且内部维护了其引用</strong>。故 ApplicationContext 与 BeanFactory 既有继承关系，又有融合关系。<li>BeanFactory 对于Bean的实例化采用的是懒加载方式，而 ApplicationContext 采用的是立即加载。</ol><h2 id=1-4、WebApplicationContext><a class=headerlink href=#1-4、WebApplicationContext title=1.4、WebApplicationContext></a>1.4、WebApplicationContext</h2><h3 id=1-4-1、简介><a class=headerlink href=#1-4-1、简介 title=1.4.1、简介></a>1.4.1、简介</h3><p><strong>WebApplicationContext 专门为Web应用服务，它允许从 相对于Web根目录的路径中 装载配置文件 并完成初始化工作</strong>。从<code>WebApplicationContext</code>中可获得<code>ServletContext</code>引用，整个Web应用上下文对象将作为属性放置到<code>ServletContext</code>中，以便 Web应用环境可以访问Spring应用上下文。 <code>WebApplicationContext</code>定义了一个常量：<code>ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE（= WebApplicationContext.class.getName() + ".ROOT";）</code>，在上下文启动时，<code>WebApplicationContext</code>实例会以此为键放置在<code>ServletContext</code>属性列表中。<h3 id=1-4-2、初始化><a class=headerlink href=#1-4-2、初始化 title=1.4.2、初始化></a>1.4.2、初始化</h3><p><strong>WebApplicationContext需要ServletContext实例，它必须拥有Web容器才能完成启动工作</strong>。<p><strong>可以在 web.xml 中配置自启动的 Servlet 或定义Web容器监听器（ ServletContextListener），满足两者之一 即可启动 Spring Web应用上下文</strong>。Spring提供了启动 <code>WebApplicationContext</code> 的 <code>Servlet</code> 和 Web容器监听器：<ol><li><code>org.springframework.web.context.ContextLoaderServlet</code><li><code>org.springframework.web.context.ContextLoaderListener</code></ol><h2 id=1-5、Bean><a class=headerlink href=#1-5、Bean title=1.5、Bean></a>1.5、Bean</h2><h3 id=1-5-1、Bean生命周期><a class=headerlink href=#1-5-1、Bean生命周期 title=1.5.1、Bean生命周期></a>1.5.1、Bean生命周期</h3><p>Spring Bean的生命周期指的是<strong>从Bean的实例化到最终存储到单例池中的一个过程</strong>。<p>Spring生命周期体现在三个阶段：<ul><li><strong>Beean实例化阶段</strong><li><strong>Bean初始化阶段</strong><li><strong>Bean完成阶段</strong></ul><p>Bean生命周期详细流程分析如下：<ol><li><p><strong>实例化 Bean</strong></p> <p>若容器注册了<code>org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor</code> 接口，则：</p> <ol><li>实例化 Bean 前，先调用该接口的<code>postProcessBeforeInstantiation()</code>方法；<li>实例化Bean（根据配置情况调用Bean构造函数或工厂方法）；<li>实例化 Bean 后，调用该接口的<code>postProcessAfterInstantiation()</code>方法，可在这里对已经实例化的对象做一点扩展；</ol><li><p><strong>填充Bean属性值</strong></p> <ol><li>先调用 <code>InstantiationAwareBeanPostProcessor</code> 接口的 <code>postProcessPropertyValues()</code> 方法（5.1版本后，推荐使用 <code>postProcessProperties</code> 方法代替）；<li>填充 Bean属性值；</ol><li><p><strong>给Bean起个名</strong></p> <ol><li>如果 Bean 实现了 <code>org.springframework.beans.factory.BeanNameAware</code> 接口，将调用setBeanName()接口方法，将配置文件中该Bean对应的名称设置到 Bean 中；</ol><li><p><strong>将BeanFactory填充至Bean中</strong></p> <ol><li>如果 Bean 实现了 <code>org.springframework.beans.factory.BeanFactoryAware</code> 接口，将调用<code>setBeanFactory()</code> 接口方法，将BeanFactory容器实例设置到Bean中；</ol><li><p><strong>对Bean进行再加工</strong></p> <ol><li>如果 BeanFactory 装配了 <code>BeanPostProcessor</code> 后处理器，则会调用它的<code>postProcessBeforeInitialization(Object bean, String beanName)</code> 接口方法对 Bean 进行加工操作。（其中入参 bean 是当前正在处理的Bean，而beanName是当前Bean配置名，返回的对象为加工处理后的Bean。用户可以使用该方法对某些 Bean进行特殊的处理，甚至改变 Bean的行为。）（Spring容器所提供的各种神奇功能，如 AOP，动态代理等都是通过BeanPostProcessor来实现）<li>如果Bean实现了<code>InitializingBean</code> 接口，将调用接口的 <code>afterPropertiesSet()</code> 方法；<li>如果 <code>init-method</code> 属性指定了初始化方法，则执行这个方法；<li>调用 <code>BeanPostProcessor</code> 的 <code>postProcessAfterInitialization(Object bean, String beanName)</code> 方法。</ol><li><p><strong>使用Bean</strong></p><li><p><strong>销毁处理</strong></p> <p>如果是Prototype Bean，直接返回bean给调用者，调用者将负责Bean后续生命的管理。如果是Singleton Bean，则将Bean放入Spring IOC容器的缓存中，并将Bean引用返回给调用者， Spring继续负责Bean生命周期的管理：</p> <ol><li>对于Singleton Bean，容器关闭时会触发Spring对Bean后续生命周期的管理工作。如果Bean实现了 <code>DisposableBean</code> 接口，则调用接口的 <code>destroy()</code> 方法（5.0开始，推荐使用close方法）。<li>对于Singleton Bean，如果 <code>destroy-method</code> 属性指定了Bean的销毁方法， Spring将执行该这个方法来完成Bean资源的释放等操作。</ol></ol><h3 id=1-5-2、Bean实例化><a class=headerlink href=#1-5-2、Bean实例化 title=1.5.2、Bean实例化></a>1.5.2、Bean实例化</h3><p>工厂方式实例化Bean，可以分为三种：<ul><li><strong>静态工厂方法实例化Bean</strong>。<li><strong>实例工厂方法实例化Bean</strong>。<li><strong>实现FactoryBean接口实例化Bean</strong>。</ul><h3 id=1-5-3、Bean作用域><a class=headerlink href=#1-5-3、Bean作用域 title=1.5.3、Bean作用域></a>1.5.3、Bean作用域</h3><ul><li><strong>Singleton（默认）</strong>：每个容器中只有一个Bean实例，单例Bean由Spring来维护。<li><strong>Prototype</strong>：原形范围与单例范围相反，为每一个Bean请求提供一个实例。<li><strong>Request</strong>：每一个请求都会创建一个实例，请求完成后，Bean会失效并被垃圾回收器回收。<li><strong>Session</strong>：每个session中有一个bean实例，Session过期后，Bean会随之失效。<li><strong>Global Session</strong>：与Portlet应用有关。当应用部署在Portlet容器中时，它包含很多portlet。所有的portlet共用全局的存储变量。</ul><h2 id=1-6、注入集合><a class=headerlink href=#1-6、注入集合 title=1.6、注入集合></a>1.6、注入集合</h2><p>Spring提供以下几种集合的配置元素：<ul><li><code>&LTlist></code>：注入一列值，允许有相同的值。<li><code>&LTset> </code>：注入一组值，不允许有相同的值。<li><code>&LTmap></code>：注入一组键值对，键和值都<strong>可以为任意类型</strong>。<li><code>&LTprops></code>：注入一组键值对，键和值都<strong>只能为String类型</strong>。</ul><h2 id=1-7、增强器><a class=headerlink href=#1-7、增强器 title=1.7、增强器></a>1.7、增强器</h2><p>Spring中的增强器分为两种：<ul><li><p><strong>BeanFactoryPostProccessor</strong></p> <p>该增强器会在准备好bean定义信息后且实例化Bean前执行，仅执行一次。</p><li><p><strong>BeanPostProcessor</strong></p> <p>该增强器会在实例化bean后且将bean放入一级缓存前执行，每创建一个Bean都会执行一次。</p></ul><h1 id=2、Spring事件机制><a class=headerlink href=#2、Spring事件机制 title=2、Spring事件机制></a>2、Spring事件机制</h1><h2 id=2-1、事件类型><a class=headerlink href=#2-1、事件类型 title=2.1、事件类型></a>2.1、事件类型</h2><p>Spring 提供了以下5种标准事件：<ol><li><p><strong>上下文开始事件</strong></p> <p>当容器调用<code>ConfigurableApplicationContext.Start()</code>方法开始/重新开始容器时触发该事件。</p><li><p><strong>上下文停止事件</strong></p> <p>当容器调用<code>ConfigurableApplicationContext.Stop()</code>方法停止容器时触发该事件。</p><li><p><strong>上下文更新事件</strong></p> <p>该事件会在<code>ApplicationContext</code>被初始化或者更新时发布。也可以在调用<code>ConfigurableApplicationContext.refresh()</code>方法时被触发。</p><li><p><strong>上下文关闭事件</strong></p> <p>当<code>ApplicationContext</code>被关闭时触发该事件。容器被关闭时，其管理的所有单例Bean都被销毁。</p><li><p><strong>请求处理事件</strong></p> <p>在Web应用中，当一个http请求（request）结束时触发该事件。</p></ol><h1 id=总结><a class=headerlink href=#总结 title=总结></a>总结</h1><p><strong>Spring IOC容器主要有BeanFactory、ApplicationContext、WebApplicationContext</strong>。<h2 id=容器启动原理><a class=headerlink href=#容器启动原理 title=容器启动原理></a>容器启动原理</h2><p>Spring IOC容器通过tomcat的Servlet或Listener监听来启动加载：<ul><li><strong>Spring MVC的容器由DispatchServlet作为入口加载；</strong><li><strong>Spring容器是Spring MVC容器的父容器；</strong></ul><h2 id=容器加载Bean原理><a class=headerlink href=#容器加载Bean原理 title=容器加载Bean原理></a>容器加载Bean原理</h2><ol><li>BeanDefinitionReader 读取 Resource 所指向的配置文件资源，然后解析配置文件。配置文件中的每一个Bean定义会被解析成一个BeanDefinition对象，并保存到 BeanDefinitionRegistry 中；<li>容器扫描 BeanDefinitionRegistry 中的 BeanDefinition；通过 InstantiationStrategy 实例化Bean；通过BeanWrapper 设置Bean属性；<li>单例Bean缓存池：Spring 在 DefaultSingletonBeanRegistry 类中提供了一个用于缓存单例Bean的缓存，其基于HashMap实现，单实例Bean以 beanName 为键保存在这个HashMap中。</ol><h2 id=ApplicationContext和BeanFactory的区别><a class=headerlink href=#ApplicationContext和BeanFactory的区别 title=ApplicationContext和BeanFactory的区别></a>ApplicationContext和BeanFactory的区别</h2><ol><li><p>BeanFactory：是Spring中的底层接口，包含各种Bean定义，读取bean配置文档，管理bean的加载、实例化，控制bean的生命周期，维护bean之间的依赖关系。</p> <p>ApplicationContext接口除了提供BeanFactory所具有的功能外，还提供了其它功能：</p> <ul><li><p><strong>默认立即初始化所有Singleton bean，也可通过配置 取消 预初始化</strong>。</p><li><p><strong>继承MessageSource，支持国际化</strong>。</p><li><p><em><strong>资源访问</strong></em>，比如访问URL和文件。</p><li><p><em><strong>事件机制</strong></em>（在监听器中注册bean事件）。</p><li><p><strong>同时加载多个配置文件</strong>。</p><li><p><strong>以声明式方式启动并创建Spring容器</strong>。</p></ul><li><p>ApplicationContext会<strong>利用Java反射机制自动识别</strong> 出配置文件中定义的<strong>BeanPostProcessor、 InstantiationAwareBeanPostProcessor和 BeanFactoryPostProcessor，并自动将它们注册到应用上下文中</strong>；而 <strong>BeanFactory需要在代码中通过显式调用 addBeanPostProcessor() 方法进行注册</strong>。这也是普遍使用 ApplicationContext 而很少使用 BeanFactory 的原因之一。</p><li><p>ApplicationContext <strong>初始化上下文时会立即实例化所有单例Bean</strong>，可通过参数<code>lazy-init=true</code>来延迟Bean实例化；BeanFactory初始化容器时 不会实例化Bean，<strong>只有在第一次从容器中拿Bean时才会实例化</strong>。 </p><li><p><strong>BeanFactory一般通过编程方式来创建，ApplicationContext还能以声明方式创建</strong>，比如 使用ContextLoader。</p></ol></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/SpringBoo%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/SpringBoo%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=url>SpringBoot系列-SpringBoot基础应用</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-03 21:16:27" datetime=2023-10-03T21:16:27+08:00 itemprop=dateModified>2023-10-03</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/SpringBoot/ itemprop=url rel=index><span itemprop=name>SpringBoot</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=0、SpringBoot启动流程><a class=headerlink href=#0、SpringBoot启动流程 title=0、SpringBoot启动流程></a>0、SpringBoot启动流程</h1><p>SpringBoot启动流程主要分两步，创建SpringApplication对象流程 和 执行其run方法流程。<h2 id=0-1、创建SpringApplication对象流程><a class=headerlink href=#0-1、创建SpringApplication对象流程 title=0.1、创建SpringApplication对象流程></a>0.1、创建SpringApplication对象流程</h2><ol><li>初始化资源加载器，默认为null。<li>断言判断参数是否不为空。<li>初始化参数源。（封装参数为LinkedHashSet）<li>初始化当前应用类型（非Web类型、Servlet类型、Reactive类型）<li>获取系统配置引导信息。<li>获取ApplicationContextInitializer.class对应的实例。<li>初始化监听器，对初始化过程及运行过程进行干预。<li>初始化了引导类类名信息，备用。</ol><h2 id=0-2、执行SpringApplication-run方法流程><a class=headerlink href=#0-2、执行SpringApplication-run方法流程 title=0.2、执行SpringApplication.run方法流程></a>0.2、执行SpringApplication.run方法流程</h2><ol><li>设置计时器，并开始计时。<li>创建系统引导上下文对象。<ol><li>获取所有之前的bootstrappers，并逐个执行。initialization()完成对引导启动器上下文环境设置。</ol><li>模拟输入输出信号，避免出现因缺少外设导致的信号传输失败，进而引发错误（模拟显示器，键盘，鼠标…）<br>java.awt.headless=true。<li>获取当前注册的所有监听器，并开启监听。<li>获取参数并结合前期所读取的参数组合成一个环境对象，来描述环境信息。<li>配置系统环境参数spring.beaninfo.ignore信息。<li>初始化并打印logo（Banner）信息。<li>创建容器对象，并设置启动模式。<li>准备容器环境，参数来源于前期的设定。<li>刷新容器环境，并做刷新后处理。<li>计时结束。<li>创建启动信息日志对象，输出日志信息，包含启动时间。<li>监听器启动。<li>调用接口ApplicationRunner和接口CommandLineRunner的实现。<li>监听器运行。<li>如果以上有异常，调用监听器的failed方法。<li>返回context对象。</ol><h1 id=1、使用Starter><a class=headerlink href=#1、使用Starter title=1、使用Starter></a>1、使用Starter</h1><h2 id=1-1、啥是Spring-Boot><a title="1.1、啥是Spring Boot" class=headerlink href=#1-1、啥是Spring-Boot></a>1.1、啥是Spring Boot</h2><p>Spring Boot 使创建可运行的独立，基于生产级的基于 Spring 的应用程序变得容易。我们对 Spring 平台和第三方库持固执己见的观点，这样您就可以以最小的麻烦开始使用。大多数 Spring Boot 应用程序只需要很少的 Spring 配置。<p>您可以使用 Spring Boot 创建 Java 应用程序，可以使用<code>java -jar</code>或更传统的 War 部署来启动这些 Java 应用程序。我们还提供了一个运行“ spring 脚本”的命令行工具。<p>主要目标是：<ul><li>为所有 Spring 开发提供根本上更快且可广泛访问的 Starter 经验。<li>开箱即用，但由于需求开始与默认值有所出入，因此很快就会摆脱困境。<li>提供一系列大型项目通用的非功能性功能(例如嵌入式服务器，安全性，Metrics，运行状况检查和外部化配置)。<li>完全没有代码生成，也不需要 XML 配置。</ul><h2 id=1-2、System-Requirements><a title="1.2、System Requirements" class=headerlink href=#1-2、System-Requirements></a>1.2、System Requirements</h2><p>Spring Boot 2.1.1.RELEASE 需要<a href=https://www.java.com/ rel=noopener target=_blank>Java 8</a>，并且与 Java 11(包括)兼容。也必须<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/ rel=noopener target=_blank>Spring Framework 5.1.3. 发布</a>或更高。<p>为以下构建工具提供了明确的构建支持：<table><thead><tr><th>Build Tool<th>Version<tbody><tr><td>Maven<td>3.3+<tr><td>Gradle<td>4.4+</table><h3 id=1-2-1、Servlet容器><a class=headerlink href=#1-2-1、Servlet容器 title=1.2.1、Servlet容器></a>1.2.1、Servlet容器</h3><p>Spring Boot 支持以下嵌入式 servlet 容器：<table><thead><tr><th>Name<th>Servlet Version<tbody><tr><td>Tomcat 9.0<td>4.0<tr><td>Jetty 9.4<td>3.1<tr><td>Undertow 2.0<td>4.0</table><p>您还可以将 Spring Boot 应用程序部署到任何 Servlet 3.1 兼容容器中。<h2 id=1-3、安装Spring-Boot><a title="1.3、安装Spring Boot" class=headerlink href=#1-3、安装Spring-Boot></a>1.3、安装Spring Boot</h2><p>Spring Boot 可以与“经典” Java 开发工具一起使用，也可以作为命令行工具安装。无论哪种方式，您都需要<a href=https://www.java.com/ rel=noopener target=_blank>Java SDK v1.8</a>或更高。在开始之前，您应该使用以下命令检查当前的 Java 安装：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -version</span></span><br></pre></table></figure><p>如果您不熟悉 Java 开发，或者想尝试使用 Spring Boot，则可能要先尝试<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/getting-started-installing-spring-boot.html#getting-started-installing-the-cli rel=noopener target=_blank>Spring Boot CLI</a>(命令行界面)。否则，请 continue 阅读“经典”安装说明。<h3 id=1-3-1、Java人员安装说明><a class=headerlink href=#1-3-1、Java人员安装说明 title=1.3.1、Java人员安装说明></a>1.3.1、Java人员安装说明</h3><p>您可以像使用任何标准 Java 库一样使用 Spring Boot。为此，请在 Classpath 中包含适当的<code>spring-boot-*.jar</code>文件。 Spring Boot 不需要任何特殊的工具集成，因此您可以使用任何 IDE 或文本编辑器。另外，Spring Boot 应用程序没有什么特别的，因此您可以像运行其他 Java 程序一样运行和调试 Spring Boot 应用程序。<p>尽管您可以复制 Spring Boot jar，但是我们通常建议您使用支持依赖项 Management 的构建工具(例如 Maven 或 Gradle)。<h4 id=1-3-1-1、Maven安装><a class=headerlink href=#1-3-1-1、Maven安装 title=1.3.1.1、Maven安装></a>1.3.1.1、Maven安装</h4><p>Spring Boot 依赖项使用<code>org.springframework.boot</code> <code>groupId</code>。通常，您的 Maven POM 文件从<code>spring-boot-starter-parent</code>项目继承，并声明对一个或多个<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#using-boot-starter rel=noopener target=_blank>“Starters”</a>的依赖关系。 Spring Boot 还提供了一个可选的<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/build-tool-plugins-maven-plugin.html rel=noopener target=_blank>Maven plugin</a>来创建可执行 jar。<p>以下 Lists 显示了一个典型的<code>pom.xml</code>文件：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>project</span> <span class=attr>xmlns</span>=<span class=string>"http://maven.apache.org/POM/4.0.0"</span> <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>	<span class=attr>xsi:schemaLocation</span>=<span class=string>"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>></span></span><br><span class=line>	<span class=tag><<span class=name>modelVersion</span>></span>4.0.0<span class=tag>&LT/<span class=name>modelVersion</span>></span></span><br><span class=line></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>com.example<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>myproject<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>version</span>></span>0.0.1-SNAPSHOT<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line></span><br><span class=line>	<span class=comment>&LT!-- Inherit defaults from Spring Boot --></span></span><br><span class=line>	<span class=tag><<span class=name>parent</span>></span></span><br><span class=line>		<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>		<span class=tag><<span class=name>artifactId</span>></span>spring-boot-starter-parent<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>		<span class=tag><<span class=name>version</span>></span>2.1.1.RELEASE<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>parent</span>></span></span><br><span class=line></span><br><span class=line>	<span class=comment>&LT!-- Add typical dependencies for a web application --></span></span><br><span class=line>	<span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>		<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>			<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>artifactId</span>></span>spring-boot-starter-web<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>dependencies</span>></span></span><br><span class=line></span><br><span class=line>	<span class=comment>&LT!-- Package as an executable jar --></span></span><br><span class=line>	<span class=tag><<span class=name>build</span>></span></span><br><span class=line>		<span class=tag><<span class=name>plugins</span>></span></span><br><span class=line>			<span class=tag><<span class=name>plugin</span>></span></span><br><span class=line>				<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>				<span class=tag><<span class=name>artifactId</span>></span>spring-boot-maven-plugin<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>			<span class=tag>&LT/<span class=name>plugin</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>plugins</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>build</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>project</span>></span></span><br></pre></table></figure><h4 id=1-3-1-2、安装Gradle><a class=headerlink href=#1-3-1-2、安装Gradle title=1.3.1.2、安装Gradle></a>1.3.1.2、安装Gradle</h4><p>Spring Boot 与 Gradle 4.4 及更高版本兼容。如果尚未安装 Gradle，则可以按照<a href=https://gradle.org/ rel=noopener target=_blank>gradle.org</a>上的说明进行操作。<p>可以使用<code>org.springframework.boot</code> <code>group</code>声明 Spring Boot 依赖项。通常，您的项目声明对一个或多个<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#using-boot-starter rel=noopener target=_blank>“Starters”</a>的依赖关系。 Spring Boot 提供了一个有用的<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/build-tool-plugins-gradle-plugin.html rel=noopener target=_blank>Gradle plugin</a>，可用于简化依赖项声明并创建可执行 jar。<blockquote><p>当您需要构建项目时，Gradle 包装器提供了一种“获取” Gradle 的好方法。这是一个小的脚本和库，您随代码一起提交以引导构建过程。有关详情，请参见<a href=https://docs.gradle.org/4.2.1/userguide/gradle_wrapper.html rel=noopener target=_blank>docs.gradle.org/4.2.1/userguide/gradle_wrapper.html</a>。</blockquote><p>有关 Spring Boot 和 Gradle Starter 的更多详细信息，可以在 Gradle 插件参考指南的<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/gradle-plugin/reference/html/#getting-started rel=noopener target=_blank>Starter 部分</a>中找到。<h3 id=1-3-2、安装Spring-Boot-CLI><a title="1.3.2、安装Spring Boot CLI" class=headerlink href=#1-3-2、安装Spring-Boot-CLI></a>1.3.2、安装Spring Boot CLI</h3><p>Spring Boot CLI(命令行界面)是一个命令行工具，可用于快速使用 Spring 进行原型设计。它使您可以运行<a href=http://groovy-lang.org/ rel=noopener target=_blank>Groovy</a>脚本，这意味着您具有类似 Java 的熟悉语法，而没有太多样板代码。<p>您无需使用 CLI 即可与 Spring Boot 配合使用，但这绝对是使 Spring 应用程序启动的最快方法。<h4 id=1-3-2-1、手动安装><a class=headerlink href=#1-3-2-1、手动安装 title=1.3.2.1、手动安装></a>1.3.2.1、手动安装</h4><p>您可以从 Spring 软件存储库下载 Spring CLI 发行版：<ul><li><a href=https://repo.spring.io/release/org/springframework/boot/spring-boot-cli/2.1.1.RELEASE/spring-boot-cli-2.1.1.RELEASE-bin.zip rel=noopener target=_blank>spring-boot-cli-2.1.1.RELEASE-bin.zip</a><li><a href=https://repo.spring.io/release/org/springframework/boot/spring-boot-cli/2.1.1.RELEASE/spring-boot-cli-2.1.1.RELEASE-bin.tar.gz rel=noopener target=_blank>spring-boot-cli-2.1.1.RELEASE-bin.tar.gz</a></ul><p>最先进的<a href=https://repo.spring.io/snapshot/org/springframework/boot/spring-boot-cli/ rel=noopener target=_blank>snapshot distributions</a>也可用。<p>下载完成后，请按照解压后的存档中的<a href=https://raw.github.com/spring-projects/spring-boot/v2.1.1.RELEASE/spring-boot-project/spring-boot-cli/src/main/content/INSTALL.txt rel=noopener target=_blank>INSTALL.txt</a>说明进行操作。总之，在<code>.zip</code>文件的<code>bin/</code>目录中有一个<code>spring</code>脚本(对于 Windows 是<code>spring.bat</code>)。或者，您可以将<code>java -jar</code>与<code>.jar</code>文件一起使用(脚本可帮助您确保正确设置了 Classpath)。<h4 id=1-3-2-2、使用SDKMAN安装><a class=headerlink href=#1-3-2-2、使用SDKMAN安装 title=1.3.2.2、使用SDKMAN安装></a>1.3.2.2、使用SDKMAN安装</h4><p>SDKMAN！ (软件开发工具包 Management 器)可用于 Management 各种二进制 SDK 的多个版本，包括 Groovy 和 Spring Boot CLI。获取 SDKMAN！从<a href=http://sdkman.io/ rel=noopener target=_blank>sdkman.io</a>开始，并使用以下命令安装 Spring Boot：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>sdk install springboot</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring --version</span></span><br><span class=line>Spring Boot v2.1.1.RELEASE</span><br></pre></table></figure><p>如果您为 CLI 开发功能并希望轻松访问所构建的版本，请使用以下命令：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>sdk install springboot dev /path/to/spring-boot/spring-boot-cli/target/spring-boot-cli-2.1.1.RELEASE-bin/spring-2.1.1.RELEASE/</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>sdk default springboot dev</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring --version</span></span><br><span class=line>Spring CLI v2.1.1.RELEASE</span><br></pre></table></figure><p>前面的说明将安装称为<code>dev</code>实例的<code>spring</code>本地实例。它指向您的目标构建位置，因此，每次重建 Spring Boot 时，<code>spring</code>都是最新的。<p>您可以通过运行以下命令来查看它：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>sdk <span class=built_in>ls</span> springboot</span></span><br><span class=line></span><br><span class=line>================================================================================</span><br><span class=line>Available Springboot Versions</span><br><span class=line>================================================================================</span><br><span class=line><span class="meta prompt_">> </span><span class=language-bash>+ dev</span></span><br><span class=line>* 2.1.1.RELEASE</span><br><span class=line></span><br><span class=line>================================================================================</span><br><span class=line>+ - local version</span><br><span class=line>* - installed</span><br><span class=line><span class="meta prompt_">> </span><span class=language-bash>- currently <span class=keyword>in</span> use</span></span><br><span class=line>================================================================================</span><br></pre></table></figure><h4 id=1-3-2-3、OSX-Homebrew安装><a title="1.3.2.3、OSX Homebrew安装" class=headerlink href=#1-3-2-3、OSX-Homebrew安装></a>1.3.2.3、OSX Homebrew安装</h4><p>如果您使用的是 Mac 并使用<a href=https://brew.sh/ rel=noopener target=_blank>Homebrew</a>，则可以使用以下命令安装 Spring Boot CLI：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>brew tap pivotal/tap</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>brew install springboot</span></span><br></pre></table></figure><p>自制软件将<code>spring</code>安装到<code>/usr/local/bin</code>。<h4 id=1-3-2-4、MacPorts安装><a class=headerlink href=#1-3-2-4、MacPorts安装 title=1.3.2.4、MacPorts安装></a>1.3.2.4、MacPorts安装</h4><p>如果您使用的是 Mac 并使用<a href=https://www.macports.org/ rel=noopener target=_blank>MacPorts</a>，则可以使用以下命令安装 Spring Boot CLI：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>sudo</span> port install spring-boot-cli</span></span><br></pre></table></figure><h4 id=1-3-2-5、命令行完成><a class=headerlink href=#1-3-2-5、命令行完成 title=1.3.2.5、命令行完成></a>1.3.2.5、命令行完成</h4><p>Spring Boot CLI 包括为<a href=https://en.wikipedia.org/wiki/Bash_(Unix_shell) rel=noopener target=_blank>BASH</a>和<a href=https://en.wikipedia.org/wiki/Z_shell rel=noopener target=_blank>zsh</a> Shell 提供命令完成的脚本。您可以在任何 shell 中<code>source</code>脚本(也称为<code>spring</code>)或将其放入个人或系统范围的 bash 完成初始化中。在 Debian 系统上，系统级脚本位于<code>/shell-completion/bash</code>中，并且在启动新 Shell 时将执行该目录中的所有脚本。例如，如果您是使用 SDKMAN！安装的，则要手动运行脚本，请使用以下命令：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>. ~/.sdkman/candidates/springboot/current/shell-completion/bash/spring</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring &LTHIT TAB HERE></span></span><br><span class=line>  grab  help  jar  run  test  version</span><br></pre></table></figure><blockquote><p>如果您使用 Homebrew 或 MacPorts 安装 Spring Boot CLI，则命令行完成脚本会自动注册到您的 Shell 中。</blockquote><h4 id=1-3-2-6、Windows-Scoop安装><a title="1.3.2.6、Windows Scoop安装" class=headerlink href=#1-3-2-6、Windows-Scoop安装></a>1.3.2.6、Windows Scoop安装</h4><p>如果您使用的是 Windows 并使用<a href=http://scoop.sh/ rel=noopener target=_blank>Scoop</a>，则可以使用以下命令安装 Spring Boot CLI：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">> </span><span class=language-bash>scoop bucket add extras</span></span><br><span class=line><span class="meta prompt_">> </span><span class=language-bash>scoop install springboot</span></span><br></pre></table></figure><p>Scoop 将<code>spring</code>安装到<code>~/scoop/apps/springboot/current/bin</code>。<blockquote><p>如果您没有看到应用 Lists，则可能是因为瓢的安装已过期。在这种情况下，请运行<code>scoop update</code>，然后重试。</blockquote><h4 id=1-3-2-7、快速Starter-Spring-CLI示例><a title="1.3.2.7、快速Starter Spring CLI示例" class=headerlink href=#1-3-2-7、快速Starter-Spring-CLI示例></a>1.3.2.7、快速Starter Spring CLI示例</h4><p>您可以使用以下 Web 应用程序来测试安装。首先，创建一个名为<code>app.groovy</code>的文件，如下所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>@RestController</span><br><span class=line>class ThisWillActuallyRun {</span><br><span class=line></span><br><span class=line>	@RequestMapping("/")</span><br><span class=line>	String home() {</span><br><span class=line>		"Hello World!"</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><p>然后从 Shell 运行它，如下所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring run app.groovy</span></span><br></pre></table></figure><p>在您喜欢的网络浏览器中打开<code>localhost:8080</code>。您应该看到以下输出：<figure class="highlight text"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>Hello World!</span><br></pre></table></figure><h3 id=1-3-3、早期版本-Spring-Boot-升级><a title="1.3.3、早期版本 Spring Boot 升级" class=headerlink href=#1-3-3、早期版本-Spring-Boot-升级></a>1.3.3、早期版本 Spring Boot 升级</h3><p>如果您要从较早版本的 Spring Boot 升级，请检查<a href=https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide rel=noopener target=_blank>项目 Wiki 上的“迁移指南”</a>，其中提供了详细的升级说明。还要在<a href=https://github.com/spring-projects/spring-boot/wiki rel=noopener target=_blank>“release notes”</a>上查看每个版本的“新功能和值得注意的”功能列表。<p>升级到新功能版本时，某些属性可能已被重命名或删除。 Spring Boot 提供了一种在启动时分析应用程序环境并打印诊断的方法，而且还可以在运行时为您临时迁移属性。要启用该功能，请将以下依赖项添加到您的项目中：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>spring-boot-properties-migrator<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>scope</span>></span>runtime<span class=tag>&LT/<span class=name>scope</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><blockquote><p>注意：较晚添加到环境的属性(例如使用<code>@PropertySource</code>时)将不被考虑。<p>迁移完成后，请确保从项目的依赖项中删除此模块。</blockquote><p>要升级现有的 CLI 安装，请使用适当的程序包 Management 器命令(例如<code>brew upgrade</code>)，或者，如果手动安装了 CLI，请遵循<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/getting-started-installing-spring-boot.html#getting-started-manual-cli-installation rel=noopener target=_blank>standard instructions</a>，记住要更新<code>PATH</code>环境变量以删除任何较旧的引用。<h2 id=1-4、第一个SpringBoot应用><a class=headerlink href=#1-4、第一个SpringBoot应用 title=1.4、第一个SpringBoot应用></a>1.4、第一个SpringBoot应用</h2><p>在开始之前，请打开终端并运行以下命令，以确保安装了有效的 Java 和 Maven 版本：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -version</span></span><br><span class=line>java version "1.8.0_102"</span><br><span class=line>Java(TM) SE Runtime Environment (build 1.8.0_102-b14)</span><br><span class=line>Java HotSpot(TM) 64-Bit Server VM (build 25.102-b14, mixed mode)</span><br></pre></table></figure><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>mvn -v</span></span><br><span class=line>Apache Maven 3.5.4 (1edded0938998edf8bf061f1ceb3cfdeccf443fe; 2018-06-17T14:33:14-04:00)</span><br><span class=line>Maven home: /usr/local/Cellar/maven/3.3.9/libexec</span><br><span class=line>Java version: 1.8.0_102, vendor: Oracle Corporation</span><br></pre></table></figure><h3 id=1-4-1、创建POM><a class=headerlink href=#1-4-1、创建POM title=1.4.1、创建POM></a>1.4.1、创建POM</h3><p>我们需要先创建一个 Maven <code>pom.xml</code>文件。 <code>pom.xml</code>是用于构建项目的配方。打开您喜欢的文本编辑器并添加以下内容：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line>&LT?xml version="1.0" encoding="UTF-8"?></span><br><span class=line>&LTproject xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class=line>	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"></span><br><span class=line>	&LTmodelVersion>4.0.0&LT/modelVersion></span><br><span class=line></span><br><span class=line>	&LTgroupId>com.example&LT/groupId></span><br><span class=line>	&LTartifactId>myproject&LT/artifactId></span><br><span class=line>	&LTversion>0.0.1-SNAPSHOT&LT/version></span><br><span class=line></span><br><span class=line>	&LTparent></span><br><span class=line>		&LTgroupId>org.springframework.boot&LT/groupId></span><br><span class=line>		&LTartifactId>spring-boot-starter-parent&LT/artifactId></span><br><span class=line>		&LTversion>2.1.1.RELEASE&LT/version></span><br><span class=line>	&LT/parent></span><br><span class=line></span><br><span class=line>	&LT!-- Additional lines to be added here... --></span><br><span class=line></span><br><span class=line>&LT/project></span><br></pre></table></figure><p>上面的 Lists 应为您提供有效的构建。您可以通过运行<code>mvn package</code>进行测试(目前，您可以忽略“ jar 将为空-没有内容被标记为包含！”警告)。<h3 id=1-4-2、添加Classpath依赖项><a class=headerlink href=#1-4-2、添加Classpath依赖项 title=1.4.2、添加Classpath依赖项></a>1.4.2、添加Classpath依赖项</h3><p>Spring Boot 提供了许多“启动器”，使您可以将 jar 添加到 Classpath 中。我们的示例应用程序已经在 POM 的<code>parent</code>部分中使用了<code>spring-boot-starter-parent</code>。 <code>spring-boot-starter-parent</code>是一个特殊的启动器，提供有用的 Maven 默认值。它还提供了一个<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#using-boot-dependency-management rel=noopener target=_blank>dependency-management</a>部分，以便您可以省略<code>version</code>标签来表示“受祝福的”依赖关系。<p>其他“Starter”提供了开发特定类型的应用程序时可能需要的依赖项。由于我们正在开发 Web 应用程序，因此我们添加了<code>spring-boot-starter-web</code>依赖项。在此之前，我们可以通过运行以下命令来查看当前的状态：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>mvn dependency:tree</span></span><br><span class=line></span><br><span class=line>[INFO] com.example:myproject:jar:0.0.1-SNAPSHOT</span><br></pre></table></figure><p><code>mvn dependency:tree</code>命令显示项目依赖项的树形表示。您可以看到<code>spring-boot-starter-parent</code>本身不提供任何依赖关系。要添加必要的依赖性，请编辑<code>pom.xml</code>并将<code>spring-boot-starter-web</code>依赖性添加在<code>parent</code>部分的正下方：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>	<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>		<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>		<span class=tag><<span class=name>artifactId</span>></span>spring-boot-starter-web<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencies</span>></span></span><br></pre></table></figure><p>如果再次运行<code>mvn dependency:tree</code>，则会看到现在还有许多其他依赖项，包括 Tomcat Web 服务器和 Spring Boot 本身。<h3 id=1-4-3、编写代码><a class=headerlink href=#1-4-3、编写代码 title=1.4.3、编写代码></a>1.4.3、编写代码</h3><p>要完成我们的应用程序，我们需要创建一个 Java 文件。默认情况下，Maven 从<code>src/main/java</code>编译源代码，因此您需要创建该文件夹结构，然后添加名为<code>src/main/java/Example.java</code>的文件以包含以下代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.boot.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.autoconfigure.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.web.bind.annotation.*;</span><br><span class=line></span><br><span class=line><span class=meta>@RestController</span></span><br><span class=line><span class=meta>@EnableAutoConfiguration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Example</span> {</span><br><span class=line>	<span class=meta>@RequestMapping("/")</span></span><br><span class=line>	String <span class="title function_">home</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=string>"Hello World!"</span>;</span><br><span class=line>	}</span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		SpringApplication.run(Example.class, args);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>尽管这里没有太多代码，但正在进行很多工作。我们将在接下来的几节中逐步介绍重要部分。<h4 id=1-4-3-1、-RestController-和-RequestMapping-注解><a title="1.4.3.1、@RestController 和@RequestMapping 注解" class=headerlink href=#1-4-3-1、-RestController-和-RequestMapping-注解></a>1.4.3.1、@RestController 和@RequestMapping 注解</h4><p>我们的<code>Example</code>类的第一个 Comments 是<code>@RestController</code>。这称为“定型”Comments。它为阅读代码的人和 Spring 提供了提示，提示该类起特定作用。在这种情况下，我们的类是一个 Web <code>@Controller</code>，因此 Spring 在处理传入的 Web 请求时会考虑使用它。<p><code>@RequestMapping</code>注解提供“路由”信息。它告诉 Spring，任何带有<code>/</code>路径的 HTTP 请求都应 Map 到<code>home</code>方法。 <code>@RestController</code>Comments 告诉 Spring 将结果字符串直接渲染回调用方。<blockquote><p><code>@RestController</code>和<code>@RequestMapping</code>Comments 是 Spring MVC Comments。 (它们并非特定于 Spring Boot.)有关更多详细信息，请参见 Spring 参考文档中的<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc rel=noopener target=_blank>MVC section</a>。</blockquote><h4 id=1-4-3-2、-EnableAutoConfiguration-注解><a title="1.4.3.2、@EnableAutoConfiguration 注解" class=headerlink href=#1-4-3-2、-EnableAutoConfiguration-注解></a>1.4.3.2、@EnableAutoConfiguration 注解</h4><p>第二个类级别的 Comments 是<code>@EnableAutoConfiguration</code>。这个 Comments 告诉 Spring Boot 根据所添加的 jar 依赖关系“猜测”您如何配置 Spring。由于<code>spring-boot-starter-web</code>添加了 Tomcat 和 Spring MVC，因此自动配置假定您正在开发 Web 应用程序并相应地设置 Spring。<blockquote><p>自动配置旨在与“启动器”配合使用，但是这两个概念并不直接相关。您可以自由选择启动器之外的 jar 依赖项。 Spring Boot 仍会尽其所能自动配置您的应用程序。</blockquote><h4 id=1-4-3-3、main方法><a class=headerlink href=#1-4-3-3、main方法 title=1.4.3.3、main方法></a>1.4.3.3、main方法</h4><p>我们应用程序的最后一部分是<code>main</code>方法。这只是遵循 Java 约定的应用程序入口点的标准方法。我们的 main 方法通过调用<code>run</code>委托给 Spring Boot 的<code>SpringApplication</code>类。 <code>SpringApplication</code>引导我们的应用程序，启动 Spring，该应用程序反过来又启动自动配置的 Tomcat Web 服务器。我们需要将<code>Example.class</code>作为参数传递给<code>run</code>方法，以告诉<code>SpringApplication</code>是主要的 Spring 组件。还将传递<code>args</code>数组以公开任何命令行参数。<h3 id=1-4-4、创建一个可执行Jar><a class=headerlink href=#1-4-4、创建一个可执行Jar title=1.4.4、创建一个可执行Jar></a>1.4.4、创建一个可执行Jar</h3><p>通过创建一个可以在生产环境中运行的完全独立的可执行 jar 文件来结束示例。可执行 jar(有时称为“胖 jar”)是包含您的已编译类以及代码需要运行的所有 jar 依赖项的归档文件。<p>要创建可执行 jar，我们需要将<code>spring-boot-maven-plugin</code>添加到<code>pom.xml</code>。为此，请在<code>dependencies</code>部分的下面插入以下行：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>build</span>></span></span><br><span class=line>	<span class=tag><<span class=name>plugins</span>></span></span><br><span class=line>		<span class=tag><<span class=name>plugin</span>></span></span><br><span class=line>			<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>artifactId</span>></span>spring-boot-maven-plugin<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>plugin</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>plugins</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>build</span>></span></span><br></pre></table></figure><blockquote><p><code>spring-boot-starter-parent</code> POM 包含<code>&LTexecutions></code>配置以绑定<code>repackage</code>目标。如果不使用父 POM，则需要自己声明此配置。有关详情，请参见<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/maven-plugin/usage.html rel=noopener target=_blank>plugin documentation</a>。</blockquote><p>保存您的<code>pom.xml</code>并从命令行运行<code>mvn package</code>，如下所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>mvn package</span></span><br><span class=line></span><br><span class=line>[INFO] Scanning for projects...</span><br><span class=line>[INFO]</span><br><span class=line>[INFO] ------------------------------------------------------------------------</span><br><span class=line>[INFO] Building myproject 0.0.1-SNAPSHOT</span><br><span class=line>[INFO] ------------------------------------------------------------------------</span><br><span class=line>[INFO] .... ..</span><br><span class=line>[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject ---</span><br><span class=line>[INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar</span><br><span class=line>[INFO]</span><br><span class=line>[INFO] --- spring-boot-maven-plugin:2.1.1.RELEASE:repackage (default) @ myproject ---</span><br><span class=line>[INFO] ------------------------------------------------------------------------</span><br><span class=line>[INFO] BUILD SUCCESS</span><br><span class=line>[INFO] ------------------------------------------------------------------------</span><br></pre></table></figure><p>如果查看<code>target</code>目录，应该会看到<code>myproject-0.0.1-SNAPSHOT.jar</code>。该文件的大小应为 10 MB 左右。如果您想窥视内部，可以使用<code>jar tvf</code>，如下所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>jar tvf target/myproject-0.0.1-SNAPSHOT.jar</span></span><br></pre></table></figure><p>您还应该在<code>target</code>目录中看到一个名为<code>myproject-0.0.1-SNAPSHOT.jar.original</code>的小得多的文件。这是 Maven 在 Spring Boot 重新打包之前创建的原始 jar 文件。<p>要运行该应用程序，请使用<code>java -jar</code>命令，如下所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -jar target/myproject-0.0.1-SNAPSHOT.jar</span></span><br><span class=line></span><br><span class=line>  .   ____          _            __ _ _</span><br><span class=line> /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class=line>( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \</span><br><span class=line> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class=line>  '  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class=line> =========|_|==============|___/=/_/_/_/</span><br><span class=line> :: Spring Boot ::  (v2.1.1.RELEASE)</span><br><span class=line>....... . . .</span><br><span class=line>....... . . . (log output here)</span><br><span class=line>....... . . .</span><br><span class=line>........ Started Example in 2.536 seconds (JVM running for 2.864)</span><br></pre></table></figure><p>和以前一样，要退出该应用程序，请按<code>ctrl-c</code>。<h1 id=2、使用Spring-Boot><a title="2、使用Spring Boot" class=headerlink href=#2、使用Spring-Boot></a>2、使用Spring Boot</h1><h2 id=2-1、Build-Systems><a title="2.1、Build Systems" class=headerlink href=#2-1、Build-Systems></a>2.1、Build Systems</h2><p>强烈建议您选择一个支持<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#using-boot-dependency-management rel=noopener target=_blank>dependency management</a>并且可以使用发布到“ Maven Central”存储库的工件的构建系统。我们建议您选择 Maven 或 Gradle。<h3 id=2-1-1、依赖性Management><a class=headerlink href=#2-1-1、依赖性Management title=2.1.1、依赖性Management></a>2.1.1、依赖性Management</h3><p>每个 Spring Boot 版本都提供了它支持的精选依赖列表。实际上，您不需要为构建配置中的所有这些依赖项提供版本，因为 Spring Boot 会为您 Management 版本。当您升级 Spring Boot 本身时，这些依赖项也会以一致的方式升级。<p>精选列表包含可与 Spring Boot 一起使用的所有 spring 模块以及精炼的第三方库列表。该列表作为标准<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#using-boot-maven-without-a-parent rel=noopener target=_blank>物料 Lists(Spring 引导相关性)</a>可用，可以与<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#using-boot-maven-parent-pom rel=noopener target=_blank>Maven</a>和<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#using-boot-gradle rel=noopener target=_blank>Gradle</a>一起使用。<blockquote><p>每个 Spring Boot 版本都与 Spring Framework 的基本版本相关联。我们强烈建议您不要指定其版本。</blockquote><h3 id=2-1-2、Maven><a class=headerlink href=#2-1-2、Maven title=2.1.2、Maven></a>2.1.2、Maven</h3><p>Maven 用户可以从<code>spring-boot-starter-parent</code>项目继承来获取合理的默认值。父项目提供以下功能：<ul><li>Java 1.8 是默认的编译器级别。<li>UTF-8 源编码。<li>继承自 spring-boot-dependencies pom 的<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#using-boot-dependency-management rel=noopener target=_blank>依赖性 Management 部分</a>，用于 Management 常见依赖项的版本。当在您自己的 pom 中使用这些依赖关系时，可以为这些依赖关系省略标记。<li>带有<code>repackage</code>执行 ID 的<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/maven-plugin/repackage-mojo.html rel=noopener target=_blank>repackage goal</a>的执行。<li>Sensible <a href=https://maven.apache.org/plugins/maven-resources-plugin/examples/filter.html rel=noopener target=_blank>resource filtering</a>.<li>合理的插件配置(<a href=https://www.mojohaus.org/exec-maven-plugin/ rel=noopener target=_blank>exec plugin</a>，<a href=https://github.com/ktoso/maven-git-commit-id-plugin rel=noopener target=_blank>Git 提交 ID</a>和<a href=https://maven.apache.org/plugins/maven-shade-plugin/ rel=noopener target=_blank>shade</a>)。<li><code>application.properties</code>和<code>application.yml</code>的敏感资源过滤，包括特定于配置文件的文件(例如<code>application-dev.properties</code>和<code>application-dev.yml</code>)</ul><p>请注意，由于<code>application.properties</code>和<code>application.yml</code>文件接受 Spring 样式占位符(<code>${…}</code>)，因此 Maven 过滤已更改为使用<code>@[email protected]</code>占位符。 (您可以通过设置名为<code>resource.delimiter</code>的 Maven 属性来覆盖它.)<h4 id=2-1-2-1、继承Starter-Parent><a title="2.1.2.1、继承Starter Parent" class=headerlink href=#2-1-2-1、继承Starter-Parent></a>2.1.2.1、继承Starter Parent</h4><p>要将项目配置为从<code>spring-boot-starter-parent</code>继承，请设置<code>parent</code>，如下所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- Inherit defaults from Spring Boot --></span></span><br><span class=line><span class=tag><<span class=name>parent</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>spring-boot-starter-parent<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>version</span>></span>2.1.1.RELEASE<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>parent</span>></span></span><br></pre></table></figure><blockquote><p>您只需要为此依赖项指定 Spring Boot 版本号。如果导入其他启动器，则可以安全地省略版本号。</blockquote><p>使用该设置，您还可以通过覆盖自己项目中的属性来覆盖各个依赖项。例如，要升级到另一个 Spring Data 发布系列，可以将以下内容添加到<code>pom.xml</code>：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>properties</span>></span></span><br><span class=line>	<span class=tag><<span class=name>spring-data-releasetrain.version</span>></span>Fowler-SR2<span class=tag>&LT/<span class=name>spring-data-releasetrain.version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>properties</span>></span></span><br></pre></table></figure><h4 id=2-1-2-2、在没有父-POM-的情况下使用-Spring-Boot><a title="2.1.2.2、在没有父 POM 的情况下使用 Spring Boot" class=headerlink href=#2-1-2-2、在没有父-POM-的情况下使用-Spring-Boot></a>2.1.2.2、在没有父 POM 的情况下使用 Spring Boot</h4><p>并非每个人都喜欢从<code>spring-boot-starter-parent</code> POM 继承。您可能需要使用自己的公司标准父级，或者可能希望显式声明所有 Maven 配置。<p>如果您不想使用<code>spring-boot-starter-parent</code>，仍然可以通过使用<code>scope=import</code>依赖项来保留依赖项 Management(而不是插件 Management)的好处，如下所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependencyManagement</span>></span></span><br><span class=line>	<span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>		<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>			<span class=comment>&LT!-- Import dependency management from Spring Boot --></span></span><br><span class=line>			<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>artifactId</span>></span>spring-boot-dependencies<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>version</span>></span>2.1.1.RELEASE<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>			<span class=tag><<span class=name>type</span>></span>pom<span class=tag>&LT/<span class=name>type</span>></span></span><br><span class=line>			<span class=tag><<span class=name>scope</span>></span>import<span class=tag>&LT/<span class=name>scope</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>dependencies</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencyManagement</span>></span></span><br></pre></table></figure><p>如上所述，前面的示例设置不允许您使用属性来覆盖各个依赖项。为了获得相同的结果，您需要在项目的<code>dependencyManagement</code> <strong>之前</strong> 在<code>spring-boot-dependencies</code>条目之前添加一个条目。例如，要升级到另一个 Spring Data 发布系列，可以将以下元素添加到<code>pom.xml</code>：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependencyManagement</span>></span></span><br><span class=line>	<span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>		<span class=comment>&LT!-- Override Spring Data release train provided by Spring Boot --></span></span><br><span class=line>		<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>			<span class=tag><<span class=name>groupId</span>></span>org.springframework.data<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>artifactId</span>></span>spring-data-releasetrain<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>version</span>></span>Fowler-SR2<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>			<span class=tag><<span class=name>type</span>></span>pom<span class=tag>&LT/<span class=name>type</span>></span></span><br><span class=line>			<span class=tag><<span class=name>scope</span>></span>import<span class=tag>&LT/<span class=name>scope</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>		<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>			<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>artifactId</span>></span>spring-boot-dependencies<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>version</span>></span>2.1.1.RELEASE<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>			<span class=tag><<span class=name>type</span>></span>pom<span class=tag>&LT/<span class=name>type</span>></span></span><br><span class=line>			<span class=tag><<span class=name>scope</span>></span>import<span class=tag>&LT/<span class=name>scope</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>dependencies</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencyManagement</span>></span></span><br></pre></table></figure><h4 id=2-1-2-3、使用Spring-Boot-Maven插件><a title="2.1.2.3、使用Spring Boot Maven插件" class=headerlink href=#2-1-2-3、使用Spring-Boot-Maven插件></a>2.1.2.3、使用Spring Boot Maven插件</h4><p>Spring Boot 包含一个<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/build-tool-plugins-maven-plugin.html rel=noopener target=_blank>Maven plugin</a>，可以将项目打包为可执行 jar。如果要使用插件，请将其添加到<code>&LTplugins></code>部分，如以下示例所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>build</span>></span></span><br><span class=line>	<span class=tag><<span class=name>plugins</span>></span></span><br><span class=line>		<span class=tag><<span class=name>plugin</span>></span></span><br><span class=line>			<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>artifactId</span>></span>spring-boot-maven-plugin<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>plugin</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>plugins</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>build</span>></span></span><br></pre></table></figure><blockquote><p>如果您使用 Spring Boot 启动器的父 pom，则只需添加插件。除非您要更改父级中定义的设置，否则无需对其进行配置。</blockquote><h3 id=2-1-3、Gradle><a class=headerlink href=#2-1-3、Gradle title=2.1.3、Gradle></a>2.1.3、Gradle</h3><p>要了解有关将 Spring Boot 与 Gradle 结合使用的信息，请参阅 Spring Boot 的 Gradle 插件的文档：<ul><li>参考(<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/gradle-plugin/reference/html rel=noopener target=_blank>HTML</a>和<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/gradle-plugin/reference/pdf/spring-boot-gradle-plugin-reference.pdf rel=noopener target=_blank>PDF</a>)<li><a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/gradle-plugin/api rel=noopener target=_blank>API</a></ul><h3 id=2-1-4、Ant><a class=headerlink href=#2-1-4、Ant title=2.1.4、Ant></a>2.1.4、Ant</h3><p>可以使用 Apache Ant Ivy 构建 Spring Boot 项目。 <code>spring-boot-antlib</code>“ AntLib”模块也可用于帮助 Ant 创建可执行 jar。<p>要声明依赖关系，典型的<code>ivy.xml</code>文件看起来类似于以下示例：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>&LTivy-module version="2.0"></span><br><span class=line>	&LTinfo organisation="org.springframework.boot" module="spring-boot-sample-ant" /></span><br><span class=line>	&LTconfigurations></span><br><span class=line>		&LTconf name="compile" description="everything needed to compile this module" /></span><br><span class=line>		&LTconf name="runtime" extends="compile" description="everything needed to run this module" /></span><br><span class=line>	&LT/configurations></span><br><span class=line>	&LTdependencies></span><br><span class=line>		&LTdependency org="org.springframework.boot" name="spring-boot-starter"</span><br><span class=line>			rev="${spring-boot.version}" conf="compile" /></span><br><span class=line>	&LT/dependencies></span><br><span class=line>&LT/ivy-module></span><br></pre></table></figure><p>典型的<code>build.xml</code>类似于以下示例：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br></pre><td class=code><pre><span class=line>&LTproject</span><br><span class=line>	xmlns:ivy="antlib:org.apache.ivy.ant"</span><br><span class=line>	xmlns:spring-boot="antlib:org.springframework.boot.ant"</span><br><span class=line>	name="myapp" default="build"></span><br><span class=line></span><br><span class=line>	&LTproperty name="spring-boot.version" value="2.1.1.RELEASE" /></span><br><span class=line></span><br><span class=line>	&LTtarget name="resolve" description="--> retrieve dependencies with ivy"></span><br><span class=line>		&LTivy:retrieve pattern="lib/[conf]/[artifact]-[type]-[revision].[ext]" /></span><br><span class=line>	&LT/target></span><br><span class=line></span><br><span class=line>	&LTtarget name="classpaths" depends="resolve"></span><br><span class=line>		&LTpath id="compile.classpath"></span><br><span class=line>			&LTfileset dir="lib/compile" includes="*.jar" /></span><br><span class=line>		&LT/path></span><br><span class=line>	&LT/target></span><br><span class=line></span><br><span class=line>	&LTtarget name="init" depends="classpaths"></span><br><span class=line>		&LTmkdir dir="build/classes" /></span><br><span class=line>	&LT/target></span><br><span class=line></span><br><span class=line>	&LTtarget name="compile" depends="init" description="compile"></span><br><span class=line>		&LTjavac srcdir="src/main/java" destdir="build/classes" classpathref="compile.classpath" /></span><br><span class=line>	&LT/target></span><br><span class=line></span><br><span class=line>	&LTtarget name="build" depends="compile"></span><br><span class=line>		&LTspring-boot:exejar destfile="build/myapp.jar" classes="build/classes"></span><br><span class=line>			&LTspring-boot:lib></span><br><span class=line>				&LTfileset dir="lib/runtime" /></span><br><span class=line>			&LT/spring-boot:lib></span><br><span class=line>		&LT/spring-boot:exejar></span><br><span class=line>	&LT/target></span><br><span class=line>&LT/project></span><br></pre></table></figure><h3 id=2-1-5、Starters><a class=headerlink href=#2-1-5、Starters title=2.1.5、Starters></a>2.1.5、Starters</h3><p>Starter 程序是一组方便的依赖项 Descriptors，您可以在应用程序中包括它们。您可以一站式购买所需的所有 Spring 和相关技术，而不必遍历示例代码和依赖 Descriptors 的复制粘贴负载。例如，如果要开始使用 Spring 和 JPA 进行数据库访问，请在项目中包括<code>spring-boot-starter-data-jpa</code>依赖项。<p>Starter 程序包含许多启动项目并快速运行所需的依赖项，并且具有一组受支持的受管传递性依赖项。<blockquote><p>所有“官方”Starter 者都遵循类似的命名方式； <code>spring-boot-starter-*</code>，其中<code>*</code>是特定类型的应用程序。这种命名结构旨在在您需要寻找 Starter 者时提供帮助。许多 IDE 中的 Maven 集成使您可以按名称搜索依赖项。例如，在安装了适当的 Eclipse 或 STS 插件的情况下，您可以在 POM 编辑器中按<code>ctrl-space</code>并键入“ spring-boot-starter”以获取完整列表。<p>如“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-auto-configuration.html#boot-features-custom-starter rel=noopener target=_blank>创建自己的 Starter</a>”部分中所述，第三方启动程序不应以<code>spring-boot</code>开头，因为它是为官方 Spring Boot 工件保留的。而是，第三方启动程序通常以项目名称开头。例如，一个名为<code>thirdpartyproject</code>的第三方启动程序项目通常会被命名为<code>thirdpartyproject-spring-boot-starter</code>。</blockquote><p>Spring Boot 在<code>org.springframework.boot</code>组下提供了以下应用程序启动器：<p><strong>表 13.1. Spring Boot 应用程序启动器</strong><table><thead><tr><th>Name<th>Description<th>Pom<tbody><tr><td><code>spring-boot-starter</code><td>核心 Starter 工具，包括自动配置支持，日志记录和 YAML<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-activemq</code><td>使用 Apache ActiveMQ 的 JMS 消息传递 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-activemq/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-amqp</code><td>使用 Spring AMQP 和 Rabbit MQ 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-amqp/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-aop</code><td>使用 Spring AOP 和 AspectJ 进行面向方面编程的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-aop/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-artemis</code><td>使用 Apache Artemis 的 JMS 消息传递 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-artemis/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-batch</code><td>使用 Spring Batch 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-batch/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-cache</code><td>使用 Spring Framework 的缓存支持的 Starter 者<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-cache/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-cloud-connectors</code><td>使用 Spring Cloud Connectors 的 Starter 程序，可简化与 Cloud Foundry 和 Heroku 等云平台中服务的连接<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-cloud-connectors/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-cassandra</code><td>使用 Cassandra 分布式数据库和 Spring Data Cassandra 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-cassandra/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-cassandra-reactive</code><td>使用 Cassandra 分布式数据库和 Spring Data Cassandra Reactive 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-cassandra-reactive/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-couchbase</code><td>使用 Couchbase 面向文档的数据库和 Spring Data Couchbase 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-couchbase/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-couchbase-reactive</code><td>使用 Couchbase 面向文档的数据库和 Spring Data Couchbase Reactive 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-couchbase-reactive/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-elasticsearch</code><td>使用 Elasticsearch 搜索和分析引擎以及 Spring Data Elasticsearch 的 Starter 者<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-elasticsearch/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-jdbc</code><td>使用 Spring Data JDBC 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-jdbc/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-jpa</code><td>将 Spring Data JPA 与 Hibernate 结合使用的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-jpa/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-ldap</code><td>使用 Spring Data LDAP 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-ldap/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-mongodb</code><td>使用 MongoDB 面向文档的数据库和 Spring Data MongoDB 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-mongodb/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-mongodb-reactive</code><td>使用 MongoDB 面向文档的数据库和 Spring Data MongoDB Reactive 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-mongodb-reactive/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-neo4j</code><td>使用 Neo4j 图形数据库和 Spring Data Neo4j 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-neo4j/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-redis</code><td>使用 Redis 键值数据存储与 Spring Data Redis 和 Lettuce Client 端的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-redis/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-redis-reactive</code><td>将 Redis 键值数据存储与 Spring Data Redis Reacting 和 Lettuce Client 端一起使用的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-redis-reactive/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-rest</code><td>使用 Spring Data REST 在 REST 上公开 Spring Data 存储库的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-rest/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-data-solr</code><td>结合使用 Apache Solr 搜索平台和 Spring Data Solr 的 Starter 者<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-data-solr/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-freemarker</code><td>使用 FreeMarker 视图构建 MVC Web 应用程序的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-freemarker/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-groovy-templates</code><td>使用 Groovy 模板视图构建 MVC Web 应用程序的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-groovy-templates/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-hateoas</code><td>使用 Spring MVC 和 Spring HATEOAS 构建基于超媒体的 RESTful Web 应用程序的 Starter 者<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-hateoas/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-integration</code><td>使用 Spring Integration 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-integration/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-jdbc</code><td>结合使用 JDBC 和 HikariCP 连接池的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jdbc/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-jersey</code><td>使用 JAX-RS 和 Jersey 构建 RESTful Web 应用程序的 Starter。 <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#spring-boot-starter-web rel=noopener target=_blank>spring-boot-starter-web</a>的替代品<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jersey/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-jooq</code><td>使用 jOOQ 访问 SQL 数据库的 Starter。替代<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#spring-boot-starter-data-jpa rel=noopener target=_blank>spring-boot-starter-data-jpa</a>或<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#spring-boot-starter-jdbc rel=noopener target=_blank>spring-boot-starter-jdbc</a><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jooq/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-json</code><td>读写 JSON Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-json/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-jta-atomikos</code><td>使用 Atomikos 的 JTATransactionStarter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jta-atomikos/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-jta-bitronix</code><td>使用 Bitronix 的 JTATransactionStarter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jta-bitronix/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-mail</code><td>开始使用 Java Mail 和 Spring Framework 的电子邮件发送支持<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-mail/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-mustache</code><td>使用 Mustache 视图构建 Web 应用程序的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-mustache/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-oauth2-client</code><td>使用 Spring Security 的 OAuth2/OpenID Connect Client 端功能的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-oauth2-client/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-oauth2-resource-server</code><td>使用 Spring Security 的 OAuth2 资源服务器功能的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-oauth2-resource-server/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-quartz</code><td>Starter 使用 Quartz Scheduler<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-quartz/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-security</code><td>使用 Spring Security 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-security/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-test</code><td>用于使用包括 JUnit，Hamcrest 和 Mockito 在内的库测试 Spring Boot 应用程序的 Starter 程序<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-test/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-thymeleaf</code><td>使用 Thymeleaf 视图构建 MVC Web 应用程序的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-thymeleaf/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-validation</code><td>通过 Hibernate Validator 使用 Java Bean 验证的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-validation/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-web</code><td>使用 Spring MVC 构建 Web(包括 RESTful)应用程序的 Starter 者。使用 Tomcat 作为默认的嵌入式容器<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-web/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-web-services</code><td>使用 Spring Web Services 的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-web-services/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-webflux</code><td>使用 Spring Framework 的反应式 Web 支持构建 WebFlux 应用程序的 Starter 者<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-webflux/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-websocket</code><td>使用 Spring Framework 的 WebSocket 支持构建 WebSocket 应用程序的 Starter<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-websocket/pom.xml rel=noopener target=_blank>Pom</a></table><p>除应用程序启动程序外，以下启动程序还可用于添加* <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready.html rel=noopener target=_blank>production ready</a> *功能：<p><strong>表 13.2 Spring Boot 生产启动器</strong><table><thead><tr><th>Name<th>Description<th>Pom<tbody><tr><td><code>spring-boot-starter-actuator</code><td>使用 Spring Boot 的 Actuator 的 Starter 程序，它提供了生产就绪功能，可帮助您监视和 Management 应用程序<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-actuator/pom.xml rel=noopener target=_blank>Pom</a></table><p>最后，Spring Boot 还包括以下启动程序，如果您想排除或交换特定的技术方面，可以使用这些启动程序：<p><strong>表 13.3 Spring Boot 技术 Starter</strong><table><thead><tr><th>Name<th>Description<th>Pom<tbody><tr><td><code>spring-boot-starter-jetty</code><td>使用 Jetty 作为嵌入式 servlet 容器的 Starter 者。 <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#spring-boot-starter-tomcat rel=noopener target=_blank>spring-boot-starter-tomcat</a>的替代品<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-jetty/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-log4j2</code><td>使用 Log4j2 进行日志记录的启动器。 <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#spring-boot-starter-logging rel=noopener target=_blank>spring-boot-starter-logging</a>的替代品<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-log4j2/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-logging</code><td>使用 Logback 进行日志记录的启动器。默认记录启动器<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-logging/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-reactor-netty</code><td>使用 Reactor Netty 作为嵌入式反应式 HTTP 服务器的 Starter 者。<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-reactor-netty/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-tomcat</code><td>使用 Tomcat 作为嵌入式 servlet 容器的 Starter。 <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#spring-boot-starter-web rel=noopener target=_blank>spring-boot-starter-web</a>使用的默认 servlet 容器启动器<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-tomcat/pom.xml rel=noopener target=_blank>Pom</a><tr><td><code>spring-boot-starter-undertow</code><td>使用 Undertow 作为嵌入式 servlet 容器的 Starter。 <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html#spring-boot-starter-tomcat rel=noopener target=_blank>spring-boot-starter-tomcat</a>的替代品<td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-starters/spring-boot-starter-undertow/pom.xml rel=noopener target=_blank>Pom</a></table><h2 id=2-2、构建代码><a class=headerlink href=#2-2、构建代码 title=2.2、构建代码></a>2.2、构建代码</h2><p>Spring Boot 不需要任何特定的代码布局即可工作。但是，有一些最佳实践可以帮助您。<h3 id=2-2-1、使用-default-软件包><a title="2.2.1、使用 default 软件包" class=headerlink href=#2-2-1、使用-default-软件包></a>2.2.1、使用 default 软件包</h3><p>当一个类不包含<code>package</code>声明时，它将被视为在“默认包”中。通常不建议使用“默认程序包”，应避免使用。对于使用<code>@ComponentScan</code>，<code>@EntityScan</code>或<code>@SpringBootApplication</code>注解的 Spring Boot 应用程序，这可能会导致特定的问题，因为每个 jar 中的每个类都会被读取。<blockquote><p>我们建议您遵循 Java 建议的程序包命名约定，并使用反向域名(例如<code>com.example.project</code>)。</blockquote><h3 id=2-2-2、查找主应用程序类><a class=headerlink href=#2-2-2、查找主应用程序类 title=2.2.2、查找主应用程序类></a>2.2.2、查找主应用程序类</h3><p>我们通常建议您将主应用程序类放在其他类之上的根包中。 <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-using-springbootapplication-annotation.html rel=noopener target=_blank>@SpringBootApplication annotation</a>通常放在您的主类上，它隐式定义某些项目的基本“搜索包”。例如，如果您正在编写 JPA 应用程序，则使用<code>@SpringBootApplication</code>注解的类的包来搜索<code>@Entity</code>项。使用根软件包还允许组件扫描仅应用于您的项目。<p>以下 Lists 显示了典型的布局：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line>com</span><br><span class=line> +- example</span><br><span class=line>     +- myapplication</span><br><span class=line>         +- Application.java</span><br><span class=line>         |</span><br><span class=line>         +- customer</span><br><span class=line>         |   +- Customer.java</span><br><span class=line>         |   +- CustomerController.java</span><br><span class=line>         |   +- CustomerService.java</span><br><span class=line>         |   +- CustomerRepository.java</span><br><span class=line>         |</span><br><span class=line>         +- order</span><br><span class=line>             +- Order.java</span><br><span class=line>             +- OrderController.java</span><br><span class=line>             +- OrderService.java</span><br><span class=line>             +- OrderRepository.java</span><br></pre></table></figure><p><code>Application.java</code>文件将声明<code>main</code>方法以及基本的<code>@SpringBootApplication</code>，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.example.myapplication;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.boot.SpringApplication;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=line></span><br><span class=line><span class=meta>@SpringBootApplication</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Application</span> {</span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>		SpringApplication.run(Application.class, args);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h2 id=2-3、配置类><a class=headerlink href=#2-3、配置类 title=2.3、配置类></a>2.3、配置类</h2><p>Spring Boot 支持基于 Java 的配置。尽管可以将<code>SpringApplication</code>与 XML 源一起使用，但是我们通常建议您的主要源为单个<code>@Configuration</code>类。通常，定义<code>main</code>方法的类是主要<code>@Configuration</code>的不错的选择。<h3 id=2-3-1、导入其它配置类><a class=headerlink href=#2-3-1、导入其它配置类 title=2.3.1、导入其它配置类></a>2.3.1、导入其它配置类</h3><p>您无需将所有<code>@Configuration</code>都放在一个类中。 <code>@Import</code>注解可用于导入其他配置类。另外，您可以使用<code>@ComponentScan</code>自动拾取所有 Spring 组件，包括<code>@Configuration</code>类。<h3 id=2-3-2、导入XML配置><a class=headerlink href=#2-3-2、导入XML配置 title=2.3.2、导入XML配置></a>2.3.2、导入XML配置</h3><p>如果绝对必须使用基于 XML 的配置，我们建议您仍然从<code>@Configuration</code>类开始。然后，您可以使用<code>@ImportResource</code>注解来加载 XML 配置文件。<h2 id=2-4、Auto-configuration><a class=headerlink href=#2-4、Auto-configuration title=2.4、Auto-configuration></a>2.4、Auto-configuration</h2><p>Spring Boot 自动配置会尝试根据添加的 jar 依赖项自动配置 Spring 应用程序。例如，如果<code>HSQLDB</code>在 Classpath 上，并且您尚未手动配置任何数据库连接 bean，那么 Spring Boot 会自动配置内存数据库。<p>您需要通过向<code>@Configuration</code>类之一添加<code>@EnableAutoConfiguration</code>或<code>@SpringBootApplication</code>Comments 来选择自动配置。<blockquote><p>您只能添加一个<code>@SpringBootApplication</code>或<code>@EnableAutoConfiguration</code>Comments。通常，我们建议您仅将一个或另一个添加到主要的<code>@Configuration</code>类中。</blockquote><h3 id=2-4-1、逐步取代自动配置><a class=headerlink href=#2-4-1、逐步取代自动配置 title=2.4.1、逐步取代自动配置></a>2.4.1、逐步取代自动配置</h3><p>自动配置是非侵入性的。在任何时候，您都可以开始定义自己的配置，以替换自动配置的特定部分。例如，如果您添加自己的<code>DataSource</code> bean，则默认的嵌入式数据库支持将退出。<p>如果您需要找出当前正在应用的自动配置以及原因，请使用<code>--debug</code>开关启动您的应用程序。这样做可以启用调试日志以供选择核心 Logger，并将条件报告记录到控制台。<h3 id=2-4-2、禁用特定的自动配置类><a class=headerlink href=#2-4-2、禁用特定的自动配置类 title=2.4.2、禁用特定的自动配置类></a>2.4.2、禁用特定的自动配置类</h3><p>如果发现正在应用不需要的特定自动配置类，则可以使用<code>@EnableAutoConfiguration</code>的 exclude 属性禁用它们，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.boot.autoconfigure.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.autoconfigure.jdbc.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.*;</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyConfiguration</span> {</span><br><span class=line>}</span><br></pre></table></figure><p>如果该类不在 Classpath 中，则可以使用 Comments 的<code>excludeName</code>属性，并指定完全限定的名称。最后，您还可以使用<code>spring.autoconfigure.exclude</code>属性来控制要排除的自动配置类的列表。<h2 id=2-5、Spring-Bean和依赖注入><a title="2.5、Spring Bean和依赖注入" class=headerlink href=#2-5、Spring-Bean和依赖注入></a>2.5、Spring Bean和依赖注入</h2><p>您可以自由使用任何标准的 Spring Framework 技术来定义 bean 及其注入的依赖项。为简单起见，我们经常发现使用<code>@ComponentScan</code>(查找您的 bean)和使用<code>@Autowired</code>(进行构造函数注入)效果很好。<p>如果按照上面的建议构造代码(将应用程序类放在根包中)，则可以添加<code>@ComponentScan</code>而没有任何参数。您的所有应用程序组件(<code>@Component</code>，<code>@Service</code>，<code>@Repository</code>，<code>@Controller</code>等)都会自动注册为 Spring Bean。<p>以下示例显示了一个<code>@Service</code> Bean，它使用构造函数注入来获取所需的<code>RiskAssessor</code> bean：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.example.service;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Service;</span><br><span class=line></span><br><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DatabaseAccountService</span> <span class=keyword>implements</span> <span class="title class_">AccountService</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> RiskAssessor riskAssessor;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">DatabaseAccountService</span><span class=params>(RiskAssessor riskAssessor)</span> {</span><br><span class=line>		<span class=built_in>this</span>.riskAssessor = riskAssessor;</span><br><span class=line>	}</span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>如果 bean 具有一个构造函数，则可以省略<code>@Autowired</code>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DatabaseAccountService</span> <span class=keyword>implements</span> <span class="title class_">AccountService</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> RiskAssessor riskAssessor;</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">DatabaseAccountService</span><span class=params>(RiskAssessor riskAssessor)</span> {</span><br><span class=line>		<span class=built_in>this</span>.riskAssessor = riskAssessor;</span><br><span class=line>	}</span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><h2 id=2-6、使用-SpringBootApplication-Comments><a title="2.6、使用@SpringBootApplication Comments" class=headerlink href=#2-6、使用-SpringBootApplication-Comments></a>2.6、使用@SpringBootApplication Comments</h2><p>许多 Spring Boot 开发人员喜欢他们的应用程序使用自动配置，组件扫描，并能够在其“应用程序类”上定义额外的配置。单个<code>@SpringBootApplication</code>Comments 可用于启用这三个功能，即：<ul><li><code>@EnableAutoConfiguration</code>：启用<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-auto-configuration.html rel=noopener target=_blank>Spring Boot 的自动配置机制</a><li><code>@ComponentScan</code>：对应用程序所在的软件包启用<code>@Component</code>扫描(请参见<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-structuring-your-code.html rel=noopener target=_blank>最佳做法</a>)<li><code>@Configuration</code>：允许在上下文中注册额外的 bean 或导入其他配置类</ul><p><code>@SpringBootApplication</code>Comments 等效于将<code>@Configuration</code>，<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>及其默认属性一起使用，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.example.myapplication;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.boot.SpringApplication;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=line></span><br><span class=line><span class=meta>@SpringBootApplication</span> <span class=comment>// same as @Configuration @EnableAutoConfiguration @ComponentScan</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Application</span> {</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>		SpringApplication.run(Application.class, args);</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p><code>@SpringBootApplication</code>还提供别名以自定义<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>的属性。<p>这些功能都不是强制性的，您可以选择用它启用的任何功能替换此单个 Comments。例如，您可能不想在应用程序中使用组件扫描：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.example.myapplication;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.boot.SpringApplication;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.ComponentScan</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Configuration;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.Import;</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableAutoConfiguration</span></span><br><span class=line><span class=meta>@Import({ MyConfig.class, MyAnotherConfig.class })</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Application</span> {</span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>			SpringApplication.run(Application.class, args);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>在此示例中，<code>Application</code>就像其他任何 Spring Boot 应用程序一样，除了不会自动检测到<code>@Component</code>Comments 的类并且显式导入用户定义的 Bean(请参阅<code>@Import</code>)。</blockquote><h2 id=2-7、运行您的应用程序><a class=headerlink href=#2-7、运行您的应用程序 title=2.7、运行您的应用程序></a>2.7、运行您的应用程序</h2><h3 id=2-7-1、从IDE运行><a class=headerlink href=#2-7-1、从IDE运行 title=2.7.1、从IDE运行></a>2.7.1、从IDE运行</h3><p>您可以将 IDE 中的 Spring Boot 应用程序作为简单的 Java 应用程序运行。但是，您首先需要导入您的项目。导入步骤因您的 IDE 和构建系统而异。大多数 IDE 可以直接导入 Maven 项目。例如，Eclipse 用户可以从<code>File</code>菜单中选择<code>Import…</code>→<code>Existing Maven Projects</code>。<p>如果您不能直接将项目导入到 IDE 中，则可以使用构建插件来生成 IDE 元数据。 Maven 包括<a href=https://maven.apache.org/plugins/maven-eclipse-plugin/ rel=noopener target=_blank>Eclipse</a>和<a href=https://maven.apache.org/plugins/maven-idea-plugin/ rel=noopener target=_blank>IDEA</a>的插件。 Gradle 提供了<a href=https://docs.gradle.org/4.2.1/userguide/userguide.html rel=noopener target=_blank>various IDEs</a>的插件。<blockquote><p>如果不小心两次运行 Web 应用程序，则会看到“端口已在使用中”错误。 STS 用户可以使用<code>Relaunch</code>按钮而不是<code>Run</code>按钮来确保关闭任何现有实例。</blockquote><h3 id=2-7-2、作为打包的应用程序运行><a class=headerlink href=#2-7-2、作为打包的应用程序运行 title=2.7.2、作为打包的应用程序运行></a>2.7.2、作为打包的应用程序运行</h3><p>如果使用 Spring Boot Maven 或 Gradle 插件创建可执行 jar，则可以使用<code>java -jar</code>运行应用程序，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -jar target/myapplication-0.0.1-SNAPSHOT.jar</span></span><br></pre></table></figure><p>也可以在启用了远程调试支持的情况下运行打包的应用程序。这样做使您可以将调试器附加到打包的应用程序，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,<span class=built_in>suspend</span>=n \</span></span><br><span class=line><span class=language-bash>       -jar target/myapplication-0.0.1-SNAPSHOT.jar</span></span><br></pre></table></figure><h3 id=2-7-3、使用Maven插件><a class=headerlink href=#2-7-3、使用Maven插件 title=2.7.3、使用Maven插件></a>2.7.3、使用Maven插件</h3><p>Spring Boot Maven 插件包含一个<code>run</code>目标，可用于快速编译和运行您的应用程序。应用程序以爆炸形式运行，就像在 IDE 中一样。以下示例显示了运行 Spring Boot 应用程序的典型 Maven 命令：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>mvn spring-boot:run</span></span><br></pre></table></figure><p>您可能还想使用<code>MAVEN_OPTS</code>os 环境变量，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>export</span> MAVEN_OPTS=-Xmx1024m</span></span><br></pre></table></figure><h4 id=2-7-4、使用Gradle插件><a class=headerlink href=#2-7-4、使用Gradle插件 title=2.7.4、使用Gradle插件></a>2.7.4、使用Gradle插件</h4><p>Spring Boot Gradle 插件还包括一个<code>bootRun</code>任务，可用于以爆炸形式运行您的应用程序。每当您应用<code>org.springframework.boot</code>和<code>java</code>插件时，便会添加<code>bootRun</code>任务，并在以下示例中显示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>gradle bootRun</span></span><br></pre></table></figure><p>您可能还想使用<code>JAVA_OPTS</code>os 环境变量，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>export</span> JAVA_OPTS=-Xmx1024m</span></span><br></pre></table></figure><h3 id=2-7-5、热插拔><a class=headerlink href=#2-7-5、热插拔 title=2.7.5、热插拔></a>2.7.5、热插拔</h3><p>由于 Spring Boot 应用程序只是普通的 Java 应用程序，因此 JVM 热交换应该可以立即使用。 JVM 热插拔在一定程度上受到它可以替换的字节码的限制。要获得更完整的解决方案，可以使用<a href=https://zeroturnaround.com/software/jrebel/ rel=noopener target=_blank>JRebel</a>。<p><code>spring-boot-devtools</code>模块还包括对应用程序快速重启的支持。有关详细信息，请参见本文档相关部分。<h2 id=2-8、Developer-Tools><a title="2.8、Developer Tools" class=headerlink href=#2-8、Developer-Tools></a>2.8、Developer Tools</h2><p>Spring Boot 包括一组额外的工具，这些工具可以使应用程序开发体验更加愉快。 <code>spring-boot-devtools</code>模块可以包含在任何项目中，以提供其他开发时功能。要包括 devtools 支持，请将模块依赖项添加到您的构建中，如以下 Maven 和 Gradle Lists 所示：<p><strong>Maven.</strong><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>	<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>		<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>		<span class=tag><<span class=name>artifactId</span>></span>spring-boot-devtools<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>		<span class=tag><<span class=name>optional</span>></span>true<span class=tag>&LT/<span class=name>optional</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencies</span>></span></span><br></pre></table></figure><p><strong>Gradle.</strong><figure class="highlight groovy"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>configurations {</span><br><span class=line>	developmentOnly</span><br><span class=line>	runtimeClasspath {</span><br><span class=line>		extendsFrom developmentOnly</span><br><span class=line>	}</span><br><span class=line>}</span><br><span class=line>dependencies {</span><br><span class=line>	developmentOnly(<span class=string>"org.springframework.boot:spring-boot-devtools"</span>)</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>运行完全打包的应用程序时，将自动禁用开发人员工具。如果您的应用程序是从<code>java -jar</code>启动的，或者是从特殊的类加载器启动的，则将其视为“生产应用程序”。在 Maven 中将依赖项标记为可选，或在 Gradle 中使用自定义的“ developmentOnly”配置(如上所示)是一种最佳实践，它可以防止将 devtools 过渡地应用到使用项目的其他模块。<p>重新打包的存档默认情况下不包含 devtools。如果要使用<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-boot-devtools-remote rel=noopener target=_blank>某些远程 devtools 功能</a>，则需要禁用<code>excludeDevtools</code> build 属性以包括它。 Maven 和 Gradle 插件均支持该属性。</blockquote><h3 id=2-8-1、属性默认值><a class=headerlink href=#2-8-1、属性默认值 title=2.8.1、属性默认值></a>2.8.1、属性默认值</h3><p>Spring Boot 支持的一些库使用缓存来提高性能。例如，<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-spring-mvc-template-engines rel=noopener target=_blank>template engines</a>缓存已编译的模板，以避免重复分析模板文件。而且，Spring MVC 可以在提供静态资源时向响应添加 HTTP 缓存 Headers。<p>虽然缓存在 Producing 非常有益，但在开发过程中可能适得其反，从而使您无法看到刚刚在应用程序中所做的更改。因此，默认情况下，spring-boot-devtools 禁用缓存选项。<p>缓存选项通常由<code>application.properties</code>文件中的设置配置。例如，Thymeleaf 提供了<code>spring.thymeleaf.cache</code>属性。无需手动设置这些属性，<code>spring-boot-devtools</code>模块会自动应用合理的开发时配置。<p>由于在开发 Spring MVC 和 Spring WebFlux 应用程序时需要有关 Web 请求的更多信息，因此开发人员工具将为<code>web</code>日志记录组启用<code>DEBUG</code>日志记录。这将为您提供有关传入请求，正在处理的处理程序，响应结果等的信息。如果您希望记录所有请求详细信息(包括潜在的敏感信息)，则可以打开<code>spring.http.log-request-details</code>配置属性。<blockquote><p>如果您不希望应用属性默认值，则可以在<code>application.properties</code>中将<code>spring.devtools.add-properties</code>设置为<code>false</code>。<p>有关 devtools 应用的属性的完整列表，请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/env/DevToolsPropertyDefaultsPostProcessor.java rel=noopener target=_blank>DevToolsPropertyDefaultsPostProcessor</a>。</blockquote><h3 id=2-8-2、自动重启><a class=headerlink href=#2-8-2、自动重启 title=2.8.2、自动重启></a>2.8.2、自动重启</h3><p>每当 Classpath 上的文件更改时，使用<code>spring-boot-devtools</code>的应用程序都会自动重新启动。当在 IDE 中工作时，这可能是一个有用的功能，因为它为代码更改提供了非常快速的反馈循环。默认情况下，将监视 Classpath 上指向文件夹的任何条目的更改。请注意，某些资源，例如静态资产和视图模板<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-boot-devtools-restart-exclude rel=noopener target=_blank>不需要重新启动应用程序</a>。<blockquote><p>当 DevTools 监视 Classpath 资源时，触发重启的唯一方法是更新 Classpath。导致 Classpath 更新的方式取决于您使用的 IDE。在 Eclipse 中，保存修改后的文件将导致 Classpath 被更新并触发重新启动。在 IntelliJ IDEA 中，构建项目(<code>Build -> Build Project</code>)具有相同的效果。<p>只要启用了分叉，您还可以使用受支持的构建插件(Maven 和 Gradle)来启动应用程序，因为 DevTools 需要隔离的应用程序类加载器才能正常运行。默认情况下，Gradle 和 Maven 在 Classpath 上检测到 DevTools 时会这样做。<p>与 LiveReload 一起使用时，自动重新启动效果很好。 <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-boot-devtools-livereload rel=noopener target=_blank>请参阅“ LiveReload”部分</a>了解详情。如果使用 JRebel，则禁用自动重新启动，而有利于动态类重新加载。仍可以使用其他 devtools 功能(例如 LiveReload 和属性替代)。<p>DevTools 依靠应用程序上下文的关闭钩子在重新启动期间将其关闭。如果禁用了关机钩子(<code>SpringApplication.setRegisterShutdownHook(false)</code>)，它将无法正常工作。<p>在确定 Classpath 上的条目是否应在更改后触发重新启动时，DevTools 会自动忽略名为<code>spring-boot</code>，<code>spring-boot-devtools</code>，<code>spring-boot-autoconfigure</code>，<code>spring-boot-actuator</code>和<code>spring-boot-starter</code>的项目。<p>DevTools 需要自定义<code>ApplicationContext</code>使用的<code>ResourceLoader</code>。如果您的应用程序已经提供了，它将被包装。不支持在<code>ApplicationContext</code>上直接覆盖<code>getResource</code>方法。<p>Spring Boot 提供的重启技术通过使用两个类加载器来工作。不变的类(例如，来自第三方 jar 的类)将被加载到* base <em>类加载器中。您正在积极开发的类将加载到</em> restart <em>类加载器中。重新启动应用程序后，将丢弃</em> restart <em>类加载器，并创建一个新的类加载器。这种方法意味着应用程序的重启通常比“冷启动”要快得多，因为</em> base *类加载器已经可用并已填充。<p>如果您发现重新启动对于应用程序而言不够快，或者遇到类加载问题，则可以考虑从 ZeroTurnaround 重新加载诸如<a href=https://zeroturnaround.com/software/jrebel/ rel=noopener target=_blank>JRebel</a>之类的技术。这些方法通过在加载类时重写类来使其更易于重新加载。</blockquote><h4 id=2-8-2-1、记录条件评估中的更改><a class=headerlink href=#2-8-2-1、记录条件评估中的更改 title=2.8.2.1、记录条件评估中的更改></a>2.8.2.1、记录条件评估中的更改</h4><p>默认情况下，每次应用程序重新启动时，都会记录一个报告，其中显示了条件评估增量。该报告显示了在进行更改(例如添加或删除 bean 以及设置配置属性)时对应用程序自动配置的更改。<p>要禁用报告的日志记录，请设置以下属性：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.devtools.restart.log-condition-evaluation-delta=false</span><br></pre></table></figure><h4 id=2-8-2-2、排除资源><a class=headerlink href=#2-8-2-2、排除资源 title=2.8.2.2、排除资源></a>2.8.2.2、排除资源</h4><p>某些资源在更改时不一定需要触发重新启动。例如，Thymeleaf 模板可以就地编辑。默认情况下，更改<code>/META-INF/maven</code>，<code>/META-INF/resources</code>，<code>/resources</code>，<code>/static</code>，<code>/public</code>或<code>/templates</code>中的资源不会触发重新启动，但会触发<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-boot-devtools-livereload rel=noopener target=_blank>live reload</a>。如果要自定义这些排除项，则可以使用<code>spring.devtools.restart.exclude</code>属性。例如，要仅排除<code>/static</code>和<code>/public</code>，则可以设置以下属性：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.devtools.restart.exclude=static/**,public/**</span><br></pre></table></figure><blockquote><p>如果要保留这些默认值并“添加”其他排除项，请改用<code>spring.devtools.restart.additional-exclude</code>属性。</blockquote><h4 id=2-8-2-3、注意其它路径><a class=headerlink href=#2-8-2-3、注意其它路径 title=2.8.2.3、注意其它路径></a>2.8.2.3、注意其它路径</h4><p>当您对不在 Classpath 上的文件进行更改时，您可能希望重新启动或重新加载应用程序。为此，使用<code>spring.devtools.restart.additional-paths</code>属性配置其他路径以监视更改。您可以使用<code>spring.devtools.restart.exclude</code>属性<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-boot-devtools-restart-exclude rel=noopener target=_blank>described earlier</a>来控制其他路径下的更改是触发完全重启还是<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-boot-devtools-livereload rel=noopener target=_blank>live reload</a>。<h4 id=2-8-2-4、禁用重启><a class=headerlink href=#2-8-2-4、禁用重启 title=2.8.2.4、禁用重启></a>2.8.2.4、禁用重启</h4><p>如果您不想使用重新启动功能，则可以使用<code>spring.devtools.restart.enabled</code>属性将其禁用。在大多数情况下，您可以在<code>application.properties</code>中设置此属性(这样做仍会初始化重新启动类加载器，但它不会监视文件更改)。<p>如果您需要<em>完全</em>禁用重启支持(例如，因为它不适用于特定的库)，则需要在调用<code>SpringApplication.run(…)</code>之前将<code>spring.devtools.restart.enabled</code> <code>System</code>属性设置为<code>false</code>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>	System.setProperty(<span class=string>"spring.devtools.restart.enabled"</span>, <span class=string>"false"</span>);</span><br><span class=line>	SpringApplication.run(MyApp.class, args);</span><br><span class=line>}</span><br></pre></table></figure><h4 id=2-8-2-5、使用触发文件><a class=headerlink href=#2-8-2-5、使用触发文件 title=2.8.2.5、使用触发文件></a>2.8.2.5、使用触发文件</h4><p>如果使用持续编译更改文件的 IDE，则可能更喜欢仅在特定时间触发重新启动。为此，可以使用“触发文件”，这是一个特殊文件，当您要实际触发重新启动检查时必须对其进行修改。更改文件只会触发检查，并且仅在 Devtools 检测到必须执行某些操作时才会重新启动。可以手动或使用 IDE 插件来更新触发文件。<p>要使用触发文件，请将<code>spring.devtools.restart.trigger-file</code>属性设置为触发文件的路径。<blockquote><p>您可能希望将<code>spring.devtools.restart.trigger-file</code>设置为<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-boot-devtools-globalsettings rel=noopener target=_blank>global setting</a>，以便所有项目的行为都相同。</blockquote><h4 id=2-8-2-6、自定义重启类加载器><a class=headerlink href=#2-8-2-6、自定义重启类加载器 title=2.8.2.6、自定义重启类加载器></a>2.8.2.6、自定义重启类加载器</h4><p>如前面的<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-spring-boot-restart-vs-reload rel=noopener target=_blank>重新启动与重新加载</a>部分所述，重新启动功能是通过使用两个类加载器实现的。对于大多数应用程序，此方法效果很好。但是，有时可能会导致类加载问题。<p>默认情况下，IDE 中的任何打开的项目都将使用“重新启动”类加载器加载，而任何常规的<code>.jar</code>文件都将使用“基本”类加载器加载。如果您在多模块项目上工作，并且并非每个模块都导入到 IDE 中，则可能需要自定义内容。为此，您可以创建一个<code>META-INF/spring-devtools.properties</code>文件。<p><code>spring-devtools.properties</code>文件可以包含以<code>restart.exclude</code>和<code>restart.include</code>为前缀的属性。 <code>include</code>元素是应上拉到“重新启动”类加载器中的项目，而<code>exclude</code>元素是应下推到“基本”类加载器中的项目。该属性的值是一个应用于 Classpath 的正则表达式模式，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>restart.exclude.companycommonlibs=/mycorp-common-[\\w-]+\.jar</span><br><span class=line>restart.include.projectcommon=/mycorp-myproj-[\\w-]+\.jar</span><br></pre></table></figure><blockquote><p>所有属性键都必须是唯一的。只要属性以<code>restart.include.</code>或<code>restart.exclude.</code>开头，它就会被考虑。<p>Classpath 中的所有<code>META-INF/spring-devtools.properties</code>都已加载。您可以将文件打包在项目内部或项目使用的库中。</blockquote><h4 id=2-8-2-7、已知限制><a class=headerlink href=#2-8-2-7、已知限制 title=2.8.2.7、已知限制></a>2.8.2.7、已知限制</h4><p>重新启动功能不适用于使用标准<code>ObjectInputStream</code>反序列化的对象。如果需要反序列化数据，则可能需要结合使用 Spring 的<code>ConfigurableObjectInputStream</code>和<code>Thread.currentThread().getContextClassLoader()</code>。<p>不幸的是，一些第三方库在不考虑上下文类加载器的情况下反序列化。如果发现这样的问题，则需要向原始作者请求修复。<h3 id=2-8-3、LiveReload><a class=headerlink href=#2-8-3、LiveReload title=2.8.3、LiveReload></a>2.8.3、LiveReload</h3><p><code>spring-boot-devtools</code>模块包括一个嵌入式 LiveReload 服务器，该服务器可用于在更改资源时触发浏览器刷新。可从<a href=http://livereload.com/extensions/ rel=noopener target=_blank>livereload.com</a>免费为 Chrome，Firefox 和 Safari 使用 LiveReload 浏览器扩展。<p>如果您不想在应用程序运行时启动 LiveReload 服务器，则可以将<code>spring.devtools.livereload.enabled</code>属性设置为<code>false</code>。<blockquote><p>一次只能运行一台 LiveReload 服务器。在启动应用程序之前，请确保没有其他 LiveReload 服务器正在运行。如果从 IDE 启动多个应用程序，则只有第一个具有 LiveReload 支持。</blockquote><h3 id=2-8-4、全局设置><a class=headerlink href=#2-8-4、全局设置 title=2.8.4、全局设置></a>2.8.4、全局设置</h3><p>您可以通过将名为<code>.spring-boot-devtools.properties</code>的文件添加到<code>$HOME</code>文件夹中来配置全局 devtools 设置(请注意，文件名以“.”开头)。添加到该文件的所有属性都适用于您机器上所有使用 devtools 的 Spring Boot 应用程序。例如，要将重新启动配置为始终使用<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-boot-devtools-restart-triggerfile rel=noopener target=_blank>trigger file</a>，则应添加以下属性：<p><strong>~/.spring-boot-devtools.properties.</strong><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.devtools.reload.trigger-file=.reloadtrigger</span><br></pre></table></figure><blockquote><p>在<code>.spring-boot-devtools.properties</code>中激活的配置文件不会影响<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-external-config.html#boot-features-external-config-profile-specific-properties rel=noopener target=_blank>特定于配置文件的配置文件</a>的加载。</blockquote><h3 id=2-8-5、远程应用程序><a class=headerlink href=#2-8-5、远程应用程序 title=2.8.5、远程应用程序></a>2.8.5、远程应用程序</h3><p>Spring Boot 开发人员工具不仅限于本地开发。远程运行应用程序时，您还可以使用多种功能。选择加入远程支持。要启用它，您需要确保重新打包的 Files 中包含<code>devtools</code>，如以下 Lists 所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>build</span>></span></span><br><span class=line>	<span class=tag><<span class=name>plugins</span>></span></span><br><span class=line>		<span class=tag><<span class=name>plugin</span>></span></span><br><span class=line>			<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>artifactId</span>></span>spring-boot-maven-plugin<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>configuration</span>></span></span><br><span class=line>				<span class=tag><<span class=name>excludeDevtools</span>></span>false<span class=tag>&LT/<span class=name>excludeDevtools</span>></span></span><br><span class=line>			<span class=tag>&LT/<span class=name>configuration</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>plugin</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>plugins</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>build</span>></span></span><br></pre></table></figure><p>然后，您需要设置一个<code>spring.devtools.remote.secret</code>属性，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.devtools.remote.secret=mysecret</span><br></pre></table></figure><blockquote><p>在远程应用程序上启用<code>spring-boot-devtools</code>是安全隐患。您永远不应在生产部署上启用支持。</blockquote><p>远程 devtools 支持分为两部分：接受连接的服务器端端点和在 IDE 中运行的 Client 端应用程序。设置<code>spring.devtools.remote.secret</code>属性后，将自动启用服务器组件。Client 端组件必须手动启动。<h4 id=2-8-5-1、运行远程Client端应用程序><a class=headerlink href=#2-8-5-1、运行远程Client端应用程序 title=2.8.5.1、运行远程Client端应用程序></a>2.8.5.1、运行远程Client端应用程序</h4><p>远程 Client 端应用程序旨在在您的 IDE 中运行。您需要使用与您连接到的远程项目相同的 Classpath 来运行<code>org.springframework.boot.devtools.RemoteSpringApplication</code>。应用程序的单个必需参数是它连接到的远程 URL。<p>例如，如果您使用的是 Eclipse 或 STS，并且您有一个名为<code>my-app</code>的项目已部署到 Cloud Foundry，则可以执行以下操作：<ul><li>从<code>Run</code>菜单中选择<code>Run Configurations…</code>。<li>创建一个新的<code>Java Application</code>“启动配置”。<li>浏览<code>my-app</code>项目。<li>使用<code>org.springframework.boot.devtools.RemoteSpringApplication</code>作为主要类。<li>将<code>https://myapp.cfapps.io</code>添加到<code>Program arguments</code>(或任何远程 URL)。</ul><p>正在运行的远程 Client 端可能类似于以下 Lists：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line>.   ____          _                                              __ _ _</span><br><span class=line> /\\ / ___'_ __ _ _(_)_ __  __ _          ___               _      \ \ \ \</span><br><span class=line>( ( )\___ | '_ | '_| | '_ \/ _` |        | _ \___ _ __  ___| |_ ___ \ \ \ \</span><br><span class=line> \\/  ___)| |_)| | | | | || (_| []::::::[]   / -_) '  \/ _ \  _/ -_) ) ) ) )</span><br><span class=line>  '  |____| .__|_| |_|_| |_\__, |        |_|_\___|_|_|_\___/\__\___|/ / / /</span><br><span class=line> =========|_|==============|___/===================================/_/_/_/</span><br><span class=line> :: Spring Boot Remote :: 2.1.1.RELEASE</span><br><span class=line></span><br><span class=line>2015-06-10 18:25:06.632  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Starting RemoteSpringApplication on pwmbp with PID 14938 (/Users/pwebb/projects/spring-boot/code/spring-boot-devtools/target/classes started by pwebb in /Users/pwebb/projects/spring-boot/code/spring-boot-samples/spring-boot-sample-devtools)</span><br><span class=line>2015-06-10 18:25:06.671  INFO 14938 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.spring[emailprotected]2a17b7b6: startup date [Wed Jun 10 18:25:06 PDT 2015]; root of context hierarchy</span><br><span class=line>2015-06-10 18:25:07.043  WARN 14938 --- [           main] o.s.b.d.r.c.RemoteClientConfiguration    : The connection to http://localhost:8080 is insecure. You should use a URL starting with 'https://'.</span><br><span class=line>2015-06-10 18:25:07.074  INFO 14938 --- [           main] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port 35729</span><br><span class=line>2015-06-10 18:25:07.130  INFO 14938 --- [           main] o.s.b.devtools.RemoteSpringApplication   : Started RemoteSpringApplication in 0.74 seconds (JVM running for 1.105)</span><br></pre></table></figure><blockquote><p>因为远程 Client 端使用与真实应用程序相同的 Classpath，所以它可以直接读取应用程序属性。这就是读取<code>spring.devtools.remote.secret</code>属性并将其传递给服务器进行身份验证的方式。<p>始终建议使用<code>https://</code>作为连接协议，以便对通信进行加密并且不能截获密码。<p>如果需要使用代理来访问远程应用程序，请配置<code>spring.devtools.remote.proxy.host</code>和<code>spring.devtools.remote.proxy.port</code>属性。</blockquote><h4 id=2-8-5-2、远程更新><a class=headerlink href=#2-8-5-2、远程更新 title=2.8.5.2、远程更新></a>2.8.5.2、远程更新</h4><p>远程 Client 端以与<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-boot-devtools-restart rel=noopener target=_blank>local restart</a>相同的方式监视应用程序 Classpath 中的更改。任何更新的资源都被推送到远程应用程序，并且(<em>如果需要</em>)触发重新启动。如果您迭代使用本地没有的云服务的功能，这将很有帮助。通常，远程更新和重新启动比完整的重建和部署周期要快得多。<blockquote><p>仅在远程 Client 端正在运行时监视文件。如果在启动远程 Client 端之前更改文件，则不会将其推送到远程服务器。</blockquote><h2 id=2-9、包装您的生产申请><a class=headerlink href=#2-9、包装您的生产申请 title=2.9、包装您的生产申请></a>2.9、包装您的生产申请</h2><p>可执行 jar 可以用于生产部署。由于它们是独立的，因此它们也非常适合基于云的部署。<p>对于其他“生产准备就绪”功能，例如运行状况，审核和度量 REST 或 JMX 端点，请考虑添加<code>spring-boot-actuator</code>。有关详细信息，请参见* <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready.html rel=noopener target=_blank>“ Spring Boot Actuator：可用于生产的功能”</a> *。<h1 id=3、Spring-Boot功能><a title="3、Spring Boot功能" class=headerlink href=#3、Spring-Boot功能></a>3、Spring Boot功能</h1><h2 id=3-1、SpringApplication><a class=headerlink href=#3-1、SpringApplication title=3.1、SpringApplication></a>3.1、SpringApplication</h2><p><code>SpringApplication</code>类提供了一种方便的方法来引导从<code>main()</code>方法启动的 Spring 应用程序。在许多情况下，您可以委派给静态<code>SpringApplication.run</code>方法，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>public static void main(String[] args) {</span><br><span class=line>	SpringApplication.run(MySpringConfiguration.class, args);</span><br><span class=line>}</span><br></pre></table></figure><p>当您的应用程序启动时，您应该看到类似于以下输出的内容：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>.   ____          _            __ _ _</span><br><span class=line> /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class=line>( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \</span><br><span class=line> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class=line>  '  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class=line> =========|_|==============|___/=/_/_/_/</span><br><span class=line> :: Spring Boot ::   v2.1.1.RELEASE</span><br><span class=line></span><br><span class=line>2013-07-31 00:08:16.117  INFO 56603 --- [           main] o.s.b.s.app.SampleApplication            : Starting SampleApplication v0.1.0 on mycomputer with PID 56603 (/apps/myapp.jar started by pwebb)</span><br><span class=line>2013-07-31 00:08:16.166  INFO 56603 --- [           main] ationConfigServletWebServerApplicationContext : Refreshing org.springframework.boot.web.ser[emailprotected]6e5a8246: startup date [Wed Jul 31 00:08:16 PDT 2013]; root of context hierarchy</span><br><span class=line>2014-03-04 13:09:54.912  INFO 41370 --- [           main] .t.TomcatServletWebServerFactory : Server initialized with port: 8080</span><br><span class=line>2014-03-04 13:09:56.501  INFO 41370 --- [           main] o.s.b.s.app.SampleApplication            : Started SampleApplication in 2.992 seconds (JVM running for 3.658)</span><br></pre></table></figure><p>默认情况下，显示<code>INFO</code>条日志记录消息，包括一些相关的启动详细信息，例如启动该应用程序的用户。如果您需要<code>INFO</code>以外的其他日志级别，则可以按照<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-logging.html#boot-features-custom-log-levels rel=noopener target=_blank>第 26.4 节“日志级别”</a>中的说明进行设置。<h3 id=3-1-1、启动失败><a class=headerlink href=#3-1-1、启动失败 title=3.1.1、启动失败></a>3.1.1、启动失败</h3><p>如果您的应用程序无法启动，则已注册的<code>FailureAnalyzers</code>有机会提供专用的错误消息和解决该问题的具体措施。例如，如果您在端口<code>8080</code>上启动 Web 应用程序，并且该端口已在使用中，则应该看到类似于以下消息的内容：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>***************************</span><br><span class=line>APPLICATION FAILED TO START</span><br><span class=line>***************************</span><br><span class=line></span><br><span class=line>Description:</span><br><span class=line></span><br><span class=line>Embedded servlet container failed to start. Port 8080 was already in use.</span><br><span class=line></span><br><span class=line>Action:</span><br><span class=line></span><br><span class=line>Identify and stop the process that's listening on port 8080 or configure this application to listen on another</span><br></pre></table></figure><blockquote><p>Spring Boot 提供了众多的<code>FailureAnalyzer</code>实现，您可以<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/howto-spring-boot-application.html#howto-failure-analyzer rel=noopener target=_blank>添加自己的</a>。</blockquote><p>如果没有故障分析器能够处理该异常，您仍然可以显示完整情况报告，以更好地了解出了什么问题。为此，您需要<code>org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</code> <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-external-config.html rel=noopener target=_blank>启用调试属性</a>或<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-logging.html#boot-features-custom-log-levels rel=noopener target=_blank>启用调试日志记录</a>。<p>例如，如果您使用<code>java -jar</code>运行应用程序，则可以启用<code>debug</code>属性，如下所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -jar myproject-0.0.1-SNAPSHOT.jar --debug</span></span><br></pre></table></figure><h3 id=3-1-2、自定义banner><a class=headerlink href=#3-1-2、自定义banner title=3.1.2、自定义banner></a>3.1.2、自定义banner</h3><p>可以通过将<code>banner.txt</code>文件添加到 Classpath 或将<code>spring.banner.location</code>属性设置为此类文件的位置来更改启动时打印的 banner。如果文件的编码不是 UTF-8，则可以设置<code>spring.banner.charset</code>。除了文本文件之外，您还可以将<code>banner.gif</code>，<code>banner.jpg</code>或<code>banner.png</code>图像文件添加到 Classpath 或设置<code>spring.banner.image.location</code>属性。图像将转换为 ASCII 艺术作品并打印在任何文本 banner 上方。<p>在<code>banner.txt</code>文件中，您可以使用以下任何占位符：<p><strong>表 23.1 标语变量</strong><table><thead><tr><th>Variable<th>Description<tbody><tr><td><code>${application.version}</code><td><code>MANIFEST.MF</code>中声明的应用程序的版本号。例如，<code>Implementation-Version: 1.0</code>被打印为<code>1.0</code>。<tr><td><code>${application.formatted-version}</code><td>您的应用程序的版本号，以<code>MANIFEST.MF</code>声明，并设置为显示格式(用方括号括起来并以<code>v</code>作为前缀)。例如<code>(v1.0)</code>。<tr><td><code>${spring-boot.version}</code><td>您正在使用的 Spring Boot 版本。例如<code>2.1.1.RELEASE</code>。<tr><td><code>${spring-boot.formatted-version}</code><td>您正在使用的 Spring Boot 版本，已格式化以用于显示(用方括号括起来，并以<code>v</code>作为前缀)。例如<code>(v2.1.1.RELEASE)</code>。<tr><td><code>${Ansi.NAME}</code>(或<code>${AnsiColor.NAME}</code>，<code>${AnsiBackground.NAME}</code>，<code>${AnsiStyle.NAME}</code>)<td>其中<code>NAME</code>是 ANSI 转义代码的名称。有关详情，请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/ansi/AnsiPropertySource.java rel=noopener target=_blank>AnsiPropertySource</a>。<tr><td><code>${application.title}</code><td><code>MANIFEST.MF</code>中声明的应用程序标题。例如<code>Implementation-Title: MyApp</code>被打印为<code>MyApp</code>。</table><blockquote><p>如果要以编程方式生成 banner，则可以使用<code>SpringApplication.setBanner(…)</code>方法。使用<code>org.springframework.boot.Banner</code>接口并实现自己的<code>printBanner()</code>方法。</blockquote><p>您还可以使用<code>spring.main.banner-mode</code>属性来确定 banner 是否必须打印在<code>System.out</code>(<code>console</code>)上，发送到配置的 Logger(<code>log</code>)或根本不打印(<code>off</code>)。<p>打印的 banner 以以下名称注册为单例 bean：<code>springBootBanner</code>。<blockquote><p>YAML 将<code>off</code>Map 到<code>false</code>，因此，如果要在应用程序中禁用 banner，请确保添加引号，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>spring:</span><br><span class=line>	main:</span><br><span class=line>		banner-mode: "off"</span><br></pre></table></figure></blockquote><h3 id=3-1-3、自定义SpringApplication><a class=headerlink href=#3-1-3、自定义SpringApplication title=3.1.3、自定义SpringApplication></a>3.1.3、自定义SpringApplication</h3><p>如果您不喜欢默认的<code>SpringApplication</code>，则可以创建一个本地实例并对其进行自定义。例如，要关闭 banner，您可以编写：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>public static void main(String[] args) {</span><br><span class=line>	SpringApplication app = new SpringApplication(MySpringConfiguration.class);</span><br><span class=line>	app.setBannerMode(Banner.Mode.OFF);</span><br><span class=line>	app.run(args);</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>传递给<code>SpringApplication</code>的构造函数参数是 Spring bean 的配置源。在大多数情况下，这些是对<code>@Configuration</code>类的引用，但它们也可以是对 XML 配置或应扫描的程序包的引用。</blockquote><p>也可以通过使用<code>application.properties</code>文件来配置<code>SpringApplication</code>。<h3 id=3-1-4、Fluent-Builder-API><a title="3.1.4、Fluent Builder API" class=headerlink href=#3-1-4、Fluent-Builder-API></a>3.1.4、Fluent Builder API</h3><p>如果您需要构建<code>ApplicationContext</code>层次结构(具有父/子关系的多个上下文)，或者您更喜欢使用“Fluent 的”构建器 API，则可以使用<code>SpringApplicationBuilder</code>。<p><code>SpringApplicationBuilder</code>使您可以将多个方法调用链接在一起，并包括<code>parent</code>和<code>child</code>方法，这些方法使您可以创建层次结构，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>new</span> <span class="title class_">SpringApplicationBuilder</span>()</span><br><span class=line>		.sources(Parent.class)</span><br><span class=line>		.child(Application.class)</span><br><span class=line>		.bannerMode(Banner.Mode.OFF)</span><br><span class=line>		.run(args);</span><br></pre></table></figure><blockquote><p>创建<code>ApplicationContext</code>层次结构时有一些限制。例如，Web 组件 <strong>必须</strong> 包含在子上下文中，并且相同的<code>Environment</code>用于父上下文和子上下文。有关详细信息，请参见<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/builder/SpringApplicationBuilder.html rel=noopener target=_blank>SpringApplicationBuilder Javadoc</a>。</blockquote><h3 id=3-1-5、应用程序事件和侦听器><a class=headerlink href=#3-1-5、应用程序事件和侦听器 title=3.1.5、应用程序事件和侦听器></a>3.1.5、应用程序事件和侦听器</h3><p>除了通常的 Spring Framework 事件(例如<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/event/ContextRefreshedEvent.html rel=noopener target=_blank>ContextRefreshedEvent</a>)之外，<code>SpringApplication</code>还发送一些其他应用程序事件。<blockquote><p>有些事件实际上是在创建<code>ApplicationContext</code>之前触发的，因此您不能将这些事件注册为<code>@Bean</code>。您可以使用<code>SpringApplication.addListeners(…)</code>方法或<code>SpringApplicationBuilder.listeners(…)</code>方法注册它们。<p>如果希望这些监听器自动注册，而不管创建应用程序的方式如何，都可以将<code>META-INF/spring.factories</code>文件添加到项目中，并使用<code>org.springframework.context.ApplicationListener</code>键引用您的监听器，如以下示例所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>org.springframework.context.ApplicationListener=com.example.project.MyListener</span><br></pre></table></figure></blockquote><p>应用程序事件在您的应用程序运行时按以下 顺序 发送：<ul><li><code>ApplicationStartingEvent</code>在运行开始时但在进行任何处理之前(侦听器和初始化器的注册除外)发送。<li>当知道要在上下文中使用的<code>Environment</code>时但在创建上下文之前发送<code>ApplicationEnvironmentPreparedEvent</code>。<li>在刷新开始之前但在加载 bean 定义之后发送<code>ApplicationPreparedEvent</code>。<li>在刷新上下文之后但在调用任何应用程序和命令行运行程序之前发送<code>ApplicationStartedEvent</code>。<li>调用任何应用程序和命令行运行程序后，将发送<code>ApplicationReadyEvent</code>。它指示应用程序已准备就绪，可以处理请求。<li>如果启动时出现异常，则会发送<code>ApplicationFailedEvent</code>。</ul><blockquote><p>您通常不需要使用应用程序事件，但是很容易知道它们的存在。在内部，Spring Boot 使用事件来处理各种任务。</blockquote><p>应用程序事件是通过使用 Spring Framework 的事件发布机制发送的。此机制的一部分确保在子级上下文中发布给侦听器的事件也可以在任何祖先上下文中发布给侦听器。结果，如果您的应用程序使用<code>SpringApplication</code>实例的层次结构，则侦听器可能会收到同一类型的应用程序事件的多个实例。<p>为了使您的侦听器能够区分其上下文的事件和后代上下文的事件，它应请求注入其应用程序上下文，然后将注入的上下文与事件的上下文进行比较。可以通过实现<code>ApplicationContextAware</code>来注入上下文，或者如果侦听器是 bean，则可以通过使用<code>@Autowired</code>来注入上下文。<h3 id=3-1-6、Web环境><a class=headerlink href=#3-1-6、Web环境 title=3.1.6、Web环境></a>3.1.6、Web环境</h3><p><code>SpringApplication</code>尝试代表您创建正确的<code>ApplicationContext</code>类型。确定<code>WebApplicationType</code>的算法非常简单：<ul><li>如果存在 Spring MVC，则使用<code>AnnotationConfigServletWebServerApplicationContext</code><li>如果不存在 Spring MVC 且存在 Spring WebFlux，则使用<code>AnnotationConfigReactiveWebServerApplicationContext</code><li>否则，使用<code>AnnotationConfigApplicationContext</code></ul><p>这意味着，如果您在同一应用程序中使用 Spring MVC 和 Spring WebFlux 的新<code>WebClient</code>，则默认使用 Spring MVC。您可以通过调用<code>setWebApplicationType(WebApplicationType)</code>轻松覆盖它。<p>也可以完全控制通过调用<code>setApplicationContextClass(…)</code>所使用的<code>ApplicationContext</code>类型。<blockquote><p>在 JUnit 测试中使用<code>SpringApplication</code>时，通常希望调用<code>setWebApplicationType(WebApplicationType.NONE)</code>。</blockquote><h3 id=3-1-7、访问应用程序参数><a class=headerlink href=#3-1-7、访问应用程序参数 title=3.1.7、访问应用程序参数></a>3.1.7、访问应用程序参数</h3><p>如果您需要访问传递给<code>SpringApplication.run(…)</code>的应用程序参数，则可以注入<code>org.springframework.boot.ApplicationArguments</code> bean。 <code>ApplicationArguments</code>接口提供对原始<code>String[]</code>参数以及已解析的<code>option</code>和<code>non-option</code>参数的访问，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.boot.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.*;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(ApplicationArguments args)</span> {</span><br><span class=line>		<span class=type>boolean</span> <span class=variable>debug</span> <span class=operator>=</span> args.containsOption(<span class=string>"debug"</span>);</span><br><span class=line>		List&LTString> files = args.getNonOptionArgs();</span><br><span class=line>		<span class=comment>// if run with "--debug logfile.txt" debug=true, files=["logfile.txt"]</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>Spring Boot 还向 Spring <code>Environment</code>注册了一个<code>CommandLinePropertySource</code>。这样，您还可以使用<code>@Value</code>Comments 注入单个应用程序参数。</blockquote><h3 id=3-1-8、使用-ApplicationRunner-或-CommandLineRunner><a title="3.1.8、使用 ApplicationRunner 或 CommandLineRunner" class=headerlink href=#3-1-8、使用-ApplicationRunner-或-CommandLineRunner></a>3.1.8、使用 ApplicationRunner 或 CommandLineRunner</h3><p>如果在<code>SpringApplication</code>启动后需要运行一些特定的代码，则可以实现<code>ApplicationRunner</code>或<code>CommandLineRunner</code>接口。两个接口以相同的方式工作，并提供一个<code>run</code>方法，该方法在<code>SpringApplication.run(…)</code>完成之前被调用。<p><code>CommandLineRunner</code>接口以简单的字符串数组提供对应用程序参数的访问，而<code>ApplicationRunner</code>使用前面讨论的<code>ApplicationArguments</code>接口。以下示例显示使用<code>run</code>方法的<code>CommandLineRunner</code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.boot.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.*;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> <span class=keyword>implements</span> <span class="title class_">CommandLineRunner</span> {</span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">run</span><span class=params>(String... args)</span> {</span><br><span class=line>		<span class=comment>// Do something...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>如果定义了几个必须按特定 Sequences 调用的<code>CommandLineRunner</code>或<code>ApplicationRunner</code> bean，则可以另外实现<code>org.springframework.core.Ordered</code>接口或使用<code>org.springframework.core.annotation.Order</code>Comments。<h3 id=3-1-9、申请退出><a class=headerlink href=#3-1-9、申请退出 title=3.1.9、申请退出></a>3.1.9、申请退出</h3><p>每个<code>SpringApplication</code>向 JVM 注册一个关闭钩子，以确保<code>ApplicationContext</code>在退出时正常关闭。可以使用所有标准的 Spring 生命周期回调(例如<code>DisposableBean</code>接口或<code>@PreDestroy</code>注解)。<p>另外，如果 bean 希望在调用<code>SpringApplication.exit()</code>时返回特定的退出代码，则可以实现<code>org.springframework.boot.ExitCodeGenerator</code>接口。然后可以将此退出代码传递给<code>System.exit()</code>，以将其作为状态代码返回，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>@SpringBootApplication</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExitCodeApplication</span> {</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> ExitCodeGenerator <span class="title function_">exitCodeGenerator</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> () -> <span class=number>42</span>;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>System.exit(SpringApplication.exit(SpringApplication.run(ExitCodeApplication.class, args)));</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>此外，<code>ExitCodeGenerator</code>接口可能会通过异常实现。遇到此类异常时，Spring Boot 将返回已实现的<code>getExitCode()</code>方法提供的退出代码。<h3 id=3-1-10、管理员功能><a class=headerlink href=#3-1-10、管理员功能 title=3.1.10、管理员功能></a>3.1.10、管理员功能</h3><p>通过指定<code>spring.application.admin.enabled</code>属性，可以为应用程序启用与 Management 员相关的功能。这将在平台<code>MBeanServer</code>上公开<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/admin/SpringApplicationAdminMXBean.java rel=noopener target=_blank>SpringApplicationAdminMXBean</a>。您可以使用此功能来远程 Management Spring Boot 应用程序。对于任何服务包装器实现，此功能也可能很有用。<blockquote><p>如果您想知道应用程序在哪个 HTTP 端口上运行，请使用<code>local.server.port</code>键获取属性。<p>启用此功能时要小心，因为 MBean 公开了一种关闭应用程序的方法。</blockquote><h2 id=3-2、Externalized-Configuration><a title="3.2、Externalized Configuration" class=headerlink href=#3-2、Externalized-Configuration></a>3.2、Externalized Configuration</h2><p>Spring Boot 使您可以外部化配置，以便可以在不同环境中使用相同的应用程序代码。您可以使用属性文件，YAML 文件，环境变量和命令行参数来外部化配置。属性值可以使用<code>@Value</code>注解直接注入到您的 bean 中，可以通过 Spring 的<code>Environment</code>抽象访问，也可以是<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-external-config.html#boot-features-external-config-typesafe-configuration-properties rel=noopener target=_blank>绑定到结构化对象</a>到<code>@ConfigurationProperties</code>。<p>Spring Boot 使用一个非常特殊的<code>PropertySource</code>Sequences，该 Sequences 被设计为允许明智地覆盖值。按以下 Sequences 考虑属性：<ul><li>您的主目录上的<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html#using-boot-devtools-globalsettings rel=noopener target=_blank>Devtools 全局设置属性</a>(在 devtools 处于 Active 状态时为<code>~/.spring-boot-devtools.properties</code>)。<li><a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/test/context/TestPropertySource.html rel=noopener target=_blank>@TestPropertySource</a>您的测试 Comments。<li>测试中的<code>properties</code>属性。在<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/test/context/SpringBootTest.html rel=noopener target=_blank>@SpringBootTest</a>和<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests rel=noopener target=_blank>测试 Comments 以测试应用程序的特定部分</a>上可用。<li>命令行参数。<li><code>SPRING_APPLICATION_JSON</code>中的属性(嵌入在环境变量或系统属性中的内联 JSON)。<li><code>ServletConfig</code>个初始化参数。<li><code>ServletContext</code>个初始化参数。<li>来自<code>java:comp/env</code>的 JNDI 属性。<li>Java 系统属性(<code>System.getProperties()</code>)。<li>os 环境变量。<li>仅在<code>random.*</code>中具有属性的<code>RandomValuePropertySource</code>。<li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-external-config.html#boot-features-external-config-profile-specific-properties rel=noopener target=_blank>特定于配置文件的应用程序属性</a>在打包的 jar 之外(<code>application-{profile}.properties</code>和 YAML 变体)。<li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-external-config.html#boot-features-external-config-profile-specific-properties rel=noopener target=_blank>特定于配置文件的应用程序属性</a>包装在 jar 中(<code>application-{profile}.properties</code>和 YAML 变体)。<li>打包的 jar 之外的应用程序属性(<code>application.properties</code>和 YAML 变体)。<li>打包在 jar 中的应用程序属性(<code>application.properties</code>和 YAML 变体)。<li><code>@Configuration</code>个类上的<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/context/annotation/PropertySource.html rel=noopener target=_blank>@PropertySource</a>条 Comments。<li>默认属性(通过设置<code>SpringApplication.setDefaultProperties</code>指定)。</ul><p>为了提供一个具体的示例，假设您开发一个使用<code>name</code>属性的<code>@Component</code>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.stereotype.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.*;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>    <span class=meta>@Value("${name}")</span></span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>在您的应用程序 Classpath 上(例如，在 jar 内)，您可以拥有一个<code>application.properties</code>文件，该文件为<code>name</code>提供了合理的默认属性值。在新环境中运行时，可以在 jar 外部提供<code>application.properties</code>文件，该文件将覆盖<code>name</code>。对于一次性测试，可以使用特定的命令行开关(例如<code>java -jar app.jar --name="Spring"</code>)启动。<blockquote><p><code>SPRING_APPLICATION_JSON</code>属性可以在命令行中提供环境变量。例如，您可以在 UN * X shell 中使用以下行：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>SPRING_APPLICATION_JSON=<span class=string>'{"acme":{"name":"test"}}'</span> java -jar myapp.jar</span></span><br></pre></table></figure><p>在前面的示例中，您在 Spring<code>Environment</code>中以<code>acme.name=test</code>结尾。您还可以在 System 属性中以<code>spring.application.json</code>的形式提供 JSON，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -Dspring.application.json=<span class=string>'{"name":"test"}'</span> -jar myapp.jar</span></span><br></pre></table></figure><p>您还可以使用命令行参数来提供 JSON，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -jar myapp.jar --spring.application.json=<span class=string>'{"name":"test"}'</span></span></span><br></pre></table></figure><p>您还可以将 JSON 作为 JNDI 变量提供，如下所示：<code>java:comp/env/spring.application.json</code>。</blockquote><h3 id=3-2-1、配置随机值><a class=headerlink href=#3-2-1、配置随机值 title=3.2.1、配置随机值></a>3.2.1、配置随机值</h3><p><code>RandomValuePropertySource</code>可用于注入随机值(例如，Importing 到机密或测试用例中)。它可以产生整数，longs，uuid 或字符串，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>my.secret=${random.value}</span><br><span class=line>my.number=${random.int}</span><br><span class=line>my.bignumber=${random.long}</span><br><span class=line>my.uuid=${random.uuid}</span><br><span class=line>my.number.less.than.ten=${random.int(10)}</span><br><span class=line>my.number.in.range=${random.int[1024,65536]}</span><br></pre></table></figure><p><code>random.int*</code>语法为<code>OPEN value (,max) CLOSE</code>，其中<code>OPEN,CLOSE</code>是任何字符，而<code>value,max</code>是整数。如果提供<code>max</code>，则<code>value</code>是最小值，而<code>max</code>是最大值(不包括)。<h3 id=3-2-2、访问命令行属性><a class=headerlink href=#3-2-2、访问命令行属性 title=3.2.2、访问命令行属性></a>3.2.2、访问命令行属性</h3><p>默认情况下，<code>SpringApplication</code>将任何命令行选项参数(即以<code>--</code>开头的参数，例如<code>--server.port=9000</code>)转换为<code>property</code>并将其添加到 Spring <code>Environment</code>。如前所述，命令行属性始终优先于其他属性源。<p>如果您不想将命令行属性添加到<code>Environment</code>，则可以使用<code>SpringApplication.setAddCommandLineProperties(false)</code>禁用它们。<h3 id=3-2-3、应用程序属性文件><a class=headerlink href=#3-2-3、应用程序属性文件 title=3.2.3、应用程序属性文件></a>3.2.3、应用程序属性文件</h3><p><code>SpringApplication</code>从以下位置的<code>application.properties</code>文件中加载属性，并将它们添加到 Spring <code>Environment</code>中：<ul><li>当前目录的<code>/config</code>子目录<li>当前目录<li>Classpath<code>/config</code>包<li>Classpath 根</ul><p>该列表按优先级排序(在列表较高位置定义的属性会覆盖在较低位置定义的属性)。<blockquote><p>您也可以<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-external-config.html#boot-features-external-config-yaml rel=noopener target=_blank>使用 YAML(‘.yml’)文件</a>替代“ .properties”。</blockquote><p>如果您不喜欢<code>application.properties</code>作为配置文件名，则可以通过指定<code>spring.config.name</code>环境属性来切换到另一个文件名。您还可以使用<code>spring.config.location</code>环境属性(这是目录位置或文件路径的逗号分隔列表)来引用显式位置。下面的示例演示如何指定其他文件名：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -jar myproject.jar --spring.config.name=myproject</span></span><br></pre></table></figure><p>下面的示例演示如何指定两个位置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -jar myproject.jar --spring.config.location=classpath:/default.properties,classpath:/override.propertie</span></span><br></pre></table></figure><blockquote><p><code>spring.config.name</code>和<code>spring.config.location</code>很早就用于确定必须加载哪些文件，因此必须将它们定义为环境属性(通常是 OS 环境变量，系统属性或命令行参数)。</blockquote><p>如果<code>spring.config.location</code>包含目录(而不是文件)，则它们应以<code>/</code>结尾(并且在运行时，应在加载之前附加从<code>spring.config.name</code>生成的名称，包括特定于配置文件的文件名)。 <code>spring.config.location</code>中指定的文件按原样使用，不支持特定于配置文件的变体，并且被任何特定于配置文件的属性覆盖。<p>配置位置以相反的 Sequences 搜索。默认情况下，配置的位置是<code>classpath:/,classpath:/config/,file:./,file:./config/</code>。结果搜索 Sequences 如下：<ul><li><code>file:./config/</code><li><code>file:./</code><li><code>classpath:/config/</code><li><code>classpath:/</code></ul><p>使用<code>spring.config.location</code>配置自定义配置位置后，它们将替换默认位置。例如，如果将<code>spring.config.location</code>配置为值<code>classpath:/custom-config/,file:./custom-config/</code>，则搜索 Sequences 如下：<ul><li><code>file:./custom-config/</code><li><code>classpath:custom-config/</code></ul><p>或者，当使用<code>spring.config.additional-location</code>配置自定义配置位置时，除默认位置外还使用它们。在默认位置之前搜索其他位置。例如，如果配置了<code>classpath:/custom-config/,file:./custom-config/</code>的其他位置，则搜索 Sequences 如下：<ul><li><code>file:./custom-config/</code><li><code>classpath:custom-config/</code><li><code>file:./config/</code><li><code>file:./</code><li><code>classpath:/config/</code><li><code>classpath:/</code></ul><p>通过此搜索 Sequences，您可以在一个配置文件中指定默认值，然后在另一个配置文件中有选择地覆盖这些值。您可以在默认位置之一的<code>application.properties</code>(或使用<code>spring.config.name</code>选择的其他任何基本名称)中为应用程序提供默认值。然后，可以在运行时使用自定义位置之一中的其他文件覆盖这些默认值。<blockquote><p>如果使用环境变量而不是系统属性，则大多数 os 都不允许使用句点分隔的键名，但可以使用下划线代替(例如，<code>SPRING_CONFIG_NAME</code>代替<code>spring.config.name</code>)。<p>如果您的应用程序在容器中运行，则可以使用 JNDI 属性(在<code>java:comp/env</code>中)或 servlet 上下文初始化参数来代替环境变量或系统属性，也可以使用它们。</blockquote><h3 id=3-2-4、特定于配置文件的属性><a class=headerlink href=#3-2-4、特定于配置文件的属性 title=3.2.4、特定于配置文件的属性></a>3.2.4、特定于配置文件的属性</h3><p>除了<code>application.properties</code>个文件之外，还可以使用以下命名约定来定义特定于配置文件的属性：<code>application-{profile}.properties</code>。 <code>Environment</code>具有一组默认配置文件(默认情况下为<code>[default]</code>)，如果未设置任何 Active 配置文件，则使用这些配置文件。换句话说，如果未显式激活任何配置文件，则将加载<code>application-default.properties</code>中的属性。<p>特定于配置文件的属性是从与标准<code>application.properties</code>相同的位置加载的，特定于配置文件的文件总是会覆盖非特定文件，无论特定于配置文件的文件是在打包 jar 的内部还是外部。<p>如果指定了多个配置文件，则采用后赢策略。例如，由<code>spring.profiles.active</code>属性指定的配置文件将添加到通过<code>SpringApplication</code> API 配置的配置文件之后，因此具有优先权。<blockquote><p>如果您在<code>spring.config.location</code>中指定了任何文件，则不会考虑这些文件的特定于配置文件的变体。如果您还想使用特定于配置文件的属性，请使用<code>spring.config.location</code>中的目录。</blockquote><h3 id=3-2-5、属性中的占位符><a class=headerlink href=#3-2-5、属性中的占位符 title=3.2.5、属性中的占位符></a>3.2.5、属性中的占位符</h3><p><code>application.properties</code>中的值在使用时会通过现有的<code>Environment</code>进行过滤，因此您可以参考以前定义的值(例如，从“系统”属性中)。<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>app.name</span>=<span class=string>MyApp</span></span><br><span class=line><span class=attr>app.description</span>=<span class=string>${app.name} is a Spring Boot application</span></span><br></pre></table></figure><blockquote><p>您还可以使用此技术来创建现有 Spring Boot 属性的“简短”变体。</blockquote><h3 id=3-2-6、加密属性><a class=headerlink href=#3-2-6、加密属性 title=3.2.6、加密属性></a>3.2.6、加密属性</h3><p>Spring Boot 不提供对加密属性值的任何内置支持，但是，它确实提供了修改 Spring <code>Environment</code>中包含的值所必需的钩子点。 <code>EnvironmentPostProcessor</code>界面允许您在应用程序启动之前操纵<code>Environment</code>。<p>如果您正在寻找一种安全的方式来存储凭据和密码，则<a href=https://cloud.spring.io/spring-cloud-vault/ rel=noopener target=_blank>Spring Cloud Vault</a>项目提供了对将外部化配置存储在<a href=https://www.vaultproject.io/ rel=noopener target=_blank>HashiCorp Vault</a>中的支持。<h3 id=3-2-7、使用YAML代替属性><a class=headerlink href=#3-2-7、使用YAML代替属性 title=3.2.7、使用YAML代替属性></a>3.2.7、使用YAML代替属性</h3><p><a href=http://yaml.org/ rel=noopener target=_blank>YAML</a>是 JSON 的超集，因此是一种用于指定层次结构配置数据的便捷格式。只要在 Classpath 上具有<a href=http://www.snakeyaml.org/ rel=noopener target=_blank>SnakeYAML</a>库，<code>SpringApplication</code>类就会自动支持 YAML 作为属性的替代方法。<blockquote><p>如果您使用“Starter”，则<code>spring-boot-starter</code>自动提供 SnakeYAML。</blockquote><h4 id=3-2-7-1、加载YAML><a class=headerlink href=#3-2-7-1、加载YAML title=3.2.7.1、加载YAML></a>3.2.7.1、加载YAML</h4><p>Spring Framework 提供了两个方便的类，可用于加载 YAML 文档。 <code>YamlPropertiesFactoryBean</code>将 YAML 加载为<code>Properties</code>，而<code>YamlMapFactoryBean</code>将 YAML 加载为<code>Map</code>。<p>例如，考虑以下 YAML 文档：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=attr>environments:</span></span><br><span class=line>	<span class=attr>dev:</span></span><br><span class=line>		<span class=attr>url:</span> <span class=string>http://dev.example.com</span></span><br><span class=line>		<span class=attr>name:</span> <span class=string>Developer</span> <span class=string>Setup</span></span><br><span class=line>	<span class=attr>prod:</span></span><br><span class=line>		<span class=attr>url:</span> <span class=string>http://another.example.com</span></span><br><span class=line>		<span class=attr>name:</span> <span class=string>My</span> <span class=string>Cool</span> <span class=string>App</span></span><br></pre></table></figure><p>前面的示例将转换为以下属性：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=attr>environments.dev.url</span>=<span class=string>http://dev.example.com</span></span><br><span class=line><span class=attr>environments.dev.name</span>=<span class=string>Developer Setup</span></span><br><span class=line><span class=attr>environments.prod.url</span>=<span class=string>http://another.example.com</span></span><br><span class=line><span class=attr>environments.prod.name</span>=<span class=string>My Cool App</span></span><br></pre></table></figure><p>YAML 列表表示为带有<code>[index]</code>解引用器的属性键。例如，考虑以下 YAML：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=attr>my:</span></span><br><span class=line>    <span class=attr>servers:</span></span><br><span class=line>        <span class=bullet>-</span> <span class=string>dev.example.com</span></span><br><span class=line>        <span class=bullet>-</span> <span class=string>another.example.com</span></span><br></pre></table></figure><p>前面的示例将转换为以下属性：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>my.servers[0]</span>=<span class=string>dev.example.com</span></span><br><span class=line><span class=attr>my.servers[1]</span>=<span class=string>another.example.com</span></span><br></pre></table></figure><p>要使用 Spring Boot 的<code>Binder</code>Util(即<code>@ConfigurationProperties</code>所做的)绑定到类似的属性，您需要在<code>java.util.List</code>(或<code>Set</code>)类型的目标 bean 中具有一个属性，并且需要提供 setter 或使用 a 初始化它。可变值。例如，以下示例绑定到前面显示的属性：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@ConfigurationProperties(prefix="my")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Config</span> {</span><br><span class=line>	<span class=keyword>private</span> List&LTString> servers = <span class=keyword>new</span> <span class="title class_">ArrayList</span>&LTString>();</span><br><span class=line>	<span class=keyword>public</span> List&LTString> <span class="title function_">getServers</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.servers;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-2-7-2、在Spring中将YAML公开为属性><a class=headerlink href=#3-2-7-2、在Spring中将YAML公开为属性 title=3.2.7.2、在Spring中将YAML公开为属性></a>3.2.7.2、在Spring中将YAML公开为属性</h4><p><code>YamlPropertySourceLoader</code>类可用于在 Spring <code>Environment</code>中将 YAML 公开为<code>PropertySource</code>。这样做使您可以将<code>@Value</code>Comments 与占位符语法一起使用以访问 YAML 属性。<h4 id=3-2-7-3、多配置文件YAML文档><a class=headerlink href=#3-2-7-3、多配置文件YAML文档 title=3.2.7.3、多配置文件YAML文档></a>3.2.7.3、多配置文件YAML文档</h4><p>您可以使用<code>spring.profiles</code>键在一个文件中指定多个特定于配置文件的 YAML 文档，以指示何时应用该文档，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>server:</span><br><span class=line>	address: 192.168.1.100</span><br><span class=line>---</span><br><span class=line>spring:</span><br><span class=line>	profiles: development</span><br><span class=line>server:</span><br><span class=line>	address: 127.0.0.1</span><br><span class=line>---</span><br><span class=line>spring:</span><br><span class=line>	profiles: production & eu-central</span><br><span class=line>server:</span><br><span class=line>	address: 192.168.1.120</span><br></pre></table></figure><p>在前面的示例中，如果<code>development</code>配置文件处于 Active 状态，则<code>server.address</code>属性为<code>127.0.0.1</code>。同样，如果<code>production</code>和<code>eu-central</code>配置文件处于 Active 状态，则<code>server.address</code>属性为<code>192.168.1.120</code>。如果<code>development</code>，<code>production</code>和<code>eu-central</code>配置文件未启用，则该属性的值为<code>192.168.1.100</code>。<blockquote><p>因此<code>spring.profiles</code>可以包含一个简单的配置文件名称(例如<code>production</code>)或一个配置文件表达式。配置文件表达式允许表达更复杂的配置文件逻辑，例如<code>production & (eu-central | eu-west)</code>。查看<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/core.html#beans-definition-profiles-java rel=noopener target=_blank>reference guide</a>以获取更多详细信息。</blockquote><p>如果在启动应用程序上下文时未明确激活任何 Active，则会激活默认配置文件。因此，在以下 YAML 中，我们为<code>spring.security.user.password</code>设置了一个值，该值在”default”配置文件中仅**可用：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=attr>server:</span></span><br><span class=line>  <span class=attr>port:</span> <span class=number>8000</span></span><br><span class=line><span class=meta>---</span></span><br><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>profiles:</span> <span class=string>default</span></span><br><span class=line>  <span class=attr>security:</span></span><br><span class=line>    <span class=attr>user:</span></span><br><span class=line>      <span class=attr>password:</span> <span class=string>weak</span></span><br></pre></table></figure><p>而在以下示例中，始终设置密码是因为该密码未附加到任何配置文件，并且必须根据需要在所有其他配置文件中将其显式重置：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=attr>server:</span></span><br><span class=line>  <span class=attr>port:</span> <span class=number>8000</span></span><br><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>security:</span></span><br><span class=line>    <span class=attr>user:</span></span><br><span class=line>      <span class=attr>password:</span> <span class=string>weak</span></span><br></pre></table></figure><p>通过使用<code>spring.profiles</code>元素指定的 Spring 轮廓可以选择通过使用<code>!</code>字符来否定。如果为单个文档同时指定了否定的配置文件和否定的配置文件，则至少一个非否定的配置文件必须匹配，并且否定的配置文件不能匹配。<h4 id=3-2-7-4、YAML缺点><a class=headerlink href=#3-2-7-4、YAML缺点 title=3.2.7.4、YAML缺点></a>3.2.7.4、YAML缺点</h4><p>无法使用<code>@PropertySource</code>Comments 加载 YAML 文件。因此，在需要以这种方式加载值的情况下，需要使用属性文件。<h3 id=3-2-8、类型安全的配置属性><a class=headerlink href=#3-2-8、类型安全的配置属性 title=3.2.8、类型安全的配置属性></a>3.2.8、类型安全的配置属性</h3><p>使用<code>@Value("${property}")</code>注解注入配置属性有时会很麻烦，尤其是当您使用多个属性或数据本质上是分层的时。 Spring Boot 提供了一种使用属性的替代方法，该方法使强类型的 Bean 可以 Management 和验证应用程序的配置，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.example;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.net.InetAddress;</span><br><span class=line><span class=keyword>import</span> java.util.ArrayList;</span><br><span class=line><span class=keyword>import</span> java.util.Collections;</span><br><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=line></span><br><span class=line><span class=meta>@ConfigurationProperties("acme")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AcmeProperties</span> {</span><br><span class=line></span><br><span class=line>	<span class=keyword>private</span> <span class=type>boolean</span> enabled;</span><br><span class=line></span><br><span class=line>	<span class=keyword>private</span> InetAddress remoteAddress;</span><br><span class=line></span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> <span class=type>Security</span> <span class=variable>security</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Security</span>();</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">isEnabled</span><span class=params>()</span> { ... }</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setEnabled</span><span class=params>(<span class=type>boolean</span> enabled)</span> { ... }</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> InetAddress <span class="title function_">getRemoteAddress</span><span class=params>()</span> { ... }</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setRemoteAddress</span><span class=params>(InetAddress remoteAddress)</span> { ... }</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> Security <span class="title function_">getSecurity</span><span class=params>()</span> { ... }</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">Security</span> {</span><br><span class=line></span><br><span class=line>		<span class=keyword>private</span> String username;</span><br><span class=line></span><br><span class=line>		<span class=keyword>private</span> String password;</span><br><span class=line></span><br><span class=line>		<span class=keyword>private</span> List&LTString> roles = <span class=keyword>new</span> <span class="title class_">ArrayList</span><>(Collections.singleton(<span class=string>"USER"</span>));</span><br><span class=line></span><br><span class=line>		<span class=keyword>public</span> String <span class="title function_">getUsername</span><span class=params>()</span> { ... }</span><br><span class=line></span><br><span class=line>		<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setUsername</span><span class=params>(String username)</span> { ... }</span><br><span class=line></span><br><span class=line>		<span class=keyword>public</span> String <span class="title function_">getPassword</span><span class=params>()</span> { ... }</span><br><span class=line></span><br><span class=line>		<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setPassword</span><span class=params>(String password)</span> { ... }</span><br><span class=line></span><br><span class=line>		<span class=keyword>public</span> List&LTString> <span class="title function_">getRoles</span><span class=params>()</span> { ... }</span><br><span class=line></span><br><span class=line>		<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setRoles</span><span class=params>(List&LTString> roles)</span> { ... }</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>前面的 POJO 定义了以下属性：<ul><li><code>acme.enabled</code>，默认值为<code>false</code>。<li><code>acme.remote-address</code>，其类型可以从<code>String</code>强制转换。<li><code>acme.security.username</code>，带有嵌套的“安全”对象，其名称由属性名称确定。特别是，返回类型在那里根本不使用，可能是<code>SecurityProperties</code>。<li><code>acme.security.password</code> .<li><code>acme.security.roles</code>，集合为<code>String</code>。</ul><blockquote><p>Getter 和 Setter 通常是强制性的，因为绑定是通过标准 Java Beans 属性 Descriptors 进行的，就像在 Spring MVC 中一样。在以下情况下，可以忽略二传手：<ul><li>只要将 Map 初始化，它们就需要使用吸气剂，但不一定需要使用 setter，因为它们可以被 Binder 改变。<li>可以通过索引(通常使用 YAML)或使用单个逗号分隔的值(属性)来访问集合和数组。在后一种情况下，必须使用二传手。我们建议始终为此类类型添加设置器。如果初始化集合，请确保它不是不可变的(如上例所示)。<li>如果初始化嵌套的 POJO 属性(如上例中的<code>Security</code>字段)，则不需要设置器。如果希望 Binder 通过使用其默认构造函数动态创建实例，则需要一个 setter。</ul><p>有些人使用 Lombok 项目自动添加获取器和设置器。确保 Lombok 不会为这种类型生成任何特定的构造函数，因为容器会自动使用它来实例化该对象。<p>最后，仅考虑标准 Java Bean 属性，不支持对静态属性的绑定。<p>另请参见<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-external-config.html#boot-features-external-config-vs-value rel=noopener target=_blank>@Value 和@ConfigurationProperties 之间的区别</a>。</blockquote><p>您还需要列出要在<code>@EnableConfigurationProperties</code>注解中注册的属性类，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableConfigurationProperties(AcmeProperties.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyConfiguration</span> {</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>以这种方式注册<code>@ConfigurationProperties</code> bean 时，该 bean 具有常规名称：<code>&LTprefix>-&LTfqn></code>，其中<code>&LTprefix></code>是<code>@ConfigurationProperties</code>注解中指定的环境密钥前缀，而<code>&LTfqn></code>是 bean 的全限定名。如果 Comments 不提供任何前缀，则仅使用 Bean 的完全限定名称。<p>上例中的 bean 名称是<code>acme-com.example.AcmeProperties</code>。</blockquote><p>即使前面的配置为<code>AcmeProperties</code>创建了一个常规 bean，我们也建议<code>@ConfigurationProperties</code>只处理环境，尤其不要从上下文中注入其他 bean。话虽如此，<code>@EnableConfigurationProperties</code>注解也会自动应用到您的项目中，从而可以从<code>Environment</code>配置任何以<code>@ConfigurationProperties</code>注解的现有 bean。您可以通过确保<code>AcmeProperties</code>已经是 Bean 来快捷方式<code>MyConfiguration</code>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@ConfigurationProperties(prefix="acme")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AcmeProperties</span> {</span><br><span class=line></span><br><span class=line>	<span class=comment>// ... see the preceding example</span></span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><p>这种配置风格特别适用于<code>SpringApplication</code>外部 YAML 配置，如以下示例所示：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=comment># application.yml</span></span><br><span class=line></span><br><span class=line><span class=attr>acme:</span></span><br><span class=line>	<span class=attr>remote-address:</span> <span class=number>192.168</span><span class=number>.1</span><span class=number>.1</span></span><br><span class=line>	<span class=attr>security:</span></span><br><span class=line>		<span class=attr>username:</span> <span class=string>admin</span></span><br><span class=line>		<span class=attr>roles:</span></span><br><span class=line>		  <span class=bullet>-</span> <span class=string>USER</span></span><br><span class=line>		  <span class=bullet>-</span> <span class=string>ADMIN</span></span><br><span class=line></span><br><span class=line><span class=comment># additional configuration as required</span></span><br></pre></table></figure><p>要使用<code>@ConfigurationProperties</code> bean，可以像使用其他任何 bean 一样注入它们，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyService</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> AcmeProperties properties;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyService</span><span class=params>(AcmeProperties properties)</span> {</span><br><span class=line>	    <span class=built_in>this</span>.properties = properties;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line> 	<span class=comment>//...</span></span><br><span class=line></span><br><span class=line>	<span class=meta>@PostConstruct</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">openConnection</span><span class=params>()</span> {</span><br><span class=line>		<span class=type>Server</span> <span class=variable>server</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Server</span>(<span class=built_in>this</span>.properties.getRemoteAddress());</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-2-8-1、第三方配置><a class=headerlink href=#3-2-8-1、第三方配置 title=3.2.8.1、第三方配置></a>3.2.8.1、第三方配置</h4><p>除了使用<code>@ConfigurationProperties</code>Comments 类，您还可以在公共<code>@Bean</code>方法上使用它。当您要将属性绑定到控件之外的第三方组件时，这样做特别有用。<p>要通过<code>Environment</code>属性配置 bean，请将<code>@ConfigurationProperties</code>添加到其 bean 注册中，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>@ConfigurationProperties(prefix = "another")</span><br><span class=line>@Bean</span><br><span class=line>public AnotherComponent anotherComponent() {</span><br><span class=line>	...</span><br><span class=line>}</span><br></pre></table></figure><p>用<code>another</code>前缀定义的任何属性都以类似于前面<code>AcmeProperties</code>示例的方式 Map 到该<code>AnotherComponent</code> bean。<h4 id=3-2-8-2、轻松绑定><a class=headerlink href=#3-2-8-2、轻松绑定 title=3.2.8.2、轻松绑定></a>3.2.8.2、轻松绑定</h4><p>Spring Boot 使用一些宽松的规则将<code>Environment</code>属性绑定到<code>@ConfigurationProperties</code> bean，因此<code>Environment</code>属性名称和 bean 属性名称之间不需要完全匹配。有用的常见示例包括破折号分隔的环境属性(例如<code>context-path</code>绑定到<code>contextPath</code>)和大写的环境属性(例如<code>PORT</code>绑定到<code>port</code>)。<p>例如，考虑以下<code>@ConfigurationProperties</code>类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>@ConfigurationProperties(prefix="acme.my-project.person")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">OwnerProperties</span> {</span><br><span class=line>	<span class=keyword>private</span> String firstName;</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> String <span class="title function_">getFirstName</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.firstName;</span><br><span class=line>	}</span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setFirstName</span><span class=params>(String firstName)</span> {</span><br><span class=line>		<span class=built_in>this</span>.firstName = firstName;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>在前面的示例中，可以全部使用以下属性名称：<p><strong>表 24.1. 轻松绑定</strong><table><thead><tr><th>Property<th>Note<tbody><tr><td><code>acme.my-project.person.first-name</code><td>Kebab 情况，建议在<code>.properties</code>和<code>.yml</code>文件中使用。<tr><td><code>acme.myProject.person.firstName</code><td>标准驼峰式语法。<tr><td><code>acme.my_project.person.first_name</code><td>下划线表示法，是在<code>.properties</code>和<code>.yml</code>文件中使用的另一种格式。<tr><td><code>ACME_MYPROJECT_PERSON_FIRSTNAME</code><td>大写格式，使用系统环境变量时建议使用。</table><blockquote><p>Comments*的<code>prefix</code>值必须为 kebab(小写并由<code>-</code>分隔，例如<code>acme.my-project.person</code>)。</blockquote><p><strong>表 24.2. 每个资源来源的宽松绑定规则</strong><table><thead><tr><th>Property Source<th>Simple<th>List<tbody><tr><td>Properties Files<td>骆驼案，烤肉串案或下划线<td>使用<code>[ ]</code>或逗号分隔值的标准列表语法<tr><td>YAML Files<td>骆驼案，烤肉串案或下划线<td>标准 YAML 列表语法或逗号分隔的值<tr><td>Environment Variables<td>以下划线作为定界符的大写格式。 <code>_</code>不应在属性名称中使用<td>带有下划线的数字值，例如<code>MY_ACME_1_OTHER = my.acme[1].other</code><tr><td>System properties<td>骆驼案，烤肉串案或下划线<td>使用<code>[ ]</code>或逗号分隔值的标准列表语法</table><blockquote><p>我们建议，如果可能的话，属性以小写的 kebab 格式存储，例如<code>my.property-name=acme</code>。</blockquote><p>绑定到<code>Map</code>属性时，如果<code>key</code>包含小写字母数字字符或<code>-</code>以外的任何内容，则需要使用方括号表示法，以便保留原始值。如果键没有被<code>[]</code>包围，则所有非字母数字或<code>-</code>的字符都将被删除。例如，考虑将以下属性绑定到<code>Map</code>：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>acme:</span><br><span class=line>  map:</span><br><span class=line>    "[/key1]": value1</span><br><span class=line>    "[/key2]": value2</span><br><span class=line>    /key3: value3</span><br></pre></table></figure><p>上面的属性将绑定到<code>Map</code>，其中<code>/key1</code>，<code>/key2</code>和<code>key3</code>作为 Map 中的键。<h4 id=3-2-8-3、合并复杂类型><a class=headerlink href=#3-2-8-3、合并复杂类型 title=3.2.8.3、合并复杂类型></a>3.2.8.3、合并复杂类型</h4><p>如果在多个位置配置了列表，则通过替换整个列表来进行覆盖。<p>例如，假设一个<code>MyPojo</code>对象的<code>name</code>和<code>description</code>属性默认为<code>null</code>。以下示例公开了<code>AcmeProperties</code>中的<code>MyPojo</code>个对象的列表：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@ConfigurationProperties("acme")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AcmeProperties</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> List&LTMyPojo> list = <span class=keyword>new</span> <span class="title class_">ArrayList</span><>();</span><br><span class=line>	<span class=keyword>public</span> List&LTMyPojo> <span class="title function_">getList</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.list;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>考虑以下配置：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=attr>acme:</span></span><br><span class=line>  <span class=attr>list:</span></span><br><span class=line>    <span class=bullet>-</span> <span class=attr>name:</span> <span class=string>my</span> <span class=string>name</span></span><br><span class=line>      <span class=attr>description:</span> <span class=string>my</span> <span class=string>description</span></span><br><span class=line><span class=meta>---</span></span><br><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>profiles:</span> <span class=string>dev</span></span><br><span class=line><span class=attr>acme:</span></span><br><span class=line>  <span class=attr>list:</span></span><br><span class=line>    <span class=bullet>-</span> <span class=attr>name:</span> <span class=string>my</span> <span class=string>another</span> <span class=string>name</span></span><br></pre></table></figure><p>如果<code>dev</code>配置文件无效，则<code>AcmeProperties.list</code>包含一个<code>MyPojo</code>条目，如先前所定义。但是，如果启用了<code>dev</code>配置文件，则<code>list</code> <em>仍然</em>仅包含一个条目(名称为<code>my another name</code>和描述为<code>null</code>)。此配置<em>不会</em>将第二个<code>MyPojo</code>实例添加到列表中，并且不会合并项目。<p>在多个配置文件中指定<code>List</code>时，将使用优先级最高的(并且只有该优先级)。考虑以下示例：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=attr>acme:</span></span><br><span class=line>  <span class=attr>list:</span></span><br><span class=line>    <span class=bullet>-</span> <span class=attr>name:</span> <span class=string>my</span> <span class=string>name</span></span><br><span class=line>      <span class=attr>description:</span> <span class=string>my</span> <span class=string>description</span></span><br><span class=line>    <span class=bullet>-</span> <span class=attr>name:</span> <span class=string>another</span> <span class=string>name</span></span><br><span class=line>      <span class=attr>description:</span> <span class=string>another</span> <span class=string>description</span></span><br><span class=line><span class=meta>---</span></span><br><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>profiles:</span> <span class=string>dev</span></span><br><span class=line><span class=attr>acme:</span></span><br><span class=line>  <span class=attr>list:</span></span><br><span class=line>    <span class=bullet>-</span> <span class=attr>name:</span> <span class=string>my</span> <span class=string>another</span> <span class=string>name</span></span><br></pre></table></figure><p>在前面的示例中，如果<code>dev</code>配置文件处于 Active 状态，则<code>AcmeProperties.list</code>包含* one * <code>MyPojo</code>条目(名称为<code>my another name</code>且描述为<code>null</code>)。对于 YAML，可以使用逗号分隔的列表和 YAML 列表来完全覆盖列表的内容。<p>对于<code>Map</code>属性，您可以绑定从多个来源获取的属性值。但是，对于多个源中的同一属性，将使用优先级最高的属性。以下示例从<code>AcmeProperties</code>公开<code>Map&LTString, MyPojo></code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@ConfigurationProperties("acme")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AcmeProperties</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> Map&LTString, MyPojo> map = <span class=keyword>new</span> <span class="title class_">HashMap</span><>();</span><br><span class=line>	<span class=keyword>public</span> Map&LTString, MyPojo> <span class="title function_">getMap</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.map;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>考虑以下配置：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=attr>acme:</span></span><br><span class=line>  <span class=attr>map:</span></span><br><span class=line>    <span class=attr>key1:</span></span><br><span class=line>      <span class=attr>name:</span> <span class=string>my</span> <span class=string>name</span> <span class=number>1</span></span><br><span class=line>      <span class=attr>description:</span> <span class=string>my</span> <span class=string>description</span> <span class=number>1</span></span><br><span class=line><span class=meta>---</span></span><br><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>profiles:</span> <span class=string>dev</span></span><br><span class=line><span class=attr>acme:</span></span><br><span class=line>  <span class=attr>map:</span></span><br><span class=line>    <span class=attr>key1:</span></span><br><span class=line>      <span class=attr>name:</span> <span class=string>dev</span> <span class=string>name</span> <span class=number>1</span></span><br><span class=line>    <span class=attr>key2:</span></span><br><span class=line>      <span class=attr>name:</span> <span class=string>dev</span> <span class=string>name</span> <span class=number>2</span></span><br><span class=line>      <span class=attr>description:</span> <span class=string>dev</span> <span class=string>description</span> <span class=number>2</span></span><br></pre></table></figure><p>如果<code>dev</code>配置文件未激活，则<code>AcmeProperties.map</code>包含一个键为<code>key1</code>的条目(名称为<code>my name 1</code>和描述为<code>my description 1</code>)。但是，如果启用了<code>dev</code>配置文件，则<code>map</code>包含两个条目，其中包含键<code>key1</code>(名称为<code>dev name 1</code>和<code>my description 1</code>的描述)和<code>key2</code>(名称为<code>dev name 2</code>和<code>dev description 2</code>的描述)。<blockquote><p>前述合并规则不仅适用于 YAML 文件，而且适用于所有属性源中的属性。</blockquote><h4 id=3-2-8-4、属性转换><a class=headerlink href=#3-2-8-4、属性转换 title=3.2.8.4、属性转换></a>3.2.8.4、属性转换</h4><p>当 Spring Boot 绑定到<code>@ConfigurationProperties</code> bean 时，它尝试将外部应用程序属性强制为正确的类型。如果需要自定义类型转换，则可以提供<code>ConversionService</code> bean(使用名为<code>conversionService</code>的 bean)或自定义属性编辑器(通过<code>CustomEditorConfigurer</code> bean)或自定义<code>Converters</code>(将 bean 定义标注为<code>@ConfigurationPropertiesBinding</code>)。<blockquote><p>由于在应用程序生命周期中非常早就请求了此 bean，因此请确保限制您的<code>ConversionService</code>使用的依赖项。通常，您需要的任何依赖项可能在创建时未完全初始化。如果配置键强制不需要自定义<code>ConversionService</code>，而只依赖于具有<code>@ConfigurationPropertiesBinding</code>限定的自定义转换器，则可能要重命名。</blockquote><h5 id=Converting-durations><a title="Converting durations" class=headerlink href=#Converting-durations></a>Converting durations</h5><p>Spring Boot 为表达持续时间提供了专门的支持。如果公开<code>java.time.Duration</code>属性，则应用程序属性中的以下格式可用：<ul><li>常规<code>long</code>表示形式(使用毫秒作为默认单位，除非已指定<code>@DurationUnit</code>)<li>标准 ISO-8601 格式<a href=https://docs.oracle.com/javase/8/docs/api//java/time/Duration.html#parse-java.lang.CharSequence- rel=noopener target=_blank>由 java.util.Duration 使用</a><li>值和单位相结合的更易读的格式(例如<code>10s</code>表示 10 秒)</ul><p>考虑以下示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=meta>@ConfigurationProperties("app.system")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppSystemProperties</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@DurationUnit(ChronoUnit.SECONDS)</span></span><br><span class=line>	<span class=keyword>private</span> <span class=type>Duration</span> <span class=variable>sessionTimeout</span> <span class=operator>=</span> Duration.ofSeconds(<span class=number>30</span>);</span><br><span class=line></span><br><span class=line>	<span class=keyword>private</span> <span class=type>Duration</span> <span class=variable>readTimeout</span> <span class=operator>=</span> Duration.ofMillis(<span class=number>1000</span>);</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> Duration <span class="title function_">getSessionTimeout</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.sessionTimeout;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setSessionTimeout</span><span class=params>(Duration sessionTimeout)</span> {</span><br><span class=line>		<span class=built_in>this</span>.sessionTimeout = sessionTimeout;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> Duration <span class="title function_">getReadTimeout</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.readTimeout;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setReadTimeout</span><span class=params>(Duration readTimeout)</span> {</span><br><span class=line>		<span class=built_in>this</span>.readTimeout = readTimeout;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>要指定 30 秒的会话超时，<code>30</code>，<code>PT30S</code>和<code>30s</code>都是等效的。可以采用以下任何形式指定 500ms 的读取超时：<code>500</code>，<code>PT0.5S</code>和<code>500ms</code>。<p>您也可以使用任何受支持的单位。这些是：<ul><li><code>ns</code>纳秒<li><code>us</code>微秒<li><code>ms</code>毫秒<li><code>s</code>秒<li><code>m</code>分钟<li><code>h</code>小时<li><code>d</code>天</ul><p>默认单位是毫秒，可以使用<code>@DurationUnit</code>覆盖，如上面的示例所示。<h5 id=转换数据大小><a class=headerlink href=#转换数据大小 title=转换数据大小></a>转换数据大小</h5><p>Spring Framework 的<code>DataSize</code>值类型允许以字节表示大小。如果公开<code>DataSize</code>属性，则应用程序属性中的以下格式可用：<ul><li>常规的<code>long</code>表示形式(除非已指定<code>@DataSizeUnit</code>，否则使用字节作为默认单位)<li>值和单位耦合在一起的更具可读性的格式(例如<code>10MB</code>表示 10 兆字节)</ul><p>考虑以下示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=meta>@ConfigurationProperties("app.io")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AppIoProperties</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@DataSizeUnit(DataUnit.MEGABYTES)</span></span><br><span class=line>	<span class=keyword>private</span> <span class=type>DataSize</span> <span class=variable>bufferSize</span> <span class=operator>=</span> DataSize.ofMegabytes(<span class=number>2</span>);</span><br><span class=line></span><br><span class=line>	<span class=keyword>private</span> <span class=type>DataSize</span> <span class=variable>sizeThreshold</span> <span class=operator>=</span> DataSize.ofBytes(<span class=number>512</span>);</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> DataSize <span class="title function_">getBufferSize</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.bufferSize;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setBufferSize</span><span class=params>(DataSize bufferSize)</span> {</span><br><span class=line>		<span class=built_in>this</span>.bufferSize = bufferSize;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> DataSize <span class="title function_">getSizeThreshold</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.sizeThreshold;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setSizeThreshold</span><span class=params>(DataSize sizeThreshold)</span> {</span><br><span class=line>		<span class=built_in>this</span>.sizeThreshold = sizeThreshold;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>要指定 10 MB 的缓冲区大小，<code>10</code>和<code>10MB</code>是等效的。可以将 256 个字节的大小阈值指定为<code>256</code>或<code>256B</code>。<p>您也可以使用任何受支持的单位。这些是：<ul><li><code>B</code>个字节<li><code>KB</code>千字节<li><code>MB</code>代表兆字节<li><code>GB</code>代表千兆字节<li><code>TB</code>代表兆兆字节</ul><p>默认单位是字节，可以使用<code>@DataSizeUnit</code>覆盖，如上面的示例所示。<h4 id=3-2-8-5、-ConfigurationProperties-验证><a title="3.2.8.5、@ConfigurationProperties 验证" class=headerlink href=#3-2-8-5、-ConfigurationProperties-验证></a>3.2.8.5、@ConfigurationProperties 验证</h4><p>每当使用 Spring 的<code>@Validated</code>Comments 进行 Comments 时，Spring Boot 就会尝试验证<code>@ConfigurationProperties</code>类。您可以在配置类上直接使用 JSR-303 <code>javax.validation</code>约束 Comments。为此，请确保在 Classpath 上有兼容的 JSR-303 实现，然后将约束 Comments 添加到字段中，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@ConfigurationProperties(prefix="acme")</span></span><br><span class=line><span class=meta>@Validated</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AcmeProperties</span> {</span><br><span class=line>	<span class=meta>@NotNull</span></span><br><span class=line>	<span class=keyword>private</span> InetAddress remoteAddress;</span><br><span class=line></span><br><span class=line>	<span class=comment>// ... getters and setters</span></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>您还可以通过使用<code>@Validated</code>Comments 创建配置属性的<code>@Bean</code>方法来触发验证。</blockquote><p>尽管嵌套属性在绑定时也会被验证，但是最好将关联的字段 Comments 为<code>@Valid</code>。这样可以确保即使没有嵌套属性也可以触发验证。以下示例基于前面的<code>AcmeProperties</code>示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>@ConfigurationProperties(prefix="acme")</span></span><br><span class=line><span class=meta>@Validated</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AcmeProperties</span> {</span><br><span class=line>	<span class=meta>@NotNull</span></span><br><span class=line>	<span class=keyword>private</span> InetAddress remoteAddress;</span><br><span class=line>	<span class=meta>@Valid</span></span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> <span class=type>Security</span> <span class=variable>security</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Security</span>();</span><br><span class=line></span><br><span class=line>	<span class=comment>// ... getters and setters</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">Security</span> {</span><br><span class=line>		<span class=meta>@NotEmpty</span></span><br><span class=line>		<span class=keyword>public</span> String username;</span><br><span class=line>		<span class=comment>// ... getters and setters</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>您还可以通过创建名为<code>configurationPropertiesValidator</code>的 bean 定义来添加自定义 Spring <code>Validator</code>。 <code>@Bean</code>方法应声明为<code>static</code>。配置属性验证器是在应用程序生命周期的早期创建的，并且将<code>@Bean</code>方法声明为静态方法可以使 Bean 得以创建而不必实例化<code>@Configuration</code>类。这样做可以避免因早期实例化而引起的任何问题。有一个<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-samples/spring-boot-sample-property-validation rel=noopener target=_blank>属性验证 samples</a>显示了如何进行设置。<blockquote><p><code>spring-boot-actuator</code>模块包含一个公开所有<code>@ConfigurationProperties</code> bean 的端点。将您的 Web 浏览器指向<code>/actuator/configprops</code>或使用等效的 JMX 端点。</blockquote><h4 id=3-2-8-6、-ConfigurationProperties-与-Value><a title="3.2.8.6、@ConfigurationProperties 与@Value" class=headerlink href=#3-2-8-6、-ConfigurationProperties-与-Value></a>3.2.8.6、@ConfigurationProperties 与@Value</h4><p><code>@Value</code>注解是核心容器功能，它没有提供与类型安全的配置属性相同的功能。下表总结了<code>@ConfigurationProperties</code>和<code>@Value</code>支持的功能：<table><thead><tr><th>Feature<th><code>@ConfigurationProperties</code><th><code>@Value</code><tbody><tr><td><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-external-config.html#boot-features-external-config-relaxed-binding rel=noopener target=_blank>Relaxed binding</a><td>Yes<td>No<tr><td><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/configuration-metadata.html rel=noopener target=_blank>Meta-data support</a><td>Yes<td>No<tr><td><code>SpEL</code>评估<td>No<td>Yes</table><p>如果您为自己的组件定义了一组配置键，我们建议您将它们组合在以<code>@ConfigurationProperties</code>Comments 的 POJO 中。您还应该意识到，由于<code>@Value</code>不支持宽松的绑定，因此如果您需要使用环境变量来提供值，则它不是很好的选择。<p>最后，尽管您可以在<code>@Value</code>中编写<code>SpEL</code>表达式，但不会从<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-external-config.html#boot-features-external-config-application-property-files rel=noopener target=_blank>应用程序属性文件</a>处理此类表达式。<h2 id=3-3、Profiles><a class=headerlink href=#3-3、Profiles title=3.3、Profiles></a>3.3、Profiles</h2><p>Spring Profiles 提供了一种隔离应用程序配置的各部分并使之仅在某些环境中可用的方法。可以用<code>@Profile</code>标记任何<code>@Component</code>或<code>@Configuration</code>以限制其加载时间，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@Profile("production")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ProductionConfiguration</span> {</span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>您可以使用<code>spring.profiles.active</code> <code>Environment</code>属性来指定哪些配置文件处于 Active 状态。您可以通过本章前面介绍的任何方式指定属性。例如，您可以将其包含在<code>application.properties</code>中，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.profiles.active=dev,hsqldb</span><br></pre></table></figure><p>您还可以使用以下开关在命令行上指定它：<code>--spring.profiles.active=dev,hsqldb</code>。<h3 id=3-3-1、添加-Active-配置文件><a title="3.3.1、添加 Active 配置文件" class=headerlink href=#3-3-1、添加-Active-配置文件></a>3.3.1、添加 Active 配置文件</h3><p><code>spring.profiles.active</code>属性遵循与其他属性相同的排序规则：最高<code>PropertySource</code>获胜。这意味着您可以在<code>application.properties</code>中指定 Active 配置文件，然后使用命令行开关“替换”它们。<p>有时，将特定于配置文件的属性“添加”到 Active 配置文件而不是替换它们很有用。 <code>spring.profiles.include</code>属性可用于无条件添加 Active 配置文件。 <code>SpringApplication</code>入口点还具有 Java API，用于设置其他配置文件(即，在<code>spring.profiles.active</code>属性激活的配置文件之上)。请参见<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/SpringApplication.html rel=noopener target=_blank>SpringApplication</a>中的<code>setAdditionalProfiles()</code>方法。<p>例如，当使用开关<code>--spring.profiles.active=prod</code>运行具有以下属性的应用程序时，还将激活<code>proddb</code>和<code>prodmq</code>配置文件：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>---</span></span><br><span class=line><span class=attr>my.property:</span> <span class=string>fromyamlfile</span></span><br><span class=line><span class=meta>---</span></span><br><span class=line><span class=attr>spring.profiles:</span> <span class=string>prod</span></span><br><span class=line><span class=attr>spring.profiles.include:</span></span><br><span class=line>  <span class=bullet>-</span> <span class=string>proddb</span></span><br><span class=line>  <span class=bullet>-</span> <span class=string>prodmq</span></span><br></pre></table></figure><blockquote><p>请记住，可以在 YAML 文档中定义<code>spring.profiles</code>属性，以确定何时将该特定文档包括在配置中。</blockquote><h3 id=3-3-2、以编程方式设置配置文件><a class=headerlink href=#3-3-2、以编程方式设置配置文件 title=3.3.2、以编程方式设置配置文件></a>3.3.2、以编程方式设置配置文件</h3><p>您可以在应用程序运行之前通过调用<code>SpringApplication.setAdditionalProfiles(…)</code>以编程方式设置 Active 配置文件。也可以使用 Spring 的<code>ConfigurableEnvironment</code>界面激活配置文件。<h3 id=3-3-3、特定于配置文件的配置文件><a class=headerlink href=#3-3-3、特定于配置文件的配置文件 title=3.3.3、特定于配置文件的配置文件></a>3.3.3、特定于配置文件的配置文件</h3><p><code>application.properties</code>(或<code>application.yml</code>)和通过<code>@ConfigurationProperties</code>引用的文件的特定于配置文件的变体都被视为文件并已加载。<h2 id=3-4、Logging><a class=headerlink href=#3-4、Logging title=3.4、Logging></a>3.4、Logging</h2><p>Spring Boot 使用<a href=https://commons.apache.org/logging rel=noopener target=_blank>Commons Logging</a>进行所有内部日志记录，但是使底层日志实现保持打开状态。为<a href=https://docs.oracle.com/javase/8/docs/api//java/util/logging/package-summary.html rel=noopener target=_blank>Java Util 记录</a>，<a href=https://logging.apache.org/log4j/2.x/ rel=noopener target=_blank>Log4J2</a>和<a href=http://logback.qos.ch/ rel=noopener target=_blank>Logback</a>提供了默认配置。在每种情况下，Logger 都已预先配置为使用控制台输出，同时还提供可选文件输出。<p>默认情况下，如果使用“启动器”，则使用 Logback 进行日志记录。还包括适当的 Logback 路由，以确保使用 Java Util Logging，Commons Logging，Log4J 或 SLF4J 的从属库均能正常工作。<blockquote><p>有许多可用于 Java 的日志记录框架。如果上面的列表看起来令人困惑，请不要担心。通常，您不需要更改日志记录依赖项，并且 Spring Boot 默认值可以正常工作。</blockquote><h3 id=3-4-1、日志格式><a class=headerlink href=#3-4-1、日志格式 title=3.4.1、日志格式></a>3.4.1、日志格式</h3><p>Spring Boot 的默认日志输出类似于以下示例：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>2014-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat/7.0.52</span><br><span class=line>2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class=line>2014-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms</span><br><span class=line>2014-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: 'dispatcherServlet' to [/]</span><br><span class=line>2014-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: 'hiddenHttpMethodFilter' to: [/*]</span><br></pre></table></figure><p>输出以下项目：<ul><li>日期和时间：毫秒精度，易于排序。<li>日志级别：<code>ERROR</code>，<code>WARN</code>，<code>INFO</code>，<code>DEBUG</code>或<code>TRACE</code>。<li>Process ID.<li><code>---</code>分隔符用于区分实际日志消息的开始。<li>线程名称：用方括号括起来(对于控制台输出可能会被截断)。<li>Logger 名称：这通常是源类名称(通常缩写)。<li>日志消息。</ul><blockquote><p>Logback 没有<code>FATAL</code>级别。它 Map 到<code>ERROR</code>。</blockquote><h3 id=3-4-2、控制台输出><a class=headerlink href=#3-4-2、控制台输出 title=3.4.2、控制台输出></a>3.4.2、控制台输出</h3><p>缺省日志配置在写入消息时将消息回显到控制台。默认情况下，将记录<code>ERROR</code>级，<code>WARN</code>级和<code>INFO</code>级消息。您还可以通过使用<code>--debug</code>标志启动应用程序来启用“调试”模式。<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -jar myapp.jar --debug</span></span><br></pre></table></figure><blockquote><p>您也可以在<code>application.properties</code>中指定<code>debug=true</code>。</blockquote><p>启用调试模式后，将配置一些核心 Logger(嵌入式容器，Hibernate 和 Spring Boot)以输出更多信息。启用调试模式不会<em>不</em>将您的应用程序配置为记录所有具有<code>DEBUG</code>级的消息。<p>另外，您可以通过使用<code>--trace</code>标志(或<code>application.properties</code>中的<code>trace=true</code>)启动应用程序来启用“跟踪”模式。这样做可以为某些核心 Logger(嵌入式容器，Hibernate 模式生成以及整个 Spring 产品组合)启用跟踪记录。<h4 id=3-4-2-1、颜色编码的输出><a class=headerlink href=#3-4-2-1、颜色编码的输出 title=3.4.2.1、颜色编码的输出></a>3.4.2.1、颜色编码的输出</h4><p>如果您的终端支持 ANSI，则使用彩色输出来提高可读性。您可以将<code>spring.output.ansi.enabled</code>设置为<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/ansi/AnsiOutput.Enabled.html rel=noopener target=_blank>supported value</a>以覆盖自动检测。<p>通过使用<code>%clr</code>转换字来配置颜色编码。转换器以最简单的形式根据对数级别为输出着色，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">%</span><span class=language-bash>clr(%5p)</span></span><br></pre></table></figure><p>下表描述了日志级别到颜色的 Map：<table><thead><tr><th>Level<th>Color<tbody><tr><td><code>FATAL</code><td>Red<tr><td><code>ERROR</code><td>Red<tr><td><code>WARN</code><td>Yellow<tr><td><code>INFO</code><td>Green<tr><td><code>DEBUG</code><td>Green<tr><td><code>TRACE</code><td>Green</table><p>另外，您可以通过将其提供为转换的选项来指定应使用的颜色或样式。例如，要使文本变黄，请使用以下设置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">%</span><span class=language-bash>clr(%d{yyyy-MM-<span class=built_in>dd</span> HH:mm:ss.SSS}){yellow}</span></span><br></pre></table></figure><p>支持以下颜色和样式：<ul><li><code>blue</code><li><code>cyan</code><li><code>faint</code><li><code>green</code><li><code>magenta</code><li><code>red</code><li><code>yellow</code></ul><h3 id=3-4-3、文件输出><a class=headerlink href=#3-4-3、文件输出 title=3.4.3、文件输出></a>3.4.3、文件输出</h3><p>默认情况下，Spring Boot 仅记录到控制台，不写日志文件。如果除了控制台输出外还想写入日志文件，则需要设置<code>logging.file</code>或<code>logging.path</code>属性(例如，在<code>application.properties</code>中)。<p>下表显示了如何一起使用<code>logging.*</code>属性：<p><strong>表 26.1 记录属性</strong><table><thead><tr><th><code>logging.file</code><th><code>logging.path</code><th>Example<th>Description<tbody><tr><td><em>(none)</em><td><em>(none)</em><td><td>仅控制台记录。<tr><td>Specific file<td><em>(none)</em><td><code>my.log</code><td>写入指定的日志文件。名称可以是确切的位置，也可以相对于当前目录。<tr><td><em>(none)</em><td>Specific directory<td><code>/var/log</code><td>将<code>spring.log</code>写入指定的目录。名称可以是确切的位置，也可以相对于当前目录。</table><p>日志文件达到 10 MB 时会旋转，并且与控制台输出一样，默认记录<code>ERROR</code> -level，<code>WARN</code> -level 和<code>INFO</code> -level 消息。大小限制可以使用<code>logging.file.max-size</code>属性更改。除非已设置<code>logging.file.max-history</code>属性，否则以前旋转的文件将无限期存档。<blockquote><p>日志记录系统在应用程序生命周期的早期进行了初始化。因此，在通过<code>@PropertySource</code>Comments 加载的属性文件中找不到日志记录属性。<p>日志记录属性与实际的日志记录基础结构无关。结果，Spring Boot 不会 Management 特定的配置密钥(例如 Log 的<code>logback.configurationFile</code>)。</blockquote><h3 id=3-4-4、日志级别><a class=headerlink href=#3-4-4、日志级别 title=3.4.4、日志级别></a>3.4.4、日志级别</h3><p>所有支持的日志记录系统都可以使用<code>logging.level.&LTlogger-name>=&LTlevel></code>在 Spring <code>Environment</code>(例如，在<code>application.properties</code>)中设置 Logger 级别，其中<code>level</code>是 TRACE，DEBUG，INFO，WARN，ERROR，FATAL 或 OFF 之一。可以使用<code>logging.level.root</code>来配置<code>root</code>Logger。<p>以下示例显示了<code>application.properties</code>中的潜在日志记录设置：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>logging.level.root</span>=<span class=string>WARN</span></span><br><span class=line><span class=attr>logging.level.org.springframework.web</span>=<span class=string>DEBUG</span></span><br><span class=line><span class=attr>logging.level.org.hibernate</span>=<span class=string>ERROR</span></span><br></pre></table></figure><h3 id=3-4-5、日志组><a class=headerlink href=#3-4-5、日志组 title=3.4.5、日志组></a>3.4.5、日志组</h3><p>能够将相关 Logger 组合在一起通常很有用，以便可以同时配置它们。例如，您可能通常会更改与 Tomcat 相关的所有 Logger 的日志记录级别，但是您不容易记住顶级软件包。<p>为了解决这个问题，Spring Boot 允许您在 Spring <code>Environment</code>中定义日志记录组。例如，这是通过将“ tomcat”组添加到<code>application.properties</code>来定义它的方法：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>logging.group.tomcat=org.apache.catalina, org.apache.coyote, org.apache.tomcat</span><br></pre></table></figure><p>定义后，您可以使用一行更改该组中所有 Logger 的级别：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>logging.level.tomcat=TRACE</span><br></pre></table></figure><p>Spring Boot 包含以下 sched 义的日志记录组，它们可以直接使用：<table><thead><tr><th>Name<th>Loggers<tbody><tr><td>web<td><code>org.springframework.core.codec</code> , <code>org.springframework.http</code> , <code>org.springframework.web</code><tr><td>sql<td><code>org.springframework.jdbc.core</code> , <code>org.hibernate.SQL</code></table><h3 id=3-4-6、自定义日志配置><a class=headerlink href=#3-4-6、自定义日志配置 title=3.4.6、自定义日志配置></a>3.4.6、自定义日志配置</h3><p>可以通过在 Classpath 中包括适当的库来激活各种日志记录系统，并可以通过在 Classpath 的根目录中或在以下 Spring <code>Environment</code>属性：<code>logging.config</code>指定的位置中提供适当的配置文件来进一步自定义各种日志记录系统。<p>您可以通过使用<code>org.springframework.boot.logging.LoggingSystem</code> system 属性来强制 Spring Boot 使用特定的日志记录系统。该值应该是<code>LoggingSystem</code>实现的完全限定的类名。您还可以使用<code>none</code>值完全禁用 Spring Boot 的日志记录配置。<blockquote><p>由于日志记录是在创建<code>ApplicationContext</code>之前**初始化的，因此无法从 Spring <code>@Configuration</code>文件中的<code>@PropertySources</code>控制日志记录。更改日志记录系统或完全禁用它的唯一方法是通过系统属性。</blockquote><p>根据您的日志系统，将加载以下文件：<table><thead><tr><th>Logging System<th>Customization<tbody><tr><td>Logback<td><code>logback-spring.xml</code>，<code>logback-spring.groovy</code>，<code>logback.xml</code>或<code>logback.groovy</code><tr><td>Log4j2<td><code>log4j2-spring.xml</code>或<code>log4j2.xml</code><tr><td>JDK(Java Util 日志记录)<td><code>logging.properties</code></table><blockquote><p>如果可能，我们建议您将<code>-spring</code>变体用于日志记录配置(例如<code>logback-spring.xml</code>而不是<code>logback.xml</code>)。如果使用标准配置位置，Spring 将无法完全控制日志初始化。<p>从“可执行 jar”运行时，Java Util Logging 存在一些已知的类加载问题，这些问题会引起问题。我们建议您尽可能从“可执行 jar”运行时避免使用它。</blockquote><p>为了帮助进行自定义，如下表所述，一些其他属性从 Spring <code>Environment</code>转移到 System 属性：<table><thead><tr><th>Spring Environment<th>System Property<th>Comments<tbody><tr><td><code>logging.exception-conversion-word</code><td><code>LOG_EXCEPTION_CONVERSION_WORD</code><td>记录异常时使用的转换字。<tr><td><code>logging.file</code><td><code>LOG_FILE</code><td>如果定义，它将在默认日志配置中使用。<tr><td><code>logging.file.max-size</code><td><code>LOG_FILE_MAX_SIZE</code><td>最大日志文件大小(如果启用了 LOG_FILE)。 (仅默认登录设置支持.)<tr><td><code>logging.file.max-history</code><td><code>LOG_FILE_MAX_HISTORY</code><td>要保留的最大归档日志文件数(如果启用了 LOG_FILE)。 (仅默认登录设置支持.)<tr><td><code>logging.path</code><td><code>LOG_PATH</code><td>如果定义，它将在默认日志配置中使用。<tr><td><code>logging.pattern.console</code><td><code>CONSOLE_LOG_PATTERN</code><td>在控制台上使用的日志模式(stdout)。 (仅默认登录设置支持.)<tr><td><code>logging.pattern.dateformat</code><td><code>LOG_DATEFORMAT_PATTERN</code><td>记录日期格式的附加模式。 (仅默认登录设置支持.)<tr><td><code>logging.pattern.file</code><td><code>FILE_LOG_PATTERN</code><td>文件中使用的日志模式(如果启用了<code>LOG_FILE</code>)。 (仅默认登录设置支持.)<tr><td><code>logging.pattern.level</code><td><code>LOG_LEVEL_PATTERN</code><td>渲染日志级别时使用的格式(默认为<code>%5p</code>)。 (仅默认登录设置支持.)<tr><td><code>PID</code><td><code>PID</code><td>当前进程 ID(如果可能，并且尚未将其定义为 OS 环境变量时发现)。</table><p>所有受支持的日志记录系统在解析其配置文件时都可以查阅系统属性。有关示例，请参见<code>spring-boot.jar</code>中的默认配置：<ul><li><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/logback/defaults.xml rel=noopener target=_blank>Logback</a><li><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/log4j2/log4j2.xml rel=noopener target=_blank>Log4j 2</a><li><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/resources/org/springframework/boot/logging/java/logging-file.properties rel=noopener target=_blank>Java Util 日志记录</a></ul><blockquote><p>如果要在日志记录属性中使用占位符，则应使用<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-external-config.html#boot-features-external-config-placeholders-in-properties rel=noopener target=_blank>Spring Boot 的语法</a>而不是基础框架的语法。值得注意的是，如果使用 Logback，则应使用<code>:</code>作为属性名称与其默认值之间的分隔符，而不应使用<code>:-</code>。<p>您可以通过仅覆盖<code>LOG_LEVEL_PATTERN</code>(或使用 Logback 覆盖<code>logging.pattern.level</code>)将 MDC 和其他临时内容添加到日志行。例如，如果使用<code>logging.pattern.level=user:%X{user} %5p</code>，则默认日志格式包含“ user”的 MDC 条目(如果存在)，如以下示例所示。<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>2015-09-30 12:30:04.031 user:someone INFO 22174 --- [  nio-8080-exec-0] demo.Controller</span><br><span class=line>Handling authenticated request</span><br></pre></table></figure></blockquote><h3 id=3-4-7、Logback扩展><a class=headerlink href=#3-4-7、Logback扩展 title=3.4.7、Logback扩展></a>3.4.7、Logback扩展</h3><p>Spring Boot 包含许多 Logback 扩展，可以帮助进行高级配置。您可以在<code>logback-spring.xml</code>配置文件中使用这些 extensions。<blockquote><p>由于标准<code>logback.xml</code>配置文件加载时间过早，因此无法在其中使用 extensions。您需要使用<code>logback-spring.xml</code>或定义<code>logging.config</code>属性。<p>这些扩展不能与 Logback 的<a href=http://logback.qos.ch/manual/configuration.html#autoScan rel=noopener target=_blank>configuration scanning</a>一起使用。如果尝试这样做，则对配置文件进行更改将导致类似于以下记录之一的错误记录：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>ERROR in [emailprotected]:71 - no applicable action for [springProperty], current ElementPath is [[configuration][springProperty]]</span><br><span class=line>ERROR in [emailprotected]:71 - no applicable action for [springProfile], current ElementPath is [[configuration][springProfile]]</span><br></pre></table></figure></blockquote><h4 id=3-4-7-1、特定于配置文件的配置><a class=headerlink href=#3-4-7-1、特定于配置文件的配置 title=3.4.7.1、特定于配置文件的配置></a>3.4.7.1、特定于配置文件的配置</h4><p><code>&LTspringProfile></code>标签可让您根据有效的 Spring 配置文件有选择地包括或排除配置部分。 <code>&LTconfiguration></code>元素中任何位置都支持概要文件部分。使用<code>name</code>属性指定哪个配置文件接受配置。 <code>&LTspringProfile></code>标记可以包含一个简单的配置文件名称(例如<code>staging</code>)或一个配置文件表达式。配置文件表达式允许表达更复杂的配置文件逻辑，例如<code>production & (eu-central | eu-west)</code>。查看<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/core.html#beans-definition-profiles-java rel=noopener target=_blank>reference guide</a>以获取更多详细信息。以下 Lists 显示了三个 samples 概要文件：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>&LTspringProfile name="staging"></span><br><span class=line>	&LT!-- configuration to be enabled when the "staging" profile is active --></span><br><span class=line>&LT/springProfile></span><br><span class=line></span><br><span class=line>&LTspringProfile name="dev | staging"></span><br><span class=line>	&LT!-- configuration to be enabled when the "dev" or "staging" profiles are active --></span><br><span class=line>&LT/springProfile></span><br><span class=line></span><br><span class=line>&LTspringProfile name="!production"></span><br><span class=line>	&LT!-- configuration to be enabled when the "production" profile is not active --></span><br><span class=line>&LT/springProfile></span><br></pre></table></figure><h4 id=3-4-7-2、环境属性><a class=headerlink href=#3-4-7-2、环境属性 title=3.4.7.2、环境属性></a>3.4.7.2、环境属性</h4><p><code>&LTspringProperty></code>标签可让您公开 Spring <code>Environment</code>中的属性，以供在 Logback 中使用。如果要从 Logback 配置中访问<code>application.properties</code>文件中的值，则这样做很有用。该标记的工作方式类似于 Logback 的标准<code>&LTproperty></code>标记。但是，不是指定直接的<code>value</code>，而是指定属性的<code>source</code>(来自<code>Environment</code>)。如果需要将属性存储在<code>local</code>范围以外的其他位置，则可以使用<code>scope</code>属性。如果需要回退值(如果未在<code>Environment</code>中设置该属性)，则可以使用<code>defaultValue</code>属性。以下示例显示如何公开用于 Logback 的属性：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>&LTspringProperty scope="context" name="fluentHost" source="myapp.fluentd.host"</span><br><span class=line>		defaultValue="localhost"/></span><br><span class=line>&LTappender name="FLUENT" class="ch.qos.logback.more.appenders.DataFluentAppender"></span><br><span class=line>	&LTremoteHost>${fluentHost}&LT/remoteHost></span><br><span class=line>	...</span><br><span class=line>&LT/appender></span><br></pre></table></figure><blockquote><p><code>source</code>必须在烤肉串情况下指定(例如<code>my.property-name</code>)。但是，可以使用宽松规则将属性添加到<code>Environment</code>。</blockquote><h2 id=3-5、JSON><a class=headerlink href=#3-5、JSON title=3.5、JSON></a>3.5、JSON</h2><p>Spring Boot 提供了与三个 JSON Map 库的集成：<ul><li>Gson<li>Jackson<li>JSON-B</ul><p>Jackson 是首选的默认库。<h3 id=3-5-1、Jackson><a class=headerlink href=#3-5-1、Jackson title=3.5.1、Jackson></a>3.5.1、Jackson</h3><p>提供了 Jackson 的自动配置功能，并且 Jackson 是<code>spring-boot-starter-json</code>的一部分。当 Jackson 放在 Classpath 上时，会自动配置<code>ObjectMapper</code> bean。为<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/howto-spring-mvc.html#howto-customize-the-jackson-objectmapper rel=noopener target=_blank>定制 ObjectMapper 的配置</a>提供了几个配置属性。<h3 id=3-5-2、Gson><a class=headerlink href=#3-5-2、Gson title=3.5.2、Gson></a>3.5.2、Gson</h3><p>提供了 Gson 的自动配置。当 Gson 在 Classpath 上时，会自动配置<code>Gson</code> bean。提供了几个<code>spring.gson.*</code>配置属性用于自定义配置。为了获得更多控制权，可以使用一个或多个<code>GsonBuilderCustomizer</code> bean。<h3 id=3-5-3、JSON-B><a class=headerlink href=#3-5-3、JSON-B title=3.5.3、JSON-B></a>3.5.3、JSON-B</h3><p>提供了 JSON-B 的自动配置。当 JSON-B API 和实现位于 Classpath 上时，将自动配置<code>Jsonb</code> bean。首选的 JSON-B 实现是提供依赖 Management 的 Apache Johnzon。<h2 id=3-6、开发Web应用程序><a class=headerlink href=#3-6、开发Web应用程序 title=3.6、开发Web应用程序></a>3.6、开发Web应用程序</h2><p>Spring Boot 非常适合 Web 应用程序开发。您可以使用嵌入式 Tomcat，Jetty，Undertow 或 Netty 创建独立的 HTTP 服务器。大多数 Web 应用程序都使用<code>spring-boot-starter-web</code>模块来快速启动和运行。您还可以选择使用<code>spring-boot-starter-webflux</code>模块来构建响应式 Web 应用程序。<p>如果尚未开发 Spring Boot Web 应用程序，则可以遵循“ Hello World！”。 * <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/getting-started-first-application.html rel=noopener target=_blank>Getting started</a> *部分中的示例。<h3 id=3-6-1、“-Spring-Web-MVC-框架”><a title="3.6.1、“ Spring Web MVC 框架”" class=headerlink href=#3-6-1、“-Spring-Web-MVC-框架”></a>3.6.1、“ Spring Web MVC 框架”</h3><p><a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc rel=noopener target=_blank>Spring Web MVC 框架</a>(通常简称为“ Spring MVC”)是一个丰富的“模型视图控制器” Web 框架。 Spring MVC 使您可以创建特殊的<code>@Controller</code>或<code>@RestController</code> bean 来处理传入的 HTTP 请求。控制器中的方法通过使用<code>@RequestMapping</code>CommentsMap 到 HTTP。<p>以下代码显示了提供 JSON 数据的典型<code>@RestController</code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=meta>@RestController</span></span><br><span class=line><span class=meta>@RequestMapping(value="/users")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyRestController</span> {</span><br><span class=line>	<span class=meta>@RequestMapping(value="/{user}", method=RequestMethod.GET)</span></span><br><span class=line>	<span class=keyword>public</span> User <span class="title function_">getUser</span><span class=params>(<span class=meta>@PathVariable</span> Long user)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=meta>@RequestMapping(value="/{user}/customers", method=RequestMethod.GET)</span></span><br><span class=line>	List&LTCustomer> <span class="title function_">getUserCustomers</span><span class=params>(<span class=meta>@PathVariable</span> Long user)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=meta>@RequestMapping(value="/{user}", method=RequestMethod.DELETE)</span></span><br><span class=line>	<span class=keyword>public</span> User <span class="title function_">deleteUser</span><span class=params>(<span class=meta>@PathVariable</span> Long user)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>Spring MVC 是核心 Spring Framework 的一部分，有关详细信息，请参见<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc rel=noopener target=_blank>reference documentation</a>。 <a href=https://spring.io/guides rel=noopener target=_blank>spring.io/guides</a>提供了一些涵盖 Spring MVC 的指南。<h4 id=3-6-1-1、Spring-MVC自动配置><a title="3.6.1.1、Spring MVC自动配置" class=headerlink href=#3-6-1-1、Spring-MVC自动配置></a>3.6.1.1、Spring MVC自动配置</h4><p>Spring Boot 为 Spring MVC 提供了自动配置，可与大多数应用程序完美配合。<p>自动配置在 Spring 的默认值之上添加了以下功能：<ul><li>包括<code>ContentNegotiatingViewResolver</code>和<code>BeanNameViewResolver</code>bean。<li>支持提供静态资源，包括对 WebJars 的支持(覆盖<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-spring-mvc-static-content rel=noopener target=_blank>本文档后面</a>)。<li>自动注册<code>Converter</code>，<code>GenericConverter</code>和<code>Formatter</code> bean。<li>支持<code>HttpMessageConverters</code>(包含<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-spring-mvc-message-converters rel=noopener target=_blank>本文档后面</a>)。<li>自动注册<code>MessageCodesResolver</code>(已发现<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-spring-message-codes rel=noopener target=_blank>本文档后面</a>)。<li>静态<code>index.html</code>支持。<li>自定义<code>Favicon</code>支持(包含<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-spring-mvc-favicon rel=noopener target=_blank>本文档后面</a>)。<li>自动使用<code>ConfigurableWebBindingInitializer</code> bean(包含<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-spring-mvc-web-binding-initializer rel=noopener target=_blank>本文档后面</a>)。</ul><p>如果您想保留 Spring Boot MVC 功能，并且想要添加其他<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc rel=noopener target=_blank>MVC configuration</a>(拦截器，格式化程序，视图控制器和其他功能)，则可以添加自己的<code>@Configuration</code>类，类型为<code>WebMvcConfigurer</code>，但是 <strong>没有</strong> <code>@EnableWebMvc</code>。如果希望提供<code>RequestMappingHandlerMapping</code>，<code>RequestMappingHandlerAdapter</code>或<code>ExceptionHandlerExceptionResolver</code>的自定义实例，则可以声明<code>WebMvcRegistrationsAdapter</code>实例以提供此类组件。<p>如果要完全控制 Spring MVC，则可以添加自己的<code>@Configuration</code>并以<code>@EnableWebMvc</code>Comments。<h4 id=3-6-1-2、HttpMessageConverters><a class=headerlink href=#3-6-1-2、HttpMessageConverters title=3.6.1.2、HttpMessageConverters></a>3.6.1.2、HttpMessageConverters</h4><p>Spring MVC 使用<code>HttpMessageConverter</code>接口转换 HTTP 请求和响应。开箱即用中包含明智的默认设置。例如，可以将对象自动转换为 JSON(通过使用 Jackson 库)或 XML(通过使用 Jackson XML 扩展(如果可用)或通过使用 JAXB(如果 Jackson XML 扩展不可用))。默认情况下，字符串以<code>UTF-8</code>编码。<p>如果需要添加或定制转换器，则可以使用 Spring Boot 的<code>HttpMessageConverters</code>类，如以下 Lists 所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.boot.autoconfigure.web.HttpMessageConverters;</span><br><span class=line><span class=keyword>import</span> org.springframework.context.annotation.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.http.converter.*;</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyConfiguration</span> {</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> HttpMessageConverters <span class="title function_">customConverters</span><span class=params>()</span> {</span><br><span class=line>		HttpMessageConverter&LT?> additional = ...</span><br><span class=line>		HttpMessageConverter&LT?> another = ...</span><br><span class=line>		<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">HttpMessageConverters</span>(additional, another);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>上下文中存在的任何<code>HttpMessageConverter</code> bean 都将添加到转换器列表中。您也可以用相同的方法覆盖默认转换器。<h4 id=3-6-1-3、自定义JSON序列化器和反序列化器><a class=headerlink href=#3-6-1-3、自定义JSON序列化器和反序列化器 title=3.6.1.3、自定义JSON序列化器和反序列化器></a>3.6.1.3、自定义JSON序列化器和反序列化器</h4><p>如果使用 Jackson 来序列化和反序列化 JSON 数据，则可能要编写自己的<code>JsonSerializer</code>和<code>JsonDeserializer</code>类。自定义序列化器通常是<a href=https://github.com/FasterXML/jackson-docs/wiki/JacksonHowToCustomSerializers rel=noopener target=_blank>通过模块在 Jackson 注册</a>，但是 Spring Boot 提供了<code>@JsonComponent</code>Comments，这使得直接注册 Spring Bean 更加容易。<p>您可以直接在<code>JsonSerializer</code>或<code>JsonDeserializer</code>实现中使用<code>@JsonComponent</code>Comments。您还可以在包含序列化器/反序列化器作为内部类的类上使用它，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.io.*;</span><br><span class=line><span class=keyword>import</span> com.fasterxml.jackson.core.*;</span><br><span class=line><span class=keyword>import</span> com.fasterxml.jackson.databind.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.jackson.*;</span><br><span class=line></span><br><span class=line><span class=meta>@JsonComponent</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Example</span> {</span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">Serializer</span> <span class=keyword>extends</span> <span class="title class_">JsonSerializer</span>&LTSomeObject> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">Deserializer</span> <span class=keyword>extends</span> <span class="title class_">JsonDeserializer</span>&LTSomeObject> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p><code>ApplicationContext</code>中的所有<code>@JsonComponent</code> bean 都会自动向 Jackson 进行注册。因为<code>@JsonComponent</code>是用<code>@Component</code>进行元 Comments 的，所以通常的组件扫描规则适用。<p>Spring Boot 还提供了<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectSerializer.java rel=noopener target=_blank>JsonObjectSerializer</a>和<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jackson/JsonObjectDeserializer.java rel=noopener target=_blank>JsonObjectDeserializer</a>Base Class，这些 Base Class 在序列化对象时为标准 Jackson 版本提供了有用的替代方法。有关详细信息，请参见 Javadoc 中的<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/jackson/JsonObjectSerializer.html rel=noopener target=_blank>JsonObjectSerializer</a>和<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/jackson/JsonObjectDeserializer.html rel=noopener target=_blank>JsonObjectDeserializer</a>。<h4 id=3-6-1-4、MessageCodesResolver><a class=headerlink href=#3-6-1-4、MessageCodesResolver title=3.6.1.4、MessageCodesResolver></a>3.6.1.4、MessageCodesResolver</h4><p>Spring MVC 有一种生成错误代码的策略，该错误代码用于从绑定错误<code>MessageCodesResolver</code>渲染错误消息。如果设置<code>spring.mvc.message-codes-resolver.format</code>属性<code>PREFIX_ERROR_CODE</code>或<code>POSTFIX_ERROR_CODE</code>，Spring Boot 会为您创建一个(请参见<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.Format.html rel=noopener target=_blank>DefaultMessageCodesResolver.Format</a>中的枚举)。<h4 id=3-6-1-5、静态内容><a class=headerlink href=#3-6-1-5、静态内容 title=3.6.1.5、静态内容></a>3.6.1.5、静态内容</h4><p>默认情况下，Spring Boot 从 Classpath 中名为<code>/static</code>(或<code>/public</code>或<code>/resources</code>或<code>/META-INF/resources</code>)的目录或<code>ServletContext</code>的根目录中提供静态内容。它使用 Spring MVC 中的<code>ResourceHttpRequestHandler</code>，因此您可以通过添加自己的<code>WebMvcConfigurer</code>并覆盖<code>addResourceHandlers</code>方法来修改该行为。<p>在独立的 Web 应用程序中，还启用了容器中的默认 servlet，并将其用作后备，如果 Spring 决定不处理<code>ServletContext</code>的根，则从<code>ServletContext</code>的根开始提供内容。在大多数情况下，这不会发生(除非您修改默认的 MVC 配置)，因为 Spring 始终可以通过<code>DispatcherServlet</code>处理请求。<p>默认情况下，资源 Map 在<code>/**</code>上，但是您可以使用<code>spring.mvc.static-path-pattern</code>属性对其进行调整。例如，将所有资源重定位到<code>/resources/**</code>可以实现如下：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.mvc.static-path-pattern=/resources/**</span><br></pre></table></figure><p>您还可以使用<code>spring.resources.static-locations</code>属性来自定义静态资源位置(用目录位置列表替换默认值)。根 Servlet 上下文路径<code>"/"</code>也会自动添加为位置。<p>除了前面提到的“标准”静态资源位置以外，还对<a href=https://www.webjars.org/ rel=noopener target=_blank>Webjars content</a>进行了特殊处理。如果 jar 文件以 Webjars 格式打包，则从 jar 文件提供带有<code>/webjars/**</code>路径的任何资源。<blockquote><p>如果您的应用程序打包为 jar，则不要使用<code>src/main/webapp</code>目录。尽管此目录是一个通用标准，但它仅在 war 打包中有效，并且在生成 jar 时，大多数构建工具都将其忽略。</blockquote><p>Spring Boot 还支持 Spring MVC 提供的高级资源处理功能，允许使用案例，例如缓存清除静态资源或对 Webjars 使用版本无关的 URL。<p>要对 Webjar 使用版本无关的 URL，请添加<code>webjars-locator-core</code>依赖项。然后声明您的 Webjar。以 jQuery 为例，在<code>"/webjars/jquery/x.y.z/jquery.min.js"</code>中添加<code>"/webjars/jquery/jquery.min.js"</code>结果。其中<code>x.y.z</code>是 Webjar 版本。<blockquote><p>如果使用 JBoss，则需要声明<code>webjars-locator-jboss-vfs</code>依赖性而不是<code>webjars-locator-core</code>。否则，所有 Webjar 都解析为<code>404</code>。</blockquote><p>要使用缓存清除，以下配置为所有静态资源配置了缓存清除解决方案，从而有效地在 URL 中添加了内容哈希，例如<code>&LTlink href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/></code>：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>spring.resources.chain.strategy.content.enabled=true</span><br><span class=line>spring.resources.chain.strategy.content.paths=/**</span><br></pre></table></figure><blockquote><p>得益于为 Thymeleaf 和 FreeMarker 自动配置的<code>ResourceUrlEncodingFilter</code>，在运行时将资源链接重写为模板。使用 JSP 时，您应该手动声明此过滤器。当前不自动支持其他模板引擎，但可以与自定义模板宏/帮助器一起使用，并可以使用<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/servlet/resource/ResourceUrlProvider.html rel=noopener target=_blank>ResourceUrlProvider</a>。</blockquote><p>例如，当使用 JavaScript 模块加载器动态加载资源时，不能重命名文件。这就是为什么其他策略也受支持并且可以组合的原因。 “固定”策略在 URL 中添加静态版本字符串，而不会更改文件名，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>spring.resources.chain.strategy.content.enabled=true</span><br><span class=line>spring.resources.chain.strategy.content.paths=/**</span><br><span class=line>spring.resources.chain.strategy.fixed.enabled=true</span><br><span class=line>spring.resources.chain.strategy.fixed.paths=/js/lib/</span><br><span class=line>spring.resources.chain.strategy.fixed.version=v12</span><br></pre></table></figure><p>通过这种配置，位于<code>"/js/lib/"</code>下的 JavaScript 模块使用固定的版本控制策略(<code>"/v12/js/lib/mymodule.js"</code>)，而其他资源仍使用内容版本(<code>&LTlink href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css"/></code>)。<p>有关更多受支持的选项，请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ResourceProperties.java rel=noopener target=_blank>ResourceProperties</a>。<h4 id=3-6-1-6、欢迎页面><a class=headerlink href=#3-6-1-6、欢迎页面 title=3.6.1.6、欢迎页面></a>3.6.1.6、欢迎页面</h4><p>Spring Boot 支持静态和模板欢迎页面。它首先在配置的静态内容位置中查找<code>index.html</code>文件。如果未找到，则它将寻找<code>index</code>模板。如果找到任何一个，它将自动用作应用程序的欢迎页面。<h4 id=3-6-1-7、自定义图标><a class=headerlink href=#3-6-1-7、自定义图标 title=3.6.1.7、自定义图标></a>3.6.1.7、自定义图标</h4><p>Spring Boot 在配置的静态内容位置和 Classpath 的根目录(按此 Sequences)中查找<code>favicon.ico</code>。如果存在这样的文件，它将自动用作应用程序的收藏夹图标。<h4 id=3-6-1-8、路径匹配和内容协商><a class=headerlink href=#3-6-1-8、路径匹配和内容协商 title=3.6.1.8、路径匹配和内容协商></a>3.6.1.8、路径匹配和内容协商</h4><p>Spring MVC 可以通过查看请求路径并将其匹配到应用程序中定义的 Map(例如 Controller 方法上的<code>@GetMapping</code>Comments)，将传入的 HTTP 请求 Map 到处理程序。<p>Spring Boot 默认选择禁用后缀模式匹配，这意味着诸如<code>"GET /projects/spring-boot.json"</code>之类的请求将不会与<code>@GetMapping("/projects/spring-boot")</code>Map 相匹配。这被视为<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc-ann-requestmapping-suffix-pattern-match rel=noopener target=_blank>Spring MVC 应用程序的最佳实践</a>。过去，此功能主要用于未发送正确的“ Accept”请求 Headers 的 HTTP Client 端。我们需要确保将正确的 Content Type 发送给 Client 端。如今，内容协商已变得更加可靠。<p>还有其他处理 HTTP Client 端的方法，这些方法不能始终发送正确的“ Accept”请求 Headers。除了使用后缀匹配，我们还可以使用查询参数来确保将<code>"GET /projects/spring-boot?format=json"</code>之类的请求 Map 到<code>@GetMapping("/projects/spring-boot")</code>：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>spring.mvc.contentnegotiation.favor-parameter=true</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>We can change the parameter name, <span class=built_in>which</span> is <span class=string>"format"</span> by default:</span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>spring.mvc.contentnegotiation.parameter-name=myparam</span></span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>We can also register additional file extensions/media types with:</span></span><br><span class=line>spring.mvc.contentnegotiation.media-types.markdown=text/markdown</span><br></pre></table></figure><p>如果您了解了注意事项，但仍希望您的应用程序使用后缀模式匹配，则需要以下配置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>spring.mvc.contentnegotiation.favor-path-extension=true</span><br><span class=line>spring.mvc.pathmatch.use-suffix-pattern=true</span><br></pre></table></figure><p>另外，与其打开所有后缀模式，不如只支持注册的后缀模式，这是更安全的：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>spring.mvc.contentnegotiation.favor-path-extension=true</span><br><span class=line>spring.mvc.pathmatch.use-registered-suffix-pattern=true</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>You can also register additional file extensions/media types with:</span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>spring.mvc.contentnegotiation.media-types.adoc=text/asciidoc</span></span><br></pre></table></figure><h4 id=3-6-1-9、ConfigurableWebBindingInitializer><a class=headerlink href=#3-6-1-9、ConfigurableWebBindingInitializer title=3.6.1.9、ConfigurableWebBindingInitializer></a>3.6.1.9、ConfigurableWebBindingInitializer</h4><p>Spring MVC 使用<code>WebBindingInitializer</code>来为特定请求初始化<code>WebDataBinder</code>。如果创建自己的<code>ConfigurableWebBindingInitializer</code> <code>@Bean</code>，Spring Boot 会自动将 Spring MVC 配置为使用它。<h4 id=3-6-1-10、模板引擎><a class=headerlink href=#3-6-1-10、模板引擎 title=3.6.1.10、模板引擎></a>3.6.1.10、模板引擎</h4><p>除了 REST Web 服务之外，您还可以使用 Spring MVC 来提供动态 HTML 内容。 Spring MVC 支持各种模板技术，包括 Thymeleaf，FreeMarker 和 JSP。同样，许多其他模板引擎包括他们自己的 Spring MVC 集成。<p>Spring Boot 包括对以下模板引擎的自动配置支持：<ul><li><a href=https://freemarker.apache.org/docs/ rel=noopener target=_blank>FreeMarker</a><li><a href=http://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine rel=noopener target=_blank>Groovy</a><li><a href=http://www.thymeleaf.org/ rel=noopener target=_blank>Thymeleaf</a><li><a href=https://mustache.github.io/ rel=noopener target=_blank>Mustache</a></ul><blockquote><p>如果可能，应避免使用 JSP。与嵌入式 servlet 容器一起使用时，有多个<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-jsp-limitations rel=noopener target=_blank>known limitations</a>。</blockquote><p>当您使用默认配置的这些模板引擎之一时，将从<code>src/main/resources/templates</code>自动拾取模板。<blockquote><p>根据您运行应用程序的方式，IntelliJ IDEA 对 Classpath 的排序方式不同。与使用 Maven 或 Gradle 或从打包的 jar 运行应用程序时，从 IDE 的 Main 方法运行应用程序的 Sequences 会有所不同。这可能会导致 Spring Boot 无法在 Classpath 上找到模板。如果遇到此问题，则可以在 IDE 中重新排序 Classpath，以首先放置模块的类和资源。另外，您可以配置模板前缀以搜索 Classpath 上的每个<code>templates</code>目录，如下所示：<code>classpath*:/templates/</code>。</blockquote><h4 id=3-6-1-11、错误处理><a class=headerlink href=#3-6-1-11、错误处理 title=3.6.1.11、错误处理></a>3.6.1.11、错误处理</h4><p>默认情况下，Spring Boot 提供了一个<code>/error</code>Map，可以明智地处理所有错误，并且已在 servlet 容器中注册为“全局”错误页面。对于机器 Client 端，它将生成 JSON 响应，其中包含错误，HTTP 状态和异常消息的详细信息。对于浏览器 Client 端，存在一个“ whitelabel”错误视图，该视图以 HTML 格式渲染相同的数据(要对其进行自定义，请添加解析为<code>error</code>的<code>View</code>)。要完全替换默认行为，可以实现<code>ErrorController</code>并注册该类型的 Bean 定义，或添加<code>ErrorAttributes</code>类型的 Bean 以使用现有机制但替换其内容。<blockquote><p><code>BasicErrorController</code>可用作自定义<code>ErrorController</code>的 Base Class。如果要为新的 Content Type 添加处理程序(默认是专门处理<code>text/html</code>并为其他所有内容提供后备功能)，则此功能特别有用。为此，扩展<code>BasicErrorController</code>，添加具有<code>produces</code>属性的<code>@RequestMapping</code>的公共方法，并创建新类型的 bean。</blockquote><p>您还可以定义带有<code>@ControllerAdvice</code>Comments 的类，以自定义 JSON 文档以针对特定的控制器和/或异常类型返回，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line>@ControllerAdvice(basePackageClasses = AcmeController.class)</span><br><span class=line>public class AcmeControllerAdvice extends ResponseEntityExceptionHandler {</span><br><span class=line></span><br><span class=line>	@ExceptionHandler(YourException.class)</span><br><span class=line>	@ResponseBody</span><br><span class=line>	ResponseEntity&LT?> handleControllerException(HttpServletRequest request, Throwable ex) {</span><br><span class=line>		HttpStatus status = getStatus(request);</span><br><span class=line>		return new ResponseEntity<>(new CustomErrorType(status.value(), ex.getMessage()), status);</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	private HttpStatus getStatus(HttpServletRequest request) {</span><br><span class=line>		Integer statusCode = (Integer) request.getAttribute("javax.servlet.error.status_code");</span><br><span class=line>		if (statusCode == null) {</span><br><span class=line>			return HttpStatus.INTERNAL_SERVER_ERROR;</span><br><span class=line>		}</span><br><span class=line>		return HttpStatus.valueOf(statusCode);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>在前面的示例中，如果在与<code>AcmeController</code>相同的程序包中定义的控制器抛出<code>YourException</code>，则使用<code>CustomErrorType</code> POJO 的 JSON 表示代替<code>ErrorAttributes</code>表示。<h5 id=自定义错误页面><a class=headerlink href=#自定义错误页面 title=自定义错误页面></a>自定义错误页面</h5><p>如果要显示给定状态代码的自定义 HTML 错误页面，可以将文件添加到<code>/error</code>文件夹。错误页面可以是静态 HTML(即添加到任何静态资源文件夹下)，也可以使用模板来构建。文件名应为确切的状态代码或系列掩码。<p>例如，要将<code>404</code>Map 到静态 HTML 文件，您的文件夹结构如下：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=string>src/</span></span><br><span class=line> <span class=string>+-</span> <span class=string>main/</span></span><br><span class=line>     <span class=string>+-</span> <span class=string>java/</span></span><br><span class=line>     <span class=string>|</span>   <span class=string>+</span> <span class=string>&LTsource</span> <span class=string>code></span></span><br><span class=line>     <span class=string>+-</span> <span class=string>resources/</span></span><br><span class=line>         <span class=string>+-</span> <span class=string>public/</span></span><br><span class=line>             <span class=string>+-</span> <span class=string>error/</span></span><br><span class=line>             <span class=string>|</span>   <span class=string>+-</span> <span class=number>404.</span><span class=string>html</span></span><br><span class=line>             <span class=string>+-</span> <span class=string>&LTother</span> <span class=string>public</span> <span class=string>assets></span></span><br></pre></table></figure><p>要使用 FreeMarker 模板 Map 所有<code>5xx</code>错误，您的文件夹结构如下：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>src/</span><br><span class=line> +- main/</span><br><span class=line>     +- java/</span><br><span class=line>     |   + &LTsource code></span><br><span class=line>     +- resources/</span><br><span class=line>         +- templates/</span><br><span class=line>             +- error/</span><br><span class=line>             |   +- 5xx.ftl</span><br><span class=line>             +- &LTother templates></span><br></pre></table></figure><p>对于更复杂的 Map，还可以添加实现<code>ErrorViewResolver</code>接口的 bean，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyErrorViewResolver</span> <span class=keyword>implements</span> <span class="title class_">ErrorViewResolver</span> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> ModelAndView <span class="title function_">resolveErrorView</span><span class=params>(HttpServletRequest request,</span></span><br><span class=line><span class=params>			HttpStatus status, Map&LTString, Object> model)</span> {</span><br><span class=line>		<span class=comment>// Use the request or status to optionally return a ModelAndView</span></span><br><span class=line>		<span class=keyword>return</span> ...</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>您还可以使用常规的 Spring MVC 功能，例如<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc-exceptionhandlers rel=noopener target=_blank>@ExceptionHandler methods</a>和<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#mvc-ann-controller-advice rel=noopener target=_blank>@ControllerAdvice</a>。 <code>ErrorController</code>然后接收任何未处理的异常。<h5 id=Map-Spring-MVC-之外的错误页面><a title="Map Spring MVC 之外的错误页面" class=headerlink href=#Map-Spring-MVC-之外的错误页面></a>Map Spring MVC 之外的错误页面</h5><p>对于不使用 Spring MVC 的应用程序，可以使用<code>ErrorPageRegistrar</code>接口直接注册<code>ErrorPages</code>。此抽象直接与基础嵌入式 servlet 容器一起使用，即使您没有 Spring MVC <code>DispatcherServlet</code>，也可以使用。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> ErrorPageRegistrar <span class="title function_">errorPageRegistrar</span><span class=params>()</span>{</span><br><span class=line>	<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">MyErrorPageRegistrar</span>();</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// ...</span></span><br><span class=line></span><br><span class=line><span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">MyErrorPageRegistrar</span> <span class=keyword>implements</span> <span class="title class_">ErrorPageRegistrar</span> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">registerErrorPages</span><span class=params>(ErrorPageRegistry registry)</span> {</span><br><span class=line>		registry.addErrorPages(<span class=keyword>new</span> <span class="title class_">ErrorPage</span>(HttpStatus.BAD_REQUEST, <span class=string>"/400"</span>));</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>如果您注册的<code>ErrorPage</code>的路径最终由<code>Filter</code>处理(这在某些非 Spring Web 框架(如 Jersey 和 Wicket)中很常见)，则必须将<code>Filter</code>明确注册为<code>ERROR</code>调度程序，如图所示。下面的例子：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> FilterRegistrationBean <span class="title function_">myFilter</span><span class=params>()</span> {</span><br><span class=line>	<span class=type>FilterRegistrationBean</span> <span class=variable>registration</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">FilterRegistrationBean</span>();</span><br><span class=line>	registration.setFilter(<span class=keyword>new</span> <span class="title class_">MyFilter</span>());</span><br><span class=line>	...</span><br><span class=line>	registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));</span><br><span class=line>	<span class=keyword>return</span> registration;</span><br><span class=line>}</span><br></pre></table></figure></blockquote><p>请注意，默认的<code>FilterRegistrationBean</code>不包括<code>ERROR</code>调度程序类型。<p>注意：Spring Boot 部署到 servlet 容器时，将使用其错误页面过滤器将具有错误状态的请求转发到相应的错误页面。如果尚未提交响应，则只能将请求转发到正确的错误页面。缺省情况下，WebSphere Application Server 8.0 和更高版本在成功完成 servlet 的服务方法后提交响应。您应该通过将<code>com.ibm.ws.webcontainer.invokeFlushAfterService</code>设置为<code>false</code>来禁用此行为。<h4 id=3-6-1-12、Spring-HATEOAS><a title="3.6.1.12、Spring HATEOAS" class=headerlink href=#3-6-1-12、Spring-HATEOAS></a>3.6.1.12、Spring HATEOAS</h4><p>如果您开发使用超媒体的 RESTful API，Spring Boot 将为 Spring HATEOAS 提供自动配置，该配置可与大多数应用程序很好地配合使用。自动配置取代了使用<code>@EnableHypermediaSupport</code>的需要，并注册了许多 Bean 以简化基于超媒体的应用程序的构建，包括<code>LinkDiscoverers</code>(用于 Client 端支持)和<code>ObjectMapper</code>，这些<code>ObjectMapper</code>被配置为将响应正确地编组为所需的表示形式。 <code>ObjectMapper</code>是通过设置各种<code>spring.jackson.*</code>属性来定制的，或者通过设置<code>Jackson2ObjectMapperBuilder</code> bean 来定制(如果存在)。<p>您可以使用<code>@EnableHypermediaSupport</code>来控制 Spring HATEOAS 的配置。请注意，这样做会禁用前面介绍的<code>ObjectMapper</code>自定义。<h4 id=3-6-1-13、CORS支持><a class=headerlink href=#3-6-1-13、CORS支持 title=3.6.1.13、CORS支持></a>3.6.1.13、CORS支持</h4><p><a href=https://en.wikipedia.org/wiki/Cross-origin_resource_sharing rel=noopener target=_blank>跨域资源共享</a>(CORS)是由<a href=https://caniuse.com/#feat=cors rel=noopener target=_blank>most browsers</a>实现的<a href=https://www.w3.org/TR/cors/ rel=noopener target=_blank>W3C specification</a>，可让您灵活地指定授权哪种类型的跨域请求，而不是使用一些安全性和功能不强的方法(例如 IFRAME 或 JSONP)。<p>从 4.2 版本开始，Spring MVC <a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#cors rel=noopener target=_blank>supports CORS</a>。在 Spring Boot 应用程序中使用<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#controller-method-cors-configuration rel=noopener target=_blank>控制器方法 CORS 配置</a>和<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html rel=noopener target=_blank>@CrossOrigin</a>注解不需要任何特定的配置。可以通过使用自定义的<code>addCorsMappings(CorsRegistry)</code>方法注册<code>WebMvcConfigurer</code> bean 来定义<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#global-cors-configuration rel=noopener target=_blank>全局 CORS 配置</a>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyConfiguration</span> {</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> WebMvcConfigurer <span class="title function_">corsConfigurer</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">WebMvcConfigurer</span>() {</span><br><span class=line>			<span class=meta>@Override</span></span><br><span class=line>			<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">addCorsMappings</span><span class=params>(CorsRegistry registry)</span> {</span><br><span class=line>				registry.addMapping(<span class=string>"/api/**"</span>);</span><br><span class=line>			}</span><br><span class=line>		};</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-6-2、“-Spring-WebFlux-框架”><a title="3.6.2、“ Spring WebFlux 框架”" class=headerlink href=#3-6-2、“-Spring-WebFlux-框架”></a>3.6.2、“ Spring WebFlux 框架”</h3><p>Spring WebFlux 是 Spring Framework 5.0 中引入的新的响应式 Web 框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步和非阻塞的，并通过<a href=https://projectreactor.io/ rel=noopener target=_blank>反应堆项目</a>实现<a href=http://www.reactive-streams.org/ rel=noopener target=_blank>Reactive Streams</a>规范。<p>Spring WebFlux 有两种形式：功能性的和基于 Comments 的。基于 Comments 的模型非常类似于 Spring MVC 模型，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=meta>@RestController</span></span><br><span class=line><span class=meta>@RequestMapping("/users")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyRestController</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@GetMapping("/{user}")</span></span><br><span class=line>	<span class=keyword>public</span> Mono&LTUser> <span class="title function_">getUser</span><span class=params>(<span class=meta>@PathVariable</span> Long user)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=meta>@GetMapping("/{user}/customers")</span></span><br><span class=line>	<span class=keyword>public</span> Flux&LTCustomer> <span class="title function_">getUserCustomers</span><span class=params>(<span class=meta>@PathVariable</span> Long user)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=meta>@DeleteMapping("/{user}")</span></span><br><span class=line>	<span class=keyword>public</span> Mono&LTUser> <span class="title function_">deleteUser</span><span class=params>(<span class=meta>@PathVariable</span> Long user)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>功能变体“ WebFlux.fn”将路由配置与请求的实际处理分开，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RoutingConfiguration</span> {</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> RouterFunction&LTServerResponse> <span class="title function_">monoRouterFunction</span><span class=params>(UserHandler userHandler)</span> {</span><br><span class=line>		<span class=keyword>return</span> route(GET(<span class=string>"/{user}"</span>).and(accept(APPLICATION_JSON)), userHandler::getUser)</span><br><span class=line>				.andRoute(GET(<span class=string>"/{user}/customers"</span>).and(accept(APPLICATION_JSON)), userHandler::getUserCustomers)</span><br><span class=line>				.andRoute(DELETE(<span class=string>"/{user}"</span>).and(accept(APPLICATION_JSON)), userHandler::deleteUser);</span><br><span class=line>	}</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">UserHandler</span> {</span><br><span class=line>	<span class=keyword>public</span> Mono&LTServerResponse> <span class="title function_">getUser</span><span class=params>(ServerRequest request)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> Mono&LTServerResponse> <span class="title function_">getUserCustomers</span><span class=params>(ServerRequest request)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> Mono&LTServerResponse> <span class="title function_">deleteUser</span><span class=params>(ServerRequest request)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>WebFlux 是 Spring Framework 的一部分，其<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web-reactive.html#webflux-fn rel=noopener target=_blank>reference documentation</a>中提供了详细信息。<blockquote><p>您可以根据需要定义尽可能多的<code>RouterFunction</code> bean，以对 Router 的定义进行模块化。如果需要应用优先级，可以 Order Bean。</blockquote><p>首先，将<code>spring-boot-starter-webflux</code>模块添加到您的应用程序中。<blockquote><p>在应用程序中同时添加<code>spring-boot-starter-web</code>和<code>spring-boot-starter-webflux</code>模块会导致 Spring Boot 自动配置 Spring MVC，而不是 WebFlux。之所以选择这种行为，是因为许多 Spring 开发人员将<code>spring-boot-starter-webflux</code>添加到他们的 Spring MVC 应用程序中以使用 Reactive<code>WebClient</code>。您仍然可以通过将选定的应用程序类型设置为<code>SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)</code>来强制执行选择。</blockquote><h4 id=3-6-2-1、Spring-WebFlux-自动配置><a title="3.6.2.1、Spring WebFlux 自动配置" class=headerlink href=#3-6-2-1、Spring-WebFlux-自动配置></a>3.6.2.1、Spring WebFlux 自动配置</h4><p>Spring Boot 为 Spring WebFlux 提供了自动配置，可与大多数应用程序完美配合。<p>自动配置在 Spring 的默认值之上添加了以下功能：<ul><li>为<code>HttpMessageReader</code>和<code>HttpMessageWriter</code>实例(说明<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-webflux-httpcodecs rel=noopener target=_blank>本文档后面</a>)配置编解码器。<li>支持服务静态资源，包括对 WebJars 的支持(描述为<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-spring-mvc-static-content rel=noopener target=_blank>本文档后面</a>)。</ul><p>如果您想保留 Spring Boot WebFlux 功能，并且想要添加其他<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#web-reactive rel=noopener target=_blank>WebFlux configuration</a>，则可以添加自己的<code>@Configuration</code>类，类型为<code>WebFluxConfigurer</code>，但 <strong>没有</strong> <code>@EnableWebFlux</code>。<p>如果要完全控制 Spring WebFlux，则可以添加带有<code>@EnableWebFlux</code>Comments 的自己的<code>@Configuration</code>。<h4 id=3-6-2-2、带有-HttpMessageReaders-和-HttpMessageWriters-的-HTTP-编解码器><a title="3.6.2.2、带有 HttpMessageReaders 和 HttpMessageWriters 的 HTTP 编解码器" class=headerlink href=#3-6-2-2、带有-HttpMessageReaders-和-HttpMessageWriters-的-HTTP-编解码器></a>3.6.2.2、带有 HttpMessageReaders 和 HttpMessageWriters 的 HTTP 编解码器</h4><p>Spring WebFlux 使用<code>HttpMessageReader</code>和<code>HttpMessageWriter</code>接口转换 HTTP 请求和响应。通过查看 Classpath 中可用的库，将它们配置为<code>CodecConfigurer</code>以具有合理的默认值。<p>Spring Boot 通过使用<code>CodecCustomizer</code>实例应用进一步的自定义。例如，将<code>spring.jackson.*</code>个配置密钥应用于 Jackson 编解码器。<p>如果需要添加或自定义编解码器，则可以创建自定义<code>CodecCustomizer</code>组件，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.boot.web.codec.CodecCustomizer;</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyConfiguration</span> {</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> CodecCustomizer <span class="title function_">myCodecCustomizer</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> codecConfigurer -> {</span><br><span class=line>			<span class=comment>// ...</span></span><br><span class=line>		}</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>您还可以使用<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-json-components rel=noopener target=_blank>Boot 的自定义 JSON 序列化器和反序列化器</a>。<h4 id=3-6-2-3、静态内容><a class=headerlink href=#3-6-2-3、静态内容 title=3.6.2.3、静态内容></a>3.6.2.3、静态内容</h4><p>默认情况下，Spring Boot 从 Classpath 中名为<code>/static</code>(或<code>/public</code>或<code>/resources</code>或<code>/META-INF/resources</code>)的目录中提供静态内容。它使用 Spring WebFlux 中的<code>ResourceWebHandler</code>，以便您可以通过添加自己的<code>WebFluxConfigurer</code>并覆盖<code>addResourceHandlers</code>方法来修改该行为。<p>默认情况下，资源 Map 在<code>/**</code>上，但是您可以通过设置<code>spring.webflux.static-path-pattern</code>属性对其进行调整。例如，将所有资源重定位到<code>/resources/**</code>可以实现如下：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.webflux.static-path-pattern=/resources/**</span><br></pre></table></figure><p>您还可以使用<code>spring.resources.static-locations</code>自定义静态资源位置。这样做会将默认值替换为目录位置列表。如果这样做，默认的欢迎页面检测将切换到您的自定义位置。因此，如果启动时您的任何位置都存在<code>index.html</code>，则它是应用程序的主页。<p>除了前面列出的“标准”静态资源位置之外，<a href=https://www.webjars.org/ rel=noopener target=_blank>Webjars content</a>也是一种特殊情况。如果 jar 文件以 Webjars 格式打包，则从 jar 文件提供带有<code>/webjars/**</code>路径的任何资源。<blockquote><p>Spring WebFlux 应用程序不严格依赖 Servlet API，因此不能将它们部署为 war 文件，也不使用<code>src/main/webapp</code>目录。</blockquote><h4 id=3-6-2-4、模板引擎><a class=headerlink href=#3-6-2-4、模板引擎 title=3.6.2.4、模板引擎></a>3.6.2.4、模板引擎</h4><p>除了 REST Web 服务之外，您还可以使用 Spring WebFlux 来提供动态 HTML 内容。 Spring WebFlux 支持多种模板技术，包括 Thymeleaf，FreeMarker 和 Mustache。<p>Spring Boot 包括对以下模板引擎的自动配置支持：<ul><li><a href=https://freemarker.apache.org/docs/ rel=noopener target=_blank>FreeMarker</a><li><a href=http://www.thymeleaf.org/ rel=noopener target=_blank>Thymeleaf</a><li><a href=https://mustache.github.io/ rel=noopener target=_blank>Mustache</a></ul><p>当您使用默认配置的这些模板引擎之一时，将从<code>src/main/resources/templates</code>自动拾取模板。<h4 id=3-6-2-5、错误处理><a class=headerlink href=#3-6-2-5、错误处理 title=3.6.2.5、错误处理></a>3.6.2.5、错误处理</h4><p>Spring Boot 提供了一个<code>WebExceptionHandler</code>，可以明智地处理所有错误。它在处理 Sequences 中的位置紧靠 WebFlux 提供的处理程序之前，该处理程序被认为是最后一个。对于机器 Client 端，它将生成 JSON 响应，其中包含错误，HTTP 状态和异常消息的详细信息。对于浏览器 Client 端，有一个“ whitelabel”错误处理程序，以 HTML 格式渲染相同的数据。您还可以提供自己的 HTML 模板来显示错误(请参见<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-webflux-error-handling-custom-error-pages rel=noopener target=_blank>next section</a>)。<p>定制此功能的第一步通常涉及使用现有机制，但替换或增加错误内容。为此，您可以添加<code>ErrorAttributes</code>类型的 bean。<p>要更改错误处理行为，可以实现<code>ErrorWebExceptionHandler</code>并注册该类型的 bean 定义。由于<code>WebExceptionHandler</code>的级别很低，因此 Spring Boot 还提供了一个方便的<code>AbstractErrorWebExceptionHandler</code>，让您以 WebFlux 功能方式处理错误，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CustomErrorWebExceptionHandler</span> <span class=keyword>extends</span> <span class="title class_">AbstractErrorWebExceptionHandler</span> {</span><br><span class=line>	<span class=comment>// Define constructor here</span></span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>protected</span> RouterFunction&LTServerResponse> <span class="title function_">getRoutingFunction</span><span class=params>(ErrorAttributes errorAttributes)</span> {</span><br><span class=line></span><br><span class=line>		<span class=keyword>return</span> RouterFunctions</span><br><span class=line>				.route(aPredicate, aHandler)</span><br><span class=line>				.andRoute(anotherPredicate, anotherHandler);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>要获得更完整的图片，您还可以直接继承<code>DefaultErrorWebExceptionHandler</code>并重写特定方法。<h5 id=自定义错误页面-1><a class=headerlink href=#自定义错误页面-1 title=自定义错误页面></a>自定义错误页面</h5><p>如果要显示给定状态代码的自定义 HTML 错误页面，可以将文件添加到<code>/error</code>文件夹。错误页面可以是静态 HTML(即添加到任何静态资源文件夹下)，也可以使用模板构建。文件名应为确切的状态代码或系列掩码。<p>例如，要将<code>404</code>Map 到静态 HTML 文件，您的文件夹结构如下：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>src/</span><br><span class=line> +- main/</span><br><span class=line>     +- java/</span><br><span class=line>     |   + &LTsource code></span><br><span class=line>     +- resources/</span><br><span class=line>         +- public/</span><br><span class=line>             +- error/</span><br><span class=line>             |   +- 404.html</span><br><span class=line>             +- &LTother public assets></span><br></pre></table></figure><p>要使用 Mustache 模板 Map 所有<code>5xx</code>错误，您的文件夹结构如下：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>src/</span><br><span class=line> +- main/</span><br><span class=line>     +- java/</span><br><span class=line>     |   + &LTsource code></span><br><span class=line>     +- resources/</span><br><span class=line>         +- templates/</span><br><span class=line>             +- error/</span><br><span class=line>             |   +- 5xx.mustache</span><br><span class=line>             +- &LTother templates></span><br></pre></table></figure><h4 id=3-6-2-6、网页过滤器><a class=headerlink href=#3-6-2-6、网页过滤器 title=3.6.2.6、网页过滤器></a>3.6.2.6、网页过滤器</h4><p>Spring WebFlux 提供了一个<code>WebFilter</code>接口，可以实现该接口来过滤 HTTP 请求-响应交换。在应用程序上下文中找到的<code>WebFilter</code> bean 将自动用于过滤每次交换。<p>在过滤器 Sequences 很重要的地方，它们可以实现<code>Ordered</code>或用<code>@Order</code>Comments。 Spring Boot 自动配置可能会为您配置 Web 过滤器。这样做时，将使用下表中显示的 Sequences：<table><thead><tr><th>Web Filter<th>Order<tbody><tr><td><code>MetricsWebFilter</code><td><code>Ordered.HIGHEST_PRECEDENCE + 1</code><tr><td><code>WebFilterChainProxy</code>(Spring Security 性)<td><code>-100</code><tr><td><code>HttpTraceWebFilter</code><td><code>Ordered.LOWEST_PRECEDENCE - 10</code></table><h3 id=3-6-3、JAX-RX和Jersey><a class=headerlink href=#3-6-3、JAX-RX和Jersey title=3.6.3、JAX-RX和Jersey></a>3.6.3、JAX-RX和Jersey</h3><p>如果您更喜欢 REST 端点的 JAX-RS 编程模型，则可以使用可用的实现之一来代替 Spring MVC。 <a href=https://jersey.github.io/ rel=noopener target=_blank>Jersey</a>和<a href=https://cxf.apache.org/ rel=noopener target=_blank>Apache CXF</a>开箱即用。 CXF 要求您在应用程序上下文中将其<code>Servlet</code>或<code>Filter</code>注册为<code>@Bean</code>。Jersey(Jersey)有一些本机 Spring 支持，因此我们在 Spring Boot 中还与启动程序一起为其提供了自动配置支持。<p>要开始使用 Jersey，请将<code>spring-boot-starter-jersey</code>作为依赖项，然后需要一个<code>ResourceConfig</code>类型的<code>@Bean</code>，在其中注册所有端点，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">JerseyConfig</span> <span class=keyword>extends</span> <span class="title class_">ResourceConfig</span> {</span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">JerseyConfig</span><span class=params>()</span> {</span><br><span class=line>		register(Endpoint.class);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>Jersey 对扫描可执行归档文件的支持非常有限。例如，在运行可执行的 war 文件时，它无法扫描在<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/deployment-install.html rel=noopener target=_blank>完全可执行的 jar 文件</a>或<code>WEB-INF/classes</code>中找到的程序包中的端点。为避免此限制，不应使用<code>packages</code>方法，并且应使用<code>register</code>方法分别注册端点，如前面的示例所示。</blockquote><p>对于更高级的定制，您还可以注册实现<code>ResourceConfigCustomizer</code>的任意数量的 bean。<p>所有注册的端点都应为<code>@Components</code>，并带有 HTTP 资源 Comments(<code>@GET</code>和其他 Comments)，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Path("/hello")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Endpoint</span> {</span><br><span class=line>	<span class=meta>@GET</span></span><br><span class=line>	<span class=keyword>public</span> String <span class="title function_">message</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=string>"Hello"</span>;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>由于<code>Endpoint</code>是 Spring <code>@Component</code>，其生命周期由 Spring Management，因此您可以使用<code>@Autowired</code>注解注入依赖项，并使用<code>@Value</code>注解注入外部配置。默认情况下，Jersey servlet 已注册并 Map 到<code>/*</code>。您可以通过将<code>@ApplicationPath</code>添加到<code>ResourceConfig</code>来更改 Map。<p>默认情况下，Jersey 在名为<code>jerseyServletRegistration</code>的<code>ServletRegistrationBean</code>类型的<code>@Bean</code>中设置为 Servlet。默认情况下，该 Servlet 延迟初始化，但是您可以通过设置<code>spring.jersey.servlet.load-on-startup</code>来自定义该行为。您可以通过使用相同的名称创建自己的一个来禁用或覆盖该 bean。您还可以通过设置<code>spring.jersey.type=filter</code>(在这种情况下，要替换或覆盖的<code>@Bean</code>是<code>jerseyFilterRegistration</code>)来使用过滤器而不是 Servlet。过滤器具有<code>@Order</code>，您可以使用<code>spring.jersey.filter.order</code>进行设置。可以使用<code>spring.jersey.init.*</code>指定属性 Map，从而为 servlet 和过滤器注册都赋予 init 参数。<p>有一个<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-samples/spring-boot-sample-jersey rel=noopener target=_blank>Jersey sample</a>，以便您可以了解如何进行设置。<h3 id=3-6-4、嵌入式Servlet容器支持><a class=headerlink href=#3-6-4、嵌入式Servlet容器支持 title=3.6.4、嵌入式Servlet容器支持></a>3.6.4、嵌入式Servlet容器支持</h3><p>Spring Boot 包含对嵌入式<a href=https://tomcat.apache.org/ rel=noopener target=_blank>Tomcat</a>，<a href=https://www.eclipse.org/jetty/ rel=noopener target=_blank>Jetty</a>和<a href=http://undertow.io/ rel=noopener target=_blank>Undertow</a>服务器的支持。大多数开发人员使用适当的“启动器”来获取完全配置的实例。默认情况下，嵌入式服务器在端口<code>8080</code>上侦听 HTTP 请求。<blockquote><p>如果选择在<a href=https://www.centos.org/ rel=noopener target=_blank>CentOS</a>上使用 Tomcat，请注意，默认情况下，将使用一个临时目录来存储编译的 JSP，文件上载等等。您的应用程序运行时，此目录可能被<code>tmpwatch</code>删除，从而导致失败。为避免这种情况，您可能需要自定义<code>tmpwatch</code>配置，以使<code>tomcat.*</code>目录不会被删除，或配置<code>server.tomcat.basedir</code>，以使嵌入式 Tomcat 使用其他位置。</blockquote><h4 id=3-6-4-1、Servlet，过滤器和侦听器><a class=headerlink href=#3-6-4-1、Servlet，过滤器和侦听器 title=3.6.4.1、Servlet，过滤器和侦听器></a>3.6.4.1、Servlet，过滤器和侦听器</h4><p>使用嵌入式 Servlet 容器时，可以通过使用 Spring bean 或扫描 Servlet 组件来注册 Servlet 规范中的 Servlet，过滤器和所有侦听器(例如<code>HttpSessionListener</code>)。<h5 id=将-Servlet，过滤器和侦听器注册为-Spring-Bean><a title="将 Servlet，过滤器和侦听器注册为 Spring Bean" class=headerlink href=#将-Servlet，过滤器和侦听器注册为-Spring-Bean></a>将 Servlet，过滤器和侦听器注册为 Spring Bean</h5><p>任何作为 Spring bean 的<code>Servlet</code>，<code>Filter</code>或 servlet <code>*Listener</code>实例都向嵌入式容器注册。如果要在配置过程中引用<code>application.properties</code>中的值，这可能特别方便。<p>默认情况下，如果上下文仅包含单个 Servlet，则将其 Map 到<code>/</code>。对于多个 servlet bean，bean 名称用作路径前缀。过滤器 Map 到<code>/*</code>。<p>如果基于约定的 Map 不够灵活，则可以使用<code>ServletRegistrationBean</code>，<code>FilterRegistrationBean</code>和<code>ServletListenerRegistrationBean</code>类进行完全控制。<p>Spring Boot 附带了许多可能定义 Filter bean 的自动配置。以下是过滤器及其各自 Sequences 的一些示例(较低的 Sequences 值表示较高的优先级)：<table><thead><tr><th>Servlet Filter<th>Order<tbody><tr><td><code>OrderedCharacterEncodingFilter</code><td><code>Ordered.HIGHEST_PRECEDENCE</code><tr><td><code>WebMvcMetricsFilter</code><td><code>Ordered.HIGHEST_PRECEDENCE + 1</code><tr><td><code>ErrorPageFilter</code><td><code>Ordered.HIGHEST_PRECEDENCE + 1</code><tr><td><code>HttpTraceFilter</code><td><code>Ordered.LOWEST_PRECEDENCE - 10</code></table><p>通常可以使无序滤 bean 处于无序状态。<p>如果需要特定的 Sequences，则应避免配置一个在<code>Ordered.HIGHEST_PRECEDENCE</code>读取请求正文的过滤器，因为它可能与应用程序的字符编码配置不符。如果 Servlet 过滤器包装了请求，则应以小于或等于<code>OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER</code>的 Sequences 对其进行配置。<h4 id=3-6-4-2、Servlet-上下文初始化><a title="3.6.4.2、Servlet 上下文初始化" class=headerlink href=#3-6-4-2、Servlet-上下文初始化></a>3.6.4.2、Servlet 上下文初始化</h4><p>嵌入式 Servlet 容器不会直接执行 Servlet 3.0 <code>javax.servlet.ServletContainerInitializer</code>接口或 Spring 的<code>org.springframework.web.WebApplicationInitializer</code>接口。这是一个有意设计的决定，目的是减少旨在在 War 中运行的第三方库可能破坏 Spring Boot 应用程序的风险。<p>如果需要在 Spring Boot 应用程序中执行 servlet 上下文初始化，则应该注册一个实现<code>org.springframework.boot.web.servlet.ServletContextInitializer</code>接口的 bean。单个<code>onStartup</code>方法提供对<code>ServletContext</code>的访问，并且在必要时可以轻松地用作现有<code>WebApplicationInitializer</code>的适配器。<h5 id=扫描-Servlet，过滤器和侦听器><a title="扫描 Servlet，过滤器和侦听器" class=headerlink href=#扫描-Servlet，过滤器和侦听器></a>扫描 Servlet，过滤器和侦听器</h5><p>使用嵌入式容器时，可以通过使用<code>@ServletComponentScan</code>来启用自动注册带有<code>@WebServlet</code>，<code>@WebFilter</code>和<code>@WebListener</code>Comments 的类。<blockquote><p><code>@ServletComponentScan</code>在独立容器中无效，而是使用该容器的内置发现机制。</blockquote><h4 id=3-6-4-3、ServletWebServerApplicationContext><a class=headerlink href=#3-6-4-3、ServletWebServerApplicationContext title=3.6.4.3、ServletWebServerApplicationContext></a>3.6.4.3、ServletWebServerApplicationContext</h4><p>在后台，Spring Boot 使用另一种类型的<code>ApplicationContext</code>来支持嵌入式 servlet 容器。 <code>ServletWebServerApplicationContext</code>是<code>WebApplicationContext</code>的一种特殊类型，它通过搜索单个<code>ServletWebServerFactory</code> bean 来进行自我引导。通常<code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>或<code>UndertowServletWebServerFactory</code>已被自动配置。<blockquote><p>通常，您不需要了解这些实现类。大多数应用程序都是自动配置的，并且代表您创建了相应的<code>ApplicationContext</code>和<code>ServletWebServerFactory</code>。</blockquote><h4 id=3-6-4-4、自定义嵌入式-Servlet-容器><a title="3.6.4.4、自定义嵌入式 Servlet 容器" class=headerlink href=#3-6-4-4、自定义嵌入式-Servlet-容器></a>3.6.4.4、自定义嵌入式 Servlet 容器</h4><p>可以使用 Spring <code>Environment</code>属性来配置常见的 servlet 容器设置。通常，您将在<code>application.properties</code>文件中定义属性。<p>常用服务器设置包括：<ul><li>网络设置：侦听传入 HTTP 请求的端口(<code>server.port</code>)，绑定到<code>server.address</code>的接口地址，等等。<li>会话设置：会话是否持久(<code>server.servlet.session.persistence</code>)，会话超时(<code>server.servlet.session.timeout</code>)，会话数据的位置(<code>server.servlet.session.store-dir</code>)和会话 cookie 配置(<code>server.servlet.session.cookie.*</code>)。<li>错误 Management：错误页面的位置(<code>server.error.path</code>)，依此类推。<li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/howto-embedded-web-servers.html#howto-configure-ssl rel=noopener target=_blank>SSL</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/howto-embedded-web-servers.html#how-to-enable-http-response-compression rel=noopener target=_blank>HTTP compression</a></ul><p>Spring Boot 尝试尽可能多地公开通用设置，但这并不总是可能的。在这种情况下，专用名称空间提供服务器特定的自定义项(请参见<code>server.tomcat</code>和<code>server.undertow</code>)。例如，<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/howto-embedded-web-servers.html#howto-configure-accesslogs rel=noopener target=_blank>access logs</a>可以配置有嵌入式 Servlet 容器的特定功能。<h5 id=Programmatic-Customization><a title="Programmatic Customization" class=headerlink href=#Programmatic-Customization></a>Programmatic Customization</h5><p>如果需要以编程方式配置嵌入式 servlet 容器，则可以注册一个实现<code>WebServerFactoryCustomizer</code>接口的 Spring bean。 <code>WebServerFactoryCustomizer</code>提供对<code>ConfigurableServletWebServerFactory</code>的访问，其中包括许多自定义设置方法。以下示例显示以编程方式设置端口：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.boot.web.server.WebServerFactoryCustomizer;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CustomizationBean</span> <span class=keyword>implements</span> <span class="title class_">WebServerFactoryCustomizer</span>&LTConfigurableServletWebServerFactory> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">customize</span><span class=params>(ConfigurableServletWebServerFactory server)</span> {</span><br><span class=line>		server.setPort(<span class=number>9000</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p><code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>和<code>UndertowServletWebServerFactory</code>是<code>ConfigurableServletWebServerFactory</code>的专用变体，分别具有针对 Tomcat，Jetty 和 Undertow 的其他自定义设置方法。</blockquote><h5 id=直接自定义-ConfigurableServletWebServerFactory><a title="直接自定义 ConfigurableServletWebServerFactory" class=headerlink href=#直接自定义-ConfigurableServletWebServerFactory></a>直接自定义 ConfigurableServletWebServerFactory</h5><p>如果上述定制技术太有限，则可以自己注册<code>TomcatServletWebServerFactory</code>，<code>JettyServletWebServerFactory</code>或<code>UndertowServletWebServerFactory</code> bean。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> ConfigurableServletWebServerFactory <span class="title function_">webServerFactory</span><span class=params>()</span> {</span><br><span class=line>	<span class=type>TomcatServletWebServerFactory</span> <span class=variable>factory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TomcatServletWebServerFactory</span>();</span><br><span class=line>	factory.setPort(<span class=number>9000</span>);</span><br><span class=line>	factory.setSessionTimeout(<span class=number>10</span>, TimeUnit.MINUTES);</span><br><span class=line>	factory.addErrorPages(<span class=keyword>new</span> <span class="title class_">ErrorPage</span>(HttpStatus.NOT_FOUND, <span class=string>"/notfound.html"</span>));</span><br><span class=line>	<span class=keyword>return</span> factory;</span><br><span class=line>}</span><br></pre></table></figure><p>提供了许多配置选项的设置器。如果您需要做一些更奇特的操作，还提供了几种受保护的方法“钩子”。有关详情，请参见<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/web/servlet/server/ConfigurableServletWebServerFactory.html rel=noopener target=_blank>源代码文档</a>。<h4 id=3-6-4-5、JSP限制><a class=headerlink href=#3-6-4-5、JSP限制 title=3.6.4.5、JSP限制></a>3.6.4.5、JSP限制</h4><p>当运行使用嵌入式 servlet 容器(并打包为可执行归档文件)的 Spring Boot 应用程序时，JSP 支持存在一些限制。<ul><li>对于 Jetty 和 Tomcat，如果使用 War 包装，它应该可以工作。与<code>java -jar</code>一起启动时，可执行的 War 将起作用，并且也可部署到任何标准容器中。使用可执行 jar 时，不支持 JSP。<li>Undertow 不支持 JSP。<li>创建自定义<code>error.jsp</code>页面不会覆盖<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-error-handling rel=noopener target=_blank>error handling</a>的默认视图。应该改用<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-error-handling-custom-error-pages rel=noopener target=_blank>自定义错误页面</a>。</ul><p>有一个<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-samples/spring-boot-sample-web-jsp rel=noopener target=_blank>JSP sample</a>，以便您可以了解如何进行设置。<h3 id=3-6-5、嵌入式反应式服务器支持><a class=headerlink href=#3-6-5、嵌入式反应式服务器支持 title=3.6.5、嵌入式反应式服务器支持></a>3.6.5、嵌入式反应式服务器支持</h3><p>Spring Boot 包含对以下嵌入式反应式 Web 服务器的支持：Reactor Netty，Tomcat，Jetty 和 Undertow。大多数开发人员使用适当的“启动器”来获取完全配置的实例。默认情况下，嵌入式服务器在端口 8080 上侦听 HTTP 请求。<h3 id=3-6-6、Reactive-服务器资源配置><a title="3.6.6、Reactive 服务器资源配置" class=headerlink href=#3-6-6、Reactive-服务器资源配置></a>3.6.6、Reactive 服务器资源配置</h3><p>当自动配置 Reactor Netty 或 Jetty 服务器时，Spring Boot 将创建特定的 bean，这些 bean 将为服务器实例提供 HTTP 资源：<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code>。<p>默认情况下，在以下情况下，这些资源还将与 Reactor Netty 和 Jetty Client 端共享，以实现最佳性能：<ul><li>服务器和 Client 端使用相同的技术<li>Client 端实例是使用 Spring Boot 自动配置的<code>WebClient.Builder</code> bean 构建的</ul><p>通过提供自定义的<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code> bean，开发人员可以覆盖 Jetty 和 Reactor Netty 的资源配置-这将同时应用于 Client 端和服务器。<p>您可以在<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-webclient.html#boot-features-webclient-runtime rel=noopener target=_blank>WebClient 运行时部分</a>中了解有关 Client 端资源配置的更多信息。<h2 id=3-7、Security><a class=headerlink href=#3-7、Security title=3.7、Security></a>3.7、Security</h2><p>如果<a href=https://projects.spring.io/spring-security/ rel=noopener target=_blank>Spring Security</a>在 Classpath 上，则默认情况下将保护 Web 应用程序的安全。 Spring Boot 依靠 Spring Security 的内容协商策略来确定使用<code>httpBasic</code>还是<code>formLogin</code>。要将方法级安全性添加到 Web 应用程序，您还可以使用所需的设置添加<code>@EnableGlobalMethodSecurity</code>。其他信息可以在<a href=https://docs.spring.io/spring-security/site/docs/5.1.2.RELEASE/reference/htmlsingle#jc-method rel=noopener target=_blank>Spring Security 参考指南</a>中找到。<p>默认的<code>UserDetailsService</code>有一个用户。用户名为<code>user</code>，密码为随机密码，并在应用程序启动时以 INFO 级别显示，如下例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>Using generated security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35</span><br></pre></table></figure><blockquote><p>如果您微调日志记录配置，请确保将<code>org.springframework.boot.autoconfigure.security</code>类别设置为记录<code>INFO</code>级消息。否则，不会打印默认密码。</blockquote><p>您可以通过提供<code>spring.security.user.name</code>和<code>spring.security.user.password</code>来更改用户名和密码。<p>默认情况下，您在 Web 应用程序中获得的基本功能是：<ul><li>具有内存存储的<code>UserDetailsService</code>(或 WebFlux 应用程序为<code>ReactiveUserDetailsService</code>)bean 和具有生成的密码的单个用户(有关用户的属性，请参见<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/autoconfigure/security/SecurityProperties.User.html rel=noopener target=_blank>SecurityProperties.User</a>)。<li>整个应用程序的基于表单的登录或 HTTP 基本安全性(取决于 Content-Type)(如果 Actuator 位于 Classpath 上，则包括 Actuator 端点)。<li><code>DefaultAuthenticationEventPublisher</code>用于发布身份验证事件。</ul><p>您可以通过添加一个 Bean 来提供另一个<code>AuthenticationEventPublisher</code>。<h3 id=3-7-1、MVC安全性><a class=headerlink href=#3-7-1、MVC安全性 title=3.7.1、MVC安全性></a>3.7.1、MVC安全性</h3><p>默认的安全配置在<code>SecurityAutoConfiguration</code>和<code>UserDetailsServiceAutoConfiguration</code>中实现。 <code>SecurityAutoConfiguration</code>导入<code>SpringBootWebSecurityConfiguration</code>以获得 Web 安全性，并且<code>UserDetailsServiceAutoConfiguration</code>配置身份验证，这也与非 Web 应用程序相关。要完全关闭默认的 Web 应用程序安全性配置，可以添加类型为<code>WebSecurityConfigurerAdapter</code>的 bean(这样做不会禁用<code>UserDetailsService</code>配置或 Actuator 的安全性)。<p>要也关闭<code>UserDetailsService</code>配置，可以添加<code>UserDetailsService</code>，<code>AuthenticationProvider</code>或<code>AuthenticationManager</code>类型的 Bean。 <a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-samples/ rel=noopener target=_blank>Spring Bootsample</a>中有几个安全的应用程序，可帮助您开始使用常见的用例。<p>通过添加自定义<code>WebSecurityConfigurerAdapter</code>可以覆盖访问规则。 Spring Boot 提供了便利的方法，可用于覆盖 Actuator 端点和静态资源的访问规则。 <code>EndpointRequest</code>可用于创建基于<code>management.endpoints.web.base-path</code>属性的<code>RequestMatcher</code>。 <code>PathRequest</code>可用于为常用位置的资源创建<code>RequestMatcher</code>。<h3 id=3-7-2、WebFlux-安全性><a title="3.7.2、WebFlux 安全性" class=headerlink href=#3-7-2、WebFlux-安全性></a>3.7.2、WebFlux 安全性</h3><p>与 Spring MVC 应用程序类似，您可以通过添加<code>spring-boot-starter-security</code>依赖项来保护 WebFlux 应用程序。默认的安全配置在<code>ReactiveSecurityAutoConfiguration</code>和<code>UserDetailsServiceAutoConfiguration</code>中实现。 <code>ReactiveSecurityAutoConfiguration</code>导入<code>WebFluxSecurityConfiguration</code>以获得 Web 安全性，并且<code>UserDetailsServiceAutoConfiguration</code>配置身份验证，这也与非 Web 应用程序相关。要完全关闭默认的 Web 应用程序安全性配置，可以添加类型为<code>WebFilterChainProxy</code>的 bean(这样做不会禁用<code>UserDetailsService</code>配置或 Actuator 的安全性)。<p>要也关闭<code>UserDetailsService</code>配置，可以添加<code>ReactiveUserDetailsService</code>或<code>ReactiveAuthenticationManager</code>类型的 Bean。<p>可以通过添加自定义<code>SecurityWebFilterChain</code>来配置访问规则。 Spring Boot 提供了便利的方法，可用于覆盖 Actuator 端点和静态资源的访问规则。 <code>EndpointRequest</code>可用于创建基于<code>management.endpoints.web.base-path</code>属性的<code>ServerWebExchangeMatcher</code>。<p><code>PathRequest</code>可用于为常用位置的资源创建<code>ServerWebExchangeMatcher</code>。<p>例如，您可以通过添加以下内容来自定义安全配置：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> SecurityWebFilterChain <span class="title function_">springSecurityFilterChain</span><span class=params>(ServerHttpSecurity http)</span> {</span><br><span class=line>	<span class=keyword>return</span> http</span><br><span class=line>		.authorizeExchange()</span><br><span class=line>.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll()</span><br><span class=line>			.pathMatchers(<span class=string>"/foo"</span>, <span class=string>"/bar"</span>)</span><br><span class=line>				.authenticated().and()</span><br><span class=line>			.formLogin().and()</span><br><span class=line>		.build();</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-7-3、OAuth2><a class=headerlink href=#3-7-3、OAuth2 title=3.7.3、OAuth2></a>3.7.3、OAuth2</h3><p><a href=https://oauth.net/2/ rel=noopener target=_blank>OAuth2</a>是 Spring 支持的广泛使用的授权框架。<h4 id=3-7-3-1、Client><a class=headerlink href=#3-7-3-1、Client title=3.7.3.1、Client></a>3.7.3.1、Client</h4><p>如果您的 Classpath 上有<code>spring-security-oauth2-client</code>，则可以利用一些自动配置功能来轻松设置 OAuth2/Open ID Connect Client 端。此配置使用<code>OAuth2ClientProperties</code>下的属性。相同的属性适用于 servlet 和反应式应用程序。<p>您可以使用<code>spring.security.oauth2.client</code>前缀注册多个 OAuth2 Client 端和提供者，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line>spring.security.oauth2.client.registration.my-client-1.client-id=abcd</span><br><span class=line>spring.security.oauth2.client.registration.my-client-1.client-secret=password</span><br><span class=line>spring.security.oauth2.client.registration.my-client-1.client-name=Client for user scope</span><br><span class=line>spring.security.oauth2.client.registration.my-client-1.provider=my-oauth-provider</span><br><span class=line>spring.security.oauth2.client.registration.my-client-1.scope=user</span><br><span class=line>spring.security.oauth2.client.registration.my-client-1.redirect-uri-template=http://my-redirect-uri.com</span><br><span class=line>spring.security.oauth2.client.registration.my-client-1.client-authentication-method=basic</span><br><span class=line>spring.security.oauth2.client.registration.my-client-1.authorization-grant-type=authorization_code</span><br><span class=line></span><br><span class=line>spring.security.oauth2.client.registration.my-client-2.client-id=abcd</span><br><span class=line>spring.security.oauth2.client.registration.my-client-2.client-secret=password</span><br><span class=line>spring.security.oauth2.client.registration.my-client-2.client-name=Client for email scope</span><br><span class=line>spring.security.oauth2.client.registration.my-client-2.provider=my-oauth-provider</span><br><span class=line>spring.security.oauth2.client.registration.my-client-2.scope=email</span><br><span class=line>spring.security.oauth2.client.registration.my-client-2.redirect-uri-template=http://my-redirect-uri.com</span><br><span class=line>spring.security.oauth2.client.registration.my-client-2.client-authentication-method=basic</span><br><span class=line>spring.security.oauth2.client.registration.my-client-2.authorization-grant-type=authorization_code</span><br><span class=line></span><br><span class=line>spring.security.oauth2.client.provider.my-oauth-provider.authorization-uri=http://my-auth-server/oauth/authorize</span><br><span class=line>spring.security.oauth2.client.provider.my-oauth-provider.token-uri=http://my-auth-server/oauth/token</span><br><span class=line>spring.security.oauth2.client.provider.my-oauth-provider.user-info-uri=http://my-auth-server/userinfo</span><br><span class=line>spring.security.oauth2.client.provider.my-oauth-provider.user-info-authentication-method=header</span><br><span class=line>spring.security.oauth2.client.provider.my-oauth-provider.jwk-set-uri=http://my-auth-server/token_keys</span><br><span class=line>spring.security.oauth2.client.provider.my-oauth-provider.user-name-attribute=name</span><br></pre></table></figure><p>对于支持<a href=https://openid.net/specs/openid-connect-discovery-1_0.html rel=noopener target=_blank>OpenID Connect 发现</a>的 OpenID Connect 提供程序，可以进一步简化配置。提供者需要配置一个<code>issuer-uri</code>，这是它声明为其发布者标识符的 URI。例如，如果提供的<code>issuer-uri</code>是“ <a href=https://example.com”,则将对“/ rel=noopener target=_blank>https://example.com”，则将对“</a> <a href=https://example.com/.well-known/openid-configuration%E2%80%9D%E8%AE%BE%E7%BD%AE%60OpenID rel=noopener target=_blank>https://example.com/.well-known/openid-configuration”设置`OpenID</a> Provider Configuration Request<code>。结果预期为</code>OpenID Provider Configuration Response<code>。以下示例显示了如何使用</code>issuer-uri`配置 OpenID Connect 提供程序：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.security.oauth2.client.provider.oidc-provider.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/</span><br></pre></table></figure><p>默认情况下，Spring Security 的<code>OAuth2LoginAuthenticationFilter</code>只处理与<code>/login/oauth2/code/*</code>匹配的 URL。如果要定制<code>redirect-uri</code>以使用其他模式，则需要提供配置以处理该定制模式。例如，对于 servlet 应用程序，您可以添加自己的<code>WebSecurityConfigurerAdapter</code>，其类似于以下内容：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">OAuth2LoginSecurityConfig</span> <span class=keyword>extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>protected</span> <span class=keyword>void</span> <span class="title function_">configure</span><span class=params>(HttpSecurity http)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		http</span><br><span class=line>			.authorizeRequests()</span><br><span class=line>				.anyRequest().authenticated()</span><br><span class=line>				.and()</span><br><span class=line>			.oauth2Login()</span><br><span class=line>				.redirectionEndpoint()</span><br><span class=line>					.baseUri(<span class=string>"/custom-callback"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h5 id=通用提供商的-OAuth2-Client-端注册><a title="通用提供商的 OAuth2 Client 端注册" class=headerlink href=#通用提供商的-OAuth2-Client-端注册></a>通用提供商的 OAuth2 Client 端注册</h5><p>对于常见的 OAuth2 和 OpenID 提供程序，包括 Google，Github，Facebook 和 Okta，我们提供了一组提供程序默认值(分别为<code>google</code>，<code>github</code>，<code>facebook</code>和<code>okta</code>)。<p>如果不需要自定义这些提供程序，则可以将<code>provider</code>属性设置为您需要为其推断默认值的属性。另外，如果用于 Client 端注册的密钥与默认支持的提供程序匹配，则 Spring Boot 也会进行推断。<p>换句话说，以下示例中的两种配置都使用 Google 提供程序：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>spring.security.oauth2.client.registration.my-client.client-id=abcd</span><br><span class=line>spring.security.oauth2.client.registration.my-client.client-secret=password</span><br><span class=line>spring.security.oauth2.client.registration.my-client.provider=google</span><br><span class=line></span><br><span class=line>spring.security.oauth2.client.registration.google.client-id=abcd</span><br><span class=line>spring.security.oauth2.client.registration.google.client-secret=password</span><br></pre></table></figure><h4 id=3-7-3-2、资源服务器><a class=headerlink href=#3-7-3-2、资源服务器 title=3.7.3.2、资源服务器></a>3.7.3.2、资源服务器</h4><p>如果您的 Classpath 上有<code>spring-security-oauth2-resource-server</code>，则只要指定了 JWK Set URI 或 OIDC Issuer URI，Spring Boot 就可以设置 OAuth2 资源服务器，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://example.com/oauth2/default/v1/keys</span><br><span class=line>spring.security.oauth2.resourceserver.jwt.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/</span><br></pre></table></figure><p>相同的属性适用于 servlet 和反应式应用程序。<p>另外，您可以为 Servlet 应用程序定义自己的<code>JwtDecoder</code> bean 或为 Reactive 应用程序定义<code>ReactiveJwtDecoder</code>。<h4 id=3-7-3-3、授权服务器><a class=headerlink href=#3-7-3-3、授权服务器 title=3.7.3.3、授权服务器></a>3.7.3.3、授权服务器</h4><p>当前，Spring Security 不提供对实现 OAuth 2.0 授权服务器的支持。但是，此功能可从<a href=https://projects.spring.io/spring-security-oauth/ rel=noopener target=_blank>Spring Security OAuth</a>项目获得，最终将被 Spring Security 完全取代。在此之前，您可以使用<code>spring-security-oauth2-autoconfigure</code>模块轻松设置 OAuth 2.0 授权服务器；有关说明，请参见其<a href=https://docs.spring.io/spring-security-oauth2-boot rel=noopener target=_blank>documentation</a>。<h3 id=3-7-4、Actuator安全性><a class=headerlink href=#3-7-4、Actuator安全性 title=3.7.4、Actuator安全性></a>3.7.4、Actuator安全性</h3><p>为了安全起见，默认禁用除<code>/health</code>和<code>/info</code>以外的所有 Actuator。 <code>management.endpoints.web.exposure.include</code>属性可用于启用 Actuator。<p>如果 Spring Security 位于 Classpath 上，并且不存在其他 WebSecurityConfigurerAdapter，则通过 Spring Boot 自动配置来保护<code>/health</code>和<code>/info</code>以外的所有 Actuator。如果您定义一个自定义<code>WebSecurityConfigurerAdapter</code>，Spring Boot 自动配置将退出，您将完全控制 Actuator 访问规则。<blockquote><p>在设置<code>management.endpoints.web.exposure.include</code>之前，请确保裸露的 Actuator 不包含敏感信息和/或通过将它们放置在防火墙后面或通过诸如 Spring Security 之类的东西进行保护。</blockquote><h4 id=3-7-4-1、跨站点请求伪造保护><a class=headerlink href=#3-7-4-1、跨站点请求伪造保护 title=3.7.4.1、跨站点请求伪造保护></a>3.7.4.1、跨站点请求伪造保护</h4><p>由于 Spring Boot 依赖于 Spring Security 的默认值，因此默认情况下 CSRF 保护是打开的。这意味着在使用默认安全性配置时，需要<code>POST</code>的 Actuator 端点(关机和 Logger 端点)，<code>PUT</code>或<code>DELETE</code>将收到 403 禁止错误。<blockquote><p>我们建议仅在创建非浏览器 Client 端使用的服务时完全禁用 CSRF 保护。</blockquote><h2 id=3-8、使用SQL数据库><a class=headerlink href=#3-8、使用SQL数据库 title=3.8、使用SQL数据库></a>3.8、使用SQL数据库</h2><p><a href=https://projects.spring.io/spring-framework/ rel=noopener target=_blank>Spring Framework</a>为使用 SQL 数据库提供了广泛的支持，从使用<code>JdbcTemplate</code>的直接 JDBC 访问到完整的“对象关系 Map”技术(例如 Hibernate)。 <a href=https://projects.spring.io/spring-data/ rel=noopener target=_blank>Spring Data</a>提供了更高级别的功能：直接从接口创建<code>Repository</code>实现，并使用约定从您的方法名称生成查询。<h3 id=3-8-1、配置数据源><a class=headerlink href=#3-8-1、配置数据源 title=3.8.1、配置数据源></a>3.8.1、配置数据源</h3><p>Java 的<code>javax.sql.DataSource</code>接口提供了使用数据库连接的标准方法。传统上，“数据源”使用<code>URL</code>以及一些凭据来构建数据库连接。<h4 id=3-8-1-1、嵌入式数据库支持><a class=headerlink href=#3-8-1-1、嵌入式数据库支持 title=3.8.1.1、嵌入式数据库支持></a>3.8.1.1、嵌入式数据库支持</h4><p>通过使用内存嵌入式数据库来开发应用程序通常很方便。显然，内存数据库不提供持久存储。您需要在应用程序启动时填充数据库，并准备在应用程序结束时丢弃数据。<p>Spring Boot 可以自动配置嵌入式<a href=http://www.h2database.com/ rel=noopener target=_blank>H2</a>，<a href=http://hsqldb.org/ rel=noopener target=_blank>HSQL</a>和<a href=https://db.apache.org/derby/ rel=noopener target=_blank>Derby</a>数据库。您无需提供任何连接 URL。您只需要包含要使用的嵌入式数据库的构建依赖项即可。<blockquote><p>如果在测试中使用此功能，则可能会注意到，整个测试套件将重用同一数据库，而不管您使用的应用程序上下文的数量如何。如果要确保每个上下文都有一个单独的嵌入式数据库，则应将<code>spring.datasource.generate-unique-name</code>设置为<code>true</code>。</blockquote><p>例如，典型的 POM 依赖关系如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>spring-boot-starter-data-jpa<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>org.hsqldb<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>hsqldb<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>scope</span>></span>runtime<span class=tag>&LT/<span class=name>scope</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><blockquote><p>您需要依赖<code>spring-jdbc</code>才能自动配置嵌入式数据库。在此示例中，它通过<code>spring-boot-starter-data-jpa</code>暂时拉入。<p>如果出于某种原因确实为嵌入式数据库配置了连接 URL，请确保确保禁用了数据库的自动关闭功能。如果使用 H2，则应使用<code>DB_CLOSE_ON_EXIT=FALSE</code>。如果使用 HSQLDB，则应确保不使用<code>shutdown=true</code>。通过禁用数据库的自动关闭功能，Spring Boot 可以控制何时关闭数据库，从而确保一旦不再需要访问数据库时就可以执行该操作。</blockquote><h4 id=3-8-1-2、连接到生产数据库><a class=headerlink href=#3-8-1-2、连接到生产数据库 title=3.8.1.2、连接到生产数据库></a>3.8.1.2、连接到生产数据库</h4><p>生产数据库连接也可以使用池<code>DataSource</code>进行自动配置。 Spring Boot 使用以下算法来选择特定的实现：<ul><li>我们更喜欢<a href=https://github.com/brettwooldridge/HikariCP rel=noopener target=_blank>HikariCP</a>的性能和并发性。如果 HikariCP 可用，我们总是选择它。<li>否则，如果 Tomcat 池<code>DataSource</code>可用，我们将使用它。<li>如果 HikariCP 和 Tomcat 池数据源都不可用，并且<a href=https://commons.apache.org/proper/commons-dbcp/ rel=noopener target=_blank>Commons DBCP2</a>可用，我们将使用它。</ul><p>如果使用<code>spring-boot-starter-jdbc</code>或<code>spring-boot-starter-data-jpa</code>“启动器”，则会自动获得<code>HikariCP</code>的依赖项。<blockquote><p>您可以完全绕过该算法，并通过设置<code>spring.datasource.type</code>属性来指定要使用的连接池。如果您在 Tomcat 容器中运行应用程序，这一点尤其重要，因为默认情况下提供<code>tomcat-jdbc</code>。<p>其他连接池始终可以手动配置。如果定义自己的<code>DataSource</code> bean，则不会进行自动配置。</blockquote><p>数据源配置由<code>spring.datasource.*</code>中的外部配置属性控制。例如，您可以在<code>application.properties</code>中声明以下部分：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.datasource.url</span>=<span class=string>jdbc:mysql://localhost/test</span></span><br><span class=line><span class=attr>spring.datasource.username</span>=<span class=string>dbuser</span></span><br><span class=line><span class=attr>spring.datasource.password</span>=<span class=string>dbpass</span></span><br><span class=line><span class=attr>spring.datasource.driver-class-name</span>=<span class=string>com.mysql.jdbc.Driver</span></span><br></pre></table></figure><blockquote><p>您至少应通过设置<code>spring.datasource.url</code>属性来指定 URL。否则，Spring Boot 会尝试自动配置嵌入式数据库。<p>您通常不需要指定<code>driver-class-name</code>，因为 Spring Boot 可以从<code>url</code>推导大多数数据库。<p>对于要创建的池<code>DataSource</code>，我们需要能够验证一个有效的<code>Driver</code>类是否可用，因此我们在进行任何操作之前都要进行检查。换句话说，如果设置<code>spring.datasource.driver-class-name=com.mysql.jdbc.Driver</code>，则该类必须是可加载的。</blockquote><p>有关更多受支持的选项，请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jdbc/DataSourceProperties.java rel=noopener target=_blank>DataSourceProperties</a>。这些是与实际实现无关的标准选项。也可以使用它们各自的前缀(<code>spring.datasource.hikari.*</code>，<code>spring.datasource.tomcat.*</code>和<code>spring.datasource.dbcp2.*</code>)微调实现特定的设置。有关更多详细信息，请参考所用连接池实现的文档。<p>例如，如果您使用<a href=https://tomcat.apache.org/tomcat-8.0-doc/jdbc-pool.html#Common_Attributes rel=noopener target=_blank>Tomcat 连接池</a>，则可以自定义许多其他设置，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_"># </span><span class=language-bash>Number of ms to <span class=built_in>wait</span> before throwing an exception <span class=keyword>if</span> no connection is available.</span></span><br><span class=line>spring.datasource.tomcat.max-wait=10000</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>Maximum number of active connections that can be allocated from this pool at the same time.</span></span><br><span class=line>spring.datasource.tomcat.max-active=50</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>Validate the connection before borrowing it from the pool.</span></span><br><span class=line>spring.datasource.tomcat.test-on-borrow=true</span><br></pre></table></figure><h4 id=3-8-1-3、><a class=headerlink href=#3-8-1-3、 title=3.8.1.3、></a>3.8.1.3、</h4><p>如果您将 Spring Boot 应用程序部署到 Application Server，则可能需要使用 Application Server 的内置功能来配置和 Management DataSource，并使用 JNDI 对其进行访问。<p><code>spring.datasource.jndi-name</code>属性可以替代<code>spring.datasource.url</code>，<code>spring.datasource.username</code>和<code>spring.datasource.password</code>属性，以从特定的 JNDI 位置访问<code>DataSource</code>。例如，<code>application.properties</code>中的以下部分显示了如何访问 JBoss AS 定义的<code>DataSource</code>：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.datasource.jndi-name</span>=<span class=string>java:jboss/datasources/customers</span></span><br></pre></table></figure><h3 id=3-8-2、使用JdbcTemplate><a class=headerlink href=#3-8-2、使用JdbcTemplate title=3.8.2、使用JdbcTemplate></a>3.8.2、使用JdbcTemplate</h3><p>Spring 的<code>JdbcTemplate</code>和<code>NamedParameterJdbcTemplate</code>类是自动配置的，您可以<code>@Autowire</code>直接将它们<code>@Autowire</code>放入自己的 bean 中，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> JdbcTemplate jdbcTemplate;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(JdbcTemplate jdbcTemplate)</span> {</span><br><span class=line>		<span class=built_in>this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>您可以使用<code>spring.jdbc.template.*</code>属性来自定义模板的某些属性，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.jdbc.template.max-rows=500</span><br></pre></table></figure><blockquote><p><code>NamedParameterJdbcTemplate</code>在后台重复使用相同的<code>JdbcTemplate</code>实例。如果定义了多个<code>JdbcTemplate</code>并且不存在主要候选对象，则不会自动配置<code>NamedParameterJdbcTemplate</code>。</blockquote><h3 id=3-8-3、JPA和Spring-Data-JPA><a title="3.8.3、JPA和Spring Data JPA" class=headerlink href=#3-8-3、JPA和Spring-Data-JPA></a>3.8.3、JPA和Spring Data JPA</h3><p>Java Persistence API 是一种标准技术，可让您将对象“Map”到关系数据库。 <code>spring-boot-starter-data-jpa</code> POM 提供了一种快速的 Starter 方法。它提供以下关键依赖性：<ul><li>Hibernate：最流行的 JPA 实现之一。<li>Spring Data JPA：使基于 JPA 的存储库的实现变得容易。<li>Spring ORM：Spring Framework 提供的核心 ORM 支持。</ul><h4 id=3-8-3-1、实体类><a class=headerlink href=#3-8-3-1、实体类 title=3.8.3.1、实体类></a>3.8.3.1、实体类</h4><p>传统上，JPA“实体”类是在<code>persistence.xml</code>文件中指定的。对于 Spring Boot，此文件不是必需的，而是使用“实体扫描”。默认情况下，将搜索主配置类(用<code>@EnableAutoConfiguration</code>或<code>@SpringBootApplication</code>Comments 的软件包)下的所有软件包。<p>任何带有<code>@Entity</code>，<code>@Embeddable</code>或<code>@MappedSuperclass</code>Comments 的类。典型的实体类类似于以下示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.example.myapp.domain;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.io.Serializable;</span><br><span class=line><span class=keyword>import</span> javax.persistence.*;</span><br><span class=line></span><br><span class=line><span class=meta>@Entity</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">City</span> <span class=keyword>implements</span> <span class="title class_">Serializable</span> {</span><br><span class=line>	<span class=meta>@Id</span></span><br><span class=line>	<span class=meta>@GeneratedValue</span></span><br><span class=line>	<span class=keyword>private</span> Long id;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Column(nullable = false)</span></span><br><span class=line>	<span class=keyword>private</span> String name;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Column(nullable = false)</span></span><br><span class=line>	<span class=keyword>private</span> String state;</span><br><span class=line></span><br><span class=line>	<span class=comment>// ... additional members, often include @OneToMany mappings</span></span><br><span class=line></span><br><span class=line>	<span class=keyword>protected</span> <span class="title function_">City</span><span class=params>()</span> {</span><br><span class=line>		<span class=comment>// no-args constructor required by JPA spec</span></span><br><span class=line>		<span class=comment>// this one is protected since it shouldn't be used directly</span></span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">City</span><span class=params>(String name, String state)</span> {</span><br><span class=line>		<span class=built_in>this</span>.name = name;</span><br><span class=line>		<span class=built_in>this</span>.state = state;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> String <span class="title function_">getName</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.name;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> String <span class="title function_">getState</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.state;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=comment>// ... etc</span></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>您可以使用<code>@EntityScan</code>Comments 来自定义实体扫描位置。</blockquote><h4 id=3-8-3-2、Spring-Data-JPA-存储库><a title="3.8.3.2、Spring Data JPA 存储库" class=headerlink href=#3-8-3-2、Spring-Data-JPA-存储库></a>3.8.3.2、Spring Data JPA 存储库</h4><p><a href=https://projects.spring.io/spring-data-jpa/ rel=noopener target=_blank>Spring Data JPA</a>存储库是您可以定义以访问数据的接口。 JPA 查询是根据您的方法名称自动创建的。例如，一个<code>CityRepository</code>接口可能声明<code>findAllByState(String state)</code>方法来查找给定 State 的所有城市。<p>对于更复杂的查询，您可以使用 Spring Data 的<a href=https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/Query.html rel=noopener target=_blank>Query</a>Comments 对方法进行 Comments。<p>Spring Data 存储库通常从<a href=https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/Repository.html rel=noopener target=_blank>Repository</a>或<a href=https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html rel=noopener target=_blank>CrudRepository</a>接口扩展。如果使用自动配置，则会从包含主配置类(用<code>@EnableAutoConfiguration</code>或<code>@SpringBootApplication</code>Comments 的主配置类)的包中搜索存储库。<p>以下示例显示了典型的 Spring Data 存储库接口定义：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.example.myapp.domain;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.data.domain.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.data.repository.*;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">CityRepository</span> <span class=keyword>extends</span> <span class="title class_">Repository</span>&LTCity, Long> {</span><br><span class=line>	Page&LTCity> <span class="title function_">findAll</span><span class=params>(Pageable pageable)</span>;</span><br><span class=line>	City <span class="title function_">findByNameAndStateAllIgnoringCase</span><span class=params>(String name, String state)</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>Spring Data JPA 存储库支持三种不同的引导模式：默认，延迟和延迟。要启用延迟引导或延迟引导，请将<code>spring.data.jpa.repositories.bootstrap-mode</code>分别设置为<code>deferred</code>或<code>lazy</code>。当使用延迟或延迟启动时，自动配置的<code>EntityManagerFactoryBuilder</code>将使用上下文的异步任务 Actuator(如果有)作为引导 Actuator。<h4 id=3-8-3-3、创建和删除JPA数据库><a class=headerlink href=#3-8-3-3、创建和删除JPA数据库 title=3.8.3.3、创建和删除JPA数据库></a>3.8.3.3、创建和删除JPA数据库</h4><p>默认情况下，如果您使用嵌入式数据库(H2，HSQL 或 Derby)，则仅“ **”自动创建 JPA 数据库。您可以使用<code>spring.jpa.*</code>属性来显式配置 JPA 设置。例如，要创建和删除表，可以将以下行添加到<code>application.properties</code>：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.jpa.hibernate.ddl-auto=create-drop</span><br></pre></table></figure><blockquote><p>Hibernate 自己的内部属性名称是<code>hibernate.hbm2ddl.auto</code>(如果您记得更好的话)。您可以使用<code>spring.jpa.properties.*</code>来设置它以及其他 Hibernate 本机属性(将前缀添加到实体 Management 器之前，前缀会被删除)。下面的行显示了为 Hibernate 设置 JPA 属性的示例：</blockquote><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.jpa.properties.hibernate.globally_quoted_identifiers</span>=<span class=string>true</span></span><br></pre></table></figure><p>前面示例中的行将<code>hibernate.globally_quoted_identifiers</code>属性的值<code>true</code>传递给 Hibernate 实体 Management 器。<p>默认情况下，DDL 执行(或验证)被推迟到<code>ApplicationContext</code>开始。还有一个<code>spring.jpa.generate-ddl</code>标志，但是如果 Hibernate 自动配置处于 Active 状态，则不使用它，因为<code>ddl-auto</code>设置更细粒度。<h4 id=3-8-3-4、在视图中打开EntityManager><a class=headerlink href=#3-8-3-4、在视图中打开EntityManager title=3.8.3.4、在视图中打开EntityManager></a>3.8.3.4、在视图中打开EntityManager</h4><p>如果您正在运行 Web 应用程序，则默认情况下，Spring Boot 注册<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/orm/jpa/support/OpenEntityManagerInViewInterceptor.html rel=noopener target=_blank>OpenEntityManagerInViewInterceptor</a>以应用“在视图中打开 EntityManager”模式，以允许在 Web 视图中进行延迟加载。如果您不希望出现这种情况，则应在<code>application.properties</code>中将<code>spring.jpa.open-in-view</code>设置为<code>false</code>。<h3 id=3-8-4、Spring-Data-JDBC><a title="3.8.4、Spring Data JDBC" class=headerlink href=#3-8-4、Spring-Data-JDBC></a>3.8.4、Spring Data JDBC</h3><p>Spring Data 包括对 JDBC 的存储库支持，并将自动为<code>CrudRepository</code>上的方法生成 SQL。对于更高级的查询，提供了<code>@Query</code>Comments。<p>当必要的依赖项位于 Classpath 上时，Spring Boot 将自动配置 Spring Data 的 JDBC 存储库。只需依赖<code>spring-boot-starter-data-jdbc</code>即可将它们添加到您的项目中。如有必要，您可以通过向应用程序中添加<code>@EnableJdbcRepositories</code>注解或<code>JdbcConfiguration</code>子类来控制 Spring Data JDBC 的配置。<h3 id=3-8-5、使用H2的Web控制台><a class=headerlink href=#3-8-5、使用H2的Web控制台 title=3.8.5、使用H2的Web控制台></a>3.8.5、使用H2的Web控制台</h3><p><a href=http://www.h2database.com/ rel=noopener target=_blank>H2 database</a>提供了<a href=http://www.h2database.com/html/quickstart.html#h2_console rel=noopener target=_blank>browser-based console</a>，Spring Boot 可以为您自动配置<a href=http://www.h2database.com/html/quickstart.html#jooq-in-7-steps-step3 rel=noopener target=_blank>browser-based console</a>。满足以下条件时，将自动配置控制台：<ul><li>您正在开发基于 servlet 的 Web 应用程序。<li><code>com.h2database:h2</code>在 Classpath 上。<li>您正在使用<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-devtools.html rel=noopener target=_blank>Spring Boot 的开发人员工具</a>。</ul><blockquote><p>如果您不使用 Spring Boot 的开发人员工具，但仍想使用 H2 的控制台，则可以将<code>spring.h2.console.enabled</code>属性配置为<code>true</code>。<p>H2 控制台仅在开发期间使用，因此您应确保在 Producing 不要将<code>spring.h2.console.enabled</code>设置为<code>true</code>。</blockquote><h4 id=3-8-5-1-更改-H2-控制台的路径><a title="3.8.5.1 更改 H2 控制台的路径" class=headerlink href=#3-8-5-1-更改-H2-控制台的路径></a>3.8.5.1 更改 H2 控制台的路径</h4><p>默认情况下，控制台位于<code>/h2-console</code>。您可以使用<code>spring.h2.console.path</code>属性来自定义控制台的路径。<h3 id=3-8-6、使用jOOQ><a class=headerlink href=#3-8-6、使用jOOQ title=3.8.6、使用jOOQ></a>3.8.6、使用jOOQ</h3><p>面向 Java 对象的查询(<a href=http://www.jooq.org/ rel=noopener target=_blank>jOOQ</a>)是<a href=http://www.datageekery.com/ rel=noopener target=_blank>Data Geekery</a>的流行产品，它可以从数据库中生成 Java 代码，并允许您通过其流畅的 API 构建类型安全的 SQL 查询。商业版和开源版都可以与 Spring Boot 一起使用。<h4 id=3-8-6-1、代码生成><a class=headerlink href=#3-8-6-1、代码生成 title=3.8.6.1、代码生成></a>3.8.6.1、代码生成</h4><p>为了使用 jOOQ 类型安全查询，您需要从数据库架构中生成 Java 类。您可以按照<a href=https://www.jooq.org/doc/3.11.7/manual-single-page/#+5+ rel=noopener target=_blank>jOOQ 用户手册</a>中的说明进行操作。如果您使用<code>jooq-codegen-maven</code>插件，并且还使用<code>spring-boot-starter-parent</code>“父 POM”，则可以安全地忽略该插件的<code>&LTversion></code>标签。您还可以使用 Spring Boot 定义的版本变量(例如<code>h2.version</code>)来声明插件的数据库依赖关系。以下 Lists 显示了一个示例：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>plugin</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>org.jooq<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>jooq-codegen-maven<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>executions</span>></span></span><br><span class=line>		...</span><br><span class=line>	<span class=tag>&LT/<span class=name>executions</span>></span></span><br><span class=line>	<span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>		<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>			<span class=tag><<span class=name>groupId</span>></span>com.h2database<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>artifactId</span>></span>h2<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>version</span>></span>${h2.version}<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>dependencies</span>></span></span><br><span class=line>	<span class=tag><<span class=name>configuration</span>></span></span><br><span class=line>		<span class=tag><<span class=name>jdbc</span>></span></span><br><span class=line>			<span class=tag><<span class=name>driver</span>></span>org.h2.Driver<span class=tag>&LT/<span class=name>driver</span>></span></span><br><span class=line>			<span class=tag><<span class=name>url</span>></span>jdbc:h2:~/yourdatabase<span class=tag>&LT/<span class=name>url</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>jdbc</span>></span></span><br><span class=line>		<span class=tag><<span class=name>generator</span>></span></span><br><span class=line>			...</span><br><span class=line>		<span class=tag>&LT/<span class=name>generator</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>configuration</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>plugin</span>></span></span><br></pre></table></figure><h4 id=3-8-6-2、使用DSLContext><a class=headerlink href=#3-8-6-2、使用DSLContext title=3.8.6.2、使用DSLContext></a>3.8.6.2、使用DSLContext</h4><p>jOOQ 提供的流畅的 API 是通过<code>org.jooq.DSLContext</code>接口启动的。 Spring Boot 将<code>DSLContext</code>自动配置为 Spring Bean，并将其连接到应用程序<code>DataSource</code>。要使用<code>DSLContext</code>，您可以<code>@Autowire</code>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">JooqExample</span> <span class=keyword>implements</span> <span class="title class_">CommandLineRunner</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> DSLContext create;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">JooqExample</span><span class=params>(DSLContext dslContext)</span> {</span><br><span class=line>		<span class=built_in>this</span>.create = dslContext;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>jOOQ 手册倾向于使用名为<code>create</code>的变量来保存<code>DSLContext</code>。</blockquote><p>然后，您可以使用<code>DSLContext</code>构造查询，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> List&LTGregorianCalendar> <span class="title function_">authorsBornAfter1980</span><span class=params>()</span> {</span><br><span class=line>	<span class=keyword>return</span> <span class=built_in>this</span>.create.selectFrom(AUTHOR)</span><br><span class=line>		.where(AUTHOR.DATE_OF_BIRTH.greaterThan(<span class=keyword>new</span> <span class="title class_">GregorianCalendar</span>(<span class=number>1980</span>, <span class=number>0</span>, <span class=number>1</span>)))</span><br><span class=line>		.fetch(AUTHOR.DATE_OF_BIRTH);</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-8-6-3、jOOQ-SQL-方言><a title="3.8.6.3、jOOQ SQL 方言" class=headerlink href=#3-8-6-3、jOOQ-SQL-方言></a>3.8.6.3、jOOQ SQL 方言</h4><p>除非已配置<code>spring.jooq.sql-dialect</code>属性，否则 Spring Boot 会确定要用于数据源的 SQL 方言。如果 Spring Boot 无法检测到方言，则使用<code>DEFAULT</code>。<blockquote><p>Spring Boot 只能自动配置开源版本的 jOOQ 支持的方言。</blockquote><h4 id=3-8-6-4、自定义jOOQ><a class=headerlink href=#3-8-6-4、自定义jOOQ title=3.8.6.4、自定义jOOQ></a>3.8.6.4、自定义jOOQ</h4><p>通过定义自己的<code>@Bean</code>定义(可以在创建 jOOQ <code>Configuration</code>时使用)可以实现更高级的自定义。您可以为以下 jOOQ 类型定义 bean：<ul><li><code>ConnectionProvider</code><li><code>ExecutorProvider</code><li><code>TransactionProvider</code><li><code>RecordMapperProvider</code><li><code>RecordUnmapperProvider</code><li><code>RecordListenerProvider</code><li><code>ExecuteListenerProvider</code><li><code>VisitListenerProvider</code><li><code>TransactionListenerProvider</code></ul><p>如果要完全控制 jOOQ 配置，也可以创建自己的<code>org.jooq.Configuration</code> <code>@Bean</code>。<h2 id=3-9、使用NoSQL技术><a class=headerlink href=#3-9、使用NoSQL技术 title=3.9、使用NoSQL技术></a>3.9、使用NoSQL技术</h2><p>Spring Data 提供了其他项目，可帮助您访问各种 NoSQL 技术，包括：<a href=https://projects.spring.io/spring-data-mongodb/ rel=noopener target=_blank>MongoDB</a>，<a href=https://projects.spring.io/spring-data-neo4j/ rel=noopener target=_blank>Neo4J</a>，<a href=https://github.com/spring-projects/spring-data-elasticsearch/ rel=noopener target=_blank>Elasticsearch</a>，<a href=https://projects.spring.io/spring-data-solr/ rel=noopener target=_blank>Solr</a>，<a href=https://projects.spring.io/spring-data-redis/ rel=noopener target=_blank>Redis</a>，<a href=https://projects.spring.io/spring-data-gemfire/ rel=noopener target=_blank>Gemfire</a>，<a href=https://projects.spring.io/spring-data-cassandra/ rel=noopener target=_blank>Cassandra</a>，<a href=https://projects.spring.io/spring-data-couchbase/ rel=noopener target=_blank>Couchbase</a>和<a href=https://projects.spring.io/spring-data-ldap/ rel=noopener target=_blank>LDAP</a>。 Spring Boot 为 Redis，MongoDB，Neo4j，Elasticsearch，Solr Cassandra，Couchbase 和 LDAP 提供自动配置。您可以使用其他项目，但是必须自己配置它们。请参考<a href=https://projects.spring.io/spring-data rel=noopener target=_blank>projects.spring.io/spring-data</a>的相应参考文档。<h3 id=3-9-1、Redis><a class=headerlink href=#3-9-1、Redis title=3.9.1、Redis></a>3.9.1、Redis</h3><p><a href=http://redis.io/ rel=noopener target=_blank>Redis</a>是缓存，消息代理和功能丰富的键值存储。 Spring Boot 为<a href=https://github.com/lettuce-io/lettuce-core/ rel=noopener target=_blank>Lettuce</a>和<a href=https://github.com/xetorthio/jedis/ rel=noopener target=_blank>Jedis</a>Client 端库提供了基本的自动配置，以及<a href=https://github.com/spring-projects/spring-data-redis rel=noopener target=_blank>Spring Data Redis</a>提供的对它们的抽象。<p>有一个<code>spring-boot-starter-data-redis</code>“启动程序”，以方便的方式收集依赖项。默认情况下，它使用<a href=https://github.com/lettuce-io/lettuce-core/ rel=noopener target=_blank>Lettuce</a>。该启动程序可以处理传统应用程序和响应式应用程序。<blockquote><p>我们还提供<code>spring-boot-starter-data-redis-reactive</code>“Starter”，以与其他具有 Reactive 支持的 Store 保持一致。</blockquote><h4 id=3-9-1-1、连接到Redis><a class=headerlink href=#3-9-1-1、连接到Redis title=3.9.1.1、连接到Redis></a>3.9.1.1、连接到Redis</h4><p>您可以像注入其他任何 Spring Bean 一样注入自动配置的<code>RedisConnectionFactory</code>，<code>StringRedisTemplate</code>或香草<code>RedisTemplate</code>实例。默认情况下，该实例尝试连接到<code>localhost:6379</code>的 Redis 服务器。下面的 Lists 显示了这种 Bean 的示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> StringRedisTemplate template;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(StringRedisTemplate template)</span> {</span><br><span class=line>		<span class=built_in>this</span>.template = template;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>您还可以注册任意数量的实现<code>LettuceClientConfigurationBuilderCustomizer</code>的 bean，以进行更高级的自定义。如果您使用 Jedis，则<code>JedisClientConfigurationBuilderCustomizer</code>也可用。</blockquote><p>如果添加自己的任何自动配置类型的<code>@Bean</code>，它将替换默认值(除非<code>RedisTemplate</code>，但排除基于 Bean 名称<code>redisTemplate</code>而不是其类型，则除外)。默认情况下，如果<code>commons-pool2</code>在 Classpath 上，则将得到一个池化连接工厂。<h3 id=3-9-2、MongoDB><a class=headerlink href=#3-9-2、MongoDB title=3.9.2、MongoDB></a>3.9.2、MongoDB</h3><p><a href=https://www.mongodb.com/ rel=noopener target=_blank>MongoDB</a>是一个开源 NoSQL 文档数据库，它使用类似 JSON 的架构而不是传统的基于表的关系数据。 Spring Boot 为使用 MongoDB 提供了许多便利，包括<code>spring-boot-starter-data-mongodb</code>和<code>spring-boot-starter-data-mongodb-reactive</code>“启动器”。<h4 id=3-9-2-1、连接到-MongoDB-数据库><a title="3.9.2.1、连接到 MongoDB 数据库" class=headerlink href=#3-9-2-1、连接到-MongoDB-数据库></a>3.9.2.1、连接到 MongoDB 数据库</h4><p>要访问 Mongo 数据库，您可以注入自动配置的<code>org.springframework.data.mongodb.MongoDbFactory</code>。默认情况下，该实例尝试连接到<code>mongodb://localhost/test</code>的 MongoDB 服务器。以下示例显示如何连接到 MongoDB 数据库：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.data.mongodb.MongoDbFactory;</span><br><span class=line><span class=keyword>import</span> com.mongodb.DB;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line></span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> MongoDbFactory mongo;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(MongoDbFactory mongo)</span> {</span><br><span class=line>		<span class=built_in>this</span>.mongo = mongo;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">example</span><span class=params>()</span> {</span><br><span class=line>		<span class=type>DB</span> <span class=variable>db</span> <span class=operator>=</span> mongo.getDb();</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>您可以设置<code>spring.data.mongodb.uri</code>属性来更改 URL 并配置其他设置，例如* replica set *，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.data.mongodb.uri</span>=<span class=string>mongodb://user:[emailprotected]:12345,mongo2.example.com:23456/test</span></span><br></pre></table></figure><p>另外，只要您使用 Mongo 2.x，就可以指定<code>host</code>/<code>port</code>。例如，您可以在<code>application.properties</code>中声明以下设置：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.data.mongodb.host</span>=<span class=string>mongoserver</span></span><br><span class=line><span class=attr>spring.data.mongodb.port</span>=<span class=string>27017</span></span><br></pre></table></figure><p>如果您定义了自己的<code>MongoClient</code>，它将用于自动配置合适的<code>MongoDbFactory</code>。 <code>com.mongodb.MongoClient</code>和<code>com.mongodb.client.MongoClient</code>均受支持。<blockquote><p>如果使用 Mongo 3.0 Java 驱动程序，则不支持<code>spring.data.mongodb.host</code>和<code>spring.data.mongodb.port</code>。在这种情况下，应使用<code>spring.data.mongodb.uri</code>提供所有配置。<p>如果未指定<code>spring.data.mongodb.port</code>，则使用默认值<code>27017</code>。您可以从前面显示的示例中删除此行。<p>如果您不使用 Spring Data Mongo，则可以注入<code>com.mongodb.MongoClient</code> bean 而不是<code>MongoDbFactory</code>。如果要完全控制构建 MongoDB 连接的方式，则还可以声明自己的<code>MongoDbFactory</code>或<code>MongoClient</code> bean。<p>如果使用 Reactive 驱动程序，则 SSL 需要 Netty。如果 Netty 可用并且尚未自定义要使用的工厂，则自动配置会自动配置该工厂。</blockquote><h4 id=3-9-2-2、MongoTemplate><a class=headerlink href=#3-9-2-2、MongoTemplate title=3.9.2.2、MongoTemplate></a>3.9.2.2、MongoTemplate</h4><p><a href=https://projects.spring.io/spring-data-mongodb/ rel=noopener target=_blank>Spring Data MongoDB</a>提供的<a href=https://docs.spring.io/spring-data/mongodb/docs/current/api/org/springframework/data/mongodb/core/MongoTemplate.html rel=noopener target=_blank>MongoTemplate</a>类的设计与 Spring 的<code>JdbcTemplate</code>非常相似。与<code>JdbcTemplate</code>一样，Spring Boot 为您自动配置一个 Bean 来注入模板，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.data.mongodb.core.MongoTemplate;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> MongoTemplate mongoTemplate;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(MongoTemplate mongoTemplate)</span> {</span><br><span class=line>		<span class=built_in>this</span>.mongoTemplate = mongoTemplate;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>有关完整的详细信息，请参见<a href=https://docs.spring.io/spring-data/mongodb/docs/current/api/org/springframework/data/mongodb/core/MongoOperations.html rel=noopener target=_blank>MongoOperations Javadoc</a>。<h4 id=3-9-2-3、Spring-Data-MongoDB-存储库><a title="3.9.2.3、Spring Data MongoDB 存储库" class=headerlink href=#3-9-2-3、Spring-Data-MongoDB-存储库></a>3.9.2.3、Spring Data MongoDB 存储库</h4><p>Spring Data 包括对 MongoDB 的存储库支持。与前面讨论的 JPA 存储库一样，基本原理是根据方法名称自动构造查询。<p>实际上，Spring Data JPA 和 Spring Data MongoDB 共享相同的通用基础架构。您可以从前面的 JPA 示例开始，并假设<code>City</code>现在是 Mongo 数据类而不是 JPA <code>@Entity</code>，它的工作方式相同，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.example.myapp.domain;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.data.domain.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.data.repository.*;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">CityRepository</span> <span class=keyword>extends</span> <span class="title class_">Repository</span>&LTCity, Long> {</span><br><span class=line>	Page&LTCity> <span class="title function_">findAll</span><span class=params>(Pageable pageable)</span>;</span><br><span class=line>	City <span class="title function_">findByNameAndStateAllIgnoringCase</span><span class=params>(String name, String state)</span>;</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>您可以使用<code>@EntityScan</code>Comments 来自定义文档扫描位置。</blockquote><h4 id=3-9-2-4、嵌入式Mongo><a class=headerlink href=#3-9-2-4、嵌入式Mongo title=3.9.2.4、嵌入式Mongo></a>3.9.2.4、嵌入式Mongo</h4><p>Spring Boot 为<a href=https://github.com/flapdoodle-oss/de.flapdoodle.embed.mongo rel=noopener target=_blank>Embedded Mongo</a>提供自动配置。要在您的 Spring Boot 应用程序中使用它，请在<code>de.flapdoodle.embed:de.flapdoodle.embed.mongo</code>上添加一个依赖项。<p>可以通过设置<code>spring.data.mongodb.port</code>属性来配置 Mongo 侦听的端口。要使用随机分配的空闲端口，请使用 0 值。由<code>MongoAutoConfiguration</code>创建的<code>MongoClient</code>自动配置为使用随机分配的端口。<blockquote><p>如果未配置自定义端口，则默认情况下，嵌入式支持使用随机端口(而不是 27017)。</blockquote><p>如果 Classpath 上有 SLF4J，则 Mongo 产生的输出将自动路由到名为<code>org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongo</code>的 Logger。<p>您可以声明自己的<code>IMongodConfig</code>和<code>IRuntimeConfig</code> bean 来控制 Mongo 实例的配置和日志记录路由。<h3 id=3-9-3、Neo4j><a class=headerlink href=#3-9-3、Neo4j title=3.9.3、Neo4j></a>3.9.3、Neo4j</h3><p><a href=http://neo4j.com/ rel=noopener target=_blank>Neo4j</a>是一个开源 NoSQL 图形数据库，它使用通过一级关系连接的节点的丰富数据模型，比传统的 RDBMS 方法更适合于连接的大数据。 Spring Boot 为 Neo4j 的使用提供了许多便利，包括<code>spring-boot-starter-data-neo4j</code>“ Starter”。<h4 id=3-9-3-1、连接到-Neo4j-数据库><a title="3.9.3.1、连接到 Neo4j 数据库" class=headerlink href=#3-9-3-1、连接到-Neo4j-数据库></a>3.9.3.1、连接到 Neo4j 数据库</h4><p>要访问 Neo4j 服务器，您可以注入自动配置的<code>org.neo4j.ogm.session.Session</code>。默认情况下，该实例尝试使用 Bolt 协议连接到<code>localhost:7687</code>处的 Neo4j 服务器。以下示例显示如何注入 Neo4j <code>Session</code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> Session session;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(Session session)</span> {</span><br><span class=line>		<span class=built_in>this</span>.session = session;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>您可以通过设置<code>spring.data.neo4j.*</code>属性来配置要使用的 uri 和凭据，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.data.neo4j.uri</span>=<span class=string>bolt://my-server:7687</span></span><br><span class=line><span class=attr>spring.data.neo4j.username</span>=<span class=string>neo4j</span></span><br><span class=line><span class=attr>spring.data.neo4j.password</span>=<span class=string>secret</span></span><br></pre></table></figure><p>您可以通过添加<code>org.neo4j.ogm.config.Configuration</code> <code>@Bean</code>来完全控制会话的创建。另外，添加类型为<code>SessionFactory</code>的<code>@Bean</code>会禁用自动配置，并提供完全控制权。<h4 id=3-9-3-2、使用嵌入式模式><a class=headerlink href=#3-9-3-2、使用嵌入式模式 title=3.9.3.2、使用嵌入式模式></a>3.9.3.2、使用嵌入式模式</h4><p>如果您将<code>org.neo4j:neo4j-ogm-embedded-driver</code>添加到应用程序的依赖项中，则 Spring Boot 将自动配置 Neo4j 的进程内嵌入式实例，该实例在应用程序关闭时不会保留任何数据。<blockquote><p>由于嵌入式 Neo4j OGM 驱动程序本身不提供 Neo4j 内核，因此您必须自己声明<code>org.neo4j:neo4j</code>作为依赖项。有关兼容版本的列表，请参考<a href=https://neo4j.com/docs/ogm-manual/current/reference/#reference:getting-started rel=noopener target=_blank>Neo4j OGM 文档</a>。</blockquote><p>当 Classpath 上有多个驱动程序时，嵌入式驱动程序优先于其他驱动程序。您可以通过设置<code>spring.data.neo4j.embedded.enabled=false</code>显式禁用嵌入式模式。<p>如上所述，如果嵌入式驱动程序和 Neo4j 内核位于 Classpath 中，则<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-neo4j-test rel=noopener target=_blank>数据 Neo4j 测试</a>自动使用嵌入式 Neo4j 实例。<blockquote><p>您可以通过在配置中提供数据库文件的路径来启用嵌入式模式的持久性。 <code>spring.data.neo4j.uri=file://var/tmp/graph.db</code>。</blockquote><h4 id=3-9-3-3、Neo4jSession><a class=headerlink href=#3-9-3-3、Neo4jSession title=3.9.3.3、Neo4jSession></a>3.9.3.3、Neo4jSession</h4><p>默认情况下，如果您正在运行 Web 应用程序，则会话将绑定到线程以进行请求的整个处理(即，它使用“在视图中打开会话”模式)。如果您不希望出现这种情况，请将以下行添加到您的<code>application.properties</code>文件中：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.data.neo4j.open-in-view</span>=<span class=string>false</span></span><br></pre></table></figure><h4 id=3-9-3-4、Spring-Data-Neo4j-存储库><a title="3.9.3.4、Spring Data Neo4j 存储库" class=headerlink href=#3-9-3-4、Spring-Data-Neo4j-存储库></a>3.9.3.4、Spring Data Neo4j 存储库</h4><p>Spring Data 包括对 Neo4j 的存储库支持。<p>Spring Data Neo4j 与许多其他 Spring Data 模块一样，与 Spring Data JPA 共享公共基础结构。您可以使用前面的 JPA 示例，并将<code>City</code>定义为 Neo4j OGM <code>@NodeEntity</code>而不是 JPA <code>@Entity</code>，并且存储库抽象以相同的方式工作，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.example.myapp.domain;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.util.Optional;</span><br><span class=line><span class=keyword>import</span> org.springframework.data.neo4j.repository.*;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">CityRepository</span> <span class=keyword>extends</span> <span class="title class_">Neo4jRepository</span>&LTCity, Long> {</span><br><span class=line>	Optional&LTCity> <span class="title function_">findOneByNameAndState</span><span class=params>(String name, String state)</span>;</span><br><span class=line>}</span><br></pre></table></figure><p><code>spring-boot-starter-data-neo4j</code>“启动器”启用存储库支持以及事务 Management。您可以通过分别在<code>@Configuration</code> -bean 上使用<code>@EnableNeo4jRepositories</code>和<code>@EntityScan</code>来定制位置以查找存储库和实体。<h3 id=3-9-4、Gemfire><a class=headerlink href=#3-9-4、Gemfire title=3.9.4、Gemfire></a>3.9.4、Gemfire</h3><p><a href=https://github.com/spring-projects/spring-data-gemfire rel=noopener target=_blank>Spring Data Gemfire</a>提供了方便使用 Spring 的便捷工具，用于访问<a href=https://pivotal.io/big-data/pivotal-gemfire#details rel=noopener target=_blank>Pivotal Gemfire</a>数据 Management 平台。有一个<code>spring-boot-starter-data-gemfire</code>“启动器”，用于以方便的方式收集依赖项。 Gemfire 当前没有自动配置支持，但是您可以使用<a href=https://github.com/spring-projects/spring-data-gemfire/blob/master/src/main/java/org/springframework/data/gemfire/repository/config/EnableGemfireRepositories.java rel=noopener target=_blank>单个 Comments：@EnableGemfireRepositories</a>启用 Spring Data Repositories。<h3 id=3-9-5、Solr><a class=headerlink href=#3-9-5、Solr title=3.9.5、Solr></a>3.9.5、Solr</h3><p><a href=https://lucene.apache.org/solr/ rel=noopener target=_blank>Apache Solr</a>是搜索引擎。 Spring Boot 为 Solr 5 Client 端库提供了基本的自动配置，并由<a href=https://github.com/spring-projects/spring-data-solr rel=noopener target=_blank>Spring Data Solr</a>提供了对它的抽象。有一个<code>spring-boot-starter-data-solr</code>“启动程序”，用于以方便的方式收集依赖项。<h4 id=3-9-5-1、连接到-Solr><a title="3.9.5.1、连接到 Solr" class=headerlink href=#3-9-5-1、连接到-Solr></a>3.9.5.1、连接到 Solr</h4><p>您可以像注入其他任何 Spring bean 一样注入自动配置的<code>SolrClient</code>实例。默认情况下，该实例尝试连接到<code>localhost:8983/solr</code>处的服务器。下面的示例显示如何注入 Solr bean：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> SolrClient solr;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(SolrClient solr)</span> {</span><br><span class=line>		<span class=built_in>this</span>.solr = solr;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>如果添加自己的<code>SolrClient</code>类型的<code>@Bean</code>，它将替换默认值。<h4 id=3-9-5-2、Spring-Data-Solr-存储库><a title="3.9.5.2、Spring Data Solr 存储库" class=headerlink href=#3-9-5-2、Spring-Data-Solr-存储库></a>3.9.5.2、Spring Data Solr 存储库</h4><p>Spring Data 包括对 Apache Solr 的存储库支持。与前面讨论的 JPA 存储库一样，基本原理是根据方法名称自动为\构造查询。<p>实际上，Spring Data JPA 和 Spring Data Solr 共享相同的通用基础结构。您可以从以前的 JPA 示例开始，并假设<code>City</code>现在是<code>@SolrDocument</code>类而不是 JPA <code>@Entity</code>，它的工作方式相同。<h3 id=3-9-6、Elasticsearch><a class=headerlink href=#3-9-6、Elasticsearch title=3.9.6、Elasticsearch></a>3.9.6、Elasticsearch</h3><p><a href=https://www.elastic.co/products/elasticsearch rel=noopener target=_blank>Elasticsearch</a>是开源，分布式，RESTful 搜索和分析引擎。 Spring Boot 为 Elasticsearch 提供了基本的自动配置。<p>Spring Boot 支持多个 HTTP Client 端：<ul><li>官方 Java“低级”和“高级” REST Client 端<li><a href=https://github.com/searchbox-io/Jest rel=noopener target=_blank>Jest</a></ul><p><a href=https://github.com/spring-projects/spring-data-elasticsearch rel=noopener target=_blank>Spring Data Elasticsearch</a>仍在使用传输 Client 端，您可以从<code>spring-boot-starter-data-elasticsearch</code>“ Starter”开始使用。<h4 id=3-9-6-1、通过-REST-Client-端连接到-Elasticsearch><a title="3.9.6.1、通过 REST Client 端连接到 Elasticsearch" class=headerlink href=#3-9-6-1、通过-REST-Client-端连接到-Elasticsearch></a>3.9.6.1、通过 REST Client 端连接到 Elasticsearch</h4><p>Elasticsearch 附带了<a href=https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html rel=noopener target=_blank>两个不同的 REST Client 端</a>，可用于查询集群：“低级”Client 端和“高级”Client 端。<p>如果您对 Classpath 具有<code>org.elasticsearch.client:elasticsearch-rest-client</code>依赖关系，Spring Boot 将自动配置并注册一个<code>RestClient</code> bean，默认情况下它针对<code>localhost:9200</code>。您可以进一步调整<code>RestClient</code>的配置方式，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.elasticsearch.rest.uris</span>=<span class=string>http://search.example.com:9200</span></span><br><span class=line><span class=attr>spring.elasticsearch.rest.username</span>=<span class=string>user</span></span><br><span class=line><span class=attr>spring.elasticsearch.rest.password</span>=<span class=string>secret</span></span><br></pre></table></figure><p>您还可以注册任意数量的实现<code>RestClientBuilderCustomizer</code>的 bean，以进行更高级的自定义。要完全控制注册，请定义一个<code>RestClient</code> bean。<p>如果您对 Classpath 具有<code>org.elasticsearch.client:elasticsearch-rest-high-level-client</code>依赖性，则 Spring Boot 将自动配置<code>RestHighLevelClient</code>，该_包装任何现有的<code>RestClient</code> bean，并重新使用其 HTTP 配置。<h4 id=3-9-6-2、使用-Jest-连接到-Elasticsearch><a title="3.9.6.2、使用 Jest 连接到 Elasticsearch" class=headerlink href=#3-9-6-2、使用-Jest-连接到-Elasticsearch></a>3.9.6.2、使用 Jest 连接到 Elasticsearch</h4><p>如果您在 Classpath 上有<code>Jest</code>，则可以注入自动配置的<code>JestClient</code>，默认情况下以<code>localhost:9200</code>为目标。您可以进一步调整 Client 端的配置方式，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.elasticsearch.jest.uris</span>=<span class=string>http://search.example.com:9200</span></span><br><span class=line><span class=attr>spring.elasticsearch.jest.read-timeout</span>=<span class=string>10000</span></span><br><span class=line><span class=attr>spring.elasticsearch.jest.username</span>=<span class=string>user</span></span><br><span class=line><span class=attr>spring.elasticsearch.jest.password</span>=<span class=string>secret</span></span><br></pre></table></figure><p>您还可以注册任意数量的实现<code>HttpClientConfigBuilderCustomizer</code>的 bean，以进行更高级的自定义。以下示例调整其他 HTTP 设置：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">HttpSettingsCustomizer</span> <span class=keyword>implements</span> <span class="title class_">HttpClientConfigBuilderCustomizer</span> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">customize</span><span class=params>(HttpClientConfig.Builder builder)</span> {</span><br><span class=line>	builder.maxTotalConnection(<span class=number>100</span>).defaultMaxTotalConnectionPerRoute(<span class=number>5</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>要完全控制注册，请定义一个<code>JestClient</code> bean。<h4 id=3-9-6-3、使用-Spring-数据连接到-Elasticsearch><a title="3.9.6.3、使用 Spring 数据连接到 Elasticsearch" class=headerlink href=#3-9-6-3、使用-Spring-数据连接到-Elasticsearch></a>3.9.6.3、使用 Spring 数据连接到 Elasticsearch</h4><p>要连接到 Elasticsearch，您必须提供一个或多个集群节点的地址。可以通过将<code>spring.data.elasticsearch.cluster-nodes</code>属性设置为逗号分隔的<code>host:port</code>列表来指定地址。有了此配置后，就可以像其他任何 Spring bean 一样注入<code>ElasticsearchTemplate</code>或<code>TransportClient</code>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>spring.data.elasticsearch.cluster-nodes=localhost:<span class=number>9300</span></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> ElasticsearchTemplate template;</span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(ElasticsearchTemplate template)</span> {</span><br><span class=line>		<span class=built_in>this</span>.template = template;</span><br><span class=line>	}</span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>如果添加自己的<code>ElasticsearchTemplate</code>或<code>TransportClient</code> <code>@Bean</code>，它将替换默认值。<h4 id=3-9-6-4、Spring-Data-Elasticsearch-存储库><a title="3.9.6.4、Spring Data Elasticsearch 存储库" class=headerlink href=#3-9-6-4、Spring-Data-Elasticsearch-存储库></a>3.9.6.4、Spring Data Elasticsearch 存储库</h4><p>Spring Data 包括对 Elasticsearch 的存储库支持。与前面讨论的 JPA 存储库一样，基本原理是根据方法名称自动为您构造查询。<p>实际上，Spring Data JPA 和 Spring Data Elasticsearch 共享相同的通用基础架构。您可以从前面的 JPA 示例开始，并假设<code>City</code>现在是 Elasticsearch <code>@Document</code>类而不是 JPA <code>@Entity</code>，它的工作方式相同。<h3 id=3-9-7、Cassandra><a class=headerlink href=#3-9-7、Cassandra title=3.9.7、Cassandra></a>3.9.7、Cassandra</h3><p><a href=https://cassandra.apache.org/ rel=noopener target=_blank>Cassandra</a>是一个开放源代码的分布式数据库 Management 系统，旨在处理许多商品服务器上的大量数据。 Spring Boot 为 Cassandra 提供自动配置，并由<a href=https://github.com/spring-projects/spring-data-cassandra rel=noopener target=_blank>Spring Data Cassandra</a>提供最高级的抽象。有一个<code>spring-boot-starter-data-cassandra</code>“启动程序”，用于以方便的方式收集依赖项。<h4 id=3-9-7-1、连接到-Cassandra><a title="3.9.7.1、连接到 Cassandra" class=headerlink href=#3-9-7-1、连接到-Cassandra></a>3.9.7.1、连接到 Cassandra</h4><p>您可以像使用其他任何 Spring Bean 一样注入自动配置的<code>CassandraTemplate</code>或 Cassandra <code>Session</code>实例。 <code>spring.data.cassandra.*</code>属性可用于自定义连接。通常，您提供<code>keyspace-name</code>和<code>contact-points</code>属性，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.data.cassandra.keyspace-name</span>=<span class=string>mykeyspace</span></span><br><span class=line><span class=attr>spring.data.cassandra.contact-points</span>=<span class=string>cassandrahost1,cassandrahost2</span></span><br></pre></table></figure><p>您还可以注册任意数量的实现<code>ClusterBuilderCustomizer</code>的 bean，以进行更高级的自定义。<p>以下代码 Lists 显示了如何注入 Cassandra bean：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> CassandraTemplate template;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(CassandraTemplate template)</span> {</span><br><span class=line>		<span class=built_in>this</span>.template = template;</span><br><span class=line>	}</span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>如果添加自己的<code>CassandraTemplate</code>类型的<code>@Bean</code>，它将替换默认值。<h4 id=3-9-7-2、Spring-Data-Cassandra-存储库><a title="3.9.7.2、Spring Data Cassandra 存储库" class=headerlink href=#3-9-7-2、Spring-Data-Cassandra-存储库></a>3.9.7.2、Spring Data Cassandra 存储库</h4><p>Spring Data 包括对 Cassandra 的基本存储库支持。当前，这比前面讨论的 JPA 存储库受到更多限制，并且需要使用<code>@Query</code>Comments finder 方法。<h3 id=3-9-8、Couchbase><a class=headerlink href=#3-9-8、Couchbase title=3.9.8、Couchbase></a>3.9.8、Couchbase</h3><p><a href=https://www.couchbase.com/ rel=noopener target=_blank>Couchbase</a>是开放源代码，分布式，多模型的 NoSQL 面向文档的数据库，已针对交互式应用程序进行了优化。 Spring Boot 为 Couchbase 提供自动配置，并由<a href=https://github.com/spring-projects/spring-data-couchbase rel=noopener target=_blank>Spring Data Couchbase</a>提供最高级的抽象。有<code>spring-boot-starter-data-couchbase</code>和<code>spring-boot-starter-data-couchbase-reactive</code>个“启动程序”，以方便的方式收集依赖项。<h4 id=3-9-8-1、连接到-Couchbase><a title="3.9.8.1、连接到 Couchbase" class=headerlink href=#3-9-8-1、连接到-Couchbase></a>3.9.8.1、连接到 Couchbase</h4><p>您可以通过添加 Couchbase SDK 和一些配置来获得<code>Bucket</code>和<code>Cluster</code>。 <code>spring.couchbase.*</code>属性可用于自定义连接。通常，您提供引导主机，存储桶名称和密码，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.couchbase.bootstrap-hosts</span>=<span class=string>my-host-1,192.168.1.123</span></span><br><span class=line><span class=attr>spring.couchbase.bucket.name</span>=<span class=string>my-bucket</span></span><br><span class=line><span class=attr>spring.couchbase.bucket.password</span>=<span class=string>secret</span></span><br></pre></table></figure><blockquote><p>您至少需要提供*引导主机，在这种情况下，存储区名称为<code>default</code>，密码为空字符串。另外，您可以定义自己的<code>org.springframework.data.couchbase.config.CouchbaseConfigurer</code> <code>@Bean</code>来控制整个配置。</blockquote><p>还可以自定义某些<code>CouchbaseEnvironment</code>设置。例如，以下配置更改了用于打开新的<code>Bucket</code>的超时并启用了 SSL 支持：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.couchbase.env.timeouts.connect</span>=<span class=string>3000</span></span><br><span class=line><span class=attr>spring.couchbase.env.ssl.key-store</span>=<span class=string>/location/of/keystore.jks</span></span><br><span class=line><span class=attr>spring.couchbase.env.ssl.key-store-password</span>=<span class=string>secret</span></span><br></pre></table></figure><p>查看<code>spring.couchbase.env.*</code>属性以获取更多详细信息。<h4 id=3-9-8-2、Spring-Data-Couchbase-存储库><a title="3.9.8.2、Spring Data Couchbase 存储库" class=headerlink href=#3-9-8-2、Spring-Data-Couchbase-存储库></a>3.9.8.2、Spring Data Couchbase 存储库</h4><p>Spring Data 包括对 Couchbase 的存储库支持。有关 Spring Data Couchbase 的完整详细信息，请参阅<a href=https://docs.spring.io/spring-data/couchbase/docs/current/reference/html/ rel=noopener target=_blank>reference documentation</a>。<p>您可以像使用任何其他 Spring Bean 一样注入自动配置的<code>CouchbaseTemplate</code>实例，前提是* default * <code>CouchbaseConfigurer</code>可用(如前所述，启用 Couchbase 支持时会发生这种情况)。<p>以下示例显示了如何注入 Couchbase bean：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> CouchbaseTemplate template;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(CouchbaseTemplate template)</span> {</span><br><span class=line>		<span class=built_in>this</span>.template = template;</span><br><span class=line>	}</span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>您可以在自己的配置中定义一些 Bean，以覆盖自动配置提供的那些：<ul><li>名称为<code>couchbaseTemplate</code>的<code>CouchbaseTemplate</code> <code>@Bean</code>。<li>名为<code>couchbaseIndexManager</code>的<code>IndexManager</code> <code>@Bean</code>。<li>名称为<code>couchbaseCustomConversions</code>的<code>CustomConversions</code> <code>@Bean</code>。</ul><p>为了避免在您自己的配置中对这些名称进行硬编码，您可以重复使用 Spring Data Couchbase 提供的<code>BeanNames</code>。例如，您可以自定义要使用的转换器，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SomeConfiguration</span> {</span><br><span class=line>	<span class=meta>@Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)</span></span><br><span class=line>	<span class=keyword>public</span> CustomConversions <span class="title function_">myCustomConversions</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">CustomConversions</span>(...);</span><br><span class=line>	}</span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>如果您想完全绕过 Spring Data Couchbase 的自动配置，请提供自己的<code>org.springframework.data.couchbase.config.AbstractCouchbaseDataConfiguration</code>实现。</blockquote><h3 id=3-9-9、LDAP><a class=headerlink href=#3-9-9、LDAP title=3.9.9、LDAP></a>3.9.9、LDAP</h3><p><a href=https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol rel=noopener target=_blank>LDAP</a>(轻型目录访问协议)是一种开放的，与供应商无关的行业标准应用程序协议，用于通过 IP 网络访问和维护分布式目录信息服务。 Spring Boot 为任何兼容的 LDAP 服务器提供自动配置，并从<a href=https://www.ldap.com/unboundid-ldap-sdk-for-java rel=noopener target=_blank>UnboundID</a>支持嵌入式内存 LDAP 服务器。<p><a href=https://github.com/spring-projects/spring-data-ldap rel=noopener target=_blank>Spring Data LDAP</a>提供 LDAP 抽象。有一个<code>spring-boot-starter-data-ldap</code>“启动程序”，以方便的方式收集依赖项。<h4 id=3-9-9-1、连接到-LDAP-服务器><a title="3.9.9.1、连接到 LDAP 服务器" class=headerlink href=#3-9-9-1、连接到-LDAP-服务器></a>3.9.9.1、连接到 LDAP 服务器</h4><p>要连接到 LDAP 服务器，请确保声明对<code>spring-boot-starter-data-ldap</code>“ Starter”或<code>spring-ldap-core</code>的依赖关系，然后在 application.properties 中声明服务器的 URL，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.ldap.urls</span>=<span class=string>ldap://myserver:1235</span></span><br><span class=line><span class=attr>spring.ldap.username</span>=<span class=string>admin</span></span><br><span class=line><span class=attr>spring.ldap.password</span>=<span class=string>secret</span></span><br></pre></table></figure><p>如果需要自定义连接设置，则可以使用<code>spring.ldap.base</code>和<code>spring.ldap.base-environment</code>属性。<p><code>LdapContextSource</code>是根据这些设置自动配置的。如果您需要对其进行自定义(例如使用<code>PooledContextSource</code>)，则仍可以注入自动配置的<code>LdapContextSource</code>。确保将自定义的<code>ContextSource</code>标记为<code>@Primary</code>，以便自动配置的<code>LdapTemplate</code>使用它。<h4 id=3-9-9-2、Spring-Data-LDAP-存储库><a title="3.9.9.2、Spring Data LDAP 存储库" class=headerlink href=#3-9-9-2、Spring-Data-LDAP-存储库></a>3.9.9.2、Spring Data LDAP 存储库</h4><p>Spring Data 包括对 LDAP 的存储库支持。有关 Spring Data LDAP 的完整详细信息，请参阅<a href=https://docs.spring.io/spring-data/ldap/docs/1.0.x/reference/html/ rel=noopener target=_blank>reference documentation</a>。<p>您还可以像使用其他任何 Spring Bean 一样注入自动配置的<code>LdapTemplate</code>实例，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> LdapTemplate template;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(LdapTemplate template)</span> {</span><br><span class=line>		<span class=built_in>this</span>.template = template;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-9-9-3、嵌入式内存-LDAP-服务器><a title="3.9.9.3、嵌入式内存 LDAP 服务器" class=headerlink href=#3-9-9-3、嵌入式内存-LDAP-服务器></a>3.9.9.3、嵌入式内存 LDAP 服务器</h4><p>出于测试目的，Spring Boot 支持从<a href=https://www.ldap.com/unboundid-ldap-sdk-for-java rel=noopener target=_blank>UnboundID</a>自动配置内存中的 LDAP 服务器。要配置服务器，请将依赖项添加到<code>com.unboundid:unboundid-ldapsdk</code>并声明<code>base-dn</code>属性，如下所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.ldap.embedded.base-dn</span>=<span class=string>dc=spring,dc=io</span></span><br></pre></table></figure><blockquote><p>可以定义多个 base-dn 值，但是，由于可分辨的名称通常包含逗号，因此必须使用正确的符号来定义它们。<p>在 yaml 文件中，您可以使用 yaml 列表符号：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>spring.ldap.embedded.base-dn:</span><br><span class=line>- dc=spring,dc=io</span><br><span class=line>- dc=pivotal,dc=io</span><br></pre></table></figure><p>在属性文件中，必须将索引包括在属性名称中：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.ldap.embedded.base-dn[0]</span>=<span class=string>dc=spring,dc=io</span></span><br><span class=line><span class=attr>spring.ldap.embedded.base-dn[1]</span>=<span class=string>dc=pivotal,dc=io</span></span><br></pre></table></figure></blockquote><p>默认情况下，服务器在随机端口上启动并触发常规 LDAP 支持。无需指定<code>spring.ldap.urls</code>属性。<p>如果您的 Classpath 上有一个<code>schema.ldif</code>文件，它将用于初始化服务器。如果要从其他资源加载初始化脚本，则也可以使用<code>spring.ldap.embedded.ldif</code>属性。<p>默认情况下，使用标准架构来验证<code>LDIF</code>个文件。您可以通过设置<code>spring.ldap.embedded.validation.enabled</code>属性完全关闭验证。如果您具有自定义属性，则可以使用<code>spring.ldap.embedded.validation.schema</code>定义您的自定义属性类型或对象类。<h3 id=3-9-10、InfluxDB><a class=headerlink href=#3-9-10、InfluxDB title=3.9.10、InfluxDB></a>3.9.10、InfluxDB</h3><p><a href=https://www.influxdata.com/ rel=noopener target=_blank>InfluxDB</a>是开放源代码的时间序列数据库，已优化用于在操作监视，应用程序度量，物联网传感器数据和实时分析等领域中快速，高可用性地存储和检索时间序列数据。<h4 id=3-9-10-1、连接到-InfluxDB><a title="3.9.10.1、连接到 InfluxDB" class=headerlink href=#3-9-10-1、连接到-InfluxDB></a>3.9.10.1、连接到 InfluxDB</h4><p>只要<code>influxdb-java</code>Client 端位于 Classpath 上并且设置了数据库的 URL，Spring Boot 就会自动配置<code>InfluxDB</code>实例，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.influx.url</span>=<span class=string>http://172.0.0.1:8086</span></span><br></pre></table></figure><p>如果与 InfluxDB 的连接需要用户和密码，则可以相应地设置<code>spring.influx.user</code>和<code>spring.influx.password</code>属性。<p>InfluxDB 依赖 OkHttp。如果需要在后台调整 http Client 端<code>InfluxDB</code>的使用，则可以注册<code>InfluxDbOkHttpClientBuilderProvider</code> bean。<h2 id=3-10、Caching><a class=headerlink href=#3-10、Caching title=3.10、Caching></a>3.10、Caching</h2><p>Spring 框架提供了对向应用程序透明添加缓存的支持。从本质上讲，抽象将缓存应用于方法，从而根据缓存中可用的信息减少执行次数。缓存逻辑是透明应用的，不会对调用者造成任何干扰。只要通过<code>@EnableCaching</code>Comments 启用了缓存支持，Spring Boot 就会自动配置缓存基础结构。<p>简而言之，将缓存添加到服务的操作就像将相关 Comments 添加到其方法一样容易，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.cache.annotation.Cacheable;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MathService</span> {</span><br><span class=line>	<span class=meta>@Cacheable("piDecimals")</span></span><br><span class=line>	<span class=keyword>public</span> <span class=type>int</span> <span class="title function_">computePiDecimal</span><span class=params>(<span class=type>int</span> i)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>本示例说明了在可能耗资巨大的操作上使用缓存的方法。在调用<code>computePiDecimal</code>之前，抽象将在<code>piDecimals</code>缓存中查找与<code>i</code>参数匹配的条目。如果找到条目，则高速缓存中的内容会立即返回给调用方，并且不会调用该方法。否则，将调用该方法，并在返回值之前更新缓存。<blockquote><p>您还可以透明地使用标准 JSR-107(JCache)注解(例如<code>@CacheResult</code>)。但是，我们强烈建议您不要混合使用 Spring Cache 和 JCache 注解。</blockquote><p>如果您不添加任何特定的缓存库，Spring Boot 会自动配置一个使用内存中并发 Map 的<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-simple rel=noopener target=_blank>simple provider</a>。需要缓存时(例如上例中的<code>piDecimals</code>)，此提供程序将为您创建它。实际上，不建议将简单提供程序用于生产用途，但是它对于 Starter 并确保您了解功能非常有用。确定要使用的缓存提供程序后，请确保阅读其文档，以了解如何配置应用程序使用的缓存。几乎所有提供程序都要求您显式配置在应用程序中使用的每个缓存。有些提供了一种自定义<code>spring.cache.cache-names</code>属性定义的默认缓存的方法。<h3 id=3-10-1、支持的缓存提供程序><a class=headerlink href=#3-10-1、支持的缓存提供程序 title=3.10.1、支持的缓存提供程序></a>3.10.1、支持的缓存提供程序</h3><p>缓存抽象不提供实际的存储，而是依赖于<code>org.springframework.cache.Cache</code>和<code>org.springframework.cache.CacheManager</code>接口实现的抽象。<p>如果尚未定义类型<code>CacheManager</code>或名为<code>cacheResolver</code>的<code>CacheResolver</code>(请参见<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/cache/annotation/CachingConfigurer.html rel=noopener target=_blank>CachingConfigurer</a>)，则 Spring Boot 尝试检测以下提供程序(按指示的 Sequences)：<ul><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-generic rel=noopener target=_blank>Generic</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-jcache rel=noopener target=_blank>JCache (JSR-107)</a>(EhCache 3，Hazelcast，Infinispan 等)<li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-ehcache2 rel=noopener target=_blank>EhCache 2.x</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-hazelcast rel=noopener target=_blank>Hazelcast</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-infinispan rel=noopener target=_blank>Infinispan</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-couchbase rel=noopener target=_blank>Couchbase</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-redis rel=noopener target=_blank>Redis</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-caffeine rel=noopener target=_blank>Caffeine</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-simple rel=noopener target=_blank>Simple</a></ul><blockquote><p>也可以通过设置<code>spring.cache.type</code>属性来“强制”特定的缓存提供程序。如果需要在某些环境(例如测试)中<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-none rel=noopener target=_blank>完全禁用缓存</a>，请使用此属性。<p>使用<code>spring-boot-starter-cache</code>“Starter”快速添加基本的缓存依赖项。启动器带来<code>spring-context-support</code>。如果手动添加依赖项，则必须包含<code>spring-context-support</code>才能使用 JCache，EhCache 2.x 或 Guava 支持。</blockquote><p>如果<code>CacheManager</code>是由 Spring Boot 自动配置的，则可以通过公开实现<code>CacheManagerCustomizer</code>接口的 bean，在完全初始化之前进一步调整其配置。下面的示例设置一个标志，指示应该将空值向下传递到基础 Map：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> CacheManagerCustomizer&LTConcurrentMapCacheManager> <span class="title function_">cacheManagerCustomizer</span><span class=params>()</span> {</span><br><span class=line>	<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">CacheManagerCustomizer</span>&LTConcurrentMapCacheManager>() {</span><br><span class=line>		<span class=meta>@Override</span></span><br><span class=line>		<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">customize</span><span class=params>(ConcurrentMapCacheManager cacheManager)</span> {</span><br><span class=line>			cacheManager.setAllowNullValues(<span class=literal>false</span>);</span><br><span class=line>		}</span><br><span class=line>	};</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>在前面的示例中，应使用自动配置的<code>ConcurrentMapCacheManager</code>。如果不是这种情况(您提供了自己的配置，或者自动配置了其他缓存提供程序)，则根本不会调用定制程序。您可以根据需要拥有任意数量的定制程序，也可以使用<code>@Order</code>或<code>Ordered</code>对其进行排序。</blockquote><h4 id=3-10-1-1、Generic><a class=headerlink href=#3-10-1-1、Generic title=3.10.1.1、Generic></a>3.10.1.1、Generic</h4><p>如果上下文至少定义了一个<code>org.springframework.cache.Cache</code> bean，则使用通用缓存。创建一个<code>CacheManager</code>包装该类型的所有 bean。<h4 id=3-10-1-2、JCache-JSR-107><a class=headerlink href=#3-10-1-2、JCache-JSR-107 title=3.10.1.2、JCache(JSR-107)></a>3.10.1.2、JCache(JSR-107)</h4><p><a href=https://jcp.org/en/jsr/detail?id=107 rel=noopener target=_blank>JCache</a>通过 Classpath 上存在<code>javax.cache.spi.CachingProvider</code>进行引导(即，Classpath 上存在符合 JSR-107 的缓存库)，并且<code>JCacheCacheManager</code>由<code>spring-boot-starter-cache</code>“启动程序”提供。提供了各种兼容的库，Spring Boot 为 Ehcache 3，Hazelcast 和 Infinispan 提供了依赖 Management。也可以添加任何其他兼容的库。<p>可能会出现多个提供者，在这种情况下，必须明确指定提供者。即使 JSR-107 标准没有强制采用标准化的方式来定义配置文件的位置，Spring Boot 也会尽其所能以设置具有实现细节的缓存，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_"># </span><span class=language-bash>Only necessary <span class=keyword>if</span> more than one provider is present</span></span><br><span class=line>spring.cache.jcache.provider=com.acme.MyCachingProvider</span><br><span class=line>spring.cache.jcache.config=classpath:acme.xml</span><br></pre></table></figure><blockquote><p>当缓存库同时提供本机实现和 JSR-107 支持时，Spring Boot 会首选 JSR-107 支持，因此，如果您切换到其他 JSR-107 实现，则可以使用相同的功能。<p>Spring Boot 具有<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-hazelcast.html rel=noopener target=_blank>对 Hazelcast 的常规支持</a>。如果有一个<code>HazelcastInstance</code>可用，则除非指定<code>spring.cache.jcache.config</code>属性，否则它也会自动为<code>CacheManager</code>重用。</blockquote><p>自定义基础<code>javax.cache.cacheManager</code>的方法有两种：<ul><li>可以在启动时通过设置<code>spring.cache.cache-names</code>属性来创建缓存。如果定义了自定义<code>javax.cache.configuration.Configuration</code> bean，则将其用于自定义它们。<li><code>org.springframework.boot.autoconfigure.cache.JCacheManagerCustomizer</code> bean 与<code>CacheManager</code>的引用一起调用以进行完全自定义。</ul><blockquote><p>如果定义了一个标准的<code>javax.cache.CacheManager</code> bean，它将自动包装在抽象期望的<code>org.springframework.cache.CacheManager</code>实现中。不再对其应用定制。</blockquote><h4 id=3-10-1-3、EhCache-2-x><a title="3.10.1.3、EhCache 2.x" class=headerlink href=#3-10-1-3、EhCache-2-x></a>3.10.1.3、EhCache 2.x</h4><p>如果可以在 Classpath 的根目录下找到名为<code>ehcache.xml</code>的文件，则使用<a href=http://www.ehcache.org/ rel=noopener target=_blank>EhCache</a>2.x。如果找到 EhCache 2.x，则使用<code>spring-boot-starter-cache</code>“启动程序”提供的<code>EhCacheCacheManager</code>来引导缓存 Management 器。也可以提供备用配置文件，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.cache.ehcache.config</span>=<span class=string>classpath:config/another-config.xml</span></span><br></pre></table></figure><h4 id=3-10-1-4、Hazelcast><a class=headerlink href=#3-10-1-4、Hazelcast title=3.10.1.4、Hazelcast></a>3.10.1.4、Hazelcast</h4><p>Spring Boot 具有<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-hazelcast.html rel=noopener target=_blank>对 Hazelcast 的常规支持</a>。如果已自动配置<code>HazelcastInstance</code>，则会自动将其包装在<code>CacheManager</code>中。<h4 id=3-10-1-5、Infinispan><a class=headerlink href=#3-10-1-5、Infinispan title=3.10.1.5、Infinispan></a>3.10.1.5、Infinispan</h4><p><a href=http://infinispan.org/ rel=noopener target=_blank>Infinispan</a>没有默认配置文件位置，因此必须明确指定。否则，将使用默认的引导程序。<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.cache.infinispan.config</span>=<span class=string>infinispan.xml</span></span><br></pre></table></figure><p>可以在启动时通过设置<code>spring.cache.cache-names</code>属性来创建缓存。如果定义了自定义<code>ConfigurationBuilder</code> bean，则用于自定义缓存。<blockquote><p>Spring Boot 对 Infinispan 的支持仅限于嵌入式模式，并且非常基础。如果您需要更多选择，则应该使用官方的 Infinispan Spring Boot 启动程序。</blockquote><h4 id=3-10-1-6、Couchbase><a class=headerlink href=#3-10-1-6、Couchbase title=3.10.1.6、Couchbase></a>3.10.1.6、Couchbase</h4><p>如果<a href=https://www.couchbase.com/ rel=noopener target=_blank>Couchbase</a> Java Client 端和<code>couchbase-spring-cache</code>实现可用且 Couchbase 为<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-nosql.html#boot-features-couchbase rel=noopener target=_blank>configured</a>，则将自动配置<code>CouchbaseCacheManager</code>。也可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建其他缓存。这些缓存在自动配置的<code>Bucket</code>上运行。您还可以*使用定制程序在另一个<code>Bucket</code>上创建其他缓存。假设您在“主” <code>Bucket</code>上需要两个缓存(<code>cache1</code>和<code>cache2</code>)，在(另一个)<code>Bucket</code>上需要一个缓存(<code>cache3</code>)的自定义时间为 2 秒。您可以通过配置创建前两个缓存，如下所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.cache.cache-names</span>=<span class=string>cache1,cache2</span></span><br></pre></table></figure><p>然后，您可以定义一个<code>@Configuration</code>类来配置额外的<code>Bucket</code>和<code>cache3</code>缓存，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CouchbaseCacheConfiguration</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> Cluster cluster;</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">CouchbaseCacheConfiguration</span><span class=params>(Cluster cluster)</span> {</span><br><span class=line>		<span class=built_in>this</span>.cluster = cluster;</span><br><span class=line>	}</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> Bucket <span class="title function_">anotherBucket</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.cluster.openBucket(<span class=string>"another"</span>, <span class=string>"secret"</span>);</span><br><span class=line>	}</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> CacheManagerCustomizer&LTCouchbaseCacheManager> <span class="title function_">cacheManagerCustomizer</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> c -> {</span><br><span class=line>			c.prepareCache(<span class=string>"cache3"</span>, CacheBuilder.newInstance(anotherBucket())</span><br><span class=line>					.withExpiration(<span class=number>2</span>));</span><br><span class=line>		};</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>此示例配置重复使用通过自动配置创建的<code>Cluster</code>。<h4 id=3-10-1-7、Redis><a class=headerlink href=#3-10-1-7、Redis title=3.10.1.7、Redis></a>3.10.1.7、Redis</h4><p>如果<a href=http://redis.io/ rel=noopener target=_blank>Redis</a>可用并已配置，则将自动配置<code>RedisCacheManager</code>。可以通过设置<code>spring.cache.cache-names</code>属性在启动时创建其他缓存，并且可以使用<code>spring.cache.redis.*</code>属性配置缓存默认值。例如，以下配置创建了“生存时间”为 10 分钟的<code>cache1</code>和<code>cache2</code>缓存：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.cache.cache-names</span>=<span class=string>cache1,cache2</span></span><br><span class=line><span class=attr>spring.cache.redis.time-to-live</span>=<span class=string>600000</span></span><br></pre></table></figure><blockquote><p>默认情况下，添加密钥前缀，以便如果两个单独的缓存使用相同的密钥，则 Redis 不会有重叠的密钥，并且不能返回无效值。如果您创建自己的<code>RedisCacheManager</code>，强烈建议您启用此设置。<p>您可以添加自己的<code>RedisCacheConfiguration</code> <code>@Bean</code>，从而完全控制配置。如果您要自定义序列化策略，这将很有用。</blockquote><h4 id=3-10-1-8、Caffeine><a class=headerlink href=#3-10-1-8、Caffeine title=3.10.1.8、Caffeine></a>3.10.1.8、Caffeine</h4><p><a href=https://github.com/ben-manes/caffeine rel=noopener target=_blank>Caffeine</a>是对 Guava 缓存的 Java 8 重写，取代了对 Guava 的支持。如果存在 Caffeine，则会自动配置<code>CaffeineCacheManager</code>(由<code>spring-boot-starter-cache</code>“Starter”提供)。缓存可以在启动时通过设置<code>spring.cache.cache-names</code>属性来创建，并且可以通过以下方式之一自定义(按指示的 Sequences)：<ul><li><code>spring.cache.caffeine.spec</code>定义的缓存规范<li>定义了一个<code>com.github.benmanes.caffeine.cache.CaffeineSpec</code> bean<li>定义了一个<code>com.github.benmanes.caffeine.cache.Caffeine</code> bean</ul><p>例如，以下配置创建<code>cache1</code>和<code>cache2</code>缓存，最大大小为 500，并且<em>生存时间</em>为 10 分钟<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.cache.cache-names</span>=<span class=string>cache1,cache2</span></span><br><span class=line><span class=attr>spring.cache.caffeine.spec</span>=<span class=string>maximumSize=500,expireAfterAccess=600s</span></span><br></pre></table></figure><p>如果定义了<code>com.github.benmanes.caffeine.cache.CacheLoader</code> bean，它将自动与<code>CaffeineCacheManager</code>关联。由于<code>CacheLoader</code>将与由缓存 Management 器 Management 的* all *缓存相关联，因此必须将其定义为<code>CacheLoader&LTObject, Object></code>。自动配置将忽略任何其他通用类型。<h4 id=3-10-1-9、Simple><a class=headerlink href=#3-10-1-9、Simple title=3.10.1.9、Simple></a>3.10.1.9、Simple</h4><p>如果找不到其他提供者，则配置使用<code>ConcurrentHashMap</code>作为缓存存储区的简单实现。如果您的应用程序中不存在任何缓存库，则这是默认设置。默认情况下，将根据需要创建缓存，但是您可以通过设置<code>cache-names</code>属性来限制可用缓存的列表。例如，如果只需要<code>cache1</code>和<code>cache2</code>缓存，则按如下所示设置<code>cache-names</code>属性：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.cache.cache-names</span>=<span class=string>cache1,cache2</span></span><br></pre></table></figure><p>如果这样做，并且您的应用程序使用了未列出的缓存，那么当需要该缓存时，它将在运行时失败，但不会在启动时失败。这类似于使用未声明的缓存时“实际”缓存提供程序的行为。<h4 id=3-10-1-10、None><a class=headerlink href=#3-10-1-10、None title=3.10.1.10、None></a>3.10.1.10、None</h4><p>当您的配置中包含<code>@EnableCaching</code>时，也需要合适的缓存配置。如果需要在某些环境中完全禁用缓存，请强制将缓存类型设置为<code>none</code>以使用无操作实现，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.cache.type</span>=<span class=string>none</span></span><br></pre></table></figure><h2 id=3-11、Messaging><a class=headerlink href=#3-11、Messaging title=3.11、Messaging></a>3.11、Messaging</h2><p>Spring 框架为与消息传递系统集成提供了广泛的支持，从简化使用<code>JmsTemplate</code>的 JMS API 的使用到完整的异步接收消息的基础结构。 Spring AMQP 为高级消息队列协议提供了类似的功能集。 Spring Boot 还为<code>RabbitTemplate</code>和 RabbitMQ 提供了自动配置选项。 Spring WebSocket 本身就包含对 STOMP 消息的支持，而 Spring Boot 通过启动程序和少量的自动配置对此提供了支持。 Spring Boot 还支持 Apache Kafka。<h3 id=3-11-1、JMS><a class=headerlink href=#3-11-1、JMS title=3.11.1、JMS></a>3.11.1、JMS</h3><p><code>javax.jms.ConnectionFactory</code>接口提供了创建<code>javax.jms.Connection</code>与 JMS 代理进行交互的标准方法。尽管 Spring 需要<code>ConnectionFactory</code>才能与 JMS 一起使用，但是您通常不需要自己直接使用它，而是可以依靠更高级别的消息抽象。 (有关详细信息，请参见 Spring Framework 参考文档的<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/integration.html#jms rel=noopener target=_blank>relevant section</a>。)Spring Boot 还自动配置必要的基础结构来发送和接收消息。<h4 id=3-11-1-1、ActiveMQ-支持><a title="3.11.1.1、ActiveMQ 支持" class=headerlink href=#3-11-1-1、ActiveMQ-支持></a>3.11.1.1、ActiveMQ 支持</h4><p>当<a href=http://activemq.apache.org/ rel=noopener target=_blank>ActiveMQ</a>在 Classpath 上可用时，Spring Boot 也可以配置<code>ConnectionFactory</code>。如果存在代理，则将自动启动和配置嵌入式代理(前提是未通过配置指定代理 URL)。<blockquote><p>如果使用<code>spring-boot-starter-activemq</code>，则将提供连接或嵌入 ActiveMQ 实例所需的依赖关系，以及与 JMS 集成的 Spring 基础结构。</blockquote><p>ActiveMQ 配置由<code>spring.activemq.*</code>中的外部配置属性控制。例如，您可以在<code>application.properties</code>中声明以下部分：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.activemq.broker-url</span>=<span class=string>tcp://192.168.1.210:9876</span></span><br><span class=line><span class=attr>spring.activemq.user</span>=<span class=string>admin</span></span><br><span class=line><span class=attr>spring.activemq.password</span>=<span class=string>secret</span></span><br></pre></table></figure><p>默认情况下，<code>CachingConnectionFactory</code>使用可以由<code>spring.jms.*</code>中的外部配置属性控制的明智设置来包装本机<code>ConnectionFactory</code>：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.jms.cache.session-cache-size</span>=<span class=string>5</span></span><br></pre></table></figure><p>如果您想使用本机池，则可以通过向<code>org.messaginghub:pooled-jms</code>添加依赖项并相应地配置<code>JmsPoolConnectionFactory</code>来实现，如下例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.activemq.pool.enabled</span>=<span class=string>true</span></span><br><span class=line><span class=attr>spring.activemq.pool.max-connections</span>=<span class=string>50</span></span><br></pre></table></figure><blockquote><p>有关更多受支持的选项，请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/activemq/ActiveMQProperties.java rel=noopener target=_blank>ActiveMQProperties</a>。您还可以注册任意数量的实现<code>ActiveMQConnectionFactoryCustomizer</code>的 bean，以进行更高级的自定义。</blockquote><p>默认情况下，ActiveMQ 将创建一个目的地(如果目的地尚不存在)，以便根据其提供的名称来解析目的地。<h4 id=3-11-1-2、Artemis-支持><a title="3.11.1.2、Artemis 支持" class=headerlink href=#3-11-1-2、Artemis-支持></a>3.11.1.2、Artemis 支持</h4><p>当 Spring Boot 检测到<a href=http://activemq.apache.org/artemis/ rel=noopener target=_blank>Artemis</a>在 Classpath 中可用时，它可以自动配置<code>ConnectionFactory</code>。如果存在代理，则将自动启动和配置嵌入式代理(除非已明确设置 mode 属性)。支持的模式为<code>embedded</code>(以明确要求使用嵌入式代理，并且如果代理在 Classpath 上不可用，则会发生错误)和<code>native</code>(使用<code>netty</code>传输协议连接到代理)。配置后者后，Spring Boot 将使用默认设置配置一个<code>ConnectionFactory</code>，该<code>ConnectionFactory</code>连接到在本地计算机上运行的代理。<blockquote><p>如果使用<code>spring-boot-starter-artemis</code>，则将提供连接到现有 Artemis 实例所需的依赖关系，以及与 JMS 集成的 Spring 基础结构。将<code>org.apache.activemq:artemis-jms-server</code>添加到您的应用程序可让您使用嵌入式模式。</blockquote><p>Artemis 配置由<code>spring.artemis.*</code>中的外部配置属性控制。例如，您可以在<code>application.properties</code>中声明以下部分：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.artemis.mode</span>=<span class=string>native</span></span><br><span class=line><span class=attr>spring.artemis.host</span>=<span class=string>192.168.1.210</span></span><br><span class=line><span class=attr>spring.artemis.port</span>=<span class=string>9876</span></span><br><span class=line><span class=attr>spring.artemis.user</span>=<span class=string>admin</span></span><br><span class=line><span class=attr>spring.artemis.password</span>=<span class=string>secret</span></span><br></pre></table></figure><p>嵌入代理时，可以选择是否要启用持久性并列出应使其可用的目的地。可以将它们指定为以逗号分隔的列表，以使用默认选项创建它们，也可以为高级队列和主题配置分别定义类型<code>org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration</code>或<code>org.apache.activemq.artemis.jms.server.config.TopicConfiguration</code>的 bean。<p>默认情况下，<code>CachingConnectionFactory</code>使用可以由<code>spring.jms.*</code>中的外部配置属性控制的明智设置来包装本机<code>ConnectionFactory</code>：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.jms.cache.session-cache-size</span>=<span class=string>5</span></span><br></pre></table></figure><p>如果您想使用本机池，则可以通过向<code>org.messaginghub:pooled-jms</code>添加依赖项并相应地配置<code>JmsPoolConnectionFactory</code>来实现，如下例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.artemis.pool.enabled</span>=<span class=string>true</span></span><br><span class=line><span class=attr>spring.artemis.pool.max-connections</span>=<span class=string>50</span></span><br></pre></table></figure><p>有关更多受支持的选项，请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jms/artemis/ArtemisProperties.java rel=noopener target=_blank>ArtemisProperties</a>。<p>不涉及 JNDI 查找，并且使用 Artemis 配置中的<code>name</code>属性或通过配置提供的名称来根据目的地名称解析目的地。<h4 id=3-11-1-3、使用-JNDI-ConnectionFactory><a title="3.11.1.3、使用 JNDI ConnectionFactory" class=headerlink href=#3-11-1-3、使用-JNDI-ConnectionFactory></a>3.11.1.3、使用 JNDI ConnectionFactory</h4><p>如果您正在应用程序服务器中运行应用程序，则 Spring Boot 会尝试使用 JNDI 查找 JMS <code>ConnectionFactory</code>。默认情况下，选中<code>java:/JmsXA</code>和<code>java:/XAConnectionFactory</code>位置。如果需要指定替代位置，则可以使用<code>spring.jms.jndi-name</code>属性，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.jms.jndi-name</span>=<span class=string>java:/MyConnectionFactory</span></span><br></pre></table></figure><h4 id=3-11-1-4、发送消息><a class=headerlink href=#3-11-1-4、发送消息 title=3.11.1.4、发送消息></a>3.11.1.4、发送消息</h4><p>Spring 的<code>JmsTemplate</code>是自动配置的，您可以将其直接自动连接到自己的 bean 中，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> JmsTemplate jmsTemplate;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(JmsTemplate jmsTemplate)</span> {</span><br><span class=line>		<span class=built_in>this</span>.jmsTemplate = jmsTemplate;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p><a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/jms/core/JmsMessagingTemplate.html rel=noopener target=_blank>JmsMessagingTemplate</a>可以类似的方式注入。如果定义了<code>DestinationResolver</code>或<code>MessageConverter</code> bean，则将其自动关联到自动配置的<code>JmsTemplate</code>。</blockquote><h4 id=3-11-1-5、接收消息><a class=headerlink href=#3-11-1-5、接收消息 title=3.11.1.5、接收消息></a>3.11.1.5、接收消息</h4><p>存在 JMS 基础结构时，可以使用<code>@JmsListener</code>Comments 任何 bean 以创建侦听器端点。如果未定义<code>JmsListenerContainerFactory</code>，则会自动配置一个默认值。如果定义了<code>DestinationResolver</code>或<code>MessageConverter</code> bean，它将自动关联到默认工厂。<p>默认情况下，默认工厂是事务性的。如果您在存在<code>JtaTransactionManager</code>的基础结构中运行，则默认情况下会将其与侦听器容器关联。如果不是，则启用<code>sessionTransacted</code>标志。在后一种情况下，可以通过在侦听器方法(或其委托)上添加<code>@Transactional</code>来将本地数据存储事务与传入消息的处理相关联。这样可以确保本地事务完成后，传入消息得到确认。这还包括发送已在同一 JMS 会话上执行的响应消息。<p>以下组件在<code>someQueue</code>目标上创建侦听器端点：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=meta>@JmsListener(destination = "someQueue")</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">processMessage</span><span class=params>(String content)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>如果您需要创建更多的<code>JmsListenerContainerFactory</code>实例，或者想覆盖默认实例，Spring Boot 提供了一个<code>DefaultJmsListenerContainerFactoryConfigurer</code>，您可以使用与自动配置的设置相同的设置来初始化<code>DefaultJmsListenerContainerFactory</code>。<p>例如，以下示例公开了另一个使用特定<code>MessageConverter</code>的工厂：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">JmsConfiguration</span> {</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> DefaultJmsListenerContainerFactory <span class="title function_">myFactory</span><span class=params>(</span></span><br><span class=line><span class=params>			DefaultJmsListenerContainerFactoryConfigurer configurer)</span> {</span><br><span class=line>		<span class=type>DefaultJmsListenerContainerFactory</span> <span class=variable>factory</span> <span class=operator>=</span></span><br><span class=line>				<span class=keyword>new</span> <span class="title class_">DefaultJmsListenerContainerFactory</span>();</span><br><span class=line>		configurer.configure(factory, connectionFactory());</span><br><span class=line>		factory.setMessageConverter(myMessageConverter());</span><br><span class=line>		<span class=keyword>return</span> factory;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>然后，您可以在任何带有<code>@JmsListener</code>Comments 的方法中使用工厂，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=meta>@JmsListener(destination = "someQueue", containerFactory="myFactory")</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">processMessage</span><span class=params>(String content)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-11-2、AMQP><a class=headerlink href=#3-11-2、AMQP title=3.11.2、AMQP></a>3.11.2、AMQP</h3><p>高级消息队列协议(AMQP)是面向消息中间件的与平台无关的有线级别协议。 Spring AMQP 项目将 Spring 的核心概念应用于基于 AMQP 的消息传递解决方案的开发。 Spring Boot 为通过 RabbitMQ 使用 AMQP 提供了许多便利，包括<code>spring-boot-starter-amqp</code>“ Starter”。<h4 id=3-11-2-1、RabbitMQ-支持><a title="3.11.2.1、RabbitMQ 支持" class=headerlink href=#3-11-2-1、RabbitMQ-支持></a>3.11.2.1、RabbitMQ 支持</h4><p><a href=https://www.rabbitmq.com/ rel=noopener target=_blank>RabbitMQ</a>是基于 AMQP 协议的轻型，可靠，可伸缩和便携式消息代理。 Spring 使用<code>RabbitMQ</code>通过 AMQP 协议进行通信。<p>RabbitMQ 配置由<code>spring.rabbitmq.*</code>中的外部配置属性控制。例如，您可以在<code>application.properties</code>中声明以下部分：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.rabbitmq.host</span>=<span class=string>localhost</span></span><br><span class=line><span class=attr>spring.rabbitmq.port</span>=<span class=string>5672</span></span><br><span class=line><span class=attr>spring.rabbitmq.username</span>=<span class=string>admin</span></span><br><span class=line><span class=attr>spring.rabbitmq.password</span>=<span class=string>secret</span></span><br></pre></table></figure><p>如果上下文中存在<code>ConnectionNameStrategy</code> bean，它将自动用于命名由自动配置的<code>ConnectionFactory</code>创建的连接。有关更多受支持的选项，请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java rel=noopener target=_blank>RabbitProperties</a>。<h4 id=3-11-2-2、发送信息><a class=headerlink href=#3-11-2-2、发送信息 title=3.11.2.2、发送信息></a>3.11.2.2、发送信息</h4><p>Spring 的<code>AmqpTemplate</code>和<code>AmqpAdmin</code>是自动配置的，您可以将它们直接自动连接到自己的 bean 中，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.amqp.core.AmqpAdmin;</span><br><span class=line><span class=keyword>import</span> org.springframework.amqp.core.AmqpTemplate;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> AmqpAdmin amqpAdmin;</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> AmqpTemplate amqpTemplate;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(AmqpAdmin amqpAdmin, AmqpTemplate amqpTemplate)</span> {</span><br><span class=line>		<span class=built_in>this</span>.amqpAdmin = amqpAdmin;</span><br><span class=line>		<span class=built_in>this</span>.amqpTemplate = amqpTemplate;</span><br><span class=line>	}</span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p><a href=https://docs.spring.io/spring-amqp/docs/current/api/org/springframework/amqp/rabbit/core/RabbitMessagingTemplate.html rel=noopener target=_blank>RabbitMessagingTemplate</a>可以类似的方式注入。如果定义了<code>MessageConverter</code> bean，它将自动关联到自动配置的<code>AmqpTemplate</code>。</blockquote><p>如有必要，任何定义为 bean 的<code>org.springframework.amqp.core.Queue</code>都会自动用于在 RabbitMQ 实例上声明相应的队列。<p>要重试操作，可以在<code>AmqpTemplate</code>上启用重试(例如，在代理连接丢失的情况下)：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.rabbitmq.template.retry.enabled</span>=<span class=string>true</span></span><br><span class=line><span class=attr>spring.rabbitmq.template.retry.initial-interval</span>=<span class=string>2s</span></span><br></pre></table></figure><p>默认情况下，重试是禁用的。您还可以pass 语句<code>RabbitRetryTemplateCustomizer</code> bean 来以编程方式自定义<code>RetryTemplate</code>。<h4 id=3-11-2-3、接收信息><a class=headerlink href=#3-11-2-3、接收信息 title=3.11.2.3、接收信息></a>3.11.2.3、接收信息</h4><p>存在 Rabbit 基础结构时，可以使用<code>@RabbitListener</code>Comments 任何 bean 以创建侦听器端点。如果未定义<code>RabbitListenerContainerFactory</code>，则会自动配置默认的<code>SimpleRabbitListenerContainerFactory</code>，并且可以使用<code>spring.rabbitmq.listener.type</code>属性切换到直接容器。如果定义了<code>MessageConverter</code>或<code>MessageRecoverer</code> bean，它将自动与默认工厂关联。<p>以下示例组件在<code>someQueue</code>队列上创建一个侦听器端点：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=meta>@RabbitListener(queues = "someQueue")</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">processMessage</span><span class=params>(String content)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>如果您需要创建更多的<code>RabbitListenerContainerFactory</code>实例，或者想覆盖默认实例，Spring Boot 提供了<code>SimpleRabbitListenerContainerFactoryConfigurer</code>和<code>DirectRabbitListenerContainerFactoryConfigurer</code>，您可以使用它们设置与自动配置使用的工厂相同的设置来初始化<code>SimpleRabbitListenerContainerFactory</code>和<code>DirectRabbitListenerContainerFactory</code>。<blockquote><p>选择哪种容器都没有关系。这两个 bean 通过自动配置公开。</blockquote><p>例如，以下配置类公开了另一个使用特定<code>MessageConverter</code>的工厂：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">RabbitConfiguration</span> {</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> SimpleRabbitListenerContainerFactory <span class="title function_">myFactory</span><span class=params>(</span></span><br><span class=line><span class=params>			SimpleRabbitListenerContainerFactoryConfigurer configurer)</span> {</span><br><span class=line>		<span class=type>SimpleRabbitListenerContainerFactory</span> <span class=variable>factory</span> <span class=operator>=</span></span><br><span class=line>				<span class=keyword>new</span> <span class="title class_">SimpleRabbitListenerContainerFactory</span>();</span><br><span class=line>		configurer.configure(factory, connectionFactory);</span><br><span class=line>		factory.setMessageConverter(myMessageConverter());</span><br><span class=line>		<span class=keyword>return</span> factory;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>然后，您可以使用任何带有<code>@RabbitListener</code>Comments 的方法来使用工厂，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=meta>@RabbitListener(queues = "someQueue", containerFactory="myFactory")</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">processMessage</span><span class=params>(String content)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>您可以启用重试来处理侦听器引发异常的情况。默认情况下，使用<code>RejectAndDontRequeueRecoverer</code>，但是您可以定义自己的<code>MessageRecoverer</code>。重试用尽后，如果将代理配置为这样做，则消息将被拒绝并被丢弃或路由到死信交换。默认情况下，重试是禁用的。您也可以pass 语句<code>RabbitRetryTemplateCustomizer</code> bean 来以编程方式自定义<code>RetryTemplate</code>。<blockquote><p>默认情况下，如果禁用了重试，并且侦听器引发了异常，则会无限期地重试传递。您可以通过两种方式修改此行为：将<code>defaultRequeueRejected</code>属性设置为<code>false</code>，以便尝试进行零次重新传递或抛出<code>AmqpRejectAndDontRequeueException</code>来指示应拒绝该消息。后者是启用重试并达到最大传递尝试次数时使用的机制。</blockquote><h3 id=3-11-3、Apache-Kafka-支持><a title="3.11.3、Apache Kafka 支持" class=headerlink href=#3-11-3、Apache-Kafka-支持></a>3.11.3、Apache Kafka 支持</h3><p>通过提供<code>spring-kafka</code>项目的自动配置来支持<a href=https://kafka.apache.org/ rel=noopener target=_blank>Apache Kafka</a>。<p>Kafka 配置由<code>spring.kafka.*</code>中的外部配置属性控制。例如，您可以在<code>application.properties</code>中声明以下部分：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.kafka.bootstrap-servers</span>=<span class=string>localhost:9092</span></span><br><span class=line><span class=attr>spring.kafka.consumer.group-id</span>=<span class=string>myGroup</span></span><br></pre></table></figure><blockquote><p>要在启动时创建主题，请添加<code>NewTopic</code>类型的 Bean。如果该主题已经存在，则将忽略 Bean。</blockquote><h4 id=3-11-3-1、发送消息><a class=headerlink href=#3-11-3-1、发送消息 title=3.11.3.1、发送消息></a>3.11.3.1、发送消息</h4><p>Spring 的<code>KafkaTemplate</code>是自动配置的，您可以直接在自己的 bean 中自动对其进行布线，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> KafkaTemplate kafkaTemplate;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyBean</span><span class=params>(KafkaTemplate kafkaTemplate)</span> {</span><br><span class=line>		<span class=built_in>this</span>.kafkaTemplate = kafkaTemplate;</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-11-3-2、接收消息><a class=headerlink href=#3-11-3-2、接收消息 title=3.11.3.2、接收消息></a>3.11.3.2、接收消息</h4><p>存在 Apache Kafka 基础结构时，可以使用<code>@KafkaListener</code>Comments 任何 bean 以创建侦听器端点。如果未定义<code>KafkaListenerContainerFactory</code>，则会使用<code>spring.kafka.listener.*</code>中定义的键自动配置一个默认值。<p>以下组件在<code>someTopic</code>主题上创建侦听器终结点：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=meta>@KafkaListener(topics = "someTopic")</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">processMessage</span><span class=params>(String content)</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>如果定义了<code>KafkaTransactionManager</code> bean，它将自动与容器工厂关联。同样，如果定义了<code>RecordMessageConverter</code>，<code>ErrorHandler</code>或<code>AfterRollbackProcessor</code> bean，它将自动与默认工厂关联。<blockquote><p>自定义<code>ChainedKafkaTransactionManager</code>必须标记为<code>@Primary</code>，因为它通常引用自动配置的<code>KafkaTransactionManager</code> bean。</blockquote><h4 id=3-11-3-3、Kafka流><a class=headerlink href=#3-11-3-3、Kafka流 title=3.11.3.3、Kafka流></a>3.11.3.3、Kafka流</h4><p>用于 Apache Kafka 的 Spring 提供了一个工厂 bean 来创建<code>StreamsBuilder</code>对象并 Management 其流的生命周期。只要<code>kafka-streams</code>在 Classpath 上并且通过<code>@EnableKafkaStreams</code>Comments 启用 Kafka Streams，Spring Boot 就会自动配置所需的<code>KafkaStreamsConfiguration</code> bean。<p>启用 Kafka Streams 意味着必须设置应用程序 ID 和引导服务器。可以使用<code>spring.kafka.streams.application-id</code>配置前者，如果未设置，则默认为<code>spring.application.name</code>。后者可以全局设置，也可以仅针对流进行覆盖。<p>使用专用属性可以使用几个附加属性。可以使用<code>spring.kafka.streams.properties</code>名称空间设置其他任意 Kafka 属性。另请参见<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-messaging.html#boot-features-kafka-extra-props rel=noopener target=_blank>第 33.3.4 节“其他 Kafka 属性”</a>。<p>要使用工厂 bean，只需将<code>StreamsBuilder</code>连接到您的<code>@Bean</code>中，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableKafkaStreams</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">KafkaStreamsExampleConfiguration</span> {</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> KStream&LTInteger, String> <span class="title function_">kStream</span><span class=params>(StreamsBuilder streamsBuilder)</span> {</span><br><span class=line>		KStream&LTInteger, String> stream = streamsBuilder.stream(<span class=string>"ks1In"</span>);</span><br><span class=line>		stream.map((k, v) -> <span class=keyword>new</span> <span class="title class_">KeyValue</span><>(k, v.toUpperCase())).to(<span class=string>"ks1Out"</span>,</span><br><span class=line>				Produced.with(Serdes.Integer(), <span class=keyword>new</span> <span class="title class_">JsonSerde</span><>()));</span><br><span class=line>		<span class=keyword>return</span> stream;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>默认情况下，由它创建的<code>StreamBuilder</code>对象 Management 的流将自动启动。您可以使用<code>spring.kafka.streams.auto-startup</code>属性来自定义此行为。<h4 id=3-11-3-4、Kafka-的其他属性><a title="3.11.3.4、Kafka 的其他属性" class=headerlink href=#3-11-3-4、Kafka-的其他属性></a>3.11.3.4、Kafka 的其他属性</h4><p>自动配置支持的属性显示在<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/common-application-properties.html rel=noopener target=_blank>附录 A，通用应用程序属性</a>中。请注意，在大多数情况下，这些属性(连字符或 camelCase)直接 Map 到 Apache Kafka 点缀属性。有关详细信息，请参阅 Apache Kafka 文档。<p>这些属性的前几个属性适用于所有组件(生产者，使用者，Management 员和流)，但如果您希望使用不同的值，则可以在组件级别上指定。 Apache Kafka 会指定重要性为 HIGH，MEDIUM 或 LOW 的属性。 Spring Boot 自动配置支持所有 HIGH 重要性属性，一些选定的 MEDIUM 和 LOW 属性以及任何没有默认值的属性。<p>Kafka 支持的属性的子集仅可通过<code>KafkaProperties</code>类直接使用。如果希望使用不直接支持的其他属性来配置生产者或使用者，请使用以下属性：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.kafka.properties.prop.one</span>=<span class=string>first</span></span><br><span class=line><span class=attr>spring.kafka.admin.properties.prop.two</span>=<span class=string>second</span></span><br><span class=line><span class=attr>spring.kafka.consumer.properties.prop.three</span>=<span class=string>third</span></span><br><span class=line><span class=attr>spring.kafka.producer.properties.prop.four</span>=<span class=string>fourth</span></span><br><span class=line><span class=attr>spring.kafka.streams.properties.prop.five</span>=<span class=string>fifth</span></span><br></pre></table></figure><p>这将公共<code>prop.one</code> Kafka 属性设置为<code>first</code>(适用于生产者，Consumer 和 Management 员)，将<code>prop.two</code> admin 属性设置为<code>second</code>，将<code>prop.three</code>Consumer 属性设置为<code>third</code>，将<code>prop.four</code>生产者属性设置为<code>fourth</code>，并将<code>prop.five</code> streams 属性设置为<code>fifth</code>。<p>您还可以如下配置 Spring Kafka <code>JsonDeserializer</code>：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.kafka.consumer.value-deserializer</span>=<span class=string>org.springframework.kafka.support.serializer.JsonDeserializer</span></span><br><span class=line><span class=attr>spring.kafka.consumer.properties.spring.json.value.default.type</span>=<span class=string>com.example.Invoice</span></span><br><span class=line><span class=attr>spring.kafka.consumer.properties.spring.json.trusted.packages</span>=<span class=string>com.example,org.acme</span></span><br></pre></table></figure><p>同样，您可以禁用在 Headers 中发送类型信息的<code>JsonSerializer</code>默认行为：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.kafka.producer.value-serializer</span>=<span class=string>org.springframework.kafka.support.serializer.JsonSerializer</span></span><br><span class=line><span class=attr>spring.kafka.producer.properties.spring.json.add.type.headers</span>=<span class=string>false</span></span><br></pre></table></figure><h2 id=3-12、使用-RestTemplate-调用-REST-服务><a title="3.12、使用 RestTemplate 调用 REST 服务" class=headerlink href=#3-12、使用-RestTemplate-调用-REST-服务></a>3.12、使用 RestTemplate 调用 REST 服务</h2><p>如果您需要从应用程序中调用远程 REST 服务，则可以使用 Spring Framework 的<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/javadoc-api/org/springframework/web/client/RestTemplate.html rel=noopener target=_blank>RestTemplate</a>类。由于<code>RestTemplate</code>实例在使用前通常需要自定义，因此 Spring Boot 不提供任何单个自动配置的<code>RestTemplate</code> bean。但是，它会自动配置<code>RestTemplateBuilder</code>，可以在需要时创建<code>RestTemplate</code>实例。自动配置的<code>RestTemplateBuilder</code>确保将明智的<code>HttpMessageConverters</code>应用于<code>RestTemplate</code>实例。<p>以下代码显示了一个典型示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyService</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> RestTemplate restTemplate;</span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyService</span><span class=params>(RestTemplateBuilder restTemplateBuilder)</span> {</span><br><span class=line>		<span class=built_in>this</span>.restTemplate = restTemplateBuilder.build();</span><br><span class=line>	}</span><br><span class=line>	<span class=keyword>public</span> Details <span class="title function_">someRestCall</span><span class=params>(String name)</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.restTemplate.getForObject(<span class=string>"/{name}/details"</span>, Details.class, name);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p><code>RestTemplateBuilder</code>包含许多可用于快速配置<code>RestTemplate</code>的有用方法。例如，要添加 BASIC 身份验证支持，可以使用<code>builder.basicAuthentication("user", "password").build()</code>。</blockquote><h3 id=3-12-1、RestTemplate-自定义><a title="3.12.1、RestTemplate 自定义" class=headerlink href=#3-12-1、RestTemplate-自定义></a>3.12.1、RestTemplate 自定义</h3><p><code>RestTemplate</code>自定义有三种 Main 方法，具体取决于您希望自定义应用的范围。<p>要使所有自定义项的范围尽可能缩小，请注入自动配置的<code>RestTemplateBuilder</code>，然后根据需要调用其方法。每个方法调用都返回一个新的<code>RestTemplateBuilder</code>实例，因此自定义仅影响构建器的使用。<p>要进行应用程序范围的附加自定义，请使用<code>RestTemplateCustomizer</code> bean。所有此类 bean 都会自动注册到自动配置的<code>RestTemplateBuilder</code>中，并应用于使用它构建的任何模板。<p>以下示例显示了一个定制程序，该定制程序为除<code>192.168.0.5</code>之外的所有主机配置代理的使用：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">ProxyCustomizer</span> <span class=keyword>implements</span> <span class="title class_">RestTemplateCustomizer</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">customize</span><span class=params>(RestTemplate restTemplate)</span> {</span><br><span class=line>		<span class=type>HttpHost</span> <span class=variable>proxy</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">HttpHost</span>(<span class=string>"proxy.example.com"</span>);</span><br><span class=line>		<span class=type>HttpClient</span> <span class=variable>httpClient</span> <span class=operator>=</span> HttpClientBuilder.create()</span><br><span class=line>				.setRoutePlanner(<span class=keyword>new</span> <span class="title class_">DefaultProxyRoutePlanner</span>(proxy) {</span><br><span class=line></span><br><span class=line>					<span class=meta>@Override</span></span><br><span class=line>					<span class=keyword>public</span> HttpHost <span class="title function_">determineProxy</span><span class=params>(HttpHost target,</span></span><br><span class=line><span class=params>							HttpRequest request, HttpContext context)</span></span><br><span class=line>							<span class=keyword>throws</span> HttpException {</span><br><span class=line>						<span class=keyword>if</span> (target.getHostName().equals(<span class=string>"192.168.0.5"</span>)) {</span><br><span class=line>							<span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>						}</span><br><span class=line>						<span class=keyword>return</span> <span class=built_in>super</span>.determineProxy(target, request, context);</span><br><span class=line>					}</span><br><span class=line></span><br><span class=line>				}).build();</span><br><span class=line>		restTemplate.setRequestFactory(</span><br><span class=line>				<span class=keyword>new</span> <span class="title class_">HttpComponentsClientHttpRequestFactory</span>(httpClient));</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>最后，最极端(也是很少使用)的选项是创建自己的<code>RestTemplateBuilder</code> bean。这样做会关闭<code>RestTemplateBuilder</code>的自动配置，并防止使用任何<code>RestTemplateCustomizer</code> bean。<h2 id=3-13、使用-WebClient-调用-REST-服务><a title="3.13、使用 WebClient 调用 REST 服务" class=headerlink href=#3-13、使用-WebClient-调用-REST-服务></a>3.13、使用 WebClient 调用 REST 服务</h2><p>如果您的 Classpath 中包含 Spring WebFlux，则还可以选择使用<code>WebClient</code>来调用远程 REST 服务。与<code>RestTemplate</code>相比，此 Client 端具有更多的功能感，并且具有完全的 Reactive。您可以在专用的<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web-reactive.html#webflux-client rel=noopener target=_blank>Spring Framework 文档中的部分</a>中了解有关<code>WebClient</code>的更多信息。<p>Spring Boot 为您创建并预配置了<code>WebClient.Builder</code>；强烈建议将其注入您的组件中并使用它来创建<code>WebClient</code>实例。 Spring Boot 正在配置该构建器以共享 HTTP 资源，以与服务器相同的方式反映编解码器的设置(请参阅<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-web-applications.html#boot-features-webflux-httpcodecs rel=noopener target=_blank>WebFlux HTTP 编解码器自动配置</a>)，以及更多。<p>以下代码显示了一个典型示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyService</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> WebClient webClient;</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyService</span><span class=params>(WebClient.Builder webClientBuilder)</span> {</span><br><span class=line>		<span class=built_in>this</span>.webClient = webClientBuilder.baseUrl(<span class=string>"http://example.org"</span>).build();</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> Mono&LTDetails> <span class="title function_">someRestCall</span><span class=params>(String name)</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=built_in>this</span>.webClient.get().uri(<span class=string>"/{name}/details"</span>, name)</span><br><span class=line>						.retrieve().bodyToMono(Details.class);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-13-1、WebClient-运行时><a title="3.13.1、WebClient 运行时" class=headerlink href=#3-13-1、WebClient-运行时></a>3.13.1、WebClient 运行时</h3><p>Spring Boot 将根据应用程序 Classpath 上可用的库自动检测要使用哪个<code>ClientHttpConnector</code>来驱动<code>WebClient</code>。目前，还支持 Reactor Netty 和 Jetty RS Client 端。<p>默认情况下，<code>spring-boot-starter-webflux</code>启动程序取决于<code>io.projectreactor.netty:reactor-netty</code>，这同时带来了服务器和 Client 端实现。如果选择使用 Jetty 作为反应式服务器，则应在 Jetty 反应式 HTTP Client 端库<code>org.eclipse.jetty:jetty-reactive-httpclient</code>上添加依赖项。对服务器和 Client 端使用相同的技术具有其优势，因为它将自动在 Client 端和服务器之间共享 HTTP 资源。<p>通过提供自定义的<code>ReactorResourceFactory</code>或<code>JettyResourceFactory</code> bean，开发人员可以覆盖 Jetty 和 Reactor Netty 的资源配置-这将同时应用于 Client 端和服务器。<p>如果您希望为 Client 端覆盖该选择，则可以定义自己的<code>ClientHttpConnector</code> bean 并完全控制 Client 端配置。<h3 id=3-13-2、WebClient-自定义><a title="3.13.2、WebClient 自定义" class=headerlink href=#3-13-2、WebClient-自定义></a>3.13.2、WebClient 自定义</h3><p><code>WebClient</code>自定义有三种 Main 方法，具体取决于您希望自定义应用的范围。<p>要使所有自定义项的范围尽可能缩小，请注入自动配置的<code>WebClient.Builder</code>，然后根据需要调用其方法。 <code>WebClient.Builder</code>实例是有状态的：构建器上的任何更改都会反映在随后使用它创建的所有 Client 端中。如果要使用同一构建器创建多个 Client 端，则也可以考虑使用<code>WebClient.Builder other = builder.clone();</code>克隆该构建器。<p>要对所有<code>WebClient.Builder</code>实例进行应用程序级的附加自定义，您可以声明<code>WebClientCustomizer</code> bean 并在注入点更改<code>WebClient.Builder</code>。<p>最后，您可以使用原始 API 并使用<code>WebClient.create()</code>。在这种情况下，不会应用任何自动配置或<code>WebClientCustomizer</code>。<h2 id=3-14、Validation><a class=headerlink href=#3-14、Validation title=3.14、Validation></a>3.14、Validation</h2><p>只要 JSR-303 实现(例如 Hibernate 验证器)位于 Classpath 上，就会自动启用 Bean 验证 1.1 支持的方法验证功能。这样就可以在 Bean 方法的参数和/或返回值上使用<code>javax.validation</code>约束 Comments。具有此类 Comments 方法的目标类需要在类型级别使用<code>@Validated</code>Comments 进行 Comments，以便在其方法中搜索内联约束 Comments。<p>例如，以下服务触发第一个参数的验证，确保其大小在 8 到 10 之间：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=meta>@Validated</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyBean</span> {</span><br><span class=line>	<span class=keyword>public</span> Archive <span class="title function_">findByCodeAndAuthor</span><span class=params>(<span class=meta>@Size(min = 8, max = 10)</span> String code,</span></span><br><span class=line><span class=params>			Author author)</span> {</span><br><span class=line>		...</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h2 id=3-15、发送电子邮件><a class=headerlink href=#3-15、发送电子邮件 title=3.15、发送电子邮件></a>3.15、发送电子邮件</h2><p>Spring 框架提供了一种使用<code>JavaMailSender</code>接口发送电子邮件的简单抽象方法，而 Spring Boot 为它提供了自动配置以及启动程序模块。<p>如果<code>spring.mail.host</code>和相关库(由<code>spring-boot-starter-mail</code>定义)可用，则如果不存在默认库<code>JavaMailSender</code>，则将创建该库。可以通过<code>spring.mail</code>名称空间中的配置项进一步自定义发送方。有关更多详细信息，请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/mail/MailProperties.java rel=noopener target=_blank>MailProperties</a>。<p>特别是，某些默认超时值是无限的，您可能需要更改该值，以避免线程被无响应的邮件服务器阻塞，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.mail.properties.mail.smtp.connectiontimeout</span>=<span class=string>5000</span></span><br><span class=line><span class=attr>spring.mail.properties.mail.smtp.timeout</span>=<span class=string>3000</span></span><br><span class=line><span class=attr>spring.mail.properties.mail.smtp.writetimeout</span>=<span class=string>5000</span></span><br></pre></table></figure><p>也可以使用 JNDI 中的现有<code>Session</code>配置<code>JavaMailSender</code>：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.mail.jndi-name</span>=<span class=string>mail/Session</span></span><br></pre></table></figure><p>设置<code>jndi-name</code>时，它优先于所有其他与会话相关的其他设置。<h2 id=3-16、-JTA-的分布式事务><a title="3.16、 JTA 的分布式事务" class=headerlink href=#3-16、-JTA-的分布式事务></a>3.16、 JTA 的分布式事务</h2><p>Spring Boot 通过使用<a href=http://www.atomikos.com/ rel=noopener target=_blank>Atomikos</a>或<a href=https://github.com/bitronix/btm rel=noopener target=_blank>Bitronix</a>嵌入式事务 Management 器，支持跨多个 XA 资源的分布式 JTA 事务。部署到合适的 Java EE 应用程序服务器时，还支持 JTA 事务。<p>当检测到 JTA 环境时，使用 Spring 的<code>JtaTransactionManager</code>来 Management 事务。自动配置的 JMS，DataSource 和 JPA Bean 已升级为支持 XA 事务。您可以使用标准的 Spring 习惯用法(例如<code>@Transactional</code>)来参与分布式事务。如果您在 JTA 环境中，并且仍要使用本地事务，则可以将<code>spring.jta.enabled</code>属性设置为<code>false</code>以禁用 JTA 自动配置。<h3 id=3-16-1、使用-Atomikos-Transaction-manager><a title="3.16.1、使用 Atomikos Transaction manager" class=headerlink href=#3-16-1、使用-Atomikos-Transaction-manager></a>3.16.1、使用 Atomikos Transaction manager</h3><p><a href=https://www.atomikos.com/ rel=noopener target=_blank>Atomikos</a>是流行的开源事务 Management 器，可以嵌入到您的 Spring Boot 应用程序中。您可以使用<code>spring-boot-starter-jta-atomikos</code> Starter 引入适当的 Atomikos 库。 Spring Boot 自动配置 Atomikos 并确保将适当的<code>depends-on</code>设置应用于您的 Spring Bean，以正确启动和关闭 Sequences。<p>默认情况下，Atomikos 事务日志将写入应用程序主目录(应用程序 jar 文件所在的目录)中的<code>transaction-logs</code>目录。您可以通过在<code>application.properties</code>文件中设置<code>spring.jta.log-dir</code>属性来自定义此目录的位置。以<code>spring.jta.atomikos.properties</code>开头的属性也可以用于自定义 Atomikos <code>UserTransactionServiceImp</code>。有关完整的详细信息，请参见<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/jta/atomikos/AtomikosProperties.html rel=noopener target=_blank>AtomikosProperties Javadoc</a>。<blockquote><p>为了确保多个事务 Management 器可以安全地协调同一资源 Management 器，必须为每个 Atomikos 实例配置一个唯一的 ID。默认情况下，此 ID 是运行 Atomikos 的计算机的 IP 地址。为了确保 Producing 的唯一性，应为应用程序的每个实例将<code>spring.jta.transaction-manager-id</code>属性配置为不同的值。</blockquote><h3 id=3-16-2、使用-Bitronix-Transaction-manager><a title="3.16.2、使用 Bitronix Transaction manager" class=headerlink href=#3-16-2、使用-Bitronix-Transaction-manager></a>3.16.2、使用 Bitronix Transaction manager</h3><p><a href=https://github.com/bitronix/btm rel=noopener target=_blank>Bitronix</a>是流行的开源 JTA 事务 Management 器实现。您可以使用<code>spring-boot-starter-jta-bitronix</code>Starter 程序将适当的 Bitronix 依赖项添加到您的项目中。与 Atomikos 一样，Spring Boot 自动配置 Bitronix 并对您的 bean 进行后处理，以确保启动和关闭 Sequences 正确。<p>默认情况下，Bitronix 事务日志文件(<code>part1.btm</code>和<code>part2.btm</code>)被写入应用程序主目录中的<code>transaction-logs</code>目录。您可以通过设置<code>spring.jta.log-dir</code>属性来自定义此目录的位置。以<code>spring.jta.bitronix.properties</code>开头的属性也绑定到<code>bitronix.tm.Configuration</code> bean，从而可以进行完全自定义。有关详情，请参见<a href=https://github.com/bitronix/btm/wiki/Transaction-manager-configuration rel=noopener target=_blank>Bitronix documentation</a>。<blockquote><p>为了确保多个事务 Management 器可以安全地协调同一资源 Management 器，必须为每个 Bitronix 实例配置唯一的 ID。默认情况下，此 ID 是运行 Bitronix 的计算机的 IP 地址。为了确保 Producing 的唯一性，应为应用程序的每个实例将<code>spring.jta.transaction-manager-id</code>属性配置为不同的值。</blockquote><h3 id=3-16-3、使用-Java-EE-托管事务-Management-器><a title="3.16.3、使用 Java EE 托管事务 Management 器" class=headerlink href=#3-16-3、使用-Java-EE-托管事务-Management-器></a>3.16.3、使用 Java EE 托管事务 Management 器</h3><p>如果将 Spring Boot 应用程序打包为<code>war</code>或<code>ear</code>文件并将其部署到 Java EE 应用程序服务器，则可以使用应用程序服务器的内置事务 Management 器。 Spring Boot 尝试通过查看常见的 JNDI 位置(<code>java:comp/UserTransaction</code>，<code>java:comp/TransactionManager</code>等)来自动配置事务 Management 器。如果使用应用程序服务器提供的事务服务，通常还需要确保所有资源都由服务器 Management 并通过 JNDI 公开。 Spring Boot 通过在 JNDI 路径(<code>java:/JmsXA</code>或<code>java:/XAConnectionFactory</code>)中查找<code>ConnectionFactory</code>来尝试自动配置 JMS，您可以使用<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-sql.html#boot-features-connecting-to-a-jndi-datasource rel=noopener target=_blank>spring.datasource.jndi-name property</a>来配置<code>DataSource</code>。<h3 id=3-16-4、混合-XA-和非-XA-JMS-连接><a title="3.16.4、混合 XA 和非 XA JMS 连接" class=headerlink href=#3-16-4、混合-XA-和非-XA-JMS-连接></a>3.16.4、混合 XA 和非 XA JMS 连接</h3><p>使用 JTA 时，主要的 JMS <code>ConnectionFactory</code> bean 支持 XA，并参与分布式事务。在某些情况下，您可能希望通过使用非 XA <code>ConnectionFactory</code>处理某些 JMS 消息。例如，您的 JMS 处理逻辑可能需要比 XA 超时更长的时间。<p>如果要使用非 XA <code>ConnectionFactory</code>，则可以注入<code>nonXaJmsConnectionFactory</code> bean 而不是<code>@Primary</code> <code>jmsConnectionFactory</code> bean。为了保持一致性，还使用 Bean 别名<code>xaJmsConnectionFactory</code>提供了<code>jmsConnectionFactory</code> bean。<p>以下示例显示了如何注入<code>ConnectionFactory</code>个实例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=comment>// Inject the primary (XA aware) ConnectionFactory</span></span><br><span class=line><span class=meta>@Autowired</span></span><br><span class=line><span class=keyword>private</span> ConnectionFactory defaultConnectionFactory;</span><br><span class=line></span><br><span class=line><span class=comment>// Inject the XA aware ConnectionFactory (uses the alias and injects the same as above)</span></span><br><span class=line><span class=meta>@Autowired</span></span><br><span class=line><span class=meta>@Qualifier("xaJmsConnectionFactory")</span></span><br><span class=line><span class=keyword>private</span> ConnectionFactory xaConnectionFactory;</span><br><span class=line></span><br><span class=line><span class=comment>// Inject the non-XA aware ConnectionFactory</span></span><br><span class=line><span class=meta>@Autowired</span></span><br><span class=line><span class=meta>@Qualifier("nonXaJmsConnectionFactory")</span></span><br><span class=line><span class=keyword>private</span> ConnectionFactory nonXaConnectionFactory;</span><br></pre></table></figure><h3 id=3-16-5、支持备用嵌入式事务-Management-器><a title="3.16.5、支持备用嵌入式事务 Management 器" class=headerlink href=#3-16-5、支持备用嵌入式事务-Management-器></a>3.16.5、支持备用嵌入式事务 Management 器</h3><p><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jms/XAConnectionFactoryWrapper.java rel=noopener target=_blank>XAConnectionFactoryWrapper</a>和<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jdbc/XADataSourceWrapper.java rel=noopener target=_blank>XADataSourceWrapper</a>接口可用于支持其他嵌入式事务 Management 器。这些接口负责包装<code>XAConnectionFactory</code>和<code>XADataSource</code> bean 并将它们作为常规<code>ConnectionFactory</code>和<code>DataSource</code> bean 公开，它们透明地注册了分布式事务。数据源和 JMS 自动配置使用 JTA 变体，前提是您拥有<code>JtaTransactionManager</code> bean 和在<code>ApplicationContext</code>中注册了适当的 XA 包装 bean。<p><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/bitronix/BitronixXAConnectionFactoryWrapper.java rel=noopener target=_blank>BitronixXAConnectionFactoryWrapper</a>和<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/jta/bitronix/BitronixXADataSourceWrapper.java rel=noopener target=_blank>BitronixXADataSourceWrapper</a>提供了有关如何编写 XA 包装程序的良好示例。<h2 id=3-17、Hazelcast><a class=headerlink href=#3-17、Hazelcast title=3.17、Hazelcast></a>3.17、Hazelcast</h2><p>如果<a href=https://hazelcast.com/ rel=noopener target=_blank>Hazelcast</a>位于 Classpath 上，并且找到了合适的配置，则 Spring Boot 会自动配置一个<code>HazelcastInstance</code>，您可以将其插入到应用程序中。<p>如果定义一个<code>com.hazelcast.config.Config</code> bean，Spring Boot 将使用它。如果您的配置定义了一个实例名称，Spring Boot 会尝试查找一个现有实例，而不是创建一个新实例。<p>您还可以指定<code>hazelcast.xml</code>配置文件以通过配置使用，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.hazelcast.config</span>=<span class=string>classpath:config/my-hazelcast.xml</span></span><br></pre></table></figure><p>否则，Spring Boot 会尝试从默认位置：工作目录中或 Classpath 根目录中的<code>hazelcast.xml</code>查找 Hazelcast 配置。我们还检查<code>hazelcast.config</code>系统属性是否设置。有关更多详细信息，请参见<a href=http://docs.hazelcast.org/docs/latest/manual/html-single/ rel=noopener target=_blank>Hazelcast documentation</a>。<p>如果<code>hazelcast-client</code>存在于 Classpath 中，则 Spring Boot 首先尝试通过检查以下配置选项来创建 Client 端：<ul><li><code>com.hazelcast.client.config.ClientConfig</code> bean 的存在。<li><code>spring.hazelcast.config</code>属性定义的配置文件。<li><code>hazelcast.client.config</code>系统属性的存在。<li>工作目录中或 Classpath 根目录中的<code>hazelcast-client.xml</code>。</ul><blockquote><p>Spring Boot 也具有<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-caching.html#boot-features-caching-provider-hazelcast rel=noopener target=_blank>对 Hazelcast 的显式缓存支持</a>。如果启用了缓存，则<code>HazelcastInstance</code>将自动包装在<code>CacheManager</code>实现中。</blockquote><h2 id=3-18、Quartz-Scheduler><a title="3.18、Quartz Scheduler" class=headerlink href=#3-18、Quartz-Scheduler></a>3.18、Quartz Scheduler</h2><p>Spring Boot 为使用<a href=http://www.quartz-scheduler.org/ rel=noopener target=_blank>Quartz scheduler</a>提供了许多便利，其中包括<code>spring-boot-starter-quartz</code>“ Starter”。如果 Quartz 可用，则会自动配置<code>Scheduler</code>(通过<code>SchedulerFactoryBean</code>抽象)。<p>以下类型的 Bean 被自动拾取并与<code>Scheduler</code>关联：<ul><li><code>JobDetail</code>：定义特定的作业。可以使用<code>JobBuilder</code> API 构建<code>JobDetail</code>实例。<li><code>Calendar</code> .<li><code>Trigger</code>：定义何时触发特定作业。</ul><p>默认情况下，使用内存中的<code>JobStore</code>。但是，如果您的应用程序中有<code>DataSource</code> bean 可用，并且相应地配置了<code>spring.quartz.job-store-type</code>属性，则可以配置基于 JDBC 的存储，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.quartz.job-store-type</span>=<span class=string>jdbc</span></span><br></pre></table></figure><p>使用 JDBC 存储时，可以在启动时初始化模式，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.quartz.jdbc.initialize-schema</span>=<span class=string>always</span></span><br></pre></table></figure><blockquote><p>默认情况下，使用 Quartz 库随附的标准脚本检测并初始化数据库。这些脚本删除现有表，并在每次重新启动时删除所有触发器。也可以通过设置<code>spring.quartz.jdbc.schema</code>属性来提供自定义脚本。</blockquote><p>要让 Quartz 使用除应用程序主<code>DataSource</code>之外的<code>DataSource</code>，请声明<code>DataSource</code> bean，并用<code>@QuartzDataSource</code>Comments 其<code>@Bean</code>方法。这样做可确保<code>SchedulerFactoryBean</code>使用 Quartz 专用的<code>DataSource</code>并用于模式初始化。<p>默认情况下，通过配置创建的作业将不会覆盖从持久性作业存储中读取的已注册作业。要启用覆盖现有作业定义的功能，请设置<code>spring.quartz.overwrite-existing-jobs</code>属性。<p>可以使用<code>spring.quartz</code>属性和<code>SchedulerFactoryBeanCustomizer</code> bean 自定义 Quartz Scheduler 配置，从而可以通过编程方式自定义<code>SchedulerFactoryBean</code>。可以使用<code>spring.quartz.properties.*</code>定制高级 Quartz 配置属性。<blockquote><p>特别是，<code>Executor</code> bean 没有与调度程序相关联，因为 Quartz 提供了一种通过<code>spring.quartz.properties</code>配置调度程序的方法。如果您需要自定义任务 Actuator，请考虑实现<code>SchedulerFactoryBeanCustomizer</code>。</blockquote><p>作业可以定义设置器以注入数据 Map 属性。常规 bean 也可以类似的方式注入，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SampleJob</span> <span class=keyword>extends</span> <span class="title class_">QuartzJobBean</span> {</span><br><span class=line>	<span class=keyword>private</span> MyService myService;</span><br><span class=line>	<span class=keyword>private</span> String name;</span><br><span class=line></span><br><span class=line>	<span class=comment>// Inject "MyService" bean</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMyService</span><span class=params>(MyService myService)</span> { ... }</span><br><span class=line></span><br><span class=line>	<span class=comment>// Inject the "name" job data property</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setName</span><span class=params>(String name)</span> { ... }</span><br><span class=line></span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>protected</span> <span class=keyword>void</span> <span class="title function_">executeInternal</span><span class=params>(JobExecutionContext context)</span></span><br><span class=line>			<span class=keyword>throws</span> JobExecutionException {</span><br><span class=line>		...</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h2 id=3-19、任务执行和计划><a class=headerlink href=#3-19、任务执行和计划 title=3.19、任务执行和计划></a>3.19、任务执行和计划</h2><p>在上下文中没有<code>TaskExecutor</code> bean 的情况下，Spring Boot 会使用合理的默认值自动配置<code>ThreadPoolTaskExecutor</code>，这些默认值可以自动与异步任务执行(<code>@EnableAsync</code>)和 Spring MVC 异步请求处理相关联。<p>线程池使用 8 个核心线程，这些线程可以根据负载增长和收缩。可以使用<code>spring.task.execution</code>名称空间对这些默认设置进行微调，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.task.execution.pool.max-threads</span>=<span class=string>16</span></span><br><span class=line><span class=attr>spring.task.execution.pool.queue-capacity</span>=<span class=string>100</span></span><br><span class=line><span class=attr>spring.task.execution.pool.keep-alive</span>=<span class=string>10s</span></span><br></pre></table></figure><p>这会将线程池更改为使用有界队列，以便当队列已满(100 个任务)时，线程池最多增加到 16 个线程。当线程空闲 10 秒(而不是默认情况下的 60 秒)时，回收线程会使池的收缩更加激进。<p>如果需要将<code>ThreadPoolTaskScheduler</code>与计划的任务执行(<code>@EnableScheduling</code>)关联，也可以对其进行自动配置。默认情况下，线程池使用一个线程，可以使用<code>spring.task.scheduling</code>名称空间对这些设置进行微调。<p>如果需要创建自定义执行程序或调度程序，则<code>TaskExecutorBuilder</code> bean 和<code>TaskSchedulerBuilder</code> bean 在上下文中都可用。<h2 id=3-20、Spring-整合><a title="3.20、Spring 整合" class=headerlink href=#3-20、Spring-整合></a>3.20、Spring 整合</h2><p>Spring Boot 为使用<a href=https://projects.spring.io/spring-integration/ rel=noopener target=_blank>Spring Integration</a>提供了许多便利，其中包括<code>spring-boot-starter-integration</code>“ Starter”。 Spring Integration 在消息传递以及其他传输(例如 HTTP，TCP 等)上提供了抽象。如果您的 Classpath 上有 Spring Integration，则可以通过<code>@EnableIntegration</code>Comments 对其进行初始化。<p>Spring Boot 还配置了一些功能，这些功能由其他 Spring Integration 模块的存在触发。如果<code>spring-integration-jmx</code>也在 Classpath 上，则消息处理统计信息将通过 JMX 发布。如果<code>spring-integration-jdbc</code>可用，则可以在启动时创建默认数据库架构，如以下行所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.integration.jdbc.initialize-schema</span>=<span class=string>always</span></span><br></pre></table></figure><p>有关更多详细信息，请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationAutoConfiguration.java rel=noopener target=_blank>IntegrationAutoConfiguration</a>和<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/integration/IntegrationProperties.java rel=noopener target=_blank>IntegrationProperties</a>类。<p>默认情况下，如果存在 Micrometer <code>meterRegistry</code> bean，那么 Spring Integration Metrics 将由 Micrometer Management。如果您希望使用旧版 Spring Integration Metrics，请将<code>DefaultMetricsFactory</code> bean 添加到应用程序上下文中。<h2 id=3-21、Spring-Session><a title="3.21、Spring Session" class=headerlink href=#3-21、Spring-Session></a>3.21、Spring Session</h2><p>Spring Boot 为广泛的数据存储提供<a href=https://projects.spring.io/spring-session/ rel=noopener target=_blank>Spring Session</a>自动配置。构建 Servlet Web 应用程序时，可以自动配置以下存储：<ul><li>JDBC<li>Redis<li>Hazelcast<li>MongoDB</ul><p>构建反应式 Web 应用程序时，可以自动配置以下存储：<ul><li>Redis<li>MongoDB</ul><p>如果 Classpath 上只有一个 Spring Session 模块，Spring Boot 会自动使用该存储实现。如果您有多个实现，则必须选择要用于存储会话的<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/session/StoreType.java rel=noopener target=_blank>StoreType</a>。例如，要将 JDBC 用作后端存储，可以按以下方式配置应用程序：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.session.store-type</span>=<span class=string>jdbc</span></span><br></pre></table></figure><blockquote><p>您可以通过将<code>store-type</code>设置为<code>none</code>来禁用 Spring Session。</blockquote><p>每个 Store 都有特定的其他设置。例如，可以为 JDBC 存储定制表的名称，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.session.jdbc.table-name</span>=<span class=string>SESSIONS</span></span><br></pre></table></figure><p>要设置会话超时，您可以使用<code>spring.session.timeout</code>属性。如果未设置该属性，则自动配置将回退到<code>server.servlet.session.timeout</code>的值。<h2 id=3-22、通过-JMX-进行监视和-Management><a title="3.22、通过 JMX 进行监视和 Management" class=headerlink href=#3-22、通过-JMX-进行监视和-Management></a>3.22、通过 JMX 进行监视和 Management</h2><p>Java Management 扩展(JMX)提供了监视和 Management 应用程序的标准机制。默认情况下，Spring Boot 创建一个 ID 为<code>mbeanServer</code>的<code>MBeanServer</code> bean，并公开任何带有 Spring JMX Comments(<code>@ManagedResource</code>，<code>@ManagedAttribute</code>或<code>@ManagedOperation</code>)的 bean。<p>有关更多详细信息，请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/jmx/JmxAutoConfiguration.java rel=noopener target=_blank>JmxAutoConfiguration</a>类。<h2 id=3-23、Testing><a class=headerlink href=#3-23、Testing title=3.23、Testing></a>3.23、Testing</h2><p>Spring Boot 提供了许多 Util 和 Comments，可以在测试应用程序时提供帮助。测试支持由两个模块提供：<code>spring-boot-test</code>包含核心项目，而<code>spring-boot-test-autoconfigure</code>支持自动配置测试。<p>大多数开发人员使用<code>spring-boot-starter-test</code>“Starter 程序”，该程序同时导入 Spring Boot 测试模块以及 JUnit，AssertJ，Hamcrest 和许多其他有用的库。<h3 id=3-23-1、测试范围依赖性><a class=headerlink href=#3-23-1、测试范围依赖性 title=3.23.1、测试范围依赖性></a>3.23.1、测试范围依赖性</h3><p><code>spring-boot-starter-test</code>“Starter”(位于<code>test</code> <code>scope</code>中)包含以下提供的库：<ul><li><a href=http://junit.org/ rel=noopener target=_blank>JUnit</a>：用于对 Java 应用程序进行单元测试的实际标准。<li><a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#integration-testing rel=noopener target=_blank>Spring Test</a>和 Spring Boot 测试：对 Spring Boot 应用程序的 Util 和集成测试支持。<li><a href=https://joel-costigliola.github.io/assertj/ rel=noopener target=_blank>AssertJ</a>：流畅的 assert 库。<li><a href=http://hamcrest.org/JavaHamcrest/ rel=noopener target=_blank>Hamcrest</a>：匹配器对象库(也称为约束或谓词)。<li><a href=http://mockito.org/ rel=noopener target=_blank>Mockito</a>：Java 模拟框架。<li><a href=https://github.com/skyscreamer/JSONassert rel=noopener target=_blank>JSONassert</a>：JSON 的 assert 库。<li><a href=https://github.com/jayway/JsonPath rel=noopener target=_blank>JsonPath</a>：JSON 的 XPath。</ul><p>通常，我们发现这些通用库在编写测试时很有用。如果这些库不满足您的需求，则可以添加自己的其他测试依赖项。<h3 id=3-23-2、测试-Spring-应用程序><a title="3.23.2、测试 Spring 应用程序" class=headerlink href=#3-23-2、测试-Spring-应用程序></a>3.23.2、测试 Spring 应用程序</h3><p>依赖注入的主要优点之一是，它应该使您的代码更易于进行单元测试。您可以使用<code>new</code>运算符实例化对象，而无需使用 Spring。您也可以使用* mock objects *代替 true 的依赖。<p>通常，您需要超越单元测试并开始集成测试(使用 Spring <code>ApplicationContext</code>)。能够进行集成测试而无需部署应用程序或连接到其他基础结构，这很有用。<p>Spring 框架包括用于此类集成测试的专用测试模块。您可以直接向<code>org.springframework:spring-test</code>声明依赖项，也可以使用<code>spring-boot-starter-test</code>“启动器”将其引入。<p>如果以前没有使用过<code>spring-test</code>模块，则应先阅读 Spring Framework 参考文档的<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#testing rel=noopener target=_blank>relevant section</a>。<h3 id=3-23-3、测试-Spring-Boot-应用程序><a title="3.23.3、测试 Spring Boot 应用程序" class=headerlink href=#3-23-3、测试-Spring-Boot-应用程序></a>3.23.3、测试 Spring Boot 应用程序</h3><p>Spring Boot 应用程序是 Spring <code>ApplicationContext</code>，因此除了用普通的 Spring 上下文进行测试之外，无需执行任何其他特殊操作即可对其进行测试。<blockquote><p>仅当您使用<code>SpringApplication</code>创建它时，Spring Boot 的外部属性，日志记录和其他功能才默认安装在上下文中。</blockquote><p>Spring Boot 提供了<code>@SpringBootTest</code>注解，可以在需要 Spring Boot 功能时用作标准<code>spring-test</code> <code>@ContextConfiguration</code>注解的替代方法。Comments 由<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-detecting-config rel=noopener target=_blank>通过 SpringApplication 创建在测试中使用的 ApplicationContext</a>起作用。除了<code>@SpringBootTest</code>之外，还为应用程序<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests rel=noopener target=_blank>测试更具体的切片</a>提供了许多其他 Comments。<blockquote><p>如果您使用的是 JUnit 4，请不要忘记也将<code>@RunWith(SpringRunner.class)</code>添加到测试中，否则 Comments 将被忽略。如果您使用的是 JUnit 5，则无需添加等效的<code>@ExtendWith(SpringExtension)</code>作为<code>@SpringBootTest</code>，并且其他<code>@…Test</code>Comments 已经对其进行了 Comments。</blockquote><p>默认情况下，<code>@SpringBootTest</code>不会启动服务器。您可以使用<code>@SpringBootTest</code>的<code>webEnvironment</code>属性来进一步优化测试的运行方式：<ul><li><code>MOCK</code>(默认)：加载 Web <code>ApplicationContext</code>并提供模拟 Web 环境。使用此 Comments 时，不会启动嵌入式服务器。如果您的 Classpath 中没有 Web 环境，则此模式将透明地退回到创建常规的非 Web <code>ApplicationContext</code>。它可以与<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-with-mock-environment rel=noopener target=_blank>@AutoConfigureMockMvc 或@AutoConfigureWebTestClient</a>结合使用，以对 Web 应用程序进行基于模拟的测试。<li><code>RANDOM_PORT</code>：加载<code>WebServerApplicationContext</code>并提供真实的 Web 环境。嵌入式服务器将启动并在随机端口上侦听。<li><code>DEFINED_PORT</code>：加载<code>WebServerApplicationContext</code>并提供真实的 Web 环境。嵌入式服务器将启动，并在已定义的端口(来自<code>application.properties</code>)或默认端口<code>8080</code>上进行侦听。<li><code>NONE</code>：使用<code>SpringApplication</code>加载<code>ApplicationContext</code>，但不提供<em>任何</em>网络环境(模拟或其他方式)。</ul><blockquote><p>如果您的测试是<code>@Transactional</code>，则默认情况下它将在每个测试方法的末尾回滚事务。但是，由于将这种安排与<code>RANDOM_PORT</code>或<code>DEFINED_PORT</code>一起使用隐式提供了 true 的 servlet 环境，因此 HTTP Client 端和服务器在单独的线程中运行，因此在单独的事务中运行。在这种情况下，服务器上启动的任何事务都不会回滚。<p>如果您的应用程序对 Management 服务器使用其他端口，则<code>@SpringBootTest</code>和<code>webEnvironment = WebEnvironment.RANDOM_PORT</code>还将在单独的随机端口上启动 Management 服务器。</blockquote><h4 id=3-23-3-1、检测-Web-应用程序类型><a title="3.23.3.1、检测 Web 应用程序类型" class=headerlink href=#3-23-3-1、检测-Web-应用程序类型></a>3.23.3.1、检测 Web 应用程序类型</h4><p>如果 Spring MVC 可用，则配置基于常规 MVC 的应用程序上下文。如果您只有 Spring WebFlux，我们将检测到该情况并配置基于 WebFlux 的应用程序上下文。<p>如果两者都存在，则 Spring MVC 优先。如果要在这种情况下测试反应式 Web 应用程序，则必须设置<code>spring.main.web-application-type</code>属性：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@SpringBootTest(properties = "spring.main.web-application-type=reactive")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyWebFluxTests</span> { ... }</span><br></pre></table></figure><h4 id=3-23-3-2、检测测试配置><a class=headerlink href=#3-23-3-2、检测测试配置 title=3.23.3.2、检测测试配置></a>3.23.3.2、检测测试配置</h4><p>如果您熟悉 Spring Test Framework，则可能会习惯使用<code>@ContextConfiguration(classes=…)</code>来指定要加载哪个 Spring <code>@Configuration</code>。另外，您可能经常在测试中使用嵌套的<code>@Configuration</code>类。<p>在测试 Spring Boot 应用程序时，通常不需要这样做。只要您没有明确定义 Spring Boot 的<code>@*Test</code>注解，它就会自动搜索您的主要配置。<p>搜索算法从包含测试的程序包开始工作，直到找到带有<code>@SpringBootApplication</code>或<code>@SpringBootConfiguration</code>Comments 的类。只要您以一种明智的方式<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-structuring-your-code.html rel=noopener target=_blank>结构化代码</a>，通常就可以找到您的主要配置。<blockquote><p>如果您使用<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-tests rel=noopener target=_blank>测试 Comments 以测试应用程序的更具体部分</a>，则应避免在<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-user-configuration rel=noopener target=_blank>Main 方法的应用程序类别</a>上添加特定于特定区域的配置设置。<p><code>@SpringBootApplication</code>的基础组件扫描配置定义了用于确保切片按预期工作的排除筛选器。如果在<code>@SpringBootApplication</code>Comments 的类上使用显式的<code>@ComponentScan</code>指令，请注意这些过滤器将被禁用。如果使用切片，则应重新定义它们。</blockquote><p>如果要自定义主要配置，则可以使用嵌套的<code>@TestConfiguration</code>类。与将使用嵌套的<code>@Configuration</code>类代替应用程序的主要配置不同的是，除了使用应用程序的主要配置之外，还使用嵌套的<code>@TestConfiguration</code>类。<blockquote><p>Spring 的测试框架在测试之间缓存应用程序上下文。因此，只要您的测试共享相同的配置(无论如何发现)，加载上下文的潜在耗时过程就只会发生一次。</blockquote><h4 id=3-23-3-3、排除测试配置><a class=headerlink href=#3-23-3-3、排除测试配置 title=3.23.3.3、排除测试配置></a>3.23.3.3、排除测试配置</h4><p>如果您的应用程序使用组件扫描(例如，如果使用<code>@SpringBootApplication</code>或<code>@ComponentScan</code>)，则可能会偶然发现到处都是为特定测试创建的顶级配置类。<p>正如我们<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-detecting-config rel=noopener target=_blank>早看过</a>，<code>@TestConfiguration</code>可以在测试的内部类上使用以自定义主要配置。当放在顶级类上时，<code>@TestConfiguration</code>指示<code>src/test/java</code>中的类不应通过扫描来拾取。然后，可以在需要的位置显式导入该类，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@SpringBootTest</span></span><br><span class=line><span class=meta>@Import(MyTestsConfiguration.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyTests</span> {</span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">exampleTest</span><span class=params>()</span> {</span><br><span class=line>		...</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>如果您直接使用<code>@ComponentScan</code>(即不是通过<code>@SpringBootApplication</code>)，则需要向其注册<code>TypeExcludeFilter</code>。有关详情，请参见<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/context/TypeExcludeFilter.html rel=noopener target=_blank>the Javadoc</a>。</blockquote><h4 id=3-23-3-4、在模拟环境中进行测试><a class=headerlink href=#3-23-3-4、在模拟环境中进行测试 title=3.23.3.4、在模拟环境中进行测试></a>3.23.3.4、在模拟环境中进行测试</h4><p>默认情况下，<code>@SpringBootTest</code>不会启动服务器。如果您有要在此模拟环境下进行测试的 Web 终结点，则可以另外配置<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference//testing.html#spring-mvc-test-framework rel=noopener target=_blank>MockMvc</a>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@SpringBootTest</span></span><br><span class=line><span class=meta>@AutoConfigureMockMvc</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MockMvcExampleTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> MockMvc mvc;</span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">exampleTest</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		<span class=built_in>this</span>.mvc.perform(get(<span class=string>"/"</span>)).andExpect(status().isOk())</span><br><span class=line>				.andExpect(content().string(<span class=string>"Hello World"</span>));</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>如果您只想关注 Web 层而不想开始完整的<code>ApplicationContext</code>，请考虑<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-mvc-tests rel=noopener target=_blank>使用@WebMvcTest 代替</a>。</blockquote><p>或者，您可以配置<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#webtestclient-tests rel=noopener target=_blank>WebTestClient</a>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.web.reactive.AutoConfigureWebTestClient;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.web.reactive.server.WebTestClient;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@SpringBootTest</span></span><br><span class=line><span class=meta>@AutoConfigureWebTestClient</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MockWebTestClientExampleTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> WebTestClient webClient;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">exampleTest</span><span class=params>()</span> {</span><br><span class=line>		<span class=built_in>this</span>.webClient.get().uri(<span class=string>"/"</span>).exchange().expectStatus().isOk()</span><br><span class=line>				.expectBody(String.class).isEqualTo(<span class=string>"Hello World"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-3-5、使用正在运行的服务器进行测试><a class=headerlink href=#3-23-3-5、使用正在运行的服务器进行测试 title=3.23.3.5、使用正在运行的服务器进行测试></a>3.23.3.5、使用正在运行的服务器进行测试</h4><p>如果需要启动完全运行的服务器，建议您使用随机端口。如果您使用<code>@SpringBootTest(webEnvironment=WebEnvironment.RANDOM_PORT)</code>，则每次运行测试时都会随机选择一个可用端口。<p><code>@LocalServerPort</code>注解可用于<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/howto-embedded-web-servers.html#howto-discover-the-http-port-at-runtime rel=noopener target=_blank>注入实际使用的端口</a>进入您的测试。为了方便起见，需要对启动的服务器进行 REST 调用的测试可以另外<code>@Autowire</code> a <a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#webtestclient-tests rel=noopener target=_blank>WebTestClient</a>，该解析可以解析到正在运行的服务器的相对链接，并带有用于验证响应的专用 API，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.context.SpringBootTest.WebEnvironment;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.web.reactive.server.WebTestClient;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RandomPortWebTestClientExampleTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> WebTestClient webClient;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">exampleTest</span><span class=params>()</span> {</span><br><span class=line>		<span class=built_in>this</span>.webClient.get().uri(<span class=string>"/"</span>).exchange().expectStatus().isOk()</span><br><span class=line>				.expectBody(String.class).isEqualTo(<span class=string>"Hello World"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>此设置在 Classpath 上需要<code>spring-webflux</code>。如果您不能或不会添加 webflux，Spring Boot 还将提供<code>TestRestTemplate</code>功能：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.context.SpringBootTest.WebEnvironment;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.web.client.TestRestTemplate;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.assertj.core.api.Assertions.assertThat;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RandomPortTestRestTemplateExampleTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> TestRestTemplate restTemplate;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">exampleTest</span><span class=params>()</span> {</span><br><span class=line>		<span class=type>String</span> <span class=variable>body</span> <span class=operator>=</span> <span class=built_in>this</span>.restTemplate.getForObject(<span class=string>"/"</span>, String.class);</span><br><span class=line>		assertThat(body).isEqualTo(<span class=string>"Hello World"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-3-6、使用-JMX><a title="3.23.3.6、使用 JMX" class=headerlink href=#3-23-3-6、使用-JMX></a>3.23.3.6、使用 JMX</h4><p>由于测试上下文框架缓存上下文，因此默认情况下禁用 JMX 以防止相同组件在同一域上注册。如果此类测试需要访问<code>MBeanServer</code>，也请考虑将其标记为脏：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@SpringBootTest(properties = "spring.jmx.enabled=true")</span></span><br><span class=line><span class=meta>@DirtiesContext</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SampleJmxTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> MBeanServer mBeanServer;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">exampleTest</span><span class=params>()</span> {</span><br><span class=line>		<span class=comment>// ...</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-3-7、模拟-bean-和-Spybean><a title="3.23.3.7、模拟 bean 和 Spybean" class=headerlink href=#3-23-3-7、模拟-bean-和-Spybean></a>3.23.3.7、模拟 bean 和 Spybean</h4><p>运行测试时，有时有必要在应用程序上下文中模拟某些组件。例如，您可能在开发期间无法使用某些远程服务的外观。当您要模拟在实际环境中可能难以触发的故障时，模拟功能也很有用。<p>Spring Boot 包含<code>@MockBean</code>注解，可用于为<code>ApplicationContext</code>中的 bean 定义 Mockito 模拟。您可以使用 Comments 添加新的 bean 或替换单个现有的 bean 定义。注解可以直接用于测试类，测试中的字段或<code>@Configuration</code>类和字段。在字段上使用时，还将注入创建的模拟的实例。每种测试方法后，模拟 bean 都会自动重置。<blockquote><p>如果您的测试使用 Spring Boot 的测试 Comments 之一(例如<code>@SpringBootTest</code>)，那么此功能将自动启用。要以其他方式使用此功能，必须显式添加侦听器，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=meta>@TestExecutionListeners(MockitoTestExecutionListener.class)</span></span><br></pre></table></figure></blockquote><p>下面的示例使用模拟实现替换现有的<code>RemoteService</code> bean：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.*;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.context.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.*;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.assertj.core.api.Assertions.*;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.mockito.BDDMockito.*;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@SpringBootTest</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyTests</span> {</span><br><span class=line>	<span class=meta>@MockBean</span></span><br><span class=line>	<span class=keyword>private</span> RemoteService remoteService;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> Reverser reverser;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">exampleTest</span><span class=params>()</span> {</span><br><span class=line>		<span class=comment>// RemoteService has been injected into the reverser bean</span></span><br><span class=line>		given(<span class=built_in>this</span>.remoteService.someCall()).willReturn(<span class=string>"mock"</span>);</span><br><span class=line>		<span class=type>String</span> <span class=variable>reverse</span> <span class=operator>=</span> reverser.reverseSomeCall();</span><br><span class=line>		assertThat(reverse).isEqualTo(<span class=string>"kcom"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>另外，您可以使用<code>@SpyBean</code>将任何现有的 bean 与 Mockito <code>spy</code>包装在一起。有关详细信息，请参见<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/test/mock/mockito/SpyBean.html rel=noopener target=_blank>Javadoc</a>。<blockquote><p>Spring 的测试框架在测试之间缓存应用程序上下文，并为共享相同配置的测试重用上下文，而<code>@MockBean</code>或<code>@SpyBean</code>的使用会影响缓存键，这很可能会增加上下文的数量。<p>如果您使用<code>@SpyBean</code>监视具有通过名称引用参数的<code>@Cacheable</code>方法的 bean，则您的应用程序必须使用<code>-parameters</code>进行编译。这样可以确保一旦侦察到 bean，就可以将参数名称用于缓存基础结构。</blockquote><h4 id=3-23-3-8、自动配置的测试><a class=headerlink href=#3-23-3-8、自动配置的测试 title=3.23.3.8、自动配置的测试></a>3.23.3.8、自动配置的测试</h4><p>Spring Boot 的自动配置系统适用于应用程序，但有时对于测试来说可能有点过多。它通常仅有助于加载测试应用程序“切片”所需的配置部分。例如，您可能想要测试 Spring MVC 控制器是否正确 Map 了 URL，并且您不想在这些测试中涉及数据库调用，或者您想要测试 JPA 实体，并且对那些 JPA 实体不感兴趣。测试运行。<p><code>spring-boot-test-autoconfigure</code>模块包含许多 Comments，可用于自动配置此类“切片”。它们中的每一个都以类似的方式工作，提供了一个<code>@…Test</code>注解，该注解加载了<code>ApplicationContext</code>和一个或多个<code>@AutoConfigure…</code>注解，这些注解可用于自定义自动配置设置。<blockquote><p>每个切片将组件扫描限制为适当的组件，并加载一组非常受限制的自动配置类。如果您需要排除其中之一，则大多数<code>@…Test</code>Comments 都提供<code>excludeAutoConfiguration</code>属性。或者，您可以使用<code>@ImportAutoConfiguration#exclude</code>。<p>不支持在一个测试中使用多个<code>@…Test</code>Comments 来包含多个“切片”。如果您需要多个“切片”，请选择<code>@…Test</code>Comments 之一，并手动添加其他“切片”的<code>@AutoConfigure…</code>Comments。<p>也可以将<code>@AutoConfigure…</code>Comments 与标准<code>@SpringBootTest</code>Comments 一起使用。如果您对“切片”应用程序不感兴趣，但需要一些自动配置的测试 bean，则可以使用此组合。</blockquote><h4 id=3-23-3-9、自动配置的-JSON-测试><a title="3.23.3.9、自动配置的 JSON 测试" class=headerlink href=#3-23-3-9、自动配置的-JSON-测试></a>3.23.3.9、自动配置的 JSON 测试</h4><p>要测试对象 JSON 序列化和反序列化是否按预期工作，可以使用<code>@JsonTest</code>注解。 <code>@JsonTest</code>自动配置可用的受支持的 JSON Map 器，该 Map 器可以是以下库之一：<ul><li>Jackson<code>ObjectMapper</code>，任何<code>@JsonComponent</code>beans 和任何 Jackson<code>Module</code> s<li><code>Gson</code><li><code>Jsonb</code></ul><blockquote><p><code>@JsonTest</code>启用的自动配置的列表可以为<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/test-auto-configuration.html rel=noopener target=_blank>见附录</a>。</blockquote><p>如果需要配置自动配置的元素，则可以使用<code>@AutoConfigureJsonTesters</code>Comments。<p>Spring Boot 包括基于 AssertJ 的助手，这些助手与 JSONAssert 和 JsonPath 库一起使用，以检查 JSON 是否按预期方式显示。 <code>JacksonTester</code>，<code>GsonTester</code>，<code>JsonbTester</code>和<code>BasicJsonTester</code>类可以分别用于 Jackson，Gson，Jsonb 和 Strings。使用<code>@JsonTest</code>时，测试类上的任何帮助程序字段都可以为<code>@Autowired</code>。以下示例显示了 Jackson 的测试类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.*;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.json.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.context.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.json.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.*;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.assertj.core.api.Assertions.*;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@JsonTest</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyJsonTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> JacksonTester&LTVehicleDetails> json;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testSerialize</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		<span class=type>VehicleDetails</span> <span class=variable>details</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">VehicleDetails</span>(<span class=string>"Honda"</span>, <span class=string>"Civic"</span>);</span><br><span class=line>		<span class=comment>// Assert against a `.json` file in the same package as the test</span></span><br><span class=line>		assertThat(<span class=built_in>this</span>.json.write(details)).isEqualToJson(<span class=string>"expected.json"</span>);</span><br><span class=line>		<span class=comment>// Or use JSON path based assertions</span></span><br><span class=line>		assertThat(<span class=built_in>this</span>.json.write(details)).hasJsonPathStringValue(<span class=string>"@.make"</span>);</span><br><span class=line>		assertThat(<span class=built_in>this</span>.json.write(details)).extractingJsonPathStringValue(<span class=string>"@.make"</span>)</span><br><span class=line>				.isEqualTo(<span class=string>"Honda"</span>);</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testDeserialize</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		<span class=type>String</span> <span class=variable>content</span> <span class=operator>=</span> <span class=string>"{\"make\":\"Ford\",\"model\":\"Focus\"}"</span>;</span><br><span class=line>		assertThat(<span class=built_in>this</span>.json.parse(content))</span><br><span class=line>				.isEqualTo(<span class=keyword>new</span> <span class="title class_">VehicleDetails</span>(<span class=string>"Ford"</span>, <span class=string>"Focus"</span>));</span><br><span class=line>		assertThat(<span class=built_in>this</span>.json.parseObject(content).getMake()).isEqualTo(<span class=string>"Ford"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>JSON 帮助程序类也可以直接在标准单元测试中使用。这样做，如果不使用<code>@JsonTest</code>，请在您的<code>@Before</code>方法中调用帮助程序的<code>initFields</code>方法。</blockquote><h4 id=3-23-3-10、自动配置的-Spring-MVC-测试><a title="3.23.3.10、自动配置的 Spring MVC 测试" class=headerlink href=#3-23-3-10、自动配置的-Spring-MVC-测试></a>3.23.3.10、自动配置的 Spring MVC 测试</h4><p>要测试 Spring MVC 控制器是否按预期工作，请使用<code>@WebMvcTest</code>注解。 <code>@WebMvcTest</code>自动配置 Spring MVC 基础结构，并将扫描的 Bean 限制为<code>@Controller</code>，<code>@ControllerAdvice</code>，<code>@JsonComponent</code>，<code>Converter</code>，<code>GenericConverter</code>，<code>Filter</code>，<code>WebMvcConfigurer</code>和<code>HandlerMethodArgumentResolver</code>。使用此 Comments 时，不扫描常规的<code>@Component</code> bean。<blockquote><p><code>@WebMvcTest</code>启用的自动配置设置的列表可以为<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/test-auto-configuration.html rel=noopener target=_blank>见附录</a>。<p>如果您需要注册其他组件，例如 Jackson <code>Module</code>，则可以在测试中使用<code>@Import</code>导入其他配置类。</blockquote><p>通常，<code>@WebMvcTest</code>限于单个控制器，并与<code>@MockBean</code>结合使用以为所需的协作者提供模拟实现。<p><code>@WebMvcTest</code>也会自动配置<code>MockMvc</code>。 Mock MVC 提供了一种强大的方法来快速测试 MVC 控制器，而无需启动完整的 HTTP 服务器。<blockquote><p>您还可以通过用<code>@AutoConfigureMockMvc</code>Comments 非<code>@WebMvcTest</code>(例如<code>@SpringBootTest</code>)来自动配置<code>MockMvc</code>。以下示例使用<code>MockMvc</code>：</blockquote><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.*;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.web.servlet.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.assertj.core.api.Assertions.*;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.mockito.BDDMockito.*;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@WebMvcTest(UserVehicleController.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyControllerTests</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> MockMvc mvc;</span><br><span class=line></span><br><span class=line>	<span class=meta>@MockBean</span></span><br><span class=line>	<span class=keyword>private</span> UserVehicleService userVehicleService;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testExample</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		given(<span class=built_in>this</span>.userVehicleService.getVehicleDetails(<span class=string>"sboot"</span>))</span><br><span class=line>				.willReturn(<span class=keyword>new</span> <span class="title class_">VehicleDetails</span>(<span class=string>"Honda"</span>, <span class=string>"Civic"</span>));</span><br><span class=line>		<span class=built_in>this</span>.mvc.perform(get(<span class=string>"/sboot/vehicle"</span>).accept(MediaType.TEXT_PLAIN))</span><br><span class=line>				.andExpect(status().isOk()).andExpect(content().string(<span class=string>"Honda Civic"</span>));</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>如果您需要配置自动配置的元素(例如，当应用 servlet 过滤器时)，则可以使用<code>@AutoConfigureMockMvc</code>注解中的属性。</blockquote><p>如果使用 HtmlUnit 或 Selenium，则自动配置还会提供 HTMLUnit <code>WebClient</code> bean 和/或<code>WebDriver</code> bean。以下示例使用 HtmlUnit：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> com.gargoylesoftware.htmlunit.*;</span><br><span class=line><span class=keyword>import</span> org.junit.*;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.web.servlet.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.mock.mockito.*;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.assertj.core.api.Assertions.*;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.mockito.BDDMockito.*;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@WebMvcTest(UserVehicleController.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyHtmlUnitTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> WebClient webClient;</span><br><span class=line>	<span class=meta>@MockBean</span></span><br><span class=line>	<span class=keyword>private</span> UserVehicleService userVehicleService;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testExample</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		given(<span class=built_in>this</span>.userVehicleService.getVehicleDetails(<span class=string>"sboot"</span>))</span><br><span class=line>				.willReturn(<span class=keyword>new</span> <span class="title class_">VehicleDetails</span>(<span class=string>"Honda"</span>, <span class=string>"Civic"</span>));</span><br><span class=line>		<span class=type>HtmlPage</span> <span class=variable>page</span> <span class=operator>=</span> <span class=built_in>this</span>.webClient.getPage(<span class=string>"/sboot/vehicle.html"</span>);</span><br><span class=line>		assertThat(page.getBody().getTextContent()).isEqualTo(<span class=string>"Honda Civic"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>默认情况下，Spring Boot 将<code>WebDriver</code> bean 放在特殊的“作用域”中，以确保驱动程序在每次测试后退出并注入新实例。如果您不希望出现这种情况，可以将<code>@Scope("singleton")</code>添加到<code>WebDriver</code> <code>@Bean</code>定义中。<p>Spring Boot 创建的<code>webDriver</code>作用域将替换任何用户定义的同名作用域。如果定义自己的<code>webDriver</code>范围，则使用<code>@WebMvcTest</code>时可能会停止工作。</blockquote><p>如果您在 Classpath 上具有 Spring Security，则<code>@WebMvcTest</code>还将扫描<code>WebSecurityConfigurer</code> bean。您可以使用 Spring Security 的测试支持，而不是完全禁用此类测试的安全性。有关如何使用 Spring Security 的<code>MockMvc</code>支持的更多详细信息，可以在此* <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/howto-use-test-with-spring-security.html rel=noopener target=_blank>使用 Spring Security 进行测试</a> *操作方法部分中找到。<blockquote><p>有时编写 Spring MVC 测试是不够的。 Spring Boot 可以帮助您运行<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-with-running-server rel=noopener target=_blank>使用实际服务器进行完整的端到端测试</a>。</blockquote><h4 id=3-23-3-11、自动配置的-Spring-WebFlux-测试><a title="3.23.3.11、自动配置的 Spring WebFlux 测试" class=headerlink href=#3-23-3-11、自动配置的-Spring-WebFlux-测试></a>3.23.3.11、自动配置的 Spring WebFlux 测试</h4><p>要测试<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference//web-reactive.html rel=noopener target=_blank>Spring WebFlux</a>控制器是否按预期工作，可以使用<code>@WebFluxTest</code>注解。 <code>@WebFluxTest</code>自动配置 Spring WebFlux 基础结构，并将扫描的 bean 限制为<code>@Controller</code>，<code>@ControllerAdvice</code>，<code>@JsonComponent</code>，<code>Converter</code>，<code>GenericConverter</code>和<code>WebFluxConfigurer</code>。使用<code>@WebFluxTest</code>注解时，不扫描常规<code>@Component</code> bean。<blockquote><p><code>@WebFluxTest</code>启用的自动配置的列表可以为<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/test-auto-configuration.html rel=noopener target=_blank>见附录</a>。<p>如果您需要注册其他组件，例如 Jackson <code>Module</code>，则可以在测试中使用<code>@Import</code>导入其他配置类。</blockquote><p><code>@WebFluxTest</code>通常仅限于单个控制器，并与<code>@MockBean</code>注解结合使用以为所需的协作者提供模拟实现。<p><code>@WebFluxTest</code>还自动配置<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#webtestclient rel=noopener target=_blank>WebTestClient</a>，它提供了一种强大的方法来快速测试 WebFlux 控制器而无需启动完整的 HTTP 服务器。<blockquote><p>您还可以通过用<code>@AutoConfigureWebTestClient</code>Comments 非<code>@WebFluxTest</code>(例如<code>@SpringBootTest</code>)来自动配置<code>WebTestClient</code>。以下示例显示了同时使用<code>@WebFluxTest</code>和<code>WebTestClient</code>的类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.web.reactive.WebFluxTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.http.MediaType;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.web.reactive.server.WebTestClient;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@WebFluxTest(UserVehicleController.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyControllerTests</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> WebTestClient webClient;</span><br><span class=line></span><br><span class=line>	<span class=meta>@MockBean</span></span><br><span class=line>	<span class=keyword>private</span> UserVehicleService userVehicleService;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testExample</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		given(<span class=built_in>this</span>.userVehicleService.getVehicleDetails(<span class=string>"sboot"</span>))</span><br><span class=line>				.willReturn(<span class=keyword>new</span> <span class="title class_">VehicleDetails</span>(<span class=string>"Honda"</span>, <span class=string>"Civic"</span>));</span><br><span class=line>		<span class=built_in>this</span>.webClient.get().uri(<span class=string>"/sboot/vehicle"</span>).accept(MediaType.TEXT_PLAIN)</span><br><span class=line>				.exchange()</span><br><span class=line>				.expectStatus().isOk()</span><br><span class=line>				.expectBody(String.class).isEqualTo(<span class=string>"Honda Civic"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>WebFlux 应用程序仅支持此设置，因为在模拟的 Web 应用程序中使用<code>WebTestClient</code>目前仅适用于 WebFlux。<p><code>@WebFluxTest</code>无法检测通过功能 Web 框架注册的路由。要在上下文中测试<code>RouterFunction</code> bean，请考虑自己通过<code>@Import</code>或使用<code>@SpringBootTest</code>导入<code>RouterFunction</code>。<p>有时编写 Spring WebFlux 测试是不够的。 Spring Boot 可以帮助您运行<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-with-running-server rel=noopener target=_blank>使用实际服务器进行完整的端到端测试</a>。</blockquote><h4 id=3-23-3-12、自动配置的数据-JPA-测试><a title="3.23.3.12、自动配置的数据 JPA 测试" class=headerlink href=#3-23-3-12、自动配置的数据-JPA-测试></a>3.23.3.12、自动配置的数据 JPA 测试</h4><p>您可以使用<code>@DataJpaTest</code>注解来测试 JPA 应用程序。默认情况下，它配置一个内存嵌入式数据库，扫描<code>@Entity</code>类，并配置 Spring Data JPA 存储库。常规<code>@Component</code> bean 未加载到<code>ApplicationContext</code>中。<p>默认情况下，数据 JPA 测试是事务性的，并在每次测试结束时回滚。有关更多详细信息，请参见《 Spring Framework 参考文档》中的<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions rel=noopener target=_blank>relevant section</a>。如果这不是您想要的，则可以按以下方式禁用测试或整个类的事务 Management：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line><span class=keyword>import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class=line><span class=keyword>import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@DataJpaTest</span></span><br><span class=line><span class=meta>@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleNonTransactionalTests</span> {</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><p>数据 JPA 测试还可以注入<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-test-autoconfigure/src/main/java/org/springframework/boot/test/autoconfigure/orm/jpa/TestEntityManager.java rel=noopener target=_blank>TestEntityManager</a> bean，它提供了专门为测试设计的标准 JPA <code>EntityManager</code>的替代方案。如果要在<code>@DataJpaTest</code>实例之外使用<code>TestEntityManager</code>，则也可以使用<code>@AutoConfigureTestEntityManager</code>Comments。如果需要，也可以提供<code>JdbcTemplate</code>。以下示例显示了正在使用的<code>@DataJpaTest</code>注解：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.*;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.*;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.orm.jpa.*;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.assertj.core.api.Assertions.*;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@DataJpaTest</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleRepositoryTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> TestEntityManager entityManager;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> UserRepository repository;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testExample</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		<span class=built_in>this</span>.entityManager.persist(<span class=keyword>new</span> <span class="title class_">User</span>(<span class=string>"sboot"</span>, <span class=string>"1234"</span>));</span><br><span class=line>		<span class=type>User</span> <span class=variable>user</span> <span class=operator>=</span> <span class=built_in>this</span>.repository.findByUsername(<span class=string>"sboot"</span>);</span><br><span class=line>		assertThat(user.getUsername()).isEqualTo(<span class=string>"sboot"</span>);</span><br><span class=line>		assertThat(user.getVin()).isEqualTo(<span class=string>"1234"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>内存嵌入式数据库通常运行良好，不需要任何安装，因此通常可以很好地进行测试。但是，如果您希望对真实数据库运行测试，则可以使用<code>@AutoConfigureTestDatabase</code>注解，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@DataJpaTest</span></span><br><span class=line><span class=meta>@AutoConfigureTestDatabase(replace=Replace.NONE)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleRepositoryTests</span> {</span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-3-13、自动配置的-JDBC-测试><a title="3.23.3.13、自动配置的 JDBC 测试" class=headerlink href=#3-23-3-13、自动配置的-JDBC-测试></a>3.23.3.13、自动配置的 JDBC 测试</h4><p><code>@JdbcTest</code>与<code>@DataJpaTest</code>类似，但适用于只需要<code>DataSource</code>并且不使用 Spring Data JDBC 的测试。默认情况下，它配置内存嵌入式数据库和<code>JdbcTemplate</code>。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。<p>缺省情况下，JDBC 测试是事务性的，并在每次测试结束时回滚。有关更多详细信息，请参见《 Spring Framework 参考文档》中的<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions rel=noopener target=_blank>relevant section</a>。如果这不是您想要的，则可以为测试或整个类禁用事务 Management，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.jdbc.JdbcTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line><span class=keyword>import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class=line><span class=keyword>import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@JdbcTest</span></span><br><span class=line><span class=meta>@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleNonTransactionalTests</span> {</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><p>如果您希望测试针对真实数据库运行，则可以使用 Comments，方式与<code>DataJpaTest</code>相同。 (请参阅“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test rel=noopener target=_blank>第 45.3.12 节，“自动配置的数据 JPA 测试”</a>”。)<h4 id=3-23-3-14、自动配置的数据-JDBC-测试><a title="3.23.3.14、自动配置的数据 JDBC 测试" class=headerlink href=#3-23-3-14、自动配置的数据-JDBC-测试></a>3.23.3.14、自动配置的数据 JDBC 测试</h4><p><code>@DataJdbcTest</code>与<code>@JdbcTest</code>类似，但适用于使用 Spring Data JDBC 存储库的测试。默认情况下，它配置一个内存嵌入式数据库<code>JdbcTemplate</code>和 Spring Data JDBC 存储库。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。<p>默认情况下，Data JDBC 测试是事务性的，并在每个测试结束时回滚。有关更多详细信息，请参见《 Spring Framework 参考文档》中的<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions rel=noopener target=_blank>relevant section</a>。如果这不是您想要的，则可以禁用测试或整个测试类的事务 Management，即<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test rel=noopener target=_blank>在 JDBC 示例中显示</a>。<p>如果您希望测试针对真实数据库运行，则可以使用 Comments，方式与<code>DataJpaTest</code>相同。 (请参阅“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-jpa-test rel=noopener target=_blank>“自动配置的数据 JPA 测试”</a>”。)<h4 id=3-23-3-15、自动配置的-jOOQ-测试><a title="3.23.3.15、自动配置的 jOOQ 测试" class=headerlink href=#3-23-3-15、自动配置的-jOOQ-测试></a>3.23.3.15、自动配置的 jOOQ 测试</h4><p>您可以以与<code>@JdbcTest</code>类似的方式使用<code>@JooqTest</code>，但可以用于与 jOOQ 相关的测试。由于 jOOQ 严重依赖与数据库模式相对应的基于 Java 的模式，因此使用现有的<code>DataSource</code>。如果要将其替换为内存数据库，则可以使用<code>@AutoConfigureTestDatabase</code>覆盖这些设置。 (有关将 jOOQ 与 Spring Boot 结合使用的更多信息，请参阅本章前面的“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-sql.html#boot-features-jooq rel=noopener target=_blank>第 30.6 节“使用 jOOQ”</a>”。)常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。<p><code>@JooqTest</code>配置<code>DSLContext</code>。常规<code>@Component</code> bean 未加载到<code>ApplicationContext</code>中。以下示例显示了正在使用的<code>@JooqTest</code>Comments：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.jooq.DSLContext;</span><br><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.jooq.JooqTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@JooqTest</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleJooqTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> DSLContext dslContext;</span><br><span class=line>}</span><br></pre></table></figure><p>JOOQ 测试是事务性的，默认情况下会在每个测试结束时回滚。如果这不是您想要的，则可以禁用测试或整个测试类的事务 Management，例如<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test rel=noopener target=_blank>在 JDBC 示例中显示</a>。<h4 id=3-23-3-16、自动配置的-Data-MongoDB-测试><a title="3.23.3.16、自动配置的 Data MongoDB 测试" class=headerlink href=#3-23-3-16、自动配置的-Data-MongoDB-测试></a>3.23.3.16、自动配置的 Data MongoDB 测试</h4><p>您可以使用<code>@DataMongoTest</code>测试 MongoDB 应用程序。默认情况下，它配置内存嵌入式 MongoDB(如果可用)，配置<code>MongoTemplate</code>，扫描<code>@Document</code>类，并配置 Spring Data MongoDB 存储库。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。 (有关将 MongoDB 与 Spring Boot 结合使用的更多信息，请参阅本章前面的“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-nosql.html#boot-features-mongodb rel=noopener target=_blank>第 31.2 节“ MongoDB”</a>”。)<p>此类显示正在使用的<code>@DataMongoTest</code>注解：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.data.mongodb.core.MongoTemplate;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@DataMongoTest</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleDataMongoTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> MongoTemplate mongoTemplate;</span><br><span class=line>	<span class=comment>//</span></span><br><span class=line>}</span><br></pre></table></figure><p>内存嵌入式 MongoDB 通常运行良好，不需要任何开发人员安装，因此通常可以很好地用于测试。但是，如果您希望对真实的 MongoDB 服务器运行测试，则应排除嵌入式 MongoDB 自动配置，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line> <span class=keyword>import</span> org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.data.mongo.DataMongoTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@DataMongoTest(excludeAutoConfiguration = EmbeddedMongoAutoConfiguration.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleDataMongoNonEmbeddedTests</span> {</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-3-17、自动配置的数据-Neo4j-测试><a title="3.23.3.17、自动配置的数据 Neo4j 测试" class=headerlink href=#3-23-3-17、自动配置的数据-Neo4j-测试></a>3.23.3.17、自动配置的数据 Neo4j 测试</h4><p>您可以使用<code>@DataNeo4jTest</code>测试 Neo4j 应用程序。默认情况下，它使用内存中嵌入式 Neo4j(如果有嵌入式驱动程序可用)，扫描<code>@NodeEntity</code>类，并配置 Spring Data Neo4j 存储库。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。 (有关将 Neo4J 与 Spring Boot 结合使用的更多信息，请参阅本章前面的“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-nosql.html#boot-features-neo4j rel=noopener target=_blank>第 31.3 节“ Neo4j”</a>”。)<p>以下示例显示了在 Spring Boot 中使用 Neo4J 测试的典型设置：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@DataNeo4jTest</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleDataNeo4jTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> YourRepository repository;</span><br><span class=line></span><br><span class=line>	<span class=comment>//</span></span><br><span class=line>}</span><br></pre></table></figure><p>默认情况下，Data Neo4j 测试是事务性的，并在每个测试结束时回滚。有关更多详细信息，请参见《 Spring Framework 参考文档》中的<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/testing.html#testcontext-tx-enabling-transactions rel=noopener target=_blank>relevant section</a>。如果这不是您想要的，则可以为测试或整个类禁用事务 Management，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.data.neo4j.DataNeo4jTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line><span class=keyword>import</span> org.springframework.transaction.annotation.Propagation;</span><br><span class=line><span class=keyword>import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@DataNeo4jTest</span></span><br><span class=line><span class=meta>@Transactional(propagation = Propagation.NOT_SUPPORTED)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleNonTransactionalTests</span> {</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-3-18、自动配置的数据-Redis-测试><a title="3.23.3.18、自动配置的数据 Redis 测试" class=headerlink href=#3-23-3-18、自动配置的数据-Redis-测试></a>3.23.3.18、自动配置的数据 Redis 测试</h4><p>您可以使用<code>@DataRedisTest</code>测试 Redis 应用程序。默认情况下，它将扫描<code>@RedisHash</code>类并配置 Spring Data Redis 存储库。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。 (有关在 Spring Boot 中使用 Redis 的更多信息，请参阅本章前面的“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-nosql.html#boot-features-redis rel=noopener target=_blank>“ Redis”</a>”。)<p>以下示例显示了正在使用的<code>@DataRedisTest</code>注解：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.data.redis.DataRedisTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@DataRedisTest</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleDataRedisTests</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> YourRepository repository;</span><br><span class=line></span><br><span class=line>	<span class=comment>//</span></span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-3-19、自动配置的数据-LDAP-测试><a title="3.23.3.19、自动配置的数据 LDAP 测试" class=headerlink href=#3-23-3-19、自动配置的数据-LDAP-测试></a>3.23.3.19、自动配置的数据 LDAP 测试</h4><p>您可以使用<code>@DataLdapTest</code>测试 LDAP 应用程序。默认情况下，它配置内存嵌入式 LDAP(如果可用)，配置<code>LdapTemplate</code>，扫描<code>@Entry</code>类，并配置 Spring Data LDAP 存储库。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。 (有关将 LDAP 与 Spring Boot 结合使用的更多信息，请参阅本章前面的“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-nosql.html#boot-features-ldap rel=noopener target=_blank>“ LDAP”</a>”。)<p>以下示例显示了正在使用的<code>@DataLdapTest</code>注解：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.ldap.core.LdapTemplate;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@DataLdapTest</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleDataLdapTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> LdapTemplate ldapTemplate;</span><br><span class=line>	<span class=comment>//</span></span><br><span class=line>}</span><br></pre></table></figure><p>内存嵌入式 LDAP 通常非常适合测试，因为它速度快并且不需要安装任何开发人员。但是，如果您希望针对真实的 LDAP 服务器运行测试，则应排除嵌入式 LDAP 自动配置，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.data.ldap.DataLdapTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@DataLdapTest(excludeAutoConfiguration = EmbeddedLdapAutoConfiguration.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleDataLdapNonEmbeddedTests</span> {</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-3-20、自动配置的-REST-Client-端><a title="3.23.3.20、自动配置的 REST Client 端" class=headerlink href=#3-23-3-20、自动配置的-REST-Client-端></a>3.23.3.20、自动配置的 REST Client 端</h4><p>您可以使用<code>@RestClientTest</code>注解来测试 REST Client 端。默认情况下，它会自动配置 Jackson，GSON 和 Jsonb 支持，配置<code>RestTemplateBuilder</code>，并添加对<code>MockRestServiceServer</code>的支持。常规<code>@Component</code> bean 没有加载到<code>ApplicationContext</code>中。<p>应该使用<code>@RestClientTest</code>的<code>value</code>或<code>components</code>属性指定要测试的特定 bean，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@RestClientTest(RemoteVehicleDetailsService.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleRestClientTest</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> RemoteVehicleDetailsService service;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> MockRestServiceServer server;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">getVehicleDetailsWhenResultIsSuccessShouldReturnDetails</span><span class=params>()</span></span><br><span class=line>			<span class=keyword>throws</span> Exception {</span><br><span class=line>		<span class=built_in>this</span>.server.expect(requestTo(<span class=string>"/greet/details"</span>))</span><br><span class=line>				.andRespond(withSuccess(<span class=string>"hello"</span>, MediaType.TEXT_PLAIN));</span><br><span class=line>		<span class=type>String</span> <span class=variable>greeting</span> <span class=operator>=</span> <span class=built_in>this</span>.service.callRestService();</span><br><span class=line>		assertThat(greeting).isEqualTo(<span class=string>"hello"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-3-21、自动配置的-Spring-REST-文档测试><a title="3.23.3.21、自动配置的 Spring REST 文档测试" class=headerlink href=#3-23-3-21、自动配置的-Spring-REST-文档测试></a>3.23.3.21、自动配置的 Spring REST 文档测试</h4><p>您可以在 Mock MVC，REST 保证或 WebTestClient 的测试中使用<code>@AutoConfigureRestDocs</code>注解来使用<a href=https://projects.spring.io/spring-restdocs/ rel=noopener target=_blank>Spring REST 文件</a>。它消除了 Spring REST Docs 中对 JUnit 规则的需求。<p><code>@AutoConfigureRestDocs</code>可用于覆盖默认输出目录(如果使用 Maven，则使用<code>target/generated-snippets</code>；如果使用 Gradle，则使用<code>build/generated-snippets</code>)。它也可以用于配置出现在任何记录的 URI 中的主机，方案和端口。<h5 id=使用-Mock-MVC-自动配置的-Spring-REST-Docs-测试><a title="使用 Mock MVC 自动配置的 Spring REST Docs 测试" class=headerlink href=#使用-Mock-MVC-自动配置的-Spring-REST-Docs-测试></a>使用 Mock MVC 自动配置的 Spring REST Docs 测试</h5><p><code>@AutoConfigureRestDocs</code>自定义<code>MockMvc</code> bean 以使用 Spring REST Docs。您可以使用<code>@Autowired</code>注入它，并像通常使用 Mock MVC 和 Spring REST Docs 一样在测试中使用它，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.http.MediaType;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.web.servlet.MockMvc;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.springframework.restdocs.mockmvc.MockMvcRestDocumentation.document;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@WebMvcTest(UserController.class)</span></span><br><span class=line><span class=meta>@AutoConfigureRestDocs</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">UserDocumentationTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> MockMvc mvc;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">listUsers</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		<span class=built_in>this</span>.mvc.perform(get(<span class=string>"/users"</span>).accept(MediaType.TEXT_PLAIN))</span><br><span class=line>				.andExpect(status().isOk())</span><br><span class=line>				.andDo(document(<span class=string>"list-users"</span>));</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>如果您需要对 Spring REST Docs 配置进行更多控制，而不是<code>@AutoConfigureRestDocs</code>属性所提供的控制，则可以使用<code>RestDocsMockMvcConfigurationCustomizer</code> bean，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@TestConfiguration</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">CustomizationConfiguration</span></span><br><span class=line>		<span class=keyword>implements</span> <span class="title class_">RestDocsMockMvcConfigurationCustomizer</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">customize</span><span class=params>(MockMvcRestDocumentationConfigurer configurer)</span> {</span><br><span class=line>		configurer.snippets().withTemplateFormat(TemplateFormats.markdown());</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><p>如果要使用 Spring REST Docs 对参数化输出目录的支持，则可以创建<code>RestDocumentationResultHandler</code> bean。自动配置使用此结果处理程序调用<code>alwaysDo</code>，从而使每个<code>MockMvc</code>调用自动生成默认片段。以下示例显示正在定义的<code>RestDocumentationResultHandler</code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@TestConfiguration</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">ResultHandlerConfiguration</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> RestDocumentationResultHandler <span class="title function_">restDocumentation</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> MockMvcRestDocumentation.document(<span class=string>"{method-name}"</span>);</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><h5 id=具有-REST-保证的自动配置的-Spring-REST-文档测试><a title="具有 REST 保证的自动配置的 Spring REST 文档测试" class=headerlink href=#具有-REST-保证的自动配置的-Spring-REST-文档测试></a>具有 REST 保证的自动配置的 Spring REST 文档测试</h5><p><code>@AutoConfigureRestDocs</code>使预配置为使用 Spring REST 文档的<code>RequestSpecification</code> bean 可用于您的测试。您可以使用<code>@Autowired</code>注入它，并像在使用 REST Assured 和 Spring REST Docs 时一样，在测试中使用它，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> io.restassured.specification.RequestSpecification;</span><br><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.junit.runner.RunWith;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.autoconfigure.restdocs.AutoConfigureRestDocs;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.context.SpringBootTest.WebEnvironment;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.web.server.LocalServerPort;</span><br><span class=line><span class=keyword>import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> io.restassured.RestAssured.given;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.hamcrest.CoreMatchers.is;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.springframework.restdocs.restassured3.RestAssuredRestDocumentation.document;</span><br><span class=line></span><br><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></span><br><span class=line><span class=meta>@AutoConfigureRestDocs</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">UserDocumentationTests</span> {</span><br><span class=line>	<span class=meta>@LocalServerPort</span></span><br><span class=line>	<span class=keyword>private</span> <span class=type>int</span> port;</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> RequestSpecification documentationSpec;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">listUsers</span><span class=params>()</span> {</span><br><span class=line>		given(<span class=built_in>this</span>.documentationSpec).filter(document(<span class=string>"list-users"</span>)).when()</span><br><span class=line>				.port(<span class=built_in>this</span>.port).get(<span class=string>"/"</span>).then().assertThat().statusCode(is(<span class=number>200</span>));</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>如果您需要对 Spring REST Docs 配置进行更多控制而不是<code>@AutoConfigureRestDocs</code>属性提供的控制，则可以使用<code>RestDocsRestAssuredConfigurationCustomizer</code> bean，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@TestConfiguration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">CustomizationConfiguration</span></span><br><span class=line>		<span class=keyword>implements</span> <span class="title class_">RestDocsRestAssuredConfigurationCustomizer</span> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">customize</span><span class=params>(RestAssuredRestDocumentationConfigurer configurer)</span> {</span><br><span class=line>		configurer.snippets().withTemplateFormat(TemplateFormats.markdown());</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-3-22、其他自动配置和切片><a class=headerlink href=#3-23-3-22、其他自动配置和切片 title=3.23.3.22、其他自动配置和切片></a>3.23.3.22、其他自动配置和切片</h4><p>每个切片提供一个或多个<code>@AutoConfigure…</code>注解，即定义应包含在切片中的自动配置。可以通过创建自定义<code>@AutoConfigure…</code>Comments 或仅通过向测试中添加<code>@ImportAutoConfiguration</code>来添加其他自动配置，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@JdbcTest</span></span><br><span class=line><span class=meta>@ImportAutoConfiguration(IntegrationAutoConfiguration.class)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleJdbcTests</span> {</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>确保不要使用常规的<code>@Import</code>Comments 来导入自动配置，因为它们是由 Spring Boot 以特定方式处理的。</blockquote><h4 id=3-23-3-23、用户配置和切片><a class=headerlink href=#3-23-3-23、用户配置和切片 title=3.23.3.23、用户配置和切片></a>3.23.3.23、用户配置和切片</h4><p>如果您以明智的方式<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-structuring-your-code.html rel=noopener target=_blank>结构化代码</a>，则您的<code>@SpringBootApplication</code>类为<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-detecting-config rel=noopener target=_blank>默认使用</a>作为测试的配置。<p>因此，重要的是不要用特定于其功能特定区域的配置设置来乱扔应用程序的主类。<p>假设您正在使用 Spring Batch，并且依赖于它的自动配置。您可以按以下方式定义<code>@SpringBootApplication</code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>@SpringBootApplication</span></span><br><span class=line><span class=meta>@EnableBatchProcessing</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SampleApplication</span> { ... }</span><br></pre></table></figure><p>因为此类是测试的源配置，所以任何切片测试实际上都尝试启动 Spring Batch，这绝对不是您想要执行的操作。建议的方法是将特定于区域的配置移到与您的应用程序相同级别的单独的<code>@Configuration</code>类，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableBatchProcessing</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BatchConfiguration</span> { ... }</span><br></pre></table></figure><blockquote><p>根据您应用程序的复杂性，您可以为自己的自定义设置一个<code>@Configuration</code>类，或者每个域区域一个类。后一种方法可让您在必要的测试中使用<code>@Import</code>注解启用它。</blockquote><p>混乱的另一个来源是 Classpath 扫描。假设在以合理的方式组织代码的同时，您需要扫描其他程序包。您的应用程序可能类似于以下代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=meta>@SpringBootApplication</span></span><br><span class=line><span class=meta>@ComponentScan({ "com.example.app", "org.acme.another" })</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SampleApplication</span> { ... }</span><br></pre></table></figure><p>这样做有效地覆盖了默认的组件扫描指令，并且具有扫描这两个软件包的副作用，而与您选择的切片无关。例如，<code>@DataJpaTest</code>似乎突然扫描了应用程序的组件和用户配置。同样，将自定义指令移至单独的类是解决此问题的好方法。<blockquote><p>如果这不是您的选择，则可以在测试层次结构中的某个位置创建<code>@SpringBootConfiguration</code>，以便代替它使用。另外，您可以为测试指定一个源，从而禁用查找默认源的行为。</blockquote><h4 id=3-23-3-24、使用-Spock-测试-Spring-Boot-应用程序><a title="3.23.3.24、使用 Spock 测试 Spring Boot 应用程序" class=headerlink href=#3-23-3-24、使用-Spock-测试-Spring-Boot-应用程序></a>3.23.3.24、使用 Spock 测试 Spring Boot 应用程序</h4><p>如果希望使用 Spock 测试 Spring Boot 应用程序，则应在应用程序的构建中添加对 Spock 的<code>spock-spring</code>模块的依赖。 <code>spock-spring</code>将 Spring 的测试框架集成到 Spock 中。建议您使用 Spock 1.2 或更高版本，以受益于 Spock 的 Spring Framework 和 Spring Boot 集成的许多改进。有关更多详细信息，请参见<a href=http://spockframework.org/spock/docs/1.2/modules.html#_spring_module rel=noopener target=_blank>Spock 的 Spring 模块的文档</a>。<h3 id=3-23-4、测试-Util><a title="3.23.4、测试 Util" class=headerlink href=#3-23-4、测试-Util></a>3.23.4、测试 Util</h3><p>一些测试 Util 类通常在测试您的应用程序时有用，它们被打包为<code>spring-boot</code>的一部分。<h4 id=3-23-4-1、ConfigFileApplicationContextInitializer><a class=headerlink href=#3-23-4-1、ConfigFileApplicationContextInitializer title=3.23.4.1、ConfigFileApplicationContextInitializer></a>3.23.4.1、ConfigFileApplicationContextInitializer</h4><p><code>ConfigFileApplicationContextInitializer</code>是<code>ApplicationContextInitializer</code>，您可以将其应用于测试以加载 Spring Boot <code>application.properties</code>文件。如不需要以下示例所示，可以在不需要<code>@SpringBootTest</code>提供的全部功能时使用它：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta>@ContextConfiguration(classes = Config.class,</span></span><br><span class=line><span class=meta>	initializers = ConfigFileApplicationContextInitializer.class)</span></span><br></pre></table></figure><blockquote><p>单独使用<code>ConfigFileApplicationContextInitializer</code>不支持<code>@Value("${…}")</code>注入。它唯一的工作就是确保将<code>application.properties</code>文件加载到 Spring 的<code>Environment</code>中。为了获得<code>@Value</code>支持，您需要另外配置<code>PropertySourcesPlaceholderConfigurer</code>或使用<code>@SpringBootTest</code>，后者会为您自动配置一个。</blockquote><h4 id=3-23-4-2、TestPropertyValues><a class=headerlink href=#3-23-4-2、TestPropertyValues title=3.23.4.2、TestPropertyValues></a>3.23.4.2、TestPropertyValues</h4><p><code>TestPropertyValues</code>可让您快速将属性添加到<code>ConfigurableEnvironment</code>或<code>ConfigurableApplicationContext</code>。您可以使用<code>key=value</code>字符串来调用它，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>TestPropertyValues.of(<span class=string>"org=Spring"</span>, <span class=string>"name=Boot"</span>).applyTo(env);</span><br></pre></table></figure><h4 id=3-23-4-3、OutputCapture><a class=headerlink href=#3-23-4-3、OutputCapture title=3.23.4.3、OutputCapture></a>3.23.4.3、OutputCapture</h4><p><code>OutputCapture</code>是一个 JUnit <code>Rule</code>，可用于捕获<code>System.out</code>和<code>System.err</code>输出。您可以将捕获声明为<code>@Rule</code>，然后将<code>toString()</code>用于 assert，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.junit.Rule;</span><br><span class=line><span class=keyword>import</span> org.junit.Test;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.test.rule.OutputCapture;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.hamcrest.Matchers.*;</span><br><span class=line><span class=keyword>import</span> <span class=keyword>static</span> org.junit.Assert.*;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyTest</span> {</span><br><span class=line>	<span class=meta>@Rule</span></span><br><span class=line>	<span class=keyword>public</span> <span class=type>OutputCapture</span> <span class=variable>capture</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">OutputCapture</span>();</span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testName</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		System.out.println(<span class=string>"Hello World!"</span>);</span><br><span class=line>		assertThat(capture.toString(), containsString(<span class=string>"World"</span>));</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-23-4-4、TestRestTemplate><a class=headerlink href=#3-23-4-4、TestRestTemplate title=3.23.4.4、TestRestTemplate></a>3.23.4.4、TestRestTemplate</h4><blockquote><p>Spring Framework 5.0 提供了一个新的<code>WebTestClient</code>，它适用于<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-autoconfigured-webflux-tests rel=noopener target=_blank>WebFlux 集成测试</a>和<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-testing.html#boot-features-testing-spring-boot-applications-testing-with-running-server rel=noopener target=_blank>WebFlux 和 MVC 端到端测试</a>。与<code>TestRestTemplate</code>不同，它为声明提供了流畅的 API。</blockquote><p><code>TestRestTemplate</code>是 Spring <code>RestTemplate</code>的便捷替代方法，在集成测试中非常有用。您可以使用普通模板或发送基本 HTTP 身份验证(带有用户名和密码)的模板。在这两种情况下，模板都不会通过在服务器端错误上引发异常来以易于测试的方式运行。建议(但不是强制性的)使用 Apache HTTP Client(版本 4.3.2 或更高版本)。如果您在 Classpath 中具有该名称，则<code>TestRestTemplate</code>会通过适当配置 Client 端进行响应。如果确实使用 Apache 的 HTTP Client 端，则会启用一些其他易于测试的功能：<ul><li>不遵循重定向(因此您可以声明响应位置)。<li>Cookies 被忽略(因此模板是 Stateless 的)。</ul><p><code>TestRestTemplate</code>可以在集成测试中直接实例化，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyTest</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=type>TestRestTemplate</span> <span class=variable>template</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TestRestTemplate</span>();</span><br><span class=line></span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testRequest</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		<span class=type>HttpHeaders</span> <span class=variable>headers</span> <span class=operator>=</span> <span class=built_in>this</span>.template.getForEntity(</span><br><span class=line>				<span class=string>"http://myhost.example.com/example"</span>, String.class).getHeaders();</span><br><span class=line>		assertThat(headers.getLocation()).hasHost(<span class=string>"other.example.com"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>另外，如果您将<code>@SpringBootTest</code>Comments 与<code>WebEnvironment.RANDOM_PORT</code>或<code>WebEnvironment.DEFINED_PORT</code>一起使用，则可以注入已完全配置的<code>TestRestTemplate</code>并开始使用它。如有必要，可以通过<code>RestTemplateBuilder</code> bean 应用其他定制。未指定主机和端口的所有 URL 都会自动连接到嵌入式服务器，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=meta>@RunWith(SpringRunner.class)</span></span><br><span class=line><span class=meta>@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SampleWebClientTests</span> {</span><br><span class=line>	<span class=meta>@Autowired</span></span><br><span class=line>	<span class=keyword>private</span> TestRestTemplate template;</span><br><span class=line>	<span class=meta>@Test</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testRequest</span><span class=params>()</span> {</span><br><span class=line>		<span class=type>HttpHeaders</span> <span class=variable>headers</span> <span class=operator>=</span> <span class=built_in>this</span>.template.getForEntity(<span class=string>"/example"</span>, String.class)</span><br><span class=line>				.getHeaders();</span><br><span class=line>		assertThat(headers.getLocation()).hasHost(<span class=string>"other.example.com"</span>);</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=meta>@TestConfiguration</span></span><br><span class=line>	<span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">Config</span> {</span><br><span class=line></span><br><span class=line>		<span class=meta>@Bean</span></span><br><span class=line>		<span class=keyword>public</span> RestTemplateBuilder <span class="title function_">restTemplateBuilder</span><span class=params>()</span> {</span><br><span class=line>			<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">RestTemplateBuilder</span>().setConnectTimeout(Duration.ofSeconds(<span class=number>1</span>))</span><br><span class=line>					.setReadTimeout(Duration.ofSeconds(<span class=number>1</span>));</span><br><span class=line>		}</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h2 id=3-24、WebSockets><a class=headerlink href=#3-24、WebSockets title=3.24、WebSockets></a>3.24、WebSockets</h2><p>Spring Boot 为嵌入式 Tomcat，Jetty 和 Undertow 提供了 WebSockets 自动配置。如果将 war 文件部署到独立容器，Spring Boot 会假定该容器负责其 WebSocket 支持的配置。<p>Spring Framework 为 MVC Web 应用程序提供了<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web.html#websocket rel=noopener target=_blank>丰富的 WebSocket 支持</a>，可以通过<code>spring-boot-starter-websocket</code>模块轻松访问。<p>WebSocket 支持也可用于<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/web-reactive.html#webflux-websocket rel=noopener target=_blank>响应式 Web 应用程序</a>，并且需要在<code>spring-boot-starter-webflux</code>旁边包括 WebSocket API：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>javax.websocket<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>javax.websocket-api<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><h2 id=3-25、Web-Service><a title="3.25、Web Service" class=headerlink href=#3-25、Web-Service></a>3.25、Web Service</h2><p>Spring Boot 提供了 Web 服务自动配置，因此您所要做的就是定义<code>Endpoints</code>。<p><a href=https://docs.spring.io/spring-ws/docs/3.0.4.RELEASE/reference/ rel=noopener target=_blank>Spring Web Services 功能</a>可以通过<code>spring-boot-starter-webservices</code>模块轻松访问。<p>可以分别为您的 WSDL 和 XSD 自动创建<code>SimpleWsdl11Definition</code>和<code>SimpleXsdSchema</code> bean。为此，请配置其位置，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.webservices.wsdl-locations</span>=<span class=string>classpath:/wsdl</span></span><br></pre></table></figure><h2 id=3-26、使用-WebServiceTemplate-调用-Web-服务><a title="3.26、使用 WebServiceTemplate 调用 Web 服务" class=headerlink href=#3-26、使用-WebServiceTemplate-调用-Web-服务></a>3.26、使用 WebServiceTemplate 调用 Web 服务</h2><p>如果需要从应用程序调用远程 Web 服务，则可以使用<a href=https://docs.spring.io/spring-ws/docs/3.0.4.RELEASE/reference/#client-web-service-template rel=noopener target=_blank>WebServiceTemplate</a>类。由于<code>WebServiceTemplate</code>实例在使用前通常需要自定义，因此 Spring Boot 不提供任何单个自动配置的<code>WebServiceTemplate</code> bean。但是，它会自动配置<code>WebServiceTemplateBuilder</code>，可以在需要时创建<code>WebServiceTemplate</code>实例。<p>以下代码显示了一个典型示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyService</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> WebServiceTemplate webServiceTemplate;</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">MyService</span><span class=params>(WebServiceTemplateBuilder webServiceTemplateBuilder)</span> {</span><br><span class=line>		<span class=built_in>this</span>.webServiceTemplate = webServiceTemplateBuilder.build();</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>	<span class=keyword>public</span> DetailsResp <span class="title function_">someWsCall</span><span class=params>(DetailsReq detailsReq)</span> {</span><br><span class=line>		 <span class=keyword>return</span> (DetailsResp) <span class=built_in>this</span>.webServiceTemplate.marshalSendAndReceive(detailsReq, <span class=keyword>new</span> <span class="title class_">SoapActionCallback</span>(ACTION));</span><br><span class=line></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>默认情况下，<code>WebServiceTemplateBuilder</code>使用 Classpath 上可用的 HTTP Client 端库检测合适的基于 HTTP 的<code>WebServiceMessageSender</code>。您还可以如下自定义读取和连接超时：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> WebServiceTemplate <span class="title function_">webServiceTemplate</span><span class=params>(WebServiceTemplateBuilder builder)</span> {</span><br><span class=line>	<span class=keyword>return</span> builder.messageSenders(<span class=keyword>new</span> <span class="title class_">HttpWebServiceMessageSenderBuilder</span>()</span><br><span class=line>			.setConnectTimeout(<span class=number>5000</span>).setReadTimeout(<span class=number>2000</span>).build()).build();</span><br><span class=line>}</span><br></pre></table></figure><h2 id=3-27、创建自己的自动配置><a class=headerlink href=#3-27、创建自己的自动配置 title=3.27、创建自己的自动配置></a>3.27、创建自己的自动配置</h2><p>如果您在开发共享库的公司中工作，或者在开源或商业库中工作，则可能需要开发自己的自动配置。自动配置类可以 Binding 在外部 jar 中，并且仍由 Spring Boot 拾取。<p>自动配置可以与“启动器”相关联，该“启动器”提供自动配置代码以及您将使用的典型库。我们首先介绍构建自己的自动配置所需的知识，然后 continue 进行<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-auto-configuration.html#boot-features-custom-starter rel=noopener target=_blank>创建自定义启动器所需的典型步骤</a>。<h3 id=3-27-1、了解自动配置的Bean><a class=headerlink href=#3-27-1、了解自动配置的Bean title=3.27.1、了解自动配置的Bean></a>3.27.1、了解自动配置的Bean</h3><p>在后台，自动配置是通过标准的<code>@Configuration</code>类实现的。其他<code>@Conditional</code>Comments 用于约束何时应应用自动配置。通常，自动配置类使用<code>@ConditionalOnClass</code>和<code>@ConditionalOnMissingBean</code>Comments。这样可以确保仅当找到相关的类并且没有声明自己的<code>@Configuration</code>时，自动配置才适用。<p>您可以浏览<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure rel=noopener target=_blank>spring-boot-autoconfigure</a>的源代码以查看 Spring 提供的<code>@Configuration</code>类(请参见<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories rel=noopener target=_blank>META-INF/spring.factories</a>文件)。<h3 id=3-27-2、查找自动配置的候选人><a class=headerlink href=#3-27-2、查找自动配置的候选人 title=3.27.2、查找自动配置的候选人></a>3.27.2、查找自动配置的候选人</h3><p>Spring Boot 检查发布的 jar 中是否存在<code>META-INF/spring.factories</code>文件。该文件应在<code>EnableAutoConfiguration</code>键下列出您的配置类，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class=string>\</span></span><br><span class=line><span class=string>com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\</span></span><br><span class=line><span class=string>com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</span></span><br></pre></table></figure><p>如果需要按特定 Sequences 应用配置，则可以使用<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureAfter.java rel=noopener target=_blank>@AutoConfigureAfter</a>或<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/AutoConfigureBefore.java rel=noopener target=_blank>@AutoConfigureBefore</a>注解。例如，如果您提供特定于 Web 的配置，则可能需要在<code>WebMvcAutoConfiguration</code>之后应用您的类。<p>如果要 Order 某些彼此之间没有直接知识的自动配置，则也可以使用<code>@AutoConfigureOrder</code>。该 Comments 与常规<code>@Order</code>Comments 具有相同的语义，但为自动配置类提供了专用 Sequences。<blockquote><p>自动配置必须以* only *的方式加载。确保在特定的软件包空间中定义了它们，尤其是它们绝不是组件扫描的目标。</blockquote><h3 id=3-27-3、条件Comments><a class=headerlink href=#3-27-3、条件Comments title=3.27.3、条件Comments></a>3.27.3、条件Comments</h3><p>您几乎总是希望在自动配置类中包含一个或多个<code>@Conditional</code>Comments。 <code>@ConditionalOnMissingBean</code>Comments 是一个常见示例，用于使开发人员在对默认设置不满意的情况下覆盖自动配置。<p>Spring Boot 包含许多<code>@Conditional</code>Comments，您可以通过 Comments<code>@Configuration</code>类或单个<code>@Bean</code>方法在自己的代码中重用。这些 Comments 包括：<ul><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-auto-configuration.html#boot-features-class-conditions rel=noopener target=_blank>第 49.3.1 节“类条件”</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-auto-configuration.html#boot-features-bean-conditions rel=noopener target=_blank>第 49.3.2 节“ Bean 条件”</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-auto-configuration.html#boot-features-property-conditions rel=noopener target=_blank>第 49.3.3 节“财产条件”</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-auto-configuration.html#boot-features-resource-conditions rel=noopener target=_blank>第 49.3.4 节“资源条件”</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-auto-configuration.html#boot-features-web-application-conditions rel=noopener target=_blank>第 49.3.5 节“ Web 应用程序条件”</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/boot-features-developing-auto-configuration.html#boot-features-spel-conditions rel=noopener target=_blank>第 49.3.6 节“ SpEL 表达条件”</a></ul><h4 id=3-27-3-1、Class-条件><a title="3.27.3.1、Class 条件" class=headerlink href=#3-27-3-1、Class-条件></a>3.27.3.1、Class 条件</h4><p><code>@ConditionalOnClass</code>和<code>@ConditionalOnMissingClass</code>注解允许根据是否存在特定类来包含配置。由于 Comments 元数据是通过使用<a href=http://asm.ow2.org/ rel=noopener target=_blank>ASM</a>进行解析的，因此即使该类实际上可能未出现在正在运行的应用程序 Classpath 上，您也可以使用<code>value</code>属性来引用真实的类。如果您希望通过使用<code>String</code>值来指定类名，则也可以使用<code>name</code>属性。<blockquote><p>如果您使用<code>@ConditionalOnClass</code>或<code>@ConditionalOnMissingClass</code>作为元 Comments 的一部分来组成自己的组合 Comments，则必须使用<code>name</code>，因为在这种情况下无法引用该类。</blockquote><h4 id=3-27-3-2、Bean-条件><a title="3.27.3.2、Bean 条件" class=headerlink href=#3-27-3-2、Bean-条件></a>3.27.3.2、Bean 条件</h4><p><code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>Comments 根据是否存在特定的 bean 来包含 bean。您可以使用<code>value</code>属性按类型指定 bean，或使用<code>name</code>按名称指定 bean。 <code>search</code>属性使您可以限制搜索 Bean 时应考虑的<code>ApplicationContext</code>层次结构。<p>当放置在<code>@Bean</code>方法上时，目标类型默认为该方法的返回类型，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyAutoConfiguration</span> {</span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=meta>@ConditionalOnMissingBean</span></span><br><span class=line>	<span class=keyword>public</span> MyService <span class="title function_">myService</span><span class=params>()</span> { ... }</span><br><span class=line>}</span><br></pre></table></figure><p>在前面的示例中，如果<code>ApplicationContext</code>中没有包含<code>MyService</code>类型的 bean，则将创建<code>myService</code> bean。<blockquote><p>您需要非常注意添加 bean 定义的 Sequences，因为这些条件是根据到目前为止已处理的内容来评估的。因此，我们建议在自动配置类上仅使用<code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>Comments(因为保证在添加任何用户定义的 Bean 定义后即可加载这些 Comments)。<p><code>@ConditionalOnBean</code>和<code>@ConditionalOnMissingBean</code>不会阻止<code>@Configuration</code>类的创建。在类级别使用这些条件与使用 Comments 标记每个包含的<code>@Bean</code>方法之间的唯一区别是，如果条件不匹配，则前者会阻止<code>@Configuration</code>类注册为 bean。</blockquote><h4 id=3-27-3-3、财产条件><a class=headerlink href=#3-27-3-3、财产条件 title=3.27.3.3、财产条件></a>3.27.3.3、财产条件</h4><p><code>@ConditionalOnProperty</code>Comments 允许基于 Spring Environment 属性包含配置。使用<code>prefix</code>和<code>name</code>属性来指定应检查的属性。默认情况下，匹配存在且不等于<code>false</code>的任何属性。您还可以使用<code>havingValue</code>和<code>matchIfMissing</code>属性创建更高级的检查。<h4 id=3-27-3-4、资源条件><a class=headerlink href=#3-27-3-4、资源条件 title=3.27.3.4、资源条件></a>3.27.3.4、资源条件</h4><p><code>@ConditionalOnResource</code>Comments 仅在存在特定资源时才包括配置。可以使用通常的 Spring 约定来指定资源，如以下示例所示：<code>file:/home/user/test.dat</code>。<h4 id=3-27-3-5、Web-应用程序条件><a title="3.27.3.5、Web 应用程序条件" class=headerlink href=#3-27-3-5、Web-应用程序条件></a>3.27.3.5、Web 应用程序条件</h4><p>根据应用程序是否为“ Web 应用程序”，可以使用<code>@ConditionalOnWebApplication</code>和<code>@ConditionalOnNotWebApplication</code>注解包含配置。 Web 应用程序是使用 Spring <code>WebApplicationContext</code>，定义<code>session</code>范围或具有<code>StandardServletEnvironment</code>的任何应用程序。<h4 id=3-27-3-6、SpEL-表达条件><a title="3.27.3.6、SpEL 表达条件" class=headerlink href=#3-27-3-6、SpEL-表达条件></a>3.27.3.6、SpEL 表达条件</h4><p><code>@ConditionalOnExpression</code>注解允许基于<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/core.html#expressions rel=noopener target=_blank>SpEL expression</a>的结果包括配置。<h3 id=3-27-4、测试您的自动配置><a class=headerlink href=#3-27-4、测试您的自动配置 title=3.27.4、测试您的自动配置></a>3.27.4、测试您的自动配置</h3><p>自动配置可能受许多因素影响：用户配置(<code>@Bean</code>定义和<code>Environment</code>定制)，条件评估(特定库的存在)和其他因素。具体而言，每个测试都应创建定义良好的<code>ApplicationContext</code>，以表示这些自定义项的组合。 <code>ApplicationContextRunner</code>提供了一种实现此目标的好方法。<p><code>ApplicationContextRunner</code>通常定义为测试类的一个字段，用于收集基本的通用配置。下面的示例确保始终调用<code>UserServiceAutoConfiguration</code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=keyword>final</span> <span class=type>ApplicationContextRunner</span> <span class=variable>contextRunner</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ApplicationContextRunner</span>()</span><br><span class=line>.withConfiguration(AutoConfigurations.of(UserServiceAutoConfiguration.class));</span><br></pre></table></figure><blockquote><p>如果必须定义多个自动配置，则无需按与运行应用程序时完全相同的 Sequences 调用它们的声明。</blockquote><p>每个测试都可以使用运行器来表示特定的用例。例如，下面的示例调用一个用户配置(<code>UserConfiguration</code>)，并检查自动配置是否正确退出。调用<code>run</code>提供了可与<code>Assert4J</code>一起使用的回调上下文。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">defaultServiceBacksOff</span><span class=params>()</span> {</span><br><span class=line>	<span class=built_in>this</span>.contextRunner.withUserConfiguration(UserConfiguration.class)</span><br><span class=line>			.run((context) -> {</span><br><span class=line>				assertThat(context).hasSingleBean(UserService.class);</span><br><span class=line>				assertThat(context.getBean(UserService.class)).isSameAs(</span><br><span class=line>						context.getBean(UserConfiguration.class).myUserService());</span><br><span class=line>			});</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">UserConfiguration</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@Bean</span></span><br><span class=line>	<span class=keyword>public</span> UserService <span class="title function_">myUserService</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">UserService</span>(<span class=string>"mine"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>还可以轻松自定义<code>Environment</code>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">serviceNameCanBeConfigured</span><span class=params>()</span> {</span><br><span class=line>	<span class=built_in>this</span>.contextRunner.withPropertyValues(<span class=string>"user.name=test123"</span>).run((context) -> {</span><br><span class=line>		assertThat(context).hasSingleBean(UserService.class);</span><br><span class=line>		assertThat(context.getBean(UserService.class).getName()).isEqualTo(<span class=string>"test123"</span>);</span><br><span class=line>	});</span><br><span class=line>}</span><br></pre></table></figure><p>Running 者也可以用来显示<code>ConditionEvaluationReport</code>。该报告可以<code>INFO</code>或<code>DEBUG</code>级别打印。以下示例显示如何在自动配置测试中使用<code>ConditionEvaluationReportLoggingListener</code>打印报告。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> autoConfigTest {</span><br><span class=line>	<span class=type>ConditionEvaluationReportLoggingListener</span> <span class=variable>initializer</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ConditionEvaluationReportLoggingListener</span>(</span><br><span class=line>			LogLevel.INFO);</span><br><span class=line>	<span class=type>ApplicationContextRunner</span> <span class=variable>contextRunner</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ApplicationContextRunner</span>()</span><br><span class=line>			.withInitializer(initializer).run((context) -> {</span><br><span class=line>					<span class=comment>// Do something...</span></span><br><span class=line>			});</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-27-4-1、模拟网络环境><a class=headerlink href=#3-27-4-1、模拟网络环境 title=3.27.4.1、模拟网络环境></a>3.27.4.1、模拟网络环境</h4><p>如果您需要测试仅在 Servlet 或 Reactive Web 应用程序上下文中运行的自动配置，请分别使用<code>WebApplicationContextRunner</code>或<code>ReactiveWebApplicationContextRunner</code>。<h4 id=3-27-4-2、覆盖Classpath><a class=headerlink href=#3-27-4-2、覆盖Classpath title=3.27.4.2、覆盖Classpath></a>3.27.4.2、覆盖Classpath</h4><p>还可以测试在运行时不存在特定的类和/或程序包时发生的情况。 Spring Boot 附带<code>FilteredClassLoader</code>，Running 者可以轻松使用。在以下示例中，我们 assert 如果不存在<code>UserService</code>，则会自动禁用自动配置：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">serviceIsIgnoredIfLibraryIsNotPresent</span><span class=params>()</span> {</span><br><span class=line>	<span class=built_in>this</span>.contextRunner.withClassLoader(<span class=keyword>new</span> <span class="title class_">FilteredClassLoader</span>(UserService.class))</span><br><span class=line>			.run((context) -> assertThat(context).doesNotHaveBean(<span class=string>"userService"</span>));</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-27-5、创建自己的启动器><a class=headerlink href=#3-27-5、创建自己的启动器 title=3.27.5、创建自己的启动器></a>3.27.5、创建自己的启动器</h3><p>库的完整 Spring BootStarter 程序可能包含以下组件：<ul><li>包含自动配置代码的<code>autoconfigure</code>模块。<li><code>starter</code>模块提供对<code>autoconfigure</code>模块以及库的依赖关系，以及通常有用的任何其他依赖关系。简而言之，添加启动程序应提供开始使用该库所需的一切。</ul><h4 id=3-27-5-1、Naming><a class=headerlink href=#3-27-5-1、Naming title=3.27.5.1、Naming></a>3.27.5.1、Naming</h4><p>您应该确保为启动器提供适当的名称空间。即使您使用其他 Maven <code>groupId</code>，也不要以<code>spring-boot</code>开头模块名称。将来，我们可能会为您自动配置的内容提供官方支持。<p>根据经验，您应该在启动器后命名一个组合模块。例如，假设您要为“ acme”创建启动程序，并且将自动配置模块命名为<code>acme-spring-boot-autoconfigure</code>，而启动程序则命名为<code>acme-spring-boot-starter</code>。如果只有一个将两者结合的模块，请将其命名为<code>acme-spring-boot-starter</code>。<p>另外，如果您的 Starter 者提供了配置密钥，请为其使用唯一的名称空间。特别是，不要在 Spring Boot 使用的名称空间中包含您的密钥(例如<code>server</code>，<code>management</code>，<code>spring</code>等)。如果使用相同的名称空间，将来我们可能会以破坏模块的方式修改这些名称空间。<p>确保<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/configuration-metadata.html#configuration-metadata-annotation-processor rel=noopener target=_blank>触发元数据生成</a>，以便您的按键也可以使用 IDE 协助。您可能需要查看生成的元数据(<code>META-INF/spring-configuration-metadata.json</code>)，以确保正确记录了您的密钥。<h4 id=3-27-5-2、自动配置模块><a class=headerlink href=#3-27-5-2、自动配置模块 title=3.27.5.2、自动配置模块></a>3.27.5.2、自动配置模块</h4><p><code>autoconfigure</code>模块包含开始使用该库所需的所有内容。它还可能包含配置键定义(例如<code>@ConfigurationProperties</code>)和可用于进一步自定义组件初始化方式的任何回调接口。<blockquote><p>您应该将对库的依赖关系标记为可选，以便可以更轻松地在项目中包含<code>autoconfigure</code>模块。如果这样做，则不提供该库，并且默认情况下，Spring Boot 会后退。</blockquote><p>Spring Boot 使用 Comments 处理器来收集元数据文件(<code>META-INF/spring-autoconfigure-metadata.properties</code>)中自动配置的条件。如果存在该文件，它将用于急切过滤不匹配的自动配置，这将缩短启动时间。建议在包含自动配置的模块中添加以下依赖项：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>spring-boot-autoconfigure-processor<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>optional</span>></span>true<span class=tag>&LT/<span class=name>optional</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><p>对于 Gradle 4.5 及更早版本，依赖关系应在<code>compileOnly</code>配置中声明，如以下示例所示：<figure class="highlight groovy"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>dependencies {</span><br><span class=line>	compileOnly <span class=string>"org.springframework.boot:spring-boot-autoconfigure-processor"</span></span><br><span class=line>}</span><br></pre></table></figure><p>在 Gradle 4.6 及更高版本中，依赖性应在<code>annotationProcessor</code>配置中声明，如以下示例所示：<figure class="highlight groovy"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>dependencies {</span><br><span class=line>	annotationProcessor <span class=string>"org.springframework.boot:spring-boot-autoconfigure-processor"</span></span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-27-5-3、Starter模块><a class=headerlink href=#3-27-5-3、Starter模块 title=3.27.5.3、Starter模块></a>3.27.5.3、Starter模块</h4><p>起动器确实是一个空Jar子。其唯一目的是提供必要的依赖关系以使用库。您可以将其视为对 Starter 所需的看法。<p>不要对添加了启动器的项目做任何假设。如果您要自动配置的库通常需要其他启动器，请同时提及它们。如果可选依赖项的数量很高，则提供一组适当的* default *依赖项可能会很困难，因为您应避免包括对于库的典型用法而言不必要的依赖项。换句话说，您不应包括可选的依赖项。<blockquote><p>无论哪种方式，您的启动程序都必须直接或间接引用核心 Spring Boot 启动程序(<code>spring-boot-starter</code>)(即，如果您的启动程序依赖于另一个启动程序，则无需添加它)。如果仅使用您的自定义启动器创建项目，则通过使用该核心启动器来兑现 Spring Boot 的核心功能。</blockquote><h2 id=3-28、Kotlin-support><a title="3.28、Kotlin support" class=headerlink href=#3-28、Kotlin-support></a>3.28、Kotlin support</h2><p><a href=https://kotlinlang.org/ rel=noopener target=_blank>Kotlin</a>是针对 JVM(和其他平台)的静态类型的语言，它允许编写简洁明了的代码，同时为<a href=https://kotlinlang.org/docs/reference/java-interop.html rel=noopener target=_blank>interoperability</a>提供以 Java 编写的现有库。<p>Spring Boot 通过利用其他 Spring 项目(例如 Spring Framework，Spring Data 和 Reactor)中的支持来提供 Kotlin 支持。有关更多信息，请参见<a href=https://docs.spring.io/spring/docs/5.1.3.RELEASE/spring-framework-reference/languages.html#kotlin rel=noopener target=_blank>Spring Framework Kotlin 支持文档</a>。<p>从 Spring Boot 和 Kotlin 开始的最简单方法是遵循<a href=https://spring.io/guides/tutorials/spring-boot-kotlin/ rel=noopener target=_blank>本综合教程</a>。您可以通过<a href=https://start.spring.io/#!language=kotlin rel=noopener target=_blank>start.spring.io</a>创建新的 Kotlin 项目。如果需要支持，可以随时加入<a href=http://slack.kotlinlang.org/ rel=noopener target=_blank>Kotlin Slack</a>的#spring Channels，或在<a href=https://stackoverflow.com/questions/tagged/spring+kotlin rel=noopener target=_blank>Stack Overflow</a>上使用<code>spring</code>和<code>kotlin</code>标签询问问题。<h3 id=3-28-1、Requirements><a class=headerlink href=#3-28-1、Requirements title=3.28.1、Requirements></a>3.28.1、Requirements</h3><p>Spring Boot 支持 Kotlin1.2.x。要使用 Kotlin，Classpath 上必须存在<code>org.jetbrains.kotlin:kotlin-stdlib</code>和<code>org.jetbrains.kotlin:kotlin-reflect</code>。也可以使用<code>kotlin-stdlib</code>变体<code>kotlin-stdlib-jdk7</code>和<code>kotlin-stdlib-jdk8</code>。<p>从<a href=https://discuss.kotlinlang.org/t/classes-final-by-default/166 rel=noopener target=_blank>Kotlin 类默认为 final</a>开始，您可能需要配置<a href=https://kotlinlang.org/docs/reference/compiler-plugins.html#spring-support rel=noopener target=_blank>kotlin-spring</a>插件，以便自动打开带有 Spring Comments 的类，以便对其进行代理。<p>在 Kotlin 中序列化/反序列化 JSON 数据需要<a href=https://github.com/FasterXML/jackson-module-kotlin rel=noopener target=_blank>Jackson 的 Kotlin 模块</a>。在 Classpath 上找到它会自动注册。如果存在 Jackson 和 Kotlin 但不存在 Jackson Kotlin 模块，则会记录一条警告消息。<blockquote><p>如果一个人在<a href=https://start.spring.io/#!language=kotlin rel=noopener target=_blank>start.spring.io</a>上引导 Kotlin 项目，则默认情况下会提供这些依赖项和插件。</blockquote><h3 id=3-28-2、Null-safety><a class=headerlink href=#3-28-2、Null-safety title=3.28.2、Null-safety></a>3.28.2、Null-safety</h3><p>Kotlin 的主要功能之一是<a href=https://kotlinlang.org/docs/reference/null-safety.html rel=noopener target=_blank>null-safety</a>。它在编译时处理<code>null</code>值，而不是将问题推迟到运行时并遇到<code>NullPointerException</code>。这有助于消除常见的错误源，而无需支付<code>Optional</code>之类的包装器的费用。 Kotlin 还允许使用具有可空值的函数构造，如<a href=http://www.baeldung.com/kotlin-null-safety rel=noopener target=_blank>Kotlin 空安全综合指南</a>中所述。<p>尽管 Java 不允许人在其类型系统中表示空安全性，但 Spring Framework，Spring Data 和 Reactor 现在通过易于使用工具的注解为 API 提供了空安全性。默认情况下，Kotlin 中使用的 Java API 中的类型被识别为<a href=https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types rel=noopener target=_blank>platform types</a>，对此类型的空检查得到了放宽。 <a href=https://kotlinlang.org/docs/reference/java-interop.html#jsr-305-support rel=noopener target=_blank>Kotlin 对 JSR 305 注解的支持</a>与可空性 Comments 结合使用，为 Kotlin 中的相关 Spring API 提供了空安全性。<p>可以通过添加带有以下选项的<code>-Xjsr305</code>编译器标志来配置 JSR 305 检查：<code>-Xjsr305={strict|warn|ignore}</code>。默认行为与<code>-Xjsr305=warn</code>相同。必须使用<code>strict</code>值来考虑从 Spring API 推断出的 Kotlin 类型的空安全性，但应使用该知识，即使 Spring API 的空性声明即使在次要发行版之间也可能会演变，并且将来可能会添加更多检查，这一点应得到使用。<blockquote><p>尚不支持泛型类型参数，varargs 和数组元素的可空性。有关最新信息，请参见<a href=https://jira.spring.io/browse/SPR-15942 rel=noopener target=_blank>SPR-15942</a>。另外请注意，Spring Boot 自己的 API 是<a href=https://github.com/spring-projects/spring-boot/issues/10712 rel=noopener target=_blank>尚未 Comments</a>。</blockquote><h3 id=3-28-3、Kotlin-API><a title="3.28.3、Kotlin API" class=headerlink href=#3-28-3、Kotlin-API></a>3.28.3、Kotlin API</h3><h4 id=3-28-3-1、runApplication><a class=headerlink href=#3-28-3-1、runApplication title=3.28.3.1、runApplication></a>3.28.3.1、runApplication</h4><p>Spring Boot 提供了一种惯用的方式来使用<code>runApplication&LTMyApplication>(*args)</code>运行应用程序，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.boot.autoconfigure.SpringBootApplication</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.runApplication</span><br><span class=line></span><br><span class=line><span class=meta>@SpringBootApplication</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">MyApplication</span></span><br><span class=line></span><br><span class=line>fun <span class="title function_">main</span><span class=params>(args: Array&LTString>)</span> {</span><br><span class=line>	runApplication&LTMyApplication>(*args)</span><br><span class=line>}</span><br></pre></table></figure><p>这是<code>SpringApplication.run(MyApplication::class.java, *args)</code>的直接替代。它还允许自定义应用程序，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>runApplication&LTMyApplication>(*args) {</span><br><span class=line>	setBannerMode(OFF)</span><br><span class=line>}</span><br></pre></table></figure><h4 id=3-28-3-2、Extensions><a class=headerlink href=#3-28-3-2、Extensions title=3.28.3.2、Extensions></a>3.28.3.2、Extensions</h4><p>Kotlin <a href=https://kotlinlang.org/docs/reference/extensions.html rel=noopener target=_blank>extensions</a>提供了使用其他功能扩展现有类的功能。 Spring Boot Kotlin API 利用这些扩展为现有 API 添加了新的 Kotlin 专用便利。<p>提供了<code>TestRestTemplate</code>extensions，类似于 Spring Framework 为<code>RestOperations</code>在 Spring Framework 中提供的 extensions。除其他事项外，这些扩展使利用 Kotlin 修饰类型参数成为可能。<h3 id=3-28-4、依赖性-Management><a title="3.28.4、依赖性 Management" class=headerlink href=#3-28-4、依赖性-Management></a>3.28.4、依赖性 Management</h3><p>为了避免在 Classpath 上混合使用不同版本的 Kotlin 依赖项，提供了以下 Kotlin 依赖项的依赖项 Management：<ul><li><code>kotlin-reflect</code><li><code>kotlin-runtime</code><li><code>kotlin-stdlib</code><li><code>kotlin-stdlib-jdk7</code><li><code>kotlin-stdlib-jdk8</code><li><code>kotlin-stdlib-jre7</code><li><code>kotlin-stdlib-jre8</code></ul><p>使用 Maven，可以通过<code>kotlin.version</code>属性自定义 Kotlin 版本，并为<code>kotlin-maven-plugin</code>提供插件 Management。使用 Gradle，Spring Boot 插件会自动将<code>kotlin.version</code>与 Kotlin 插件的版本对齐。<h3 id=3-28-5、-ConfigurationProperties><a class=headerlink href=#3-28-5、-ConfigurationProperties title=3.28.5、@ConfigurationProperties></a>3.28.5、@ConfigurationProperties</h3><p><code>@ConfigurationProperties</code>目前仅适用于<code>lateinit</code>或可为空的<code>var</code>属性(建议使用前者)，因为构造函数初始化的不可变类为<a href=https://github.com/spring-projects/spring-boot/issues/8762 rel=noopener target=_blank>尚不支持</a>。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>@ConfigurationProperties("example.kotlin")</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">KotlinExampleProperties</span> {</span><br><span class=line>	lateinit <span class=keyword>var</span> name: String</span><br><span class=line>	lateinit <span class=keyword>var</span> description: String</span><br><span class=line>	<span class=type>val</span> <span class=variable>myService</span> <span class=operator>=</span> MyService()</span><br><span class=line></span><br><span class=line>	<span class=keyword>class</span> <span class="title class_">MyService</span> {</span><br><span class=line>		lateinit <span class=keyword>var</span> apiToken: String</span><br><span class=line>		lateinit <span class=keyword>var</span> uri: URI</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>要使用 Comments 处理器生成<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/configuration-metadata.html#configuration-metadata-annotation-processor rel=noopener target=_blank>您自己的元数据</a>，具有<code>spring-boot-configuration-processor</code>依赖性的<a href=https://kotlinlang.org/docs/reference/kapt.html rel=noopener target=_blank>kapt 应该配置</a>。</blockquote><h3 id=3-28-6、Testing><a class=headerlink href=#3-28-6、Testing title=3.28.6、Testing></a>3.28.6、Testing</h3><p>虽然可以使用 JUnit 4(由<code>spring-boot-starter-test</code>提供的默认值)来测试 Kotlin 代码，但建议使用 JUnit 5. JUnit 5 使一个测试类可以实例化一次，并可以重新用于该类的所有测试。这样就可以在非静态方法上使用<code>@BeforeAll</code>和<code>@AfterAll</code>注解，这非常适合 Kotlin。<p>要使用 JUnit 5，请从<code>spring-boot-starter-test</code>中排除<code>junit:junit</code>依赖性，添加 JUnit 5 依赖性，并相应地配置 Maven 或 Gradle 插件。有关更多详细信息，请参见<a href=https://junit.org/junit5/docs/current/user-guide/#dependency-metadata-junit-jupiter-samples rel=noopener target=_blank>JUnit 5 文档</a>。您还需要<a href=https://junit.org/junit5/docs/current/user-guide/#writing-tests-test-instance-lifecycle-changing-default rel=noopener target=_blank>将测试实例生命周期切换为“每个类”</a>。<h3 id=3-28-7、Resources><a class=headerlink href=#3-28-7、Resources title=3.28.7、Resources></a>3.28.7、Resources</h3><h4 id=3-28-7-1、进一步阅读><a class=headerlink href=#3-28-7-1、进一步阅读 title=3.28.7.1、进一步阅读></a>3.28.7.1、进一步阅读</h4><ul><li><a href=https://kotlinlang.org/docs/reference/ rel=noopener target=_blank>Kotlin 语言参考</a><li><a href=http://slack.kotlinlang.org/ rel=noopener target=_blank>Kotlin Slack</a>(带有专用的#spring Channels)<li><a href=https://stackoverflow.com/questions/tagged/spring+kotlin rel=noopener target=_blank>具有 Spring 和 Kotlin 标签的 Stackoverflow</a><li><a href=https://try.kotlinlang.org/ rel=noopener target=_blank>在浏览器中尝试 Kotlin</a><li><a href=https://blog.jetbrains.com/kotlin/ rel=noopener target=_blank>Kotlin blog</a><li><a href=https://kotlin.link/ rel=noopener target=_blank>Awesome Kotlin</a><li><a href=https://spring.io/guides/tutorials/spring-boot-kotlin/ rel=noopener target=_blank>教程：使用 Spring Boot 和 Kotlin 构建 Web 应用程序</a><li><a href=https://spring.io/blog/2016/02/15/developing-spring-boot-applications-with-kotlin rel=noopener target=_blank>使用 Kotlin 开发 Spring Boot 应用程序</a><li><a href=https://spring.io/blog/2016/03/20/a-geospatial-messenger-with-kotlin-spring-boot-and-postgresql rel=noopener target=_blank>带有 Kotlin，Spring Boot 和 PostgreSQL 的地理空间 Messenger</a><li><a href=https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0 rel=noopener target=_blank>在 Spring Framework 5.0 中引入 Kotlin 支持</a><li><a href=https://spring.io/blog/2017/08/01/spring-framework-5-kotlin-apis-the-functional-way rel=noopener target=_blank>Spring Framework 5 Kotlin API 的功能方式</a></ul><h4 id=3-28-7-2、Examples><a class=headerlink href=#3-28-7-2、Examples title=3.28.7.2、Examples></a>3.28.7.2、Examples</h4><ul><li><a href=https://github.com/sdeleuze/spring-boot-kotlin-demo rel=noopener target=_blank>spring-boot-kotlin-demo</a>：常规 Spring Boot Spring Data JPA 项目<li><a href=https://github.com/mixitconf/mixit rel=noopener target=_blank>mixit</a>：Spring Boot 2 WebFlux Reactive Spring Data MongoDB<li><a href=https://github.com/sdeleuze/spring-kotlin-fullstack rel=noopener target=_blank>spring-kotlin-fullstack</a>：WebFlux Kotlin 全栈示例，其中 Kotlin2js 用于前端，而不是 JavaScript 或 TypeScript<li><a href=https://github.com/spring-petclinic/spring-petclinic-kotlin rel=noopener target=_blank>spring-petclinic-kotlin</a>：Spring PetClinic 示例应用程序的 Kotlin 版本<li><a href=https://github.com/sdeleuze/spring-kotlin-deepdive rel=noopener target=_blank>spring-kotlin-deepdive</a>：从 Boot 1.0 Java 到 Boot 2.0 Kotlin 的逐步迁移</ul><h1 id=4、Spring-Boot-Actuator><a title="4、Spring Boot Actuator" class=headerlink href=#4、Spring-Boot-Actuator></a>4、Spring Boot Actuator</h1><p>Spring Boot 包含许多附加功能，可在您将应用程序投入生产时帮助您监视和 Management 应用程序。您可以选择使用 HTTP 端点或 JMX Management 和监视您的应用程序。审核，运行状况和 Metrics 收集也可以自动应用于您的应用程序。<h2 id=4-1、启用生产就绪功能><a class=headerlink href=#4-1、启用生产就绪功能 title=4.1、启用生产就绪功能></a>4.1、启用生产就绪功能</h2><p><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator rel=noopener target=_blank>spring-boot-actuator</a>模块提供了 Spring Boot 生产就绪的所有功能。启用功能的最简单方法是将依赖项添加到<code>spring-boot-starter-actuator</code>‘Starter’。<blockquote><p>致动器是制造术语，是指用于移动或控制某些物体的机械设备。Actuator 可以通过很小的变化产生大量的运动。</blockquote><p>要将 Actuator 添加到基于 Maven 的项目中，请添加以下“ Starter”依赖项：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>	<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>		<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>		<span class=tag><<span class=name>artifactId</span>></span>spring-boot-starter-actuator<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencies</span>></span></span><br></pre></table></figure><p>对于 Gradle，使用以下声明：<figure class="highlight groovy"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>dependencies {</span><br><span class=line>	compile(<span class=string>"org.springframework.boot:spring-boot-starter-actuator"</span>)</span><br><span class=line>}</span><br></pre></table></figure><h2 id=4-2、Endpoints><a class=headerlink href=#4-2、Endpoints title=4.2、Endpoints></a>4.2、Endpoints</h2><p>Actuator 端点使您可以监视应用程序并与之交互。 Spring Boot 包含许多内置端点，可让您添加自己的端点。例如，<code>health</code>端点提供基本的应用程序运行状况信息。<p>每个端点可以是<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-endpoints.html#production-ready-endpoints-enabling-endpoints rel=noopener target=_blank>启用或禁用</a>。这控制了是否创建了端点以及它的 bean 在应用程序上下文中是否存在。要远程访问，端点也必须是<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-endpoints.html#production-ready-endpoints-exposing-endpoints rel=noopener target=_blank>通过 JMX 或 HTTP 公开</a>。大多数应用程序选择 HTTP，其中终结点的 ID 和前缀<code>/actuator</code>Map 到 URL。例如，默认情况下，<code>health</code>端点 Map 到<code>/actuator/health</code>。<p>可以使用以下与技术无关的端点：<table><thead><tr><th>ID<th>Description<th>默认启用<tbody><tr><td><code>auditevents</code><td>公开当前应用程序的审核事件信息。<td>Yes<tr><td><code>beans</code><td>显示应用程序中所有 Spring Bean 的完整列表。<td>Yes<tr><td><code>caches</code><td>公开可用的缓存。<td>Yes<tr><td><code>conditions</code><td>显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因。<td>Yes<tr><td><code>configprops</code><td>显示所有<code>@ConfigurationProperties</code>的整理列表。<td>Yes<tr><td><code>env</code><td>从 Spring 的<code>ConfigurableEnvironment</code>公开属性。<td>Yes<tr><td><code>flyway</code><td>显示已应用的所有 Flyway 数据库迁移。<td>Yes<tr><td><code>health</code><td>显示应用程序运行状况信息。<td>Yes<tr><td><code>httptrace</code><td>显示 HTTP 跟踪信息(默认情况下，最近 100 个 HTTP 请求-响应交换)。<td>Yes<tr><td><code>info</code><td>显示任意应用程序信息。<td>Yes<tr><td><code>integrationgraph</code><td>显示 Spring Integration 图。<td>Yes<tr><td><code>loggers</code><td>显示和修改应用程序中 Logger 的配置。<td>Yes<tr><td><code>liquibase</code><td>显示已应用的所有 Liquibase 数据库迁移。<td>Yes<tr><td><code>metrics</code><td>显示当前应用程序的“Metrics”信息。<td>Yes<tr><td><code>mappings</code><td>显示所有<code>@RequestMapping</code>路径的整理列表。<td>Yes<tr><td><code>scheduledtasks</code><td>显示应用程序中的计划任务。<td>Yes<tr><td><code>sessions</code><td>允许从 Spring Session 支持的会话存储中检索和删除用户会话。使用 Spring Session 对反应式 Web 应用程序的支持时不可用。<td>Yes<tr><td><code>shutdown</code><td>使应用程序正常关闭。<td>No<tr><td><code>threaddump</code><td>执行线程转储。<td>Yes</table><p>如果您的应用程序是 Web 应用程序(Spring MVC，Spring WebFlux 或 Jersey)，则可以使用以下附加端点：<table><thead><tr><th>ID<th>Description<th>默认启用<tbody><tr><td><code>heapdump</code><td>返回一个<code>hprof</code>堆转储文件。<td>Yes<tr><td><code>jolokia</code><td>通过 HTTP 公开 JMX bean(当 Jolokia 在 Classpath 上时，不适用于 WebFlux)。<td>Yes<tr><td><code>logfile</code><td>返回日志文件的内容(如果已设置<code>logging.file</code>或<code>logging.path</code>属性)。支持使用 HTTP <code>Range</code>Headers 来检索部分日志文件的内容。<td>Yes<tr><td><code>prometheus</code><td>以 Prometheus 服务器可以抓取的格式公开 Metrics。<td>Yes</table><p>要了解有关 Actuator 端点及其请求和响应格式的更多信息，请参阅单独的 API 文档(<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/actuator-api//html rel=noopener target=_blank>HTML</a>或<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/actuator-api//pdf/spring-boot-actuator-web-api.pdf rel=noopener target=_blank>PDF</a>)。<h3 id=4-2-1、启用端点><a class=headerlink href=#4-2-1、启用端点 title=4.2.1、启用端点></a>4.2.1、启用端点</h3><p>默认情况下，除<code>shutdown</code>之外的所有端点均处于启用状态。要配置端点的启用，请使用其<code>management.endpoint.&LTid>.enabled</code>属性。以下示例启用<code>shutdown</code>端点：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoint.shutdown.enabled</span>=<span class=string>true</span></span><br></pre></table></figure><p>如果您宁愿选择启用端点启用而不是选择退出，请将<code>management.endpoints.enabled-by-default</code>属性设置为<code>false</code>并使用单个端点<code>enabled</code>属性选择重新加入。以下示例启用<code>info</code>端点并禁用所有其他端点：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoints.enabled-by-default</span>=<span class=string>false</span></span><br><span class=line><span class=attr>management.endpoint.info.enabled</span>=<span class=string>true</span></span><br></pre></table></figure><h3 id=4-2-2、公开端点><a class=headerlink href=#4-2-2、公开端点 title=4.2.2、公开端点></a>4.2.2、公开端点</h3><p>由于端点可能包含敏感信息，因此应谨慎考虑何时公开它们。下表显示了内置端点的默认暴露：<table><thead><tr><th>ID<th>JMX<th>Web<tbody><tr><td><code>auditevents</code><td>Yes<td>No<tr><td><code>beans</code><td>Yes<td>No<tr><td><code>caches</code><td>Yes<td>No<tr><td><code>conditions</code><td>Yes<td>No<tr><td><code>configprops</code><td>Yes<td>No<tr><td><code>env</code><td>Yes<td>No<tr><td><code>flyway</code><td>Yes<td>No<tr><td><code>health</code><td>Yes<td>Yes<tr><td><code>heapdump</code><td>N/A<td>No<tr><td><code>httptrace</code><td>Yes<td>No<tr><td><code>info</code><td>Yes<td>Yes<tr><td><code>integrationgraph</code><td>Yes<td>No<tr><td><code>jolokia</code><td>N/A<td>No<tr><td><code>logfile</code><td>N/A<td>No<tr><td><code>loggers</code><td>Yes<td>No<tr><td><code>liquibase</code><td>Yes<td>No<tr><td><code>metrics</code><td>Yes<td>No<tr><td><code>mappings</code><td>Yes<td>No<tr><td><code>prometheus</code><td>N/A<td>No<tr><td><code>scheduledtasks</code><td>Yes<td>No<tr><td><code>sessions</code><td>Yes<td>No<tr><td><code>shutdown</code><td>Yes<td>No<tr><td><code>threaddump</code><td>Yes<td>No</table><p>要更改公开哪些端点，请使用以下特定于技术的<code>include</code>和<code>exclude</code>属性：<table><thead><tr><th>Property<th>Default<tbody><tr><td><code>management.endpoints.jmx.exposure.exclude</code><td><tr><td><code>management.endpoints.jmx.exposure.include</code><td><code>*</code><tr><td><code>management.endpoints.web.exposure.exclude</code><td><tr><td><code>management.endpoints.web.exposure.include</code><td><code>info, health</code></table><p><code>include</code>属性列出了公开的端点的 ID。 <code>exclude</code>属性列出了不应公开的端点的 ID。 <code>exclude</code>属性优先于<code>include</code>属性。 <code>include</code>和<code>exclude</code>属性都可以使用端点 ID 列表进行配置。<p>例如，要停止通过 JMX 公开所有端点，而仅公开<code>health</code>和<code>info</code>端点，请使用以下属性：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoints.jmx.exposure.include</span>=<span class=string>health,info</span></span><br></pre></table></figure><p><code>*</code>可用于选择所有端点。例如，要通过 HTTP 公开除<code>env</code>和<code>beans</code>端点之外的所有内容，请使用以下属性：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoints.web.exposure.include</span>=<span class=string>*</span></span><br><span class=line><span class=attr>management.endpoints.web.exposure.exclude</span>=<span class=string>env,beans</span></span><br></pre></table></figure><blockquote><p><code>*</code>在 YAML 中具有特殊含义，因此，如果要包括(或排除)所有端点，请确保添加引号，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>management:</span><br><span class=line>endpoints:</span><br><span class=line>web:</span><br><span class=line>exposure:</span><br><span class=line>include: "*"</span><br></pre></table></figure><p>如果您的申请公开公开，我们强烈建议您也<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-endpoints.html#production-ready-endpoints-security rel=noopener target=_blank>保护您的端点</a>。<p>如果要针对暴露端点的时间实施自己的策略，则可以注册<code>EndpointFilter</code> bean。</blockquote><h3 id=4-2-3、保护HTTP端点><a class=headerlink href=#4-2-3、保护HTTP端点 title=4.2.3、保护HTTP端点></a>4.2.3、保护HTTP端点</h3><p>您应该像对待其他任何敏感 URL 一样，小心保护 HTTP 端点的安全。如果存在 Spring Security，则默认情况下使用 Spring Security 的内容协商策略保护端点的安全。例如，如果您希望为 HTTP 端点配置自定义安全性，只允许具有特定角色的用户访问它们，Spring Boot 提供了一些方便的<code>RequestMatcher</code>对象，可以将它们与 Spring Security 结合使用。<p>典型的 Spring Security 配置可能类似于以下示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ActuatorSecurity</span> <span class=keyword>extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>protected</span> <span class=keyword>void</span> <span class="title function_">configure</span><span class=params>(HttpSecurity http)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests()</span><br><span class=line>				.anyRequest().hasRole(<span class=string>"ENDPOINT_ADMIN"</span>)</span><br><span class=line>				.and()</span><br><span class=line>			.httpBasic();</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>前面的示例使用<code>EndpointRequest.toAnyEndpoint()</code>将请求匹配到任何端点，然后确保所有角色都具有<code>ENDPOINT_ADMIN</code>角色。 <code>EndpointRequest</code>上还有其他几种匹配器方法。有关详细信息，请参见 API 文档(<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/actuator-api//html rel=noopener target=_blank>HTML</a>或<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/actuator-api//pdf/spring-boot-actuator-web-api.pdf rel=noopener target=_blank>PDF</a>)。<p>如果将应用程序部署在防火墙后面，则可能希望可以在不进行身份验证的情况下访问所有 Actuator 端点。您可以通过更改<code>management.endpoints.web.exposure.include</code>属性来做到这一点，如下所示：<p><strong>application.properties.</strong><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoints.web.exposure.include</span>=<span class=string>*</span></span><br></pre></table></figure><p>此外，如果存在 Spring Security，则需要添加自定义安全配置，该配置允许未经身份验证的端点访问，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ActuatorSecurity</span> <span class=keyword>extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>protected</span> <span class=keyword>void</span> <span class="title function_">configure</span><span class=params>(HttpSecurity http)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>		http.requestMatcher(EndpointRequest.toAnyEndpoint()).authorizeRequests()</span><br><span class=line>			.anyRequest().permitAll();</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h3 id=4-2-4、配置端点><a class=headerlink href=#4-2-4、配置端点 title=4.2.4、配置端点></a>4.2.4、配置端点</h3><p>端点自动缓存对不带任何参数的读取操作的响应。要配置端点缓存响应的时间，请使用其<code>cache.time-to-live</code>属性。以下示例将<code>beans</code>终结点的缓存的生存时间设置为 10 秒：<p><strong>application.properties.</strong><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoint.beans.cache.time-to-live</span>=<span class=string>10s</span></span><br></pre></table></figure><blockquote><p>前缀<code>management.endpoint.&LTname></code>用于唯一标识正在配置的端点。<p>发出经过身份验证的 HTTP 请求时，<code>Principal</code>被视为端点的 Importing，因此将不缓存响应。</blockquote><h3 id=4-2-5、用于-Actuator-Web-端点的超媒体><a title="4.2.5、用于 Actuator Web 端点的超媒体" class=headerlink href=#4-2-5、用于-Actuator-Web-端点的超媒体></a>4.2.5、用于 Actuator Web 端点的超媒体</h3><p>添加了“发现页面”以及指向所有端点的链接。默认情况下，“发现页面”在<code>/actuator</code>上可用。<p>配置自定义 Management 上下文路径后，“发现页面”会自动从<code>/actuator</code>移到 Management 上下文的根目录。例如，如果 Management 上下文路径为<code>/management</code>，则可从<code>/management</code>访问发现页面。当 Management 上下文路径设置为<code>/</code>时，将禁用发现页面，以防止与其他 Map 发生冲突的可能性。<h3 id=4-2-6、CORS-支持><a title="4.2.6、CORS 支持" class=headerlink href=#4-2-6、CORS-支持></a>4.2.6、CORS 支持</h3><p><a href=https://en.wikipedia.org/wiki/Cross-origin_resource_sharing rel=noopener target=_blank>跨域资源共享</a>(CORS)是<a href=https://www.w3.org/TR/cors/ rel=noopener target=_blank>W3C specification</a>，它使您可以灵活地指定授权哪种类型的跨域请求。如果使用 Spring MVC 或 Spring WebFlux，则可以将 Actuator 的 Web 端点配置为支持此类方案。<p>默认情况下，CORS 支持是禁用的，只有在设置<code>management.endpoints.web.cors.allowed-origins</code>属性后才启用。以下配置允许来自<code>example.com</code>域的<code>GET</code>和<code>POST</code>调用：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoints.web.cors.allowed-origins</span>=<span class=string>http://example.com</span></span><br><span class=line><span class=attr>management.endpoints.web.cors.allowed-methods</span>=<span class=string>GET,POST</span></span><br></pre></table></figure><h3 id=4-2-7、实施自定义端点><a class=headerlink href=#4-2-7、实施自定义端点 title=4.2.7、实施自定义端点></a>4.2.7、实施自定义端点</h3><p>如果添加带有<code>@Endpoint</code>Comments 的<code>@Bean</code>，则带有<code>@ReadOperation</code>，<code>@WriteOperation</code>或<code>@DeleteOperation</code>Comments 的任何方法都将通过 JMX 以及 Web 应用程序中的 HTTP 自动公开。可以使用 Jersey，Spring MVC 或 Spring WebFlux 通过 HTTP 公开端点。<p>您还可以使用<code>@JmxEndpoint</code>或<code>@WebEndpoint</code>编写技术特定的端点。这些端点仅限于其各自的技术。例如，<code>@WebEndpoint</code>仅通过 HTTP 而不是 JMX 公开。<p>您可以使用<code>@EndpointWebExtension</code>和<code>@EndpointJmxExtension</code>编写技术特定的扩展。这些 Comments 使您可以提供特定于技术的操作来扩展现有端点。<p>最后，如果您需要访问特定于 Web 框架的功能，则可以实现 Servlet 或 Spring <code>@Controller</code>和<code>@RestController</code>端点，但代价是它们无法通过 JMX 或使用其他 Web 框架使用。<h4 id=4-2-7-1、接收-Importing><a title="4.2.7.1、接收 Importing" class=headerlink href=#4-2-7-1、接收-Importing></a>4.2.7.1、接收 Importing</h4><p>端点上的操作通过其参数接收 Importing。通过网络公开时，这些参数的值取自 URL 的查询参数和 JSON 请求正文。通过 JMX 公开时，参数将 Map 到 MBean 操作的参数。默认情况下，参数是必需的。可以通过使用<code>@org.springframework.lang.Nullable</code>对其进行 Comments 来使它们成为可选的。<p>JSON 请求正文中的每个根属性都可以 Map 到端点的参数。考虑以下 JSON 请求正文：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>{</span><br><span class=line>	"name": "test",</span><br><span class=line>	"counter": 42</span><br><span class=line>}</span><br></pre></table></figure><p>这可用于调用采用<code>String name</code>和<code>int counter</code>参数的写操作。<blockquote><p>由于端点与技术无关，因此只能在方法签名中指定简单类型。特别是，不支持使用定义<code>name</code>和<code>counter</code>属性的自定义类型声明单个参数。<p>为了将 ImportingMap 到操作方法的参数，实现端点的 Java 代码应使用<code>-parameters</code>编译，而实现端点的 Kotlin 代码应使用<code>-java-parameters</code>编译。如果您使用的是 Spring Boot 的 Gradle 插件，或者您使用的是 Maven 和<code>spring-boot-starter-parent</code>，那么这将自动发生。</blockquote><h5 id=Importing-类型转换><a title="Importing 类型转换" class=headerlink href=#Importing-类型转换></a>Importing 类型转换</h5><p>如有必要，传递给端点操作方法的参数会自动转换为所需的类型。在调用操作方法之前，使用<code>ApplicationConversionService</code>实例将通过 JMX 或 HTTP 请求接收的 Importing 转换为所需的类型。<h4 id=4-2-7-2、自定义-Web-端点><a title="4.2.7.2、自定义 Web 端点" class=headerlink href=#4-2-7-2、自定义-Web-端点></a>4.2.7.2、自定义 Web 端点</h4><p>使用 Jersey，Spring MVC 或 Spring WebFlux 通过 HTTP 自动公开<code>@Endpoint</code>，<code>@WebEndpoint</code>或<code>@EndpointWebExtension</code>上的操作。<h5 id=Web-端点请求谓词><a title="Web 端点请求谓词" class=headerlink href=#Web-端点请求谓词></a>Web 端点请求谓词</h5><p>对于在暴露于 Web 的端点上的每个操作，都会自动生成一个请求谓词。<h5 id=Path><a class=headerlink href=#Path title=Path></a>Path</h5><p>谓词的路径由终结点的 ID 和暴露于 Web 的终结点的基本路径确定。默认基本路径为<code>/actuator</code>。例如，ID 为<code>sessions</code>的端点将使用<code>/actuator/sessions</code>作为其在谓词中的路径。<p>通过使用<code>@Selector</code>Comments 操作方法的一个或多个参数，可以进一步自定义路径。将这样的参数作为路径变量添加到路径谓词。当端点操作被调用时，变量的值被传递到操作方法中。<h5 id=HTTP-method><a title="HTTP method" class=headerlink href=#HTTP-method></a>HTTP method</h5><p>谓词的 HTTP 方法由操作类型决定，如下表所示：<table><thead><tr><th>Operation<th>HTTP method<tbody><tr><td><code>@ReadOperation</code><td><code>GET</code><tr><td><code>@WriteOperation</code><td><code>POST</code><tr><td><code>@DeleteOperation</code><td><code>DELETE</code></table><h5 id=Consumes><a class=headerlink href=#Consumes title=Consumes></a>Consumes</h5><p>对于使用请求正文的<code>@WriteOperation</code>(HTTP <code>POST</code>)，谓词的消耗子句为<code>application/vnd.spring-boot.actuator.v2+json, application/json</code>。对于所有其他操作，消耗子句为空。<h5 id=Produces><a class=headerlink href=#Produces title=Produces></a>Produces</h5><p>谓词的 Produces 子句可以由<code>@DeleteOperation</code>，<code>@ReadOperation</code>和<code>@WriteOperation</code>注解的<code>produces</code>属性确定。该属性是可选的。如果未使用，则会自动确定 produces 子句。<p>如果操作方法返回<code>void</code>或<code>Void</code>，则 produces 子句为空。如果操作方法返回<code>org.springframework.core.io.Resource</code>，则 Produces 子句为<code>application/octet-stream</code>。对于所有其他操作，produces 子句为<code>application/vnd.spring-boot.actuator.v2+json, application/json</code>。<h5 id=Web-端点响应状态><a title="Web 端点响应状态" class=headerlink href=#Web-端点响应状态></a>Web 端点响应状态</h5><p>端点操作的默认响应状态取决于操作类型(读，写或删除)以及该操作返回的内容(如果有)。<p><code>@ReadOperation</code>返回一个值，响应状态将为 200(确定)。如果未返回值，则响应状态将为 404(未找到)。<p>如果<code>@WriteOperation</code>或<code>@DeleteOperation</code>返回值，则响应状态将为 200(确定)。如果未返回值，则响应状态将为 204(无内容)。<p>如果在没有必需参数或无法将参数转换为必需类型的参数的情况下调用操作，则不会调用该操作方法，并且响应状态将为 400(错误请求)。<h5 id=Web-端点范围请求><a title="Web 端点范围请求" class=headerlink href=#Web-端点范围请求></a>Web 端点范围请求</h5><p>HTTP 范围请求可用于请求 HTTP 资源的一部分。使用 Spring MVC 或 Spring Web Flux 时，返回<code>org.springframework.core.io.Resource</code>的操作自动支持范围请求。<blockquote><p>使用 Jersey 时不支持范围请求。</blockquote><h5 id=Web-端点安全><a title="Web 端点安全" class=headerlink href=#Web-端点安全></a>Web 端点安全</h5><p>Web 终结点或特定于 Web 的终结点扩展上的操作可以接收当前的<code>java.security.Principal</code>或<code>org.springframework.boot.actuate.endpoint.SecurityContext</code>作为方法参数。前者通常与<code>@Nullable</code>结合使用，以为经过身份验证和未经身份验证的用户提供不同的行为。后者通常用于使用其<code>isUserInRole(String)</code>方法执行授权检查。<h4 id=4-2-7-3、Servlet-端点><a title="4.2.7.3、Servlet 端点" class=headerlink href=#4-2-7-3、Servlet-端点></a>4.2.7.3、Servlet 端点</h4><p>通过实现带有<code>@ServletEndpoint</code>Comments 的类(也可以实现<code>Supplier&LTEndpointServlet></code>)，可以将<code>Servlet</code>公开为端点。 Servlet 端点提供了与 Servlet 容器的更深层集成，但以可移植性为代价。它们旨在用于将现有的<code>Servlet</code>公开为端点。对于新端点，应尽可能使用<code>@Endpoint</code>和<code>@WebEndpoint</code>注解。<h4 id=4-2-7-4、控制器端点><a class=headerlink href=#4-2-7-4、控制器端点 title=4.2.7.4、控制器端点></a>4.2.7.4、控制器端点</h4><p><code>@ControllerEndpoint</code>和<code>@RestControllerEndpoint</code>可用于实现仅由 Spring MVC 或 Spring WebFlux 公开的端点。使用 Spring MVC 和 Spring WebFlux 的标准 Comments(例如<code>@RequestMapping</code>和<code>@GetMapping</code>)Map 方法，并将端点的 ID 用作路径的前缀。控制器端点提供了与 Spring Web 框架的更深层集成，但以可移植性为代价。尽可能使用<code>@Endpoint</code>和<code>@WebEndpoint</code>注解。<h3 id=4-2-8、健康信息><a class=headerlink href=#4-2-8、健康信息 title=4.2.8、健康信息></a>4.2.8、健康信息</h3><p>您可以使用运行状况信息来检查正在运行的应用程序的状态。监视软件通常使用它在生产系统出现故障时向某人发出警报。 <code>health</code>端点公开的信息取决于<code>management.endpoint.health.show-details</code>属性，该属性可以配置以下值之一：<table><thead><tr><th>Name<th>Description<tbody><tr><td><code>never</code><td>详细信息永远不会显示。<tr><td><code>when-authorized</code><td>详细信息仅显示给授权用户。可以使用<code>management.endpoint.health.roles</code>配置授权角色。<tr><td><code>always</code><td>向所有用户显示详细信息。</table><p>默认值为<code>never</code>。当用户担任一个或多个端点的角色时，该用户被视为已授权。如果端点没有配置的角色(默认值)，则所有通过身份验证的用户均被视为已授权。可以使用<code>management.endpoint.health.roles</code>属性配置角色。<blockquote><p>如果您已保护应用程序安全并希望使用<code>always</code>，则安全配置必须允许经过身份验证的用户和未经身份验证的用户都可以访问运行状况端点。</blockquote><p>运行状况信息是从<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicatorRegistry.java rel=noopener target=_blank>HealthIndicatorRegistry</a>的内容中收集的(默认情况下，<code>ApplicationContext</code>中定义的所有<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java rel=noopener target=_blank>HealthIndicator</a>实例。Spring Boot 包含许多自动配置的<code>HealthIndicators</code>，您也可以编写自己的实例。默认情况下，最终的系统状态由<code>HealthAggregator</code>根据状态的有序列表对每个<code>HealthIndicator</code>的状态进行排序。排序后的列表中的第一个状态用作整体运行状况。如果没有<code>HealthIndicator</code>返回<code>HealthAggregator</code>已知的状态，则使用<code>UNKNOWN</code>状态。<blockquote><p><code>HealthIndicatorRegistry</code>可用于在运行时注册和注销运行状况指示器。</blockquote><h4 id=4-2-8-1、自动配置的健康-Metrics><a title="4.2.8.1、自动配置的健康 Metrics" class=headerlink href=#4-2-8-1、自动配置的健康-Metrics></a>4.2.8.1、自动配置的健康 Metrics</h4><p>适当时，Spring Boot 会自动配置以下<code>HealthIndicators</code>：<table><thead><tr><th>Name<th>Description<tbody><tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/cassandra/CassandraHealthIndicator.java rel=noopener target=_blank>CassandraHealthIndicator</a><td>检查 Cassandra 数据库是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/couchbase/CouchbaseHealthIndicator.java rel=noopener target=_blank>CouchbaseHealthIndicator</a><td>检查 Couchbase 群集是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/system/DiskSpaceHealthIndicator.java rel=noopener target=_blank>DiskSpaceHealthIndicator</a><td>检查磁盘空间不足。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/jdbc/DataSourceHealthIndicator.java rel=noopener target=_blank>DataSourceHealthIndicator</a><td>检查是否可以构建到<code>DataSource</code>的连接。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/elasticsearch/ElasticsearchHealthIndicator.java rel=noopener target=_blank>ElasticsearchHealthIndicator</a><td>检查 Elasticsearch 集群是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/influx/InfluxDbHealthIndicator.java rel=noopener target=_blank>InfluxDbHealthIndicator</a><td>检查 InfluxDB 服务器是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/jms/JmsHealthIndicator.java rel=noopener target=_blank>JmsHealthIndicator</a><td>检查 JMS 代理是否启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mail/MailHealthIndicator.java rel=noopener target=_blank>MailHealthIndicator</a><td>检查邮件服务器是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mongo/MongoHealthIndicator.java rel=noopener target=_blank>MongoHealthIndicator</a><td>检查 Mongo 数据库是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/neo4j/Neo4jHealthIndicator.java rel=noopener target=_blank>Neo4jHealthIndicator</a><td>检查 Neo4j 服务器是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/amqp/RabbitHealthIndicator.java rel=noopener target=_blank>RabbitHealthIndicator</a><td>检查 Rabbit 服务器是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/redis/RedisHealthIndicator.java rel=noopener target=_blank>RedisHealthIndicator</a><td>检查 Redis 服务器是否启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/solr/SolrHealthIndicator.java rel=noopener target=_blank>SolrHealthIndicator</a><td>检查 Solr 服务器是否已启动。</table><blockquote><p>您可以通过设置<code>management.health.defaults.enabled</code>属性来全部禁用它们。</blockquote><h4 id=4-2-8-2、编写自定义健康-Metrics><a title="4.2.8.2、编写自定义健康 Metrics" class=headerlink href=#4-2-8-2、编写自定义健康-Metrics></a>4.2.8.2、编写自定义健康 Metrics</h4><p>要提供自定义健康信息，您可以注册实现<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java rel=noopener target=_blank>HealthIndicator</a>接口的 Spring bean。您需要提供<code>health()</code>方法的实现并返回<code>Health</code>响应。 <code>Health</code>响应应包含状态，并且可以选择包含要显示的其他详细信息。以下代码显示了示例<code>HealthIndicator</code>实现：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.springframework.boot.actuate.health.Health;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.actuate.health.HealthIndicator;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyHealthIndicator</span> <span class=keyword>implements</span> <span class="title class_">HealthIndicator</span> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> Health <span class="title function_">health</span><span class=params>()</span> {</span><br><span class=line>		<span class=type>int</span> <span class=variable>errorCode</span> <span class=operator>=</span> check(); <span class=comment>// perform some specific health check</span></span><br><span class=line>		<span class=keyword>if</span> (errorCode != <span class=number>0</span>) {</span><br><span class=line>			<span class=keyword>return</span> Health.down().withDetail(<span class=string>"Error Code"</span>, errorCode).build();</span><br><span class=line>		}</span><br><span class=line>		<span class=keyword>return</span> Health.up().build();</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>给定<code>HealthIndicator</code>的标识符是不带<code>HealthIndicator</code>后缀的 bean 的名称(如果存在)。在前面的示例中，健康信息在名为<code>my</code>的条目中可用。</blockquote><p>除了 Spring Boot 的 sched 义<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/Status.java rel=noopener target=_blank>Status</a>类型之外，<code>Health</code>还可以返回表示新系统状态的自定义<code>Status</code>。在这种情况下，还需要提供<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthAggregator.java rel=noopener target=_blank>HealthAggregator</a>接口的自定义实现，或者必须使用<code>management.health.status.order</code>配置属性来配置默认实现。<p>例如，假设在您的<code>HealthIndicator</code>实现中使用了新的<code>Status</code>代码<code>FATAL</code>。要配置严重性 Sequences，请将以下属性添加到您的应用程序属性中：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.health.status.order</span>=<span class=string>FATAL, DOWN, OUT_OF_SERVICE, UNKNOWN, UP</span></span><br></pre></table></figure><p>响应中的 HTTP 状态代码反映了总体健康状态(例如<code>UP</code>Map 为 200，而<code>OUT_OF_SERVICE</code>和<code>DOWN</code>Map 为 503)。如果通过 HTTP 访问运行状况终结点，则可能还需要注册自定义状态 Map。例如，以下属性将<code>FATAL</code>Map 到 503(服务不可用)：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.health.status.http-mapping.FATAL</span>=<span class=string>503</span></span><br></pre></table></figure><blockquote><p>如果需要更多控制，则可以定义自己的<code>HealthStatusHttpMapper</code> bean。</blockquote><p>下表显示了内置状态的默认状态 Map：<table><thead><tr><th>Status<th>Mapping<tbody><tr><td>DOWN<td>SERVICE_UNAVAILABLE (503)<tr><td>OUT_OF_SERVICE<td>SERVICE_UNAVAILABLE (503)<tr><td>UP<td>默认情况下没有 Map，因此 http 状态为 200<tr><td>UNKNOWN<td>默认情况下没有 Map，因此 http 状态为 200</table><h4 id=4-2-8-3、Reactive-健康-Metrics><a title="4.2.8.3、Reactive 健康 Metrics" class=headerlink href=#4-2-8-3、Reactive-健康-Metrics></a>4.2.8.3、Reactive 健康 Metrics</h4><p>对于响应式应用程序，例如使用 Spring WebFlux 的应用程序，<code>ReactiveHealthIndicator</code>提供了非阻塞 Contract 以获取应用程序的运行状况。与传统<code>HealthIndicator</code>相似，健康信息是从<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicatorRegistry.java rel=noopener target=_blank>ReactiveHealthIndicatorRegistry</a>的内容中收集的(默认情况下，在<code>ApplicationContext</code>中定义的所有<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java rel=noopener target=_blank>HealthIndicator</a>和<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicator.java rel=noopener target=_blank>ReactiveHealthIndicator</a>实例。常规<code>HealthIndicator</code>不会根据反应式 API 进行检查，都是在弹性调度程序上执行的。<blockquote><p>在响应式应用程序中，<code>ReactiveHealthIndicatorRegistry</code>可用于在运行时注册和注销运行状况指示器。</blockquote><p>要从反应式 API 提供自定义健康信息，您可以注册实现<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicator.java rel=noopener target=_blank>ReactiveHealthIndicator</a>接口的 Spring bean。以下代码显示了一个示例<code>ReactiveHealthIndicator</code>实现：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyReactiveHealthIndicator</span> <span class=keyword>implements</span> <span class="title class_">ReactiveHealthIndicator</span> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> Mono&LTHealth> <span class="title function_">health</span><span class=params>()</span> {</span><br><span class=line>		<span class=keyword>return</span> doHealthCheck() <span class=comment>//perform some specific health check that returns a Mono&LTHealth></span></span><br><span class=line>			.onErrorResume(ex -> Mono.just(<span class=keyword>new</span> <span class="title class_">Health</span>.Builder().down(ex).build())));</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>要自动处理错误，请考虑从<code>AbstractReactiveHealthIndicator</code>扩展。</blockquote><h4 id=4-2-8-4、自动配置的-ReactiveHealthIndicators><a title="4.2.8.4、自动配置的 ReactiveHealthIndicators" class=headerlink href=#4-2-8-4、自动配置的-ReactiveHealthIndicators></a>4.2.8.4、自动配置的 ReactiveHealthIndicators</h4><p>适当时，Spring Boot 会自动配置以下<code>ReactiveHealthIndicators</code>：<table><thead><tr><th>Name<th>Description<tbody><tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/cassandra/CassandraReactiveHealthIndicator.java rel=noopener target=_blank>CassandraReactiveHealthIndicator</a><td>检查 Cassandra 数据库是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/couchbase/CouchbaseReactiveHealthIndicator.java rel=noopener target=_blank>CouchbaseReactiveHealthIndicator</a><td>检查 Couchbase 群集是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/mongo/MongoReactiveHealthIndicator.java rel=noopener target=_blank>MongoReactiveHealthIndicator</a><td>检查 Mongo 数据库是否已启动。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/redis/RedisReactiveHealthIndicator.java rel=noopener target=_blank>RedisReactiveHealthIndicator</a><td>检查 Redis 服务器是否启动。</table><blockquote><p>如有必要，可用无功指示器代替常规指示器。另外，任何未明确处理的<code>HealthIndicator</code>都会自动包装。</blockquote><h3 id=4-2-9、申请信息><a class=headerlink href=#4-2-9、申请信息 title=4.2.9、申请信息></a>4.2.9、申请信息</h3><p>应用程序信息公开了从<code>ApplicationContext</code>中定义的所有<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java rel=noopener target=_blank>InfoContributor</a> bean 中收集的各种信息。 Spring Boot 包含许多自动配置的<code>InfoContributor</code> bean，您可以编写自己的。<h4 id=4-2-9-1、自动配置的信息贡献者><a class=headerlink href=#4-2-9-1、自动配置的信息贡献者 title=4.2.9.1、自动配置的信息贡献者></a>4.2.9.1、自动配置的信息贡献者</h4><p>适当时，Spring Boot 会自动配置以下<code>InfoContributor</code> bean：<table><thead><tr><th>Name<th>Description<tbody><tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/EnvironmentInfoContributor.java rel=noopener target=_blank>EnvironmentInfoContributor</a><td>在<code>info</code>键下公开<code>Environment</code>中的任何键。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/GitInfoContributor.java rel=noopener target=_blank>GitInfoContributor</a><td>如果<code>git.properties</code>文件可用，则公开 git 信息。<tr><td><a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/BuildInfoContributor.java rel=noopener target=_blank>BuildInfoContributor</a><td>如果<code>META-INF/build-info.properties</code>文件可用，则公开构建信息。</table><blockquote><p>通过设置<code>management.info.defaults.enabled</code>属性，可以全部禁用它们。</blockquote><h4 id=4-2-9-2、自定义应用程序信息><a class=headerlink href=#4-2-9-2、自定义应用程序信息 title=4.2.9.2、自定义应用程序信息></a>4.2.9.2、自定义应用程序信息</h4><p>您可以通过设置<code>info.*</code> Spring 属性来自定义<code>info</code>终结点公开的数据。 <code>info</code>键下的所有<code>Environment</code>属性将自动显示。例如，您可以将以下设置添加到<code>application.properties</code>文件中：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>info.app.encoding</span>=<span class=string>UTF-8</span></span><br><span class=line><span class=attr>info.app.java.source</span>=<span class=string>1.8</span></span><br><span class=line><span class=attr>info.app.java.target</span>=<span class=string>1.8</span></span><br></pre></table></figure><blockquote><p>除了对这些值进行硬编码，您还可以<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/howto-properties-and-configuration.html#howto-automatic-expansion rel=noopener target=_blank>在构建时扩展信息属性</a>。<p>假设您使用 Maven，则可以按如下所示重写前面的示例：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>info.app.encoding[emailprotected]@</span></span><br><span class=line><span class=attr>info.app.java.source[emailprotected]@</span></span><br><span class=line><span class=attr>info.app.java.target[emailprotected]@</span></span><br></pre></table></figure></blockquote><h4 id=4-2-9-3、Git-提交信息><a title="4.2.9.3、Git 提交信息" class=headerlink href=#4-2-9-3、Git-提交信息></a>4.2.9.3、Git 提交信息</h4><p><code>info</code>端点的另一个有用功能是，它可以在项目构建时发布有关<code>git</code>源代码存储库状态的信息。如果<code>GitProperties</code> bean 可用，则公开<code>git.branch</code>，<code>git.commit.id</code>和<code>git.commit.time</code>属性。<blockquote><p>如果<code>git.properties</code>文件在 Classpath 的根目录中可用，则会自动配置<code>GitProperties</code> bean。有关更多详细信息，请参见“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/howto-build.html#howto-git-info rel=noopener target=_blank>生成 git 信息</a>”。</blockquote><p>如果要显示完整的 git 信息(即<code>git.properties</code>的完整内容)，请使用<code>management.info.git.mode</code>属性，如下所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.info.git.mode</span>=<span class=string>full</span></span><br></pre></table></figure><h4 id=4-2-9-4、生成信息><a class=headerlink href=#4-2-9-4、生成信息 title=4.2.9.4、生成信息></a>4.2.9.4、生成信息</h4><p>如果有<code>BuildProperties</code> bean，则<code>info</code>端点也可以发布有关构建的信息。如果<code>META-INF/build-info.properties</code>文件在 Classpath 中可用，则会发生这种情况。<blockquote><p>Maven 和 Gradle 插件都可以生成该文件。</blockquote><h4 id=4-2-9-5、编写自定义信息提供者><a class=headerlink href=#4-2-9-5、编写自定义信息提供者 title=4.2.9.5、编写自定义信息提供者></a>4.2.9.5、编写自定义信息提供者</h4><p>要提供自定义应用程序信息，您可以注册实现<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java rel=noopener target=_blank>InfoContributor</a>接口的 Spring bean。<p>下面的示例使用单个值贡献一个<code>example</code>条目：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.Collections;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> org.springframework.boot.actuate.info.Info;</span><br><span class=line><span class=keyword>import</span> org.springframework.boot.actuate.info.InfoContributor;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Component;</span><br><span class=line></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleInfoContributor</span> <span class=keyword>implements</span> <span class="title class_">InfoContributor</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">contribute</span><span class=params>(Info.Builder builder)</span> {</span><br><span class=line>		builder.withDetail(<span class=string>"example"</span>,</span><br><span class=line>				Collections.singletonMap(<span class=string>"key"</span>, <span class=string>"value"</span>));</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><p>如果到达<code>info</code>端点，则应该看到包含以下附加条目的响应：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>{</span><br><span class=line>	"example": {</span><br><span class=line>		"key" : "value"</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h2 id=4-3、通过-HTTP-进行监视和-Management><a title="4.3、通过 HTTP 进行监视和 Management" class=headerlink href=#4-3、通过-HTTP-进行监视和-Management></a>4.3、通过 HTTP 进行监视和 Management</h2><p>如果您正在开发 Web 应用程序，则 Spring Boot Actuator 会自动配置所有启用的端点以通过 HTTP 公开。默认约定是使用端点的<code>id</code>和前缀<code>/actuator</code>作为 URL 路径。例如，<code>health</code>被公开为<code>/actuator/health</code>。提示：Spring MVC，Spring WebFlux 和 Jersey 本身支持 Actuator。<h3 id=4-3-1、自定义-Management-端点路径><a title="4.3.1、自定义 Management 端点路径" class=headerlink href=#4-3-1、自定义-Management-端点路径></a>4.3.1、自定义 Management 端点路径</h3><p>有时，自定义 Management 端点的前缀很有用。例如，您的应用程序可能已经将<code>/actuator</code>用于其他用途。您可以使用<code>management.endpoints.web.base-path</code>属性来更改 Management 端点的前缀，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.endpoints.web.base-path=/manage</span><br></pre></table></figure><p>前面的<code>application.properties</code>示例将端点从<code>/actuator/{id}</code>更改为<code>/manage/{id}</code>(例如<code>/manage/info</code>)。<blockquote><p>除非 Management 端口已配置为<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-monitoring.html#production-ready-customizing-management-server-port rel=noopener target=_blank>通过使用其他 HTTP 端口公开端点</a>，否则<code>management.endpoints.web.base-path</code>是相对于<code>server.servlet.context-path</code>的。如果配置了<code>management.server.port</code>，则<code>management.endpoints.web.base-path</code>相对于<code>management.server.servlet.context-path</code>。</blockquote><p>如果要将端点 Map 到其他路径，可以使用<code>management.endpoints.web.path-mapping</code>属性。<p>以下示例将<code>/actuator/health</code>重新 Map 到<code>/healthcheck</code>：<p><strong>application.properties.</strong><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoints.web.base-path</span>=<span class=string>/</span></span><br><span class=line><span class=attr>management.endpoints.web.path-mapping.health</span>=<span class=string>healthcheck</span></span><br></pre></table></figure><h3 id=4-3-2、自定义-Management-服务器端口><a title="4.3.2、自定义 Management 服务器端口" class=headerlink href=#4-3-2、自定义-Management-服务器端口></a>4.3.2、自定义 Management 服务器端口</h3><p>对于基于云的部署，使用默认的 HTTP 端口公开 Management 端点是明智的选择。但是，如果您的应用程序在自己的数据中心内运行，则您可能更喜欢使用其他 HTTP 端口公开端点。<p>您可以设置<code>management.server.port</code>属性来更改 HTTP 端口，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.server.port</span>=<span class=string>8081</span></span><br></pre></table></figure><h3 id=4-3-3、配置特定于-Management-的-SSL><a title="4.3.3、配置特定于 Management 的 SSL" class=headerlink href=#4-3-3、配置特定于-Management-的-SSL></a>4.3.3、配置特定于 Management 的 SSL</h3><p>当配置为使用自定义端口时，还可以通过使用各种<code>management.server.ssl.*</code>属性将 Management 服务器配置为其自己的 SSL。例如，这样做可以使 Management 服务器在主应用程序使用 HTTPS 时通过 HTTP 可用，如以下属性设置所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=attr>server.port</span>=<span class=string>8443</span></span><br><span class=line><span class=attr>server.ssl.enabled</span>=<span class=string>true</span></span><br><span class=line><span class=attr>server.ssl.key-store</span>=<span class=string>classpath:store.jks</span></span><br><span class=line><span class=attr>server.ssl.key-password</span>=<span class=string>secret</span></span><br><span class=line><span class=attr>management.server.port</span>=<span class=string>8080</span></span><br><span class=line><span class=attr>management.server.ssl.enabled</span>=<span class=string>false</span></span><br></pre></table></figure><p>另外，主服务器和 Management 服务器都可以使用 SSL，但具有不同的密钥库，如下所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=attr>server.port</span>=<span class=string>8443</span></span><br><span class=line><span class=attr>server.ssl.enabled</span>=<span class=string>true</span></span><br><span class=line><span class=attr>server.ssl.key-store</span>=<span class=string>classpath:main.jks</span></span><br><span class=line><span class=attr>server.ssl.key-password</span>=<span class=string>secret</span></span><br><span class=line><span class=attr>management.server.port</span>=<span class=string>8080</span></span><br><span class=line><span class=attr>management.server.ssl.enabled</span>=<span class=string>true</span></span><br><span class=line><span class=attr>management.server.ssl.key-store</span>=<span class=string>classpath:management.jks</span></span><br><span class=line><span class=attr>management.server.ssl.key-password</span>=<span class=string>secret</span></span><br></pre></table></figure><h3 id=4-3-4、自定义-Management-服务器地址><a title="4.3.4、自定义 Management 服务器地址" class=headerlink href=#4-3-4、自定义-Management-服务器地址></a>4.3.4、自定义 Management 服务器地址</h3><p>您可以通过设置<code>management.server.address</code>属性来自定义 Management 端点可用的地址。如果您只想侦听内部或面向操作的网络，或者只侦听来自<code>localhost</code>的连接，则这样做很有用。<blockquote><p>仅当端口与主服务器端口不同时，您才能在其他地址上侦听。</blockquote><p>以下示例<code>application.properties</code>不允许远程 Management 连接：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>management.server.port</span>=<span class=string>8081</span></span><br><span class=line><span class=attr>management.server.address</span>=<span class=string>127.0.0.1</span></span><br></pre></table></figure><h3 id=4-3-5、禁用-HTTP-端点><a title="4.3.5、禁用 HTTP 端点" class=headerlink href=#4-3-5、禁用-HTTP-端点></a>4.3.5、禁用 HTTP 端点</h3><p>如果您不想通过 HTTP 公开端点，则可以将 Management 端口设置为<code>-1</code>，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.server.port</span>=<span class=string>-1</span></span><br></pre></table></figure><p>也可以使用<code>management.endpoints.web.exposure.exclude</code>属性来实现，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoints.web.exposure.exclude</span>=<span class=string>*</span></span><br></pre></table></figure><h2 id=4-4、通过-JMX-进行监视和-Management><a title="4.4、通过 JMX 进行监视和 Management" class=headerlink href=#4-4、通过-JMX-进行监视和-Management></a>4.4、通过 JMX 进行监视和 Management</h2><p>Java Management 扩展(JMX)提供了监视和 Management 应用程序的标准机制。默认情况下，Spring Boot 在<code>org.springframework.boot</code>域下将 Management 端点公开为 JMX MBean。<h3 id=4-4-1、自定义-MBean-名称><a title="4.4.1、自定义 MBean 名称" class=headerlink href=#4-4-1、自定义-MBean-名称></a>4.4.1、自定义 MBean 名称</h3><p>MBean 的名称通常是从端点的<code>id</code>生成的。例如，<code>health</code>端点公开为<code>org.springframework.boot:type=Endpoint,name=Health</code>。<p>如果您的应用程序包含多个 Spring <code>ApplicationContext</code>，则您可能会发现名称冲突。要解决此问题，可以将<code>spring.jmx.unique-names</code>属性设置为<code>true</code>，以便 MBean 名称始终是唯一的。<p>您还可以自定义暴露端点的 JMX 域。以下设置显示了在<code>application.properties</code>中执行此操作的示例：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>spring.jmx.unique-names</span>=<span class=string>true</span></span><br><span class=line><span class=attr>management.endpoints.jmx.domain</span>=<span class=string>com.example.myapp</span></span><br></pre></table></figure><h3 id=4-4-2、禁用-JMX-端点><a title="4.4.2、禁用 JMX 端点" class=headerlink href=#4-4-2、禁用-JMX-端点></a>4.4.2、禁用 JMX 端点</h3><p>如果不想通过 JMX 公开终结点，可以将<code>management.endpoints.jmx.exposure.exclude</code>属性设置为<code>*</code>，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoints.jmx.exposure.exclude</span>=<span class=string>*</span></span><br></pre></table></figure><h3 id=4-4-3、通过-HTTP-将-Jolokia-用于-JMX><a title="4.4.3、通过 HTTP 将 Jolokia 用于 JMX" class=headerlink href=#4-4-3、通过-HTTP-将-Jolokia-用于-JMX></a>4.4.3、通过 HTTP 将 Jolokia 用于 JMX</h3><p>Jolokia 是一个 JMX-HTTP bridge，它提供了一种访问 JMX Bean 的替代方法。要使用 Jolokia，请包括对<code>org.jolokia:jolokia-core</code>的依赖。例如，使用 Maven，您将添加以下依赖项：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>org.jolokia<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>jolokia-core<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><p>然后，可以通过向<code>management.endpoints.web.exposure.include</code>属性添加<code>jolokia</code>或<code>*</code>来暴露 Jolokia 端点。然后，可以通过在 Management HTTP 服务器上使用<code>/actuator/jolokia</code>来访问它。<h4 id=4-4-3-1、自定义-Jolokia><a title="4.4.3.1、自定义 Jolokia" class=headerlink href=#4-4-3-1、自定义-Jolokia></a>4.4.3.1、自定义 Jolokia</h4><p>Jolokia 具有许多设置，这些设置通常是通过设置 servlet 参数进行配置的。通过 Spring Boot，您可以使用<code>application.properties</code>文件。为此，请在参数前面加上<code>management.endpoint.jolokia.config.</code>，如以下示例所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoint.jolokia.config.debug</span>=<span class=string>true</span></span><br></pre></table></figure><h4 id=4-4-3-2、禁用-Jolokia><a title="4.4.3.2、禁用 Jolokia" class=headerlink href=#4-4-3-2、禁用-Jolokia></a>4.4.3.2、禁用 Jolokia</h4><p>如果您使用 Jolokia 但不希望 Spring Boot 对其进行配置，则将<code>management.endpoint.jolokia.enabled</code>属性设置为<code>false</code>，如下所示：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.endpoint.jolokia.enabled</span>=<span class=string>false</span></span><br></pre></table></figure><h2 id=4-5、Loggers><a class=headerlink href=#4-5、Loggers title=4.5、Loggers></a>4.5、Loggers</h2><p>Spring Boot Actuator 可以在运行时查看和配置应用程序的日志级别。您可以查看整个列表，也可以查看单个 Logger 的配置，该配置由显式配置的记录级别以及由记录框架赋予它的有效记录级别组成。这些级别可以是以下之一：<ul><li><code>TRACE</code><li><code>DEBUG</code><li><code>INFO</code><li><code>WARN</code><li><code>ERROR</code><li><code>FATAL</code><li><code>OFF</code><li><code>null</code></ul><p><code>null</code>表示没有显式配置。<h3 id=4-5-1、配置Logger><a class=headerlink href=#4-5-1、配置Logger title=4.5.1、配置Logger></a>4.5.1、配置Logger</h3><p>要配置给定的 Logger，请为资源的 URI <code>POST</code>部分实体，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>{</span><br><span class=line>	"configuredLevel": "DEBUG"</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>要“重置”Logger 的特定级别(并使用默认配置)，可以将值<code>null</code>作为<code>configuredLevel</code>传递。</blockquote><h2 id=4-6、Metrics><a class=headerlink href=#4-6、Metrics title=4.6、Metrics></a>4.6、Metrics</h2><p>Spring Boot Actuator 为<a href=https://micrometer.io/ rel=noopener target=_blank>Micrometer</a>提供依赖关系 Management 和自动配置，<a href=https://micrometer.io/ rel=noopener target=_blank>Micrometer</a>是一种应用程序 Metrics 外观，支持众多监视系统，包括：<ul><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-appoptics rel=noopener target=_blank>AppOptics</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-atlas rel=noopener target=_blank>Atlas</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-datadog rel=noopener target=_blank>Datadog</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-dynatrace rel=noopener target=_blank>Dynatrace</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-dynatrace rel=noopener target=_blank>Elastic</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-ganglia rel=noopener target=_blank>Ganglia</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-graphite rel=noopener target=_blank>Graphite</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-humio rel=noopener target=_blank>Humio</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-influx rel=noopener target=_blank>Influx</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-jmx rel=noopener target=_blank>JMX</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-kairos rel=noopener target=_blank>KairosDB</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-newrelic rel=noopener target=_blank>New Relic</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-prometheus rel=noopener target=_blank>Prometheus</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-signalfx rel=noopener target=_blank>SignalFx</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-simple rel=noopener target=_blank>Simple (in-memory)</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-statsd rel=noopener target=_blank>StatsD</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-export-wavefront rel=noopener target=_blank>Wavefront</a></ul><h3 id=4-6-1、使用-Starter><a title="4.6.1、使用 Starter" class=headerlink href=#4-6-1、使用-Starter></a>4.6.1、使用 Starter</h3><p>Spring Boot 自动配置组合<code>MeterRegistry</code>，并为其在 Classpath 上找到的每个受支持的实现向组合添加注册表。在运行时 Classpath 中具有<code>micrometer-registry-{system}</code>的依赖关系足以让 Spring Boot 配置注册表。<p>大多数注册表具有共同的 Feature。例如，即使 Micrometer 注册表实现位于 Classpath 中，您也可以禁用特定的注册表。例如，要禁用 Datadog：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.metrics.export.datadog.enabled</span>=<span class=string>false</span></span><br></pre></table></figure><p>Spring Boot 还会将任何自动配置的注册表添加到<code>Metrics</code>类的全局静态复合注册表中，除非您明确告知不要：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>management.metrics.use-global-registry</span>=<span class=string>false</span></span><br></pre></table></figure><p>您可以注册任意数量的<code>MeterRegistryCustomizer</code> bean 来进一步配置注册表，例如在向注册表注册任何计量器之前应用通用标签：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line>MeterRegistryCustomizer&LTMeterRegistry> <span class="title function_">metricsCommonTags</span><span class=params>()</span> {</span><br><span class=line>	<span class=keyword>return</span> registry -> registry.config().commonTags(<span class=string>"region"</span>, <span class=string>"us-east-1"</span>);</span><br><span class=line>}</span><br></pre></table></figure><p>您可以通过更具体地了解通用类型，将自定义应用于特定的注册表实现：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line>MeterRegistryCustomizer&LTGraphiteMeterRegistry> <span class="title function_">graphiteMetricsNamingConvention</span><span class=params>()</span> {</span><br><span class=line>	<span class=keyword>return</span> registry -> registry.config().namingConvention(MY_CUSTOM_CONVENTION);</span><br><span class=line>}</span><br></pre></table></figure><p>完成该设置后，您可以在组件中注入<code>MeterRegistry</code>并注册 Metrics：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SampleBean</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> Counter counter;</span><br><span class=line>	<span class=keyword>public</span> <span class="title function_">SampleBean</span><span class=params>(MeterRegistry registry)</span> {</span><br><span class=line>		<span class=built_in>this</span>.counter = registry.counter(<span class=string>"received.messages"</span>);</span><br><span class=line>	}</span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">handleMessage</span><span class=params>(String message)</span> {</span><br><span class=line>		<span class=built_in>this</span>.counter.increment();</span><br><span class=line>		<span class=comment>// handle message implementation</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>Spring Boot 也是<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-meter rel=noopener target=_blank>配置内置仪器</a>(即<code>MeterBinder</code>实现)，您可以通过配置或专用 Comments 标记进行控制。<h3 id=4-6-2、支持的监视系统><a class=headerlink href=#4-6-2、支持的监视系统 title=4.6.2、支持的监视系统></a>4.6.2、支持的监视系统</h3><h4 id=4-6-2-1、AppOptics><a class=headerlink href=#4-6-2-1、AppOptics title=4.6.2.1、AppOptics></a>4.6.2.1、AppOptics</h4><p>默认情况下，AppOptics 注册表会定期将 Metrics 推送到<a href=https://api.appoptics.com/v1/measurements rel=noopener target=_blank>api.appoptics.com/v1/measurements</a>。要将 Metrics 导出到 SaaS <a href=http://micrometer.io/docs/registry/appoptics rel=noopener target=_blank>AppOptics</a>，必须提供您的 API 令牌：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.appoptics.api-token=YOUR_TOKEN</span><br></pre></table></figure><h4 id=4-6-2-2、Atlas><a class=headerlink href=#4-6-2-2、Atlas title=4.6.2.2、Atlas></a>4.6.2.2、Atlas</h4><p>默认情况下，度量标准导出到在本地计算机上运行的<a href=http://micrometer.io/docs/registry/atlas rel=noopener target=_blank>Atlas</a>。可以使用以下方式提供要使用的<a href=https://github.com/Netflix/atlas rel=noopener target=_blank>Atlas server</a>的位置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.atlas.uri=http://atlas.example.com:7101/api/v1/publish</span><br></pre></table></figure><h4 id=4-6-2-3、Datadog><a class=headerlink href=#4-6-2-3、Datadog title=4.6.2.3、Datadog></a>4.6.2.3、Datadog</h4><p>Datadog 注册表会定期将 Metrics 推送到<a href=https://www.datadoghq.com/ rel=noopener target=_blank>datadoghq</a>。要将 Metrics 导出到<a href=http://micrometer.io/docs/registry/datadog rel=noopener target=_blank>Datadog</a>，必须提供您的 API 密钥：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.datadog.api-key=YOUR_KEY</span><br></pre></table></figure><p>您还可以更改将度量标准发送到 Datadog 的时间间隔：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.datadog.step=30s</span><br></pre></table></figure><h4 id=4-6-2-4、Dynatrace><a class=headerlink href=#4-6-2-4、Dynatrace title=4.6.2.4、Dynatrace></a>4.6.2.4、Dynatrace</h4><p>Dynatrace 注册表会定期将 Metrics 推送到配置的 URI。要将 Metrics 导出到<a href=http://micrometer.io/docs/registry/dynatrace rel=noopener target=_blank>Dynatrace</a>，必须提供您的 API 令牌，设备 ID 和 URI：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>management.metrics.export.dynatrace.api-token=YOUR_TOKEN</span><br><span class=line>management.metrics.export.dynatrace.device-id=YOUR_DEVICE_ID</span><br><span class=line>management.metrics.export.dynatrace.uri=YOUR_URI</span><br></pre></table></figure><p>您还可以更改将度量标准发送到 Dynatrace 的时间间隔：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.dynatrace.step=30s</span><br></pre></table></figure><h4 id=4-6-2-5、Elastic><a class=headerlink href=#4-6-2-5、Elastic title=4.6.2.5、Elastic></a>4.6.2.5、Elastic</h4><p>默认情况下，度量标准导出到在本地计算机上运行的<a href=http://micrometer.io/docs/registry/elastic rel=noopener target=_blank>Elastic</a>。可以使用以下属性提供要使用的 Elastic 服务器的位置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.elastic.host=http://elastic.example.com:8086</span><br></pre></table></figure><h4 id=4-6-2-6、Ganglia><a class=headerlink href=#4-6-2-6、Ganglia title=4.6.2.6、Ganglia></a>4.6.2.6、Ganglia</h4><p>默认情况下，度量标准导出到在本地计算机上运行的<a href=http://micrometer.io/docs/registry/ganglia rel=noopener target=_blank>Ganglia</a>。可以使用以下方式提供要使用的<a href=http://ganglia.sourceforge.net/ rel=noopener target=_blank>Ganglia server</a>主机和端口：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>management.metrics.export.ganglia.host=ganglia.example.com</span><br><span class=line>management.metrics.export.ganglia.port=9649</span><br></pre></table></figure><h4 id=4-6-2-7、Graphite><a class=headerlink href=#4-6-2-7、Graphite title=4.6.2.7、Graphite></a>4.6.2.7、Graphite</h4><p>默认情况下，度量标准导出到在本地计算机上运行的<a href=http://micrometer.io/docs/registry/graphite rel=noopener target=_blank>Graphite</a>。可以使用以下方式提供要使用的<a href=https://graphiteapp.org/ rel=noopener target=_blank>Graphite server</a>主机和端口：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>management.metrics.export.graphite.host=graphite.example.com</span><br><span class=line>management.metrics.export.graphite.port=9004</span><br></pre></table></figure><p>千分尺提供默认值<code>HierarchicalNameMapper</code>，该默认值<code>HierarchicalNameMapper</code>决定尺寸表 ID <a href=http://micrometer.io/docs/registry/graphite#_hierarchical_name_mapping rel=noopener target=_blank>Map 到平面层次结构名称</a>的方式。<blockquote><p>要控制此行为，请定义您的<code>GraphiteMeterRegistry</code>并提供您自己的<code>HierarchicalNameMapper</code>。除非您定义自己的，否则将提供自动配置的<code>GraphiteConfig</code>和<code>Clock</code> bean：</blockquote><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> GraphiteMeterRegistry <span class="title function_">graphiteMeterRegistry</span><span class=params>(GraphiteConfig config, Clock clock)</span> {</span><br><span class=line>	<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">GraphiteMeterRegistry</span>(config, clock, MY_HIERARCHICAL_MAPPER);</span><br><span class=line>}</span><br></pre></table></figure><h4 id=4-6-2-8、Humio><a class=headerlink href=#4-6-2-8、Humio title=4.6.2.8、Humio></a>4.6.2.8、Humio</h4><p>默认情况下，Humio 注册表会定期将 Metrics 推送到<a href=https://cloud.humio.com/ rel=noopener target=_blank>cloud.humio.com</a>。要将 Metrics 导出到 SaaS <a href=http://micrometer.io/docs/registry/humio rel=noopener target=_blank>Humio</a>，必须提供您的 API 令牌：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.humio.api-token=YOUR_TOKEN</span><br></pre></table></figure><p>您还应该配置一个或多个标记以标识将度量标准推送到的数据源：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>management.metrics.export.humio.tags.alpha=a</span><br><span class=line>management.metrics.export.humio.tags.bravo=b</span><br></pre></table></figure><h4 id=4-6-2-9、Influx><a class=headerlink href=#4-6-2-9、Influx title=4.6.2.9、Influx></a>4.6.2.9、Influx</h4><p>默认情况下，度量标准导出到在本地计算机上运行的<a href=http://micrometer.io/docs/registry/influx rel=noopener target=_blank>Influx</a>。可以使用以下方式提供要使用的<a href=https://www.influxdata.com/ rel=noopener target=_blank>Influx server</a>的位置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.influx.uri=http://influx.example.com:8086</span><br></pre></table></figure><h4 id=4-6-2-10、JMX><a class=headerlink href=#4-6-2-10、JMX title=4.6.2.10、JMX></a>4.6.2.10、JMX</h4><p>千分尺提供到<a href=http://micrometer.io/docs/registry/jmx rel=noopener target=_blank>JMX</a>的层次结构 Map，主要是作为一种便宜且可移植的方式在本地查看 Metrics。默认情况下，Metrics 会导出到<code>metrics</code> JMX 域。可以使用以下方式提供要使用的域：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.jmx.domain=com.example.app.metrics</span><br></pre></table></figure><p>千分尺提供默认值<code>HierarchicalNameMapper</code>，该默认值<code>HierarchicalNameMapper</code>决定尺寸表 ID <a href=http://micrometer.io/docs/registry/jmx#_hierarchical_name_mapping rel=noopener target=_blank>Map 到平面层次结构名称</a>的方式。<blockquote><p>要控制此行为，请定义您的<code>JmxMeterRegistry</code>并提供您自己的<code>HierarchicalNameMapper</code>。除非您定义自己的，否则将提供自动配置的<code>JmxConfig</code>和<code>Clock</code> bean：</blockquote><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> JmxMeterRegistry <span class="title function_">jmxMeterRegistry</span><span class=params>(JmxConfig config, Clock clock)</span> {</span><br><span class=line>	<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">JmxMeterRegistry</span>(config, clock, MY_HIERARCHICAL_MAPPER);</span><br><span class=line>}</span><br></pre></table></figure><h4 id=4-6-2-11、KairosDB><a class=headerlink href=#4-6-2-11、KairosDB title=4.6.2.11、KairosDB></a>4.6.2.11、KairosDB</h4><p>默认情况下，度量标准导出到在本地计算机上运行的<a href=http://micrometer.io/docs/registry/kairos rel=noopener target=_blank>KairosDB</a>。可以使用以下方式提供要使用的<a href=https://kairosdb.github.io/ rel=noopener target=_blank>KairosDB server</a>的位置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.kairos.uri=http://kairosdb.example.com:8080/api/v1/datapoints</span><br></pre></table></figure><h4 id=4-6-2-12、New-Relic><a title="4.6.2.12、New Relic" class=headerlink href=#4-6-2-12、New-Relic></a>4.6.2.12、New Relic</h4><p>新的 Relic 注册表会定期将 Metrics 推送到<a href=http://micrometer.io/docs/registry/new-relic rel=noopener target=_blank>New Relic</a>。要将 Metrics 导出到<a href=https://newrelic.com/ rel=noopener target=_blank>New Relic</a>，必须提供您的 API 密钥和帐户 ID：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>management.metrics.export.newrelic.api-key=YOUR_KEY</span><br><span class=line>management.metrics.export.newrelic.account-id=YOUR_ACCOUNT_ID</span><br></pre></table></figure><p>您还可以更改将度量标准发送到 New Relic 的时间间隔：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.newrelic.step=30s</span><br></pre></table></figure><h4 id=4-6-2-13、Prometheus><a class=headerlink href=#4-6-2-13、Prometheus title=4.6.2.13、Prometheus></a>4.6.2.13、Prometheus</h4><p><a href=http://micrometer.io/docs/registry/prometheus rel=noopener target=_blank>Prometheus</a>希望抓取或轮询单个应用程序实例以获取 Metrics。 Spring Boot 在<code>/actuator/prometheus</code>处提供了一个 Actuator 端点，以渲染具有适当格式的<a href=https://prometheus.io/ rel=noopener target=_blank>Prometheus scrape</a>。<p>这是将<code>scrape_config</code>添加到<code>prometheus.yml</code>的示例：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>scrape_configs:</span><br><span class=line>  - job_name: 'spring'</span><br><span class=line>	metrics_path: '/actuator/prometheus'</span><br><span class=line>	static_configs:</span><br><span class=line>	  - targets: ['HOST:PORT']</span><br></pre></table></figure><h4 id=4-6-2-14、SignalFx><a class=headerlink href=#4-6-2-14、SignalFx title=4.6.2.14、SignalFx></a>4.6.2.14、SignalFx</h4><p>SignalFx 注册表会定期将 Metrics 推送到<a href=http://micrometer.io/docs/registry/signalfx rel=noopener target=_blank>SignalFx</a>。要将 Metrics 导出到<a href=https://signalfx.com/ rel=noopener target=_blank>SignalFx</a>，必须提供您的访问令牌：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.signalfx.access-token=YOUR_ACCESS_TOKEN</span><br></pre></table></figure><p>您还可以更改将度量标准发送到 SignalFx 的时间间隔：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.signalfx.step=30s</span><br></pre></table></figure><h4 id=4-6-2-15、Simple><a class=headerlink href=#4-6-2-15、Simple title=4.6.2.15、Simple></a>4.6.2.15、Simple</h4><p>千分尺附带一个简单的内存后端，如果未配置其他注册表，该后端将自动用作后备。这使您可以查看<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-metrics.html#production-ready-metrics-endpoint rel=noopener target=_blank>metrics endpoint</a>中收集了哪些 Metrics。<p>使用任何其他可用后端时，内存后端都会自行禁用。您还可以显式禁用它：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.simple.enabled=false</span><br></pre></table></figure><h4 id=4-6-2-16、StatsD><a class=headerlink href=#4-6-2-16、StatsD title=4.6.2.16、StatsD></a>4.6.2.16、StatsD</h4><p>StatsD 注册表急切地通过 UDP 将度量标准推送到 StatsD 代理。默认情况下，Metrics 会导出到本地计算机上运行的<a href=http://micrometer.io/docs/registry/statsd rel=noopener target=_blank>StatsD</a>代理。可以使用以下方式提供要使用的 StatsD 代理主机和端口：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>management.metrics.export.statsd.host=statsd.example.com</span><br><span class=line>management.metrics.export.statsd.port=9125</span><br></pre></table></figure><p>您还可以更改要使用的 StatsD 线路协议(默认为 Datadog)：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.statsd.flavor=etsy</span><br></pre></table></figure><h4 id=4-6-2-17、Wavefront><a class=headerlink href=#4-6-2-17、Wavefront title=4.6.2.17、Wavefront></a>4.6.2.17、Wavefront</h4><p>Wavefront 注册表会定期将 Metrics 推送到<a href=http://micrometer.io/docs/registry/wavefront rel=noopener target=_blank>Wavefront</a>。如果您直接将 Metrics 导出到<a href=https://www.wavefront.com/ rel=noopener target=_blank>Wavefront</a>，则必须提供您的 API 令牌：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.wavefront.api-token=YOUR_API_TOKEN</span><br></pre></table></figure><p>或者，您可以使用在您的环境中设置的 Wavefront 辅助工具或内部代理，将 Metrics 数据转发到 Wavefront API 主机：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.wavefront.uri=proxy://localhost:2878</span><br></pre></table></figure><blockquote><p>如果将 Metrics 发布到 Wavefront 代理(如<a href=https://docs.wavefront.com/proxies_installing.html rel=noopener target=_blank>the documentation</a>中所述)，则主机必须为<code>proxy://HOST:PORT</code>格式。</blockquote><p>您还可以更改将度量标准发送到 Wavefront 的时间间隔：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.export.wavefront.step=30s</span><br></pre></table></figure><h3 id=4-6-3、支持的-Metrics><a title="4.6.3、支持的 Metrics" class=headerlink href=#4-6-3、支持的-Metrics></a>4.6.3、支持的 Metrics</h3><p>如果适用，Spring Boot 将注册以下核心 Metrics：<ul><li>JVM Metrics，报告以下方面的利用率：<li>各种内存和缓冲池<ul><li>与垃圾收集有关的统计数据<li>Threads utilization<li>加载/卸载的类数</ul><li>CPU metrics<li>文件 DescriptorsMetrics<li>KafkaConsumerMetrics<li>Log4j2 Metrics：记录每个级别记录到 Log4j2 的事件数<li>Logback Metrics：记录每个级别记录到 Logback 的事件数<li>正常运行时间 Metrics：报告正常运行时间的量度和代表应用程序绝对启动时间的固定量度<li>Tomcat metrics<li><a href=https://docs.spring.io/spring-integration/docs/current/reference/html/system-management-chapter.html#micrometer-integration rel=noopener target=_blank>Spring Integration</a> metrics</ul><h4 id=4-6-3-1、Spring-MVC-Metrics><a title="4.6.3.1、Spring MVC Metrics" class=headerlink href=#4-6-3-1、Spring-MVC-Metrics></a>4.6.3.1、Spring MVC Metrics</h4><p>通过自动配置，可以检测由 Spring MVC 处理的请求。当<code>management.metrics.web.server.auto-time-requests</code>为<code>true</code>时，将对所有请求进行检测。或者，当设置为<code>false</code>时，可以通过将<code>@Timed</code>添加到请求处理方法来启用检测：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@RestController</span></span><br><span class=line><span class=meta>@Timed</span> (<span class=number>1</span>)</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyController</span> {</span><br><span class=line></span><br><span class=line>	<span class=meta>@GetMapping("/api/people")</span></span><br><span class=line>	<span class=meta>@Timed(extraTags = { "region", "us-east-1" })</span> (<span class=number>2</span>)</span><br><span class=line>	<span class=meta>@Timed(value = "all.people", longTask = true)</span> (<span class=number>3</span>)</span><br><span class=line>	<span class=keyword>public</span> List&LTPerson> <span class="title function_">listPeople</span><span class=params>()</span> { ... }</span><br><span class=line></span><br><span class=line>}</span><br></pre></table></figure><ul><li><strong>(1)</strong> 控制器类，用于对控制器中的每个请求处理程序启用计时。<li><strong>(2)</strong> 一种启用单个端点的方法。如果您将它放在类中，则不必这样做，但是可以用于进一步为此特定端点自定义计时器。<li><strong>(3)</strong> 具有<code>longTask = true</code>的方法为该方法启用长任务计时器。长任务计时器需要一个单独的度量标准名称，并且可以与短任务计时器堆叠在一起。</ul><p>默认情况下，使用名称<code>http.server.requests</code>生成度量。可以通过设置<code>management.metrics.web.server.requests-metric-name</code>属性来自定义名称。<p>默认情况下，与 Spring MVC 相关的 Metrics 带有以下信息标记：<table><thead><tr><th>Tag<th>Description<tbody><tr><td><code>exception</code><td>处理请求时引发的任何异常的简单类名。<tr><td><code>method</code><td>请求的方法(例如<code>GET</code>或<code>POST</code>)<tr><td><code>outcome</code><td>请求的结果基于响应的状态码。 1xx 是<code>INFORMATIONAL</code>，2xx 是<code>SUCCESS</code>，3xx 是<code>REDIRECTION</code>，4xx <code>CLIENT_ERROR</code>，5xx 是<code>SERVER_ERROR</code><tr><td><code>status</code><td>响应的 HTTP 状态代码(例如<code>200</code>或<code>500</code>)<tr><td><code>uri</code><td>变量替换之前的请求 URI 模板(如果可能)(例如<code>/api/person/{id}</code>)</table><p>要自定义标签，请提供实现<code>WebMvcTagsProvider</code>的<code>@Bean</code>。<h4 id=4-6-3-2、Spring-WebFlux-Metrics><a title="4.6.3.2、Spring WebFlux Metrics" class=headerlink href=#4-6-3-2、Spring-WebFlux-Metrics></a>4.6.3.2、Spring WebFlux Metrics</h4><p>通过自动配置，可以检测 WebFlux 控制器和功能处理程序处理的所有请求。<p>默认情况下，使用名称<code>http.server.requests</code>生成度量。您可以通过设置<code>management.metrics.web.server.requests-metric-name</code>属性来自定义名称。<p>默认情况下，与 WebFlux 相关的度量标准标记有以下信息：<table><thead><tr><th>Tag<th>Description<tbody><tr><td><code>exception</code><td>处理请求时引发的任何异常的简单类名。<tr><td><code>method</code><td>请求的方法(例如<code>GET</code>或<code>POST</code>)<tr><td><code>outcome</code><td>请求的结果基于响应的状态码。 1xx 是<code>INFORMATIONAL</code>，2xx 是<code>SUCCESS</code>，3xx 是<code>REDIRECTION</code>，4xx <code>CLIENT_ERROR</code>，5xx 是<code>SERVER_ERROR</code><tr><td><code>status</code><td>响应的 HTTP 状态代码(例如<code>200</code>或<code>500</code>)<tr><td><code>uri</code><td>变量替换之前的请求 URI 模板(如果可能)(例如<code>/api/person/{id}</code>)</table><p>要自定义标签，请提供实现<code>WebFluxTagsProvider</code>的<code>@Bean</code>。<h4 id=4-6-3-3、Jersey-服务器-Metrics><a title="4.6.3.3、Jersey 服务器 Metrics" class=headerlink href=#4-6-3-3、Jersey-服务器-Metrics></a>4.6.3.3、Jersey 服务器 Metrics</h4><p>通过自动配置，可以检测由 Jersey JAX-RS 实现处理的请求。当<code>management.metrics.web.server.auto-time-requests</code>为<code>true</code>时，将对所有请求进行检测。或者，当设置为<code>false</code>时，可以通过将<code>@Timed</code>添加到请求处理方法来启用检测：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=meta>@Path("/api/people")</span></span><br><span class=line><span class=meta>@Timed</span> (<span class=number>1</span>)</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Endpoint</span> {</span><br><span class=line>	<span class=meta>@GET</span></span><br><span class=line>	<span class=meta>@Timed(extraTags = { "region", "us-east-1" })</span> (<span class=number>2</span>)</span><br><span class=line>	<span class=meta>@Timed(value = "all.people", longTask = true)</span> (<span class=number>3</span>)</span><br><span class=line>	<span class=keyword>public</span> List&LTPerson> <span class="title function_">listPeople</span><span class=params>()</span> { ... }</span><br><span class=line>}</span><br></pre></table></figure><ul><li><strong>(1)</strong> 在资源类上，以对资源中的每个请求处理程序启用计时。<li><strong>(2)</strong> 关于启用单个端点的方法。如果您将它放在类中，则不必这样做，但是可以用于进一步为此特定端点自定义计时器。<li><strong>(3)</strong> 在具有<code>longTask = true</code>的方法上为该方法启用长任务计时器。长任务计时器需要一个单独的度量标准名称，并且可以与短任务计时器堆叠在一起。</ul><p>默认情况下，使用名称<code>http.server.requests</code>生成度量。可以通过设置<code>management.metrics.web.server.requests-metric-name</code>属性来自定义名称。<p>默认情况下，Jersey 服务器 Metrics 带有以下信息：<table><thead><tr><th>Tag<th>Description<tbody><tr><td><code>exception</code><td>处理请求时引发的任何异常的简单类名。<tr><td><code>method</code><td>请求的方法(例如<code>GET</code>或<code>POST</code>)<tr><td><code>outcome</code><td>请求的结果基于响应的状态码。 1xx 是<code>INFORMATIONAL</code>，2xx 是<code>SUCCESS</code>，3xx 是<code>REDIRECTION</code>，4xx <code>CLIENT_ERROR</code>，5xx 是<code>SERVER_ERROR</code><tr><td><code>status</code><td>响应的 HTTP 状态代码(例如<code>200</code>或<code>500</code>)<tr><td><code>uri</code><td>变量替换之前的请求 URI 模板(如果可能)(例如<code>/api/person/{id}</code>)</table><p>要自定义标签，请提供实现<code>JerseyTagsProvider</code>的<code>@Bean</code>。<h4 id=4-6-3-4、HTTP-Client-端-Metrics><a title="4.6.3.4、HTTP Client 端 Metrics" class=headerlink href=#4-6-3-4、HTTP-Client-端-Metrics></a>4.6.3.4、HTTP Client 端 Metrics</h4><p>Spring Boot Actuator Management<code>RestTemplate</code>和<code>WebClient</code>的工具。为此，您必须注入自动配置的构建器并使用它来创建实例：<ul><li><code>RestTemplateBuilder</code> <code>RestTemplate</code><li><code>WebClient.Builder</code> <code>WebClient</code></ul><p>也可以手动应用负责此工具的定制程序，即<code>MetricsRestTemplateCustomizer</code>和<code>MetricsWebClientCustomizer</code>。<p>默认情况下，使用名称<code>http.client.requests</code>生成度量。可以通过设置<code>management.metrics.web.client.requests-metric-name</code>属性来自定义名称。<p>默认情况下，由检测的 Client 端生成的度量标准标记有以下信息：<ul><li><code>method</code>，即请求的方法(例如<code>GET</code>或<code>POST</code>)。<li><code>uri</code>，变量替换之前的请求 URI 模板(如果可能的话，例如<code>/api/person/{id}</code>)。<li><code>status</code>，即响应的 HTTP 状态代码(例如<code>200</code>或<code>500</code>)。<li><code>clientName</code>，即 URI 的主机部分。</ul><p>要自定义标签，并根据您选择的 Client 端，可以提供实现<code>RestTemplateExchangeTagsProvider</code>或<code>WebClientExchangeTagsProvider</code>的<code>@Bean</code>。 <code>RestTemplateExchangeTags</code>和<code>WebClientExchangeTags</code>中有便捷的静态函数。<h4 id=4-6-3-5、缓存-Metrics><a title="4.6.3.5、缓存 Metrics" class=headerlink href=#4-6-3-5、缓存-Metrics></a>4.6.3.5、缓存 Metrics</h4><p>通过自动配置，可以在启动时使用前缀<code>cache</code>的度量来检测所有可用的<code>Cache</code>。高速缓存检测针对一组基本 Metrics 进行了标准化。还提供其他特定于缓存的 Metrics。<p>支持以下缓存库：<ul><li>Caffeine<li>EhCache 2<li>Hazelcast<li>任何兼容的 JCache(JSR-107)实现</ul><p>用高速缓存的名称和从 Bean 名称派生的<code>CacheManager</code>的名称来标记度量标准。<h4 id=4-6-3-6、数据源-Metrics><a title="4.6.3.6、数据源 Metrics" class=headerlink href=#4-6-3-6、数据源-Metrics></a>4.6.3.6、数据源 Metrics</h4><p>通过自动配置，可以使用名为<code>jdbc</code>的度量标准检测所有可用的<code>DataSource</code>对象。数据源检测产生的量规表示池中当前 Active，最大允许和最小允许的连接。这些仪表中的每个都有一个以<code>jdbc</code>为前缀的名称。<p>度量标准还标有根据 Bean 名称计算出的<code>DataSource</code>的名称。<blockquote><p>默认情况下，Spring Boot 为所有支持的数据源提供元数据。如果不支持立即使用您喜欢的数据源，则可以添加其他<code>DataSourcePoolMetadataProvider</code> bean。有关示例，请参见<code>DataSourcePoolMetadataProvidersConfiguration</code>。</blockquote><p>此外，特定于 Hikari 的 Metrics 以<code>hikaricp</code>前缀公开。每个度量标准都由池的名称标记(可以使用<code>spring.datasource.name</code>进行控制)。<h4 id=4-6-3-7、HibernateMetrics><a class=headerlink href=#4-6-3-7、HibernateMetrics title=4.6.3.7、HibernateMetrics></a>4.6.3.7、HibernateMetrics</h4><p>通过自动配置，可以检测所有可用名为<code>hibernate</code>的 Metrics 启用了统计信息的 Hibernate <code>EntityManagerFactory</code>实例。<p>度量标准还标有从 Bean 名称派生的<code>EntityManagerFactory</code>的名称。<p>要启用统计信息，必须将标准 JPA 属性<code>hibernate.generate_statistics</code>设置为<code>true</code>。您可以在自动配置的<code>EntityManagerFactory</code>上启用它，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>spring.jpa.properties.hibernate.generate_statistics=true</span><br></pre></table></figure><h4 id=4-6-3-8、RabbitMQ-Metrics><a title="4.6.3.8、RabbitMQ Metrics" class=headerlink href=#4-6-3-8、RabbitMQ-Metrics></a>4.6.3.8、RabbitMQ Metrics</h4><p>自动配置将启用所有名为<code>rabbitmq</code>的度量的可用 RabbitMQ 连接工厂的检测。<h3 id=4-6-4、注册自定义-Metrics><a title="4.6.4、注册自定义 Metrics" class=headerlink href=#4-6-4、注册自定义-Metrics></a>4.6.4、注册自定义 Metrics</h3><p>要注册自定义 Metrics，请在组件中注入<code>MeterRegistry</code>，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">Dictionary</span> {</span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>final</span> List&LTString> words = <span class=keyword>new</span> <span class="title class_">CopyOnWriteArrayList</span><>();</span><br><span class=line>	Dictionary(MeterRegistry registry) {</span><br><span class=line>		registry.gaugeCollectionSize(<span class=string>"dictionary.size"</span>, Tags.empty(), <span class=built_in>this</span>.words);</span><br><span class=line>	}</span><br><span class=line>	<span class=comment>// …</span></span><br><span class=line>}</span><br></pre></table></figure><p>如果发现您在组件或应用程序中反复测试了一套 Metrics，则可以将此套件封装在<code>MeterBinder</code>实现中。默认情况下，所有<code>MeterBinder</code> bean 的度量将自动绑定到 Spring Management 的<code>MeterRegistry</code>。<h3 id=4-6-5、自定义单个-Metrics><a title="4.6.5、自定义单个 Metrics" class=headerlink href=#4-6-5、自定义单个-Metrics></a>4.6.5、自定义单个 Metrics</h3><p>如果您需要对特定的<code>Meter</code>实例应用自定义设置，则可以使用<code>io.micrometer.core.instrument.config.MeterFilter</code>界面。默认情况下，所有<code>MeterFilter</code> bean 将自动应用于千分尺<code>MeterRegistry.Config</code>。<p>例如，如果要将所有以<code>com.example</code>开头的仪表 ID 的<code>mytag.region</code>标签重命名为<code>mytag.area</code>，则可以执行以下操作：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> MeterFilter <span class="title function_">renameRegionTagMeterFilter</span><span class=params>()</span> {</span><br><span class=line>	<span class=keyword>return</span> MeterFilter.renameTag(<span class=string>"com.example"</span>, <span class=string>"mytag.region"</span>, <span class=string>"mytag.area"</span>);</span><br><span class=line>}</span><br></pre></table></figure><h4 id=4-6-5-1、常用标签><a class=headerlink href=#4-6-5-1、常用标签 title=4.6.5.1、常用标签></a>4.6.5.1、常用标签</h4><p>通用标签通常用于在操作环境(如主机，实例，区域，堆栈等)上进行维度深入分析。通用标签适用于所有仪表，可以按以下示例所示进行配置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>management.metrics.tags.region=us-east-1</span><br><span class=line>management.metrics.tags.stack=prod</span><br></pre></table></figure><p>上面的示例将<code>region</code>和<code>stack</code>标签添加到所有仪表，其值分别为<code>us-east-1</code>和<code>prod</code>。<blockquote><p>如果使用 Graphite，则常用标签的 Sequences 很重要。由于使用这种方法不能保证通用标签的 Sequences，因此建议 Graphite 用户定义自定义<code>MeterFilter</code>。</blockquote><h4 id=4-6-5-2、每米属性><a class=headerlink href=#4-6-5-2、每米属性 title=4.6.5.2、每米属性></a>4.6.5.2、每米属性</h4><p>除了<code>MeterFilter</code> bean 外，还可以使用属性在每米基础上应用有限的一组自定义设置。每表定制适用于以给定名称开头的所有所有表 ID。例如，以下将禁用所有 ID 以<code>example.remote</code>开头的仪表<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.metrics.enable.example.remote=false</span><br></pre></table></figure><p>以下属性允许按米自定义：<p><strong>表 57.1. 每米自定义</strong><table><thead><tr><th>Property<th>Description<tbody><tr><td><code>management.metrics.enable</code><td>是否拒绝仪表发出任何 Metrics。<tr><td><code>management.metrics.distribution.percentiles-histogram</code><td>是否发布适合计算可凝集(跨维度)百分位数逼近的直方图。<tr><td><code>management.metrics.distribution.minimum-expected-value</code> , <code>management.metrics.distribution.maximum-expected-value</code><td>通过限制期望值的范围来发布较少的直方图桶。<tr><td><code>management.metrics.distribution.percentiles</code><td>发布在应用程序中计算的百分位值<tr><td><code>management.metrics.distribution.sla</code><td>发布包含您的 SLA 定义的存储区的累积直方图。</table><p>有关<code>percentiles-histogram</code>，<code>percentiles</code>和<code>sla</code>后面的概念的更多详细信息，请参阅千分尺文档的<a href=https://micrometer.io/docs/concepts#_histograms_and_percentiles rel=noopener target=_blank>“直方图和百分位数”部分</a>。<h3 id=4-6-6、Metrics-终结点><a title="4.6.6、Metrics 终结点" class=headerlink href=#4-6-6、Metrics-终结点></a>4.6.6、Metrics 终结点</h3><p>Spring Boot 提供了一个<code>metrics</code>端点，可用于诊断检查应用程序收集的 Metrics。该端点默认情况下不可用，必须公开，有关更多详细信息，请参见<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-endpoints.html#production-ready-endpoints-exposing-endpoints rel=noopener target=_blank>exposing endpoints</a>。<p>导航到<code>/actuator/metrics</code>将显示可用仪表名称的列表。您可以通过提供特定名称作为 selectors 来深入查看有关特定仪表的信息，例如<code>/actuator/metrics/jvm.memory.max</code>。<blockquote><p>您在此处使用的名称应与代码中使用的名称相匹配，而不是已针对其出厂的监视系统进行了命名约定标准化后的名称。换句话说，如果<code>jvm.memory.max</code>由于其蛇形命名约定而在 Prometheus 中显示为<code>jvm_memory_max</code>，则在<code>metrics</code>端点中检查电表时，仍应使用<code>jvm.memory.max</code>作为 selectors。</blockquote><p>您还可以在网址末尾添加任意数量的<code>tag=KEY:VALUE</code>查询参数，以在维度上更深入地了解电表，例如<code>/actuator/metrics/jvm.memory.max?tag=area:nonheap</code>。<blockquote><p>报告的测量值是与仪表名称和已应用的所有标签相匹配的所有仪表的统计信息的<em>和</em>。因此，在上面的示例中，返回的“值”统计量是堆的“代码缓存”，“压缩类空间”和“元空间”区域的最大内存占用量的总和。如果您只想查看“ Metaspace”的最大大小，则可以添加一个额外的<code>tag=id:Metaspace</code>，即<code>/actuator/metrics/jvm.memory.max?tag=area:nonheap&tag=id:Metaspace</code>。</blockquote><h2 id=4-7、Auditing><a class=headerlink href=#4-7、Auditing title=4.7、Auditing></a>4.7、Auditing</h2><p>一旦运行了 Spring Security，Spring Boot Actuator 将具有一个灵活的审核框架，该框架可以发布事件(默认情况下，“身份验证成功”，“失败”和“访问被拒绝”异常)。此功能对于基于身份验证失败的报告和实施锁定策略非常有用。要自定义已发布的安全事件，可以提供自己的<code>AbstractAuthenticationAuditListener</code>和<code>AbstractAuthorizationAuditListener</code>实现。<p>您也可以将审核服务用于自己的业务事件。为此，可以将现有的<code>AuditEventRepository</code>注入到您自己的组件中，然后直接使用它，或者通过 Spring <code>ApplicationEventPublisher</code>发布<code>AuditApplicationEvent</code>(通过实现<code>ApplicationEventPublisherAware</code>)。<h2 id=4-8、HTTP-跟踪><a title="4.8、HTTP 跟踪" class=headerlink href=#4-8、HTTP-跟踪></a>4.8、HTTP 跟踪</h2><p>将为所有 HTTP 请求自动启用跟踪。您可以查看<code>httptrace</code>端点，并获取有关最近 100 次请求-响应交换的基本信息。<h3 id=4-8-1-自定义-HTTP-跟踪><a title="4.8.1 自定义 HTTP 跟踪" class=headerlink href=#4-8-1-自定义-HTTP-跟踪></a>4.8.1 自定义 HTTP 跟踪</h3><p>要自定义每个跟踪中包含的项目，请使用<code>management.trace.http.include</code>配置属性。要进行高级自定义，请考虑注册自己的<code>HttpExchangeTracer</code>实现。<p>默认情况下，使用<code>InMemoryHttpTraceRepository</code>来存储最近 100 次请求-响应交换的跟踪。如果需要扩展容量，则可以定义自己的<code>InMemoryHttpTraceRepository</code> bean 实例。您还可以创建自己的替代<code>HttpTraceRepository</code>实现。<h2 id=4-9、Process-Monitoring><a title="4.9、Process Monitoring" class=headerlink href=#4-9、Process-Monitoring></a>4.9、Process Monitoring</h2><p>在<code>spring-boot</code>模块中，您可以找到两个类来创建通常对过程监视有用的文件：<ul><li><code>ApplicationPidFileWriter</code>创建一个包含应用程序 PID 的文件(默认情况下，在应用程序目录中，文件名为<code>application.pid</code>)。<li><code>WebServerPortFileWriter</code>创建一个(或多个)文件，其中包含正在运行的 Web 服务器的端口(默认情况下，在应用程序目录中，文件名为<code>application.port</code>)。</ul><p>默认情况下，不会激活这些编写器，但是您可以启用：<ul><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-process-monitoring.html#production-ready-process-monitoring-configuration rel=noopener target=_blank>通过扩展配置</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/production-ready-process-monitoring.html#production-ready-process-monitoring-programmatically rel=noopener target=_blank>第 60.2 节“以编程方式”</a></ul><h3 id=4-9-1、扩展配置><a class=headerlink href=#4-9-1、扩展配置 title=4.9.1、扩展配置></a>4.9.1、扩展配置</h3><p>在<code>META-INF/spring.factories</code>文件中，可以激活写入 PID 文件的侦听器，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>org.springframework.context.ApplicationListener=\</span><br><span class=line>org.springframework.boot.context.ApplicationPidFileWriter,\</span><br><span class=line>org.springframework.boot.web.context.WebServerPortFileWriter</span><br></pre></table></figure><h3 id=4-9-2、Programmatically><a class=headerlink href=#4-9-2、Programmatically title=4.9.2、Programmatically></a>4.9.2、Programmatically</h3><p>您还可以通过调用<code>SpringApplication.addListeners(…)</code>方法并传递适当的<code>Writer</code>对象来激活侦听器。此方法还允许您自定义<code>Writer</code>构造函数中的文件名和路径。<h2 id=4-10、Cloud-Foundry-支持><a title="4.10、Cloud Foundry 支持" class=headerlink href=#4-10、Cloud-Foundry-支持></a>4.10、Cloud Foundry 支持</h2><p>Spring Boot 的 Actuator 模块包括额外的支持，当您将其部署到兼容的 Cloud Foundry 实例时就会激活。 <code>/cloudfoundryapplication</code>路径提供了通往所有<code>@Endpoint</code> bean 的备用安全路由。<p>扩展支持使 Cloud Foundry Management UI(例如可用于查看已部署的应用程序的 Web 应用程序)增加了 Spring Boot Actuator 信息。例如，应用程序状态页面可能包含完整的运行状况信息，而不是典型的“正在运行”或“已停止”状态。<blockquote><p>普通用户无法直接访问<code>/cloudfoundryapplication</code>路径。为了使用端点，必须将有效的 UAA 令牌与请求一起传递。</blockquote><h3 id=4-10-1、禁用扩展的-Cloud-Foundry-Actuator-支持><a title="4.10.1、禁用扩展的 Cloud Foundry Actuator 支持" class=headerlink href=#4-10-1、禁用扩展的-Cloud-Foundry-Actuator-支持></a>4.10.1、禁用扩展的 Cloud Foundry Actuator 支持</h3><p>如果要完全禁用<code>/cloudfoundryapplication</code>端点，则可以将以下设置添加到<code>application.properties</code>文件中：<p><strong>application.properties.</strong><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.cloudfoundry.enabled=false</span><br></pre></table></figure><h3 id=4-10-2、Cloud-Foundry-自签名证书><a title="4.10.2、Cloud Foundry 自签名证书" class=headerlink href=#4-10-2、Cloud-Foundry-自签名证书></a>4.10.2、Cloud Foundry 自签名证书</h3><p>默认情况下，对<code>/cloudfoundryapplication</code>个端点的安全性验证会对各种 Cloud Foundry 服务进行 SSL 调用。如果您的 Cloud Foundry UAA 或 Cloud Controller 服务使用自签名证书，则需要设置以下属性：<p><strong>application.properties.</strong><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>management.cloudfoundry.skip-ssl-validation=true</span><br></pre></table></figure><h3 id=4-10-3、自定义上下文路径><a class=headerlink href=#4-10-3、自定义上下文路径 title=4.10.3、自定义上下文路径></a>4.10.3、自定义上下文路径</h3><p>如果服务器的上下文路径已配置为<code>/</code>以外的其他值，则 Cloud Foundry 端点在应用程序的根目录将不可用。例如，如果<code>server.servlet.context-path=/app</code>，Cloud Foundry 端点将在<code>/app/cloudfoundryapplication/*</code>可用。<p>如果您希望 Cloud Foundry 端点始终在<code>/cloudfoundryapplication/*</code>可用，而与服务器的上下文路径无关，则需要在应用程序中进行显式配置。配置将根据所使用的 Web 服务器而有所不同。对于 Tomcat，可以添加以下配置：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> TomcatServletWebServerFactory <span class="title function_">servletWebServerFactory</span><span class=params>()</span> {</span><br><span class=line>	<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">TomcatServletWebServerFactory</span>() {</span><br><span class=line></span><br><span class=line>		<span class=meta>@Override</span></span><br><span class=line>		<span class=keyword>protected</span> <span class=keyword>void</span> <span class="title function_">prepareContext</span><span class=params>(Host host,</span></span><br><span class=line><span class=params>				ServletContextInitializer[] initializers)</span> {</span><br><span class=line>			<span class=built_in>super</span>.prepareContext(host, initializers);</span><br><span class=line>			<span class=type>StandardContext</span> <span class=variable>child</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StandardContext</span>();</span><br><span class=line>			child.addLifecycleListener(<span class=keyword>new</span> <span class="title class_">Tomcat</span>.FixContextListener());</span><br><span class=line>			child.setPath(<span class=string>"/cloudfoundryapplication"</span>);</span><br><span class=line>			<span class=type>ServletContainerInitializer</span> <span class=variable>initializer</span> <span class=operator>=</span> getServletContextInitializer(</span><br><span class=line>					getContextPath());</span><br><span class=line>			child.addServletContainerInitializer(initializer, Collections.emptySet());</span><br><span class=line>			child.setCrossContext(<span class=literal>true</span>);</span><br><span class=line>			host.addChild(child);</span><br><span class=line>		}</span><br><span class=line></span><br><span class=line>	};</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>private</span> ServletContainerInitializer <span class="title function_">getServletContextInitializer</span><span class=params>(String contextPath)</span> {</span><br><span class=line>	<span class=keyword>return</span> (c, context) -> {</span><br><span class=line>		<span class=type>Servlet</span> <span class=variable>servlet</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">GenericServlet</span>() {</span><br><span class=line></span><br><span class=line>			<span class=meta>@Override</span></span><br><span class=line>			<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">service</span><span class=params>(ServletRequest req, ServletResponse res)</span></span><br><span class=line>					<span class=keyword>throws</span> ServletException, IOException {</span><br><span class=line>				<span class=type>ServletContext</span> <span class=variable>context</span> <span class=operator>=</span> req.getServletContext()</span><br><span class=line>						.getContext(contextPath);</span><br><span class=line>				context.getRequestDispatcher(<span class=string>"/cloudfoundryapplication"</span>).forward(req,</span><br><span class=line>						res);</span><br><span class=line>			}</span><br><span class=line></span><br><span class=line>		};</span><br><span class=line>		context.addServlet(<span class=string>"cloudfoundry"</span>, servlet).addMapping(<span class=string>"/*"</span>);</span><br><span class=line>	};</span><br><span class=line>}</span><br></pre></table></figure><h1 id=5、部署-SpringBoot-应用><a title="5、部署 SpringBoot 应用" class=headerlink href=#5、部署-SpringBoot-应用></a>5、部署 SpringBoot 应用</h1><p>在部署应用程序时，Spring Boot 的灵活打包选项提供了很多选择。您可以将 Spring Boot 应用程序部署到各种云平台，容器映像(例如 Docker)或虚拟机/真实机上。<h2 id=5-1、部署到云端><a class=headerlink href=#5-1、部署到云端 title=5.1、部署到云端></a>5.1、部署到云端</h2><p>Spring Boot 的可执行 jar 已为大多数流行的云 PaaS(平台即服务)提供程序准备就绪。这些提供程序往往要求您“自带容器”。他们 Management 应用程序流程(不是专门用于 Java 应用程序)，因此他们需要一个中间层，以使您的应用程序适应运行过程的“云”概念。<p>两家受欢迎的云提供商，Heroku 和 Cloud Foundry，采用了“构建包”方法。 buildpack 将您部署的代码包装在“启动”应用程序所需的任何内容中。它可能是 JDK，也可能是对<code>java</code>的调用，嵌入式 Web 服务器或成熟的应用程序服务器。一个 buildpack 是可插入的，但是理想情况下，您应该能够通过尽可能少的自定义来获得它。这减少了您无法控制的功能的占用空间。它使开发和生产环境之间的差异最小化。<p>理想情况下，您的应用程序像 Spring Boot 可执行 jar 一样，具有打包运行所需的一切。<p>在本节中，我们将介绍如何在“Starter”部分中启动<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/getting-started-first-application.html rel=noopener target=_blank>我们开发的简单应用程序</a>并在云中运行。<h3 id=5-1-1、Cloud-Foundry><a title="5.1.1、Cloud Foundry" class=headerlink href=#5-1-1、Cloud-Foundry></a>5.1.1、Cloud Foundry</h3><p>如果未指定其他构建包，Cloud Foundry 将提供默认的构建包。 Cloud Foundry <a href=https://github.com/cloudfoundry/java-buildpack rel=noopener target=_blank>Java buildpack</a>对 Spring 应用程序(包括 Spring Boot)提供了出色的支持。您可以部署独立的可执行 jar 应用程序以及传统的<code>.war</code>打包应用程序。<p>一旦构建了应用程序(例如，使用<code>mvn clean package</code>)并拥有<a href=https://docs.cloudfoundry.org/cf-cli/install-go-cli.html rel=noopener target=_blank>安装了 cf 命令行工具</a>，就可以使用<code>cf push</code>命令部署您的应用程序，并替换已编译的<code>.jar</code>的路径。在推送应用程序之前，请确保拥有<a href=https://docs.cloudfoundry.org/cf-cli/getting-started.html#login rel=noopener target=_blank>使用 cf 命令行 Client 端登录</a>。以下行显示了使用<code>cf push</code>命令部署应用程序：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>cf push acloudyspringtime -p target/demo-0.0.1-SNAPSHOT.jar</span></span><br></pre></table></figure><blockquote><p>在前面的示例中，我们用<code>acloudyspringtime</code>代替您给<code>cf</code>作为应用程序名称的任何值。</blockquote><p>有关更多选项，请参见<a href=https://docs.cloudfoundry.org/cf-cli/getting-started.html#push rel=noopener target=_blank>cf 推文档</a>。如果同一目录中存在 Cloud Foundry <a href=https://docs.cloudfoundry.org/devguide/deploy-apps/manifest.html rel=noopener target=_blank>manifest.yml</a>文件，则认为该文件。<p>此时，<code>cf</code>开始上载您的应用程序，产生类似于以下示例的输出：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line>Uploading acloudyspringtime... OK</span><br><span class=line>Preparing to start acloudyspringtime... OK</span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Downloaded app package (8.9M)</span></span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Java Buildpack Version: v3.12 (offline) | https://github.com/cloudfoundry/java-buildpack.git#6f25b7e</span></span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Downloading Open Jdk JRE 1.8.0_121 from https://java-buildpack.cloudfoundry.org/openjdk/trusty/x86_64/openjdk-1.8.0_121.tar.gz (found <span class=keyword>in</span> cache)</span></span><br><span class=line>       Expanding Open Jdk JRE to .java-buildpack/open_jdk_jre (1.6s)</span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Downloading Open JDK Like Memory Calculator 2.0.2_RELEASE from https://java-buildpack.cloudfoundry.org/memory-calculator/trusty/x86_64/memory-calculator-2.0.2_RELEASE.tar.gz (found <span class=keyword>in</span> cache)</span></span><br><span class=line>       Memory Settings: -Xss349K -Xmx681574K -XX:MaxMetaspaceSize=104857K -Xms681574K -XX:MetaspaceSize=104857K</span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Downloading Container Certificate Trust Store 1.0.0_RELEASE from https://java-buildpack.cloudfoundry.org/container-certificate-trust-store/container-certificate-trust-store-1.0.0_RELEASE.jar (found <span class=keyword>in</span> cache)</span></span><br><span class=line>       Adding certificates to .java-buildpack/container_certificate_trust_store/truststore.jks (0.6s)</span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Downloading Spring Auto Reconfiguration 1.10.0_RELEASE from https://java-buildpack.cloudfoundry.org/auto-reconfiguration/auto-reconfiguration-1.10.0_RELEASE.jar (found <span class=keyword>in</span> cache)</span></span><br><span class=line>Checking status of app 'acloudyspringtime'...</span><br><span class=line>  0 of 1 instances running (1 starting)</span><br><span class=line>  ...</span><br><span class=line>  0 of 1 instances running (1 starting)</span><br><span class=line>  ...</span><br><span class=line>  0 of 1 instances running (1 starting)</span><br><span class=line>  ...</span><br><span class=line>  1 of 1 instances running (1 running)</span><br><span class=line></span><br><span class=line>App started</span><br></pre></table></figure><p>恭喜你！该应用程序现已上线！<p>应用程序上线后，可以使用<code>cf apps</code>命令验证已部署应用程序的状态，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>cf apps</span></span><br><span class=line>Getting applications in ...</span><br><span class=line>OK</span><br><span class=line></span><br><span class=line>name                 requested state   instances   memory   disk   urls</span><br><span class=line>...</span><br><span class=line>acloudyspringtime    started           1/1         512M     1G     acloudyspringtime.cfapps.io</span><br><span class=line>...</span><br></pre></table></figure><p>一旦 Cloud Foundry 确认已部署了您的应用程序，您就应该能够在给定的 URI 上找到该应用程序。在前面的示例中，您可以在<code>http://acloudyspringtime.cfapps.io/</code>找到它。<h4 id=5-1-1-1、绑定到服务><a class=headerlink href=#5-1-1-1、绑定到服务 title=5.1.1.1、绑定到服务></a>5.1.1.1、绑定到服务</h4><p>默认情况下，有关正在运行的应用程序以及服务连接信息的元数据作为环境变量(例如<code>$VCAP_SERVICES</code>)公开给应用程序。该架构决定是由于 Cloud Foundry 的多语言(可以将任何语言和平台支持为 buildpack)所决定的。过程范围的环境变量与语言无关。<p>环境变量并非总是使用最简单的 API，因此 Spring Boot 会自动提取它们并将数据展平为可以通过 Spring 的<code>Environment</code>抽象访问的属性，如以下示例所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">MyBean</span> <span class=keyword>implements</span> <span class="title class_">EnvironmentAware</span> {</span><br><span class=line>	<span class=keyword>private</span> String instanceId;</span><br><span class=line></span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setEnvironment</span><span class=params>(Environment environment)</span> {</span><br><span class=line>		<span class=built_in>this</span>.instanceId = environment.getProperty(<span class=string>"vcap.application.instance_id"</span>);</span><br><span class=line>	}</span><br><span class=line>	<span class=comment>// ...</span></span><br><span class=line>}</span><br></pre></table></figure><p>所有 Cloud Foundry 属性均以<code>vcap</code>为前缀。您可以使用<code>vcap</code>属性来访问应用程序信息(例如应用程序的公共 URL)和服务信息(例如数据库凭据)。有关完整的详细信息，请参见<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/api/org/springframework/boot/cloud/CloudFoundryVcapEnvironmentPostProcessor.html rel=noopener target=_blank>‘CloudFoundryVcapEnvironmentPostProcessor’</a> Javadoc。<blockquote><p><a href=https://cloud.spring.io/spring-cloud-connectors/ rel=noopener target=_blank>Spring Cloud 连接器</a>项目更适合诸如配置数据源之类的任务。 Spring Boot 包括自动配置支持和<code>spring-boot-starter-cloud-connectors</code>启动器。</blockquote><h3 id=5-1-2、Heroku><a class=headerlink href=#5-1-2、Heroku title=5.1.2、Heroku></a>5.1.2、Heroku</h3><p>Heroku 是另一个流行的 PaaS 平台。要自定义 Heroku 构建，请提供<code>Procfile</code>，它提供部署应用程序所需的内容。 Heroku 为 Java 应用程序分配一个<code>port</code>，然后确保路由到外部 URI 起作用。<p>您必须配置您的应用程序以侦听正确的端口。以下示例显示了我们的 Starter REST 应用程序的<code>Procfile</code>：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>web: java -Dserver.port=$PORT -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></table></figure><p>Spring Boot 使<code>-D</code>参数作为可从 Spring <code>Environment</code>实例访问的属性。 <code>server.port</code>配置属性被馈送到嵌入式 Tomcat，Jetty 或 Undertow 实例，然后在启动时使用该端口。 <code>$PORT</code>环境变量是由 Heroku PaaS 分配给我们的。<p>这应该是您需要的一切。 Heroku 部署最常见的部署工作流程是将代码<code>git push</code>投入生产，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>git push heroku master</span></span><br><span class=line></span><br><span class=line>Initializing repository, done.</span><br><span class=line>Counting objects: 95, done.</span><br><span class=line>Delta compression using up to 8 threads.</span><br><span class=line>Compressing objects: 100% (78/78), done.</span><br><span class=line>Writing objects: 100% (95/95), 8.66 MiB | 606.00 KiB/s, done.</span><br><span class=line>Total 95 (delta 31), reused 0 (delta 0)</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Java app detected</span></span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Installing OpenJDK 1.8... <span class=keyword>done</span></span></span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Installing Maven 3.3.1... <span class=keyword>done</span></span></span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Installing settings.xml... <span class=keyword>done</span></span></span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Executing: mvn -B -DskipTests=<span class=literal>true</span> clean install</span></span><br><span class=line></span><br><span class=line>       [INFO] Scanning for projects...</span><br><span class=line>       Downloading: https://repo.spring.io/...</span><br><span class=line>       Downloaded: https://repo.spring.io/... (818 B at 1.8 KB/sec)</span><br><span class=line>		....</span><br><span class=line>       Downloaded: http://s3pository.heroku.com/jvm/... (152 KB at 595.3 KB/sec)</span><br><span class=line>       [INFO] Installing /tmp/build_0c35a5d2-a067-4abc-a232-14b1fb7a8229/target/...</span><br><span class=line>       [INFO] Installing /tmp/build_0c35a5d2-a067-4abc-a232-14b1fb7a8229/pom.xml ...</span><br><span class=line>       [INFO] ------------------------------------------------------------------------</span><br><span class=line>       [INFO] BUILD SUCCESS</span><br><span class=line>       [INFO] ------------------------------------------------------------------------</span><br><span class=line>       [INFO] Total time: 59.358s</span><br><span class=line>       [INFO] Finished at: Fri Mar 07 07:28:25 UTC 2014</span><br><span class=line>       [INFO] Final Memory: 20M/493M</span><br><span class=line>       [INFO] ------------------------------------------------------------------------</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Discovering process types</span></span><br><span class=line>       Procfile declares types -> web</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Compressing... <span class=keyword>done</span>, 70.4MB</span></span><br><span class=line><span class="meta prompt_">-----> </span><span class=language-bash>Launching... <span class=keyword>done</span>, v6</span></span><br><span class=line>       http://agile-sierra-1405.herokuapp.com/ deployed to Heroku</span><br><span class=line></span><br><span class=line>To [emailprotected]:agile-sierra-1405.git</span><br><span class=line> * [new branch]      master -> master</span><br></pre></table></figure><p>您的应用程序现在应该已经在 Heroku 上启动并运行了。<h3 id=5-1-3、OpenShift><a class=headerlink href=#5-1-3、OpenShift title=5.1.3、OpenShift></a>5.1.3、OpenShift</h3><p><a href=https://www.openshift.com/ rel=noopener target=_blank>OpenShift</a>是 Kubernetes 容器编排平台的 Red Hat 公共(和企业)扩展。与 Kubernetes 相似，OpenShift 具有许多用于安装基于 Spring Boot 的应用程序的选项。<p>OpenShift 有许多资源描述了如何部署 Spring Boot 应用程序，包括：<ul><li><a href=https://blog.openshift.com/using-openshift-enterprise-grade-spring-boot-deployments/ rel=noopener target=_blank>使用 S2I 构建器</a><li><a href=https://access.redhat.com/documentation/en-us/reference_architectures/2017/html-single/spring_boot_microservices_on_red_hat_openshift_container_platform_3/ rel=noopener target=_blank>Architecture guide</a><li><a href=https://blog.openshift.com/using-spring-boot-on-openshift/ rel=noopener target=_blank>在 Wildfly 上作为传统的 Web 应用程序运行</a><li><a href=https://blog.openshift.com/openshift-commons-briefing-96-cloud-native-applications-spring-rhoar/ rel=noopener target=_blank>OpenShift 公共简报</a></ul><h3 id=5-1-4、Amazon-Web-Services-AWS><a title="5.1.4、Amazon Web Services(AWS)" class=headerlink href=#5-1-4、Amazon-Web-Services-AWS></a>5.1.4、Amazon Web Services(AWS)</h3><p>Amazon Web Services 提供了多种安装基于 Spring Boot 的应用程序的方法，这些方法既可以作为传统的 Web 应用程序(war)，也可以作为具有嵌入式 Web 服务器的可执行 jar 文件安装。选项包括：<ul><li>AWS Elastic Beanstalk<li>AWS Code Deploy<li>AWS OPS 作品<li>AWS 云形成<li>AWS 容器注册表</ul><p>每个都有不同的功能和定价模型。在本文档中，我们仅描述最简单的选项：AWS Elastic Beanstalk。<h4 id=5-1-4-1、AWS-Elastic-Beanstalk><a title="5.1.4.1、AWS Elastic Beanstalk" class=headerlink href=#5-1-4-1、AWS-Elastic-Beanstalk></a>5.1.4.1、AWS Elastic Beanstalk</h4><p>如官方<a href=https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_Java.html rel=noopener target=_blank>Elastic Beanstalk Java 指南</a>中所述，部署 Java 应用程序有两个主要选项。您可以使用“ Tomcat 平台”或“ Java SE 平台”。<h5 id=使用-Tomcat-平台><a title="使用 Tomcat 平台" class=headerlink href=#使用-Tomcat-平台></a>使用 Tomcat 平台</h5><p>该选项适用于产生 war 文件的 Spring Boot 项目。无需特殊配置。您只需要遵循官方指南即可。<h5 id=使用-Java-SE-平台><a title="使用 Java SE 平台" class=headerlink href=#使用-Java-SE-平台></a>使用 Java SE 平台</h5><p>该选项适用于产生 jar 文件并运行嵌入式 Web 容器的 Spring Boot 项目。 Elastic Beanstalk 环境在端口 80 上运行 nginx 实例以代理在端口 5000 上运行的实际应用程序。要对其进行配置，请将以下行添加到<code>application.properties</code>文件：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>server.port=5000</span><br></pre></table></figure><blockquote><p>默认情况下，Elastic Beanstalk 上载源并在 AWS 中进行编译。但是，最好改为上传二进制文件。为此，请在您的<code>.elasticbeanstalk/config.yml</code>文件中添加类似于以下内容的行：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>deploy:</span></span><br><span class=line>	<span class=attr>artifact:</span> <span class=string>target/demo-0.0.1-SNAPSHOT.jar</span></span><br></pre></table></figure><p>默认情况下，Elastic Beanstalk 环境是负载平衡的。负载均衡器的成本很高。为避免该开销，请按照<a href=https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/environments-create-wizard.html#environments-create-wizard-capacity rel=noopener target=_blank>亚马逊文档</a>所述将环境类型设置为“单个实例”。您还可以使用 CLI 和以下命令来创建单实例环境：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>eb create -s</span><br></pre></table></figure></blockquote><h4 id=5-1-4-2、Summary><a class=headerlink href=#5-1-4-2、Summary title=5.1.4.2、Summary></a>5.1.4.2、Summary</h4><p>这是通向 AWS 的最简单方法之一，但还有更多内容要讲，例如如何将 Elastic Beanstalk 集成到任何 CI/CD 工具中，如何使用 Elastic Beanstalk Maven 插件而不是 CLI 等等。 <a href=https://exampledriven.wordpress.com/2017/01/09/spring-boot-aws-elastic-beanstalk-example/ rel=noopener target=_blank>blog post</a>详细介绍了这些主题。<h3 id=5-1-5、Boxfuse-和-Amazon-Web-Services><a title="5.1.5、Boxfuse 和 Amazon Web Services" class=headerlink href=#5-1-5、Boxfuse-和-Amazon-Web-Services></a>5.1.5、Boxfuse 和 Amazon Web Services</h3><p><a href=https://boxfuse.com/ rel=noopener target=_blank>Boxfuse</a>通过将您的 Spring Boot 可执行 jar 或 war 变成一个最小的 VM 映像来工作，该映像可以在 VirtualBox 或 AWS 上不变地部署。 Boxfuse 与 Spring Boot 进行了深度集成，并使用 Spring Boot 配置文件中的信息自动配置端口和运行状况检查 URL。 Boxfuse 在生成的图像以及它提供的所有资源(实例，安全组，弹性负载均衡器等)中均利用此信息。<p>创建<a href=https://console.boxfuse.com/ rel=noopener target=_blank>Boxfuse account</a>，将其连接到您的 AWS 账户，安装最新版本的 Boxfuse Client 并确保该应用程序已由 Maven 或 Gradle 构建(通过使用<code>mvn clean package</code>)后，就可以部署 Spring 使用与以下类似的命令将应用程序引导到 AWS：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>boxfuse run myapp-1.0.jar -<span class=built_in>env</span>=prod</span></span><br></pre></table></figure><p>有关更多选项，请参见<a href=https://boxfuse.com/docs/commandline/run.html rel=noopener target=_blank>boxfuse 运行文档</a>。如果当前目录中存在<a href=https://boxfuse.com/docs/commandline/#configuration rel=noopener target=_blank>boxfuse.conf</a>文件，则将其考虑。<blockquote><p>默认情况下，Boxfuse 在启动时会激活名为<code>boxfuse</code>的 Spring 配置文件。如果您的可执行 jar 或 war 包含<a href=https://boxfuse.com/docs/payloads/springboot.html#configuration rel=noopener target=_blank>application-boxfuse.properties</a>文件，则 Boxfuse 的配置将基于其包含的属性。</blockquote><p>此时，<code>boxfuse</code>为您的应用程序创建一个映像，上传该映像，并在 AWS 上配置和启动必要的资源，其输出类似于以下示例：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line>Fusing Image for myapp-1.0.jar ...</span><br><span class=line>Image fused in 00:06.838s (53937 K) -> axelfontaine/myapp:1.0</span><br><span class=line>Creating axelfontaine/myapp ...</span><br><span class=line>Pushing axelfontaine/myapp:1.0 ...</span><br><span class=line>Verifying axelfontaine/myapp:1.0 ...</span><br><span class=line>Creating Elastic IP ...</span><br><span class=line>Mapping myapp-axelfontaine.boxfuse.io to 52.28.233.167 ...</span><br><span class=line>Waiting for AWS to create an AMI for axelfontaine/myapp:1.0 in eu-central-1 (this may take up to 50 seconds) ...</span><br><span class=line>AMI created in 00:23.557s -> ami-d23f38cf</span><br><span class=line>Creating security group boxfuse-sg_axelfontaine/myapp:1.0 ...</span><br><span class=line>Launching t2.micro instance of axelfontaine/myapp:1.0 (ami-d23f38cf) in eu-central-1 ...</span><br><span class=line>Instance launched in 00:30.306s -> i-92ef9f53</span><br><span class=line>Waiting for AWS to boot Instance i-92ef9f53 and Payload to start at http://52.28.235.61/ ...</span><br><span class=line>Payload started in 00:29.266s -> http://52.28.235.61/</span><br><span class=line>Remapping Elastic IP 52.28.233.167 to i-92ef9f53 ...</span><br><span class=line>Waiting 15s for AWS to complete Elastic IP Zero Downtime transition ...</span><br><span class=line>Deployment completed successfully. axelfontaine/myapp:1.0 is up and running at http://myapp-axelfontaine.boxfuse.io/</span><br></pre></table></figure><p>您的应用程序现在应该已启动并在 AWS 上运行。<p>请参阅<a href=https://boxfuse.com/blog/spring-boot-ec2.html rel=noopener target=_blank>在 EC2 上部署 Spring Boot 应用</a>和<a href=https://boxfuse.com/docs/payloads/springboot.html rel=noopener target=_blank>Boxfuse Spring Boot 集成的文档</a>上的博客文章，以开始使用 Maven 构建来运行该应用程序。<h3 id=5-1-6、Google-Cloud><a title="5.1.6、Google Cloud" class=headerlink href=#5-1-6、Google-Cloud></a>5.1.6、Google Cloud</h3><p>Google Cloud 有多个选项可用于启动 Spring Boot 应用程序。最容易上手的可能是 App Engine，但您也可以找到在 Container Engine 的容器中或 Compute Engine 的虚拟机上运行 Spring Boot 的方法。<p>要在 App Engine 中运行，您可以先在用户界面中创建一个项目，该项目将为您设置一个唯一的标识符，并还设置 HTTP 路由。将 Java 应用程序添加到项目中，并将其保留为空，然后使用<a href=https://cloud.google.com/sdk/downloads rel=noopener target=_blank>Google Cloud SDK</a>从命令行或 CI 构建将 Spring Boot 应用程序推入该插槽。<p>App Engine Standard 要求您使用 WAR 包装。按照<a href=https://github.com/GoogleCloudPlatform/getting-started-java/blob/master/appengine-standard-java8/springboot-appengine-standard/README.md rel=noopener target=_blank>these steps</a>的要求将 App Engine Standard 应用程序部署到 Google Cloud。<p>另外，App Engine Flex 要求您创建一个<code>app.yaml</code>文件来描述您的应用程序所需的资源。通常，您将此文件放在<code>src/main/appengine</code>中，它应类似于以下文件：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line>service: default</span><br><span class=line></span><br><span class=line>runtime: java</span><br><span class=line>env: flex</span><br><span class=line></span><br><span class=line>runtime_config:</span><br><span class=line>  jdk: openjdk8</span><br><span class=line></span><br><span class=line>handlers:</span><br><span class=line>- url: /.*</span><br><span class=line>  script: this field is required, but ignored</span><br><span class=line></span><br><span class=line>manual_scaling:</span><br><span class=line>  instances: 1</span><br><span class=line></span><br><span class=line>health_check:</span><br><span class=line>  enable_health_check: False</span><br><span class=line></span><br><span class=line>env_variables:</span><br><span class=line>  ENCRYPT_KEY: your_encryption_key_here</span><br></pre></table></figure><p>您可以通过将项目 ID 添加到构建配置中来部署应用程序(例如，使用 Maven 插件)，如以下示例所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>plugin</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>com.google.cloud.tools<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>appengine-maven-plugin<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>version</span>></span>1.3.0<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>	<span class=tag><<span class=name>configuration</span>></span></span><br><span class=line>		<span class=tag><<span class=name>project</span>></span>myproject<span class=tag>&LT/<span class=name>project</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>configuration</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>plugin</span>></span></span><br></pre></table></figure><p>然后使用<code>mvn appengine:deploy</code>进行部署(如果您需要先进行身份验证，则构建将失败)。<h2 id=5-2、安装-Spring-Boot-应用程序><a title="5.2、安装 Spring Boot 应用程序" class=headerlink href=#5-2、安装-Spring-Boot-应用程序></a>5.2、安装 Spring Boot 应用程序</h2><p>除了使用<code>java -jar</code>运行 Spring Boot 应用程序外，还可以为 Unix 系统制作完全可执行的应用程序。完全可执行的 jar 可以像其他任何可执行二进制文件一样执行，也可以是<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/deployment-install.html#deployment-service rel=noopener target=_blank>在 init.d 或 systemd 中注册</a>。这使得在普通生产环境中安装和 Management Spring Boot 应用程序变得非常容易。<blockquote><p>完全可执行的 jar 通过在文件的开头嵌入一个额外的脚本来工作。当前，某些工具不接受此格式，因此您可能无法始终使用此技术。例如，<code>jar -xf</code>可能会默默地提取无法完全执行的 jar 或 war。建议仅在打算直接执行 jar 或 war 时才使它们完全可执行，而不是使用<code>java -jar</code>运行它或将其部署到 servlet 容器中。</blockquote><p>要使用 Maven 创建一个“完全可执行”的 jar，请使用以下插件配置：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>plugin</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>spring-boot-maven-plugin<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>configuration</span>></span></span><br><span class=line>		<span class=tag><<span class=name>executable</span>></span>true<span class=tag>&LT/<span class=name>executable</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>configuration</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>plugin</span>></span></span><br></pre></table></figure><p>以下示例显示了等效的 Gradle 配置：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>bootJar {</span><br><span class=line>	launchScript()</span><br><span class=line>}</span><br></pre></table></figure><p>然后，您可以通过键入<code>./my-application.jar</code>(其中<code>my-application</code>是工件的名称)来运行您的应用程序。包含 jar 的目录用作应用程序的工作目录。<h3 id=5-2-1、支持的-os><a title="5.2.1、支持的 os" class=headerlink href=#5-2-1、支持的-os></a>5.2.1、支持的 os</h3><p>默认脚本支持大多数 Linux 发行版，并已在 CentOS 和 Ubuntu 上进行了测试。其他平台，例如 OS X 和 FreeBSD，则需要使用自定义的<code>embeddedLaunchScript</code>。<h3 id=5-2-2、Unix-Linux-服务><a title="5.2.2、Unix/Linux 服务" class=headerlink href=#5-2-2、Unix-Linux-服务></a>5.2.2、Unix/Linux 服务</h3><p>使用<code>init.d</code>或<code>systemd</code>可以轻松地将 Spring Boot 应用程序作为 Unix/Linux 服务启动。<h4 id=5-2-2-1、作为-init-d-服务安装-系统-V><a title="5.2.2.1、作为 init.d 服务安装(系统 V)" class=headerlink href=#5-2-2-1、作为-init-d-服务安装-系统-V></a>5.2.2.1、作为 init.d 服务安装(系统 V)</h4><p>如果您将 Spring Boot 的 Maven 或 Gradle 插件配置为生成<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/deployment-install.html rel=noopener target=_blank>完全可执行的 jar</a>，而不使用自定义<code>embeddedLaunchScript</code>，则您的应用程序可以用作<code>init.d</code>服务。为此，请将 jar 链接到<code>init.d</code>以支持标准<code>start</code>，<code>stop</code>，<code>restart</code>和<code>status</code>命令。<p>该脚本支持以下功能：<ul><li>以拥有 jar 文件的用户身份启动服务<li>使用<code>/var/run/&LTappname>/&LTappname>.pid</code>跟踪应用程序的 PID<li>将控制台日志写入<code>/var/log/&LTappname>.log</code></ul><p>假设您已在<code>/var/myapp</code>中安装了 Spring Boot 应用程序，要将 Spring Boot 应用程序安装为<code>init.d</code>服务，请创建一个符号链接，如下所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>sudo</span> <span class=built_in>ln</span> -s /var/myapp/myapp.jar /etc/init.d/myapp</span></span><br></pre></table></figure><p>安装后，您可以按照通常的方式启动和停止服务。例如，在基于 Debian 的系统上，可以使用以下命令启动它：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>service myapp start</span></span><br></pre></table></figure><blockquote><p>如果您的应用程序无法启动，请检查写入<code>/var/log/&LTappname>.log</code>的日志文件是否有错误。</blockquote><p>您还可以使用标准 os 工具将应用程序标记为自动启动。例如，在 Debian 上，您可以使用以下命令：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>update-rc.d myapp defaults &LTpriority></span></span><br></pre></table></figure><h5 id=保护-init-d-服务><a title="保护 init.d 服务" class=headerlink href=#保护-init-d-服务></a>保护 init.d 服务</h5><p>当以 root 身份执行时(例如使用 root 来启动 init.d 服务时)，默认的可执行脚本以拥有 jar 文件的用户身份运行应用程序。您永远不要以<code>root</code>的身份运行 Spring Boot 应用程序，因此您的应用程序的 jar 文件绝对不应由 root 拥有。而是创建一个特定用户来运行您的应用程序，并使用<code>chown</code>使其成为 jar 文件的所有者，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>chown</span> bootapp:bootapp your-app.jar</span></span><br></pre></table></figure><p>在这种情况下，默认的可执行脚本以<code>bootapp</code>用户身份运行该应用程序。<blockquote><p>为了减少应用程序的用户帐户遭到破坏的机会，应考虑阻止它使用登录 Shell 程序。例如，您可以将帐户的 Shell 设置为<code>/usr/sbin/nologin</code>。</blockquote><p>您还应该采取步骤来防止修改应用程序的 jar 文件。首先，配置其权限，使其不能被写入，只能由其所有者读取或执行，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>chmod</span> 500 your-app.jar</span></span><br></pre></table></figure><p>其次，如果您的应用程序或运行该应用程序的帐户受到威胁，您还应采取措施限制损害。如果攻击者确实获得了访问权限，则他们可以使 jar 文件可写并更改其内容。防止这种情况发生的一种方法是使用<code>chattr</code>使其不变，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>sudo</span> chattr +i your-app.jar</span></span><br></pre></table></figure><p>这将阻止任何用户(包括 root 用户)修改 jar。<p>如果使用 root 来控制应用程序的服务，并且您<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/deployment-install.html#deployment-script-customization-conf-file rel=noopener target=_blank>使用.conf 文件</a>自定义其启动，则 root 用户将读取并评估<code>.conf</code>文件。应该相应地对其进行保护。使用<code>chmod</code>，以便只有所有者可以读取文件，并使用<code>chown</code>将 root 成为所有者，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>chmod</span> 400 your-app.conf</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>sudo</span> <span class=built_in>chown</span> root:root your-app.conf</span></span><br></pre></table></figure><h4 id=5-2-2-2、作为系统服务安装><a class=headerlink href=#5-2-2-2、作为系统服务安装 title=5.2.2.2、作为系统服务安装></a>5.2.2.2、作为系统服务安装</h4><p><code>systemd</code>是 System V init 系统的后继产品，现已被许多现代 Linux 发行版使用。尽管您可以 continue 将_脚本与<code>systemd</code>一起使用，但是也可以通过使用<code>systemd</code>‘service’脚本来启动 Spring Boot 应用程序。<p>假设您已在<code>/var/myapp</code>中安装了 Spring Boot 应用程序，要将 Spring Boot 应用程序安装为<code>systemd</code>服务，请创建名为<code>myapp.service</code>的脚本并将其放置在<code>/etc/systemd/system</code>目录中。以下脚本提供了一个示例：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>[Unit]</span><br><span class=line>Description=myapp</span><br><span class=line>After=syslog.target</span><br><span class=line></span><br><span class=line>[Service]</span><br><span class=line>User=myapp</span><br><span class=line>ExecStart=/var/myapp/myapp.jar</span><br><span class=line>SuccessExitStatus=143</span><br><span class=line></span><br><span class=line>[Install]</span><br><span class=line>WantedBy=multi-user.target</span><br></pre></table></figure><blockquote><p>切记为您的应用程序更改<code>Description</code>，<code>User</code>和<code>ExecStart</code>字段。<p><code>ExecStart</code>字段未声明脚本操作命令，这意味着默认情况下使用<code>run</code>命令。</blockquote><p>请注意，与作为<code>init.d</code>服务运行时不同，运行应用程序，PID 文件和控制台日志文件的用户由<code>systemd</code>本身 Management，因此必须通过在“服务”脚本中使用适当的字段进行配置。有关更多详细信息，请咨询<a href=https://www.freedesktop.org/software/systemd/man/systemd.service.html rel=noopener target=_blank>服务单元配置手册页</a>。<p>要将应用程序标记为在系统启动时自动启动，请使用以下命令：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>systemctl <span class=built_in>enable</span> myapp.service</span></span><br></pre></table></figure><p>有关更多详细信息，请参考<code>man systemctl</code>。<h4 id=5-2-2-3、自定义启动脚本><a class=headerlink href=#5-2-2-3、自定义启动脚本 title=5.2.2.3、自定义启动脚本></a>5.2.2.3、自定义启动脚本</h4><p>由 Maven 或 Gradle 插件编写的默认嵌入式启动脚本可以通过多种方式进行自定义。对于大多数人来说，使用默认脚本和一些自定义设置通常就足够了。如果发现无法自定义所需的内容，请使用<code>embeddedLaunchScript</code>选项完全编写自己的文件。<h5 id=编写后自定义启动脚本><a class=headerlink href=#编写后自定义启动脚本 title=编写后自定义启动脚本></a>编写后自定义启动脚本</h5><p>在将启动脚本写入 jar 文件时，自定义启动脚本的元素通常很有意义。例如，init.d 脚本可以提供“描述”。由于您已经预先了解了描述(并且无需更改)，因此在生成 jar 时也可以提供它。<p>要自定义书面元素，请使用 Spring Boot Maven 插件的<code>embeddedLaunchScriptProperties</code>选项或<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/gradle-plugin/reference/html/#packaging-executable-configuring-launch-script rel=noopener target=_blank>Spring Boot Gradle 插件的 launchScript 的 properties 属性</a>。<p>默认脚本支持以下属性替换：<table><thead><tr><th>Name<th>Description<th>Gradle default<th>Maven default<tbody><tr><td><code>mode</code><td>脚本模式。<td><code>auto</code><td><code>auto</code><tr><td><code>initInfoProvides</code><td>“ INIT INFO”的<code>Provides</code>部分<td><code>${task.baseName}</code><td><code>${project.artifactId}</code><tr><td><code>initInfoRequiredStart</code><td>“ INIT INFO”的<code>Required-Start</code>部分。<td><code>$remote_fs $syslog $network</code><td><code>$remote_fs $syslog $network</code><tr><td><code>initInfoRequiredStop</code><td>“ INIT INFO”的<code>Required-Stop</code>部分。<td><code>$remote_fs $syslog $network</code><td><code>$remote_fs $syslog $network</code><tr><td><code>initInfoDefaultStart</code><td>“ INIT INFO”的<code>Default-Start</code>部分。<td><code>2 3 4 5</code><td><code>2 3 4 5</code><tr><td><code>initInfoDefaultStop</code><td>“ INIT INFO”的<code>Default-Stop</code>部分。<td><code>0 1 6</code><td><code>0 1 6</code><tr><td><code>initInfoShortDescription</code><td>“ INIT INFO”的<code>Short-Description</code>部分。<td>单行版本的<code>${project.description}</code>(回退到<code>${task.baseName}</code>)<td><code>${project.name}</code><tr><td><code>initInfoDescription</code><td>“ INIT INFO”的<code>Description</code>部分。<td><code>${project.description}</code>(回到<code>${task.baseName}</code>)<td><code>${project.description}</code>(回到<code>${project.name}</code>)<tr><td><code>initInfoChkconfig</code><td>“ INIT INFO”的<code>chkconfig</code>部分<td><code>2345 99 01</code><td><code>2345 99 01</code><tr><td><code>confFolder</code><td><code>CONF_FOLDER</code>的默认值<td>包含Jar子的文件夹<td>包含Jar子的文件夹<tr><td><code>inlinedConfScript</code><td>引用应在默认启动脚本中内联的文件脚本。可以在加载任何外部配置文件之前设置环境变量，例如<code>JAVA_OPTS</code><td><td><tr><td><code>logFolder</code><td><code>LOG_FOLDER</code>的默认值。仅对<code>init.d</code>服务有效<td><td><tr><td><code>logFilename</code><td><code>LOG_FILENAME</code>的默认值。仅对<code>init.d</code>服务有效<td><td><tr><td><code>pidFolder</code><td><code>PID_FOLDER</code>的默认值。仅对<code>init.d</code>服务有效<td><td><tr><td><code>pidFilename</code><td>PID 文件名在<code>PID_FOLDER</code>中的默认值。仅对<code>init.d</code>服务有效<td><td><tr><td><code>useStartStopDaemon</code><td><code>start-stop-daemon</code>命令(如果可用)是否应用于控制过程<td><code>true</code><td><code>true</code><tr><td><code>stopWaitTime</code><td><code>STOP_WAIT_TIME</code>的默认值，以秒为单位。仅对<code>init.d</code>服务有效<td>60<td>60</table><h5 id=运行时自定义脚本><a class=headerlink href=#运行时自定义脚本 title=运行时自定义脚本></a>运行时自定义脚本</h5><p>对于<em>在</em>编写 jar 之后需要自定义脚本的项目，可以使用环境变量或<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/deployment-install.html#deployment-script-customization-conf-file rel=noopener target=_blank>config file</a>。<p>默认脚本支持以下环境属性：<table><thead><tr><th>Variable<th>Description<tbody><tr><td><code>MODE</code><td>操作的“模式”。默认值取决于 jar 的构建方式，但通常为<code>auto</code>(这意味着它会通过检查目录<code>init.d</code>中的符号链接来尝试猜测它是否为初始化脚本)。您可以将其显式设置为<code>service</code>，以便`stop<tr><td><code>USE_START_STOP_DAEMON</code><td><code>start-stop-daemon</code>命令(如果可用)是否应用于控制过程。默认为<code>true</code>。<tr><td><code>PID_FOLDER</code><td>pid 文件夹的根名称(默认为<code>/var/run</code>)。<tr><td><code>LOG_FOLDER</code><td>放置日志文件的文件夹的名称(默认为<code>/var/log</code>)。<tr><td><code>CONF_FOLDER</code><td>从中读取.conf 文件的文件夹的名称(默认情况下与 jar 文件相同的文件夹)。<tr><td><code>LOG_FILENAME</code><td><code>LOG_FOLDER</code>(默认为<code>&LTappname>.log</code>)中的日志文件名称。<tr><td><code>APP_NAME</code><td>应用程序的名称。如果 jar 是从符号链接运行的，则脚本会猜测该应用程序的名称。如果它不是符号链接，或者您要显式设置应用程序名称，则这将很有用。<tr><td><code>RUN_ARGS</code><td>传递给程序的参数(Spring Boot 应用程序)。<tr><td><code>JAVA_HOME</code><td>默认情况下，通过使用<code>PATH</code>发现<code>java</code>可执行文件的位置，但是如果<code>$JAVA_HOME/bin/java</code>处有可执行文件，则可以显式设置它。<tr><td><code>JAVA_OPTS</code><td>启动 JVM 时传递给 JVM 的选项。<tr><td><code>JARFILE</code><td>jar 文件的显式位置，以防脚本用于启动实际上未嵌入的 jar。<tr><td><code>DEBUG</code><td>如果不为空，请在 shell 进程中设置<code>-x</code>标志，从而易于查看脚本中的逻辑。<tr><td><code>STOP_WAIT_TIME</code><td>停止应用程序之前要强制关闭的 await 时间(以秒为单位)(默认为<code>60</code>)。</table><blockquote><p><code>PID_FOLDER</code>，<code>LOG_FOLDER</code>和<code>LOG_FILENAME</code>变量仅对<code>init.d</code>服务有效。对于<code>systemd</code>，使用’service’脚本进行等效的自定义。有关更多详细信息，请参见<a href=https://www.freedesktop.org/software/systemd/man/systemd.service.html rel=noopener target=_blank>服务单元配置手册页</a>。</blockquote><p>除<code>JARFILE</code>和<code>APP_NAME</code>以外，可以使用<code>.conf</code>文件配置上一节中列出的设置。该文件应位于 jar 文件的旁边，并且具有相同的名称，但后缀为<code>.conf</code>而不是<code>.jar</code>。例如，名为<code>/var/myapp/myapp.jar</code>的 jar 使用名为<code>/var/myapp/myapp.conf</code>的配置文件，如以下示例所示：<p><strong>myapp.conf.</strong><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>JAVA_OPTS=-Xmx1024M</span><br><span class=line>LOG_FOLDER=/custom/log/folder</span><br></pre></table></figure><blockquote><p>如果您不喜欢将配置文件放在 jar 文件旁边，则可以设置<code>CONF_FOLDER</code>环境变量以自定义配置文件的位置。</blockquote><h3 id=5-2-3、Microsoft-Windows-服务><a title="5.2.3、Microsoft Windows 服务" class=headerlink href=#5-2-3、Microsoft-Windows-服务></a>5.2.3、Microsoft Windows 服务</h3><p>可以使用<a href=https://github.com/kohsuke/winsw rel=noopener target=_blank>winsw</a>将 Spring Boot 应用程序作为 Windows 服务启动。<p>(<a href=https://github.com/snicoll-scratches/spring-boot-daemon rel=noopener target=_blank>单独维护的 samples</a>)分步说明了如何为 Spring Boot 应用程序创建 Windows 服务。<h1 id=6、Spring-Boot-CLI><a title="6、Spring Boot CLI" class=headerlink href=#6、Spring-Boot-CLI></a>6、Spring Boot CLI</h1><p>Spring Boot CLI 是一个命令行工具，如果您想快速开发 Spring 应用程序，可以使用它。它使您可以运行 Groovy 脚本，这意味着您具有类似 Java 的熟悉语法，而没有太多样板代码。您还可以引导一个新项目或为其编写自己的命令。<h2 id=6-1、安装CLI><a class=headerlink href=#6-1、安装CLI title=6.1、安装CLI></a>6.1、安装CLI</h2><p>可以使用 SDKMAN 手动安装 Spring Boot CLI(命令行界面)！ (SDK Manager)或使用 Homebrew 或 MacPorts(如果您是 OSX 用户)。有关全面的安装说明，请参阅“Starter”部分中的* <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/getting-started-installing-spring-boot.html#getting-started-installing-the-cli rel=noopener target=_blank>第 10.2 节“安装 Spring Boot CLI”</a> *。<h2 id=6-2、使用CLI><a class=headerlink href=#6-2、使用CLI title=6.2、使用CLI></a>6.2、使用CLI</h2><p>安装 CLI 后，可以通过键入<code>spring</code>并在命令行中按 Enter 来运行它。如果您不带任何参数运行<code>spring</code>，则会显示一个简单的帮助屏幕，如下所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring</span></span><br><span class=line>usage: spring [--help] [--version]</span><br><span class=line>       &LTcommand> [&LTargs>]</span><br><span class=line></span><br><span class=line>Available commands are:</span><br><span class=line></span><br><span class=line>  run [options] &LTfiles> [--] [args]</span><br><span class=line>    Run a spring groovy script</span><br><span class=line></span><br><span class=line>  ... more command help is shown here</span><br></pre></table></figure><p>您可以键入<code>spring help</code>以获取有关任何受支持命令的更多详细信息，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring <span class=built_in>help</span> run</span></span><br><span class=line>spring run - Run a spring groovy script</span><br><span class=line></span><br><span class=line>usage: spring run [options] &LTfiles> [--] [args]</span><br><span class=line></span><br><span class=line>Option                     Description</span><br><span class=line>------                     -----------</span><br><span class=line>--autoconfigure [Boolean]  Add autoconfigure compiler</span><br><span class=line>                             transformations (default: true)</span><br><span class=line>--classpath, -cp           Additional classpath entries</span><br><span class=line>-e, --edit                 Open the file with the default system</span><br><span class=line>                             editor</span><br><span class=line>--no-guess-dependencies    Do not attempt to guess dependencies</span><br><span class=line>--no-guess-imports         Do not attempt to guess imports</span><br><span class=line>-q, --quiet                Quiet logging</span><br><span class=line>-v, --verbose              Verbose logging of dependency</span><br><span class=line>                             resolution</span><br><span class=line>--watch                    Watch the specified file for changes</span><br></pre></table></figure><p><code>version</code>命令提供了一种快速的方法来检查您正在使用的 Spring Boot 版本，如下所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring version</span></span><br><span class=line>Spring CLI v2.1.1.RELEASE</span><br></pre></table></figure><h3 id=6-2-1、使用-CLI-运行应用程序><a title="6.2.1、使用 CLI 运行应用程序" class=headerlink href=#6-2-1、使用-CLI-运行应用程序></a>6.2.1、使用 CLI 运行应用程序</h3><p>您可以使用<code>run</code>命令来编译和运行 Groovy 源代码。 Spring Boot CLI 是完全独立的，因此您不需要任何外部 Groovy 安装。<p>以下示例显示了用 Groovy 编写的“ hello world” Web 应用程序：<p><strong>hello.groovy.</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@RestController</span></span><br><span class=line><span class=keyword>class</span> <span class="title class_">WebApplication</span> {</span><br><span class=line>	<span class=meta>@RequestMapping("/")</span></span><br><span class=line>	String <span class="title function_">home</span><span class=params>()</span> {</span><br><span class=line>		<span class=string>"Hello World!"</span></span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>要编译并运行该应用程序，请键入以下命令：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring run hello.groovy</span></span><br></pre></table></figure><p>要将命令行参数传递给应用程序，请使用<code>--</code>将命令与“ spring”命令参数分开，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring run hello.groovy -- --server.port=9000</span></span><br></pre></table></figure><p>要设置 JVM 命令行参数，可以使用<code>JAVA_OPTS</code>环境变量，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>JAVA_OPTS=-Xmx1024m spring run hello.groovy</span></span><br></pre></table></figure><blockquote><p>在 Microsoft Windows 上设置<code>JAVA_OPTS</code>时，请确保引用整个指令，例如<code>set "JAVA_OPTS=-Xms256m -Xmx2048m"</code>。这样做可以确保将值正确传递给流程。</blockquote><h4 id=6-2-1-1、推论”grab”依赖性><a class=headerlink href=#6-2-1-1、推论”grab”依赖性 title=6.2.1.1、推论”grab”依赖性></a>6.2.1.1、推论”grab”依赖性</h4><p>标准 Groovy 包含<code>@Grab</code>注解，该注解使您可以声明对第三方库的依赖关系。 Groovy 可以使用这种有用的技术以与 Maven 或 Gradle 相同的方式下载 jar，而无需使用构建工具。<p>Spring Boot 进一步扩展了该技术，并尝试根据您的代码推断出哪些库可以“抢”。例如，由于先前显示的<code>WebApplication</code>代码使用<code>@RestController</code>注解，因此 Spring Boot 会捕获“ Tomcat”和“ Spring MVC”。<p>以下各项用作“抓取提示”：<table><thead><tr><th>Items<th>Grabs<tbody><tr><td><code>JdbcTemplate</code> , <code>NamedParameterJdbcTemplate</code> , <code>DataSource</code><td>JDBC Application.<tr><td><code>@EnableJms</code><td>JMS Application.<tr><td><code>@EnableCaching</code><td>Caching abstraction.<tr><td><code>@Test</code><td>JUnit.<tr><td><code>@EnableRabbit</code><td>RabbitMQ.<tr><td>延伸<code>Specification</code><td>Spock test.<tr><td><code>@EnableBatchProcessing</code><td>Spring Batch.<tr><td><code>@MessageEndpoint</code> <code>@EnableIntegration</code><td>Spring Integration.<tr><td><code>@Controller</code> <code>@RestController</code> <code>@EnableWebMvc</code><td>Spring MVC 嵌入式 Tomcat。<tr><td><code>@EnableWebSecurity</code><td>Spring Security.<tr><td><code>@EnableTransactionManagement</code><td>SpringTransactionManagement。</table><blockquote><p>请参阅 Spring Boot CLI 源代码中的<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-cli/src/main/java/org/springframework/boot/cli/compiler/CompilerAutoConfiguration.java rel=noopener target=_blank>CompilerAutoConfiguration</a>的子类，以确切地了解如何应用定制。</blockquote><h4 id=6-2-1-2、推导”grab”坐标><a class=headerlink href=#6-2-1-2、推导”grab”坐标 title=6.2.1.2、推导”grab”坐标></a>6.2.1.2、推导”grab”坐标</h4><p>Spring Boot 通过允许您指定不带组或版本的依赖项(例如<code>@Grab('freemarker')</code>)来扩展 Groovy 的标准<code>@Grab</code>支持。这样做可以参考 Spring Boot 的默认依赖元数据来推断工件的组和版本。<blockquote><p>默认元数据与您使用的 CLI 版本相关。仅当您移至新版本的 CLI 时，它才会更改，从而使您可以控制依赖项的版本何时更改。可以在<a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/appendix-dependency-versions.html rel=noopener target=_blank>appendix</a>中找到一个表格，其中显示了默认元数据中包含的依赖项及其版本。</blockquote><h4 id=6-2-1-3、默认导入语句><a class=headerlink href=#6-2-1-3、默认导入语句 title=6.2.1.3、默认导入语句></a>6.2.1.3、默认导入语句</h4><p>为了帮助减少 Groovy 代码的大小，将自动包含多个<code>import</code>语句。注意，前面的示例如何引用<code>@Component</code>，<code>@RestController</code>和<code>@RequestMapping</code>，而无需使用完全限定的名称或<code>import</code>语句。<blockquote><p>许多 Spring Comments 无需使用<code>import</code>语句即可工作。在添加导入之前，请尝试运行您的应用程序以查看失败的原因。</blockquote><h4 id=6-2-1-4、自动-main-方法><a title="6.2.1.4、自动 main 方法" class=headerlink href=#6-2-1-4、自动-main-方法></a>6.2.1.4、自动 main 方法</h4><p>与等效的 Java 应用程序不同，您不需要在<code>Groovy</code>脚本中包含<code>public static void main(String[] args)</code>方法。会自动创建一个<code>SpringApplication</code>，并将您的编译后代码用作<code>source</code>。<h4 id=6-2-1-5、自定义依赖项-Management><a title="6.2.1.5、自定义依赖项 Management" class=headerlink href=#6-2-1-5、自定义依赖项-Management></a>6.2.1.5、自定义依赖项 Management</h4><p>默认情况下，CLI 使用<code>spring-boot-dependencies</code>中声明的依赖性 Management 来解决<code>@Grab</code>依赖性。可以使用<code>@DependencyManagementBom</code>注解来配置其他依赖项 Management，这些依赖项 Management 将覆盖默认的依赖项 Management。Comments 的值应指定一个或多个 Maven BOM 的坐标(<code>groupId:artifactId:version</code>)。<p>例如，考虑以下声明：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=meta>@DependencyManagementBom("com.example.custom-bom:1.0.0")</span></span><br></pre></table></figure><p>前面的声明在<code>com/example/custom-versions/1.0.0/</code>下的 Maven 存储库中选取<code>custom-bom-1.0.0.pom</code>。<p>当您指定多个 BOM 时，它们以声明它们的 Sequences 应用，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>@DependencyManagementBom(["com.example.custom-bom:1.0.0",</span><br><span class=line>		"com.example.another-bom:1.0.0"])</span><br></pre></table></figure><p>前面的示例表明<code>another-bom</code>中的依赖项 Management 覆盖<code>custom-bom</code>中的依赖项 Management。<p>您可以在可以使用<code>@Grab</code>的任何地方使用<code>@DependencyManagementBom</code>。但是，为确保依赖性 Management 的 Sequences 一致，您最多可以在应用程序中使用<code>@DependencyManagementBom</code>。 <a href=https://platform.spring.io/ rel=noopener target=_blank>Spring IO 平台</a>是依赖 Management 的有用资源(它是 Spring Boot 依赖 Management 的超集)，您可以将其包括在以下行中：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>@DependencyManagementBom('io.spring.platform:platform-bom:1.1.2.RELEASE')</span><br></pre></table></figure><h3 id=6-2-2、具有多个源文件的应用程序><a class=headerlink href=#6-2-2、具有多个源文件的应用程序 title=6.2.2、具有多个源文件的应用程序></a>6.2.2、具有多个源文件的应用程序</h3><p>您可以对所有接受文件 Importing 的命令使用“ shell globbing”。这样可以使您从单个目录使用多个文件，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring run *.groovy</span></span><br></pre></table></figure><h3 id=6-2-3、打包您的应用程序><a class=headerlink href=#6-2-3、打包您的应用程序 title=6.2.3、打包您的应用程序></a>6.2.3、打包您的应用程序</h3><p>您可以使用<code>jar</code>命令将您的应用程序打包到一个独立的可执行 jar 文件中，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring jar my-app.jar *.groovy</span></span><br></pre></table></figure><p>生成的 jar 包含通过编译应用程序产生的类以及应用程序的所有依赖关系，以便随后可以使用<code>java -jar</code>来运行它。 jar 文件还包含来自应用程序的 Classpath 的条目。您可以使用<code>--include</code>和<code>--exclude</code>添加和删除 jar 的显式路径。两者都用逗号分隔，并且都接受形式为“”和“-”的前缀，以表示应将其从默认值中删除。默认包括以下内容：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>public/**, resources/**, static/**, templates/**, META-INF/**, *</span><br></pre></table></figure><p>默认排除项如下：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>.*, repository/**, build/**, target/**, **/*.jar, **/*.groovy</span><br></pre></table></figure><p>在命令行上键入<code>spring help jar</code>以获取更多信息。<h3 id=6-2-4、初始化新项目><a class=headerlink href=#6-2-4、初始化新项目 title=6.2.4、初始化新项目></a>6.2.4、初始化新项目</h3><p><code>init</code>命令使您可以使用<a href=https://start.spring.io/ rel=noopener target=_blank>start.spring.io</a>创建新项目，而无需离开 Shell，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring init --dependencies=web,data-jpa my-project</span></span><br><span class=line>Using service at https://start.spring.io</span><br><span class=line>Project extracted to '/Users/developer/example/my-project'</span><br></pre></table></figure><p>前面的示例使用<code>spring-boot-starter-web</code>和<code>spring-boot-starter-data-jpa</code>创建一个基于 Maven 的项目的<code>my-project</code>目录。您可以使用<code>--list</code>标志列出服务的功能，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring init --list</span></span><br><span class=line>=======================================</span><br><span class=line>Capabilities of https://start.spring.io</span><br><span class=line>=======================================</span><br><span class=line></span><br><span class=line>Available dependencies:</span><br><span class=line>-----------------------</span><br><span class=line>actuator - Actuator: Production ready features to help you monitor and manage your application</span><br><span class=line>...</span><br><span class=line>web - Web: Support for full-stack web development, including Tomcat and spring-webmvc</span><br><span class=line>websocket - Websocket: Support for WebSocket development</span><br><span class=line>ws - WS: Support for Spring Web Services</span><br><span class=line></span><br><span class=line>Available project types:</span><br><span class=line>------------------------</span><br><span class=line>gradle-build -  Gradle Config [format:build, build:gradle]</span><br><span class=line>gradle-project -  Gradle Project [format:project, build:gradle]</span><br><span class=line>maven-build -  Maven POM [format:build, build:maven]</span><br><span class=line>maven-project -  Maven Project [format:project, build:maven] (default)</span><br><span class=line></span><br><span class=line>...</span><br></pre></table></figure><p><code>init</code>命令支持许多选项。有关更多详细信息，请参见<code>help</code>输出。例如，以下命令创建使用 Java 8 和<code>war</code>打包的 Gradle 项目：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring init --build=gradle --java-version=1.8 --dependencies=websocket --packaging=war sample-app.zip</span></span><br><span class=line>Using service at https://start.spring.io</span><br><span class=line>Content saved to 'sample-app.zip'</span><br></pre></table></figure><h3 id=6-2-5、使用嵌入式-Shell><a title="6.2.5、使用嵌入式 Shell" class=headerlink href=#6-2-5、使用嵌入式-Shell></a>6.2.5、使用嵌入式 Shell</h3><p>Spring Boot 包含用于 BASH 和 zsh Shell 的命令行完成脚本。如果您不使用这两个 Shell 程序(也许您是 Windows 用户)，则可以使用<code>shell</code>命令启动集成 Shell 程序，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring shell</span></span><br><span class=line>Spring Boot (v2.1.1.RELEASE)</span><br><span class=line>Hit TAB to complete. Type \'help' and hit RETURN for help, and \'exit' to quit.</span><br></pre></table></figure><p>在嵌入式 Shell 程序内部，您可以直接运行其他命令：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>version</span></span><br><span class=line>Spring CLI v2.1.1.RELEASE</span><br></pre></table></figure><p>嵌入式 Shell 支持 ANSI 颜色输出以及<code>tab</code>完成。如果需要运行本机命令，则可以使用<code>!</code>前缀。要退出嵌入式 Shell，请按<code>ctrl-c</code>。<h3 id=6-2-6、将扩展添加到-CLI><a title="6.2.6、将扩展添加到 CLI" class=headerlink href=#6-2-6、将扩展添加到-CLI></a>6.2.6、将扩展添加到 CLI</h3><p>您可以使用<code>install</code>命令将扩展添加到 CLI。该命令采用<code>group:artifact:version</code>格式的一组或多组工件坐标，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring install com.example:spring-boot-cli-extension:1.0.0.RELEASE</span></span><br></pre></table></figure><p>除了安装由您提供的坐标标识的工件之外，还将安装所有工件的依赖项。<p>要卸载依赖项，请使用<code>uninstall</code>命令。与<code>install</code>命令一样，它采用<code>group:artifact:version</code>格式的一组或多组工件坐标，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring uninstall com.example:spring-boot-cli-extension:1.0.0.RELEASE</span></span><br></pre></table></figure><p>它将卸载由您提供的坐标及其依赖项标识的工件。<p>要卸载所有其他依赖项，可以使用<code>--all</code>选项，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>spring uninstall --all</span></span><br></pre></table></figure><h2 id=6-3、使用-Groovy-Bean-DSL-开发应用程序><a title="6.3、使用 Groovy Bean DSL 开发应用程序" class=headerlink href=#6-3、使用-Groovy-Bean-DSL-开发应用程序></a>6.3、使用 Groovy Bean DSL 开发应用程序</h2><p>Spring Framework 4.0 对<code>beans{}</code>“ DSL”(从<a href=http://grails.org/ rel=noopener target=_blank>Grails</a>借来)具有本地支持，并且您可以使用相同的格式将 Bean 定义嵌入 Groovy 应用程序脚本中。有时，这是包括外部功能(如中间件声明)的好方法，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line>@Configuration</span><br><span class=line>class Application implements CommandLineRunner {</span><br><span class=line></span><br><span class=line>	@Autowired</span><br><span class=line>	SharedService service</span><br><span class=line></span><br><span class=line>	@Override</span><br><span class=line>	void run(String... args) {</span><br><span class=line>		println service.message</span><br><span class=line>	}</span><br><span class=line></span><br><span class=line>}</span><br><span class=line></span><br><span class=line>import my.company.SharedService</span><br><span class=line></span><br><span class=line>beans {</span><br><span class=line>	service(SharedService) {</span><br><span class=line>		message = "Hello World"</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p>您可以将类声明与<code>beans{}</code>混合在同一文件中，只要它们位于顶层即可；或者，如果愿意，可以将 bean DSL 放在单独的文件中。<h2 id=6-4、使用-settings-xml-配置-CLI><a title="6.4、使用 settings.xml 配置 CLI" class=headerlink href=#6-4、使用-settings-xml-配置-CLI></a>6.4、使用 settings.xml 配置 CLI</h2><p>Spring Boot CLI 使用 Maven 的依赖关系解析引擎 Aether 来解决依赖关系。 CLI 利用<code>~/.m2/settings.xml</code>中的 Maven 配置来配置 Aether。 CLI 遵循以下配置设置：<ul><li>Offline<li>Mirrors<li>Servers<li>Proxies<li>Profiles<li>Activation<ul><li>Repositories</ul><li>Active profiles</ul><p>有关更多信息，请参见<a href=https://maven.apache.org/settings.html rel=noopener target=_blank>Maven 的设置文档</a>。<h2 id=6-5、接下来读什么><a class=headerlink href=#6-5、接下来读什么 title=6.5、接下来读什么></a>6.5、接下来读什么</h2><p>GitHub 存储库中有一些<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-cli/samples rel=noopener target=_blank>常规脚本示例</a>可用于尝试 Spring Boot CLI。整个<a href=https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-project/spring-boot-cli/src/main/java/org/springframework/boot/cli rel=noopener target=_blank>source code</a>中也有广泛的 Javadoc。<p>如果发现达到了 CLI 工具的极限，则可能需要考虑将应用程序转换为完整的 Gradle 或 Maven 构建的“ Groovy 项目”。下一节将介绍 Spring Boot 的“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/build-tool-plugins.html rel=noopener target=_blank>构建工具插件</a>”，您可以将其与 Gradle 或 Maven 一起使用。<h1 id=7、构建工具插件><a class=headerlink href=#7、构建工具插件 title=7、构建工具插件></a>7、构建工具插件</h1><p>Spring Boot 为 Maven 和 Gradle 提供了构建工具插件。插件提供了多种功能，包括可执行 jar 的打包。本节提供了有关这两个插件的更多详细信息，以及在扩展不受支持的构建系统时所需的一些帮助。如果您刚刚 Starter，则可能需要先从“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot.html rel=noopener target=_blank>第三部分，“使用 Spring Boot”</a>”部分阅读“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/using-boot-build-systems.html rel=noopener target=_blank>第 13 章，构建系统</a>”。<h2 id=7-1、Spring-Boot-Maven-插件><a title="7.1、Spring Boot Maven 插件" class=headerlink href=#7-1、Spring-Boot-Maven-插件></a>7.1、Spring Boot Maven 插件</h2><p><a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/maven-plugin rel=noopener target=_blank>Spring Boot Maven 插件</a>在 Maven 中提供 Spring Boot 支持，使您可以打包可执行 jar 或 war 归档文件并“就地”运行应用程序。要使用它，必须使用 Maven 3.2(或更高版本)。<h3 id=7-1-1、包含插件><a class=headerlink href=#7-1-1、包含插件 title=7.1.1、包含插件></a>7.1.1、包含插件</h3><p>要使用 Spring Boot Maven 插件，请在<code>pom.xml</code>的<code>plugins</code>部分中包含适当的 XML，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line>&LT?xml version="1.0" encoding="UTF-8"?></span><br><span class=line>&LTproject xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class=line>	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"></span><br><span class=line>	&LTmodelVersion>4.0.0&LT/modelVersion></span><br><span class=line>	&LT!-- ... --></span><br><span class=line>	&LTbuild></span><br><span class=line>		&LTplugins></span><br><span class=line>			&LTplugin></span><br><span class=line>				&LTgroupId>org.springframework.boot&LT/groupId></span><br><span class=line>				&LTartifactId>spring-boot-maven-plugin&LT/artifactId></span><br><span class=line>				&LTversion>2.1.1.RELEASE&LT/version></span><br><span class=line>				&LTexecutions></span><br><span class=line>					&LTexecution></span><br><span class=line>						&LTgoals></span><br><span class=line>							&LTgoal>repackage&LT/goal></span><br><span class=line>						&LT/goals></span><br><span class=line>					&LT/execution></span><br><span class=line>				&LT/executions></span><br><span class=line>			&LT/plugin></span><br><span class=line>		&LT/plugins></span><br><span class=line>	&LT/build></span><br><span class=line>&LT/project></span><br></pre></table></figure><p>前面的配置重新打包了在 Maven 生命周期的<code>package</code>阶段构建的 jar 或 war。以下示例显示了重新打包的 jar 和<code>target</code>目录中的原始 jar：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>mvn package</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>ls</span> target/*.jar</span></span><br><span class=line>target/myproject-1.0.0.jar target/myproject-1.0.0.jar.original</span><br></pre></table></figure><p>如上例所示，如果不包括<code>&LTexecution/></code>配置，则可以单独运行插件(但也必须同时使用软件包目标)，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>mvn package spring-boot:repackage</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>ls</span> target/*.jar</span></span><br><span class=line>target/myproject-1.0.0.jar target/myproject-1.0.0.jar.original</span><br></pre></table></figure><p>如果使用里程碑或快照发行版，则还需要添加相应的<code>pluginRepository</code>元素，如以下 Lists 所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>pluginRepositories</span>></span></span><br><span class=line>	<span class=tag><<span class=name>pluginRepository</span>></span></span><br><span class=line>		<span class=tag><<span class=name>id</span>></span>spring-snapshots<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>		<span class=tag><<span class=name>url</span>></span>https://repo.spring.io/snapshot<span class=tag>&LT/<span class=name>url</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>pluginRepository</span>></span></span><br><span class=line>	<span class=tag><<span class=name>pluginRepository</span>></span></span><br><span class=line>		<span class=tag><<span class=name>id</span>></span>spring-milestones<span class=tag>&LT/<span class=name>id</span>></span></span><br><span class=line>		<span class=tag><<span class=name>url</span>></span>https://repo.spring.io/milestone<span class=tag>&LT/<span class=name>url</span>></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>pluginRepository</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>pluginRepositories</span>></span></span><br></pre></table></figure><h3 id=7-1-2、包装可执行的-Jar-和-War-文件><a title="7.1.2、包装可执行的 Jar 和 War 文件" class=headerlink href=#7-1-2、包装可执行的-Jar-和-War-文件></a>7.1.2、包装可执行的 Jar 和 War 文件</h3><p>将<code>spring-boot-maven-plugin</code>包含在<code>pom.xml</code>中后，它会自动尝试重写 Files，以使 Files 可以通过<code>spring-boot:repackage</code>目标执行。您应该使用通常的<code>packaging</code>元素将项目配置为构建 jar 或 war(视情况而定)，如以下示例所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>project</span> <span class=attr>xmlns</span>=<span class=string>"http://maven.apache.org/POM/4.0.0"</span> <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>	<span class=attr>xsi:schemaLocation</span>=<span class=string>"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>></span></span><br><span class=line>	<span class=comment>&LT!-- ... --></span></span><br><span class=line>	<span class=tag><<span class=name>packaging</span>></span>jar<span class=tag>&LT/<span class=name>packaging</span>></span></span><br><span class=line>	<span class=comment>&LT!-- ... --></span></span><br><span class=line><span class=tag>&LT/<span class=name>project</span>></span></span><br></pre></table></figure><p>Spring Boot 在<code>package</code>阶段会增强您现有的存档。可以通过使用配置选项或通过以常规方式向 Lists 添加<code>Main-Class</code>属性来指定要启动的主类。如果未指定主类，则插件将使用<code>public static void main(String[] args)</code>方法搜索一个类。<p>要构建和运行项目工件，可以键入以下内容：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>mvn package</span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>java -jar target/mymodule-0.0.1-SNAPSHOT.jar</span></span><br></pre></table></figure><p>要构建既可执行又可部署到外部容器的 war 文件，您需要将嵌入式容器的依赖关系标记为“已提供”，如以下示例所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>project</span> <span class=attr>xmlns</span>=<span class=string>"http://maven.apache.org/POM/4.0.0"</span> <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>	<span class=attr>xsi:schemaLocation</span>=<span class=string>"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>></span></span><br><span class=line>	<span class=comment>&LT!-- ... --></span></span><br><span class=line>	<span class=tag><<span class=name>packaging</span>></span>war<span class=tag>&LT/<span class=name>packaging</span>></span></span><br><span class=line>	<span class=comment>&LT!-- ... --></span></span><br><span class=line>	<span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>		<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>			<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>artifactId</span>></span>spring-boot-starter-web<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>		<span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>			<span class=tag><<span class=name>groupId</span>></span>org.springframework.boot<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>artifactId</span>></span>spring-boot-starter-tomcat<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>			<span class=tag><<span class=name>scope</span>></span>provided<span class=tag>&LT/<span class=name>scope</span>></span></span><br><span class=line>		<span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>		<span class=comment>&LT!-- ... --></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>dependencies</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>project</span>></span></span><br></pre></table></figure><h2 id=7-2、Spring-Boot-Gradle-插件><a title="7.2、Spring Boot Gradle 插件" class=headerlink href=#7-2、Spring-Boot-Gradle-插件></a>7.2、Spring Boot Gradle 插件</h2><p>Spring Boot Gradle 插件在 Gradle 中提供了 Spring Boot 支持，使您可以打包可执行 jar 或 war 归档文件，运行 Spring Boot 应用程序以及使用<code>spring-boot-dependencies</code>提供的依赖项 Management。它需要 Gradle 4.4 或更高版本。请参考插件的文档以了解更多信息：<ul><li>参考(<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/gradle-plugin/reference/html rel=noopener target=_blank>HTML</a>和<a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/gradle-plugin/reference/pdf/spring-boot-gradle-plugin-reference.pdf rel=noopener target=_blank>PDF</a>)<li><a href=https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/gradle-plugin/api rel=noopener target=_blank>API</a></ul><h2 id=7-3、Spring-Boot-AntLib-模块><a title="7.3、Spring Boot AntLib 模块" class=headerlink href=#7-3、Spring-Boot-AntLib-模块></a>7.3、Spring Boot AntLib 模块</h2><p>Spring Boot AntLib 模块为 Apache Ant 提供了基本的 Spring Boot 支持。您可以使用该模块创建可执行 jar。要使用该模块，您需要在<code>build.xml</code>中声明一个额外的<code>spring-boot</code>命名空间，如以下示例所示：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>project</span> <span class=attr>xmlns:ivy</span>=<span class=string>"antlib:org.apache.ivy.ant"</span></span></span><br><span class=line><span class=tag>	<span class=attr>xmlns:spring-boot</span>=<span class=string>"antlib:org.springframework.boot.ant"</span></span></span><br><span class=line><span class=tag>	<span class=attr>name</span>=<span class=string>"myapp"</span> <span class=attr>default</span>=<span class=string>"build"</span>></span></span><br><span class=line>	...</span><br><span class=line><span class=tag>&LT/<span class=name>project</span>></span></span><br></pre></table></figure><p>您需要记住使用<code>-lib</code>选项启动 Ant，如以下示例所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash>ant -lib &LTfolder containing spring-boot-antlib-2.1.1.RELEASE.jar></span></span><br></pre></table></figure><h3 id=7-3-1、Spring-Boot-Ant-任务><a title="7.3.1、Spring Boot Ant 任务" class=headerlink href=#7-3-1、Spring-Boot-Ant-任务></a>7.3.1、Spring Boot Ant 任务</h3><p>声明<code>spring-boot-antlib</code>名称空间后，可以使用以下附加任务：<ul><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/build-tool-plugins-antlib.html#spring-boot-ant-exejar rel=noopener target=_blank>第 73.1.1 节“ spring-boot：exejar”</a><li><a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/build-tool-plugins-antlib.html#spring-boot-ant-findmainclass rel=noopener target=_blank>第 73.2 节“ spring-boot：findmainclass”</a></ul><h4 id=7-3-1-1、spring-boot-exejar><a class=headerlink href=#7-3-1-1、spring-boot-exejar title=7.3.1.1、spring-boot:exejar></a>7.3.1.1、spring-boot:exejar</h4><p>您可以使用<code>exejar</code>任务创建一个 Spring Boot 可执行 jar。任务支持以下属性：<table><thead><tr><th>Attribute<th>Description<th>Required<tbody><tr><td><code>destfile</code><td>要创建的目标 jar 文件<td>Yes<tr><td><code>classes</code><td>Java 类文件的根目录<td>Yes<tr><td><code>start-class</code><td>要运行的主要应用程序类<td>否*(默认为找到的第一个声明<code>main</code>方法的类)*</table><p>以下嵌套元素可用于任务：<table><thead><tr><th>Element<th>Description<tbody><tr><td><code>resources</code><td>一个或多个<a href=https://ant.apache.org/manual/Types/resources.html#collection rel=noopener target=_blank>Resource Collections</a>描述一组<a href=https://ant.apache.org/manual/Types/resources.html rel=noopener target=_blank>Resources</a>，应将其添加到创建的 jar 文件的内容中。<tr><td><code>lib</code><td>应该将一个或多个<a href=https://ant.apache.org/manual/Types/resources.html#collection rel=noopener target=_blank>Resource Collections</a>添加到组成应用程序运行时依赖项 Classpath 的 jar 库集合中。</table><h4 id=7-3-1-2、Examples><a class=headerlink href=#7-3-1-2、Examples title=7.3.1.2、Examples></a>7.3.1.2、Examples</h4><p>本节显示了两个 Ant 任务示例。<p><strong>Specify start-class.</strong><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>spring-boot:exejar</span> <span class=attr>destfile</span>=<span class=string>"target/my-application.jar"</span></span></span><br><span class=line><span class=tag>		<span class=attr>classes</span>=<span class=string>"target/classes"</span> <span class=attr>start-class</span>=<span class=string>"com.example.MyApplication"</span>></span></span><br><span class=line>	<span class=tag><<span class=name>resources</span>></span></span><br><span class=line>		<span class=tag><<span class=name>fileset</span> <span class=attr>dir</span>=<span class=string>"src/main/resources"</span> /></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>resources</span>></span></span><br><span class=line>	<span class=tag><<span class=name>lib</span>></span></span><br><span class=line>		<span class=tag><<span class=name>fileset</span> <span class=attr>dir</span>=<span class=string>"lib"</span> /></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>lib</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>spring-boot:exejar</span>></span></span><br></pre></table></figure><p><strong>Detect start-class.</strong><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>exejar</span> <span class=attr>destfile</span>=<span class=string>"target/my-application.jar"</span> <span class=attr>classes</span>=<span class=string>"target/classes"</span>></span></span><br><span class=line>	<span class=tag><<span class=name>lib</span>></span></span><br><span class=line>		<span class=tag><<span class=name>fileset</span> <span class=attr>dir</span>=<span class=string>"lib"</span> /></span></span><br><span class=line>	<span class=tag>&LT/<span class=name>lib</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>exejar</span>></span></span><br></pre></table></figure><h3 id=7-3-2、spring-boot-findmainclass><a class=headerlink href=#7-3-2、spring-boot-findmainclass title=7.3.2、spring-boot:findmainclass></a>7.3.2、spring-boot:findmainclass</h3><p><code>exejar</code>在内部使用<code>findmainclass</code>任务来查找声明<code>main</code>的类。如有必要，您也可以直接在构建中使用此任务。支持以下属性：<table><thead><tr><th>Attribute<th>Description<th>Required<tbody><tr><td><code>classesroot</code><td>Java 类文件的根目录<td>是*(除非指定了<code>mainclass</code>)*<tr><td><code>mainclass</code><td>可用于短路<code>main</code>类搜索<td>No<tr><td><code>property</code><td>应该与结果一起设置的 Ant 属性<td>否*(如果未指定，将记录结果)*</table><h4 id=7-3-2-1、Examples><a class=headerlink href=#7-3-2-1、Examples title=7.3.2.1、Examples></a>7.3.2.1、Examples</h4><p>本节包含三个使用<code>findmainclass</code>的示例。<p><strong>查找并记录.</strong><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>&LTfindmainclass classesroot="target/classes" /></span><br></pre></table></figure><p><strong>查找并设置.</strong><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>&LTfindmainclass classesroot="target/classes" property="main-class" /></span><br></pre></table></figure><p><strong>覆盖并设置.</strong><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>&LTfindmainclass mainclass="com.example.MainClass" property="main-class" /></span><br></pre></table></figure><h2 id=7-4、支持其他构建系统><a class=headerlink href=#7-4、支持其他构建系统 title=7.4、支持其他构建系统></a>7.4、支持其他构建系统</h2><p>如果要使用 Maven，Gradle 或 Ant 以外的构建工具，则可能需要开发自己的插件。可执行的 jar 需要遵循特定的格式，并且某些条目需要以未压缩的形式编写(有关详细信息，请参见附录中的“ <a href=https://www.docs4dev.com/docs/zh/spring-boot/2.1.1.RELEASE/reference/executable-jar.html rel=noopener target=_blank>可执行 jar 格式</a>”部分)。<p>Spring Boot Maven 和 Gradle 插件都使用<code>spring-boot-loader-tools</code>来实际生成 jar。如果需要，可以直接使用此库。<h3 id=7-4-1、重新打包-Files><a title="7.4.1、重新打包 Files" class=headerlink href=#7-4-1、重新打包-Files></a>7.4.1、重新打包 Files</h3><p>要重新打包现有存档，使其成为独立的可执行存档，请使用<code>org.springframework.boot.loader.tools.Repackager</code>。 <code>Repackager</code>类采用单个构造函数参数，该参数引用现有的 jar 或 war 存档。使用两个可用的<code>repackage()</code>方法之一替换原始文件或写入新目标。在重新打包程序运行之前，还可以在其上配置各种设置。<h3 id=7-4-2、嵌套库><a class=headerlink href=#7-4-2、嵌套库 title=7.4.2、嵌套库></a>7.4.2、嵌套库</h3><p>重新打包归档文件时，可以使用<code>org.springframework.boot.loader.tools.Libraries</code>接口包含对依赖文件的引用。我们在这里不提供<code>Libraries</code>的任何具体实现，因为它们通常是特定于构建系统的。<p>如果您的存档中已经包含库，则可以使用<code>Libraries.NONE</code>。<h3 id=7-4-3、查找主要类><a class=headerlink href=#7-4-3、查找主要类 title=7.4.3、查找主要类></a>7.4.3、查找主要类</h3><p>如果不使用<code>Repackager.setMainClass()</code>指定主类，则重新打包程序将使用<a href=http://asm.ow2.org/ rel=noopener target=_blank>ASM</a>读取类文件，并尝试使用<code>public static void main(String[] args)</code>方法查找合适的类。如果找到多个候选者，则会引发异常。<h3 id=7-4-4、重新打包实施示例><a class=headerlink href=#7-4-4、重新打包实施示例 title=7.4.4、重新打包实施示例></a>7.4.4、重新打包实施示例</h3><p>以下示例显示了典型的重新打包实现：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>Repackager repackager = new Repackager(sourceJarFile);</span><br><span class=line>repackager.setBackupSource(false);</span><br><span class=line>repackager.repackage(new Libraries() {</span><br><span class=line>			@Override</span><br><span class=line>			public void doWithLibraries(LibraryCallback callback) throws IOException {</span><br><span class=line>				// Build system specific implementation, callback for each dependency</span><br><span class=line>				// callback.library(new Library(nestedFile, LibraryScope.COMPILE));</span><br><span class=line>			}</span><br><span class=line>		});</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/SpringBoot%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/SpringBoot%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/ itemprop=url>SpringBoot系列-SpringBoot原理解析</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-03 22:02:20" datetime=2023-10-03T22:02:20+08:00 itemprop=dateModified>2023-10-03</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/SpringBoot/ itemprop=url rel=index><span itemprop=name>SpringBoot</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=启动初始化><a class=headerlink href=#启动初始化 title=启动初始化></a>启动初始化</h1><p><strong>SpringBoot的启动和初始化步骤主要由 SpringApplication.run(String..) 方法和AbstractApplicationContext.refresh() 方法完成</strong>。<p>SpringApplication.run(String…)中会调用AbstractApplicationContext.run()方法。<p>当然，<em><strong>最初先调用SprirngApplication(ResourceLoader, Class)来构造SpringApplication对象</strong></em>，详情如下：<p><strong>（1）初始化相关参数</strong><p>初始化bannerModel为Console，logStartupInfo为true，addCommandLineProperties为true，addConversionService为true，headLess为true，registerShutdownHook为true，isCustomEnvironment为false，lazyInitialization为false，applicationContextFactory为DefaultApplicationContextFactory，applicationStartup为DefaultApplicationStartup。<p><strong>（2）初始化当前应用的类型</strong><p><strong>如果存在DispatcherHandler，不存在DispatcherServlet和ServletContainer，那么应用类型为Reactive</strong>。<p><strong>如果不存在Servlet或ConfigurableWebApplicationContext，那么应用类型为None</strong>。<p><strong>除了上面两种情况，其它情况都属于Servlet应用</strong>。<p><strong>（3）初始化接口实现和确定主启动类</strong><p>初始化集合bootstrapRegistryInitializers为接口BootstrapRegistryInitializer的所有实现，初始化initializers为接口ApplicationContextInitializer的所有实现，初始化listeners为接口ApplicationListener的所有实现，初始化mainApplicationClass为启动类Class。<h2 id=1-1、SpringApplication-run-String…><a class=headerlink href=#1-1、SpringApplication-run-String… title=1.1、SpringApplication.run(String…)></a>1.1、SpringApplication.run(String…)</h2><h3 id=1-1-1、SpringApplication-createBootstrapContext><a class=headerlink href=#1-1-1、SpringApplication-createBootstrapContext title=1.1.1、SpringApplication.createBootstrapContext()></a>1.1.1、SpringApplication.createBootstrapContext()</h3><p>（1）创建DefaultBootstrapContext实例，实例名为bootstrapContext。<p>（2）遍历接口BootstrapRegistryInitializer的所有实现类，并调用每个实现类的initialize(bootstrapContext)方法，将bootstrapContext作为参数传进去。<p>（3）最终将创建的bootstrapContext实例return。<h3 id=1-1-2、SpringApplication-configureHeadlessProperty><a class=headerlink href=#1-1-2、SpringApplication-configureHeadlessProperty title=1.1.2、SpringApplication.configureHeadlessProperty()></a>1.1.2、SpringApplication.configureHeadlessProperty()</h3><p>（1）配置Headless属性<p>配置属性java.awt.headless，值默认为true。<h3 id=1-1-3、SpringApplication-getRunListeners><a class=headerlink href=#1-1-3、SpringApplication-getRunListeners title=1.1.3、SpringApplication.getRunListeners(.)></a>1.1.3、SpringApplication.getRunListeners(.)</h3><p><strong>（1）SpringApplication.getSpringFactoriesInstances(…)</strong><p>扫描<code>META-INF/spring.factories</code>文件，获取接口SpringApplicaitonRunListener的所有实现类。如果没有自定义，那么默认有1个，就是：org.springframework.boot.context.event.EventPublishingRunListener。<p>通过反射拿到每个实现类的构造器，调用其构造器实例化对象，然后通过集合List的默认排序方法进行排序。<p><strong>（2）return new SpringApplicationRunListeners(…)</strong><p>由LogAdapter.Sfl4jLocationAwareLog、上一步拿到的实现类实例、DefaultApplicationStartup作为参数来创建SpringApplicationRunListeners实例对象并return。<h3 id=1-1-4、SpringApplicationRunListeners-starting><a class=headerlink href=#1-1-4、SpringApplicationRunListeners-starting title=1.1.4、SpringApplicationRunListeners.starting(..)></a>1.1.4、SpringApplicationRunListeners.starting(..)</h3><p><strong>（1）构造3个参数，一个是String，两个是Consumer对象</strong>。<p>参数1：spring.boot.application.starting；参数2：DefaultBootstrapContext作为参数，调用传进来listener的starting方法；参数3：如果主类不为null，那么将字符串mainApplicationClass、字符串主类的全类名作为参数，调用传进来参数的tag方法。<p><strong>（2）SpringApplicationRunListeners.doWithListeners(String, Consumer, Consumer)</strong><p>调用DefaultApplicationStartup.start(“spring.boot.application.starting”)方法返回一个DefaultApplicationStartup.DefaultStartupStep实例对象。<p>执行参数2的Consumer，也就是执行所有listener的starting方法。执行参数3的Consumer，也就是调用上面返回的DefaultApplicationStartup.DefaultStartupStep实例对象的tag方法，然后调用end方法。<h3 id=1-1-5、new-DefaultApplicationArguments-args><a title="1.1.5、new DefaultApplicationArguments(args)" class=headerlink href=#1-1-5、new-DefaultApplicationArguments-args></a>1.1.5、new DefaultApplicationArguments(args)</h3><p>初始化DefaultApplicationArguments的source变量为DefaultApplicationArguments.Source，变量source的name参数值为commandLineArgs，nonOptionArgsPropertyName参数值为nonOptionArgs。<p>初始化DefaultApplicationArguments的args变量为空的String类型数组。<h3 id=1-1-6、SpringApplication-prepareEnvironment-…><a class=headerlink href=#1-1-6、SpringApplication-prepareEnvironment-… title=1.1.6、SpringApplication.prepareEnvironment(…)></a>1.1.6、SpringApplication.prepareEnvironment(…)</h3><p><strong>（1）SpringApplication.getOrCreateEnvironment()</strong><p>如果SpringApplication的变量ConfigurableEnvironment environment不为null，那么可以直接返回，不用往下执行了。<p>调用DefaultApplicationContextFactory.getFromSpringFactories(…)方法从META-INF/spring.factories文件中获取接口ApplicationContextFactory的所有实现，默认有2个，分别是AnnotationConfigReactiveWebServerApplicationContext.Factory和AnnotationConfigServletWebServerApplicationContext.Factory，并创建每个实现类的实例对象。<p>将实现类对象、WebApplicationType作为参数调用ApplicationContextFactory.createEnvironment()方法，然后将该方法的返回值return，如果项目是servlet项目，那么这里返回的是ApplicationServletEnvironment，最终会再将之强转为ConfigurableEnvironment返回。<p>如果上一步最终返回为null，那么会默认创建一个ApplicationEnvironment对象返回。<p><strong>（2）SpringApplication.configureEnvironment(..)</strong><p>如果允许添加转换服务，那么为当前环境对象ApplicationServletEnvironment添加一个ApplicationConversionService实例对象。<p>配置属性源，也就是说项目会读取哪里的配置。<p>配置Profiles，默认方法空实现。<p><strong>（3）调用ConfigurationPropertySources.attach(.)</strong><p>获取当前environment的属性源MutablePropertySources。默认有4个，详情如下：<ul><li>servletConfigInitParams<li>servletContextInitParams<li>systemProperties（67个属性）<li>systemEnvironment（42个属性）</ul><p>将这4个属性源封装成ConfigurationPropertySourcesPropertySource，将这个封装好的属性源和上面4个组合到一起，封装好的放第一个，然后再将这5个添加进MutablePropertySources中。<p><strong>（4）SpringApplicationRunListeners.environmentPrepared()</strong><p>构造2个参数，一个是String，一个是Consumer对象。参数1：spring.boot.application.environement-prepared；参数2：DefaultBootstrapContext、environment作为参数，调用传进来listener的environmentPrepared方法。<p>调用SpringApplicationRunListeners.doWithListeners(String, Consumer, Consumer)方法来处理：调用DefaultApplicationStartup.start(“spring.boot.application.environment-prepared”)方法返回一个DefaultApplicationStartup.DefaultStartupStep实例对象。执行参数2的Consumer，也就是执行所有listener的environmentPrepared方法。调用上面返回的DefaultApplicationStartup.DefaultStartupStep实例对象的end方法。<p><strong>（5）DefaultPropertiesPropertySource.moveToEnd(.)</strong><p>将名字为defaultProperties的属性源移动到列表最后一个。<p><strong>（6）SpringApplication.bindToSpringApplication()</strong><p><strong>（7）EnvironmentConverter.converEnvironmentIfNecessary()</strong><p>如果不是自定义环境environment，那么需要使用环境转换器对当前环境进行转换。<h3 id=1-1-7、SpringApplication-configureIgnoreBeanInfo><a class=headerlink href=#1-1-7、SpringApplication-configureIgnoreBeanInfo title=1.1.7、SpringApplication.configureIgnoreBeanInfo()></a>1.1.7、SpringApplication.configureIgnoreBeanInfo()</h3><p>设置环境属性spring.beaninfo.ignore，值为true。<h3 id=1-1-8、SpringApplication-printBanner><a class=headerlink href=#1-1-8、SpringApplication-printBanner title=1.1.8、SpringApplication.printBanner(.)></a>1.1.8、SpringApplication.printBanner(.)</h3><p>打印Banner信息。<h3 id=1-1-9、SpringApplication-createApplicationContext><a class=headerlink href=#1-1-9、SpringApplication-createApplicationContext title=1.1.9、SpringApplication.createApplicationContext()></a>1.1.9、SpringApplication.createApplicationContext()</h3><p>（1）构建3个参数，一个是项目类型Servlet，一个是Consumer，一个是方法引用。<p>（2）基于这些参数尝试从META-INF/spring.factories文件中获取接口ApplicationContextFactory的所有实现。<h3 id=1-1-10、GenericApplicationContext-setApplicationStartup><a class=headerlink href=#1-1-10、GenericApplicationContext-setApplicationStartup title=1.1.10、GenericApplicationContext.setApplicationStartup(.)></a>1.1.10、GenericApplicationContext.setApplicationStartup(.)</h3><p>为AnnotationConfigServletWebServerApplicationContext添加一个DefaultApplicationStartup类实例。<h3 id=1-1-11、SpringApplicationContext-prepareContext><a class=headerlink href=#1-1-11、SpringApplicationContext-prepareContext title=1.1.11、SpringApplicationContext.prepareContext()></a>1.1.11、SpringApplicationContext.prepareContext()</h3><p><strong>（1）为AnnotationConfigServletWebServerApplicationContext设置环境environment。</strong><p><strong>（2）为AnnotationConfigServletWebServerApplicationContext中的BeanFactory设置一个转换服务ApplicationConversionService。</strong><p><strong>（3）应用所有的初始化器。</strong><p>默认有8个：DelegatingApplicationContextInitializer、SharedMetadataReaderFactoryContextInitializer、ContextIdApplicationContextInitializer、MyApplicationContextInitializer、ConfigurationWarningsApplicationContextInitializer、RSocketPortInfoApplicationContextInitializer、ServerPortInfoApplicationContextInitializer、ConditionEvaluationReportLoggingListener。<p>将AnnotationConfigServletWebServerApplicationContext作为参数调用每个initialize的initialize方法。<p><strong>（4）调用形参SpringApplicationRunListeners的contextPrepared方法。</strong><p><strong>（5）调用形参DefaultBootstrapContext的close方法，发布BootstrapContextClosedEvent事件。</strong><p><strong>（6）使用BeanFactory注册一个单例springApplicationArguments。</strong><p><strong>（7）使用BeanFactory注册一个单例springBootBanner。</strong><p><strong>（8）设置允许Bean循环应用，允许Bean定义信息被重写。</strong><p><strong>（9）如果允许延迟实例化Bean，那么为context 注册一个LazyInitializationBeanFactoryPostProcessor。</strong><p><strong>（10）加载Bean定义信息。</strong><p>创建一个Bean定义加载器BeanDefinitionLoader，该加载器中已经初始化好了AnnotatedBeanDifinitionReader、XmlBeanDefinitionReader、ClassPathBeanDefinitionScanner。<p>加载源souce默认只有一个，就是启动类。默认只能加载4种类型的源，分别是Class、Resouce、Package、CharSequence。调用BeanDefinitionLoader.load()方法来加载每一个源，默认是启动类。<p>以启动类为例来分析。会调用AnnotatedBeanDefinitionReader.doRegisterBean方法来注册启动类Class。在该方法中会先将启动类包装成BeanDefinition，为该BeanDefinition设置名字为启动类名字首字母小写，设置Scope为singleton，并处理启动类上注解为Lazy、DependsOn、Role、Description等信息并做相关操作，没有就跳过。最终将该Beean定义注册到容器中。<p><strong>（11）以字符串spring.boot.application.context-loaded为参数调用StartupStep的start和end方法，以context为参数调用SpringApplicationRunListeners的contextLoaded方法</strong>。<h3 id=1-1-12、SpringApplication-refreshContext><a class=headerlink href=#1-1-12、SpringApplication-refreshContext title=1.1.12、SpringApplication.refreshContext(.)></a>1.1.12、SpringApplication.refreshContext(.)</h3><p>详情参考1.2章节。<h3 id=1-1-13、SpringApplication-afterRefresh><a class=headerlink href=#1-1-13、SpringApplication-afterRefresh title=1.1.13、SpringApplication.afterRefresh(..)></a>1.1.13、SpringApplication.afterRefresh(..)</h3><p>默认空实现。<h3 id=1-1-14、SpringApplicationRunListeners-started><a class=headerlink href=#1-1-14、SpringApplicationRunListeners-started title=1.1.14、SpringApplicationRunListeners.started(..)></a>1.1.14、SpringApplicationRunListeners.started(..)</h3><p>以字符串spring.boot.application.started为参数调用StartupStep的start和end方法，以context为参数调用SpringApplicationRunListeners为参数调用listener的started方法。<h3 id=1-1-15、SpringApplication-callRunners><a class=headerlink href=#1-1-15、SpringApplication-callRunners title=1.1.15、SpringApplication.callRunners(..)></a>1.1.15、SpringApplication.callRunners(..)</h3><p>（1）获取接口ApplicationRunner、CommandLineRunner的所有实现类装进List集合中，然后使用List的默认排序方式进行排序。<p>（2）遍历所有的Runner，并执行它们的run方法。先执行ApplicationRunner的实现类的run方法，再执行CommandLineRunner的实现类。<h3 id=1-1-16、catch-Throwable><a class=headerlink href=#1-1-16、catch-Throwable title=1.1.16、catch:Throwable></a>1.1.16、catch:Throwable</h3><p>（1）SpringApplication.handleRunFailure(…)<h3 id=1-1-17、SpringApplicationRunListeners-ready><a class=headerlink href=#1-1-17、SpringApplicationRunListeners-ready title=1.1.17、SpringApplicationRunListeners.ready(..)></a>1.1.17、SpringApplicationRunListeners.ready(..)</h3><p>以字符串spring.boot.application.ready为参数调用StartupStep的start和end方法，以context为参数调用SpringApplicationRunListeners为参数调用listener的ready方法。<p>最终将初始化好的context实例返回，结束SpringBoot的启动和初始化。下一步就是处理HTTP请求的流程。<h3 id=1-1-18、catch-Throwable><a class=headerlink href=#1-1-18、catch-Throwable title=1.1.18、catch:Throwable></a>1.1.18、catch:Throwable</h3><p>（1）SpringApplication.handleRunFailure(…)<h2 id=1-2、AbstractApplicationContext-refresh><a class=headerlink href=#1-2、AbstractApplicationContext-refresh title=1.2、AbstractApplicationContext.refresh()></a>1.2、AbstractApplicationContext.refresh()</h2><h3 id=1-2-1、DefaultApplicationStartup-start-“spring-context-refresh”><a class=headerlink href=#1-2-1、DefaultApplicationStartup-start-“spring-context-refresh” title=1.2.1、DefaultApplicationStartup.start(“spring.context.refresh”)></a>1.2.1、DefaultApplicationStartup.start(“spring.context.refresh”)</h3><p>创建一个DefaultApplicationStartup.DefaultStartupStep实例。<h3 id=1-2-2、AnnnotationConfigServletWebServerApplicationContext-prepareRefresh><a class=headerlink href=#1-2-2、AnnnotationConfigServletWebServerApplicationContext-prepareRefresh title=1.2.2、AnnnotationConfigServletWebServerApplicationContext.prepareRefresh()></a>1.2.2、AnnnotationConfigServletWebServerApplicationContext.prepareRefresh()</h3><p><strong>（1）清空缓存</strong><p>如果Map集合metadataReaderCache属于LocalResourceCache类型，那么清空该集合。<p>如果Map集合metadataReaderCache为null，那么初始化一个容量为256的集合LocalResourceCache。<p><strong>（2）准备刷新</strong><p>初始化属性源，验证Required配置。初始化Set集合earlyApplicationListeners，为集合导入13个ApplicationListener。<h3 id=1-2-3、AbstractApplicationContext-obtainFreshBeanFactory><a class=headerlink href=#1-2-3、AbstractApplicationContext-obtainFreshBeanFactory title=1.2.3、AbstractApplicationContext.obtainFreshBeanFactory()></a>1.2.3、AbstractApplicationContext.obtainFreshBeanFactory()</h3><p>为BeanFactory设置序列化ID为字符串application，然后返回。<h3 id=1-2-4、AbstractApplicationContext-prepareBeanFactory><a class=headerlink href=#1-2-4、AbstractApplicationContext-prepareBeanFactory title=1.2.4、AbstractApplicationContext.prepareBeanFactory()></a>1.2.4、AbstractApplicationContext.prepareBeanFactory()</h3><p><strong>（1）为BeanFactory设置Bean类加载器Launcher.AppClassLoader。</strong><p><strong>（2）为BeanFactory设置Bean表达式解析器StandardBeanExpressionResolver。</strong><p><strong>（3）为BeanFactory添加属性编辑注册器ResourceEditorRegistrar。</strong><p><strong>（4）为BeanFactory添加Bean增强器ApplicationContextAwareProcessor。</strong><p><strong>（5）设置要忽略的依赖接口</strong><p>这些接口包括：EnvironmentAware、EmbeddedValueResolverAware、ResourceLoader、ApplicationEventPublisherAware、MessageSourceAware、ApplicationContextAware、ApplicationStartupAware。<p><strong>（6）注册分解依赖</strong><p>这些依赖包括：BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext。<p><strong>（7）为BeanFactory添加一个Bean增强器ApplicationListenerDetector。</strong><p><strong>（8）如果BeanFactory中没有environment、systemProperties、systemEnvironment、applicationStartup，那么将它们注册为单例Bean。</strong><h3 id=1-2-5、AnnotationConfigServletWebServerApplicationContext-postProcessBeanFactory><a class=headerlink href=#1-2-5、AnnotationConfigServletWebServerApplicationContext-postProcessBeanFactory title=1.2.5、AnnotationConfigServletWebServerApplicationContext.postProcessBeanFactory(.)></a>1.2.5、AnnotationConfigServletWebServerApplicationContext.postProcessBeanFactory(.)</h3><p><strong>（1）ServletWebServerApplicationContext.postProcessBeanFactory(.)</strong><p>为当前BeanFactory添加一个Bean增强器WebApplicationContextServletContextAwareProcessor，并设置忽略依赖的接口ServletContextAware。<p>注册Web应用的Scope。先注册现有的Scope，再注册其它的Scope：request:RequestScope、session:SessionScope、注册可解析的依赖：ServletRequest:RequestObjectFactory、ServletResponse:ResponseObjectFactory、HttpSession:SessionObjectFactory、WebRequest:WebRequestObjectFactory。如果有必要会注册门面依赖：FacesContext、ExternalContext。<p><strong>（2）如果basePackages、annotatedClasses不为空，那么扫描这些包并注册这些注解。</strong><h3 id=1-2-6、DefaultApplicationStartup-start-“spring-context-beans-post-process”><a class=headerlink href=#1-2-6、DefaultApplicationStartup-start-“spring-context-beans-post-process” title=1.2.6、DefaultApplicationStartup.start(“spring.context.beans.post-process”)></a>1.2.6、DefaultApplicationStartup.start(“spring.context.beans.post-process”)</h3><p>以字符串spring.context.beans.post-process为参数调用DefaultApplicationStartup.start方法创建一个DefaultApplicationStartup.DefaultStartupStep实例。<h3 id=1-2-7、AbstractApplicationContext-invokeBeanFactoryPostProcessors><a class=headerlink href=#1-2-7、AbstractApplicationContext-invokeBeanFactoryPostProcessors title=1.2.7、AbstractApplicationContext.invokeBeanFactoryPostProcessors(.)></a>1.2.7、AbstractApplicationContext.invokeBeanFactoryPostProcessors(.)</h3><p>入口从AbstractApplicationContext.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory)开始。<p>该方法会做如下事情：<ol><li>执行BanFactory增强器。<li>如果不是原生镜像，且当前beanFactory的临时类加载器为null，且beanFactory中包含名字是loadTimeWeaver的Bean，那么为当前BeanFactory添加一个Bean增强器LoadTimeWeaverAwareProcessor并设置一个临时类加载器。</ol><p>（1）<code>AbstractApplicationContext.invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory, List&LTBeanFactoryPostProcessor>)</code><p>调用<code>PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessor(Collection&LTBeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry, ApplicationStartup)</code>方法来注册BeanDefinition信息。<p>（2）<code>PostProcessorRegistrationDelegate.invokeBeanDefinitionRegistryPostProcessor(Collection&LTBeanDefinitionRegistryPostProcessor>, BeanDefinitionRegistry, ApplicationStartup)</code><p>遍历BeanDefinitionRegistryPostProcessor集合，默认集合只有一个ConfigurationClassPostProcessor，执行其postProcessBeanDefinitionRegistry(BeanDefinitionRegistry)方法来完成BeanDefinition的注入。<p>（3）ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry(BeanDefinitionRegistry)<p>调用ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry)方法来处理配置的BeanDefinition信息。<p>（4）ConfigurationClassPostProcessor.processConfigBeanDefinitions(BeanDefinitionRegistry)<p>调用<code>ConfiguraionClassParser.parse(Set&LTBeanDefinitionHolder>)</code>方法来解析配置类。<p>（5）<code>ConfiguraionClassParser.parse(Set&LTBeanDefinitionHolder>)</code><p>调用ConfigurationClassParser.DeferredImportSelectorHandler.process()方法来处理。<p>（6）ConfigurationClassParser.DeferredImportSelectorHandler.process()<p>调用ConfigurationClassParser.DeferredImportSelectorGroupingHandler.processGroupImports()方法来处理。<p>（7）ConfigurationClassParser.DeferredImportSelectorGroupingHandler.processGroupImports()<p>调用ConfigurationClassParser.DeferedImportSelectorGrouping.getImports()方法获取要导入的配置类信息。<p>遍历所有的配置类信息，调用ConfigurationClassParser.processImports(…..)来将这些配置类导入到容器中。<p>（8）ConfigurationClassParser.DeferedImportSelectorGrouping.getImports()<p>调用AutoConfigurationImportSelector.AutoConfigurationGroup.process()方法来处理。<p>调用AutoConfigurationImportSelector.AutoConfigurationGroup.selectImports()来处理。<p>（9）AutoConfigurationImportSelector.AutoConfigurationGroup.process()<p>调用AutoConfigurationImportSelector.getAutoConfigurationEntry()方法来获取配置类，然后将这些配置类装进Map中。<p>（10）AutoConfigurationImportSelector.getAutoConfigurationEntry()<p>调用AutoConfigurationImportSelector.getCandidateConfiguration()方法来读取项目META-INFO/spring.factories文件和项目META-INFO/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports文件中的自动配置类信息。<p>对扫描的配置类进行过滤，过滤掉要排除的配置类，将最终剩下的需要使用的全部配置类整体打包成AutoConfigurationEntry并返回。<h3 id=1-2-8、AbstractApplicationContext-registerBeanPostProcessors><a class=headerlink href=#1-2-8、AbstractApplicationContext-registerBeanPostProcessors title=1.2.8、AbstractApplicationContext.registerBeanPostProcessors(.)></a>1.2.8、AbstractApplicationContext.registerBeanPostProcessors(.)</h3><p><em><strong>会调用PostProcessorRegistrationDelegate.registerBeanPostProcessors(..)方法来处理</strong></em>。<p>获取接口BeanPostProcessor的所有实现类，默认有7个，分别是：internalAutowiredAnnotationProcessor、internalCommonAnnotationProcessor、ConfigurationPropertiesBindingPostProcessor、webServerFactoryCustomizerBeanPostProcessor、errorPageRegistrarBeanPostProcessor、internalAutoProxyCreator、persistenceExceptionTranslationPostProcessor。<p><em><strong>为当前BeanFactory添加Bean增强器BeanPostProcessorChecker</strong></em>。<p>遍历所有的Bean增强器，将这些Bean增强器按照实现了PriorityOrdered、实现Ordered、普通的分类装进不同的List集合中。先将实现了PriorityOrder的所有Bean增强器添加进BeanFactory中。把实现了Ordered的Bean增强器中挑选处实现了MergeBeanDefinitionPostProcessor的装进对应的集合中。然后将实现了Ordered的Bean增强器添加进BeanFactory中。从普通的Bean增强器中也挑选出MergeBeanDefinitionPostProcessor类型的装进对应的集合中，然后将普通的Bean增强器装进BeanFactory中，然后将普通的MergeBeanDefinitionPostProcessor类型的也装进去。<p>最后再为BeanFactory添加一个Bean增强器ApplicationListenerDetector。<h3 id=1-2-9、DefaultApplicationStartup-DefaultStartupStep-end><a class=headerlink href=#1-2-9、DefaultApplicationStartup-DefaultStartupStep-end title=1.2.9、DefaultApplicationStartup.DefaultStartupStep.end()></a>1.2.9、DefaultApplicationStartup.DefaultStartupStep.end()</h3><p>默认空实现。<h3 id=1-2-10、AbstractApplicationContext-initMessageSource><a class=headerlink href=#1-2-10、AbstractApplicationContext-initMessageSource title=1.2.10、AbstractApplicationContext.initMessageSource()></a>1.2.10、AbstractApplicationContext.initMessageSource()</h3><p>（1）如果BeanFactory中包含名字为messageSource的Bean，且该Bean属于HierarchicalMessageSource类型，那么为该类型的Bean设置父消息源。<p>（2）如果BeanFactory中没有名字为messageSource的Bean，那么创建一个空的DelegatingMessageSource，并初始化父消息源，然后将之赋值给this.messageSource，然后将该messageSource注册成一个单例。<h3 id=1-2-11、AbstractApplicationContext-initApplicationEventMulticaster><a class=headerlink href=#1-2-11、AbstractApplicationContext-initApplicationEventMulticaster title=1.2.11、AbstractApplicationContext.initApplicationEventMulticaster()></a>1.2.11、AbstractApplicationContext.initApplicationEventMulticaster()</h3><p>（1）如果BeanFactory中存在一个名字为applicationEventMulticaster的Bean，那么获取该Bean并将之赋值给this.applicationEventMulticaster。<p>（2）如果BeanFactory中没有名字为applicationEventMulticaster的Bean，那么创建一个SimpleApplicationEventMulticaster并赋值给this.applicationEventMulticaster，并将该实例以applicationEventMulticaster为名字注册为单例。<h3 id=1-2-12、ServletWebServerApplicationContext-onRefresh><a class=headerlink href=#1-2-12、ServletWebServerApplicationContext-onRefresh title=1.2.12、ServletWebServerApplicationContext.onRefresh()></a>1.2.12、ServletWebServerApplicationContext.onRefresh()</h3><p><strong>（1）调用父类的onRefresh()方法</strong><p>初始化主题源this.themSource为ResourceBundleThemeSource。<p><strong>（2）调用ServletWebServerApplicationContext.createWebServer()方法创建WebServer</strong><p>如果WebServer、ServletContext不为null，那么获取自定义初始化器，并调用其onstartup方法。<p>如果WebServer、ServletContext为null，那么获取WebServerFactory，再通过Factory获取WebServer。<p><strong>（3）获取WebServerFactory和WebServer</strong><p>获取接口ServletWebServerFactory的所有实现类名字，默认会获取到一个tomcatServletWebServerFactory，然后根据该名字尝试从BeanFactory中获取。<p>调用TomcatServletWebServerFactory.getWebServer()方法来获取WebServer，参数是一个ServletContextInitializer类型的数组，符合要求时会调用实现类的onStartup()方法。<p>创建Tomcat类实例对象，为其设置BaseDir为/var/folders/ys/xxxxxxxx/T/tomcat.9001.xxxxxxxxx。如果存在接口LifecycleListener的实现类，那么将这些实现类添加进当前tomcat实例的Server中。<p>基于Http11NioProtocol创建Connector类实例，然后将该实例添加进tomcat实例的Service中。对该Connector实例进行自定义设置，比如：设置端口号；如果connector的ProtocolHandler是AbstractProtocol类型，那么对其进行自定义配置，执行它们的customize(protocolHandler)方法；设置URIEncoding为UTF-8；设置属性bindOnInit为false；如果开启了HTTP2，那么使用Http2Protocol；如果开启了SSL，那么对其进行配置；使用TomcatConnectorCustomizer对connector进行定制；<p>为当前tomcat实例设置定制后的connector实例，并关闭tomcat实例中Host的自动部署功能，设置tomcat实例的Engine后台处理延迟为10秒。如果当前存在连接Connector，那么为tomcat实例的Service添加connector。<p>准备上下文Context。为context设置name为””，设置displayName为application，设置path为””，设置DocBase为/var/folders/ys/xxxxxxx/T/tomcat-docbase.9001.xxxxx，为context添加生命周期监听器Tomcat.FixContextListener，设置父类加载器，设置默认本地映射：en:UTF-8、fr:UTF-8、ja:UTF-8，设置创建上传目标为true，为context的StandardJarScanner设置StandardJarScanFilter。为context设置Wrapper加载器WrapperLoader，该WrapperLoader会加载TomcatEmbeddedWebappClassLoader。为context添加LifecycleListener的StaticResourceConfigurer。<p>将当前context添加进Host中，然后再对context做一些配置。<p><strong>最后基于参数tomcat实例、true、名字是IMMEDIATE的Shutdown实例创建TomcatWebServer实例返回。</strong><p><strong>（4）注册两个Lifecycle</strong><p>一个是名字为webServerGracefulShutdown的WebServerGracefulShuedownLifecycle。<p>一个是名字为webServerStartStop的WebServerStartStopLifecycle。<p><strong>（5）调用GenericWebApplicationContext.initPropertySources()方法来初始化属性源。</strong><h3 id=1-2-13、AbstractApplicationContext-registerListeners><a class=headerlink href=#1-2-13、AbstractApplicationContext-registerListeners title=1.2.13、AbstractApplicationContext.registerListeners()></a>1.2.13、AbstractApplicationContext.registerListeners()</h3><p>（1）获取所有ApplicationListener实现类，然后将这些实现类添加进SimpleApplicationEventMulticaster中。<p>（2）如果存在早期的ApplicationEvent，那么通过上一步获取事件多播器触发这些Event。<h3 id=1-2-14、AbstractApplicationContext-finishBeanFactoryInitialization><a class=headerlink href=#1-2-14、AbstractApplicationContext-finishBeanFactoryInitialization title=1.2.14、AbstractApplicationContext.finishBeanFactoryInitialization(.)></a>1.2.14、AbstractApplicationContext.finishBeanFactoryInitialization(.)</h3><p>（1）如果BeanFactory中存在名字为conversionService的Bean那么为BeanFactory设置该Bean。<p>（2）如果BeanFactory中不存在StringValueResolver，那么为之设置一个，该Resolver会调用当前environment来解析占位符。<p>（3）如果BeanFactory中存在类型LoadTimeWeaverAware的Bean定义名字，那么实例话这个Bean并放入容器中。<p>（4）冻结配置<p><strong>（5）预实例化Bean。会将所有的Bean定义进行实例化并放入容器中</strong>。<p>遍历所有的Bean定义名字，先实例化非FactoryBean类型的、抽象的、非单例的、懒加载的那些Bean，其中先处理SmartInitializingSingleton类型的Bean，并执行这些bean的afterSingletonsInstantiated()方法，然后基于bean名字获取合并的bean定义。<p>如果当前bean属于FactoryBean类型，那么在bean名字前拼接符号&来尝试获取bean，如果不属于FactoryBean类型，那么直接通过bean名字尝试获取bean。<p>如果当前bean是FactoryBean类型<h3 id=1-2-15、AbstractApplicationContext-finishRefresh><a class=headerlink href=#1-2-15、AbstractApplicationContext-finishRefresh title=1.2.15、AbstractApplicationContext.finishRefresh()></a>1.2.15、AbstractApplicationContext.finishRefresh()</h3><p>入口从AbstractApplicationContext.finishRefresh()方法开始。该方法会做如下事情：<ol><li><strong>初始化生命周期处理器并调用其刷新方法完成刷新。内置Tomcat的启动在这一步实现。</strong><li><strong>发布ContextRefreshedEvent事件。监听到该事件的监听器会做自己的相关操作。</strong></ol><p><strong>（1）AbstractApplicationContext.finishRefresh()</strong><p>调用DefaultLifecycleProcessor.onRefresh()方法来处理。<p><strong>（2）DefaultLifecycleProcessor.onRefresh()</strong><p>调用DefaultLifecycleProcessor.startBeans(true)方法来处理。<p><strong>（3）DefaultLifecycleProcessor.startBeans(true)</strong><p>调用DefaultLifecycleProcessor.start()方法来处理。<p><strong>（4）DefaultLifecycleProcessor.start()</strong><p>调用DefaultLifecycleProcessor.doStart()方法来处理。<p><strong>（5）DefaultLifecycleProcessor.doStart()</strong><p>这一步会调用实现Lifecycle接口的所有实现类的start方法。以WebServerStartStopLifecycle.start()方法为例来分析。<p><strong>（6）WebServerStartStopLifecycle.start()</strong><p>调用TomcatWebServer.start()方法来处理，然后设置running为true，最后发布ServletWebServerInitializedEvent事件。<p><strong>（7）TomcatWebServer.start()</strong><p>调用TomcatWebServer.addPreviouslyRemovedConnectorrs()方法来为所有的service添加connector。<p><strong>（8）TomcatWebServer.addPreviouslyRemovedConnectorrs()</strong><p>遍历所有service，通过每个service获取所有的connector，然后再调用StandardService.addConnector(Connector) 方法将这些connector添加进对应的service中。<p><strong>（9）StandardService.addConnector(Connector)</strong><p>调用当前Connector的start()方法开启Tomcat初始化等操作。详情查看Tomcat原理解析章节。<h3 id=1-2-16、catch-BeanException><a class=headerlink href=#1-2-16、catch-BeanException title=1.2.16、catch:BeanException></a>1.2.16、catch:BeanException</h3><p>（1）AbstractApplicationContext.destroyBeans()<p>（2）AbstractApplicaitonContext.cancelRefresh(.)<h3 id=1-2-18、finally><a class=headerlink href=#1-2-18、finally title=1.2.18、finally></a>1.2.18、finally</h3><p>（1）AbstractApplicationContext.resetCommonCaches()<p>清理定义的方法和字段缓存，清理注册过滤器缓存，清理解析类型缓存，清理缓存操作关连的类加载器。<p>（2）DefaultApplicationStartup.DefaultStartupStep.end()<p>调用end方法标识执行结束。<h1 id=Web开发><a class=headerlink href=#Web开发 title=Web开发></a>Web开发</h1><h2 id=1-1、概述><a class=headerlink href=#1-1、概述 title=1.1、概述></a>1.1、概述</h2><p>web开发场景下，springboot默认使用的自动配置类如下<ul><li><strong>Client</strong><ul><li>RestTemplateAutoConfiguration<ul><li>HttpMessageConvertersAutoConfiguration<ul><li>GsonAutoConfiguration：会使用GsonProperties读取前缀为spring.gson的配置，<li>JacksonAutoConfiguration：会使用JacksonProperties读取前缀为spring.jackson的配置。<li>JsonbAutoConfiguration</ul></ul></ul><li><strong>Embedded</strong><ul><li>EmbeddedWebServerFactoryCustomizerAutoConfiguration：会使用ServerPropertie读取前缀为server的配置。</ul><li><strong>Servlet应用</strong><ul><li>DispatcherServletAutoConfiguration：会使用WebMvcProperties读取前缀为spring.mvc的配置。<li>ServletWebServerFactoryAutoConfiguration：会使用ServerProperties读取前缀为server的配置。<li>ErrorMvcAutoConfiguration：会使用ServerProperties读取前缀为server的配置，使用WebMvcProperties读取前缀为spring.mvc的配置，使用WebProperties读取前缀为spring.web的配置。<li>HttpEncodingAutoConfiguration：会使用ServerProperties读取前缀为server的配置。<li>MultipartAutoConfiguration：会使用MultipartProperties读取前缀为spring.servlet.multipart的配置。<li>WebMvcAutoConfiguration：会使用WebProperties读取前缀spring.web的配置，使用WebMvcProperties读取spring.mvc的配置。</ul><li><strong>Reactive应用</strong><ul><li>HttpHandlerAutoConfiguration<li>ReactiveMultipartAutoConfiguration<li>ReactiveWebServerFactoryAutoConfiguration<li>WebFluxAutoConfiguration<li>WebSessionIdResolverAutoConfiguration<li>ErrorWebFluxAutoConfiguration<li>ClientHttpConnectorAutoConfiguration<li>WebClientAutoConfiguration</ul></ul><h2 id=1-2、Servlet应用><a class=headerlink href=#1-2、Servlet应用 title=1.2、Servlet应用></a>1.2、Servlet应用</h2><h3 id=1-2-1、概述><a class=headerlink href=#1-2-1、概述 title=1.2.1、概述></a>1.2.1、概述</h3><p><font color=red>注意事项：当显式使用注解 @EnableWebMvc 时，WebMvcAutoConfiguration将不再有效。因为 WebMvcAutoConfiguration 生效的前提是容器中没有 WebMvcConfigurationSupport，而注解 @EnableWebMvc 会间接向容器中注入一个 WebMvcConfigurationSupport。</font><p>自动配置加载顺序如下：<ol><li>ErrorMvcAutoConfiguration<li>ServletWebServerFactoryAutoConfiguration<li>DispatcherServletAutoConfiguration<li>TaskExecutionAutoConfiguration<li>ValidationAutoConfiguration<li>WebMvcAutoConfiguration<li>HttpEncodingAutoConfiguration<li>MultipartAutoConfiguration</ol><h3 id=1-2-2、ErrorMvcAutoConfiguration><a class=headerlink href=#1-2-2、ErrorMvcAutoConfiguration title=1.2.2、ErrorMvcAutoConfiguration></a>1.2.2、ErrorMvcAutoConfiguration</h3><p>自动配置类<code>ErrorMvcAutoConfiguration</code>生效的前提条件如下：<ol><li>项目类型是servlet类型.<li>存在class：Servlet.class、DispatcherServlet.class。</ol><p>自动配置类<code>ErrorMvcAutoConfiguration</code>会读取ServerProperties.class、WebMvcProperties.class。<p>自动配置类<code>ErrorMvcAutoConfiguration</code>拥有如下内部类或接口：<ul><li><strong>DefaultErrorViewResolverConfiguration</strong><li><strong>ErrorPageCustomizer</strong><li><strong>ErrorTemplateMissingCondition</strong><li><strong>PreserverErrorControllerTargetClassPostProcessor</strong><li><strong>StaticView</strong><li><strong>WhitelabelErrorViewConfiguration</strong></ul><p><strong>1. 内部类 DefaultErrorViewResolverConfiguration</strong><p>如果存在DispatcherServlet.class，且没有ErrorViewResolver.class时，向容器中注入一个DefaulErrorViewResolver。<p><strong>2. 内部类 ErrorPageCustomizer</strong><p>获取错误页面的路径，如果配置了属性error.path，则以配置的为准，否则以默认路径<code>/error</code>为准。<p>从错误路径下获取所有的错误页面，将这些错误页面添加进错误页面注册器ErrorPageRegistry中。<p><strong>3. 内部类 ErrorTemplateMissingCondition</strong><p>配置错误模板缺失匹配规则 ErrorTemplateMissingCondition。<p><strong>4. 内部类 PreserverErrorControllerTargetClassPostProcessor</strong><p>实现BeanFactoryPostProcessor的postProcessBeanFactory方法。<p>获取类型为ErrorController.class的所有Bean的定义，为所有Bean的定义设置属性值 preserveTargetClass=true。<p>ErrorController.class类型的Bean默认有1个，即 BasicErrorController。<p><em><strong>BasicErrorController会拦截请求路径为 server.error.path 或 error.path 或 /error 的请求，且处理方式分两种</strong></em>：<ul><li><p><strong>将错误信息以JSON格式返回</strong></p> <p>当对响应数据的格式没有要求，会被方法error拦截，该方法会将错误信息以JSON格式返回；</p><li><p><strong>将错误信息以错误视图方式返回</strong></p> <p>当要求响应数据的媒体类型是<code>text/html</code>，会被方法 errorHtml 拦截，该方法会以错误视图页面的方式返回。</p> <p><strong>错误视图的查找匹配规则如下</strong>：</p> <ol><li>精确匹配响应码为名字的页面，比如404.html、500.html等。如果使用了模板引擎，那么会先到路径 <code>resources/templates/error/</code>下查找；如果没有使用模板引擎，那么会到静态资源路径下查找。<li>匹配通用模糊错误页面，比如4xx.html、5xx.html等。如果使用了模板引擎，那么会先到路径<code>resources/templates/error/</code>下查找；如果没有使用模板引擎，那么会到静态资源路径下查找。<li>如果通用模糊错误页面也没有找到，那么会直接查找名字为 error 的页面。<li>如果名字为 error 的页面也没有找到，那么会使用spring boot的默认 error 页面，也就是白页。</ol></ul><p><strong>5. 内部类 StaticView</strong><p>在方法 render 中进行错误视图的渲染，也就是将错误信息渲染到白页中，然后在浏览器中展示。<p><strong>6. 内部类 WhitelabelErrorViewConfiguration</strong><p>如果配置了属性 server.error.whitelabel.enabled，但属性值不为true，且符合内部类ErrorTemplateMissingCondition定义的规则，那么继续。<p>如果容器中缺少名字为 error，类型是View的Bean，那么向容器中注入一个名字为 error 类型是 StaticView（白页） 的Bean。<p>如果容器中缺少名字为 beanNameViewResolver 类型是 BeanNameViewResolver 的Bean，那么向容器中注入一个名字是 beanNameViewResolver 类型是 BeanNameViewResolver 的Bean。<h3 id=1-2-3、ServletWebServerFactoryAutoConfiguration><a class=headerlink href=#1-2-3、ServletWebServerFactoryAutoConfiguration title=1.2.3、ServletWebServerFactoryAutoConfiguration></a>1.2.3、ServletWebServerFactoryAutoConfiguration</h3><p>自动配置类<code>ServletWebServerFactoryAutoConfiguration</code>生效的前提条件如下：<ol><li>项目类型是servlet类型.<li>存在class：ServletRequest.class。</ol><p>自动配置类<code>ServletWebServerFactoryAutoConfiguration</code>会读取ServerProperties.class、WebMvcProperties.class。<p>自动配置类<code>ServletWebServerFactoryAutoConfiguration</code>拥有如下内部类或接口：<ul><li><strong>BeanPostProcessorsRegistrar</strong><li><strong>ForwardedHeaderFilterConfiguration</strong><li><strong>ForwardedHeaderFilterCustomizer</strong></ul><p><strong>1. 自动配置类本身操作</strong><p>会通过@Import导入如下类：<ul><li><strong>BeanPostProcessorsRegistrar</strong><li><strong>ServletWebServerFactoryConfiguration.EmbeddedTomcat</strong><li><strong>ServletWebServerFactoryConfiguration.EmbeddedJetty</strong><li><strong>ServletWebServerFactoryConfiguration.EmbeddedUndertow</strong></ul><p>会向容器中注入类：<ul><li><strong>ServletWebServerFactoryCustomizer</strong><li>如果存在org.apache.catalina.startup.Tomcat，那么导入TomcatServletWebServerFactoryCustomizer</ul><p><strong>2. 内部类BeanPostProcessorsRegistrar操作</strong><p>实现了接口 ImportBeanDefinitionRegistrar 的 registerBeanDefinitions方法，如果缺失就注册两个bean：webServerFactoryCustomizerBeanPostProcessor、errorPageRegistrarBeanPostProcessor。<p><strong>3. 内部类ForwardedHeaderFilterConfiguration操作</strong><p>如果配置了属性server.forward-headers-strategy=framework，那么配置有效。<p>如果存在org.apache.catalina.startup.Tomcat，那么向容器中注入一个ForwardedHeaderFilterCustomizer。<p>向容器中注入一个FilterRegistrationBean。<h3 id=1-2-4、DispatcherServletAutoConfiguration><a class=headerlink href=#1-2-4、DispatcherServletAutoConfiguration title=1.2.4、DispatcherServletAutoConfiguration></a>1.2.4、DispatcherServletAutoConfiguration</h3><p>该自动配置类生效的前提是：<ol><li>已经加载了执行了ServletWebServerFactoryAutoConfiguration<li>项目是servlet类型。<li>存在class：DispatcherServlet.class。</ol><p>该自动配置类存在如下内部类：<ul><li>DispatcherServletRegistrationConfiguration<li>DispatcherServletConfiguration</ul><p><strong>1. 静态内部类：DispatcherServletRegistrationConfiguration</strong><p>该配置生效的前提是存在class：ServletRegistration。<p>该配置类会导入DispatcherServletConfiguration。<p>如果已经存在名字为dispatcherServlet的DispatcherServlet，那么创建DispatcherServletRegistrationBean，设置其名字为dispatcherServlet，并为其设置文件上传，最后放入容器。<p><strong>2. 静态内部类：DispatcherServletConfiguration</strong><p>该自动配置类生效的前提是存在class：ServletRegistration。<p>该配置类会读取WebMvcProperties绑定的前缀为<code>spring.mvc</code>的配置。<p>创建名字为 dispatcherServlet 的 DispatcherServlet，为其设置WebMvcProperties绑定的dispatchOptionsRequest、dispatchTraceRequest、异常抛出、事件发布、日志记录等配置，最后放入容器中。<p>如果存在Bean：MultipartResolver，且缺失名字为multipartResolver的Bean，那么创建MultipartResolver并放入容器。<h3 id=1-2-5、TaskExecutionAutoConfiguration><a class=headerlink href=#1-2-5、TaskExecutionAutoConfiguration title=1.2.5、TaskExecutionAutoConfiguration></a>1.2.5、TaskExecutionAutoConfiguration</h3><p>该自动配置生效的前提是存在class：ThreadPoolTaskExecutor。<p>如果容器中缺少名字为 taskExecutorBuilder 的 TaskExecutorBuilder，那么创建它并放入容器中。<p>如果缺少Bean：Executor，那么创建名为 applicationTaskExecutor 或 taskExecutor 的 ThreadPoolTaskExecutor。<h3 id=1-2-6、ValidationAutoConfiguration><a class=headerlink href=#1-2-6、ValidationAutoConfiguration title=1.2.6、ValidationAutoConfiguration></a>1.2.6、ValidationAutoConfiguration</h3><p>该自动配置生效的前提如下：<ul><li>存在class：ExecutableValidator。<li>存在resource：classpath:META-INF/services/javax.validation.spi.ValidationProvider</ul><p>该自动配置会导入PrimaryDefaultValidatorPostProcessor。<p>如果缺少Bean：Validator，那么创建名字 defaultValidator 的 LocalValidatorFactoryBean 放入容器。<p>如果当前查找策略缺失，那么创建名为 methodValidationPostProcessor 的 FilteredMethodValidationPostProcessor，为其设置验证器，设置proxyTargetClass的值为属性spring.aop.proxy-target-class的值，最后将之放入容器。<h3 id=1-2-7、WebMvcAutoConfiguration><a class=headerlink href=#1-2-7、WebMvcAutoConfiguration title=1.2.7、WebMvcAutoConfiguration></a>1.2.7、WebMvcAutoConfiguration</h3><p><strong>自动配置类<code>WebMvcAutoConfiguration</code>生效的前提条件如下：</strong><ol><li>自动配置类<code>DispatcherServletAutoConfiguration、TaskExecutionAutoConfiguration、ValidationAutoConfiguration</code>已经加载配置完毕。<li>当前项目类型必须是Servlet类型。<li>必须存在class：<code>Servlet.class、DispatcherServlet.class、WebMvcConfigurer.class</code>。<li>项目没有手动配置<code>WebMvcConfigurationSupport.class</code>。</ol><p><strong>自动配置类<code>WebMvcAutoConfiguration</code>内部类或接口如下：</strong><ul><li>EnableWebMvcConfiguration<li>WebMvcAutoConfigurationAdapter<li>OptionPathExtensionContentNegotiationStrategy<li>ProblemDetailsErrorHandingConfiguration<li>ReourceChainCustomizerConfiguration<li>ResourceChainResourceHandlerRegistrationCustomizer<li>接口 ResourceHandlerRegistrationCustomizer<li>接口 WelcomePageHandlerMappingFactory</ul><p>**1. WebMvcAutoConfiguration本身操作 **<p>向容器中注入两个Filter<ul><li>OrderedHiddenHttpMethodFilter：页面表单提交Rest请求（GET、POST、PUT、DELETE）。<li>OrderedFormContentFilter：表单内容Filter，GET请求数据放地址后面，POST请求数据放请求体，PUT、DELET请求会被忽略。</ul><p><strong>2. 静态内部类：EnableWebMvcConfiguration</strong><p>该内部类继承了 DelegatingWebMvcConfiguration，间接继承了 WebMvcConfigurationSupport。<strong>通过DelegatingWebMvcConfiguration 可以获取 WebMvcConfigurer 的所有实现类实现定制化配置，通过 WebMvcConfigurationSupport 可以为 DispatcherServlet 初始化必要的组件</strong>。<p>创建 RequestMappingHandlerAdapter、WelcomePageHandlerMapping、WelcomePageNotAcceptableHandlerMapping、LocaleResolver并注入到容器中。<p>如果不存在名字为 themeResolver 的 ThemeResolver，那么就创建一个名字为 themeResolver 的ThemeResolver。如果不存在名字为 flashMapManager的 FlashMapManager，那么就创建一个名字为 flashMapManager 的FlashMapManager。<p>创建名字为 mvcConversionService 的 FormattingConversionService 并注入到容器中。创建名字为 nvcValidator 的 Validator 并注入到容器中。创建名字为 mvcContentNegotiationManager 的 ContentNegotiationManager 并注入到容器中。<p><strong>3. 静态内部类：WebMvcAutoConfigurationAdapter</strong><p>首先导入一个配置类 EnableWebMvcConfiguration.class。<p>该内部类实现了 WebMvcConfigurer、ServletContextAware，通过 WebMvcConfigurer 可以定制化一些底层组件。<p>如果没有 InternalResourceViewResolver，那么创建名为 defaultViewResolver 的 InternalResourceViewResolver 并注入到容器中。<p>如果存在 View.calss，但没有 BeanNameViewResolver，那么创建名为 beanNameViewResolver 的 BeanNameViewResolver 并注入到容器中。<p>如果存在 ViewResolver.class，但没有名字为 viewResolver 的 ContentNegotiatingViewResolver，那么就创建名字为 viewResolver 的 ContentNegotiatingViewResolver 并注入到容器中。<p>如果没有 RequestContextListener、RequestContextFilter、RequestContextFilter，那么创建名为 requestContextFilter 的 OrderedRequestContextFilter 并注入到容器中。<p><strong>4. 静态内部类：OptionPathExtensionContentNegotiationStrategy</strong><p>配置内容协商策略，默认支持所有类型的内容，即MediaType.ALL。如果显式配置了协商策略，则以自定义配置的为准。<p><strong>5. 静态内部类：ProblemDetailsErrorHandingConfiguration</strong><p>如果配置了 spring.mvc.problemdetails.enabled : true，该配置才会生效。<p>如果不存在 ResponseEntityExceptionHandler.class，那么创建 ProblemDetailsExceptionHandler 并注入到容器中。<p>ProblemDetailsExceptionHandler 被注解 @ControllerAdvice 标示，且继承了 ResponseEntityExceptionHnadler，ResponseEntityExceptionHnadler中方法handlerException被注解 @ExceptionHandler 标示，该方法可以处理常见的16个异常。 该方法在处理异常时，会使用新媒体类型<code>application/problem+json</code>来返回错误信息。<p><strong>6. 静态内部类：ReourceChainCustomizerConfiguration</strong><p>如果开启了资源链功能，那么向容器中注入一个ResourceChainResourceHandlerRegistrationCustomizer。<p><strong>7. 静态内部类：ResourceChainResourceHandlerRegistrationCustomizer</strong><p>如果在配置文件中spring.web开头下配置了资源链，那么应用配置的内容。<p><strong>8. 接口 ResourceHandlerRegistrationCustomizer</strong><p><strong>9. 接口 WelcomePageHandlerMappingFactory</strong><h2 id=1-3、Client应用><a class=headerlink href=#1-3、Client应用 title=1.3、Client应用></a>1.3、Client应用</h2><p>自动配置加载顺序如下：<ol><li>GsonAutoConfiguration<li>JacksonAutoConfiguration<li>JsonbAutoConfiguration<li>HttpMessageConvertersAutoConfiguration<li>RestTemplateAutoConfiguration</ol><h3 id=1-3-1、GsonAutoConfiguration><a class=headerlink href=#1-3-1、GsonAutoConfiguration title=1.3.1、GsonAutoConfiguration></a>1.3.1、GsonAutoConfiguration</h3><p><strong>当前自动配置生效的前提是存在calss：Gson</strong>。<p>如果缺失GsonBuilder，那么创建一个名为 gsonBuilder 的 GsonBuilder，使用GsonBuilderCustomizer的所有实现对该builder进行定制化，最后将该builder放入容器。<p>如果缺失Gson，那么创建一个名为 gson 的 Gson 放入容器。<p>创建一个名为 standardGsonBuilderCustomizer 的 StandardGsonBuilderCustomizer 放入容器。<p><strong>1. 静态内部类：StandardGsonBuilderCustomizer</strong><p>创建接口 GsonBuilderCustomizer 的实现 StandardGsonBuilderCustomizer，在customize方法中配置对 GsonBuilder 进行定制化处理。<h3 id=1-3-2、JacksonAutoConfiguration><a class=headerlink href=#1-3-2、JacksonAutoConfiguration title=1.3.2、JacksonAutoConfiguration></a>1.3.2、JacksonAutoConfiguration</h3><p>自动配置生效的前提是存在class：ObjectMapper。<p>初始化 FEATURE_DEFAULTS，设置<code>SerializationFeature.WRITE_DATES_AS_TIMESTAMPS</code>为 false，<code>SerializationFeature.WRITE_DURATIONS_AS_TIMESTAMPS</code>为false。<p>创建一个JsonComponentModule放入容器。基于自动配置包名创建一个 JsonMixinModule 放入容器。<p><strong>1. 静态内部类：Jackson2ObjectMapperBuilderCustomizerConfiguration</strong><p>生效的前提是存在class：Jackson2ObjectMapperBuilder。<p>创建StandardJackson2ObjectMapperBuilderCustomizer放入容器。<p>创建接口 Jackson2ObjectMapperBuilderCustomizer 的实现StandardJackson2ObjectMapperBuilderCustomizer，通过customize方法对 Jackson2ObjectMapperBuilder 进行定制化处理。<p><strong>2. 静态内部类：JacksonObjectMapperBuilderConfiguration</strong><p>生效的前提是存在class：Jackson2ObjectMapperBuilder。<p>创建Jackson2ObjectMapperBuilder，并基于 Jackson2ObjectMapperBuilderCustomizer 的所有实现对该 builder 进行定制化处理，最后将builder放入容器。<p><strong>3. 静态内部类：ParameterNamesModuleConfiguration</strong><p>生效的前提是存在class：ParameterNamesModule。<p>如果缺失 ParameterNamesModule，那么基于默认模式创建 ParameterNamesModule 并放入容器。<p><strong>4. 静态内部类：JacksonObjectMapperConfiguration</strong><p>生效的前提是存在class：Jackson2ObjectMapperBuilder。<p>如果缺失 ObjectMapper，那么创建名为 jacksonObjectMapper 的 ObjectMapper 并放入容器。<h3 id=1-3-3、JsonbAutoConfiguration><a class=headerlink href=#1-3-3、JsonbAutoConfiguration title=1.3.3、JsonbAutoConfiguration></a>1.3.3、JsonbAutoConfiguration</h3><p>生效的前提是存在class：Jsonb，且存在resource：classpath:META-INF/services/javax.json.bind.spi.JsonbProvider”, “classpath:META-INF/services/javax.json.spi.JsonProvider。<p>创建名为 jsonb 的 Jsonb 放入容器。<h3 id=1-3-4、HttpMessageConvertersAutoConfiguration><a class=headerlink href=#1-3-4、HttpMessageConvertersAutoConfiguration title=1.3.4、HttpMessageConvertersAutoConfiguration></a>1.3.4、HttpMessageConvertersAutoConfiguration</h3><p>该自动配置类生效的前提：<ul><li>已经加载了配置：GsonAutoConfiguration、JacksonAutoConfiguration、JsonbAutoConfiguration。<li>存在class：HttpMessageConverter。<li>NotReactiveWebApplicationCondition符合要求。</ul><p>该自动配置类会导入如下配置：<ul><li>JacksonHttpMessageConvertersConfiguration<li>GsonHttpMessageConvertersConfiguration<li>JsonbHttpMessageConvertersConfiguration</ul><p>如果缺失 HttpMessageConverters ，那么基于基于所有的 HttpMessageConverter 创建 HttpMessageConverters并放入容器。<p><strong>1. 静态内部类：StringHttpMessageConverterConfiguration</strong><p>该配置生效前提是存在class：StringHttpMessageConverter。<p>如果缺失 StringHttpMessageConverter，那么创建 StringHttpMessageConverter 并放入容器。<h3 id=1-3-5、RestTemplateAutoConfiguration><a class=headerlink href=#1-3-5、RestTemplateAutoConfiguration title=1.3.5、RestTemplateAutoConfiguration></a>1.3.5、RestTemplateAutoConfiguration</h3><p>该配置生效的前提如下：<ul><li>已经加载配置 HttpMessageConvertersAutoConfiguration。<li>存在class：RestTemplate。<li>NotReactiveWebApplicationCondition符合要求。</ul><p>如果缺失 RestTemplateBuilderConfigurer，那么创建 RestTemplateBuilderConfigurer，设置为懒加载，并放入容器。<p>如果缺失 RestTemplateBuilder，那么创建 RestTemplateBuilder，使用 RestTemplateBuilderConfigurer 对该builder进行配置，设置该builder为懒加载，并放入容器。<h2 id=1-4、嵌入式应用><a class=headerlink href=#1-4、嵌入式应用 title=1.4、嵌入式应用></a>1.4、嵌入式应用</h2><p>自动配置如下：<ul><li>EmbeddedWebServerFactoryCustomizerAutoConfiguration</ul><h3 id=1-4-1、EmbeddedWebServerFactoryCustomizerAutoConfiguration><a class=headerlink href=#1-4-1、EmbeddedWebServerFactoryCustomizerAutoConfiguration title=1.4.1、EmbeddedWebServerFactoryCustomizerAutoConfiguration></a>1.4.1、EmbeddedWebServerFactoryCustomizerAutoConfiguration</h3><p>该自动配置生效的前提：<ul><li>当前项目是web应用<li>非传统war包部署的应用程序</ul><p><strong>1. 静态内部类：TomcatWebServerFactoryCustomizerConfiguration</strong><p>该配置生效的前提是存在class：Tomcat、UpgradeProtocol。<p>创建 TomcatWebServerFactoryCustomizer 放入容器。<p><strong>2. 静态内部类：JettyWebServerFactoryCustomizerConfiguration</strong><p>该配置生效的前提是存在class：Server、Loader、WebAppContext。<p>创建 JettyWebServerFactoryCustomizer 放入容器。<p><strong>3. 静态内部类：UndertowWebServerFactoryCustomizerConfiguration</strong><p>该配置生效的前提是存在class：Undertow、SslClientAuthMode。<p>创建 UndertowWebServerFactoryCustomizer 放入容器。<p><strong>4. 静态内部类：NettyWebServerFactoryCustomizerConfiguration</strong><p>该配置生效的前提是存在class：HttpServer。<p>创建 NettyWebServerFactoryCustomizer 放入容器。<h2 id=1-5、Reactive应用><a class=headerlink href=#1-5、Reactive应用 title=1.5、Reactive应用></a>1.5、Reactive应用</h2><p>待补充。<h1 id=AOP管理><a class=headerlink href=#AOP管理 title=AOP管理></a>AOP管理</h1><h2 id=1-1、概述-1><a class=headerlink href=#1-1、概述-1 title=1.1、概述></a>1.1、概述</h2><p><strong>对于AOP功能，springboot默认加载的自动配置为 AopAutoConfiguration</strong>。<h2 id=1-2、AopAutoConfiguration><a class=headerlink href=#1-2、AopAutoConfiguration title=1.2、AopAutoConfiguration></a>1.2、AopAutoConfiguration</h2><p>该配置生效的前提是设置了属性<code>spring.aop.auto=true</code>。<p><strong>1. 静态内部类：AspectJAutoProxyingConfiguration</strong><p>该配置生效的前提是存在class：Advice。<p><strong>如果设置了属性<code>spring.aop.proxy-target-class=false</code>，开启JDK动态代理。</strong>会向容器中导入一个AspectJAutoProxyRegistrar，该类实现了 ImportBeanDefinitionRegistrar 的 registerBeanDefinitions方法，在该方法中会获取自动代理创建器的bean定义信息，为该bean定义设置属性proxyTargetClass=true。<p><strong>如果设置了属性<code>spring.aop.proxy-target-class=true</code>，或没有配置该属性，那么都会开启CGLib代理。</strong>会向容器中导入一个AspectJAutoProxyRegistrar，该类实现了 ImportBeanDefinitionRegistrar 的 registerBeanDefinitions方法，在该方法中会获取自动代理创建器的bean定义信息，为该bean定义设置属性exposeProxy=true。<p><strong>2. 静态内部类：ClassProxyingConfiguration</strong><p>该配置生效的前提如下：<ul><li>缺失class：org.aspectj.weaver.Advice。<li>设置了属性 spring.aop.proxy-target-class=true。</ul><p>创建一个BeanFactoryPostProcessor，通过该增强器向容器中放入一个代理创建器，实现最终代理对象的创建。<h1 id=事务管理><a class=headerlink href=#事务管理 title=事务管理></a>事务管理</h1><h2 id=1-1、概述-2><a class=headerlink href=#1-1、概述-2 title=1.1、概述></a>1.1、概述</h2><p>对于事务管理，springboot默认自动配置如下：<ul><li><strong>TransactionAutoConfiguration</strong>：会读取TransactionProperties绑定的前缀为<code>spring.transaction</code>的配置。<li><strong>JtaAutoConfiguration</strong>：</ul><h2 id=1-2、TransactionAutoConfiguration><a class=headerlink href=#1-2、TransactionAutoConfiguration title=1.2、TransactionAutoConfiguration></a>1.2、TransactionAutoConfiguration</h2><p>该配置生效的前提是存在class：PlatformTransactionManager。<p>如果缺失 TransactionManagerCustomizers，那么创建 TransactionManagerCustomizers 放入容器。<p>如果缺失 TransactionalOperator，且只存在一个ReactiveTransactionManager，那么创建 TransactionalOperator 放入容器。<p><strong>1. 静态内部类：TransactionTemplateConfiguration</strong><p>该配置生效的前提是容器中只有一个 PlatformTransactionManager。<p>如果缺失 TransactionOperations，那么创建 TransactionTemplate 放入容器。<p><strong>2. 静态内部类：EnableTransactionManagementConfiguration</strong><p>该配置生效的前提是存在TransactionManager，且不存在 AbstractTransactionManagementConfiguration。<p>如果设置了属性spring.aop.proxy-target-class=false，那么使用注解@EnableTransactionManagement(proxyTargetClass=false) 标示 JdkDynamicAutoProxyConfiguration。<p>如果设置了属性spring.aop.proxy-target-class=true，或没有设置，那么使用注解@EnableTransactionManagement(proxyTargetClass=true) 标示 CglibAutoProxyConfiguration。<h2 id=1-3、JtaAutoConfiguration><a class=headerlink href=#1-3、JtaAutoConfiguration title=1.3、JtaAutoConfiguration></a>1.3、JtaAutoConfiguration</h2><p>该配置生效的前提如下：<ul><li>存在class：javax.transaction.Transaction。<li>设置了属性spring.jta.enabled。</ul><p>该配置会导入如下配置：<ul><li>JndiJtaConfiguration<li>AtomikosJtaConfiguration</ul><p>该配置加载完后会加载如下配置：<ul><li>XADataSourceAutoConfiguration<li>ActiveMQAutoConfiguration<li>ArtemisAutoConfiguration<li>HibernateJpaAutoConfiguration<li>TransactionAutoConfiguration</ul></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/SpringAOP/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/SpringAOP/ itemprop=url>Spring系列-SpringAOP</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-04 10:53:40" datetime=2023-10-04T10:53:40+08:00 itemprop=dateModified>2023-10-04</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Spring/ itemprop=url rel=index><span itemprop=name>Spring</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=基础知识><a class=headerlink href=#基础知识 title=基础知识></a>基础知识</h1><h2 id=1-1、使用场景><a class=headerlink href=#1-1、使用场景 title=1.1、使用场景></a>1.1、使用场景</h2><ul><li>Authentication（权限）<li>Caching（缓存）<li>Context passing（内容传递）<li>Error handling（错误处理）<li>Lazy loading（懒加载）<li>Debugging（调试）<li>logging / tracing / profiling and monitoring（记录跟踪 / 优化 / 校准）<li>Performance optimization（性能优化）<li>Persistence（持久化）<li>Resource pooling（资源池）<li>Synchronization（同步）<li>Transactions（事务）</ul><h2 id=1-2、AOP思想><a class=headerlink href=#1-2、AOP思想 title=1.2、AOP思想></a>1.2、AOP思想</h2><p>AOP思想的实现技术主要有Spring AOP 和 AspectJ。<p>AspectJ底层<strong>通过静态代理实现编译时自动编译得到一个新类</strong>，新类增强了原有类功能。<p>Spring AOP底层<strong>通过动态代理实现运行时增强目标方法，不会生成新类</strong>。Spring AOP支持 JDK动态代理 和CGLib代理。<blockquote><p>Spring 允许使用 AspectJ Annotation 来定义方面（Aspect）、切入点（Pointcut）和增强处理（Advice），且可根据这些Annotation来生成AOP代理。Spring 仅仅使用了和AspectJ 5一样的注解，并没有使用AspectJ的编译器或织入器（Weaver）。</blockquote><h2 id=1-3、重要概念><a class=headerlink href=#1-3、重要概念 title=1.3、重要概念></a>1.3、重要概念</h2><ul><li><strong>连接点</strong>：目标对象中可以被增强的方法；<li><strong>切入点</strong>：目标对象中实际被增强的方法；<li><strong>通知</strong>：增强的代码逻辑；<li><strong>切面</strong>：增强和切入点的组合；<li><strong>织入</strong>：将通知和切入点动态组合的过程；</ul><h2 id=1-4、切点表达式><a class=headerlink href=#1-4、切点表达式 title=1.4、切点表达式></a>1.4、切点表达式</h2><h3 id=1-4-1、语法><a class=headerlink href=#1-4-1、语法 title=1.4.1、语法></a>1.4.1、语法</h3><p>切点表达式的语法如下：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>execution([访问修饰符]</span> <span class=string>返回类型 包名.类名.方法名(参数))</span></span><br></pre></table></figure><p>注意事项：<ul><li><strong>访问修饰符可以省略不写</strong>；<li>返回值类型、包名、类名、方法名可以使用<code>*</code>代替，表示任意；<li>包名与类名之间使用<strong>一个点表示该包下的类，两个点表示该包及子包下的类</strong>；<li>参数可以使用<strong>两个点表示任意参数</strong>；</ul><h3 id=1-4-2、常用表达式示例><a class=headerlink href=#1-4-2、常用表达式示例 title=1.4.2、常用表达式示例></a>1.4.2、常用表达式示例</h3><figure class="highlight txt"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>execution(* cn.shh.xxx.A.*(..))：	// 类A下的任意方法都匹配；</span><br><span class=line>execution(* cn.shh.xxx.*.*(..))：	// 包xxx下的任意类的任意方法都匹配；</span><br><span class=line>execution(* cn.shh.xxx..*.*(..))：	// 包xxx及子包下的任意类的任意方法都匹配；</span><br><span class=line>execution(* *..*.*(..))：			// 任意包下任意类的任意方法都匹配；</span><br></pre></table></figure><h2 id=1-5、通知类型><a class=headerlink href=#1-5、通知类型 title=1.5、通知类型></a>1.5、通知类型</h2><p>Spring AOP通知分如下几种：<ol><li><strong>前置通知 Before advice</strong>；<li><strong>后置通知 After (finally) advice</strong>；<li><strong>返回/引入通知 After returning advice</strong>：引入通知只需要进行配置即可，目的是用来指定哪些方法需要执行相应的通知，如，我们想指定只有 sayHello() 方法执行前置通知；<li><strong>异常通知 After throwing advice</strong>；<li><strong>环绕通知 Around advice</strong>；</ol><h1 id=使用AOP><a class=headerlink href=#使用AOP title=使用AOP></a>使用AOP</h1><h2 id=1-1、实现方式><a class=headerlink href=#1-1、实现方式 title=1.1、实现方式></a>1.1、实现方式</h2><p>实现AOP有如下几种方式：<ul><li>使用<code>xml</code>实现；<ul><li>Advisor方式<li>AspectJ方式</ul><li>使用注解实现。<li>使用<code>ProxyFactoryBean</code>实现；<li>使用<code>ProxyFactory</code>实现；</ul><h2 id=1-2、XML实现><a class=headerlink href=#1-2、XML实现 title=1.2、XML实现></a>1.2、XML实现</h2><h3 id=1-2-1、Advisor方式><a class=headerlink href=#1-2-1、Advisor方式 title=1.2.1、Advisor方式></a>1.2.1、Advisor方式</h3><p>xml配置内容如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"test_xml2aop_service"</span> <span class=attr>class</span>=<span class=string>"cn.shh.demo.spring.aop.impl.xml2aop.Xml2AopServieImpl"</span>/></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"test_xml2aop_advice"</span> <span class=attr>class</span>=<span class=string>"cn.shh.demo.spring.aop.impl.xml2aop.Xml2AopAdvice"</span>/></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>aop:config</span> <span class=attr>proxy-target-class</span>=<span class=string>"true"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"test_xml2aop_pointcut"</span> <span class=attr>expression</span>=<span class=string>"execution(* cn.shh.demo.spring.aop.impl.xml2aop.Xml2AopServie.*())"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>aop:advisor</span> <span class=attr>advice-ref</span>=<span class=string>"test_xml2aop_advice"</span> <span class=attr>pointcut-ref</span>=<span class=string>"test_xml2aop_pointcut"</span>></span><span class=tag>&LT/<span class=name>aop:advisor</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br></pre></table></figure><p>Java类文件内容如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Xml2AopAdvice</span> <span class=keyword>implements</span> <span class="title class_">Advice</span>, Ordered {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">getOrder</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">before</span><span class=params>()</span>{</span><br><span class=line>        System.out.println(<span class=string>"--- xml before advice ---"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">after</span><span class=params>()</span>{</span><br><span class=line>        System.out.println(<span class=string>"--- xml after advice ---"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">afterReturning</span><span class=params>()</span>{</span><br><span class=line>        System.out.println(<span class=string>"--- xml afterReturn advice ---"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">afterThrowing</span><span class=params>()</span>{</span><br><span class=line>        System.out.println(<span class=string>"--- xml throwing advice ---"</span>);</span><br><span class=line>    }</span><br><span class=line>    Object <span class="title function_">aroundAdvice</span><span class=params>(ProceedingJoinPoint pjp)</span> <span class=keyword>throws</span> Throwable{</span><br><span class=line>        System.out.println(<span class=string>"Xml2AopAdvice.aroundAdvice before"</span>);</span><br><span class=line>        <span class=type>Object</span> <span class=variable>result</span> <span class=operator>=</span> pjp.proceed();</span><br><span class=line>        System.out.println(<span class=string>"Xml2AopAdvice.aroundAdvice after"</span>);</span><br><span class=line>        <span class=keyword>return</span> result;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=comment>//====================</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Xml2AopServie</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">info</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line><span class=comment>//====================</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Xml2AopServieImpl</span> <span class=keyword>implements</span> <span class="title class_">Xml2AopServie</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">info</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Xml2AopServieImpl.info"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-2、AspectJ方式><a class=headerlink href=#1-2-2、AspectJ方式 title=1.2.2、AspectJ方式></a>1.2.2、AspectJ方式</h3><p>xml配置内容如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"test_xml2aop_service2"</span> <span class=attr>class</span>=<span class=string>"cn.shh.demo.spring.aop.impl.xml2aop.Xml2AopServieImpl"</span>/></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"test_xml2aop_advice2"</span> <span class=attr>class</span>=<span class=string>"cn.shh.demo.spring.aop.impl.xml2aop.Xml2AopAdvice2"</span>/></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>aop:config</span> <span class=attr>proxy-target-class</span>=<span class=string>"true"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>aop:aspect</span> <span class=attr>id</span>=<span class=string>"test_xml2aop_aspect"</span> <span class=attr>ref</span>=<span class=string>"test_xml2aop_advice2"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>aop:pointcut</span> <span class=attr>id</span>=<span class=string>"test_xml2aop_pointcut"</span> <span class=attr>expression</span>=<span class=string>"execution(* cn.shh.demo.spring.aop.impl.xml2aop.Xml2AopServie.*())"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>aop:before</span> <span class=attr>pointcut-ref</span>=<span class=string>"test_xml2aop_pointcut"</span> <span class=attr>method</span>=<span class=string>"before"</span> /></span></span><br><span class=line>        <span class=tag><<span class=name>aop:after</span> <span class=attr>pointcut-ref</span>=<span class=string>"test_xml2aop_pointcut"</span> <span class=attr>method</span>=<span class=string>"after"</span> /></span></span><br><span class=line>        <span class=tag><<span class=name>aop:after-returning</span> <span class=attr>pointcut-ref</span>=<span class=string>"test_xml2aop_pointcut"</span> <span class=attr>method</span>=<span class=string>"afterReturning"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>aop:after-throwing</span> <span class=attr>pointcut-ref</span>=<span class=string>"test_xml2aop_pointcut"</span> <span class=attr>method</span>=<span class=string>"afterThrowing"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>aop:around</span> <span class=attr>pointcut-ref</span>=<span class=string>"test_xml2aop_pointcut"</span> <span class=attr>method</span>=<span class=string>"aroundAdvice"</span> /></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>aop:aspect</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>aop:config</span>></span></span><br></pre></table></figure><p>Java类文件内容与Advisor方式中的一样。<h2 id=1-3、注解实现><a class=headerlink href=#1-3、注解实现 title=1.3、注解实现></a>1.3、注解实现</h2><p><strong>（1）创建增强类AspectJ.java</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AspectJ</span> {</span><br><span class=line>	<span class=comment>//@Pointcut("execution(* doing(..))")</span></span><br><span class=line>	<span class=meta>@Pointcut("@annotation(cn.shh.demo.spring.aop.impl.aspectj2aop.AspectJAnnotation)")</span></span><br><span class=line>	<span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">pointcut</span><span class=params>()</span>{}</span><br><span class=line>	<span class=meta>@Before("pointcut()")</span></span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">before</span><span class=params>()</span>{</span><br><span class=line>		System.out.println(<span class=string>"--- aspectj before advice ---"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p><strong>（2）创建配置类AopConfig.java，开启AOP功能</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@EnableAspectJAutoProxy</span> <span class=comment>// 开启aop功能</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AopConfig</span> {</span><br><span class=line>}</span><br></pre></table></figure><h2 id=1-4、ProxyFactoryBean实现><a class=headerlink href=#1-4、ProxyFactoryBean实现 title=1.4、ProxyFactoryBean实现></a>1.4、ProxyFactoryBean实现</h2><p><strong>（1）创建增强通知类</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">PFBAdvice</span> <span class=keyword>implements</span> <span class="title class_">MethodInterceptor</span>, Advice {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> Object <span class="title function_">invoke</span><span class=params>(MethodInvocation invocation)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>		System.out.println(<span class=string>"--- ProxyFactoryBean before advice ---"</span>);</span><br><span class=line>		<span class=type>Object</span> <span class=variable>proceed</span> <span class=operator>=</span> invocation.proceed();</span><br><span class=line>		System.out.println(<span class=string>"--- ProxyFactoryBean after advice ---"</span>);</span><br><span class=line>		<span class=keyword>return</span> proceed;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p><strong>（2）使用main方法测试效果</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">App</span> {</span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>		<span class=type>ProxyFactoryBean</span> <span class=variable>factoryBean</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ProxyFactoryBean</span>();</span><br><span class=line>		factoryBean.setTarget(<span class=keyword>new</span> <span class="title class_">PFBServiceImpl</span>());</span><br><span class=line>		factoryBean.addAdvice(<span class=keyword>new</span> <span class="title class_">PFBAdvice</span>());</span><br><span class=line>		<span class=type>PFBServiceImpl</span> <span class=variable>pfbService</span> <span class=operator>=</span> (PFBServiceImpl) factoryBean.getObject();</span><br><span class=line>		pfbService.doing();</span><br><span class=line>		pfbService.doing2();</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h2 id=1-5、ProxyFactory实现><a class=headerlink href=#1-5、ProxyFactory实现 title=1.5、ProxyFactory实现></a>1.5、ProxyFactory实现</h2><p><strong>（1）创建增强通知类</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">PFAdvice</span> <span class=keyword>implements</span> <span class="title class_">MethodInterceptor</span> {</span><br><span class=line>	<span class=meta>@Override</span></span><br><span class=line>	<span class=keyword>public</span> Object <span class="title function_">invoke</span><span class=params>(MethodInvocation invocation)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>		System.out.println(<span class=string>"--- ProxyFactory before advice ---"</span>);</span><br><span class=line>		<span class=type>Object</span> <span class=variable>proceed</span> <span class=operator>=</span> invocation.proceed();</span><br><span class=line>		System.out.println(<span class=string>"--- ProxyFactory after advice ---"</span>);</span><br><span class=line>		<span class=keyword>return</span> proceed;</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><p><strong>（2）使用main方法测试效果</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">App</span> {</span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>		<span class=type>ProxyFactory</span> <span class=variable>factory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ProxyFactory</span>(<span class=keyword>new</span> <span class="title class_">PFServiceImpl</span>());</span><br><span class=line>		factory.addAdvice(<span class=keyword>new</span> <span class="title class_">PFAdvice</span>());</span><br><span class=line>		<span class=type>PFService</span> <span class=variable>proxy</span> <span class=operator>=</span> (PFService) factory.getProxy();</span><br><span class=line>		proxy.doing();</span><br><span class=line>		proxy.doing2();</span><br><span class=line>	}</span><br><span class=line>}</span><br></pre></table></figure><h1 id=原理解析><a class=headerlink href=#原理解析 title=原理解析></a>原理解析</h1><h2 id=1-1、动态代理><a class=headerlink href=#1-1、动态代理 title=1.1、动态代理></a>1.1、动态代理</h2><p><strong>Spring AOP通过JDK动态代理和CGLib动态代理实现增强</strong>。<h3 id=1-1-1、JDK动态代理><a class=headerlink href=#1-1-1、JDK动态代理 title=1.1.1、JDK动态代理></a>1.1.1、JDK动态代理</h3><p>JDK动态代理的前提如下：<ul><li>目标类实现了接口，默认使用该方式；</ul><p>JDK动态代理会<strong>基于接口创建实现类的代理对象，创建出来的代理对象与目标类同属于接口的实现类，与目标类是平级关系</strong>。<p>原理：<strong>获取抽象接口信息（利用Java反射技术），并生成一个实现了接口的动态代理类（字节码），再通过反射生成该代理类的实例对象，在调用具体方法时会被拦截，然后执行代理类的方法逻辑</strong>。<h3 id=1-1-2、CGLIB代理><a class=headerlink href=#1-1-2、CGLIB代理 title=1.1.2、CGLIB代理></a>1.1.2、CGLIB代理</h3><p>CGLib动态代理的前提如下：<ul><li>目标类没有实现接口，且没有被final修饰，则默认使用该方式；<li>若目标类实现了接口，那么可通过设置属性<code>proxy-target-class=true</code>来强制使用CGLib代理；</ul><p>原理：<strong>通过ASM加载被代理类的class文件，通过修改其字节码生成子类，并在子类中采用方法拦截技术，拦截所有父类方法调用，并顺势织入增强逻辑</strong>。<h2 id=1-2、功能实现原理><a class=headerlink href=#1-2、功能实现原理 title=1.2、功能实现原理></a>1.2、功能实现原理</h2><h3 id=1-2-1、入口-aop-config><a title="1.2.1、入口 aop:config" class=headerlink href=#1-2-1、入口-aop-config></a>1.2.1、入口 aop:config</h3><p><strong>（1）向容器中注入一个Bean增强器，通过Bean增强器对目标对象进行增强</strong><p>通过标签解析器 ConfigBeanDefinitionParser 向容器中注入<code>AspectJAwareAdvisorAutoProxyCreator</code>。AspectJAwareAdvisorAutoProxyCreator 就是一个BeanPostProcessor，会<strong>在Bean初始化阶段对相关Bean进行增强</strong>。<p><strong>（2）Bean增强器会使用祖先的方法进行增强</strong><p>AspectJAwareAdvisorAutoProxyCreator 会使用爷爷AbstractAutoProxyCreator的postProcessorAfterInitialization方法对bean增强。<p><strong>（3）根据目标对象的实际情况，会选择使用CGLib代理或JDK代理来创建代理进行增强</strong>。<h3 id=1-2-2、入口-EnableAspectJAutoProxy><a class=headerlink href=#1-2-2、入口-EnableAspectJAutoProxy title=1.2.2、入口@EnableAspectJAutoProxy></a>1.2.2、入口@EnableAspectJAutoProxy</h3><p>流程与入口aop:config的类似，详情如下：<p><strong>（1）向容器中注入一个Bean增强器，通过Bean增强器对目标对象进行增强</strong><p>通过标签解析器 AspectJAutoProxyBeanDefinitionParser 向容器中注入<code>AnnotationAwareAspectJAutoProxyCreator</code>。AnnotationAwareAspectJAutoProxyCreator 就是一个BeanPostProcessor，会<strong>在Bean初始化阶段对其进行增强</strong>。<p><strong>（2）该bean增强器是aop:config导入的增强器的子类</strong><p>AnnotationAwareAspectJAutoProxyCreator 就是 AspectJAwareAdvisorAutoProxyCreator 的子类。<p><strong>（3）Bean增强器会使用祖先的方法进行增强</strong><p>AnnotationAwareAspectJAutoProxyCreator 会使用 AbstractAutoProxyCreator 的postProcessorAfterInitialization方法对bean增强。<p><strong>（3）根据目标对象的实际情况，会选择使用CGLib代理或JDK代理来创建代理进行增强</strong>。</div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Shell%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87/ itemprop=url>Linux系列-Shell基础应用</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-09-25 11:37:27" datetime=2023-09-25T11:37:27+08:00 itemprop=dateModified>2023-09-25</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Linux/ itemprop=url rel=index><span itemprop=name>Linux</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、Shell变量><a class=headerlink href=#1、Shell变量 title=1、Shell变量></a>1、Shell变量</h1><h2 id=1-1、简介><a class=headerlink href=#1-1、简介 title=1.1、简介></a>1.1、简介</h2><p>Linux中Shell变量分为两种：<strong>系统变量 和 自定义变量。</strong><ul><li><p>系统变量。例如：$HOME / $PWD / $SHELL / $USER等。</p><li><p>自定义变量</p></ul><p>运行shell时，会同时存在三种变量：<ul><li><strong>局部变量：</strong>局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。<li><strong>环境变量：</strong>所有程序都能访问环境变量，有些程序依赖环境变量来保证运行。必要时shell脚本也可以定义环境变量。<li><strong>shell变量：</strong>shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行。</ul><h2 id=1-2、变量管理><a class=headerlink href=#1-2、变量管理 title=1.2、变量管理></a>1.2、变量管理</h2><h3 id=1-2-1、定义变量><a class=headerlink href=#1-2-1、定义变量 title=1.2.1、定义变量></a>1.2.1、定义变量</h3><h4 id=1-2-1-1、使用语法><a class=headerlink href=#1-2-1-1、使用语法 title=1.2.1.1、使用语法></a>1.2.1.1、使用语法</h4><p>定义语法如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>your_name=<span class=string>"runoob.com"</span></span><br></pre></table></figure><p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：<ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。<li>中间不能有空格，可使用下划线 **_**。<li>不能使用标点符号。<li>不能使用bash里的关键字（可用help命令查看保留关键字）。</ul><h4 id=1-2-1-2、只读变量><a class=headerlink href=#1-2-1-2、只读变量 title=1.2.1.2、只读变量></a>1.2.1.2、只读变量</h4><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。<p>下面的例子尝试更改只读变量，结果报错：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>#!/bin/bash</span></span><br><span class=line>myUrl=<span class=string>"https://www.google.com"</span></span><br><span class=line><span class=built_in>readonly</span> myUrl</span><br><span class=line>myUrl=<span class=string>"https://www.runoob.com"</span></span><br></pre></table></figure><h3 id=1-2-2、使用变量><a class=headerlink href=#1-2-2、使用变量 title=1.2.2、使用变量></a>1.2.2、使用变量</h3><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>your_name=<span class=string>"qinjx"</span></span><br><span class=line><span class=built_in>echo</span> <span class=variable>$your_name</span></span><br><span class=line><span class=built_in>echo</span> <span class=variable>${your_name}</span></span><br></pre></table></figure><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：<h3 id=1-2-3、删除变量><a class=headerlink href=#1-2-3、删除变量 title=1.2.3、删除变量></a>1.2.3、删除变量</h3><p>使用 unset 命令可以删除变量。语法：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>unset</span> variable_name</span><br></pre></table></figure><p>变量被删除后不能再次使用。unset 命令不能删除只读变量。<p><strong>实例</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>#!/bin/sh</span></span><br><span class=line>myUrl=<span class=string>"https://www.runoob.com"</span></span><br><span class=line><span class=built_in>unset</span> myUrl</span><br><span class=line><span class=built_in>echo</span> <span class=variable>$myUrl</span></span><br></pre></table></figure><h2 id=1-3、变量数据类型><a class=headerlink href=#1-3、变量数据类型 title=1.3、变量数据类型></a>1.3、变量数据类型</h2><h3 id=1-3-1、字符串><a class=headerlink href=#1-3-1、字符串 title=1.3.1、字符串></a>1.3.1、字符串</h3><h4 id=1-3-1-1、简介><a class=headerlink href=#1-3-1-1、简介 title=1.3.1.1、简介></a>1.3.1.1、简介</h4><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），<strong>字符串可以用单引号，也可以用双引号，也可以不用引号。</strong><p><strong>（1）单引号</strong><p>单引号字符串限制：<ul><li>单引号里的任何字符都会原样输出，<strong>单引号字符串中的变量是无效的</strong>；<li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</ul><p><strong>（2）双引号</strong><p>双引号优点：<ul><li>双引号里可以有<strong>变量</strong>。<li>双引号里可以出现<strong>转义字符</strong>。</ul><h4 id=1-3-1-2、拼接字符串><a class=headerlink href=#1-3-1-2、拼接字符串 title=1.3.1.2、拼接字符串></a>1.3.1.2、拼接字符串</h4><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>your_name="runoob"</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>方式1：使用 双引号 拼接</span></span><br><span class=line>greeting="hello, "$your_name" !"</span><br><span class=line>greeting_1="hello, ${your_name} !"</span><br><span class=line>echo $greeting  $greeting_1</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>方式2：使用 单引号 拼接</span></span><br><span class=line>greeting_2='hello, '$your_name' !'</span><br><span class=line>greeting_3='hello, ${your_name} !'</span><br><span class=line>echo $greeting_2  $greeting_3</span><br></pre></table></figure><h4 id=1-3-1-3、获取字符串长度><a class=headerlink href=#1-3-1-3、获取字符串长度 title=1.3.1.3、获取字符串长度></a>1.3.1.3、获取字符串长度</h4><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>string="abcd"</span><br><span class=line>echo ${#string} 	# 输出 4</span><br></pre></table></figure><h4 id=1-3-1-4、提取子字符串><a class=headerlink href=#1-3-1-4、提取子字符串 title=1.3.1.4、提取子字符串></a>1.3.1.4、提取子字符串</h4><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_"># </span><span class=language-bash>以下实例从字符串第 2 个字符开始截取 4 个字符：</span></span><br><span class=line>string="runoob is a great site"</span><br><span class=line>echo ${string:1:4} 	# 输出 unoo</span><br></pre></table></figure><p><strong>注意</strong>：第一个字符的索引值为 <strong>0</strong>。<h4 id=1-3-1-5、查找字符串><a class=headerlink href=#1-3-1-5、查找字符串 title=1.3.1.5、查找字符串></a>1.3.1.5、查找字符串</h4><p>查找字符 <strong>i</strong> 或 <strong>o</strong> 的位置(哪个字母先出现就计算哪个)：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>string="runoob is a great site"</span><br><span class=line>echo `expr index "$string" io`  # 输出 4</span><br></pre></table></figure><p><font color=red>注意：以上脚本中 <strong>`</strong> 是反引号，而不是单引号 **’**，不要看错了哦。</font><h3 id=1-3-2、数组><a class=headerlink href=#1-3-2、数组 title=1.3.2、数组></a>1.3.2、数组</h3><h4 id=1-3-2-1、简介><a class=headerlink href=#1-3-2-1、简介 title=1.3.2.1、简介></a>1.3.2.1、简介</h4><p><strong>bash支持一维数组（不支持多维数组），且没有限定数组大小。</strong><p>获取数组元素要通过下标，下标可以是整数或算术表达式，其值应大于或等于 0。<h4 id=1-3-2-2、定义数组><a class=headerlink href=#1-3-2-2、定义数组 title=1.3.2.2、定义数组></a>1.3.2.2、定义数组</h4><p>在 Shell 中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>数组名=(值1 值2 ... 值n)</span><br></pre></table></figure><p>比如：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>array_name=(value0 value1 value2 value3)</span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>or</span></span><br><span class=line>array_name=(</span><br><span class=line>value0</span><br><span class=line>value1</span><br><span class=line>value2</span><br><span class=line>value3</span><br><span class=line>)</span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>还可以单独定义数组的各个分量：</span></span><br><span class=line>array_name[0]=value0</span><br><span class=line>array_name[1]=value1</span><br><span class=line>array_name[n]=valuen</span><br></pre></table></figure><blockquote><p>注意：可以不使用连续的下标，而且下标的范围没有限制。</blockquote><h4 id=1-3-2-3、读取数组><a class=headerlink href=#1-3-2-3、读取数组 title=1.3.2.3、读取数组></a>1.3.2.3、读取数组</h4><p>读取数组元素值的一般格式是：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>${数组名[下标]}</span><br></pre></table></figure><p>例如：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>valuen=${array_name[n]}</span><br></pre></table></figure><p>使用<code>@</code>符号可以获取数组中的所有元素，例如：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>echo ${array_name[@]}</span><br></pre></table></figure><h4 id=1-3-2-4、获取数组长度><a class=headerlink href=#1-3-2-4、获取数组长度 title=1.3.2.4、获取数组长度></a>1.3.2.4、获取数组长度</h4><p>获取数组长度的方法与获取字符串长度的方法相同，例如：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment># 取得数组元素的个数</span></span><br><span class=line>length=<span class=variable>${#array_name[@]}</span></span><br><span class=line><span class=comment># 或者</span></span><br><span class=line>length=<span class=variable>${#array_name[*]}</span></span><br><span class=line><span class=comment># 取得数组单个元素的长度</span></span><br><span class=line>lengthn=<span class=variable>${#array_name[n]}</span></span><br></pre></table></figure><h3 id=1-3-3、注释><a class=headerlink href=#1-3-3、注释 title=1.3.3、注释></a>1.3.3、注释</h3><h4 id=1-3-3-1、简介><a class=headerlink href=#1-3-3-1、简介 title=1.3.3.1、简介></a>1.3.3.1、简介</h4><p><strong>以<code>#</code>开头的行就是注释，会被解释器忽略。</strong><p>通过每一行加一个<code>#</code>号设置多行注释，像这样：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=comment>#--------------------------------------------</span></span><br><span class=line><span class=comment># 这是一个注释</span></span><br><span class=line><span class=comment># author：菜鸟教程</span></span><br><span class=line><span class=comment># site：www.runoob.com</span></span><br><span class=line><span class=comment># slogan：学的不仅是技术，更是梦想！</span></span><br><span class=line><span class=comment>#--------------------------------------------</span></span><br><span class=line><span class=comment>##### 用户配置区 开始 #####</span></span><br><span class=line><span class=comment>#</span></span><br><span class=line><span class=comment>#</span></span><br><span class=line><span class=comment># 这里可以添加脚本描述信息</span></span><br><span class=line><span class=comment># </span></span><br><span class=line><span class=comment>#</span></span><br><span class=line><span class=comment>##### 用户配置区 结束  #####</span></span><br></pre></table></figure><blockquote><p>开发过程中遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？<p>每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</blockquote><h4 id=1-3-3-2、多行注释><a class=headerlink href=#1-3-3-2、多行注释 title=1.3.3.2、多行注释></a>1.3.3.2、多行注释</h4><p>多行注释还可以使用以下格式：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>:<&LTEOF</span><br><span class=line>注释内容...</span><br><span class=line>注释内容...</span><br><span class=line>注释内容...</span><br><span class=line>EOF</span><br></pre></table></figure><p>EOF 也可以使用其他符号:<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>:<<'</span><br><span class=line>注释内容...</span><br><span class=line>注释内容...</span><br><span class=line>注释内容...</span><br><span class=line>'</span><br><span class=line></span><br><span class=line>:<&LT!</span><br><span class=line>注释内容...</span><br><span class=line>注释内容...</span><br><span class=line>注释内容...</span><br><span class=line>!</span><br></pre></table></figure><h1 id=2、Shell参数><a class=headerlink href=#2、Shell参数 title=2、Shell参数></a>2、Shell参数</h1><h2 id=2-1、简介><a class=headerlink href=#2-1、简介 title=2.1、简介></a>2.1、简介</h2><p><strong>向脚本传递参数，脚本内获取参数的格式为<code>$n</code>。<code>n</code>代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推。</strong><h2 id=2-2-、特殊字符><a class=headerlink href=#2-2-、特殊字符 title=2.2.、特殊字符></a>2.2.、特殊字符</h2><p>有几个特殊字符用来处理参数：<table><thead><tr><th align=left>参数处理<th align=left>说明<tbody><tr><td align=left>$#<td align=left>传递到脚本的参数个数<tr><td align=left>$*<td align=left>以一个单字符串显示所有向脚本传递的参数。 如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。<tr><td align=left>$$<td align=left>脚本运行的当前进程ID号<tr><td align=left>$!<td align=left>后台运行的最后一个进程的ID号<tr><td align=left>$@<td align=left>与$*相同，但是使用时加引号，并在引号中返回每个参数。 如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。<tr><td align=left>$-<td align=left>显示Shell使用的当前选项，与<a href=https://www.runoob.com/linux/linux-comm-set.html rel=noopener target=_blank>set命令</a>功能相同。<tr><td align=left>$?<td align=left>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</table><p>$* 与 $@ 区别：<ul><li>相同点：都是引用所有参数。<li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</ul><h2 id=2-3、示例><a class=headerlink href=#2-3、示例 title=2.3、示例></a>2.3、示例</h2><p>以下实例我们向脚本传递三个参数，并分别输出，其中 $0 为执行的文件名（包含文件路径）：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">#</span><span class=language-bash>!/bin/bash</span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>author:菜鸟教程</span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>url:www.runoob.com</span></span><br><span class=line></span><br><span class=line>echo "Shell 传递参数实例！";</span><br><span class=line>echo "执行的文件名：$0";</span><br><span class=line>echo "第一个参数为：$1";</span><br><span class=line>echo "第二个参数为：$2";</span><br><span class=line>echo "第三个参数为：$3";</span><br></pre></table></figure><p>为脚本设置可执行权限，并执行脚本，输出结果如下所示：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>chmod</span> +x test.sh</span> </span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash>./test.sh 1 2 3</span></span><br><span class=line>Shell 传递参数实例！</span><br><span class=line>执行的文件名：./test.sh</span><br><span class=line>第一个参数为：1</span><br><span class=line>第二个参数为：2</span><br><span class=line>第三个参数为：3</span><br></pre></table></figure><h1 id=3、Shell运算符><a class=headerlink href=#3、Shell运算符 title=3、Shell运算符></a>3、Shell运算符</h1><h2 id=3-1、简介><a class=headerlink href=#3-1、简介 title=3.1、简介></a>3.1、简介</h2><p>Shell 和其他编程语言一样，支持多种运算符，包括：<ul><li>算数运算符<li>关系运算符<li>布尔运算符<li>字符串运算符<li>文件测试运算符</ul><p><strong>原生bash不支持简单数学运算，但可以通过其他命令来实现，例如 awk 和 expr</strong>，expr 最常用。expr 是一款表达式计算工具，使用它能完成表达式的求值操作。<p>例如，两个数相加：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_"># </span><span class=language-bash>使用的是反引号，并非是 单引号。</span></span><br><span class=line><span class="meta prompt_">#</span><span class=language-bash>!/bin/bash*</span></span><br><span class=line></span><br><span class=line>val=`expr 2 + 2`</span><br><span class=line>echo "两数之和为 : $val"</span><br></pre></table></figure><p>注意：<ul><li><strong>表达式和运算符之间要有空格</strong>。例如<code>2+2</code>是不对的，必须写成<code>2 + 2</code>，这与我们熟悉的大多数编程语言不一样。<li><strong>完整的表达式要被反引号``` `包含</strong>。</ul><h2 id=3-2、算术运算符><a class=headerlink href=#3-2、算术运算符 title=3.2、算术运算符></a>3.2、算术运算符</h2><p>下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：<table><thead><tr><th align=left>运算符<th align=left>说明<th align=left>举例<tbody><tr><td align=left>+<td align=left>加法<td align=left><code>expr $a + $b</code> 结果为 30。<tr><td align=left>-<td align=left>减法<td align=left><code>expr $a - $b</code> 结果为 -10。<tr><td align=left>*<td align=left>乘法<td align=left><code>expr $a \* $b</code> 结果为 200。<tr><td align=left>/<td align=left>除法<td align=left><code>expr $b / $a</code> 结果为 2。<tr><td align=left>%<td align=left>取余<td align=left><code>expr $b % $a</code> 结果为 0。<tr><td align=left>=<td align=left>赋值<td align=left>a=$b 将把变量 b 的值赋给 a。<tr><td align=left>==<td align=left>相等。用于比较两个数字，相同则返回 true。<td align=left>[ $a == $b ] 返回 false。<tr><td align=left>!=<td align=left>不相等。用于比较两个数字，不相同则返回 true。<td align=left>[ $a != $b ] 返回 true。</table><p><font color=red>注意：条件表达式要放在方括号之间，并且要有空格，例如 [$a==$b] 是错误的，必须写成 [ $a == $b ]。</font><h2 id=3-3、关系运算符><a class=headerlink href=#3-3、关系运算符 title=3.3、关系运算符></a>3.3、关系运算符</h2><p><strong>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</strong><p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：<table><thead><tr><th align=left>运算符<th align=left>说明<th align=left>举例<tbody><tr><td align=left>-eq<td align=left>检测两个数是否相等，相等返回 true。<td align=left>[ $a -eq $b ] 返回 false。<tr><td align=left>-ne<td align=left>检测两个数是否不相等，不相等返回 true。<td align=left>[ $a -ne $b ] 返回 true。<tr><td align=left>-gt<td align=left>检测左边的数是否大于右边的，如果是，则返回 true。<td align=left>[ $a -gt $b ] 返回 false。<tr><td align=left>-lt<td align=left>检测左边的数是否小于右边的，如果是，则返回 true。<td align=left>[ $a -lt $b ] 返回 true。<tr><td align=left>-ge<td align=left>检测左边的数是否大于等于右边的，如果是，则返回 true。<td align=left>[ $a -ge $b ] 返回 false。<tr><td align=left>-le<td align=left>检测左边的数是否小于等于右边的，如果是，则返回 true。<td align=left>[ $a -le $b ] 返回 true。</table><h2 id=3-4、布尔运算符><a class=headerlink href=#3-4、布尔运算符 title=3.4、布尔运算符></a>3.4、布尔运算符</h2><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：<table><thead><tr><th align=left>运算符<th align=left>说明<th align=left>举例<tbody><tr><td align=left>!<td align=left>非运算，表达式为 true 则返回 false，否则返回 true。<td align=left>[ ! false ] 返回 true。<tr><td align=left>-o<td align=left>或运算，有一个表达式为 true 则返回 true。<td align=left>[ $a -lt 20 -o $b -gt 100 ] 返回 true。<tr><td align=left>-a<td align=left>与运算，两个表达式都为 true 才返回 true。<td align=left>[ $a -lt 20 -a $b -gt 100 ] 返回 false。</table><h2 id=3-5、逻辑运算符><a class=headerlink href=#3-5、逻辑运算符 title=3.5、逻辑运算符></a>3.5、逻辑运算符</h2><p>以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20：<table><thead><tr><th align=left>运算符<th align=left>说明<th align=left>举例<tbody><tr><td align=left>&&<td align=left>逻辑的 AND<td align=left>[[ $a -lt 100 && $b -gt 100 ]] 返回 false<tr><td align=left>||<td align=left>逻辑的 OR<td align=left>[[ $a -lt 100 || $b -gt 100 ]] 返回 true</table><h2 id=3-6、字符串运算符><a class=headerlink href=#3-6、字符串运算符 title=3.6、字符串运算符></a>3.6、字符串运算符</h2><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：<table><thead><tr><th align=left>运算符<th align=left>说明<th align=left>举例<tbody><tr><td align=left>=<td align=left>检测两个字符串是否相等，相等返回 true。<td align=left>[ $a = $b ] 返回 false。<tr><td align=left>!=<td align=left>检测两个字符串是否不相等，不相等返回 true。<td align=left>[ $a != $b ] 返回 true。<tr><td align=left>-z<td align=left>检测字符串长度是否为0，为0返回 true。<td align=left>[ -z $a ] 返回 false。<tr><td align=left>-n<td align=left>检测字符串长度是否不为 0，不为 0 返回 true。<td align=left>[ -n “$a” ] 返回 true。<tr><td align=left>$<td align=left>检测字符串是否为空，不为空返回 true。<td align=left>[ $a ] 返回 true。</table><h2 id=3-7、文件测试运算符><a class=headerlink href=#3-7、文件测试运算符 title=3.7、文件测试运算符></a>3.7、文件测试运算符</h2><p>文件测试运算符用于检测 Unix 文件各种属性。<p>属性检测描述如下：<table><thead><tr><th align=left>操作符<th align=left>说明<th align=left>举例<tbody><tr><td align=left>-b file<td align=left>检测文件是否是块设备文件，如果是，则返回 true。<td align=left>[ -b $file ] 返回 false。<tr><td align=left>-c file<td align=left>检测文件是否是字符设备文件，如果是，则返回 true。<td align=left>[ -c $file ] 返回 false。<tr><td align=left>-d file<td align=left>检测文件是否是目录，如果是，则返回 true。<td align=left>[ -d $file ] 返回 false。<tr><td align=left>-f file<td align=left>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。<td align=left>[ -f $file ] 返回 true。<tr><td align=left>-g file<td align=left>检测文件是否设置了 SGID 位，如果是，则返回 true。<td align=left>[ -g $file ] 返回 false。<tr><td align=left>-k file<td align=left>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。<td align=left>[ -k $file ] 返回 false。<tr><td align=left>-p file<td align=left>检测文件是否是有名管道，如果是，则返回 true。<td align=left>[ -p $file ] 返回 false。<tr><td align=left>-u file<td align=left>检测文件是否设置了 SUID 位，如果是，则返回 true。<td align=left>[ -u $file ] 返回 false。<tr><td align=left>-r file<td align=left>检测文件是否可读，如果是，则返回 true。<td align=left>[ -r $file ] 返回 true。<tr><td align=left>-w file<td align=left>检测文件是否可写，如果是，则返回 true。<td align=left>[ -w $file ] 返回 true。<tr><td align=left>-x file<td align=left>检测文件是否可执行，如果是，则返回 true。<td align=left>[ -x $file ] 返回 true。<tr><td align=left>-s file<td align=left>检测文件是否为空（文件大小是否大于0），不为空返回 true。<td align=left>[ -s $file ] 返回 true。<tr><td align=left>-e file<td align=left>检测文件（包括目录）是否存在，如果是，则返回 true。<td align=left>[ -e $file ] 返回 true。</table><p>其他检查符：<ul><li>-S：判断某文件是否 socket。<li>-L：检测文件是否存在并且是一个符号链接。</ul><h1 id=4、输出指令><a class=headerlink href=#4、输出指令 title=4、输出指令></a>4、输出指令</h1><h2 id=4-1、echo命令><a class=headerlink href=#4-1、echo命令 title=4.1、echo命令></a>4.1、echo命令</h2><h3 id=4-2-1、简介><a class=headerlink href=#4-2-1、简介 title=4.2.1、简介></a>4.2.1、简介</h3><p>简介：<strong>Shell的echo指令类似于PHP的echo，都是用于字符串输出。</strong><h3 id=4-2-2、实例><a class=headerlink href=#4-2-2、实例 title=4.2.2、实例></a>4.2.2、实例</h3><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_"># </span><span class=language-bash>1.显示普通字符串:</span></span><br><span class=line>echo "It is a test"</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>2.显示转义字符</span></span><br><span class=line>echo "\"It is a test\""</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>3.显示变量</span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash><span class=built_in>read</span> 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</span></span><br><span class=line><span class="meta prompt_">#</span><span class=language-bash>!/bin/sh</span></span><br><span class=line>read name </span><br><span class=line>echo "$name It is a test"</span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:</span></span><br><span class=line>[root@www ~]# sh test.sh</span><br><span class=line>OK                     #标准输入</span><br><span class=line>OK It is a test        #输出</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>4.显示换行</span></span><br><span class=line>echo -e "OK! \n" # -e 开启转义</span><br><span class=line>echo "It is a test"</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>5.显示不换行</span></span><br><span class=line><span class="meta prompt_">#</span><span class=language-bash>!/bin/sh</span></span><br><span class=line>echo -e "OK! \c" # -e 开启转义 \c 不换行</span><br><span class=line>echo "It is a test"</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>6.显示结果定向至文件</span></span><br><span class=line>echo "It is a test" > myfile</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>7.原样输出字符串，不进行转义或取变量(用单引号)</span></span><br><span class=line>echo '$name\"'</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>8.显示命令执行结果</span></span><br><span class=line>echo `date`</span><br></pre></table></figure><h2 id=4-2、printf命令><a class=headerlink href=#4-2、printf命令 title=4.2、printf命令></a>4.2、printf命令</h2><h3 id=4-2-1、简介-1><a class=headerlink href=#4-2-1、简介-1 title=4.2.1、简介></a>4.2.1、简介</h3><p><strong>printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。</strong><p>printf 使用 引用文本 或 空格 分隔参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认的<code>printf</code>不会像<code>echo</code>自动添加换行符，我们可以手动添加<code>\n</code>。<h3 id=4-2-2、语法><a class=headerlink href=#4-2-2、语法 title=4.2.2、语法></a>4.2.2、语法</h3><p>printf 命令语法：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>printf</span>  format-string  [arguments...]</span><br></pre></table></figure><p>参数说明：<ul><li><strong>format-string</strong>：格式控制字符串。<li><strong>arguments</strong>：参数列表。</ul><h2 id=4-3、printf转义序列><a class=headerlink href=#4-3、printf转义序列 title=4.3、printf转义序列></a>4.3、printf转义序列</h2><table><thead><tr><th align=left>序列<th align=left>说明<tbody><tr><td align=left>\a<td align=left>警告字符，通常为ASCII的BEL字符<tr><td align=left>\b<td align=left>后退<tr><td align=left>\c<td align=left>抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略<tr><td align=left>\f<td align=left>换页（formfeed）<tr><td align=left>\n<td align=left>换行<tr><td align=left>\r<td align=left>回车（Carriage return）<tr><td align=left>\t<td align=left>水平制表符<tr><td align=left>\v<td align=left>垂直制表符<tr><td align=left>\<td align=left>一个字面上的反斜杠字符<tr><td align=left>\ddd<td align=left>表示1到3位数八进制值的字符。仅在格式字符串中有效<tr><td align=left>\0ddd<td align=left>表示1到3位的八进制值字符</table><p>实例：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>printf</span> <span class=string>"a string, no processing:<%s>\n"</span> <span class=string>"A\nB"</span></span></span><br><span class=line>a string, no processing:&LTA\nB></span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>printf</span> <span class=string>"a string, no processing:<%b>\n"</span> <span class=string>"A\nB"</span></span></span><br><span class=line>a string, no processing:&LTA</span><br><span class=line><span class="meta prompt_">B></span><span class=language-bash></span></span><br><span class=line><span class=language-bash></span><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_">$ </span><span class=language-bash><span class=built_in>printf</span> <span class=string>"www.runoob.com \a"</span></span></span><br><span class=line>www.runoob.com $                  #不换行</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Sentinel%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Sentinel%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/ itemprop=url>Sentinel系列-Sentinel基础使用</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 16:10:55" datetime=2023-10-02T16:10:55+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Sentinel/ itemprop=url rel=index><span itemprop=name>Sentinel</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、加入依赖><a class=headerlink href=#1、加入依赖 title=1、加入依赖></a>1、加入依赖</h1><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>com.alibaba.cloud<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>spring-cloud-starter-alibaba-sentinel<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><h1 id=2、编写配置><a class=headerlink href=#2、编写配置 title=2、编写配置></a>2、编写配置</h1><figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>cloud:</span></span><br><span class=line>    <span class=attr>sentinel:</span></span><br><span class=line>      <span class=attr>transport:</span></span><br><span class=line>        <span class=attr>dashboard:</span> <span class=number>127.0</span><span class=number>.0</span><span class=number>.1</span><span class=string>:8080</span></span><br></pre></table></figure><h1 id=3、配置规则><a class=headerlink href=#3、配置规则 title=3、配置规则></a>3、配置规则</h1><p>在控制台配置所需的规则即可。<h1 id=4、自定义异常><a class=headerlink href=#4、自定义异常 title=4、自定义异常></a>4、自定义异常</h1><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SentinelBlockHandler</span> <span class=keyword>implements</span> <span class="title class_">BlockExceptionHandler</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">handle</span><span class=params>(HttpServletRequest request, HttpServletResponse response, BlockException e)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>String</span> <span class=variable>msg</span> <span class=operator>=</span> <span class=string>"未知异常！"</span>;</span><br><span class=line>        <span class=type>int</span> <span class=variable>status</span> <span class=operator>=</span> <span class=number>429</span>;</span><br><span class=line>        <span class=keyword>if</span> (e <span class=keyword>instanceof</span> FlowException){</span><br><span class=line>            msg = <span class=string>"请求被限流了！"</span>;</span><br><span class=line>        }<span class=keyword>else</span> <span class=keyword>if</span> (e <span class=keyword>instanceof</span> DegradeException){</span><br><span class=line>            msg = <span class=string>"请求被降级了！"</span>;</span><br><span class=line>        }<span class=keyword>else</span> <span class=keyword>if</span> (e <span class=keyword>instanceof</span> ParamFlowException){</span><br><span class=line>            msg = <span class=string>"热点参数限流！"</span>;</span><br><span class=line>        }<span class=keyword>else</span> <span class=keyword>if</span> (e <span class=keyword>instanceof</span> AuthorityException){</span><br><span class=line>            msg = <span class=string>"请求没有权限！"</span>;</span><br><span class=line>            status = <span class=number>401</span>;</span><br><span class=line>        }</span><br><span class=line>        response.setContentType(<span class=string>"application/json; charset=UTF-8"</span>);</span><br><span class=line>        response.setStatus(status);</span><br><span class=line>        response.getWriter().println(<span class=string>"{\"msg\":\""</span> + msg + <span class=string>"\",\"status\":\""</span> + status + <span class=string>"\"}"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <nav class=pagination><a class="extend prev" aria-label=上一页 href=/page/3/ rel=prev title=上一页><i class="fa fa-angle-left"></i></a><a class=page-number href=/>1</a><span class=space>…</span><a class=page-number href=/page/3/>3</a><span class="page-number current">4</span><a class=page-number href=/page/5/>5</a><span class=space>…</span><a class=page-number href=/page/12/>12</a><a class="extend next" aria-label=下一页 href=/page/5/ rel=next title=下一页><i class="fa fa-angle-right"></i></a></nav> <footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer> <div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div> <div class=sidebar-dimmer></div> <div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div> <noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript> <script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script> <script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script> <script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script> <script src=/js/third-party/search/local-search.js></script> 