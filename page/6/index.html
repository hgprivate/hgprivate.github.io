<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hgprivate.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content=豪哥博客 name=description><meta content=website property=og:type><meta content=豪哥博客 property=og:title><meta content=https://hgprivate.github.io/page/6/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content=豪哥博客 property=og:description><meta content=zh_CN property=og:locale><meta content=豪哥 property=article:author><meta content=HG property=article:tag><meta content=summary name=twitter:card><link href=https://hgprivate.github.io/page/6/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/6/index.html","title":""}</script><script class=next-config data-name=calendar type=application/json>""</script><title>豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <h1 class=site-title>豪哥博客</h1> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>116</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>36</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>129</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hgprivate.github.io/2024/08/21/Redis%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Redis%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/ itemprop=url>Redis系列-Redis缓存问题</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-07 09:23:32" datetime=2023-08-07T09:23:32+08:00 itemprop=dateModified>2023-08-07</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Redis/ itemprop=url rel=index><span itemprop=name>Redis</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=问题总结><a class=headerlink href=#问题总结 title=问题总结></a>问题总结</h1><h2 id=1-1、缓存穿透><a class=headerlink href=#1-1、缓存穿透 title=1.1、缓存穿透></a>1.1、缓存穿透</h2><h3 id=1-1-1、定义><a class=headerlink href=#1-1-1、定义 title=1.1.1、定义></a>1.1.1、定义</h3><p><strong>请求的 key 数据在缓存中不存在，那么会将请求发至后端 DB，后端 DB 因受到巨大压力可能导致宕机</strong>。<h3 id=1-1-2、解决方案><a class=headerlink href=#1-1-2、解决方案 title=1.1.2、解决方案></a>1.1.2、解决方案</h3><ol><li><p><strong>采用布隆过滤器</strong></p> <p>布隆过滤器的思想是：将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截，从而避免了对后端DB造成的压力。</p><li><p><strong>返回空，并设置超时时间</strong></p> <p>如果请求的结果不存在，则返回一个空结果，并将该空结果缓存起来且设置一个有限期。</p></ol><h2 id=1-2、缓存击穿><a class=headerlink href=#1-2、缓存击穿 title=1.2、缓存击穿></a>1.2、缓存击穿</h2><h3 id=1-2-1、定义><a class=headerlink href=#1-2-1、定义 title=1.2.1、定义></a>1.2.1、定义</h3><p><strong>请求的 key 数据在数据库和 Redis 中都存在，但 redis 中的过期了，此时若有大量并发请求打进来，将会直接跳过缓存到达后端 DB，加载完数据并回设到缓存，期间因DB承受巨大请求压力可能导致宕机</strong>，这个场景我们称为【缓存击穿】。<h3 id=1-2-2、解决方案><a class=headerlink href=#1-2-2、解决方案 title=1.2.2、解决方案></a>1.2.2、解决方案</h3><p><strong>常用解决方案是使用互斥锁</strong>。<p>缓存失效时不立即加载后端DB，而是让 Redis去set一个mutex key并返回set结果状态，然后再去加载后端DB并刷新缓存；否则，就重试获取缓存。<blockquote><p>SETNX，是「SET if Not EXists」的缩写，意为：只有key不存在才设置，可以利用它来实现锁的效果。</blockquote><h2 id=1-3、缓存雪崩><a class=headerlink href=#1-3、缓存雪崩 title=1.3、缓存雪崩></a>1.3、缓存雪崩</h2><h3 id=1-3-1、定义><a class=headerlink href=#1-3-1、定义 title=1.3.1、定义></a>1.3.1、定义</h3><p><strong>当缓存服务器重启或大量缓存数据全部集中在某一个时间段失效，此时若有大量并发请求打进来，将会直接跳过缓存到达后端 DB</strong>，这个场景称为【缓存雪崩】。<h3 id=1-3-2、解决方案><a class=headerlink href=#1-3-2、解决方案 title=1.3.2、解决方案></a>1.3.2、解决方案</h3><ol><li><strong>使用锁或者队列</strong>。<li><strong>设置过期标志，更新缓存</strong>。<li><strong>为 Key 设置不同的失效时间</strong>。</ol><h1 id=Redis和memcache区别><a class=headerlink href=#Redis和memcache区别 title=Redis和memcache区别></a>Redis和memcache区别</h1><p><strong>（1）存储方式</strong><p>Memcache的数据存在于内存中，断电后会丢失，且数据容量不能超过内存大小。<p>Redis支持数据持久化，内存中的数据可持久化至磁盘，重启后可再利用。（RDB快照和AOF日志）。<p><strong>（2）备份</strong><p>Redis支持数据备份，及master-slave模式数据备份。<p><strong>（3）数据支持类型</strong><p>Redis支持的数据类型要比Memcache多。<p><strong>（4）底层模型不同</strong><p>新版本Redis构建了自己的VM机制，因为一般的系统调用系统函数会浪费一定的时间去移动和请求。</div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hgprivate.github.io/2024/08/21/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB%E5%92%8CAOF/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB%E5%92%8CAOF/ itemprop=url>Redis系列-Redis持久化</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 21:37:49" datetime=2023-10-02T21:37:49+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Redis/ itemprop=url rel=index><span itemprop=name>Redis</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、RDB持久化><a class=headerlink href=#1、RDB持久化 title=1、RDB持久化></a>1、RDB持久化</h1><h2 id=1-1、RDB简介><a class=headerlink href=#1-1、RDB简介 title=1.1、RDB简介></a>1.1、RDB简介</h2><p><strong>RDB 是默认持久化方案</strong>。<p>RDB持久化工作内容：<strong>指定时间间隔内，执行指定次数的写操作就会触发持久化</strong>，在指定目录下生成一个dump.rdb文件。Redis 重启时通过加载<code>dump.rdb</code>文件恢复数据。<h2 id=1-2、持久化开启与关闭><a class=headerlink href=#1-2、持久化开启与关闭 title=1.2、持久化开启与关闭></a>1.2、持久化开启与关闭</h2><h3 id=1-2-1、开启持久化><a class=headerlink href=#1-2-1、开启持久化 title=1.2.1、开启持久化></a>1.2.1、开启持久化</h3><h4 id=开启功能><a class=headerlink href=#开启功能 title=开启功能></a>开启功能</h4><p>若要开启持久化功能，只需注释掉<code>sava ""</code>，然后显式设置save逻辑即可。<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment># 配置格式：save <指定时间间隔> <执行指定次数更新操作></span></span><br><span class=line><span class=comment># save ""</span></span><br><span class=line><span class=attr>save</span> <span class=string>900 1</span></span><br><span class=line><span class=attr>save</span> <span class=string>300 10</span></span><br><span class=line><span class=attr>save</span> <span class=string>60 10000</span></span><br></pre></table></figure><p>分析：<strong>满足配置条件就会持久化内存数据到硬盘</strong>。官方默认规则：900秒内有1个更改，300秒内有10个更改、60秒内有1万个更改时将持久化内存数据到磁盘。<h4 id=配置持久化目录与文件><a class=headerlink href=#配置持久化目录与文件 title=配置持久化目录与文件></a>配置持久化目录与文件</h4><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment># 持久化目录</span></span><br><span class=line><span class=attr>dir</span> <span class=string>./</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment># 持久化文件，默认为dump.rdb</span></span><br><span class=line><span class=attr>dbfilename</span> <span class=string>dump.rdb</span></span><br></pre></table></figure><p>若需开启数据压缩功能，那么加入配置：<code>rdbcompression yes</code>。<p><font color=red>注意：配置 存储至本地数据库时是否压缩数据，默认为yes，建议开启。Redis采用LZF压缩方式。</font><h3 id=1-2-2、关闭持久化><a class=headerlink href=#1-2-2、关闭持久化 title=1.2.2、关闭持久化></a>1.2.2、关闭持久化</h3><p><strong>若需关闭RDB持久化，只需配置<code>sava ""</code>即可。也就是说将注释掉的<code>save ""</code>打开即可</strong>。<h2 id=1-3、触发RDB快照><a class=headerlink href=#1-3、触发RDB快照 title=1.3、触发RDB快照></a>1.3、触发RDB快照</h2><ol><li>指定时间间隔内，执行指定次数写操作。<li>执行save（阻塞， 只保存快照，其它等待） 或者是bgsave（异步）命令。<li>执行 flushall 命令，清空数据库所有数据，意义不大。<li>执行 shutdown 命令，保证服务器正常关闭且不丢失任何数据，意义不大。</ol><h2 id=1-4、RDB恢复><a class=headerlink href=#1-4、RDB恢复 title=1.4、RDB恢复></a>1.4、RDB恢复</h2><p><strong>将dump.rdb文件拷贝到 redis bin 目录下，重启redis服务将会加载<code>dump.rdb</code>文件来恢复数据</strong>。<h2 id=1-5、RDB优缺点><a class=headerlink href=#1-5、RDB优缺点 title=1.5、RDB优缺点></a>1.5、RDB优缺点</h2><h3 id=1-5-1、优点><a class=headerlink href=#1-5-1、优点 title=1.5.1、优点></a>1.5.1、优点</h3><ol><li>适合大规模数据恢复。<li>如果对数据完整性和一致性要求不高，RDB是很好选择。</ol><h3 id=1-5-2、缺点><a class=headerlink href=#1-5-2、缺点 title=1.5.2、缺点></a>1.5.2、缺点</h3><ol><li>数据完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。<li>备份时占用内存，因为 Redis 在备份时会独立创建一个子进程将数据写入到一个临时文件（此时内存中的数据是原来的两倍），然后用该临时文件替换之前的旧文件。</ol><h1 id=2、AOF持久化><a class=headerlink href=#2、AOF持久化 title=2、AOF持久化></a>2、AOF持久化</h1><h2 id=2-1、AOF简介><a class=headerlink href=#2-1、AOF简介 title=2.1、AOF简介></a>2.1、AOF简介</h2><p><strong>AOF持久化功能 默认关闭。AOF会以 日志形式 记录每个写操作并追加到文件中。Redis 重启时会读取该文件来完成数据恢复工作</strong>。<h2 id=2-2、AOF持久化规则><a class=headerlink href=#2-2、AOF持久化规则 title=2.2、AOF持久化规则></a>2.2、AOF持久化规则</h2><h3 id=2-2-1、开启AOF持久化><a class=headerlink href=#2-2-1、开启AOF持久化 title=2.2.1、开启AOF持久化></a>2.2.1、开启AOF持久化</h3><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment># 开启功能</span></span><br><span class=line><span class=attr>appendonly</span> <span class=string>yes</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment># 持久化文件，默认是appendonly.aof</span></span><br><span class=line><span class=attr>appendfilename</span> <span class=string>"appendonly.aof"</span></span><br></pre></table></figure><h3 id=2-2-2、指定AOF日志更新规则><a class=headerlink href=#2-2-2、指定AOF日志更新规则 title=2.2.2、指定AOF日志更新规则></a>2.2.2、指定AOF日志更新规则</h3><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=comment># appendfsync always</span></span><br><span class=line><span class=attr>appendfsync</span> <span class=string>everysec</span></span><br><span class=line><span class=comment># appendfsync no</span></span><br></pre></table></figure><p>配置分析：<ul><li><strong>always</strong>：同步持久化，数据发生变化 就会 立刻写入磁盘。性能差 但 数据完整性较好。<li><strong>everysec</strong>：数据修改时，将修改内容放入AOF缓冲区，然后以每秒的速度写入磁盘；默认配置。<li><strong>no</strong>：数据修改时，将修改内容放入AOP缓冲区，由操作系统决定何时将缓冲区内容写入磁盘。</ul><h3 id=2-2-3、重写触发机制><a class=headerlink href=#2-2-3、重写触发机制 title=2.2.3、重写触发机制></a>2.2.3、重写触发机制</h3><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>auto-aof-rewrite-percentage</span> <span class=string>100</span></span><br><span class=line><span class=attr>auto-aof-rewrite-min-size</span> <span class=string>64mb</span></span><br></pre></table></figure><p>配置分析：<p><strong>当AOF文件大小是上次重写后大小的一倍且文件大于 64M 时触发</strong>。<h2 id=2-3、触发AOF持久化><a class=headerlink href=#2-3、触发AOF持久化 title=2.3、触发AOF持久化></a>2.3、触发AOF持久化</h2><p>依据 配置文件中配置的规则 来触发，可以是每次执行触发、每秒触发，服务关闭时触发。<h2 id=2-4、AOF恢复><a class=headerlink href=#2-4、AOF恢复 title=2.4、AOF恢复></a>2.4、AOF恢复</h2><p>将<code>appendonly.aof</code>文件拷贝到<code>/redis/bin</code>目录，重启 redis 服务将会加载<code>appendonly.aof</code>文件来恢复数据。<p>有时<code>appendonly.aof</code>文件可能会出现格式问题，此时可通过命令<code>redis-check-aof --fix appendonly.aof</code> 修复即可 。<h2 id=2-5、AOF重写机制><a class=headerlink href=#2-5、AOF重写机制 title=2.5、AOF重写机制></a>2.5、AOF重写机制</h2><h3 id=2-5-1、AOF重写简介><a class=headerlink href=#2-5-1、AOF重写简介 title=2.5.1、AOF重写简介></a>2.5.1、AOF重写简介</h3><p><strong>不断将 写操作 追加到文件中会导致文件冗余内容越来越多，故引入重写机制。当 AOF文件大小超过设定阈值时会对 AOF文件进行压缩</strong>。<h3 id=2-5-2、重写原理><a class=headerlink href=#2-5-2、重写原理 title=2.5.2、重写原理></a>2.5.2、重写原理</h3><p>fork一个子进程来读取内存中的数据，并重新写入一个临时文件，最后拿该临时文件替换旧AOF文件。<h3 id=2-5-3、触发机制><a class=headerlink href=#2-5-3、触发机制 title=2.5.3、触发机制></a>2.5.3、触发机制</h3><p>当AOF文件大小是上次rewrite后大小的一倍且文件大于 64M 时触发。这里的“一倍”和“64M” 可以通过配置文件来修改。<h2 id=2-6、AOF优缺点><a class=headerlink href=#2-6、AOF优缺点 title=2.6、AOF优缺点></a>2.6、AOF优缺点</h2><h3 id=2-6-1、优点><a class=headerlink href=#2-6-1、优点 title=2.6.1、优点></a>2.6.1、优点</h3><p>数据完整性 和 一致性 更高。<h3 id=2-6-2、缺点><a class=headerlink href=#2-6-2、缺点 title=2.6.2、缺点></a>2.6.2、缺点</h3><p>数据恢复速度慢，因为AOF记录内容较多。<h1 id=3、混合持久化><a class=headerlink href=#3、混合持久化 title=3、混合持久化></a>3、混合持久化</h1><h2 id=3-1、简介><a class=headerlink href=#3-1、简介 title=3.1、简介></a>3.1、简介</h2><p><strong>Redis4.0后新增 RDB-AOF 混合持久化方式，既能快速加载又能避免丢失太多数据</strong>。<h2 id=3-2、开启混合持久化><a class=headerlink href=#3-2、开启混合持久化 title=3.2、开启混合持久化></a>3.2、开启混合持久化</h2><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># yes 表示开启，no 表示禁用。</span></span><br><span class=line><span class=attr>aof-use-rdb-preamble</span> <span class=string>yes</span></span><br></pre></table></figure><h2 id=3-3、混合持久化之AOF重写><a class=headerlink href=#3-3、混合持久化之AOF重写 title=3.3、混合持久化之AOF重写></a>3.3、混合持久化之AOF重写</h2><h3 id=3-3-1、重写过程><a class=headerlink href=#3-3-1、重写过程 title=3.3.1、重写过程></a>3.3.1、重写过程</h3><p><strong>混合持久化开启后，<code>fork</code>出的 重写子进程 会先将与主线程共享的内存数据以 RDB 方式写入AOF 文件，写过程中主线程接收的新操作命令会被记录在重写缓冲区，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知 主进程 将含有RDB格式和AOF格式的 新AOF文件 替换 旧AOF 文件</strong>。<p>混合持久化AOF文件 前半部分是RDB格式全量数据，后半部分是AOF格式增量数据。<p><img alt=image-20210629214554392 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E6%8C%81%E4%B9%85%E5%8C%96-image-20210629214554392.png><p>注意：混合持久化AOF文件中 RDB内容的最后会使用一个<font color=orange><code>RDB_OPCODE_EOF</code></font>结束标记来区分。读取混合AOF文件时，会<strong>通过函数<code>rdbLoadRio</code>读取其中的RDB内容，通过函数<code>loadAppendOnlyFile</code>读取其中的AOF内容</strong>。<h3 id=3-3-2、数据恢复><a class=headerlink href=#3-3-2、数据恢复 title=3.3.2、数据恢复></a>3.3.2、数据恢复</h3><p>混合持久化AOF日志的优点：重启Redis后恢复数据会很快。<h1 id=5、相关问题><a class=headerlink href=#5、相关问题 title=5、相关问题></a>5、相关问题</h1><h2 id=5-1、RDB快照><a class=headerlink href=#5-1、RDB快照 title=5.1、RDB快照></a>5.1、RDB快照</h2><h3 id=5-1-1、save命令><a class=headerlink href=#5-1-1、save命令 title=5.1.1、save命令></a>5.1.1、save命令</h3><p><strong>redis内存数据高达几十G，上百G时建议用 save</strong>。<p>save命令虽然会阻塞redis直到快照生成完毕，但不用创建子进程，所以save创建快照的速度会比 bgsave 要快。<h3 id=5-1-2、保存快照时数据能否修改？><a class=headerlink href=#5-1-2、保存快照时数据能否修改？ title=5.1.2、保存快照时数据能否修改？></a>5.1.2、保存快照时数据能否修改？</h3><p><strong>得益于写时复制技术，bgsava命令运行中可继续处理其它请求</strong>。<p>bgsava 命令会通过<code>fork()</code>创建子进程，子进程和父进程 共享 同一片内存数据，子进程会复制父进程页表，但页表指向的物理内存还是同一个。<p><img alt=image-20210629221033289 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E6%8C%81%E4%B9%85%E5%8C%96-image-20210629221033289.png><p>只有发生内存数据修改时，物理内存才会被复制一份。<p><img alt=image-20210629221126775 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E6%8C%81%E4%B9%85%E5%8C%96-image-20210629221126775.png><p>这样做是为了加快创建子进程速度，减少性能损耗（创建子进程会阻塞主线程）。所以，创建 bgsave 子进程后，由于共享父进程所有内存数据，故可以直接读取主线程中的内存数据并将数据写入到 RDB 文件。<p><strong>主线程 只读 共享内存数据 时，主线程 和 bgsave子进程 间不会相互影响。但主线程要 修改 共享数据中某一块数据（比如键值对<code>A</code>）时，会发生写时复制，此时这块数据的物理内存就会被复制一份（键值对 <code>A'</code>），然后主线程在这个数据副本（键值对 <code>A'</code>）上进行修改。与此同时，bgsave 子进程可以继续把原来的数据（键值对 <code>A</code>）写入到 RDB 文件。</strong><p><strong>bgsave 快照过程中，如果主线程修改了共享数据，发生了写时复制后，RDB 快照保存的是原来的内存数据，而主线程刚修改的数据没办法在这一时间写入 RDB 文件，只能交由下一次 bgsave 快照</strong>。<blockquote><p>Redis 执行 RDB 持久化期间，如果主进程修改了共享内存，那么被修改数据的物理内存就会被复制一份。如果共享内存全部被修改，则此时内存占用将会是原先的 2 倍。所以，多写环境下要注意快照过程中的内存变化，防止内存占满。</blockquote></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hgprivate.github.io/2024/08/21/RabbitMQ%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/RabbitMQ%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/ itemprop=url>RabbitMQ系列-RabbitMQ基础应用</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 21:00:52" datetime=2023-10-02T21:00:52+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/RabbitMQ/ itemprop=url rel=index><span itemprop=name>RabbitMQ</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、-RabbitMQ概述><a title="1、 RabbitMQ概述" class=headerlink href=#1、-RabbitMQ概述></a>1、 RabbitMQ概述</h1><h2 id=1-1、何为RabbitMQ><a class=headerlink href=#1-1、何为RabbitMQ title=1.1、何为RabbitMQ></a>1.1、何为RabbitMQ</h2><p><strong>RabbitMQ是一种开源的消息队列软件，它实现了高级消息队列协议 AMQP 的标准。它是一种可靠、灵活和可扩展的消息队列，用于在应用程序之间进行异步消息传递</strong>。<h2 id=1-2、用户><a class=headerlink href=#1-2、用户 title=1.2、用户></a>1.2、用户</h2><h3 id=1-2-1、用户角色><a class=headerlink href=#1-2-1、用户角色 title=1.2.1、用户角色></a>1.2.1、用户角色</h3><p>用户角色有如下几种：<ul><li><strong>administrator</strong>：用户可以做监控所能做的一切，管理用户、vhosts和权限，关闭其他用户的连接，并管理所有vhosts的策略和参数。<li><strong>monitoring</strong>：用户可以访问管理插件，查看所有连接和通道以及节点相关信息。<li><strong>policymaker</strong>：用户可以访问管理插件，并管理他们可以访问的vhosts的策略和参数。<li><strong>management</strong>：用户可以访问管理插件<li><strong>impersonator</strong>：模拟。<li><strong>none</strong>（什么都没有）</ul><h3 id=1-2-2、用户权限><a class=headerlink href=#1-2-2、用户权限 title=1.2.2、用户权限></a>1.2.2、用户权限</h3><p>可以为用户设置的权限有：配置权限、写权限、读权限、路由权限等，设置权限时可以使用通配符。比如，基于通配符形式为用户设置读权限<code>.*</code>和写权限<code>.*</code>，两者都是通过一个点加一个星组成。<h2 id=1-3、交换机><a class=headerlink href=#1-3、交换机 title=1.3、交换机></a>1.3、交换机</h2><h3 id=1-3-1、交换机类型><a class=headerlink href=#1-3-1、交换机类型 title=1.3.1、交换机类型></a>1.3.1、交换机类型</h3><p>常见的交换机类型如下：<ul><li><strong>direct（直接）</strong><li><strong>fanout（扇出）</strong><li><strong>topic（主题）</strong><li><strong>headers（标题）</strong><li><strong>x-delayed-message（延迟交换机，依赖于插件）</strong></ul><p>注意：编码时**如果没有显式指定交换机，那么将使用默认交换机<code>(AMQP default)</code>**。<h3 id=1-3-2、交换机参数><a class=headerlink href=#1-3-2、交换机参数 title=1.3.2、交换机参数></a>1.3.2、交换机参数</h3><p>RabbitMQ 3.9.5版本中存在的交换机参数如下：<ul><li><code>alternate-exchange</code></ul><h2 id=1-3、队列><a class=headerlink href=#1-3、队列 title=1.3、队列></a>1.3、队列</h2><h3 id=1-3-1、队列参数><a class=headerlink href=#1-3-1、队列参数 title=1.3.1、队列参数></a>1.3.1、队列参数</h3><p>RabbitMQ 3.9.5版本中存在的队列参数如下：<ul><li><code>x-message-ttl</code>：发送到队列中的消息能存活多长时间，单位是毫秒。<li><code>x-expires</code>：该队列被删除前可以使用的时长，单位是毫秒。<li><code>x-overflow</code>：当队列中的消息达到最大长度时会发生什么。取值范围：<code>drop-head、reject-publish、reject-publish-dlx</code>。注意的是对于仲裁队列，只有前两个取值有效。<li><code>x-single-active-consumer</code>：一次只能有一个消费者来消费队列中的消息，如果该消费者被取消或死亡时会自动转为另一个消费者来消费消息。<li><code>x-dead-letter-exchange</code>：设置当前队列需要连接的死信交换机。当该队列中的消息成为死信后会被转发到死信交换机。<li><code>x-dead-letter-routing-key</code>：队列中的消息被转发到死信交换机时使用的路由KEY。<li><code>x-max-length</code>：设置该队列中最多可以存储多少条消息。<li><code>x-max-length-bytes</code>：设置该队列中最多可以存储多少字节的内容。<li><code>x-max-priority</code>：设置该队列中的消息可以设置的最大优先级。<li><code>x-queue-mode</code>：设置该队列的模式，默认为<code>lazy</code>。<li><code>x-queue-master-locator</code>：将队列设为主节点模式。</ul><h1 id=2、高级特性><a class=headerlink href=#2、高级特性 title=2、高级特性></a>2、高级特性</h1><h2 id=2-1、TTL><a class=headerlink href=#2-1、TTL title=2.1、TTL></a>2.1、TTL</h2><p><strong>TTL全称 Time To Live（存活时间/过期时间）</strong>。当消息到达存活时间后还没有被消费，那么该消息会被自动清除。<p>RabbitMQ可以对消息设置过期时间，也可以对队列设置过期时间。<ul><li><p>为队列设置过期时间</p> <p>创建队列时，为队列设置参数<code>x-message-ttl</code>，参数值是数值类型，单位毫秒。</p><li><p>为消息设置过期时间</p> <p>创建消息时，为消息本身设置参数。</p></ul><p>注意事项：<ol><li>队列过期后，会将队列中的消息全部移除。<li>队列和消息都设置了过期时间的情况下，以过期时间最短的为准。<li>消息过期后，只有该过期消息在队列顶端时，才会判断是否过期然后再判断是否移除。</ol><h2 id=2-2、死信队列><a class=headerlink href=#2-2、死信队列 title=2.2、死信队列></a>2.2、死信队列</h2><p><strong>死信队列，英文称为 DLX，全称为 Dead Letter Exchange（死信交换机）</strong>。当消息成为死信时，可以被重新发送至另一个交换机，而这个交换机就称为 死信交换机。需要注意的是，RabbitMQ中的死信队列通常指的是 死信交换机。<p>消息成为死信的情况有如下三种：<ul><li><strong>队列消息长度达到限制</strong>。<li><strong>队列存在过期时间设置，消息到达过期时间时没有被消费</strong>。<li><strong>消费端拒绝接收消息（消息被拒收，且没有将消息重新放入队列）</strong></ul><p>如何给队列绑定死信交换机呢？可以通过给队列设置参数<code>x-dead-letter-exchange</code>和<code>x-dead-letter-touting-key</code>来实现。<h2 id=2-3、延迟队列><a class=headerlink href=#2-3、延迟队列 title=2.3、延迟队列></a>2.3、延迟队列</h2><p>延迟队列指的是 <strong>消息进入队列后不会被立即消费，只有到达设定的时间后才会被消费</strong>。<p><font color=red>注意：RabbitMQ中没有提供 延迟队列 的功能，但可以通过 TTL+死信队列 来实现相同的功能和效果，但要注意的是TTL+死信队列实现的延迟队列有一个BUG，就是任务优先级与执行顺序不匹配的问题。</font><p>通过死信队列+TTL来实现的延迟队列功能存在一个 超时优先级错误问题，也就是消息被消费的顺序是由消息在队列中的排列顺序来决定的，而这个排列顺序是由消息被发往死信队列时的时间顺序来决定的。这样一来就会存在一种现象，那就是超时时间短的消息如果排在超时时间长的消息的后边，那么这个超时时间短的消息何时会被消费取决于其前面的超时时间长的消息何时被消费。<p><strong>要解决这个超时优先级错误问题，需要使用 RabbitMQ 提供的插件方式的延迟队列来解决</strong>。<p>要使用插件方式的延迟队列，首先要<strong>通过命令<code>rabbitmq-plugins enable x_delayed_message_exchange</code>开启该插件</strong>功能，然后在**创建交换机时设置其类型为<code>x-delayed-message</code>**即可实现延迟功能，同时也可以解决之前存在的超时优先级错误问题。<h2 id=2-4、惰性队列><a class=headerlink href=#2-4、惰性队列 title=2.4、惰性队列></a>2.4、惰性队列</h2><p><strong>RabbitMQ 3.6.0开始支持惰性队列</strong>。<p>惰性队列的特点如下：<ul><li><strong>接收到消息后直接存入磁盘而非内存</strong>。<li>消费者消费消息时会从磁盘读取消息加载到内存中。<li>支持数百万条消息的存储。</ul><p>设置或配置一个队列是惰性队列的方式如下：<ul><li><p>创建队列时直接配置</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>// 方式1 调用lazy()方法</span></span><br><span class=line><span class=keyword>return</span> QueueBuilder.durable(<span class=string>""</span>).lazy().build();</span><br><span class=line></span><br><span class=line><span class=comment>// 方式2 注解方式来配置属性x-queue-mode为lazy</span></span><br><span class=line><span class=meta>@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class=line><span class=meta>    arguments = @Argument(name = "x-queue-mode", value = "lazy")</span></span><br><span class=line><span class=meta>))</span></span><br></pre></table></figure><li><p>将运行中的队里设为惰性队列</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>rabbitmqctl set_policy Lazy <span class=string>"^lazy-queue$"</span> <span class=string>'{"queue-mode":"lazy"}'</span> --apply-to queues</span><br></pre></table></figure></ul><h2 id=2-5、仲裁队列><a class=headerlink href=#2-5、仲裁队列 title=2.5、仲裁队列></a>2.5、仲裁队列</h2><p><strong>镜像集群虽然支持主从，但主从同步并非强一致。为解决该问题，可以采用 仲裁队列 技术</strong>。<p>RabbitMQ 3.8开始推出了仲裁队列，用来替代镜像集群，该队列底层<strong>采用Raft协议</strong>保证主从同步的一致性。<p>创建仲裁队列的方法很简单，如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>// 通过调用quorum()方法即可</span></span><br><span class=line><span class=keyword>return</span> QueueBuilder.durable(<span class=string>"quorum.queue"</span>).quorum().build();</span><br></pre></table></figure><h2 id=2-6、备份交换机><a class=headerlink href=#2-6、备份交换机 title=2.6、备份交换机></a>2.6、备份交换机</h2><p>备份交换机指的是<strong>一个交换机无法将消息发送到队列时可以将该消息转发到备份交换机</strong>。<p>如何将消息转发至备份交换机呢？只需在创建交换机时为该交换机设置参数<code>alternae-exchange</code>，参数值就是备份交换机的名字。这样就可以实现该交换机无法转发消息到队列时选择将消息转发至备份交换机。<h2 id=2-7、日志与监控><a class=headerlink href=#2-7、日志与监控 title=2.7、日志与监控></a>2.7、日志与监控</h2><p>RabbitMQ日志存放路径默认在 <code>var/log/rabbitmq/rabbit@xxx.log</code>。<h2 id=2-8、消息追踪><a class=headerlink href=#2-8、消息追踪 title=2.8、消息追踪></a>2.8、消息追踪</h2><p>RabbitMQ中可以使用Firehose和rabbitmq_tracing插件功能来实现消息追踪。<h2 id=2-9、管理><a class=headerlink href=#2-9、管理 title=2.9、管理></a>2.9、管理</h2><h1 id=3、高可用><a class=headerlink href=#3、高可用 title=3、高可用></a>3、高可用</h1><h2 id=3-1、消息可靠性><a class=headerlink href=#3-1、消息可靠性 title=3.1、消息可靠性></a>3.1、消息可靠性</h2><p>通过如下配置可以实现 消息可靠性投递。<ul><li><p><strong>confirm模式</strong></p> <p>producer发送的消息无论是否成功到达 exchange 都会执行 confirmCallback。</p><li><p><strong>return模式</strong></p> <p>消息从 exchange 投递到 queue 失败时会执行 returnCallback。</p><li><p><strong>template.mandatory</strong></p> <p>设置消息路由失败时的策略。true表示会调用 returnCallback，false表示直接丢弃消息。</p></ul><h3 id=3-1-1、数据持久化><a class=headerlink href=#3-1-1、数据持久化 title=3.1.1、数据持久化></a>3.1.1、数据持久化</h3><p>交换机持久化实现方式：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>// 第二个参数表示是否持久化；第三个参数表示没有queue与之绑定时是否删除；</span></span><br><span class=line><span class=keyword>new</span> <span class="title class_">DirectExchange</span>(<span class=string>"exchange_name"</span>, <span class=literal>true</span>, <span class=literal>false</span>);</span><br></pre></table></figure><p>队列持久化实现方式：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>// durable()方法表示该队列默认就是持久化</span></span><br><span class=line>QueueBuilder.durable(<span class=string>"queue_name"</span>).build();</span><br></pre></table></figure><p>消息持久化实现方式：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>// 使用Message对象来构建要发送的消息，MessageDeliveryMode.PERSISTENT表示持久化</span></span><br><span class=line>MessageBuilder.withBody(<span class=string>"hello"</span>.getBytes(StandardCharsets.UTF_8))</span><br><span class=line>    .setDeliveryMode(MessageDeliveryMode.PERSISTENT)</span><br><span class=line>    .build();</span><br></pre></table></figure><h3 id=3-1-2、生产端确认><a class=headerlink href=#3-1-2、生产端确认 title=3.1.2、生产端确认></a>3.1.2、生产端确认</h3><p>配置文件：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>rabbitmq:</span></span><br><span class=line>    <span class=attr>addresses:</span> <span class=number>127.0</span><span class=number>.0</span><span class=number>.1</span><span class=string>:5672</span></span><br><span class=line>    <span class=attr>username:</span> <span class=string>test</span></span><br><span class=line>    <span class=attr>password:</span> <span class=string>test</span></span><br><span class=line>    <span class=attr>virtual-host:</span> <span class=string>/test</span></span><br><span class=line>    <span class=comment># 可靠投递：producer发送消息至exchange，无论消息是否成功到达exchange，都会执行confirmCallback。</span></span><br><span class=line>    <span class=comment># 可选值3个：NONE、CORRELATED（异步回调）、SIMPLE（同步等待），默认为NONE</span></span><br><span class=line>    <span class=attr>publisher-confirm-type:</span> <span class=string>correlated</span></span><br><span class=line>    <span class=comment># 可靠投递：exchange转发消息至queue失败时，会执行returnCallback。</span></span><br><span class=line>    <span class=attr>publisher-returns:</span> <span class=literal>true</span></span><br><span class=line>    <span class=comment># 消息路由失败时的处理策略。true表示会调用returnCallback，false表示直接丢弃消息。</span></span><br><span class=line>    <span class=attr>template:</span></span><br><span class=line>      <span class=attr>mandatory:</span> <span class=literal>true</span></span><br></pre></table></figure><p>注意：<strong>需要为 RabbitTemplate 设置 ReturnCallback；需要通过 CorrelationData 设置 ConfirmCallback 并保障每条消息全局唯一</strong>；<h3 id=3-1-3、消费端确认><a class=headerlink href=#3-1-3、消费端确认 title=3.1.3、消费端确认></a>3.1.3、消费端确认</h3><p><strong>ACK指的是 acknowledge，确认，表示消费端收到消息后的处理方式</strong>。<p>消费端收到消息后的处理方式有如下三种：<ul><li><p><strong>自动确认</strong>：acknowledge设为none。</p> <p>消费端收到消息后会自动确认消息已经收到，然后将消息从消息缓存中删除。</p><li><p><strong>手动确认</strong>：acknowledge设为manual。</p> <p>消费端收到消息并处理完业务后需要手动确认消息。手动确认消息可以通过调用<code>basicAck()</code>方法实现。</p><li><p><strong>根据异常情况选择性确认</strong>：acknowledge设为auto。</p> <p>消费端收到消息且在处理业务时出现了异常，会执行<code>basicNack()</code>方法并让生产端重新发送消息。如果没有出现异常，则会调用普通的<code>basicAck()</code>方法。</p></ul><p>配置文件示例如下：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=attr>spring:</span>   </span><br><span class=line>  <span class=attr>rabbitmq:</span></span><br><span class=line>    <span class=attr>addresses:</span> <span class=number>192.168</span><span class=number>.2</span><span class=number>.5</span><span class=string>:5672</span></span><br><span class=line>    <span class=attr>username:</span> <span class=string>test</span></span><br><span class=line>    <span class=attr>password:</span> <span class=string>test</span></span><br><span class=line>    <span class=attr>virtual-host:</span> <span class=string>/test</span></span><br><span class=line>    <span class=comment># 可靠投递：producer发送消息至exchange，无论消息是否成功到达exchange，都会执行confirmCallback。</span></span><br><span class=line>    <span class=comment># 可选值3个：NONE、CORRELATED（异步回调）、SIMPLE（同步等待），默认为NONE</span></span><br><span class=line>    <span class=attr>publisher-confirm-type:</span> <span class=string>correlated</span></span><br><span class=line>    <span class=comment># 可靠投递：exchange转发消息至queue失败时，会执行returnCallback。</span></span><br><span class=line>    <span class=attr>publisher-returns:</span> <span class=literal>true</span></span><br><span class=line>    <span class=comment># 消息路由失败时的处理策略。true表示会调用returnCallback，false表示直接丢弃消息。</span></span><br><span class=line>    <span class=attr>template:</span></span><br><span class=line>      <span class=attr>mandatory:</span> <span class=literal>true</span></span><br><span class=line>    <span class=attr>listener:</span></span><br><span class=line>      <span class=attr>simple:</span></span><br><span class=line>        <span class=attr>prefetch:</span> <span class=number>1</span></span><br><span class=line>        <span class=attr>concurrency:</span> <span class=number>3</span></span><br><span class=line>        <span class=attr>acknowledge-mode:</span> <span class=string>manual</span></span><br></pre></table></figure><h3 id=3-1-4、消费端失败重试><a class=headerlink href=#3-1-4、消费端失败重试 title=3.1.4、消费端失败重试></a>3.1.4、消费端失败重试</h3><p>收到消息后，在处理业务时出现异常会进行重试，那么重试策略可以通过以下几个参数来配置：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>rabbitmq:</span></span><br><span class=line>    <span class=attr>listener:</span></span><br><span class=line>      <span class=attr>simple:</span></span><br><span class=line>        <span class=attr>retry:</span></span><br><span class=line>          <span class=attr>enabled:</span> <span class=literal>true</span>              <span class=comment># 开启消费失败重试</span></span><br><span class=line>          <span class=attr>initial-interval:</span> <span class=number>1000</span>     <span class=comment># 初始失败等待时长1S</span></span><br><span class=line>          <span class=attr>multiplier:</span> <span class=number>2</span>              <span class=comment># 下次失败 等待时长翻倍</span></span><br><span class=line>          <span class=attr>max-attempts:</span> <span class=number>3</span>            <span class=comment># 最大重试次数</span></span><br><span class=line>          <span class=attr>stateless:</span> <span class=literal>true</span>            <span class=comment># true：无状态，false：有状态。若有事务则改为false。</span></span><br></pre></table></figure><p><strong>重试次数耗尽后，如果依然失败，那么需要 MessageRecoverer 接口来处理</strong>。该接口包含三种不同实现：<ul><li>RejectAndDontRequeueRecoverer：重试耗尽后，直接拒绝并丢弃消息。默认策略。<li>ImmediateRequeueMessageRecoverer：重试耗尽后，返回NACK，消息重新入队。<li>RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定交换机。</ul><p>要配置使用其它策略，可以直接创建实例并注入到容器即可。例如：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment>// 第二个参数是交换机名字；第三个参数是路由key；</span></span><br><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class=params>(RabbitTemplate rabbitTemplate)</span>{</span><br><span class=line>    <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class=string>"error.exchange"</span>, <span class=string>"error"</span>);</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-1-5、消费端限流><a class=headerlink href=#3-1-5、消费端限流 title=3.1.5、消费端限流></a>3.1.5、消费端限流</h3><p>消费端限流指的是 <strong>消费端每次只能从MQ中拉取限定数量的消息。这个限定可以通过在消费端配置<code>prefetch</code>属性来实现</strong>。<p><font color=red>注意：想要让消费端限流功能生效，必须将消费端确认消息的模式设为 手动确认，即将acknowledge设为manual。</font><h3 id=3-1-6、消息堆积><a class=headerlink href=#3-1-6、消息堆积 title=3.1.6、消息堆积></a>3.1.6、消息堆积</h3><p><strong>生产者发送消息的速度超过消费者消费的速度时会导致消息在队列中堆积，当达到队列堆积上限时会将最早接收到的消息变为死信，会被丢弃</strong>。这就是消息堆积问题。<p>解决消息堆积问题常见的方法如下：<ul><li><p><strong>增加更多的消费者</strong>，提高消费速度。</p><li><p>在消费者内<strong>开启线程池技术</strong>加快消息处理速度。</p><li><p><strong>扩大队列容量</strong>，提高消息堆积的上限。</p> <p>这种方式不太好，队列中的消息默认保存在内存中，一旦机器出现问题，内存中的数据将会消失。若需要避免这个问题，可以使用惰性队列来避免，因为惰性队列的数据会保存在磁盘中。</p></ul><h1 id=3、应用问题><a class=headerlink href=#3、应用问题 title=3、应用问题></a>3、应用问题</h1><h2 id=3-1、消息可靠性保障><a class=headerlink href=#3-1、消息可靠性保障 title=3.1、消息可靠性保障></a>3.1、消息可靠性保障</h2><p>消息的可靠性 可以通过 消息补偿机制 来实现。也可以通过以下方式来实现：<ul><li>集群 + 镜像队列<li>集群 + haproxy + keepalived<li>消息确认和应答</ul><h2 id=3-2、消息幂等性保障><a class=headerlink href=#3-2、消息幂等性保障 title=3.2、消息幂等性保障></a>3.2、消息幂等性保障</h2><p>消息的幂等性 可以通过 以下几种方式来实现：<ul><li>乐观锁<li>唯一ID<li>redis setnx命令</ul><h2 id=3-3、集群问题><a class=headerlink href=#3-3、集群问题 title=3.3、集群问题></a>3.3、集群问题</h2><h3 id=3-3-1、普通集群><a class=headerlink href=#3-3-1、普通集群 title=3.3.1、普通集群></a>3.3.1、普通集群</h3><p>普通集群存在如下问题：<ul><li>声明队列的节点如果down掉，其它节点中关于该队列也将无法使用。可以使用镜像队列来解决。</ul></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hgprivate.github.io/2024/08/21/RabbitMQ%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/RabbitMQ%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/ itemprop=url>RabbitMQ系列-RabbitMQ常见业务问题</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-09-23 19:28:20" datetime=2023-09-23T19:28:20+08:00 itemprop=dateModified>2023-09-23</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/RabbitMQ/ itemprop=url rel=index><span itemprop=name>RabbitMQ</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、消息丢失><a class=headerlink href=#1、消息丢失 title=1、消息丢失></a>1、消息丢失</h1><h2 id=1-1、丢失类型及解决方案><a class=headerlink href=#1-1、丢失类型及解决方案 title=1.1、丢失类型及解决方案></a>1.1、丢失类型及解决方案</h2><ul><li>消息发送出去，由于网络原因 没有 送达服务器。<ol><li>做好容错（try-catch），失败后要有重试机制，可记录到数据，然后定期扫描重发。<li>做好日志记录。<li>做好定期重发。</ol><li>消息到达服务器后，broker需要持久化到磁盘才算成功，但在持久化过程中服务器宕机。<ol><li>publisher也必须加入确认回调机制，确认成功的消息，修改数据库消息状态。</ol><li>自动ACK，消费者收到了消息，但没来得及消费就宕机了。<ol><li>开启手动ACK，消息消费成功后再移除，失败或没有来的及处理的消息需要noAck并重新入队。</ol></ul><h1 id=2、消息积压><a class=headerlink href=#2、消息积压 title=2、消息积压></a>2、消息积压</h1><h2 id=2-1、积压类型与解决方案><a class=headerlink href=#2-1、积压类型与解决方案 title=2.1、积压类型与解决方案></a>2.1、积压类型与解决方案</h2><ul><li>消费者宕机导致的积压。<li>消费者消费能力不足导致的积压。<li>发送者发送流量太快或太大导致积压。<ol><li>增加消费者。<li>先将数据放入数据库，然后慢慢消费。</ol></ul><h1 id=3、消息重复><a class=headerlink href=#3、消息重复 title=3、消息重复></a>3、消息重复</h1><h2 id=3-1、重复类型与解决方案><a class=headerlink href=#3-1、重复类型与解决方案 title=3.1、重复类型与解决方案></a>3.1、重复类型与解决方案</h2><ul><li>消息消费成功，事务已提交，ack时机器宕机，导致没有ack成功。<ol><li>消息由unack变为ready，然后发送给其它消费者。</ol><li>消息成功消费，ack时机器宕机，消息由unack变为ready，Broker又重新发送了。<ol><li>设计 消费者接口 满足幂等性。<li>使用防重表。<li>RabbitMQ的每条消息都有<code>redelivered</code>字段，可以判断当前消息是否被重新投递了，然后做不同处理。</ol><li>消息消费失败，由于重试机制，自动又将消息发送了一遍。</ul></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hgprivate.github.io/2024/08/21/RabbitMQ%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/RabbitMQ%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/ itemprop=url>RabbitMQ系列-RabbitMQ环境搭建</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-07 10:27:24" datetime=2023-08-07T10:27:24+08:00 itemprop=dateModified>2023-08-07</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/RabbitMQ/ itemprop=url rel=index><span itemprop=name>RabbitMQ</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1-单机部署><a class=headerlink href=#1-单机部署 title=1.单机部署></a>1.单机部署</h1><p>Centos7环境下使用Docker来安装。<h2 id=1-1-下载镜像><a class=headerlink href=#1-1-下载镜像 title=1.1.下载镜像></a>1.1.下载镜像</h2><p>方式一：在线拉取<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker pull rabbitmq:3-management</span><br></pre></table></figure><p>方式二：从本地加载<p>将镜像包上传到虚拟机中后，使用命令加载镜像即可：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker load -i mq.tar</span><br></pre></table></figure><h2 id=1-2-部署MQ><a class=headerlink href=#1-2-部署MQ title=1.2.部署MQ></a>1.2.部署MQ</h2><p>执行下面的命令来运行MQ容器：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>docker run \</span><br><span class=line> -e RABBITMQ_DEFAULT_USER=rabbitmq \</span><br><span class=line> -e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class=line> --name rabbitmq-node1 \</span><br><span class=line> --hostname mq1 \</span><br><span class=line> -p 15672:15672 \</span><br><span class=line> -p 5672:5672 \</span><br><span class=line> -d rabbitmq:3-management</span><br></pre></table></figure><h1 id=2-安装DelayExchange插件><a class=headerlink href=#2-安装DelayExchange插件 title=2.安装DelayExchange插件></a>2.安装DelayExchange插件</h1><h2 id=2-1-下载插件><a class=headerlink href=#2-1-下载插件 title=2.1.下载插件></a>2.1.下载插件</h2><p>RabbitMQ官方插件社区<a href=https://www.rabbitmq.com/community-plugins.html rel=noopener target=_blank>https://www.rabbitmq.com/community-plugins.html</a> 中包含各种插件，包括我们要使用的DelayExchange插件。<h2 id=2-2-上传插件><a class=headerlink href=#2-2-上传插件 title=2.2.上传插件></a>2.2.上传插件</h2><p>因为我们是基于Docker安装，所以需要先查看RabbitMQ的插件目录对应的数据卷。<p>先前设置的RabbitMQ数据卷名称为<code>mq-plugins</code>，使用下面命令可查看数据卷：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker volume inspect mq-plugins</span><br></pre></table></figure><h2 id=2-3-安装插件><a class=headerlink href=#2-3-安装插件 title=2.3.安装插件></a>2.3.安装插件</h2><p>进入MQ容器内部来执行安装。我的容器名为<code>mq</code>，所以执行下面命令：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker <span class=built_in>exec</span> -it mq bash</span><br></pre></table></figure><p>进入容器内部后，执行下面命令开启插件：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>rabbitmq-plugins <span class=built_in>enable</span> rabbitmq_delayed_message_exchange</span><br></pre></table></figure><h1 id=3-集群部署><a class=headerlink href=#3-集群部署 title=3.集群部署></a>3.集群部署</h1><h2 id=3-1-集群分类><a class=headerlink href=#3-1-集群分类 title=3.1.集群分类></a>3.1.集群分类</h2><p>RabbitMQ官方提出了两种集群的配置方式：<ul><li><font color=orange>普通模式</font>：普通模式集群不进行数据同步，每个MQ都有自己的队列、数据信息（其它元数据信息如交换机等会同步）。例如我们有2个MQ：mq1，和mq2，如果你的消息在mq1，而你连接到了mq2，那么mq2会去mq1拉取消息，然后返回给你。如果mq1宕机，消息就会丢失。<li><font color=orange>镜像模式</font>：与普通模式不同，队列会在各个mq的镜像节点之间同步，因此你连接到任何一个镜像节点，均可获取到消息。而且如果一个节点宕机，并不会导致数据丢失。不过，这种方式增加了数据同步的带宽消耗。</ul><p>先看普通模式集群，计划部署3个节点来实现mq集群：<table><thead><tr><th>主机名<th>控制台端口<th>amqp通信端口<tbody><tr><td>mq1<td>8081 —> 15672<td>8071 —> 5672<tr><td>mq2<td>8082 —> 15672<td>8072 —> 5672<tr><td>mq3<td>8083 —> 15672<td>8073 —> 5672</table><p>集群节点标示默认都是：<code>rabbit@[hostname]</code>，因此以上三个节点的名称分别为：<ul><li>rabbit@mq1<li>rabbit@mq2<li>rabbit@mq3</ul><h2 id=3-2-获取cookie><a class=headerlink href=#3-2-获取cookie title=3.2.获取cookie></a>3.2.获取cookie</h2><p>RabbitMQ底层依赖于Erlang，而Erlang虚拟机就是一个面向分布式的语言，默认就支持集群模式。集群模式中的每个RabbitMQ 节点使用 cookie 来确定它们是否被允许相互通信。<p>要使两个节点能够通信，它们必须具有相同的共享秘密，称为<strong>Erlang cookie</strong>。cookie 只是一串最多 255 个字符的字母数字字符。<p>每个集群节点必须具有<strong>相同的 cookie</strong>。实例之间也需要它来相互通信。<p>我们先在之前启动的mq容器中获取一个cookie值，作为集群的cookie。执行下面的命令：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker <span class=built_in>exec</span> -it mq <span class=built_in>cat</span> /var/lib/rabbitmq/.erlang.cookie</span><br></pre></table></figure><p>可以看到cookie值如下：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>FXZMCVGLBIXZCDEMMVZQ</span><br></pre></table></figure><p>停止并删除当前mq容器，重新搭建集群。<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker <span class=built_in>rm</span> -f mq</span><br></pre></table></figure><h2 id=3-3-准备集群配置><a class=headerlink href=#3-3-准备集群配置 title=3.3.准备集群配置></a>3.3.准备集群配置</h2><p>在/tmp目录新建一个配置文件 rabbitmq.conf：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=built_in>cd</span> /tmp</span><br><span class=line><span class=comment># 创建文件</span></span><br><span class=line><span class=built_in>touch</span> rabbitmq.conf</span><br></pre></table></figure><p>文件内容如下：<figure class="highlight nginx"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>loopback_users.<span class=attribute>guest</span> = <span class=literal>false</span></span><br><span class=line>listeners.tcp.default = <span class=number>5672</span></span><br><span class=line>cluster_formation.peer_discovery_backend = rabbit_peer_discovery_classic_config</span><br><span class=line>cluster_formation.classic_config.nodes.<span class=number>1</span> = rabbit<span class=variable>@mq1</span></span><br><span class=line>cluster_formation.classic_config.nodes.<span class=number>2</span> = rabbit<span class=variable>@mq2</span></span><br><span class=line>cluster_formation.classic_config.nodes.<span class=number>3</span> = rabbit<span class=variable>@mq3</span></span><br></pre></table></figure><p>再创建一个文件，记录cookie<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=built_in>cd</span> /tmp</span><br><span class=line><span class=comment># 创建cookie文件</span></span><br><span class=line><span class=built_in>touch</span> .erlang.cookie</span><br><span class=line><span class=comment># 写入cookie</span></span><br><span class=line><span class=built_in>echo</span> <span class=string>"FXZMCVGLBIXZCDEMMVZQ"</span> > .erlang.cookie</span><br><span class=line><span class=comment># 修改cookie文件的权限</span></span><br><span class=line><span class=built_in>chmod</span> 600 .erlang.cookie</span><br></pre></table></figure><p>准备三个目录,mq1、mq2、mq3：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=built_in>cd</span> /tmp</span><br><span class=line><span class=comment># 创建目录</span></span><br><span class=line><span class=built_in>mkdir</span> mq1 mq2 mq3</span><br></pre></table></figure><p>然后拷贝rabbitmq.conf、cookie文件到mq1、mq2、mq3：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment># 进入/tmp</span></span><br><span class=line><span class=built_in>cd</span> /tmp</span><br><span class=line><span class=comment># 拷贝</span></span><br><span class=line><span class=built_in>cp</span> rabbitmq.conf mq1</span><br><span class=line><span class=built_in>cp</span> rabbitmq.conf mq2</span><br><span class=line><span class=built_in>cp</span> rabbitmq.conf mq3</span><br><span class=line><span class=built_in>cp</span> .erlang.cookie mq1</span><br><span class=line><span class=built_in>cp</span> .erlang.cookie mq2</span><br><span class=line><span class=built_in>cp</span> .erlang.cookie mq3</span><br></pre></table></figure><h2 id=3-4-启动集群><a class=headerlink href=#3-4-启动集群 title=3.4.启动集群></a>3.4.启动集群</h2><p>创建一个网络：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker network create mq-net</span><br></pre></table></figure><p>docker volume create<p>运行命令<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line>docker run -d --net mq-net \</span><br><span class=line>-v <span class=variable>${PWD}</span>/mq1/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf \</span><br><span class=line>-v <span class=variable>${PWD}</span>/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \</span><br><span class=line>-e RABBITMQ_DEFAULT_USER=itcast \</span><br><span class=line>-e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class=line>--name mq1 \</span><br><span class=line>--hostname mq1 \</span><br><span class=line>-p 8071:5672 \</span><br><span class=line>-p 8081:15672 \</span><br><span class=line>rabbitmq:3.8-management</span><br></pre></table></figure><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line>docker run -d --net mq-net \</span><br><span class=line>-v <span class=variable>${PWD}</span>/mq2/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf \</span><br><span class=line>-v <span class=variable>${PWD}</span>/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \</span><br><span class=line>-e RABBITMQ_DEFAULT_USER=itcast \</span><br><span class=line>-e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class=line>--name mq2 \</span><br><span class=line>--hostname mq2 \</span><br><span class=line>-p 8072:5672 \</span><br><span class=line>-p 8082:15672 \</span><br><span class=line>rabbitmq:3.8-management</span><br></pre></table></figure><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line>docker run -d --net mq-net \</span><br><span class=line>-v <span class=variable>${PWD}</span>/mq3/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf \</span><br><span class=line>-v <span class=variable>${PWD}</span>/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \</span><br><span class=line>-e RABBITMQ_DEFAULT_USER=itcast \</span><br><span class=line>-e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class=line>--name mq3 \</span><br><span class=line>--hostname mq3 \</span><br><span class=line>-p 8073:5672 \</span><br><span class=line>-p 8083:15672 \</span><br><span class=line>rabbitmq:3.8-management</span><br></pre></table></figure><h2 id=2-5-测试><a class=headerlink href=#2-5-测试 title=2.5.测试></a>2.5.测试</h2><p>在mq1这个节点上添加一个队列，在mq2和mq3两个控制台也都能看到。<h3 id=2-5-1-数据共享测试><a class=headerlink href=#2-5-1-数据共享测试 title=2.5.1.数据共享测试></a>2.5.1.数据共享测试</h3><h3 id=2-5-2-可用性测试><a class=headerlink href=#2-5-2-可用性测试 title=2.5.2.可用性测试></a>2.5.2.可用性测试</h3><p>让节点mq1宕机：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker stop mq1</span><br></pre></table></figure><p>然后登录mq2或mq3的控制台，发现simple.queue也不可用了，说明数据并没有拷贝到mq2和mq3。<h1 id=4-镜像模式><a class=headerlink href=#4-镜像模式 title=4.镜像模式></a>4.镜像模式</h1><p>创建队列的主机宕机后队列就不可用了，不具备高可用能力。为解决该问题，必须使用镜像集群方案。<p>官方文档地址：<a href=https://www.rabbitmq.com/ha.html rel=noopener target=_blank>https://www.rabbitmq.com/ha.html</a><h2 id=4-1-镜像模式特征><a class=headerlink href=#4-1-镜像模式特征 title=4.1.镜像模式特征></a>4.1.镜像模式特征</h2><p>默认情况下，队列只保存在创建该队列的节点上。而镜像模式下，创建队列的节点被称为该队列的<strong>主节点</strong>，队列还会拷贝到集群中的其它节点，也叫做该队列的<strong>镜像</strong>节点。<p>但是，不同队列可以在集群中的任意节点上创建，因此不同队列的主节点可以不同。甚至，<strong>一个队列的主节点可能是另一个队列的镜像节点</strong>。<p>用户发送给队列的一切请求，例如发送消息、消息回执默认都会在主节点完成，如果是从节点接收到请求，也会路由到主节点去完成。<strong>镜像节点仅仅起到备份数据作用</strong>。<p>当主节点接收到消费者的ACK时，所有镜像都会删除节点中的数据。<p>总结如下：<ul><li>镜像队列结构是一主多从（从就是镜像）<li>所有操作都是主节点完成，然后同步给镜像节点<li>主宕机后，镜像节点会替代成新的主（如果在主从同步完成前，主就已经宕机，可能出现数据丢失）<li>不具备负载均衡功能，因为所有操作都会有主节点完成（但是不同队列，其主节点可以不同，可以利用这个提高吞吐量）</ul><h2 id=4-2-镜像模式配置><a class=headerlink href=#4-2-镜像模式配置 title=4.2.镜像模式配置></a>4.2.镜像模式配置</h2><p>镜像模式的配置有3种模式：<table><thead><tr><th align=left>ha-mode<th align=left>ha-params<th align=left>效果<tbody><tr><td align=left>准确模式exactly<td align=left>队列的副本量count<td align=left>集群中队列副本（主服务器和镜像服务器之和）的数量。count如果为1意味着单个副本：即队列主节点。count值为2表示2个副本：1个队列主和1个队列镜像。换句话说：count = 镜像数量 + 1。如果群集中的节点数少于count，则该队列将镜像到所有节点。如果有集群总数大于count+1，并且包含镜像的节点出现故障，则将在另一个节点上创建一个新的镜像。<tr><td align=left>all<td align=left>(none)<td align=left>队列在群集中的所有节点之间进行镜像。队列将镜像到任何新加入的节点。镜像到所有节点将对所有群集节点施加额外的压力，包括网络I / O，磁盘I / O和磁盘空间使用情况。推荐使用exactly，设置副本数为（N / 2 +1）。<tr><td align=left>nodes<td align=left><em>node names</em><td align=left>指定队列创建到哪些节点，如果指定的节点全部不存在，则会出现异常。如果指定的节点在集群中存在，但是暂时不可用，会创建节点到当前客户端连接到的节点。</table><h3 id=4-2-1-exactly模式><a class=headerlink href=#4-2-1-exactly模式 title=4.2.1.exactly模式></a>4.2.1.exactly模式</h3><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>rabbitmqctl set_policy ha-two <span class=string>"^two\."</span> <span class=string>'{"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"}'</span></span><br></pre></table></figure><ul><li><code>rabbitmqctl set_policy</code>：固定写法<li><code>ha-two</code>：策略名称，自定义<li><code>"^two\."</code>：匹配队列的正则表达式，符合命名规则的队列才生效，这里是任何以<code>two.</code>开头的队列名称<li><code>'{"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"}'</code>: 策略内容<ul><li><code>"ha-mode":"exactly"</code>：策略模式，此处是exactly模式，指定副本数量<li><code>"ha-params":2</code>：策略参数，这里是2，就是副本数量为2，1主1镜像<li><code>"ha-sync-mode":"automatic"</code>：同步策略，默认是manual，即新加入的镜像节点不会同步旧的消息。如果设置为automatic，则新加入的镜像节点会把主节点中所有消息都同步，会带来额外的网络开销</ul></ul><h3 id=4-2-2-all模式><a class=headerlink href=#4-2-2-all模式 title=4.2.2.all模式></a>4.2.2.all模式</h3><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>rabbitmqctl set_policy ha-all <span class=string>"^all\."</span> <span class=string>'{"ha-mode":"all"}'</span></span><br></pre></table></figure><ul><li><code>ha-all</code>：策略名称，自定义<li><code>"^all\."</code>：匹配所有以<code>all.</code>开头的队列名<li><code>'{"ha-mode":"all"}'</code>：策略内容<ul><li><code>"ha-mode":"all"</code>：策略模式，此处是all模式，即所有节点都会称为镜像节点</ul></ul><h3 id=4-2-3-nodes模式><a class=headerlink href=#4-2-3-nodes模式 title=4.2.3.nodes模式></a>4.2.3.nodes模式</h3><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>rabbitmqctl set_policy ha-nodes <span class=string>"^nodes\."</span> <span class=string>'{"ha-mode":"nodes","ha-params":["rabbit@nodeA", "rabbit@nodeB"]}'</span></span><br></pre></table></figure><ul><li><code>rabbitmqctl set_policy</code>：固定写法<li><code>ha-nodes</code>：策略名称，自定义<li><code>"^nodes\."</code>：匹配队列的正则表达式，符合命名规则的队列才生效，这里是任何以<code>nodes.</code>开头的队列名称<li><code>'{"ha-mode":"nodes","ha-params":["rabbit@nodeA", "rabbit@nodeB"]}'</code>: 策略内容<ul><li><code>"ha-mode":"nodes"</code>：策略模式，此处是nodes模式<li><code>"ha-params":["rabbit@mq1", "rabbit@mq2"]</code>：策略参数，这里指定副本所在节点名称</ul></ul><h2 id=4-3-测试><a class=headerlink href=#4-3-测试 title=4.3.测试></a>4.3.测试</h2><p>我们使用exactly模式的镜像，因为集群节点数量为3，因此镜像数量就设置为2。<p>运行下面的命令：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker <span class=built_in>exec</span> -it mq1 rabbitmqctl set_policy ha-two <span class=string>"^two\."</span> <span class=string>'{"ha-mode":"exactly","ha-params":2,"ha-sync-mode":"automatic"}'</span></span><br></pre></table></figure><p>创建一个新的队列，在任意一个mq控制台查看队列。<h3 id=4-3-1-测试数据共享><a class=headerlink href=#4-3-1-测试数据共享 title=4.3.1.测试数据共享></a>4.3.1.测试数据共享</h3><p>给two.queue发送一条消息，然后在mq1、mq2、mq3的任意控制台查看消息。<h3 id=4-3-2-测试高可用><a class=headerlink href=#4-3-2-测试高可用 title=4.3.2.测试高可用></a>4.3.2.测试高可用</h3><p>现在，我们让two.queue的主节点mq1宕机：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker stop mq1</span><br></pre></table></figure><p>查看集群状态、队列状态，发现依然健康，且主节点切换到了rabbit@mq2上。<h1 id=5-仲裁队列><a class=headerlink href=#5-仲裁队列 title=5.仲裁队列></a>5.仲裁队列</h1><p>RabbitMQ 3.8开始引入仲裁队列，具备镜像队列的功能，且使用更加方便。<h2 id=5-1-添加仲裁队列><a class=headerlink href=#5-1-添加仲裁队列 title=5.1.添加仲裁队列></a>5.1.添加仲裁队列</h2><p>在任意控制台添加一个队列，一定要选择队列类型为Quorum类型。在任意控制台查看队列，可以看到仲裁队列的 + 2字样。代表这个队列有2个镜像节点。<p>因为仲裁队列默认的镜像数为5。如果你的集群有7个节点，那么镜像数肯定是5；而我们集群只有3个节点，因此镜像数量就是3.<h2 id=5-2-测试><a class=headerlink href=#5-2-测试 title=5.2.测试></a>5.2.测试</h2><p>可以参考对镜像集群的测试，效果是一样的。<h2 id=5-3-集群扩容><a class=headerlink href=#5-3-集群扩容 title=5.3.集群扩容></a>5.3.集群扩容</h2><h3 id=5-3-1-加入集群><a class=headerlink href=#5-3-1-加入集群 title=5.3.1.加入集群></a>5.3.1.加入集群</h3><p>1）启动一个新的MQ容器：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>docker run -d --net mq-net \</span><br><span class=line>-v <span class=variable>${PWD}</span>/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \</span><br><span class=line>-e RABBITMQ_DEFAULT_USER=itcast \</span><br><span class=line>-e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class=line>--name mq4 \</span><br><span class=line>--hostname mq5 \</span><br><span class=line>-p 8074:15672 \</span><br><span class=line>-p 8084:15672 \</span><br><span class=line>rabbitmq:3.8-management</span><br></pre></table></figure><p>2）进入容器控制台：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker <span class=built_in>exec</span> -it mq4 bash</span><br></pre></table></figure><p>3）停止mq进程<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>rabbitmqctl stop_app</span><br></pre></table></figure><p>4）重置RabbitMQ中的数据：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>rabbitmqctl reset</span><br></pre></table></figure><p>5）加入mq1<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>rabbitmqctl join_cluster rabbit@mq1</span><br></pre></table></figure><p>6）再次启动mq进程<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>rabbitmqctl start_app</span><br></pre></table></figure><h3 id=5-3-2-增加仲裁队列副本><a class=headerlink href=#5-3-2-增加仲裁队列副本 title=5.3.2.增加仲裁队列副本></a>5.3.2.增加仲裁队列副本</h3><p>我们先查看下quorum.queue这个队列目前的副本情况，进入mq1容器：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker <span class=built_in>exec</span> -it mq1 bash</span><br></pre></table></figure><p>执行命令：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>rabbitmq-queues quorum_status <span class=string>"quorum.queue"</span></span><br></pre></table></figure><p>现在，我们让mq4也加入进来：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>rabbitmq-queues add_member <span class=string>"quorum.queue"</span> <span class=string>"rabbit@mq4"</span></span><br></pre></table></figure><p>再次查看：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>rabbitmq-queues quorum_status <span class=string>"quorum.queue"</span></span><br></pre></table></figure><p>查看控制台，发现quorum.queue的镜像数量也从原来的 +2 变成了 +3。</div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hgprivate.github.io/2024/08/21/Nginx%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Nginx%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/ itemprop=url>Nginx系列-Nginx基础应用</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 20:08:49" datetime=2023-10-02T20:08:49+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Nginx/ itemprop=url rel=index><span itemprop=name>Nginx</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=目录结构><a class=headerlink href=#目录结构 title=目录结构></a>目录结构</h1><p>Nginx主目录有如下文件，其中 带temp后缀 的文件夹在刚安装后是没有的，主要用来存放运行过程中的临时文件。<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>client_body_temp、conf、fastcgi_temp、html、logs、proxy_temp、sbin、scgi_temp、uwsgi_temp</span></span><br></pre></table></figure><ul><li>conf：用来存放配置文件相关。<li>html：用来存放静态文件的默认目录 html、css等。<li>sbin：nginx的主程序。</ul><h1 id=Nginx配置><a class=headerlink href=#Nginx配置 title=Nginx配置></a>Nginx配置</h1><h2 id=最小配置><a class=headerlink href=#最小配置 title=最小配置></a>最小配置</h2><ul><li><p><strong>worker_processes</strong>：业务进程数量，默认1。</p><li><p><strong>worker_connections</strong>：单个业务进程连接数，默认1024。</p><li><p><strong>include mime.types</strong>：引入http mime类型。</p><li><p><strong>default_type application/octet-stream</strong>：如果mime类型没匹配上，默认使用二进制流的方式传输。</p><li><p><strong>sendfile on</strong>：使用 linux sendfile(socket, file, len) 高效网络传输，也就是数据 零拷贝。</p><li><p><strong>keepalive_timeout</strong>：长连接超时时间，65。</p></ul><h2 id=配置示例><a class=headerlink href=#配置示例 title=配置示例></a>配置示例</h2><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=attr>server</span> <span class=string>{</span></span><br><span class=line>    <span class=attr>listen</span> <span class=string>80; 监听端口号</span></span><br><span class=line>    <span class=attr>server_name</span> <span class=string>localhost; 主机名</span></span><br><span class=line>    <span class=attr>location</span> <span class=string>/ { 匹配路径</span></span><br><span class=line>        <span class=attr>root</span> <span class=string>html; 文件根目录</span></span><br><span class=line>        <span class=attr>index</span> <span class=string>index.html index.htm; 默认页名称</span></span><br><span class=line>    <span class=attr>}</span></span><br><span class=line>    <span class=attr>error_page</span> <span class=string>500 502 503 504 /50x.html; 报错编码对应页面</span></span><br><span class=line>    <span class=attr>location</span> = <span class=string>/50x.html {</span></span><br><span class=line>    	<span class=attr>root</span> <span class=string>html;</span></span><br><span class=line>    <span class=attr>}</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><h2 id=server-name匹配规则><a class=headerlink href=#server-name匹配规则 title=server_name匹配规则></a>server_name匹配规则</h2><ul><li><p>完整匹配</p> <figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>server_name</span> <span class=string>vod.mmban.com www1.mmban.com;</span></span><br></pre></table></figure><li><p>通配符匹配</p> <figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>server_name</span> <span class=string>*.mmban.com</span></span><br></pre></table></figure><li><p>通配符结束匹配</p> <figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>server_name</span> <span class=string>vod.*;</span></span><br></pre></table></figure><li><p>正则匹配</p> <figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>server_name</span> <span class=string>~^[0-9]+\.mmban\.com$;</span></span><br></pre></table></figure></ul><h1 id=负载均衡><a class=headerlink href=#负载均衡 title=负载均衡></a>负载均衡</h1><h2 id=使用示例><a class=headerlink href=#使用示例 title=使用示例></a>使用示例</h2><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=attr>upstream</span> <span class=string>httpd {</span></span><br><span class=line>    <span class=attr>server</span> <span class=string>192.168.44.102:80;</span></span><br><span class=line>    <span class=attr>server</span> <span class=string>192.168.43.103:80;</span></span><br><span class=line><span class=attr>}</span></span><br><span class=line></span><br><span class=line><span class=attr>location</span> <span class=string>/ {</span></span><br><span class=line>	<span class=attr>proxy_pass</span> <span class=string>http://httpd;</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><h2 id=负载均衡策略><a class=headerlink href=#负载均衡策略 title=负载均衡策略></a>负载均衡策略</h2><h3 id=轮询（默认）><a class=headerlink href=#轮询（默认） title=轮询（默认）></a>轮询（默认）</h3><p><strong>轮询是默认策略。每个请求会按时间顺序逐一分配到不同的后端服务器</strong>。<p>参数：<ul><li><strong>fail_timeout</strong>：与max_fails结合使用。<li><strong>max_fails</strong>：fail_timeout时间内请求失败次数超过该参数值，就会确认为服务器宕机。<li><strong>fail_time</strong>：停机时间长度，默认为10s。<li><strong>backup</strong>：标记服务器为备用服务器，当主服务器无法提供服务时，备用服务器将负责提供服务。<li><strong>down</strong>：标记服务器永久停机。</ul><p>注意事项：<ul><li>轮询过程中服务器宕机会被自动移除。<li>轮询策略是默认配置。<li>适用于 无状态且短平快的服务。</ul><h3 id=权重><a class=headerlink href=#权重 title=权重></a>权重</h3><p><strong>在轮询基础上设置权重，权重越大优先提供服务。使用 weight 参数设置权重，默认值1</strong>。<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=attr>upstream</span> <span class=string>httpd {</span></span><br><span class=line>    <span class=attr>server</span> <span class=string>127.0.0.1:8050 weight=10 down;</span></span><br><span class=line>    <span class=attr>server</span> <span class=string>127.0.0.1:8060 weight=1;</span></span><br><span class=line>    <span class=attr>server</span> <span class=string>127.0.0.1:8060 weight=1 backup;</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><p>参数解析：<ul><li><strong>down</strong>：当前server暂时不参与负载。<li><strong>weight</strong>：默认为1，weight越大，负载权重越大。<li><strong>backup</strong>：非backup机器不能工作时，请求将转发至backup机器。</ul><p>注意事项：<ul><li>权重越高 表示 需要处理的请求越多。<li>可以与 least_conn 和 ip_hash 结合使用。<li>适用于 服务器配置相差较大的服务。</ul><h3 id=ip-hash><a class=headerlink href=#ip-hash title=ip_hash></a>ip_hash</h3><p><strong>根据ip地址转发至同一服务器。适用于有状态的服务</strong>。<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=attr>upstream</span> <span class=string>dynamic_zuoyu {</span></span><br><span class=line>    <span class=attr>ip_hash;</span>  <span class=string>#保证每个访客固定访问一个后端服务器</span></span><br><span class=line>    <span class=attr>server</span> <span class=string>localhost:8080  weight=2; 				 	 #tomcat 7.0</span></span><br><span class=line>    <span class=attr>server</span> <span class=string>localhost:8081; 								#tomcat 8.0</span></span><br><span class=line>    <span class=attr>server</span> <span class=string>localhost:8082; 								#tomcat 8.5</span></span><br><span class=line>    <span class=attr>server</span> <span class=string>localhost:8083  max_fails=3 fail_timeout=20s;   #tomcat 9.0</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><p>注意：<ul><li>nginx 1.3.1前，不能在ip_hash中使用权重weight。<li>ip_hash不能与backup同时使用。<li>服务器需要被移除时必须手动执行。</ul><h3 id=least-conn><a class=headerlink href=#least-conn title=least_conn></a>least_conn</h3><p><strong>将请求转发给连接数较少的后端服务器。适用于处理请求时间长短不同的服务</strong>。<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=attr>upstream</span> <span class=string>dynamic_zuoyu {</span></span><br><span class=line>  <span class=attr>least_conn;</span>  <span class=string>#把请求转发给连接数较少的后端服务器</span></span><br><span class=line>  <span class=attr>server</span> <span class=string>localhost:8080  weight=2; #tomcat 7.0</span></span><br><span class=line>  <span class=attr>server</span> <span class=string>localhost:8081; #tomcat 8.0</span></span><br><span class=line>  <span class=attr>server</span> <span class=string>localhost:8082 backup; #tomcat 8.5</span></span><br><span class=line>  <span class=attr>server</span> <span class=string>localhost:8083  max_fails=3 fail_timeout=20s; #tomcat 9.0</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><h3 id=url-hash（第三方）><a class=headerlink href=#url-hash（第三方） title=url_hash（第三方）></a>url_hash（第三方）</h3><p><strong>根据请求url的hash来分配请求，可以将每个url定向到同一个服务器，要配合缓存命中来使用</strong>。<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=attr>upstream</span> <span class=string>dynamic_zuoyu {</span></span><br><span class=line>  <span class=attr>hash</span> <span class=string>$request_uri;  #实现每个url定向到同一个后端服务器</span></span><br><span class=line>  <span class=attr>server</span> <span class=string>localhost:8080; #tomcat 7.0</span></span><br><span class=line>  <span class=attr>server</span> <span class=string>localhost:8081; #tomcat 8.0</span></span><br><span class=line>  <span class=attr>server</span> <span class=string>localhost:8082; #tomcat 8.5</span></span><br><span class=line>  <span class=attr>server</span> <span class=string>localhost:8083; #tomcat 9.0</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><h3 id=fair（第三方）><a class=headerlink href=#fair（第三方） title=fair（第三方）></a>fair（第三方）</h3><p><strong>根据 服务响应时间来分配请求，响应时间短的优先分配</strong>。<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=attr>upstream</span> <span class=string>dynamic_zuoyu {</span></span><br><span class=line>  <span class=attr>server</span> <span class=string>localhost:8080; #tomcat 7.0</span></span><br><span class=line>  <span class=attr>server</span> <span class=string>localhost:8081; #tomcat 8.0</span></span><br><span class=line>  <span class=attr>server</span> <span class=string>localhost:8082; #tomcat 8.5</span></span><br><span class=line>  <span class=attr>server</span> <span class=string>localhost:8083; #tomcat 9.0</span></span><br><span class=line>  <span class=attr>fair;</span>  <span class=string>#实现响应时间短的优先分配</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><h2 id=动静分离><a class=headerlink href=#动静分离 title=动静分离></a>动静分离</h2><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=comment># 静态文件放在 html\static 目录下</span></span><br><span class=line><span class=attr>nginx\html\static</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment># nginx.conf文件添加配置</span></span><br><span class=line><span class=attr>server</span> <span class=string>{</span></span><br><span class=line>	<span class=attr>listen</span>       <span class=string>80;</span></span><br><span class=line>	<span class=attr>server_name</span>  <span class=string>xxx.com *.xxx.com;</span></span><br><span class=line>	<span class=attr>underscores_in_headers</span> <span class=string>on;</span></span><br><span class=line><span class=comment>	</span></span><br><span class=line><span class=comment>	# 方式1（二选一）</span></span><br><span class=line>	<span class=attr>location</span> <span class=string>/static/ {</span></span><br><span class=line>		<span class=attr>root</span> <span class=string>html;</span></span><br><span class=line>	<span class=attr>}</span></span><br><span class=line><span class=comment>	</span></span><br><span class=line><span class=comment>	# 方式2（二选一）</span></span><br><span class=line>	<span class=attr>location</span> <span class=string>~*/(css|img|js) {</span></span><br><span class=line>        <span class=attr>root</span> <span class=string>/usr/local/nginx/static;</span></span><br><span class=line>        <span class=attr>index</span> <span class=string>index.html index.htm;</span></span><br><span class=line>    <span class=attr>}</span></span><br><span class=line></span><br><span class=line>	<span class=attr>location</span> <span class=string>/ {</span></span><br><span class=line>		<span class=attr>proxy_set_header</span> <span class=string>Host $host;</span></span><br><span class=line>		<span class=attr>proxy_pass</span> <span class=string>http://gulimall;</span></span><br><span class=line>	<span class=attr>}</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><h2 id=UrlRewrite><a class=headerlink href=#UrlRewrite title=UrlRewrite></a>UrlRewrite</h2><p><strong>rewrite可实现<code>url</code>重写，根据<code>regex</code>（正则表达式）重定向到<code>replacement</code>，结尾是flag标记。</strong><h3 id=语法及参数><a class=headerlink href=#语法及参数 title=语法及参数></a>语法及参数</h3><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>关键字</span>   <span class=string>正则     替代内容      flag标记</span></span><br><span class=line><span class=attr>rewrite</span> <span class=string>&LTregex> &LTreplacement> [flag];</span></span><br></pre></table></figure><ul><li>正则：判断是否满足特定需求的一种规则。<li>替代内容：符合正则匹配需求时，需要的替换内容。<li>flag标记：rewrite支持的flag标记。<ul><li>last #本条规则匹配完成后，继续向下匹配新的location URI规则。<li>break #本条规则匹配完成即终止，不再匹配后面的任何规则。<li>redirect #返回302临时重定向，浏览器地址会显示跳转后的URL地址。<li>permanent #返回301永久重定向，浏览器地址栏会显示跳转后的URL地址。</ul></ul><p>配置示例：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>rewrite ^/([0-9]+).html$ /index.jsp?pageNum=<span class=variable>$1</span> <span class=built_in>break</span>;</span><br></pre></table></figure><h3 id=网关配置><a class=headerlink href=#网关配置 title=网关配置></a>网关配置</h3><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=attr>upstream</span> <span class=string>httpds {</span></span><br><span class=line>    <span class=attr>server</span> <span class=string>192.168.44.102 weight=8 down;</span></span><br><span class=line>    <span class=attr>server</span> <span class=string>192.168.44.103:8080 weight=2;</span></span><br><span class=line>    <span class=attr>server</span> <span class=string>192.168.44.104:8080 weight=1 backup;</span></span><br><span class=line><span class=attr>}</span></span><br><span class=line><span class=attr>location</span> <span class=string>/ {</span></span><br><span class=line>    <span class=attr>rewrite</span> <span class=string>^/([0-9]+).html$ /index.jsp?pageNum=$1 redirect;</span></span><br><span class=line>    <span class=attr>proxy_pass</span> <span class=string>http://httpds ;</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><h2 id=防盗链><a class=headerlink href=#防盗链 title=防盗链></a>防盗链</h2><h3 id=语法><a class=headerlink href=#语法 title=语法></a>语法</h3><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>valid_referers none | blocked | server_names | strings ....;</span><br></pre></table></figure><ul><li>none：检测 Referer 头域不存在的情况。<li>blocked：检测 Referer 头域的值被防火墙或代理服务器删除或伪装的情况。这种情况该头域的值不以 “http://” 或 “https://” 开头。<li>server_names：设置一个或多个 URL ，检测 Referer 头域的值是否是这些 URL 中的某一个。</ul><h3 id=配置示例-1><a class=headerlink href=#配置示例-1 title=配置示例></a>配置示例</h3><p>在需要防盗链的location中配置：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=attr>valid_referers</span> <span class=string>192.168.44.101;</span></span><br><span class=line><span class=attr>if</span> <span class=string>($invalid_referer) {</span></span><br><span class=line>	<span class=attr>return</span> <span class=string>403;</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><h3 id=测试><a class=headerlink href=#测试 title=测试></a>测试</h3><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># curl测试</span></span><br><span class=line><span class=attr>curl</span> <span class=string>-I http://192.168.44.101/img/logo.png</span></span><br><span class=line><span class=comment># 带引用</span></span><br><span class=line><span class=attr>curl</span> <span class=string>-e "http://baidu.com" -I http://192.168.44.101/img/logo.png</span></span><br></pre></table></figure><h1 id=高可用><a class=headerlink href=#高可用 title=高可用></a>高可用</h1><h2 id=keepalived><a class=headerlink href=#keepalived title=keepalived></a>keepalived</h2><h3 id=概述><a class=headerlink href=#概述 title=概述></a>概述</h3><p><strong>Keepalived 是一个开源的高可用解决方案，用于确保服务和网络的连续可用性。它主要用于构建高可用性集群，提供故障切换和故障恢复机制。</strong><p><strong>Keepalived 基于虚拟路由冗余协议 VRRP 实现了服务器的冗余和故障转移。</strong>VRRP 是一种网络协议，用于将多个路由器组成一个虚拟路由器，提供故障切换和负载均衡功能。<p>Keepalived监视服务器的状态和可用性，一旦活动服务器发生故障不可用，它会自动将备份服务器切换为活动状态，接管服务并继续提供服务。<p><strong>除了故障转移，Keepalived 还提供了健康检测、负载均衡、通知机制等功能。</strong><h3 id=安装使用><a class=headerlink href=#安装使用 title=安装使用></a>安装使用</h3><p><strong>（1）通过命令安装</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 安装keepalived</span></span><br><span class=line>yum install keepalived</span><br></pre></table></figure><p>安装后配置文件在<code>/etc/keepalived/keepalived.conf</code>。<p><strong>（2）配置</strong><p>master配置信息如下：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=comment>! Configuration File for keepalived</span></span><br><span class=line><span class=attr>global_defs</span> <span class=string>{</span></span><br><span class=line>	<span class=attr>router_id</span> <span class=string>lb111</span></span><br><span class=line><span class=attr>}</span></span><br><span class=line><span class=attr>vrrp_instance</span> <span class=string>atguigu {</span></span><br><span class=line>    <span class=attr>state</span> <span class=string>MASTER</span></span><br><span class=line>    <span class=attr>interface</span> <span class=string>ens33</span></span><br><span class=line>    <span class=attr>virtual_router_id</span> <span class=string>51</span></span><br><span class=line>    <span class=attr>priority</span> <span class=string>100</span></span><br><span class=line>    <span class=attr>advert_int</span> <span class=string>1</span></span><br><span class=line>    <span class=attr>authentication</span> <span class=string>{</span></span><br><span class=line>        <span class=attr>auth_type</span> <span class=string>PASS</span></span><br><span class=line>        <span class=attr>auth_pass</span> <span class=string>1111</span></span><br><span class=line>    <span class=attr>}</span></span><br><span class=line>    <span class=attr>virtual_ipaddress</span> <span class=string>{</span></span><br><span class=line>        <span class=attr>192.168.44.200</span></span><br><span class=line>    <span class=attr>}</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><p>backup配置如下：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=comment>! Configuration File for keepalived</span></span><br><span class=line><span class=attr>global_defs</span> <span class=string>{</span></span><br><span class=line>	<span class=attr>router_id</span> <span class=string>lb110</span></span><br><span class=line><span class=attr>}</span></span><br><span class=line><span class=attr>vrrp_instance</span> <span class=string>atguigu {</span></span><br><span class=line>    <span class=attr>state</span> <span class=string>BACKUP	# 需要修改</span></span><br><span class=line>    <span class=attr>interface</span> <span class=string>ens33</span></span><br><span class=line>    <span class=attr>virtual_router_id</span> <span class=string>51</span></span><br><span class=line>    <span class=attr>priority</span> <span class=string>50		# 需要修改</span></span><br><span class=line>    <span class=attr>advert_int</span> <span class=string>1</span></span><br><span class=line>    <span class=attr>authentication</span> <span class=string>{</span></span><br><span class=line>        <span class=attr>auth_type</span> <span class=string>PASS</span></span><br><span class=line>        <span class=attr>auth_pass</span> <span class=string>1111</span></span><br><span class=line>    <span class=attr>}</span></span><br><span class=line>    <span class=attr>virtual_ipaddress</span> <span class=string>{</span></span><br><span class=line>        <span class=attr>192.168.44.200</span></span><br><span class=line>    <span class=attr>}</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><p><strong>（3）启动服务，测试效果</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>systemctl start keepalived</span><br></pre></table></figure><h1 id=Openresty><a class=headerlink href=#Openresty title=Openresty></a>Openresty</h1><h2 id=Docker方式安装><a class=headerlink href=#Docker方式安装 title=Docker方式安装></a>Docker方式安装</h2><h3 id=准备工作><a class=headerlink href=#准备工作 title=准备工作></a>准备工作</h3><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment># 1、拉取镜像</span></span><br><span class=line>docker pull openresty/openresty</span><br><span class=line></span><br><span class=line><span class=comment># 2、创建文件夹</span></span><br><span class=line><span class=built_in>mkdir</span>  /tmp/openresty/data</span><br><span class=line><span class=built_in>mkdir</span>  /tmp/openresty/conf</span><br></pre></table></figure><p>在<code>/tmp/openresty/conf</code>目录下创建<code>nginx.conf</code>文件，添加如下内容：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br></pre><td class=code><pre><span class=line><span class=comment># nginx.conf  --  docker-openresty</span></span><br><span class=line><span class=comment>#</span></span><br><span class=line><span class=comment># This file is installed to:</span></span><br><span class=line><span class=comment>#   `/usr/local/openresty/nginx/conf/nginx.conf`</span></span><br><span class=line><span class=comment># and is the file loaded by nginx at startup,</span></span><br><span class=line><span class=comment># unless the user specifies otherwise.</span></span><br><span class=line><span class=comment>#</span></span><br><span class=line><span class=comment># It tracks the upstream OpenResty's `nginx.conf`, but removes the `server`</span></span><br><span class=line><span class=comment># section and adds this directive:</span></span><br><span class=line><span class=comment>#     `include /etc/nginx/conf.d/*.conf;`</span></span><br><span class=line><span class=comment>#</span></span><br><span class=line><span class=comment># The `docker-openresty` file `nginx.vh.default.conf` is copied to</span></span><br><span class=line><span class=comment># `/etc/nginx/conf.d/default.conf`.  It contains the `server section</span></span><br><span class=line><span class=comment># of the upstream `nginx.conf`.</span></span><br><span class=line><span class=comment>#</span></span><br><span class=line><span class=comment># See https://github.com/openresty/docker-openresty/blob/master/README.md#nginx-config-files</span></span><br><span class=line><span class=comment>#</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment>#user  nobody;</span></span><br><span class=line><span class=comment>#worker_processes 1;</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment># Enables the use of JIT for regular expressions to speed-up their processing.</span></span><br><span class=line><span class=attr>pcre_jit</span> <span class=string>on;</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment>#error_log  logs/error.log;</span></span><br><span class=line><span class=comment>#error_log  logs/error.log  notice;</span></span><br><span class=line><span class=comment>#error_log  logs/error.log  info;</span></span><br><span class=line><span class=comment>#pid        logs/nginx.pid;</span></span><br><span class=line></span><br><span class=line><span class=attr>events</span> <span class=string>{</span></span><br><span class=line>    <span class=attr>worker_connections</span>  <span class=string>1024;</span></span><br><span class=line><span class=attr>}</span></span><br><span class=line></span><br><span class=line><span class=attr>http</span> <span class=string>{</span></span><br><span class=line>    <span class=attr>include</span>       <span class=string>mime.types;</span></span><br><span class=line>    <span class=attr>default_type</span>  <span class=string>application/octet-stream;</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment>    # Enables or disables the use of underscores in client request header fields.</span></span><br><span class=line><span class=comment>    # When the use of underscores is disabled, request header fields whose names contain underscores are marked as invalid and become subject to the ignore_invalid_headers directive.</span></span><br><span class=line><span class=comment>    # underscores_in_headers off;</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment>    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class=line><span class=comment>    #                  '$status $body_bytes_sent "$http_referer" '</span></span><br><span class=line><span class=comment>    #                  '"$http_user_agent" "$http_x_forwarded_for"';</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment>    #access_log  logs/access.log  main;</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment>        # Log in JSON Format</span></span><br><span class=line><span class=comment>        # log_format nginxlog_json escape=json '{ "timestamp": "$time_iso8601", '</span></span><br><span class=line><span class=comment>        # '"remote_addr": "$remote_addr", '</span></span><br><span class=line><span class=comment>        #  '"body_bytes_sent": $body_bytes_sent, '</span></span><br><span class=line><span class=comment>        #  '"request_time": $request_time, '</span></span><br><span class=line><span class=comment>        #  '"response_status": $status, '</span></span><br><span class=line><span class=comment>        #  '"request": "$request", '</span></span><br><span class=line><span class=comment>        #  '"request_method": "$request_method", '</span></span><br><span class=line><span class=comment>        #  '"host": "$host",'</span></span><br><span class=line><span class=comment>        #  '"upstream_addr": "$upstream_addr",'</span></span><br><span class=line><span class=comment>        #  '"http_x_forwarded_for": "$http_x_forwarded_for",'</span></span><br><span class=line><span class=comment>        #  '"http_referrer": "$http_referer", '</span></span><br><span class=line><span class=comment>        #  '"http_user_agent": "$http_user_agent", '</span></span><br><span class=line><span class=comment>        #  '"http_version": "$server_protocol", '</span></span><br><span class=line><span class=comment>        #  '"nginx_access": true }';</span></span><br><span class=line><span class=comment>        # access_log /dev/stdout nginxlog_json;</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment>    # See Move default writable paths to a dedicated directory (#119)</span></span><br><span class=line><span class=comment>    # https://github.com/openresty/docker-openresty/issues/119</span></span><br><span class=line>    <span class=attr>client_body_temp_path</span> <span class=string>/var/run/openresty/nginx-client-body;</span></span><br><span class=line>    <span class=attr>proxy_temp_path</span>       <span class=string>/var/run/openresty/nginx-proxy;</span></span><br><span class=line>    <span class=attr>fastcgi_temp_path</span>     <span class=string>/var/run/openresty/nginx-fastcgi;</span></span><br><span class=line>    <span class=attr>uwsgi_temp_path</span>       <span class=string>/var/run/openresty/nginx-uwsgi;</span></span><br><span class=line>    <span class=attr>scgi_temp_path</span>        <span class=string>/var/run/openresty/nginx-scgi;</span></span><br><span class=line></span><br><span class=line>    <span class=attr>sendfile</span>        <span class=string>on;</span></span><br><span class=line><span class=comment>    #tcp_nopush     on;</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment>    #keepalive_timeout  0;</span></span><br><span class=line>    <span class=attr>keepalive_timeout</span>  <span class=string>65;</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment>    #gzip  on;</span></span><br><span class=line></span><br><span class=line>    <span class=attr>include</span> <span class=string>/etc/nginx/conf.d/*.conf;</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment>    # Don't reveal OpenResty version to clients.</span></span><br><span class=line><span class=comment>    # server_tokens off;</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><h3 id=运行容器><a class=headerlink href=#运行容器 title=运行容器></a>运行容器</h3><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>docker run -<span class=built_in>id</span> -p 80:80 \</span><br><span class=line>--name openresty --restart always \</span><br><span class=line>-v /tmp/openresty/conf/nginx.conf:/usr/local/openresty/nginx/conf/nginx.conf \</span><br><span class=line>-v /etc/localtime:/etc/localtime \</span><br><span class=line>openresty/openresty</span><br><span class=line>---</span><br><span class=line>-v /tmp/openresty/lualib:/usr/local/openresty/lualib \</span><br></pre></table></figure><h2 id=本地安装><a class=headerlink href=#本地安装 title=本地安装></a>本地安装</h2><h3 id=1-2-1、安装开发库><a class=headerlink href=#1-2-1、安装开发库 title=1.2.1、安装开发库></a>1.2.1、安装开发库</h3><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>yum install -y pcre-devel openssl-devel gcc --skip-broken</span><br></pre></table></figure><h3 id=1-2-2、安装OpenResty仓库><a class=headerlink href=#1-2-2、安装OpenResty仓库 title=1.2.2、安装OpenResty仓库></a>1.2.2、安装OpenResty仓库</h3><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>yum-config-manager --add-repo https://openresty.org/package/centos/openresty.repo</span><br></pre></table></figure><p>若提示命令不存在，则运行下面命令，然后再重新安装。<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>yum install -y yum-utils </span><br></pre></table></figure><h3 id=1-2-3、安装OpenResty><a class=headerlink href=#1-2-3、安装OpenResty title=1.2.3、安装OpenResty></a>1.2.3、安装OpenResty</h3><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>yum install -y openresty</span><br></pre></table></figure><h3 id=1-2-4、安装opm工具><a class=headerlink href=#1-2-4、安装opm工具 title=1.2.4、安装opm工具></a>1.2.4、安装opm工具</h3><p>opm是OpenResty的一个管理工具，可以帮助我们安装一个第三方的Lua模块。<p>如果你想安装命令行工具 <code>opm</code>，那么可以像下面这样安装 <code>openresty-opm</code> 包：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>yum install -y openresty-opm</span><br></pre></table></figure><h3 id=1-2-5、配置Nginx环境变量><a class=headerlink href=#1-2-5、配置Nginx环境变量 title=1.2.5、配置Nginx环境变量></a>1.2.5、配置Nginx环境变量</h3><p>编辑<code>/etc/profile</code>文件，添加如下内容：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=built_in>export</span> NGINX_HOME=/usr/local/openresty/nginx</span><br><span class=line><span class=built_in>export</span> PATH=<span class=variable>${NGINX_HOME}</span>/sbin:<span class=variable>$PATH</span></span><br></pre></table></figure><p>添加完后执行命令<code>source /etc/profile</code>，让配置生效。<h3 id=1-2-6、启动运行><a class=headerlink href=#1-2-6、启动运行 title=1.2.6、启动运行></a>1.2.6、启动运行</h3><p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，内容如下：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=comment>#user  nobody;</span></span><br><span class=line><span class=attr>worker_processes</span>  <span class=string>1;</span></span><br><span class=line><span class=attr>error_log</span>  <span class=string>logs/error.log;</span></span><br><span class=line></span><br><span class=line><span class=attr>events</span> <span class=string>{</span></span><br><span class=line>    <span class=attr>worker_connections</span>  <span class=string>1024;</span></span><br><span class=line><span class=attr>}</span></span><br><span class=line></span><br><span class=line><span class=attr>http</span> <span class=string>{</span></span><br><span class=line>    <span class=attr>include</span>       <span class=string>mime.types;</span></span><br><span class=line>    <span class=attr>default_type</span>  <span class=string>application/octet-stream;</span></span><br><span class=line>    <span class=attr>sendfile</span>        <span class=string>on;</span></span><br><span class=line>    <span class=attr>keepalive_timeout</span>  <span class=string>65;</span></span><br><span class=line></span><br><span class=line>    <span class=attr>server</span> <span class=string>{</span></span><br><span class=line>        <span class=attr>listen</span>       <span class=string>8081;</span></span><br><span class=line>        <span class=attr>server_name</span>  <span class=string>localhost;</span></span><br><span class=line>        <span class=attr>location</span> <span class=string>/ {</span></span><br><span class=line>            <span class=attr>root</span>   <span class=string>html;</span></span><br><span class=line>            <span class=attr>index</span>  <span class=string>index.html index.htm;</span></span><br><span class=line>        <span class=attr>}</span></span><br><span class=line>        <span class=attr>error_page</span>   <span class=string>500 502 503 504  /50x.html;</span></span><br><span class=line>        <span class=attr>location</span> = <span class=string>/50x.html {</span></span><br><span class=line>            <span class=attr>root</span>   <span class=string>html;</span></span><br><span class=line>        <span class=attr>}</span></span><br><span class=line>    <span class=attr>}</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><p>输入命令<code>nginx</code>来启动 Nginx。然后访问页面：<code>http://192.168.150.101:8081</code>。<h2 id=基本使用><a class=headerlink href=#基本使用 title=基本使用></a>基本使用</h2><h3 id=监听处理请求><a class=headerlink href=#监听处理请求 title=监听处理请求></a>监听处理请求</h3><p>在 nginx.conf 文件中的 http 标签下面添加对 OpenResty lua 模块的加载。<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># lua 模块</span></span><br><span class=line><span class=attr>lua_package_path</span> <span class=string>"/usr/local/openresty/lualib/?.lua;;";</span></span><br><span class=line><span class=comment># c 模块     </span></span><br><span class=line><span class=attr>lua_package_cpath</span> <span class=string>"/usr/local/openresty/lualib/?.so;;";  </span></span><br></pre></table></figure><p>在 nginx.conf 文件中的 server 标签下面添加对请求路径的监听。<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=attr>localtion</span> <span class=string>/api/item {</span></span><br><span class=line><span class=comment>	# 响应类型</span></span><br><span class=line>	<span class=attr>default_type</span> <span class=string>application/json;</span></span><br><span class=line><span class=comment>	# 响应数据由 item.lua 文件来决定</span></span><br><span class=line>	<span class=attr>content_by_lua_file</span> <span class=string>lua/item.lua;</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><h3 id=获取请求参数><a class=headerlink href=#获取请求参数 title=获取请求参数></a>获取请求参数</h3><p>获取不同类型参数的方式如下：<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8-6.1.2.2-%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-OpenResty-%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0.png><h2 id=Nginx本地缓存><a class=headerlink href=#Nginx本地缓存 title=Nginx本地缓存></a>Nginx本地缓存</h2><h3 id=简介><a class=headerlink href=#简介 title=简介></a>简介</h3><p>OpenResty 为 Nginx 提供<code>shard dict</code>功能，可以在 nginx 多个 worker 之间共享数据，实现缓存功能。<h3 id=使用><a class=headerlink href=#使用 title=使用></a>使用</h3><p>1）开启共享词典<figure class="highlight nginx"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 共享字典，也就是本地缓存，名称叫做：item_cache，大小150m</span></span><br><span class=line><span class=attribute>lua_shared_dict</span> item_cache <span class=number>150m</span>; </span><br></pre></table></figure><p>2）操作共享字典<figure class="highlight lua"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>local</span> item_cache = ngx.shard.item_cache</span><br><span class=line>item_cache:set(<span class=string>'key'</span>, <span class=string>'val'</span>, <span class=number>1000</span>)</span><br><span class=line><span class=keyword>local</span> val = item_cache:get(<span class=string>'key'</span>)</span><br></pre></table></figure><h2 id=Nginx访问Redis><a class=headerlink href=#Nginx访问Redis title=Nginx访问Redis></a>Nginx访问Redis</h2><h3 id=简介-1><a class=headerlink href=#简介-1 title=简介></a>简介</h3><p>OpenResty 提供了操作 Redis 的模块，直接引入即可使用。<h3 id=环境配置><a class=headerlink href=#环境配置 title=环境配置></a>环境配置</h3><p>1）加载 OpenResty lua 模块。<p>在 nginx.conf 文件中的 http 标签下面添加对 OpenResty lua 模块的加载：<figure class="highlight nginx"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># lua 模块</span></span><br><span class=line><span class=attribute>lua_package_path</span> <span class=string>"/usr/local/openresty/lualib/?.lua;;"</span>;</span><br><span class=line><span class=comment># c 模块     </span></span><br><span class=line><span class=attribute>lua_package_cpath</span> <span class=string>"/usr/local/openresty/lualib/?.so;;"</span>;  </span><br></pre></table></figure><p>2）引入 Redis 模块，初始化 Redis 对象。<figure class="highlight lua"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>local</span> redis = <span class=built_in>require</span>(<span class=string>"resty.redis"</span>)</span><br><span class=line><span class=keyword>local</span> red = redis:new()</span><br><span class=line>red:set_timeouts(<span class=number>1000</span>, <span class=number>1000</span>, <span class=number>1000</span>)</span><br></pre></table></figure><h3 id=封装工具><a class=headerlink href=#封装工具 title=封装工具></a>封装工具</h3><p>编辑 OpenResty 函数库文件<code>/usr/local/openresty/lualib/common.lua</code>，添加如下内容：<p>1）发送 redis 请求。<figure class="highlight lua"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=comment>-- 查询redis的方法 ip和port是redis地址，key是查询的key</span></span><br><span class=line><span class=keyword>local</span> <span class=function><span class=keyword>function</span> <span class=title>read_redis</span><span class=params>(ip, port, key)</span></span></span><br><span class=line>    <span class=comment>-- 获取一个连接</span></span><br><span class=line>    <span class=keyword>local</span> ok, err = red:connect(ip, port)</span><br><span class=line>    <span class=keyword>if</span> <span class=keyword>not</span> ok <span class=keyword>then</span></span><br><span class=line>        ngx.<span class=built_in>log</span>(ngx.ERR, <span class=string>"连接redis失败 : "</span>, err)</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>nil</span></span><br><span class=line>    <span class=keyword>end</span></span><br><span class=line>    <span class=comment>-- 查询redis</span></span><br><span class=line>    <span class=keyword>local</span> resp, err = red:get(key)</span><br><span class=line>    <span class=comment>-- 查询失败处理</span></span><br><span class=line>    <span class=keyword>if</span> <span class=keyword>not</span> resp <span class=keyword>then</span></span><br><span class=line>        ngx.<span class=built_in>log</span>(ngx.ERR, <span class=string>"查询Redis失败: "</span>, err, <span class=string>", key = "</span> , key)</span><br><span class=line>    <span class=keyword>end</span></span><br><span class=line>    <span class=comment>--得到的数据为空处理</span></span><br><span class=line>    <span class=keyword>if</span> resp == ngx.null <span class=keyword>then</span></span><br><span class=line>        resp = <span class=literal>nil</span></span><br><span class=line>        ngx.<span class=built_in>log</span>(ngx.ERR, <span class=string>"查询Redis数据为空, key = "</span>, key)</span><br><span class=line>    <span class=keyword>end</span></span><br><span class=line>    close_redis(red)</span><br><span class=line>    <span class=keyword>return</span> resp</span><br><span class=line><span class=keyword>end</span></span><br></pre></table></figure><p>2）关闭 redis 连接。<figure class="highlight lua"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment>-- 关闭redis连接的工具方法，其实是放入连接池</span></span><br><span class=line><span class=keyword>local</span> <span class=function><span class=keyword>function</span> <span class=title>close_redis</span><span class=params>(red)</span></span></span><br><span class=line>    <span class=keyword>local</span> pool_max_idle_time = <span class=number>10000</span> <span class=comment>-- 连接的空闲时间，单位是毫秒</span></span><br><span class=line>    <span class=keyword>local</span> pool_size = <span class=number>100</span> <span class=comment>--连接池大小</span></span><br><span class=line>    <span class=keyword>local</span> ok, err = red:set_keepalive(pool_max_idle_time, pool_size)</span><br><span class=line>    <span class=keyword>if</span> <span class=keyword>not</span> ok <span class=keyword>then</span></span><br><span class=line>        ngx.<span class=built_in>log</span>(ngx.ERR, <span class=string>"放入redis连接池失败: "</span>, err)</span><br><span class=line>    <span class=keyword>end</span></span><br><span class=line><span class=keyword>end</span></span><br></pre></table></figure><p>3）发送 http 请求。<figure class="highlight lua"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=comment>-- 封装函数，发送http请求，并解析响应</span></span><br><span class=line><span class=keyword>local</span> <span class=function><span class=keyword>function</span> <span class=title>read_http</span><span class=params>(path, params)</span></span></span><br><span class=line>    <span class=keyword>local</span> resp = ngx.location.capture(<span class=built_in>path</span>,{</span><br><span class=line>        method = ngx.HTTP_GET,</span><br><span class=line>        args = params,</span><br><span class=line>    })</span><br><span class=line>    <span class=keyword>if</span> <span class=keyword>not</span> resp <span class=keyword>then</span></span><br><span class=line>        <span class=comment>-- 记录错误信息，返回404</span></span><br><span class=line>        ngx.<span class=built_in>log</span>(ngx.ERR, <span class=string>"http not found, path: "</span>, <span class=built_in>path</span> , <span class=string>", args: "</span>, args)</span><br><span class=line>        ngx.<span class=built_in>exit</span>(<span class=number>404</span>)</span><br><span class=line>    <span class=keyword>end</span></span><br><span class=line>    <span class=keyword>return</span> resp.body</span><br><span class=line><span class=keyword>end</span></span><br><span class=line><span class=comment>-- 将方法导出</span></span><br><span class=line><span class=keyword>local</span> _M = {  </span><br><span class=line>    read_http = read_http</span><br><span class=line>}  </span><br><span class=line><span class=keyword>return</span> _M</span><br></pre></table></figure><h3 id=测试示例><a class=headerlink href=#测试示例 title=测试示例></a>测试示例</h3><figure class="highlight lua"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=comment>-- 引入cjson库</span></span><br><span class=line><span class=keyword>local</span> cjson = <span class=built_in>require</span>(<span class=string>'cjson'</span>)</span><br><span class=line><span class=comment>-- 引入 common 函数库</span></span><br><span class=line><span class=keyword>local</span> common = <span class=built_in>require</span>(<span class=string>'common'</span>)</span><br><span class=line><span class=keyword>local</span> read_http = common.read_http</span><br><span class=line><span class=keyword>local</span> read_redis = common.read_redis</span><br><span class=line></span><br><span class=line><span class=comment>-- 先查询redis，未命中时再查询tomcat</span></span><br><span class=line><span class=function><span class=keyword>function</span> <span class=title>read_data</span><span class=params>(key, path, params)</span></span></span><br><span class=line>    <span class=keyword>local</span> resp = read_redis(<span class=string>"127.0.0.1"</span>, <span class=number>6379</span>, key)</span><br><span class=line>    <span class=keyword>if</span> <span class=keyword>not</span> resp <span class=keyword>then</span></span><br><span class=line>        ngx.<span class=built_in>log</span>(<span class=string>"redis查询失败，尝试查询http，key："</span>， key)</span><br><span class=line>        resp = read_http(<span class=built_in>path</span>, params)</span><br><span class=line>    <span class=keyword>end</span></span><br><span class=line>    <span class=keyword>return</span> resp</span><br><span class=line><span class=keyword>end</span></span><br><span class=line></span><br><span class=line><span class=keyword>local</span> itemJson = read_data(<span class=string>"item:id"</span> .. id, <span class=string>"/item/"</span> .. id, <span class=literal>nil</span>)</span><br><span class=line><span class=comment>-- 将 json 转为lua的table</span></span><br><span class=line><span class=keyword>local</span> item = cjson.decode(itemJson)</span><br><span class=line>    </span><br><span class=line>ngx.say(cjson.encode(item))</span><br></pre></table></figure><h2 id=Nginx访问Tomcat><a class=headerlink href=#Nginx访问Tomcat title=Nginx访问Tomcat></a>Nginx访问Tomcat</h2><h3 id=发送HTTP请求><a class=headerlink href=#发送HTTP请求 title=发送HTTP请求></a>发送HTTP请求</h3><h3 id=proxy-pass方式><a class=headerlink href=#proxy-pass方式 title=proxy_pass方式></a>proxy_pass方式</h3><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br></pre><td class=code><pre><span class=line><span class=attr>http</span> <span class=string>{</span></span><br><span class=line>    <span class=attr>upstream</span> <span class=string>md5_server{</span></span><br><span class=line>        <span class=attr>server</span> <span class=string>127.0.0.1:81;</span></span><br><span class=line>        <span class=attr>keepalive</span> <span class=string>20;</span></span><br><span class=line>    <span class=attr>}</span></span><br><span class=line></span><br><span class=line>    <span class=attr>server</span> <span class=string>{</span></span><br><span class=line>        <span class=attr>listen</span>    <span class=string>80;</span></span><br><span class=line>        <span class=attr>location</span> <span class=string>/test {</span></span><br><span class=line>            <span class=attr>content_by_lua_block</span> <span class=string>{</span></span><br><span class=line>                <span class=attr>ngx.req.read_body()</span></span><br><span class=line>                <span class=attr>local</span> <span class=string>args, err = ngx.req.get_uri_args()</span></span><br><span class=line>                <span class=attr>local</span> <span class=string>res = ngx.location.capture('/spe_md5',{</span></span><br><span class=line>                        <span class=attr>method</span> = <span class=string>ngx.HTTP_POST,</span></span><br><span class=line>                        <span class=attr>body</span> = <span class=string>args.data</span></span><br><span class=line>                <span class=attr>})</span></span><br><span class=line>                <span class=attr>if</span> <span class=string>200 ~= res.status then</span></span><br><span class=line>                    <span class=attr>ngx.exit(res.status)</span></span><br><span class=line>                <span class=attr>end</span></span><br><span class=line>                <span class=attr>if</span> <span class=string>args.key == res.body then</span></span><br><span class=line>                    <span class=attr>ngx.say("valid</span> <span class=string>request")</span></span><br><span class=line>                <span class=attr>else</span></span><br><span class=line>                    <span class=attr>ngx.say("invalid</span> <span class=string>request")</span></span><br><span class=line>                <span class=attr>end</span></span><br><span class=line>            <span class=attr>}</span></span><br><span class=line>        <span class=attr>}</span></span><br><span class=line>        <span class=attr>location</span> <span class=string>/spe_md5 {</span></span><br><span class=line>            <span class=attr>proxy_pass</span> <span class=string>http://md5_server;   -- ④</span></span><br><span class=line><span class=comment>            #For HTTP, the proxy_http_version directive should be set to “1.1” and the “Connection” </span></span><br><span class=line><span class=comment>            #header field should be cleared.（from:http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive)</span></span><br><span class=line>            <span class=attr>proxy_http_version</span> <span class=string>1.1;</span></span><br><span class=line>            <span class=attr>proxy_set_header</span> <span class=string>Connection "";</span></span><br><span class=line>        <span class=attr>}</span></span><br><span class=line>    <span class=attr>}</span></span><br><span class=line></span><br><span class=line>    <span class=attr>server</span> <span class=string>{</span></span><br><span class=line>        <span class=attr>listen</span>    <span class=string>81;</span></span><br><span class=line>        <span class=attr>location</span> <span class=string>/spe_md5 {</span></span><br><span class=line>            <span class=attr>content_by_lua_block</span> <span class=string>{</span></span><br><span class=line>                <span class=attr>ngx.req.read_body()</span></span><br><span class=line>                <span class=attr>local</span> <span class=string>data = ngx.req.get_body_data()</span></span><br><span class=line>                <span class=attr>ngx.print(ngx.md5(data</span> <span class=string>.. "*&^%$#$^&kjtrKUYG"))</span></span><br><span class=line>            <span class=attr>}</span></span><br><span class=line>        <span class=attr>}</span></span><br><span class=line>    <span class=attr>}</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><h3 id=cosocket方式><a class=headerlink href=#cosocket方式 title=cosocket方式></a>cosocket方式</h3><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br></pre><td class=code><pre><span class=line><span class=attr>http</span> <span class=string>{</span></span><br><span class=line>    <span class=attr>server</span> <span class=string>{</span></span><br><span class=line>        <span class=attr>listen</span> <span class=string>80;</span></span><br><span class=line>        <span class=attr>location</span> <span class=string>/test {</span></span><br><span class=line>            <span class=attr>content_by_lua_block</span> <span class=string>{</span></span><br><span class=line>                <span class=attr>ngx.req.read_body()</span></span><br><span class=line>                <span class=attr>local</span> <span class=string>args, err = ngx.req.get_uri_args()</span></span><br><span class=line>                <span class=attr>local</span> <span class=string>http = require "resty.http"</span></span><br><span class=line>                <span class=attr>local</span> <span class=string>httpc = http.new()</span></span><br><span class=line>                <span class=attr>local</span> <span class=string>res, err = httpc:request_uri(</span></span><br><span class=line>                    <span class=attr>"http</span>:<span class=string>//127.0.0.1:81/spe_md5",{</span></span><br><span class=line>                        <span class=attr>method</span> = <span class=string>"POST",</span></span><br><span class=line>                        <span class=attr>body</span> = <span class=string>args.data,</span></span><br><span class=line>                     <span class=attr>})</span></span><br><span class=line></span><br><span class=line>                <span class=attr>if</span> <span class=string>200 ~= res.status then</span></span><br><span class=line>                    <span class=attr>ngx.exit(res.status)</span></span><br><span class=line>                <span class=attr>end</span></span><br><span class=line></span><br><span class=line>                <span class=attr>if</span> <span class=string>args.key == res.body then</span></span><br><span class=line>                    <span class=attr>ngx.say("valid</span> <span class=string>request")</span></span><br><span class=line>                <span class=attr>else</span></span><br><span class=line>                    <span class=attr>ngx.say("invalid</span> <span class=string>request")</span></span><br><span class=line>                <span class=attr>end</span></span><br><span class=line>            <span class=attr>}</span></span><br><span class=line>        <span class=attr>}</span></span><br><span class=line>    <span class=attr>}</span></span><br><span class=line></span><br><span class=line>    <span class=attr>server</span> <span class=string>{</span></span><br><span class=line>        <span class=attr>listen</span>    <span class=string>81;</span></span><br><span class=line>        <span class=attr>location</span> <span class=string>/spe_md5 {</span></span><br><span class=line>            <span class=attr>content_by_lua_block</span> <span class=string>{</span></span><br><span class=line>                <span class=attr>ngx.req.read_body()</span></span><br><span class=line>                <span class=attr>local</span> <span class=string>data = ngx.req.get_body_data()</span></span><br><span class=line>                <span class=attr>ngx.print(ngx.md5(data</span> <span class=string>.. "*&^%$#$^&kjtrKUYG"))</span></span><br><span class=line>            <span class=attr>}</span></span><br><span class=line>        <span class=attr>}</span></span><br><span class=line>    <span class=attr>}</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><h3 id=环境配置-1><a class=headerlink href=#环境配置-1 title=环境配置></a>环境配置</h3><p>加载 OpenResty lua 模块。<p>在配置文件 nginx.conf 中的 http 模块下添加如下内容：<figure class="highlight nginx"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>#lua 模块</span></span><br><span class=line><span class=attribute>lua_package_path</span> <span class=string>"/usr/local/openresty/lualib/?.lua;;"</span>;</span><br><span class=line><span class=comment>#c模块     </span></span><br><span class=line><span class=attribute>lua_package_cpath</span> <span class=string>"/usr/local/openresty/lualib/?.so;;"</span>;  </span><br></pre></table></figure><h3 id=封装工具-1><a class=headerlink href=#封装工具-1 title=封装工具></a>封装工具</h3><p>封装发送 http 请求的函数。<p>编辑 OpenResty 函数库文件<code>/usr/local/openresty/lualib/common.lua</code>，添加如下内容：<figure class="highlight lua"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=comment>-- 封装函数，发送http请求，并解析响应</span></span><br><span class=line><span class=keyword>local</span> <span class=function><span class=keyword>function</span> <span class=title>read_http</span><span class=params>(path, params)</span></span></span><br><span class=line>    <span class=keyword>local</span> resp = ngx.location.capture(<span class=built_in>path</span>,{</span><br><span class=line>        method = ngx.HTTP_GET,</span><br><span class=line>        args = params,</span><br><span class=line>    })</span><br><span class=line>    <span class=keyword>if</span> <span class=keyword>not</span> resp <span class=keyword>then</span></span><br><span class=line>        ngx.<span class=built_in>log</span>(ngx.ERR, <span class=string>"http not found, path: "</span>, <span class=built_in>path</span> , <span class=string>", args: "</span>, args)</span><br><span class=line>        ngx.<span class=built_in>exit</span>(<span class=number>404</span>)</span><br><span class=line>    <span class=keyword>end</span></span><br><span class=line>    <span class=keyword>return</span> resp.body</span><br><span class=line><span class=keyword>end</span></span><br><span class=line><span class=comment>-- 将方法导出</span></span><br><span class=line><span class=keyword>local</span> _M = {  </span><br><span class=line>    read_http = read_http</span><br><span class=line>}  </span><br><span class=line><span class=keyword>return</span> _M</span><br></pre></table></figure><h3 id=测试示例-1><a class=headerlink href=#测试示例-1 title=测试示例></a>测试示例</h3><figure class="highlight lua"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=comment>-- 引入 common 函数库</span></span><br><span class=line><span class=keyword>local</span> common = <span class=built_in>require</span>(<span class=string>'common'</span>)</span><br><span class=line><span class=keyword>local</span> read_http = common.read_http</span><br><span class=line><span class=comment>-- 引入cjson库</span></span><br><span class=line><span class=keyword>local</span> cjson = <span class=built_in>require</span>(<span class=string>'cjson'</span>)</span><br><span class=line></span><br><span class=line><span class=comment>-- 获取路径参数</span></span><br><span class=line><span class=keyword>local</span> id = ngx.var[<span class=number>1</span>]</span><br><span class=line></span><br><span class=line><span class=comment>-- 获取商品信息</span></span><br><span class=line><span class=keyword>local</span> itemJson = read_http(<span class=string>"/item"</span> .. id, <span class=literal>nil</span>)</span><br><span class=line><span class=keyword>local</span> item = cjson.decode(itemJson)</span><br><span class=line></span><br><span class=line><span class=comment>-- 返回结果</span></span><br><span class=line>ngx.say(itemJson)</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hgprivate.github.io/2024/08/21/Netty%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Netty%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=url>计算机系列-Netty</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-06 16:32:46" datetime=2023-10-06T16:32:46+08:00 itemprop=dateModified>2023-10-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/ itemprop=url rel=index><span itemprop=name>计算机</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、Netty><a class=headerlink href=#1、Netty title=1、Netty></a>1、Netty</h1><h2 id=1-1、Netty-NIO><a title="1.1、Netty NIO" class=headerlink href=#1-1、Netty-NIO></a>1.1、Netty NIO</h2><h3 id=1-1-1、TCP粘包-拆包解决之道><a class=headerlink href=#1-1-1、TCP粘包-拆包解决之道 title=1.1.1、TCP粘包/拆包解决之道></a>1.1.1、TCP粘包/拆包解决之道</h3><h4 id=TCP粘包-拆包问题><a class=headerlink href=#TCP粘包-拆包问题 title=TCP粘包/拆包问题></a>TCP粘包/拆包问题</h4><p><img alt=image-20200926153613957 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20200926153613957.png><p><img alt=image-20200926153705885 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20200926153705885.png><h4 id=TCP粘包-拆包发送的原因><a class=headerlink href=#TCP粘包-拆包发送的原因 title=TCP粘包/拆包发送的原因></a>TCP粘包/拆包发送的原因</h4><ol><li>应用程序write写入的字节 大于 套接口发送缓冲区的大小。<li>进行MSS大小的TCP分段。<li>以太网帧的payload大于MTU进行IP分片。</ol><h4 id=TCP粘包-拆包解决策略><a class=headerlink href=#TCP粘包-拆包解决策略 title=TCP粘包/拆包解决策略></a>TCP粘包/拆包解决策略</h4><ol><li>消息定长。<li>在包尾增加回车换行符进行分割，例如FTP协议。<li>将消息分为消息头和消息体，消息头中包含表示消息总长度的字段，通常设计思路为消息头的第一个字段使用int32来表示消息总长度。<li>更复杂的应用层协议。</ol><h4 id=利用LineBasedFrameDecoder解决TCP粘包问题><a class=headerlink href=#利用LineBasedFrameDecoder解决TCP粘包问题 title=利用LineBasedFrameDecoder解决TCP粘包问题></a>利用LineBasedFrameDecoder解决TCP粘包问题</h4><h3 id=1-1-2、分隔符和定长解码器的应用><a class=headerlink href=#1-1-2、分隔符和定长解码器的应用 title=1.1.2、分隔符和定长解码器的应用></a>1.1.2、分隔符和定长解码器的应用</h3><p><img alt=image-20200926154906270 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20200926154906270.png><h4 id=DelimiterBasedFrameDecoder应用开发><a class=headerlink href=#DelimiterBasedFrameDecoder应用开发 title=DelimiterBasedFrameDecoder应用开发></a>DelimiterBasedFrameDecoder应用开发</h4><p>通过DelimiterBasedFrameDecoder的使用，可以自动完成以分隔符作为码流结束标志的消息的解码。<h4 id=FixedLengthFrameDecoder应用开发><a class=headerlink href=#FixedLengthFrameDecoder应用开发 title=FixedLengthFrameDecoder应用开发></a>FixedLengthFrameDecoder应用开发</h4><p>FixedLengthFrameDecoder是固定长度解码器，它能够按照指定长度对消息进行自动解码，开发者无需考虑TCP粘包/拆包问题，非常实用。<h2 id=1-2、Netty编解码技术><a class=headerlink href=#1-2、Netty编解码技术 title=1.2、Netty编解码技术></a>1.2、Netty编解码技术</h2><h3 id=1-2-1、编解码技术><a class=headerlink href=#1-2-1、编解码技术 title=1.2.1、编解码技术></a>1.2.1、编解码技术</h3><h4 id=Java序列化缺点><a class=headerlink href=#Java序列化缺点 title=Java序列化缺点></a>Java序列化缺点</h4><ol><li>无法跨语言。<li>序列化后码流太大。<li>序列化性能太低。</ol><h4 id=主流编解码框架><a class=headerlink href=#主流编解码框架 title=主流编解码框架></a>主流编解码框架</h4><ol><li>Google的Protobuf。<li>Facebook的Thrift。<li>JBoss Marshalling。</ol><h3 id=1-2-2、MessagePack编解码><a class=headerlink href=#1-2-2、MessagePack编解码 title=1.2.2、MessagePack编解码></a>1.2.2、MessagePack编解码</h3><h4 id=MessagePack特点><a class=headerlink href=#MessagePack特点 title=MessagePack特点></a>MessagePack特点</h4><ol><li>编解码高效、性能高。<li>序列化后码流小。<li>支持跨语言。</ol><h4 id=粘包-半包支持><a class=headerlink href=#粘包-半包支持 title=粘包/半包支持></a>粘包/半包支持</h4><p>基于Netty的<code>LengthFieldPrepender</code>和<code>LengthFieldBasedFrameDecoder</code>并结合<code>MessagePark</code>可以实现对TCP粘包/半包的支持。<h3 id=1-2-3、Google-Protobuf编解码><a title="1.2.3、Google Protobuf编解码" class=headerlink href=#1-2-3、Google-Protobuf编解码></a>1.2.3、Google Protobuf编解码</h3><h4 id=Protobuf优点><a class=headerlink href=#Protobuf优点 title=Protobuf优点></a>Protobuf优点</h4><ol><li>谷歌内部长期使用，成熟度高。<li>跨语言支持。<li>编码后消息更小。<li>编解码性能非常高。<li>支持不同协议版本的向前兼容。<li>支持定义可选和必选字段。</ol><h4 id=注意事项><a class=headerlink href=#注意事项 title=注意事项></a>注意事项</h4><ol><li>ProtobufDecoder仅负责解码，且不支持读半包。因此ProtobufDecoder前面一定要有能够处理读半包的解码器，其由以下三种方式可选择：<ol><li>使用Netty提供的ProtobufVarint32FrameDecoder，其可以处理半包消息。<li>继承Netty提供的通用半包解码器LengthFieldBasedFrameDecoder。<li>继承ByteToMessageDecoder类，自己处理半包消息。</ol></ol><h3 id=1-2-4、JBoss-Marshalling编解码><a title="1.2.4、JBoss Marshalling编解码" class=headerlink href=#1-2-4、JBoss-Marshalling编解码></a>1.2.4、JBoss Marshalling编解码</h3><h2 id=1-3、HTTP协议开发应用><a class=headerlink href=#1-3、HTTP协议开发应用 title=1.3、HTTP协议开发应用></a>1.3、HTTP协议开发应用</h2><h3 id=1-3-1、HTTP协议介绍><a class=headerlink href=#1-3-1、HTTP协议介绍 title=1.3.1、HTTP协议介绍></a>1.3.1、HTTP协议介绍</h3><p>HTTP协议的主要特点：<ol><li>支持Client/Server模式。<li>简单——客户端请求服务器时，只需指定URL，携带必要请求参数或消息体。<li>灵活——HTTP允许传递任意类型的数据对象，传输内容的类型由HTTP消息头中的Content-Type加以标记。<li>无状态——HTTP是无状态协议，无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要之前的消息，则它必须重传，这样可能导致每次连接传递的数据量增大。另一方面，在服务器不需要先前消息时它的应答就很快。</ol><h3 id=1-3-2、HTTP请求消息><a class=headerlink href=#1-3-2、HTTP请求消息 title=1.3.2、HTTP请求消息></a>1.3.2、HTTP请求消息</h3><p>HTTP请求由三部分组成：<ol><li>HTTP请求行。<li>HTTP消息头。<li>HTTP请求正文。</ol><p><img alt=image-20200926145610266 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20200926145610266.png><p>请求方法有多种，各方法作用如下：<ol><li>GET：请求获取 Request-URLI所标识的资源后附加新的提交数据；<li>POST：在 Request-URI所标识的资源后 附加新的提交数据；<li>HEAD：请求获取 由Request-URI 所标识的资源的响应消息报头；<li>PUT：请求服务器存储一个资源，并用 Request-URI 作为其标识；<li>DELETE：请求服务器删除 Request-URI 所标识的资源；<li>TRACE：请求服务器回收收到的请求信息，主要用于测试或诊断；<li>CONNECT：保留将来使用；<li>OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求；</ol><h3 id=1-3-3、HTTP响应消息><a class=headerlink href=#1-3-3、HTTP响应消息 title=1.3.3、HTTP响应消息></a>1.3.3、HTTP响应消息</h3><p>HTTP响应由三部分组成：<ol><li><p>状态行。</p> <p><img alt=image-20200926150121923 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20200926150121923.png></p> <p>状态代码由三位数字组成：</p> <p><img alt=image-20200926150229810 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20200926150229810.png></p> <p><img alt=image-20200926150317627 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20200926150317627.png></p><li><p>消息报头。</p><li><p>响应正文。</p></ol><h2 id=1-4、WebSocket协议开发><a class=headerlink href=#1-4、WebSocket协议开发 title=1.4、WebSocket协议开发></a>1.4、WebSocket协议开发</h2><h3 id=1-4-1、HTTP协议弊端><a class=headerlink href=#1-4-1、HTTP协议弊端 title=1.4.1、HTTP协议弊端></a>1.4.1、HTTP协议弊端</h3><ol><li>HTTP是半双工协议。半双工说的是<strong>数据可以在客户端和服务两个方向传输，但不能同时传输</strong>。<li>HTTP消息冗长繁琐。HTTP消息包括消息头、消息体、换行符等，通常采用文本方式传输，相比其它二进制通信协议，冗长而繁琐。<li>针对服务器推送的黑客攻击，例如长时间轮询。</ol><p>为了解决其弊端，HTML5定义了WebSocket协议，能节省服务器资源和带宽并达到实时通信。<h3 id=1-4-2、WebSocket入门><a class=headerlink href=#1-4-2、WebSocket入门 title=1.4.2、WebSocket入门></a>1.4.2、WebSocket入门</h3><p>WebSocket特点如下：<ol><li>单一TCP连接，采用全双工模式通信。<li>对代理、防火墙、路由器透明。<li>无头部信息、Cookie和身份验证。<li>无安全开销。<li>通过<code>ping/pong</code>帧保持链路激活。<li>服务器可以主动传递消息给客户端，不再需要客户端轮询。</ol><h4 id=WebSocket链接建立><a class=headerlink href=#WebSocket链接建立 title=WebSocket链接建立></a>WebSocket链接建立</h4><p>为建立一个WebSocket连接，客户端浏览器首选需要发送一个HTTP请求，该请求包含了一些附加头信息<code>Upgrade:WebSocket</code>，该附加头表明这是一个申请协议升级的请求。服务器解析附加头信息后，客户端和服务器就建立了连接，双方可以通过该连接通道互相传送消息，该连接会一直持续到客户端或服务端一方主动关闭连接。<h4 id=WebSocket生命周期><a class=headerlink href=#WebSocket生命周期 title=WebSocket生命周期></a>WebSocket生命周期</h4><p><img alt=image-20201220161719568 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20201220161719568.png><h4 id=WebSocket连接关闭><a class=headerlink href=#WebSocket连接关闭 title=WebSocket连接关闭></a>WebSocket连接关闭</h4><p>为关闭WebSocket连接，客和服需要通过一个安全的方法关闭底层的TCP链接以及TLS会话。如果合适，丢弃任何可能已经接收的字节，必要时，可以通过任何可用的手段关闭连接。<h3 id=1-4-3、Netty-WebSocket协议开发><a title="1.4.3、Netty WebSocket协议开发" class=headerlink href=#1-4-3、Netty-WebSocket协议开发></a>1.4.3、Netty WebSocket协议开发</h3><p>Netty基于HTTP协议栈开发了WebSocket协议栈，利用Netty的WebSocket协议栈可以很方便开发出WebSocket客户端和服务端。<h2 id=1-5、私有协议栈开发><a class=headerlink href=#1-5、私有协议栈开发 title=1.5、私有协议栈开发></a>1.5、私有协议栈开发</h2><h3 id=1-5-1、Netty协议栈功能设计><a class=headerlink href=#1-5-1、Netty协议栈功能设计 title=1.5.1、Netty协议栈功能设计></a>1.5.1、Netty协议栈功能设计</h3><p>Netty协议栈用于内部各模块之间的通信，它基于TCP/IP协议栈，是一个类HTTP协议的应用层协议栈，相比传统标准协议栈，它更轻巧、灵活和实用。<h4 id=Netty协议栈主要功能如下：><a class=headerlink href=#Netty协议栈主要功能如下： title=Netty协议栈主要功能如下：></a>Netty协议栈主要功能如下：</h4><ol><li>基于Netty的NIO通信框架，提供高性能的异步通信功能。<li>提供消息的编解码框架，可实现POJO的序列化和反序列化。<li>提供基于IP地址的白名单接入认证机制。<li>链路的有效性校验机制。<li>链路的断连重连机制。</ol><h4 id=Netty协议栈通信模型><a class=headerlink href=#Netty协议栈通信模型 title=Netty协议栈通信模型></a>Netty协议栈通信模型</h4><p><img alt=image-20200925134651980 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20200925134651980.png><h4 id=Netty协议栈消息定义包括两部分><a class=headerlink href=#Netty协议栈消息定义包括两部分 title=Netty协议栈消息定义包括两部分;></a>Netty协议栈消息定义包括两部分;</h4><ol><li>消息头。<li>消息体。</ol><h4 id=Netty协议支持的字段数据类型如下图：><a class=headerlink href=#Netty协议支持的字段数据类型如下图： title=Netty协议支持的字段数据类型如下图：></a>Netty协议支持的字段数据类型如下图：</h4><p><img alt=image-20200925135153588 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20200925135153588.png><h4 id=链路的建立><a class=headerlink href=#链路的建立 title=链路的建立></a>链路的建立</h4><p>为了安全，链路的建立需要通过基于IP地址或者号段的黑白名单安全认证机制。<p>客户端与服务端链路建立成功后，由客户端发送握手请求消息。握手请求信息定义如下：<ol><li>消息头的 type 字段值为3；<li>可选附件个数为0；<li>消息体为空；<li>握手消息的长度为22个字符；</ol><p>服务端接收到握手请求消息后，会返回握手成功应答。握手应答定义如下：<ol><li>消息头的 type 字段值为4；<li>可选附件个数为0；<li>消息体为 byte 类型的结果，“0”表示认证成功；“-1”表示认证失败；</ol><h4 id=链路的关闭><a class=headerlink href=#链路的关闭 title=链路的关闭></a>链路的关闭</h4><p>由于采用长连接通信，正常业务期间，双方通过心跳和业务消息维持链路，任何一方都无需主动关闭连接。<p>但在如下情况下，双方需要关闭连接：<ol><li>双方宕机或者重启，会主动关闭链路。由于采用TCP全双工通信，通信双方都需要关闭连接，释放资源。<li>消息读写过程中，发送了I/O异常，需要主动关闭连接。<li>心跳消息读写过程中发生了I/O异常，需要主动关闭连接。<li>心跳超时，需要主动关闭连接。<li>发生编码异常等不可恢复错误时，需要主动关闭连接。</ol><h4 id=可靠性设计><a class=headerlink href=#可靠性设计 title=可靠性设计></a>可靠性设计</h4><ol><li>心跳机制<li>重连机制<li>重复登录保护<li>消息缓存重发</ol><h4 id=安全性设计><a class=headerlink href=#安全性设计 title=安全性设计></a>安全性设计</h4><p>为了保证整个集群环境的安全，内部长连接采用基于 IP 地址的安全认证机制。服务端对握手请求消息的 IP 地址进行合法校验，如果在白名单内，则校验通过；否则，拒绝对方连接。<h4 id=可扩展性设计><a class=headerlink href=#可扩展性设计 title=可扩展性设计></a>可扩展性设计</h4><p>Netty 协议需要具备一定的扩展能力。通过Netty消息头中的可选附件 attachment 字段，业务可以方便地进行自定义扩展。<h3 id=1-5-2、Netty协议栈开发><a class=headerlink href=#1-5-2、Netty协议栈开发 title=1.5.2、Netty协议栈开发></a>1.5.2、Netty协议栈开发</h3><h4 id=数据结构定义><a class=headerlink href=#数据结构定义 title=数据结构定义></a>数据结构定义</h4><h4 id=消息编解码><a class=headerlink href=#消息编解码 title=消息编解码></a>消息编解码</h4><h4 id=握手和安全认证><a class=headerlink href=#握手和安全认证 title=握手和安全认证></a>握手和安全认证</h4><h4 id=心跳检测机制><a class=headerlink href=#心跳检测机制 title=心跳检测机制></a>心跳检测机制</h4><h4 id=断连重连><a class=headerlink href=#断连重连 title=断连重连></a>断连重连</h4><h4 id=实例><a class=headerlink href=#实例 title=实例></a>实例</h4><h2 id=1-6、ByteBuf和相关辅助类><a class=headerlink href=#1-6、ByteBuf和相关辅助类 title=1.6、ByteBuf和相关辅助类></a>1.6、ByteBuf和相关辅助类</h2><h3 id=1-6-1、ByteBuf><a class=headerlink href=#1-6-1、ByteBuf title=1.6.1、ByteBuf></a>1.6.1、ByteBuf</h3><h4 id=ByteBuf如何工作><a class=headerlink href=#ByteBuf如何工作 title=ByteBuf如何工作></a>ByteBuf如何工作</h4><p>ByteBuf 维护了两个不同的索引：一个用于读取，一个用于写入。当你从 ByteBuf 读取时，它的 readerIndex 将会被递增已经被读取的字节数。同样地，当你写入 ByteBuf 时，它的writerIndex 也会被递增。图 5-1 展示了一个空 ByteBuf 的布局结构和状态。<p><img alt=image-20201003133045657 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20201003133045657.png><p>名称以 read 或者 write 开头的 ByteBuf 方法，将会推进其对应的索引，而名称以 set 或 者 get 开头的操作则不会。后面的这些方法将在作为一个参数传入的一个相对索引上执行操作。可以指定 ByteBuf 的最大容量。试图移动写索引（即 writerIndex）超过这个值将会触发一个异常。（默认的限制是 Integer.MAX_VALUE。）<h4 id=ByteBuf使用模式><a class=headerlink href=#ByteBuf使用模式 title=ByteBuf使用模式></a>ByteBuf使用模式</h4><ol><li><p>堆缓冲区</p> <p>最常用的 ByteBuf 模式是将数据存储在 JVM 的堆空间中。这种模式被称为支撑数组（backing array），它能在没有使用池化的情况下提供快速的分配和释放。这种方式非常适合于有遗留的数据需要处理的情况。</p><li><p>直接缓冲区</p> <p>直接缓冲区是另外一种 ByteBuf 模式。我们期望用于对象创建的内存分配永远都来自于堆中，但这并不是必须的——NIO 在 JDK 1.4 中引入的 ByteBuffer 类允许 JVM 实现通过本地调用来分配内存。这主要是为了避免在每次调用本地 I/O 操作之前（或者之后）将缓冲区的内容复制到一个中间缓冲区（或者从中间缓冲区把内容复制到缓冲区）。</p> <blockquote><p>直接缓冲区的主要缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。如果你正在处理遗留代码，你也可能会遇到另外一个缺点：因为数据不是在堆上，所以你不得不进行一次复制.<p>显然，与使用支撑数组相比，这涉及的工作更多。因此，如果事先知道容器中的数据将会被作为数组来访问，你可能更愿意使用堆内存。</blockquote><li><p>复合缓冲区</p> <p>该模式为多个 ByteBuf 提供一个聚合视图。在这里你可以根据需要添加或者删除 ByteBuf 实例，这是一个 JDK 的 ByteBuffer 实现完全缺失的特性。</p> <p>Netty 通过一个 ByteBuf 子类——CompositeByteBuf——实现了这个模式，它提供了一个将多个缓冲区表示为单个合并缓冲区的虚拟表示。</p></ol><h4 id=ByteBuf工作原理><a class=headerlink href=#ByteBuf工作原理 title=ByteBuf工作原理></a>ByteBuf工作原理</h4><p>ByteBuf依然是一个Byte数组的缓冲区，它的功能和JDK中的ByteBuffer一致，其基本功能如下：<ol><li>7种Java基础类型、byte数组、ByteBuffer等的读写。<li>缓冲区自身的copy和sice等。<li>设置网络字节序。<li>构造缓冲区实例。<li>操作位置指针等方法。</ol><p>NettyBuf的实现有两种策略：<ol><li>参考JDK ByteBuffer的实现，增加额外功能，解决原ByteBuffer的缺点。<li>聚合JDK ByteBuffer，通过Facade模式对其进行包装，可以减少自身的代码量。</ol><blockquote><p>由于JDK ByteBuffer只有一个位置指针用于处理读写操作，因此每次读写时需要额外调用flip()方法和clear()方法。</blockquote><h4 id=ByteBuf功能介绍><a class=headerlink href=#ByteBuf功能介绍 title=ByteBuf功能介绍></a>ByteBuf功能介绍</h4><ul><li>顺序读操作<li>顺序写操作<li>readerIndex和writerIndex<li>Discardable bytes<li>Readable bytes 和 Writable bytes<li>Clear操作<li>Mark 和 Rset<li>查找操作<li>Derived buffers<li>转换成标准的ByteBuffer<li>随机读写</ul><h4 id=ByteBuf-API优点><a title="ByteBuf API优点" class=headerlink href=#ByteBuf-API优点></a>ByteBuf API优点</h4><ol><li>它可以被用户自定义的缓冲区类型扩展；<li>通过内置的复合缓冲区类型实现了透明的零拷贝；<li>容量可以按需增长（类似于 JDK 的 StringBuilder）；<li>在读和写这两种模式之间切换不需要调用 ByteBuffer 的 flip()方法；<li>读和写使用了不同的索引；<li>支持方法的链式调用；<li>支持引用计数；<li>支持池化；</ol><h4 id=ByteBuf相关辅助类><a class=headerlink href=#ByteBuf相关辅助类 title=ByteBuf相关辅助类></a>ByteBuf相关辅助类</h4><ol><li><p>ByteBufHolder</p> <p>ByteBufHolder是ByteBuf的容器。</p><li><p>ByteBufAllocator</p> <p>ByteBufAllocator是字节缓冲区分配器，按照Netty的缓冲区其实现有两种：</p> <ol><li>基于内存池的字节缓冲区分配器。<li>普通的字节缓冲区分配器。</ol><li><p>CompositeByteBuf</p> <p>CompositeByteBuf允许将多个ByteBuf的实例组装到一起，形成一个统一的视图。</p><li><p>ByteBufUtil</p> <p>ByteBufUtil是一个实用工具类，提供一系列方法操作ByteBuf对象。</p></ol><h3 id=1-6-2、ByteBufHolder-接口><a title="1.6.2、ByteBufHolder 接口" class=headerlink href=#1-6-2、ByteBufHolder-接口></a>1.6.2、ByteBufHolder 接口</h3><p>ByteBufHolder 为 Netty 的高级特性提供了支持，如缓冲区池化，其中可以从池中借用 ByteBuf，并且在需要时自动释放。<p>ByteBufHolder 只有几种用于访问底层数据和引用计数的方法。表 5-6 列出了它们（这里不包括它继承自 ReferenceCounted 的那些方法）。<p><img alt=image-20201003134433406 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20201003134433406.png><p>如果想要实现一个将其有效负载存储在 ByteBuf 中的消息对象，那么 ByteBufHolder 将是个不错的选择。<h3 id=1-6-3、ByteBuf分配><a class=headerlink href=#1-6-3、ByteBuf分配 title=1.6.3、ByteBuf分配></a>1.6.3、ByteBuf分配</h3><h4 id=按需分配：ByteBufAllocator-接口><a title="按需分配：ByteBufAllocator 接口" class=headerlink href=#按需分配：ByteBufAllocator-接口></a>按需分配：ByteBufAllocator 接口</h4><p>为了降低分配和释放内存的开销，Netty 通过 interface ByteBufAllocator 实现了（ByteBuf 的）池化，它可以用来分配我们所描述过的任意类型的 ByteBuf 实例。使用池化是特定于应用程序的决定，其并不会以任何方式改变 ByteBuf API（的语义）<p>可以通过 Channel（每个都可以有一个不同的 ByteBufAllocator 实例）或者绑定到ChannelHandler 的 ChannelHandlerContext 获取一个到 ByteBufAllocator 的引用。<p>Netty提供了两种ByteBufAllocator实现：<ol><li>PooledByteBufAllocator（Netty默认）：池化了ByteBuf的实例以提高性能并最大限度地减少内存碎片。此现使用了一种称为jemalloc的已被大量现代操作系统所采用的高效方法来分配内存。<li>UnpooledByteBufAllocator：后者的实现不池化ByteBuf实例，并且在每次它被调用时都会返回一个新的实例。</ol><h4 id=Unpooled-缓冲区><a title="Unpooled 缓冲区" class=headerlink href=#Unpooled-缓冲区></a>Unpooled 缓冲区</h4><p>可能某些情况下，你未能获取一个到 ByteBufAllocator 的引用。对于这种情况，Netty 提供了一个简单的称为 Unpooled 的工具类，它提供了静态的辅助方法来创建未池化的 ByteBuf实例。<p>Unpooled 类还使得 ByteBuf 同样可用于那些并不需要 Netty 的其他组件的非网络项目，使得其能得益于高性能的可扩展的缓冲区 API。<h4 id=ByteBufUtil-类><a title="ByteBufUtil 类" class=headerlink href=#ByteBufUtil-类></a>ByteBufUtil 类</h4><p>ByteBufUtil 提供了用于操作 ByteBuf 的静态的辅助方法。因为这个 API 是通用的，并且和池化无关，所以这些方法已然在分配类的外部实现。<p>该类中有两个较为实用的方法：<ol><li>hexdump()方法，它以十六进制的表示形式打印ByteBuf 的内容。<li>equals(ByteBuf, ByteBuf)方法，它被用来判断两个 ByteBuf实例的相等性。如果你实现自己的 ByteBuf 子类，你可能会发现 ByteBufUtil 的其他有用方法。</ol><h3 id=1-6-4、引用计数><a class=headerlink href=#1-6-4、引用计数 title=1.6.4、引用计数></a>1.6.4、引用计数</h3><p>引用计数是一种通过在某个对象所持有的资源不再被其他对象引用时释放该对象所持有的资源来优化内存使用和性能的技术。Netty 在第 4 版中为 ByteBuf 和 ByteBufHolder 引入了引用计数技术，它们都实现了 interface ReferenceCounted。<p>引用计数背后的想法并不是特别的复杂；它主要涉及跟踪到某个特定对象的活动引用的数量。一个 ReferenceCounted 实现的实例将通常以活动的引用计数为 1 作为开始。只要引用计数大于 0，就能保证对象不会被释放。当活动引用的数量减少到 0 时，该实例就会被释放。注意，虽然释放的确切语义可能是特定于实现的，但是至少已经释放的对象应该不可再用了。<p>引用计数对于池化实现（如 PooledByteBufAllocator）来说是至关重要的，它降低了内存分配的开销。<p>试图访问一个已经被释放的引用计数的对象，将会导致一个 IllegalReferenceCountException。<p>注意，一个特定的（ReferenceCounted 的实现）类，可以用它自己的独特方式来定义它的引用计数规则。例如，我们可以设想一个类，其 release()方法的实现总是将引用计数设为零，而不用关心它的当前值，从而一次性地使所有的活动引用都失效。<p><strong>谁负责释放：</strong>一般来说，是由最后访问（引用计数）对象的那一方来负责将它释放。在第 6 章中，我们将会解释这个概念和 ChannelHandler 以及 ChannelPipeline 的相关性。<h3 id=1-6-5、DirectByteBuffer内存释放><a class=headerlink href=#1-6-5、DirectByteBuffer内存释放 title=1.6.5、DirectByteBuffer内存释放></a>1.6.5、DirectByteBuffer内存释放</h3><p>我们已经知道，在网络编程中，为了避免频繁的在用户空间与内核空间拷贝数据，通常会直接从内核空间中申请内存，存放数据，在Java中，把内核空间的内存称之为直接内存，nio包中的<code>ByteBuffer</code>的<code>allocateDirect</code>方法，就是帮助我们申请直接内存的，代码如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> ByteBuffer <span class="title function_">allocateDirect</span><span class=params>(<span class=type>int</span> capacity)</span> {</span><br><span class=line> <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">DirectByteBuffer</span>(capacity);</span><br><span class=line>}</span><br></pre></table></figure><p>在上述代码片段中，返回的是一个<code>DirectByteBuffer</code>对象，其是ByteBuffer的子类，对于直接内存的分配，就是在这个类中实现的。<p>有经验的读者可能知道，在java中，直接内存的申请与释放是通过<code>Unsafe</code>类的<code>allocateMemory</code>方法和<code>freeMemory</code>方法来实现的，且对于直接内存的释放，必须手工调用freeMemory方法，因为JVM只能帮我们管理堆内存，直接内存不在其管理范围之内。<p>DirectByteBuffer帮我们简化了直接内存的使用，我们不需要直接操作Unsafe类来进行直接内存的申请与释放，那么其是如何实现的呢？<h4 id=直接内存申请：><a class=headerlink href=#直接内存申请： title=直接内存申请：></a>直接内存申请：</h4><p>在DirectByteBuffer实例通过构造方法创建的时候，会通过Unsafe类的allocateMemory方法 帮我们申请直接内存资源。<h4 id=直接内存释放：><a class=headerlink href=#直接内存释放： title=直接内存释放：></a>直接内存释放：</h4><p>DirectByteBuffer本身是一个Java对象，其是位于堆内存中的，JDK的GC机制可以自动帮我们回收，但是其申请的直接内存，不再GC范围之内，无法自动回收。好在JDK提供了一种机制，可以为堆内存对象注册一个钩子函数(其实就是实现Runnable接口的子类)，当堆内存对象被GC回收的时候，会回调run方法，我们可以在这个方法中执行释放DirectByteBuffer引用的直接内存，即在run方法中调用Unsafe 的freeMemory 方法。注册是通过<code>sun.misc.Cleaner</code>类来实现的。<h4 id=源码分析：><a class=headerlink href=#源码分析： title=源码分析：></a>源码分析：</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">DirectByteBuffer</span> <span class=keyword>extends</span> <span class="title class_">MappedByteBuffer</span> <span class=keyword>implements</span> <span class="title class_">DirectBuffer</span>{</span><br><span class=line> <span class=comment>//构造方法</span></span><br><span class=line> DirectByteBuffer(<span class=type>int</span> cap) { <span class=comment>// package-private</span></span><br><span class=line>     <span class=built_in>super</span>(-<span class=number>1</span>, <span class=number>0</span>, cap, cap);</span><br><span class=line>     <span class=type>boolean</span> <span class=variable>pa</span> <span class=operator>=</span> VM.isDirectMemoryPageAligned();</span><br><span class=line>     <span class=type>int</span> <span class=variable>ps</span> <span class=operator>=</span> Bits.pageSize();</span><br><span class=line>     <span class=type>long</span> <span class=variable>size</span> <span class=operator>=</span> Math.max(<span class=number>1L</span>, (<span class=type>long</span>)cap + (pa ? ps : <span class=number>0</span>));<span class=comment>//对申请的直接内存大小，进行重新计算</span></span><br><span class=line>     Bits.reserveMemory(size, cap);</span><br><span class=line></span><br><span class=line>     <span class=type>long</span> <span class=variable>base</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>     <span class=keyword>try</span> {</span><br><span class=line>     	 base = unsafe.allocateMemory(size); <span class=comment>//分配直接内存，base表示的是直接内存的开始地址</span></span><br><span class=line>     } <span class=keyword>catch</span> (OutOfMemoryError x) {</span><br><span class=line>         Bits.unreserveMemory(size, cap);</span><br><span class=line>         <span class=keyword>throw</span> x;</span><br><span class=line>     }</span><br><span class=line>     	unsafe.setMemory(base, size, (<span class=type>byte</span>) <span class=number>0</span>);</span><br><span class=line>     <span class=keyword>if</span> (pa && (base % ps != <span class=number>0</span>)) {</span><br><span class=line>     	<span class=comment>// Round up to page boundary</span></span><br><span class=line>     	address = base + ps - (base & (ps - <span class=number>1</span>));</span><br><span class=line>     } <span class=keyword>else</span> {</span><br><span class=line>     	address = base;</span><br><span class=line>     }</span><br><span class=line>     <span class=comment>//注册钩子函数，释放直接内存</span></span><br><span class=line>     cleaner = Cleaner.create(<span class=built_in>this</span>, <span class=keyword>new</span> <span class="title class_">Deallocator</span>(base, size, cap));</span><br><span class=line>     att = <span class=literal>null</span>;</span><br><span class=line> }</span><br><span class=line> <span class=comment>//....</span></span><br><span class=line>}</span><br></pre></table></figure><p>可以看到构造方法中的确是用了<code>unsafe.allocateMemory</code>方法帮我们分配了直接内存，另外，在构造方法的最后，通过 Cleaner.create方法注册了一个钩子函数，用于清除直接内存的引用。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> Cleaner <span class="title function_">create</span><span class=params>(Object var0, Runnable var1)</span> {</span><br><span class=line>	<span class=keyword>return</span> var1 == <span class=literal>null</span> ? <span class=literal>null</span> : add(<span class=keyword>new</span> <span class="title class_">Cleaner</span>(var0, var1));</span><br><span class=line>}</span><br></pre></table></figure><p>其中第一个参数是一个堆内存对象，第二个参数是一个Runnable任务，表示这个堆内存对象被回收的时候，需要执行的回调方法。我们可以看到在DirectByteBuffer的最后一行中，传入的这两个参数分别是<code>this</code>，和一个<code>Deallocator</code>(实现了Runnable接口)，其中this表示就是当前DirectByteBuffer实例，也就是当前DirectByteBuffer被回收的时候，回调<code>Deallocator</code>的run方法。<p>Deallocator就是用于清除DirectByteBuffer引用的直接内存，代码如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">Deallocator</span> <span class=keyword>implements</span> <span class="title class_">Runnable</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>Unsafe</span> <span class=variable>unsafe</span> <span class=operator>=</span> Unsafe.getUnsafe();</span><br><span class=line>    <span class=keyword>private</span> <span class=type>long</span> address;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>long</span> size;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> capacity;</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class="title function_">Deallocator</span><span class=params>(<span class=type>long</span> address, <span class=type>long</span> size, <span class=type>int</span> capacity)</span> {</span><br><span class=line>        <span class=keyword>assert</span> (address != <span class=number>0</span>);</span><br><span class=line>        <span class=built_in>this</span>.address = address;</span><br><span class=line>        <span class=built_in>this</span>.size = size;</span><br><span class=line>        <span class=built_in>this</span>.capacity = capacity;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">run</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>if</span> (address == <span class=number>0</span>) {</span><br><span class=line>            <span class=comment>// Paranoia</span></span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 调用了unsafe.freeMemory方法释放了直接内存的引用。</span></span><br><span class=line>        unsafe.freeMemory(address);</span><br><span class=line>        address = <span class=number>0</span>;</span><br><span class=line>        Bits.unreserveMemory(size, capacity);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h4 id=System-gc对直接内存释放的影响：><a class=headerlink href=#System-gc对直接内存释放的影响： title=System.gc对直接内存释放的影响：></a>System.gc对直接内存释放的影响：</h4><p>在DirectByteBuffer实例创建的时候，分配内存之前调用了<code>Bits.reserveMemory</code>方法，如果分配失败调用了<code>Bits.unreserveMemory</code>，同时在Deallocator释放完直接内存的时候，也调用了<code>Bits.unreserveMemory</code>方法。<p>这两个方法，主要是记录jdk已经使用的直接内存的数量，当分配直接内存时，需要进行增加，当释放时，需要减少，源码如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br></pre><td class=code><pre><span class=line><span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">reserveMemory</span><span class=params>(<span class=type>long</span> size, <span class=type>int</span> cap)</span> {</span><br><span class=line>     <span class=comment>//如果直接有足够多的直接内存可以用，直接增加直接内存引用的计数</span></span><br><span class=line>     <span class=keyword>synchronized</span> (Bits.class) {</span><br><span class=line>         <span class=keyword>if</span> (!memoryLimitSet && VM.isBooted()) {</span><br><span class=line>             maxMemory = VM.maxDirectMemory();</span><br><span class=line>             memoryLimitSet = <span class=literal>true</span>;</span><br><span class=line>         }</span><br><span class=line>         <span class=comment>// -XX:MaxDirectMemorySize limits the total capacity rather than the</span></span><br><span class=line>         <span class=comment>// actual memory usage, which will differ when buffers are page</span></span><br><span class=line>         <span class=comment>// aligned.</span></span><br><span class=line>         <span class=keyword>if</span> (cap <= maxMemory - totalCapacity) {<span class=comment>//维护已经使用的直接内存的数量</span></span><br><span class=line>             reservedMemory += size;</span><br><span class=line>             totalCapacity += cap;</span><br><span class=line>             count++;</span><br><span class=line>         	 <span class=keyword>return</span>;</span><br><span class=line>         }</span><br><span class=line>     }</span><br><span class=line>     <span class=comment>//如果没有有足够多的直接内存可以用，先进行垃圾回收</span></span><br><span class=line>     System.gc();</span><br><span class=line>     <span class=keyword>try</span> {</span><br><span class=line>     	Thread.sleep(<span class=number>100</span>);<span class=comment>//休眠100秒，等待垃圾回收完成</span></span><br><span class=line>     } <span class=keyword>catch</span> (InterruptedException x) {</span><br><span class=line>         <span class=comment>// Restore interrupt status</span></span><br><span class=line>         Thread.currentThread().interrupt();</span><br><span class=line>     }</span><br><span class=line>     <span class=keyword>synchronized</span> (Bits.class) {<span class=comment>//休眠100毫秒后，增加直接内存引用的计数</span></span><br><span class=line>         <span class=keyword>if</span> (totalCapacity + cap > maxMemory)</span><br><span class=line>         <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">OutOfMemoryError</span>(<span class=string>"Direct buffer memory"</span>);</span><br><span class=line>                reservedMemory += size;</span><br><span class=line>                totalCapacity += cap;</span><br><span class=line>                count++;</span><br><span class=line>     }</span><br><span class=line>}</span><br><span class=line><span class=comment>//释放内存时，减少引用直接内存的计数</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>synchronized</span> <span class=keyword>void</span> <span class="title function_">unreserveMemory</span><span class=params>(<span class=type>long</span> size, <span class=type>int</span> cap)</span> {</span><br><span class=line>    <span class=keyword>if</span> (reservedMemory > <span class=number>0</span>) {</span><br><span class=line>        reservedMemory -= size;</span><br><span class=line>        totalCapacity -= cap;</span><br><span class=line>        count--;</span><br><span class=line>        <span class=keyword>assert</span> (reservedMemory > -<span class=number>1</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>通过上面代码的分析，我们事实上可以认为<code>Bits</code>类是直接内存的分配担保，当有足够的直接内存可以用时，增加直接内存应用计数，否则，调用System.gc，进行垃圾回收，需要注意的是，<code>System.gc</code>只会回收堆内存中的对象，但是我们前面已经讲过，DirectByteBuffer对象被回收时，那么其引用的直接内存也会被回收，试想现在刚好有其他的DirectByteBuffer可以被回收，那么其被回收的直接内存就可以用于本次DirectByteBuffer直接的内存的分配。<p>有一些文章讲解在使用Nio的时候，不要禁用System.gc，也就是启动JVM的时候，不要传入<code>-XX:+DisableExplicitGC</code>参数，因为这样可能会造成直接内存溢出。道理很明显，因为直接内存的释放与获取比堆内存更加耗时，每次创建DirectByteBuffer实例分配直接内存的时候，都调用System.gc，可以让已经使用完的DirectByteBuffer得到及时的回收。<p>虽然System.gc只是建议JVM去垃圾回收，可能JVM并不会立即回收，但是频繁的建议，JVM总不会视而不见。<p>不过，这并不是绝对的，因为System.gc导致的是FullGC，可能会暂停用户线程，也就是JVM不能继续响应用户的请求，对于一些要求延时比较短的应用，是不希望JVM频繁的进行FullGC的。<p>所以建议：禁用System.gc，调大最大可以使用的直接内存。如：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-XX:+DisableExplicitGC -XX:MaxDirectMemorySize=256M</span><br></pre></table></figure><h2 id=1-7、Channel和Unsafe><a class=headerlink href=#1-7、Channel和Unsafe title=1.7、Channel和Unsafe></a>1.7、Channel和Unsafe</h2><h3 id=1-7-1、Channel><a class=headerlink href=#1-7-1、Channel title=1.7.1、Channel></a>1.7.1、Channel</h3><h4 id=工作原理><a class=headerlink href=#工作原理 title=工作原理></a>工作原理</h4><p>Channel是Netty抽象出来的网络I/O读写相关接口。<h4 id=功能介绍><a class=headerlink href=#功能介绍 title=功能介绍></a>功能介绍</h4><ol><li>网络 I/O 操作<li>其它常用API</ol><h3 id=1-7-2、Unsafe><a class=headerlink href=#1-7-2、Unsafe title=1.7.2、Unsafe></a>1.7.2、Unsafe</h3><h4 id=功能说明><a class=headerlink href=#功能说明 title=功能说明></a>功能说明</h4><p>Unsade接口实际上是Channel接口的辅助接口，它不应该被用户直接使用。实际的读写操作都是由Unsafe接口完成的。<h4 id=源码分析><a class=headerlink href=#源码分析 title=源码分析></a>源码分析</h4><p>实际的网络 I/O 操作基本都是由 Unsafe 功能类负责实现的。<h2 id=1-8、ChannelHandler和ChannelPipeline><a class=headerlink href=#1-8、ChannelHandler和ChannelPipeline title=1.8、ChannelHandler和ChannelPipeline></a>1.8、ChannelHandler和ChannelPipeline</h2><p>ChannelPipeline 和 ChannelHandler 机制类似于 Servlet 和 Filter 过滤器，这种拦截器实际上是职责链模式的一种变形。<h3 id=1-8-1、ChannelHandler><a class=headerlink href=#1-8-1、ChannelHandler title=1.8.1、ChannelHandler></a>1.8.1、ChannelHandler</h3><p>Netty 的主要组件是 ChannelHandler，它充当了所有处理入站和出站数据的应用程序逻辑的容器。因为 ChannelHandler 的方法是由网络事件触发的。<p>ChannelHandler类似于Servlet的Filter过滤器，负责对I/O事件或I/O操作进行拦截和处理，它可以选择性的拦截和处理自己感兴趣的事件，也可以透传和终止事件的传递。<h4 id=Channel生命周期><a class=headerlink href=#Channel生命周期 title=Channel生命周期></a>Channel生命周期</h4><p>Channel 的正常生命周期如图 6-1 所示。当这些状态发生改变时，将会生成对应的事件。这些事件将会被转发给 ChannelPipeline 中的 ChannelHandler，其可以随后对它们做出响应。<p><img alt=image-20201003165119330 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20201003165119330.png><h4 id=ChannelHandler生命周期><a class=headerlink href=#ChannelHandler生命周期 title=ChannelHandler生命周期></a>ChannelHandler生命周期</h4><p>表 6-2 中列出了 interface ChannelHandler 定义的生命周期操作，在 ChannelHandler被添加到 ChannelPipeline 中或者被从 ChannelPipeline 中移除时会调用这些操作。这些方法中的每一个都接受一个 ChannelHandlerContext 参数。<p><img alt=image-20201003165259567 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20201003165259567.png><p>Netty 定义了下面两个重要的 ChannelHandler 子接口：<ol><li>ChannelInboundHandler——处理入站数据以及各种状态变化；<li>ChannelOutboundHandler——处理出站数据并且允许拦截所有的操作。</ol><h4 id=ChannelInboundHandler-接口><a title="ChannelInboundHandler 接口" class=headerlink href=#ChannelInboundHandler-接口></a>ChannelInboundHandler 接口</h4><p>当某个 ChannelInboundHandler 的实现重写 channelRead()方法时，它将负责显式地释放与池化的 ByteBuf 实例相关的内存。Netty 为此提供了一个实用方法 ReferenceCountUtil.release()。<p>由于 SimpleChannelInboundHandler 会自动释放资源，所以你不应该存储指向任何消息的引用供将来使用，因为这些引用都将会失效。<h4 id=ChannelOutboundHandler-接口><a title="ChannelOutboundHandler 接口" class=headerlink href=#ChannelOutboundHandler-接口></a>ChannelOutboundHandler 接口</h4><p>出站操作和数据将由 ChannelOutboundHandler 处理。它的方法将被 Channel、ChannelPipeline 以及 ChannelHandlerContext 调用。<p>ChannelOutboundHandler 的一个强大的功能是可以按需推迟操作或者事件，这使得可以通过一些复杂的方法来处理请求。例如，如果到远程节点的写入被暂停了，那么你可以推迟冲 刷操作并在稍后继续。<h4 id=ChannelHandler-适配器><a title="ChannelHandler 适配器" class=headerlink href=#ChannelHandler-适配器></a>ChannelHandler 适配器</h4><p>你可以使用 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter类作为自己的 ChannelHandler 的起始点。这两个适配器分别提供了 ChannelInboundHandler 和 ChannelOutboundHandler 的基本实现。通过扩展抽象类 ChannelHandlerAdapter，它们获得了它们共同的超接口 ChannelHandler 的方法。<p>ChannelHandlerAdapter 还提供了实用方法 isSharable()。如果其对应的实现被标注为 Sharable，那么这个方法将返回 true，表示它可以被添加到多个 ChannelPipeline中<p>在 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter 中所提供的方法体调用了其相关联的 ChannelHandlerContext 上的等效方法，从而将事件转发到了 ChannelPipeline 中的下一个 ChannelHandler 中。<h4 id=资源管理><a class=headerlink href=#资源管理 title=资源管理></a>资源管理</h4><p>每当通过调用 ChannelInboundHandler.channelRead()或者 ChannelOutboundHandler.write()方法来处理数据时，你都需要确保没有任何的资源泄漏。<p>为了帮助你诊断潜在的（资源泄漏）问题，Netty提供了class ResourceLeakDetector，它将对你应用程序的缓冲区分配做大约 1%的采样来检测内存泄露。相关的开销是非常小的。<p>如果检测到了内存泄露，将会产生类似于下面的日志消息：<figure class="highlight verilog"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>LEAK: ByteBuf<span class=variable>.release</span>() was <span class=keyword>not</span> called <span class=keyword>before</span> it's garbage-collected. Enable</span><br><span class=line>advanced leak reporting to find out where the leak occurred. To enable</span><br><span class=line>advanced leak reporting, <span class=keyword>specify</span> the JVM option</span><br><span class=line>'-Dio<span class=variable>.netty</span><span class=variable>.leakDetectionLevel</span>=ADVANCED' <span class=keyword>or</span> call</span><br><span class=line>ResourceLeakDetector<span class=variable>.setLevel</span>().</span><br></pre></table></figure><p>Netty 目前定义了 4 种泄漏检测级别，如表 6-5 所示：<p><img alt=image-20201003170533335 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20201003170533335.png><p>泄露检测级别可以通过将下面的 Java 系统属性设置为表中的一个值来定义：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -Dio.netty.leakDetectionLevel=ADVANCED</span><br></pre></table></figure><p>在出站方向这边，如果你处理了 write()操作并丢弃了一个消息，那么你也应该负责释放它。重要的是，不仅要释放资源，还要通知 ChannelPromise。否则可能会出现 ChannelFutureListener 收不到某个消息已经被处理了的通知的情况。<h3 id=1-8-2、ChannelPipeline><a class=headerlink href=#1-8-2、ChannelPipeline title=1.8.2、ChannelPipeline></a>1.8.2、ChannelPipeline</h3><p>ChannelPipeline 提供了 ChannelHandler 链的容器，并定义了用于在该链上传播入站和出站事件流的 API。当 Channel 被创建时，它会被自动地分配到它专属的 ChannelPipeline。<p>ChannelHandler 安装到 ChannelPipeline 中的过程如下：<ol><li>一个ChannelInitializer的实现被注册到了ServerBootstrap中；<li>当 ChannelInitializer.initChannel()方法被调用时，ChannelInitializer将在ChannelPipeline中安装一组自定义的 ChannelHandler；<li>ChannelInitializer 将它自己从 ChannelPipeline 中移除。</ol><p>一个 Netty 应用程序中入站和出站数据流之间的区别：从一个客户端应用程序的角度来看，如果事件的运动方向是从客户端到服务器端，那么我们称这些事件为出站的，反之则称为入站的。<p><img alt=image-20201003111119360 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20201003111119360.png><p>鉴于出站操作和入站操作是不同的，你可能会想知道如果将两个类别的 ChannelHandler都混合添加到同一个 ChannelPipeline 中会发生什么。虽然 ChannelInboundHandle 和ChannelOutboundHandle 都扩展自ChannelHandler，但是 Netty 能区分 ChannelInboundHandler 实现和 ChannelOutboundHandler 实现，并确保数据只会在具有相同定向类型的两个 ChannelHandler 之间传递。<p>当ChannelHandler 被添加到ChannelPipeline 时，它将会被分配一个ChannelHandlerContext，其代表了 ChannelHandler 和 ChannelPipeline 之间的绑定。虽然这个对象可以被用于获取底层的 Channel，但是它主要还是被用于写出站数据。<p>在 Netty 中，有两种发送消息的方式：<ol><li>直接写到 Channel 中，该方式将会导致消息从ChannelPipeline 的尾端开始流动。<li>写到和 ChannelHandler相关联的ChannelHandlerContext对象中，该方式会导致消息从 ChannelPipeline 中的下一个 ChannelHander开始流动。</ol><p>在 ChannelPipeline 传播事件时，它会测试 ChannelPipeline 中的下一个 ChannelHandler 的类型是否和事件的运动方向相匹配。如果不匹配，ChannelPipeline 将跳过该ChannelHandler 并前进到下一个，直到它找到和该事件所期望的方向相匹配的为止。<h4 id=修改ChannelPipeline><a class=headerlink href=#修改ChannelPipeline title=修改ChannelPipeline></a>修改ChannelPipeline</h4><p>ChannelHandler 可以通过添加、删除或者替换其他的 ChannelHandler 来实时地修改ChannelPipeline 的布局。<blockquote><p>通常 ChannelPipeline 中的每一个 ChannelHandler 都是通过它的 EventLoop（I/O 线程）来处理传递给它的事件的。所以至关重要的是不要阻塞这个线程，因为这会对整体的 I/O 处理产生负面的影响。<p>但有时可能需要与那些使用阻塞 API 的遗留代码进行交互。对于这种情况，ChannelPipeline 有一些接受一个 EventExecutorGroup 的 add()方法。如果一个事件被传递给一个自定义的 EventExecutorGroup，它将被包含在这个 EventExecutorGroup 中的某个 EventExecutor 所处理，从而被从该Channel 本身的 EventLoop 中移除。对于这种用例，Netty 提供了一个叫 DefaultEventExecutorGroup 的默认实现。</blockquote><h3 id=1-8-3、ChannelHandlerContext-接口><a title="1.8.3、ChannelHandlerContext 接口" class=headerlink href=#1-8-3、ChannelHandlerContext-接口></a>1.8.3、ChannelHandlerContext 接口</h3><p>ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关联，每当有 ChannelHandler 添加到 ChannelPipeline 中时，都会创建 ChannelHandlerContext。ChannelHandlerContext 的主要功能是管理它所关联的 ChannelHandler 和在同一个 ChannelPipeline 中的其他 ChannelHandler 之间的交互。<p>当使用 ChannelHandlerContext 的 API 的时候，请牢记以下两点：<ol><li>ChannelHandlerContext 和 ChannelHandler 之间的关联（绑定）是永远不会改变的，所以缓存对它的引用是安全的；<li>如同我们在本节开头所解释的一样，相对于其他类的同名方法，ChannelHandler Context的方法将产生更短的事件流，应该尽可能地利用这个特性来获得最大的性能。</ol><h4 id=使用-ChannelHandlerContext><a title="使用 ChannelHandlerContext" class=headerlink href=#使用-ChannelHandlerContext></a>使用 ChannelHandlerContext</h4><p>ChannelHandlerContext、Channel 和 ChannelPipeline之间的关系如下图所示：<p><img alt=image-20201003181432006 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20201003181432006.png><p>通过 Channel 或者 ChannelPipeline 进行的事件传播：<p><img alt=image-20201003181705767 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20201003181705767.png><p>为什么会想要从 ChannelPipeline 中的某个特定点开始传播事件呢？<ol><li>为了减少将事件传经对它不感兴趣的 ChannelHandler 所带来的开销。<li>为了避免将事件传经那些可能会对它感兴趣的 ChannelHandler。</ol><p>要想调用从某个特定的 ChannelHandler 开始的处理过程，必须获取到在（ChannelPipeline）该 ChannelHandler 之前的 ChannelHandler 所关联的 ChannelHandlerContext。这个 ChannelHandlerContext 将调用和它所关联的 ChannelHandler 之后的 ChannelHandler。<h3 id=1-8-4、编解码器><a class=headerlink href=#1-8-4、编解码器 title=1.8.4、编解码器></a>1.8.4、编解码器</h3><p>当你通过 Netty 发送或者接收一个消息的时候，就将会发生一次数据转换。入站消息会被解码；也就是说，从字节转换为另一种格式，通常是一个 Java 对象。如果是出站消息，则会发生相反方向的转换：它将从它的当前格式被编码为字节。这两种方向的转换的原因很简单：网络数据总是一系列的字节。<p>对应于特定的需要，Netty 为编码器和解码器提供了不同类型的抽象类。所有由 Netty 提供的编码器/解码器适配器类都实现了 ChannelOutboundHandler 或者 ChannelInboundHandler 接口。<p>对于入站数据来说，channelRead 方法/事件已经被重写了。对于每个从入站Channel 读取的消息，这个方法都将会被调用。随后，它将调用由预置解码器所提供的 decode()方法，并将已解码的字节转发给 ChannelPipeline 中的下一个 ChannelInboundHandler。出站消息的模式是相反方向的：编码器将消息转换为字节，并将它们转发给下一个ChannelOutboundHandler。<h3 id=1-8-5、抽象类-SimpleChannelInboundHandler><a title="1.8.5、抽象类 SimpleChannelInboundHandler" class=headerlink href=#1-8-5、抽象类-SimpleChannelInboundHandler></a>1.8.5、抽象类 SimpleChannelInboundHandler</h3><p>最常见的情况是，你的应用程序会利用一个 ChannelHandler 来接收解码消息，并对该数据应用业务逻辑。要创建一个这样的 ChannelHandler，你只需要扩展基类 SimpleChannelInboundHandler<t>，其中 T 是你要处理的消息的 Java 类型 。 <p>在这种类型的 ChannelHandler 中，最重要的方法是 channelRead0(ChannelHandlerContext,T)。除了要求不要阻塞当前的 I/O 线程之外，其具体实现完全取决于你。</p> <h3 id=1-8-6、异常处理><a class=headerlink href=#1-8-6、异常处理 title=1.8.6、异常处理></a>1.8.6、异常处理</h3><p>异常处理是任何真实应用程序的重要组成部分，它也可以通过多种方式来实现。</p> <h4 id=处理入站异常><a class=headerlink href=#处理入站异常 title=处理入站异常></a>处理入站异常</h4><p>如果在处理入站事件的过程中有异常被抛出，那么它将从它在 ChannelInboundHandler里被触发的那一点开始流经 ChannelPipeline。要想处理这种类型的入站异常，你需要在你的 ChannelInboundHandler 实现中重写下面的方法。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">exceptionCaught</span><span class=params>(ChannelHandlerContext ctx, Throwable cause)</span> <span class=keyword>throws</span> Exception</span><br></pre></table></figure> <p>因为异常将会继续按照入站方向流动（就像所有的入站事件一样），所以实现了前面所示逻辑的 ChannelInboundHandler 通常位于 ChannelPipeline 的最后。这确保了所有的入站异常都总是会被处理，无论它们可能会发生在 ChannelPipeline 中的什么位置。</p> <p>总结一下：</p> <ol><li>ChannelHandler.exceptionCaught()的默认实现是简单地将当前异常转发给ChannelPipeline 中的下一个 ChannelHandler；<li>如果异常到达了 ChannelPipeline 的尾端，它将会被记录为未被处理；<li>要想定义自定义的处理逻辑，你需要重写 exceptionCaught()方法。然后你需要决定是否需要将该异常传播出去。</ol> <h4 id=处理出站异常><a class=headerlink href=#处理出站异常 title=处理出站异常></a>处理出站异常</h4><p>用于处理出站操作中的正常完成以及异常的选项，都基于以下的通知机制。</p> <ol><li><p>每个出站操作都将返回一个 ChannelFuture。注册到 ChannelFuture 的 ChannelFutureListener 将在操作完成时被通知该操作是成功了还是出错了。</p><li><p>几乎所有的 ChannelOutboundHandler 上的方法都会传入一个 ChannelPromise的实例。作为 ChannelFuture 的子类，ChannelPromise 也可以被分配用于异步通知的监听器。但是，ChannelPromise 还具有提供立即通知的可写方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>ChannelPromise <span class="title function_">setSuccess</span><span class=params>()</span>;</span><br><span class=line>ChannelPromise <span class="title function_">setFailure</span><span class=params>(Throwable cause)</span>;</span><br></pre></table></figure></ol> <p>添加 ChannelFutureListener 有两种方式：</p> <ol><li><p>调用出站操作（如 write()方法）所返回的 ChannelFuture 上的 addListener()方法。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=type>ChannelFuture</span> <span class=variable>future</span> <span class=operator>=</span> channel.write(someMessage);</span><br><span class=line>future.addListener(<span class=keyword>new</span> <span class="title class_">ChannelFutureListener</span>() {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">operationComplete</span><span class=params>(ChannelFuture f)</span> {</span><br><span class=line>        <span class=keyword>if</span> (!f.isSuccess()) {</span><br><span class=line>            f.cause().printStackTrace();</span><br><span class=line>            f.channel().close();</span><br><span class=line>        } </span><br><span class=line>    }</span><br><span class=line>});</span><br></pre></table></figure><li><p>将 ChannelFutureListener 添加到即将作为参数传递给 ChannelOutboundHandler 的方法的 ChannelPromise。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">OutboundExceptionHandler</span> <span class=keyword>extends</span> <span class="title class_">ChannelOutboundHandlerAdapter</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">write</span><span class=params>(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> {</span><br><span class=line>        promise.addListener(<span class=keyword>new</span> <span class="title class_">ChannelFutureListener</span>() {</span><br><span class=line>            <span class=meta>@Override</span></span><br><span class=line>            <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">operationComplete</span><span class=params>(ChannelFuture f)</span> {</span><br><span class=line>                <span class=keyword>if</span> (!f.isSuccess()) {</span><br><span class=line>                    f.cause().printStackTrace();</span><br><span class=line>                    f.channel().close();</span><br><span class=line>                } </span><br><span class=line>            }</span><br><span class=line>        });</span><br><span class=line>    } </span><br><span class=line>}</span><br></pre></table></figure> <blockquote><p>ChannelPromise 的可写方法：通过调用 ChannelPromise 上的 setSuccess()和 setFailure()方法，可以使一个操作的状态在 ChannelHandler 的方法返回给其调用者时便即刻被感知到。</blockquote></ol> <h2 id=1-9、EventLoop和EventLoopGroup><a class=headerlink href=#1-9、EventLoop和EventLoopGroup title=1.9、EventLoop和EventLoopGroup></a>1.9、EventLoop和EventLoopGroup</h2><h3 id=1-9-1、EventLoop-接口><a title="1.9.1、EventLoop 接口" class=headerlink href=#1-9-1、EventLoop-接口></a>1.9.1、EventLoop 接口</h3><p>Netty 的 EventLoop 是协同设计的一部分，它采用了两个基本的 API：并发和网络编程。首先，io.netty.util.concurrent 包构建在 JDK 的 java.util.concurrent 包上，用来提供线程执行器。其次，io.netty.channel 包中的类，为了与 Channel 的事件进行交互，扩展了这些接口/类。</p> <p>在这个模型中，一个 EventLoop 将由一个永远都不会改变的 Thread 驱动，同时任务（Runnable 或者 Callable）可以直接提交给 EventLoop 实现，以立即执行或者调度执行。根据配置和可用核心的不同，可能会创建多个 EventLoop 实例用以优化资源的使用，并且单个EventLoop 可能会被指派用于服务多个 Channel。</p> <blockquote><p><strong>事件/任务的执行顺序：</strong>事件和任务是以先进先出（FIFO）的顺序执行的。这样可以通过保证字节内容总是按正确的顺序被处理，消除潜在的数据损坏的可能性。</blockquote> <h3 id=1-9-2、任务调度><a class=headerlink href=#1-9-2、任务调度 title=1.9.2、任务调度></a>1.9.2、任务调度</h3><h4 id=JDK-的任务调度-API><a title="JDK 的任务调度 API" class=headerlink href=#JDK-的任务调度-API></a>JDK 的任务调度 API</h4><p>在 Java 5 之前，任务调度是建立在 java.util.Timer 类之上的，其使用了一个后台 Thread，并且具有与标准线程相同的限制。随后，JDK 提供了 java.util.concurrent 包，它定义了interface ScheduledExecutorService。</p> <p>虽然 ScheduledExecutorService API 是直截了当的，但是在高负载下它将带来性能上的负担。</p> <h4 id=使用-EventLoop-调度任务><a title="使用 EventLoop 调度任务" class=headerlink href=#使用-EventLoop-调度任务></a>使用 EventLoop 调度任务</h4><p>ScheduledExecutorService 的实现具有局限性，例如，事实上作为线程池管理的一部分，将会有额外的线程创建。如果有大量任务被紧凑地调度，那么这将成为一个瓶颈。Netty 通过 Channel 的 EventLoop 实现任务调度解决了这一问题，</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>Channel</span> <span class=variable>ch</span> <span class=operator>=</span> ...</span><br><span class=line>ScheduledFuture&LT?> future = ch.eventLoop().schedule(<span class=keyword>new</span> <span class="title class_">Runnable</span>() {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">run</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"60 seconds later"</span>);</span><br><span class=line>    }</span><br><span class=line>}, <span class=number>60</span>, TimeUnit.SECONDS);</span><br></pre></table></figure> <p>要想取消或者检查（被调度任务的）执行状态，可以使用每个异步操作所返回的 ScheduledFuture。</p> <h3 id=1-9-3、实现细节><a class=headerlink href=#1-9-3、实现细节 title=1.9.3、实现细节></a>1.9.3、实现细节</h3><h4 id=线程管理><a class=headerlink href=#线程管理 title=线程管理></a>线程管理</h4><p>Netty线程模型的卓越性能取决于对于当前执行的Thread的身份的确定，也就是说，确定它是否是分配给当前Channel以及它的EventLoop的那一个线程。</p> <p>如果（当前）调用线程正是支撑 EventLoop 的线程，那么所提交的代码块将会被（直接）执行。否则，EventLoop 将调度该任务以便稍后执行，并将它放入到内部队列中。当 EventLoop下次处理它的事件时，它会执行队列中的那些任务/事件。这也就解释了任何的 Thread 是如何与 Channel 直接交互而无需在 ChannelHandler 中进行额外同步的。</p> <p>注意，每个 EventLoop 都有它自已的任务队列，独立于任何其他的 EventLoop。</p> <h4 id=EventLoop-线程的分配><a class=headerlink href=#EventLoop-线程的分配 title=EventLoop/线程的分配></a>EventLoop/线程的分配</h4><p>服务于 Channel 的 I/O 和事件的 EventLoop 包含在 EventLoopGroup 中。根据不同的传输实现，EventLoop 的创建和分配方式也不同。</p> <ol><li><p>异步传输</p> <p>异步传输实现只使用了少量的 EventLoop（以及和它们相关联的 Thread），而且在当前的线程模型中，它们可能会被多个 Channel 所共享。这使得可以通过尽可能少量的 Thread 来支撑大量的 Channel，而不是每个 Channel 分配一个 Thread。</p><li><p>阻塞传输</p> <p>每一个 Channel 都将被分配给一个 EventLoop（以及它的 Thread）。得到的保证是每个 Channel 的 I/O 事件都将只会被一个 Thread（用于支撑该 Channel 的 EventLoop 的那个 Thread）处理。这也是另一个 Netty 设计一致性的例子，它（这种设计上的一致性）对 Netty 的可靠性和易用性做出了巨大贡献。</p></ol> <h3 id=1-9-4、Netty线程模型><a class=headerlink href=#1-9-4、Netty线程模型 title=1.9.4、Netty线程模型></a>1.9.4、Netty线程模型</h3><h4 id=Reactor单线程模型><a class=headerlink href=#Reactor单线程模型 title=Reactor单线程模型></a>Reactor单线程模型</h4><p><img alt=image-20200926143305077 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20200926143305077.png></p> <h4 id=Reactor多线程模型><a class=headerlink href=#Reactor多线程模型 title=Reactor多线程模型></a>Reactor多线程模型</h4><p><img alt=image-20200926143349772 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20200926143349772.png></p> <h4 id=主从Reactor多线程模型><a class=headerlink href=#主从Reactor多线程模型 title=主从Reactor多线程模型></a>主从Reactor多线程模型</h4><p><img alt=image-20200926143448810 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20200926143448810.png></p> <h4 id=Netty线程模型><a class=headerlink href=#Netty线程模型 title=Netty线程模型></a>Netty线程模型</h4><p>Netty的线程模型并发一成不变，它实际取决于用户的启动参数配置。通过配置，Netty可以同时支持Reactor单线程模型、Reactor多线程模型、主从Reactor多线程模型。</p> <p><img alt=image-20200925151324727 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20200925151324727.png></p> <h3 id=1-9-5、NioEventLoop><a class=headerlink href=#1-9-5、NioEventLoop title=1.9.5、NioEventLoop></a>1.9.5、NioEventLoop</h3><h4 id=设计原理><a class=headerlink href=#设计原理 title=设计原理></a>设计原理</h4><p>NioEventLoop并非一个纯粹的I/O线程，它除了负责I/O读写外，还兼顾处理如下两类任务：</p> <ol><li>系统Task。<li>定时任务。</ol> <h2 id=1-10、Future和Promise><a class=headerlink href=#1-10、Future和Promise title=1.10、Future和Promise></a>1.10、Future和Promise</h2><h3 id=1-10-1、Future功能><a class=headerlink href=#1-10-1、Future功能 title=1.10.1、Future功能></a>1.10.1、Future功能</h3><p>Future最早来源于JDK的<code>java.util.concurrent.Future</code>，它代表异步操作的结果。</p> <p>Netty中的Future都是与异步I/O操作相关，因此，将其命名为ChannelFuture，代表与channel操作相关。</p> <h3 id=1-10-2、Promise功能><a class=headerlink href=#1-10-2、Promise功能 title=1.10.2、Promise功能></a>1.10.2、Promise功能</h3><p>Promise是可写的Future，Future本身并没有写操作相关的接口，Netty通过Promise对Future进行扩展，用于设置I/O操作的结果。</p> <h2 id=1-11、引导><a class=headerlink href=#1-11、引导 title=1.11、引导></a>1.11、引导</h2><h3 id=1-11-1、引导分类><a class=headerlink href=#1-11-1、引导分类 title=1.11.1、引导分类></a>1.11.1、引导分类</h3><p>有两种类型的引导：</p> <ol><li>一种用于客户端（简单地称为 Bootstrap）；<li>而另一种（ServerBootstrap）用于服务器；</ol> <p>无论你的应用程序使用哪种协议或者处理哪种类型的数据，唯一决定它使用哪种引导类的是它是作为一个客户端还是作为一个服务器。</p> <p><img alt=image-20201003121533517 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20201003121533517.png></p> <p>引导一个客户端只需要一个 EventLoopGroup，但是一个ServerBootstrap 则需要两个（也可以是同一个实例）。为什么呢？</p> <p>因为服务器需要两组不同的 Channel。第一组将只包含一个 ServerChannel，代表服务器自身的已绑定到某个本地端口的正在监听的套接字。而第二组将包含所有已创建的用来处理传入客户端连接（对于每个服务器已经接受的连接都有一个）的 Channel。图 3-4 说明了这个模型，并且展示了为何需要两个不同的 EventLoopGroup。</p> <p><img alt=image-20201003122021907 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20201003122021907.png></p> <p>与 ServerChannel 相关联的 EventLoopGroup 将分配一个负责为传入连接请求创建Channel 的 EventLoop。一旦连接被接受，第二个 EventLoopGroup 就会给它的 Channel分配一个 EventLoop。</p> <h3 id=1-11-2、从-Channel-引导客户端><a title="1.11.2、从 Channel 引导客户端" class=headerlink href=#1-11-2、从-Channel-引导客户端></a>1.11.2、从 Channel 引导客户端</h3><p>假设你的服务器正在处理一个客户端的请求，这个请求需要它充当第三方系统的客户端。当一个应用程序（如一个代理服务器）必须要和组织现有的系统（如 Web 服务或者数据库）集成时，就可能发生这种情况。在这种情况下，将需要从已经被接受的子 Channel 中引导一个客户端 Channel。</p> <p>一个更好的解决方案是：通过将已被接受的子 Channel 的 EventLoop 传递给 Bootstrap的 group()方法来共享该 EventLoop。因为分配给 EventLoop 的所有 Channel 都使用同一个线程，所以这避免了额外的线程创建，以及前面所提到的相关的上下文切换。这个共享的解决方案如图 8-4 所示。</p> <p><img alt=image-20201004110224106 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20201004110224106.png></p> <h3 id=1-11-3、在引导过程中添加多个-ChannelHandler><a title="1.11.3、在引导过程中添加多个 ChannelHandler" class=headerlink href=#1-11-3、在引导过程中添加多个-ChannelHandler></a>1.11.3、在引导过程中添加多个 ChannelHandler</h3><p>Netty 提供了一个特殊的 ChannelInboundHandlerAdapter 子类：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">ChannelInitializer</span>&LTC <span class=keyword>extends</span> <span class="title class_">Channel</span>> <span class=keyword>extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span></span><br></pre></table></figure> <p>它定义了下面的方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>protected</span> <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">initChannel</span><span class=params>(C ch)</span> <span class=keyword>throws</span> Exception;</span><br></pre></table></figure> <p>这个方法提供了一种将多个 ChannelHandler 添加到一个 ChannelPipeline 中的简便方法。你只需要简单地向 Bootstrap 或 ServerBootstrap 的实例提供你的 ChannelInitializer 实现即可，并且一旦 Channel 被注册到了它的 EventLoop 之后，就会调用你的initChannel()版本。在该方法返回之后，ChannelInitializer 的实例将会从 ChannelPipeline 中移除它自己。</p> <h3 id=1-11-4、使用-Netty-的-ChannelOption-和属性><a title="1.11.4、使用 Netty 的 ChannelOption 和属性" class=headerlink href=#1-11-4、使用-Netty-的-ChannelOption-和属性></a>1.11.4、使用 Netty 的 ChannelOption 和属性</h3><p>在每个 Channel 创建时都手动配置它可能会变得相当乏味。幸运的是，你不必这样做。相反，你可以使用 option()方法来将 ChannelOption 应用到引导。你所提供的值将会被自动应用到引导所创建的所有 Channel。可用的 ChannelOption 包括了底层连接的详细信息，如keep-alive 或者超时属性以及缓冲区设置。</p> <h3 id=1-11-5、引导-DatagramChannel><a title="1.11.5、引导 DatagramChannel" class=headerlink href=#1-11-5、引导-DatagramChannel></a>1.11.5、引导 DatagramChannel</h3><p>引导使用不仅可以基于 TCP 协议的 SocketChannel，也可以被用于无连接的协议。为此，Netty 提供了各种 DatagramChannel 的实现。唯一区别就是，不再调用 connect()方法，而是只调用 bind()方法，</p> <h3 id=1-11-6、关闭><a class=headerlink href=#1-11-6、关闭 title=1.11.6、关闭></a>1.11.6、关闭</h3><p>引导使你的应用程序启动并且运行起来，但是迟早你都需要优雅地将它关闭。最重要的是，你需要关闭 EventLoopGroup，它将处理任何挂起的事件和任务，并且随后释放所有活动的线程。这就是调用 EventLoopGroup.shutdownGracefully()方法的作用。这个方法调用将会返回一个 Future，这个 Future 将在关闭完成时接收到通知。需要注意的是，shutdownGracefully()方法也是一个异步的操作，所以你需要阻塞等待直到它完成，或者向所返回的 Future 注册一个监听器以在关闭完成时获得通知。</p> <h1 id=2、Netty架构剖析><a class=headerlink href=#2、Netty架构剖析 title=2、Netty架构剖析></a>2、Netty架构剖析</h1><h2 id=2-1、Netty逻辑架构><a class=headerlink href=#2-1、Netty逻辑架构 title=2.1、Netty逻辑架构></a>2.1、Netty逻辑架构</h2><p>Netty采用三层网络架构进行设计和开发，逻辑架构如图：</p> <p><img alt=image-20200925153422674 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20200925153422674.png></p> <h3 id=2-1-1、Reactor通信调度层><a class=headerlink href=#2-1-1、Reactor通信调度层 title=2.1.1、Reactor通信调度层></a>2.1.1、Reactor通信调度层</h3><h3 id=2-1-2、职责链ChannelPipeline><a class=headerlink href=#2-1-2、职责链ChannelPipeline title=2.1.2、职责链ChannelPipeline></a>2.1.2、职责链ChannelPipeline</h3><h3 id=2-1-3、业务逻辑编排层（Service-ChannelHandler）><a title="2.1.3、业务逻辑编排层（Service ChannelHandler）" class=headerlink href=#2-1-3、业务逻辑编排层（Service-ChannelHandler）></a>2.1.3、业务逻辑编排层（Service ChannelHandler）</h3><h2 id=2-2、关键架构质量属性><a class=headerlink href=#2-2、关键架构质量属性 title=2.2、关键架构质量属性></a>2.2、关键架构质量属性</h2><h3 id=2-2-1、高性能><a class=headerlink href=#2-2-1、高性能 title=2.2.1、高性能></a>2.2.1、高性能</h3><p><img alt=image-20200925153953385 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20200925153953385.png></p> <h3 id=2-2-2、可靠性><a class=headerlink href=#2-2-2、可靠性 title=2.2.2、可靠性></a>2.2.2、可靠性</h3><ol><li>链路有效性检测<li>内存保护机制<li>优雅停机</ol> <h3 id=2-2-3、可定制性><a class=headerlink href=#2-2-3、可定制性 title=2.2.3、可定制性></a>2.2.3、可定制性</h3><p><img alt=image-20230805105116323 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20230805105116323.png></p> <h3 id=2-2-4、可扩展性><a class=headerlink href=#2-2-4、可扩展性 title=2.2.4、可扩展性></a>2.2.4、可扩展性</h3><p><img alt=image-20200925154324225 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20200925154324225.png></p> <h1 id=3、Java多线程在Netty中的应用><a class=headerlink href=#3、Java多线程在Netty中的应用 title=3、Java多线程在Netty中的应用></a>3、Java多线程在Netty中的应用</h1><h2 id=3-1、Netty并发编程实践><a class=headerlink href=#3-1、Netty并发编程实践 title=3.1、Netty并发编程实践></a>3.1、Netty并发编程实践</h2><h3 id=3-1-1、对共享可变数据进行正确同步><a class=headerlink href=#3-1-1、对共享可变数据进行正确同步 title=3.1.1、对共享可变数据进行正确同步></a>3.1.1、对共享可变数据进行正确同步</h3><p><img alt=image-20200925154944535 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20200925154944535.png></p> <h3 id=3-1-2、正确使用锁><a class=headerlink href=#3-1-2、正确使用锁 title=3.1.2、正确使用锁></a>3.1.2、正确使用锁</h3><p>参考ForkJoinTask源码。</p> <h3 id=3-1-3、正确使用volatile><a class=headerlink href=#3-1-3、正确使用volatile title=3.1.3、正确使用volatile></a>3.1.3、正确使用volatile</h3><p>参考NioEventLoop源码。</p> <h3 id=3-1-4、CAS指令和原子类><a class=headerlink href=#3-1-4、CAS指令和原子类 title=3.1.4、CAS指令和原子类></a>3.1.4、CAS指令和原子类</h3><p>参考ChannelOutboundBuffer源码，分析如何对发送的总字节数进行计数和更新操作。</p> <h3 id=3-1-5、线程安全类的应用><a class=headerlink href=#3-1-5、线程安全类的应用 title=3.1.5、线程安全类的应用></a>3.1.5、线程安全类的应用</h3><p>参考NioEventLoop源码。</p> <h3 id=3-1-6、读写锁的应用><a class=headerlink href=#3-1-6、读写锁的应用 title=3.1.6、读写锁的应用></a>3.1.6、读写锁的应用</h3><p>参考HashedWheelTimer源码。</p> <h1 id=4、Netty高性能之道><a class=headerlink href=#4、Netty高性能之道 title=4、Netty高性能之道></a>4、Netty高性能之道</h1><h2 id=4-1、RPC调用性能模型分析><a class=headerlink href=#4-1、RPC调用性能模型分析 title=4.1、RPC调用性能模型分析></a>4.1、RPC调用性能模型分析</h2><h3 id=4-1-1、传统RPC调用性能差的三宗罪><a class=headerlink href=#4-1-1、传统RPC调用性能差的三宗罪 title=4.1.1、传统RPC调用性能差的三宗罪></a>4.1.1、传统RPC调用性能差的三宗罪</h3><ol><li><p>网络传输方式</p> <p>传统RPC基于同步阻塞I/O实现。</p><li><p>序列化性能差</p> <p>Java序列化存在几个问题：</p> <ol><li>Java序列化机制是Java内部的一种对象编解码技术，无法跨语言使用。<li>相比其它开源序列化框架，Java序列化后的码流太大，无论网络传输还是持久化磁盘，都会导致额外资源占用。<li>序列化性能差，资源占用率高（主要是CPU资源）。</ol><li><p>线程模型问题</p> <p>采用同步阻塞I/O，故每个TCP连接都会占用一个线程，这样一来，I/O读写阻塞导致线程无法释放时，会导致系统性能急剧下降，严重会导致虚拟机无法创建新的线程。</p></ol> <h3 id=4-1-2、I-O通信性能三原则><a class=headerlink href=#4-1-2、I-O通信性能三原则 title=4.1.2、I/O通信性能三原则></a>4.1.2、I/O通信性能三原则</h3><ol><li>传输：I/O模型很大程度上决定了通信性能。<li>协议：采用什么通信协议，协议不同，性能也不同。相比公有协议，内部私有协议的性能通常可以被设计的更好。<li>线程：数据报如何读取？读取后编解码让哪个线程去做？编解码后消息如何派发？Reactor线程模型的不同，对性能影响也非常大。</ol> <h2 id=4-2、Netty高性能之道><a class=headerlink href=#4-2、Netty高性能之道 title=4.2、Netty高性能之道></a>4.2、Netty高性能之道</h2><h3 id=4-2-1、异步非阻塞通信><a class=headerlink href=#4-2-1、异步非阻塞通信 title=4.2.1、异步非阻塞通信></a>4.2.1、异步非阻塞通信</h3><h3 id=4-2-2、高效的Reactor线程模型><a class=headerlink href=#4-2-2、高效的Reactor线程模型 title=4.2.2、高效的Reactor线程模型></a>4.2.2、高效的Reactor线程模型</h3><h3 id=4-2-3、无锁化的串行设计><a class=headerlink href=#4-2-3、无锁化的串行设计 title=4.2.3、无锁化的串行设计></a>4.2.3、无锁化的串行设计</h3><h3 id=4-2-4、高效的并发编程><a class=headerlink href=#4-2-4、高效的并发编程 title=4.2.4、高效的并发编程></a>4.2.4、高效的并发编程</h3><ol><li>volatile大量、正确的使用。<li>CAS和原子类的广泛使用。<li>线程安全容器的使用。<li>通过读写锁提升并发性能。</ol> <h3 id=4-2-5、高性能的序列化框架><a class=headerlink href=#4-2-5、高性能的序列化框架 title=4.2.5、高性能的序列化框架></a>4.2.5、高性能的序列化框架</h3><p>影响序列化性能的关键因素如下：</p> <ol><li>序列化后的码流太大（网络带宽占用）。<li>序列化和反序列化的性能（CPU资源占用）。<li>是否支持跨语言（异构系统的对接和开发语言切换）。</ol> <h3 id=4-2-6、零拷贝><a class=headerlink href=#4-2-6、零拷贝 title=4.2.6、零拷贝></a>4.2.6、零拷贝</h3><h4 id=传统意义上的拷贝><a class=headerlink href=#传统意义上的拷贝 title=传统意义上的拷贝></a>传统意义上的拷贝</h4><ol><li>数据从磁盘读取到内核的read buffer<li>数据从内核缓冲区拷贝到用户缓冲区<li>数据从用户缓冲区拷贝到内核的socket buffer<li>数据从内核的socket buffer拷贝到网卡接口（硬件）的缓冲区</ol> <h4 id=零拷贝的概念><a class=headerlink href=#零拷贝的概念 title=零拷贝的概念></a>零拷贝的概念</h4><p>明显上面的第二步和第三步是没有必要的，通过java的FileChannel.transferTo方法，可以避免上面两次多余的拷贝（当然这需要底层操作系统支持）</p> <ol><li>调用transferTo，数据从文件由DMA引擎拷贝到内核read buffer。<li>接着DMA从内核read buffer将数据拷贝到网卡接口buffer上面的两次操作都不需要CPU参与，所以就达到了零拷贝。</ol> <h4 id=Netty零拷贝实现><a class=headerlink href=#Netty零拷贝实现 title=Netty零拷贝实现></a>Netty零拷贝实现</h4><ol><li>Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。<li>零拷贝的实现CompositeByteBuf对外将多个ByteBuf封装成一个ByteBuf，对外提供统一封装后的ByteBuf接口。<li>文件传输，Netty文件传输类DefaultFileRegion通过transferTo方法将文件发送到目标Channel中。</ol> <h3 id=4-2-7、内存池><a class=headerlink href=#4-2-7、内存池 title=4.2.7、内存池></a>4.2.7、内存池</h3><h3 id=4-2-8、灵活的TCP参数配置能力><a class=headerlink href=#4-2-8、灵活的TCP参数配置能力 title=4.2.8、灵活的TCP参数配置能力></a>4.2.8、灵活的TCP参数配置能力</h3><p>对性能影响较大的配置项：</p> <ol><li>SO_RCVBUF和SO_SNDBUF：建议值为128K或者256K。<li>SO_TCPNODELAY：NAGLE算法通过将缓冲区内的小封包自动相连组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但对于时延敏感的场景需要关闭该优化算法：<li>软中断。</ol> <h1 id=5、Netty参数配置表><a class=headerlink href=#5、Netty参数配置表 title=5、Netty参数配置表></a>5、Netty参数配置表</h1><p><img alt=image-20200926142549088 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/10/06/image-20200926142549088.png></p> <footer class=post-footer><div class=post-eof></div></footer> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hgprivate.github.io/2024/08/21/Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/ itemprop=url>Nacos系列-Nacos配置中心</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-07 15:16:33" datetime=2023-08-07T15:16:33+08:00 itemprop=dateModified>2023-08-07</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Nacos/ itemprop=url rel=index><span itemprop=name>Nacos</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、搭建配置中心><a class=headerlink href=#1、搭建配置中心 title=1、搭建配置中心></a>1、搭建配置中心</h1><p>直接开启Nacos服务即可。<h1 id=2、配置><a class=headerlink href=#2、配置 title=2、配置></a>2、配置</h1><h2 id=2-1、注意事项><a class=headerlink href=#2-1、注意事项 title=2.1、注意事项></a>2.1、注意事项</h2><p>Nacos 配置中心的 dataId 完整格式：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>${prefix}-${spring.profiles.active}.${file-extension}</span></span><br></pre></table></figure><p>参数解析：<ul><li>prefix：默认为 spring.application.name 的值，也可以通过配置项spring.cloud.nacos.config.prefix来配置。<li>spring.profiles.active：当前环境对应的 profile，spring.profiles.active 为空时，对应的连接符 - 也将不存在，dataId 的拼接格式变成 ${prefix}.${file-extension}<li>file-exetension：配置内容的数据格式，可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。</ul><h2 id=2-2、配置示例><a class=headerlink href=#2-2、配置示例 title=2.2、配置示例></a>2.2、配置示例</h2><h3 id=2-2-1、bootstrap-yml><a class=headerlink href=#2-2-1、bootstrap-yml title=2.2.1、bootstrap.yml></a>2.2.1、bootstrap.yml</h3><p>项目中创建bootstrap.yml文件，添加如下内容：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=comment># bootstrap.yml</span></span><br><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>application:</span></span><br><span class=line>    <span class=attr>name:</span> <span class=string>shh-gulimall-order</span></span><br><span class=line>  <span class=comment># 环境 dev|test|prod</span></span><br><span class=line>  <span class=attr>profiles:</span></span><br><span class=line>    <span class=attr>active:</span> <span class=string>dev</span></span><br><span class=line>  <span class=attr>cloud:</span></span><br><span class=line>    <span class=attr>nacos:</span></span><br><span class=line>      <span class=attr>config:</span></span><br><span class=line>        <span class=attr>server-addr:</span> <span class=number>127.0</span><span class=number>.0</span><span class=number>.1</span><span class=string>:8848</span></span><br><span class=line>        <span class=attr>namespace:</span> <span class=string>37d6d15b-ee13-4bb6-8dfb-101f2281d479</span></span><br><span class=line>        <span class=attr>group:</span> <span class=string>gulimall-order</span></span><br><span class=line>        <span class=attr>file-extension:</span> <span class=string>yaml</span></span><br><span class=line>        <span class=string>extension-configs[0]:</span></span><br><span class=line>          <span class=attr>group:</span> <span class=string>gulimall-order</span></span><br><span class=line>          <span class=attr>dataId:</span> <span class=string>shh-gulimall-order-common.yaml</span></span><br><span class=line>          <span class=attr>refresh:</span> <span class=literal>true</span></span><br><span class=line>        <span class=string>extension-configs[1]:</span></span><br><span class=line>          <span class=attr>group:</span> <span class=string>gulimall-order</span></span><br><span class=line>          <span class=attr>dataId:</span> <span class=string>shh-gulimall-order-dev.yaml</span></span><br><span class=line>          <span class=attr>refresh:</span> <span class=literal>true</span></span><br></pre></table></figure><h3 id=2-2-2、Nacos服务中心配置><a class=headerlink href=#2-2-2、Nacos服务中心配置 title=2.2.2、Nacos服务中心配置></a>2.2.2、Nacos服务中心配置</h3><figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=comment># ===========DataID===========</span></span><br><span class=line><span class=string>shh-gulimall-order-dev.yaml</span></span><br><span class=line></span><br><span class=line><span class=comment># ===========配置格式===========</span></span><br><span class=line><span class=string>YAML</span></span><br><span class=line></span><br><span class=line><span class=comment># ===========配置内容===========</span></span><br><span class=line><span class=comment># Spring</span></span><br><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>application:</span></span><br><span class=line>    <span class=attr>name:</span> <span class=string>shh-gulimall-order</span></span><br><span class=line>  <span class=attr>cloud:</span></span><br><span class=line>    <span class=attr>nacos:</span></span><br><span class=line>      <span class=attr>discovery:</span></span><br><span class=line>        <span class=attr>server-addr:</span> <span class=number>127.0</span><span class=number>.0</span><span class=number>.1</span><span class=string>:8848</span></span><br><span class=line>        <span class=attr>namespace:</span> <span class=string>37d6d15b-ee13-4bb6-8dfb-101f2281d479</span></span><br><span class=line>        <span class=attr>group:</span> <span class=string>gulimall-server-list</span></span><br><span class=line>    <span class=attr>alibaba:</span></span><br><span class=line>      <span class=attr>seata:</span></span><br><span class=line>        <span class=attr>tx-service-group:</span> <span class=string>shh-gulimall-tagroup</span></span><br></pre></table></figure><h1 id=3、项目使用><a class=headerlink href=#3、项目使用 title=3、项目使用></a>3、项目使用</h1><h2 id=3-1、使用示例><a class=headerlink href=#3-1、使用示例 title=3.1、使用示例></a>3.1、使用示例</h2><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Configuration</span></span><br><span class=line><span class=meta>@ConfigurationProperties(prefix = "spring.application")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ConfigProperties</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">print</span><span class=params>()</span>{</span><br><span class=line>        System.out.println(<span class=string>"name: "</span> + name);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hgprivate.github.io/2024/08/21/Nacos%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Nacos%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/ itemprop=url>Nacos系列-Nacos基础应用</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 15:23:00" datetime=2023-10-02T15:23:00+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Nacos/ itemprop=url rel=index><span itemprop=name>Nacos</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、注册中心搭建><a class=headerlink href=#1、注册中心搭建 title=1、注册中心搭建></a>1、注册中心搭建</h1><h2 id=1-1、启动Nacos服务><a class=headerlink href=#1-1、启动Nacos服务 title=1.1、启动Nacos服务></a>1.1、启动Nacos服务</h2><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># standalone 表示单机模式启动，不写默认为集群模式</span></span><br><span class=line>./nacos/bin/startup.sh -m standalone</span><br></pre></table></figure><h1 id=2、注册服务><a class=headerlink href=#2、注册服务 title=2、注册服务></a>2、注册服务</h1><h2 id=2-1、添加依赖><a class=headerlink href=#2-1、添加依赖 title=2.1、添加依赖></a>2.1、添加依赖</h2><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>com.alibaba.cloud<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>spring-cloud-starter-alibaba-nacos-discovery<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><h2 id=2-2、编写配置><a class=headerlink href=#2-2、编写配置 title=2.2、编写配置></a>2.2、编写配置</h2><figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=comment># application.yml</span></span><br><span class=line><span class=attr>server:</span></span><br><span class=line>  <span class=attr>port:</span> <span class=number>8070</span></span><br><span class=line></span><br><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>application:</span></span><br><span class=line>    <span class=attr>name:</span> <span class=string>shhsca-registry-nacos-provider</span></span><br><span class=line>  <span class=attr>profiles:</span></span><br><span class=line>    <span class=attr>active:</span> <span class=string>dev</span></span><br><span class=line>  <span class=attr>output:</span></span><br><span class=line>    <span class=attr>ansi:</span></span><br><span class=line>      <span class=attr>enabled:</span> <span class=string>always</span> <span class=comment>#使用色彩输出提高日志可读性</span></span><br><span class=line>      </span><br><span class=line><span class=comment># application-dev.yml</span></span><br><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>cloud:</span></span><br><span class=line>    <span class=attr>nacos:</span></span><br><span class=line>      <span class=attr>discovery:</span></span><br><span class=line>        <span class=attr>server-addr:</span> <span class=number>127.0</span><span class=number>.0</span><span class=number>.1</span><span class=string>:8848</span></span><br><span class=line>        <span class=attr>cluster-name:</span> <span class=string>SH</span></span><br><span class=line>        <span class=attr>ephemeral:</span> <span class=literal>false</span>    <span class=comment># 是否是临时实例，默认为true。</span></span><br><span class=line>        <span class=attr>namespace:</span> <span class=string>5f90237f-3796-47e9-9afd-258fba2843ab</span></span><br><span class=line>        <span class=attr>group:</span> <span class=string>shhsca</span></span><br></pre></table></figure><h2 id=2-3、编写main方法><a class=headerlink href=#2-3、编写main方法 title=2.3、编写main方法></a>2.3、编写main方法</h2><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@EnableDiscoveryClient</span></span><br><span class=line><span class=meta>@SpringBootApplication</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">NCosProviderApplication</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        SpringApplication.run(NCosProviderApplication.class, args);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hgprivate.github.io/2024/08/21/Nacos%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Nacos%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ itemprop=url>Nacos系列-Nacos原理解析</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 15:52:48" datetime=2023-10-02T15:52:48+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Nacos/ itemprop=url rel=index><span itemprop=name>Nacos</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、服务注册><a class=headerlink href=#1、服务注册 title=1、服务注册></a>1、服务注册</h1><h2 id=1-1、客户端><a class=headerlink href=#1-1、客户端 title=1.1、客户端></a>1.1、客户端</h2><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line>- SPring启动时 加载 自动配置类 NacosServiceRegistryAutoConfiguration</span><br><span class=line>- 注入 return new NacosAutoServiceRegistration(...)</span><br><span class=line>	- 其父类 AbstractAutoServiceRegistration 也被初始化了</span><br><span class=line>		- 实现了ApplicationListener接口，监听Spring容器启动过程中的事件</span><br><span class=line>		- 监听到 WebServerInitializedEvent（web服务初始化完成）的事件后，开启服务注册流程。</span><br><span class=line>			1、发布开始注册的事件</span><br><span class=line>			2、开始注册：register();</span><br><span class=line>			3、发布注册完成事件</span><br><span class=line>			4、服务状态设置为运行状态。</span><br><span class=line></span><br><span class=line>- 开始注册：register();</span><br><span class=line>- NacosServiceRegistry.register(Registration registration);</span><br><span class=line>	`NacosServiceRegistry`是Spring的`ServiceRegistry`接口的实现类，</span><br><span class=line>	而ServiceRegistry接口是服务注册、发现的规约接口，定义了register、</span><br><span class=line>	deregister等方法的声明。</span><br><span class=line>- NamingService.registerInstance(serviceId, group, instance);</span><br><span class=line>	NamingService接口的默认实现就是NacosNamingService。</span><br><span class=line>- NacosProxy.registerService(groupedServiceName, groupName, instance);</span><br><span class=line>	发送注册服务实例请求。发送到 /nacos/v1/ns/instance</span><br></pre></table></figure><h2 id=1-2、服务端><a class=headerlink href=#1-2、服务端 title=1.2、服务端></a>1.2、服务端</h2><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line>- 入口 com.alibaba.nacos.naming.controllers.InstanceController</span><br><span class=line></span><br><span class=line>- 将 实例信息 封装成 Instance对象。然后 执行注册实例方法。</span><br><span class=line>	ServiceManager.registerInstance(namespaceId, serviceName, instance);</span><br><span class=line>- 将 要注册的实例放入Service中</span><br><span class=line>	addInstance(namespaceId, serviceName, instance.isEphemeral(), instance);</span><br><span class=line>	</span><br><span class=line>	- 对服务加synchronized（不同服务不会阻塞，同一个服务的不同实例会被阻塞）</span><br><span class=line>		- 将实例列表封装成 instances 对象</span><br><span class=line>		- 更新注册表，完成 Nacos集群数据同步。 consistencyService.put(key, instances);</span><br><span class=line></span><br><span class=line>- 更新服务列表 ServiceManager.updateIpAddresses(...);</span><br><span class=line>	先获取旧的实例列表，然后把新的实例信息与旧的做对比，新的实例就添加，老的实例同步ID。</span><br><span class=line>	然后返回最新的实例列表。</span><br><span class=line></span><br><span class=line>- 集群一致性 更新 </span><br><span class=line>	- DelegateConsistencyServiceImpl.put(..);</span><br><span class=line>		- 根据实例是否是临时实例，判断委托对象</span><br><span class=line>			// 判断是否是临时实例：（默认情况下，所有实例都是临时实例，我们关注DistroConsistencyServiceImpl即可。）</span><br><span class=line>			// 是，选择 ephemeralConsistencyService，也就是 DistroConsistencyServiceImpl类</span><br><span class=line>			// 否，选择 persistentConsistencyService，也就是PersistentConsistencyServiceDelegateImpl</span><br><span class=line></span><br><span class=line>		- 先将要更新的实例信息写入本地实例列表，然后同步集群数据</span><br><span class=line>			- onPut(key, value);</span><br><span class=line>				- 将任务放入阻塞队列，通过线程池异步从队列中取出任务来执行。</span><br><span class=line>					notifier.addTask(key, DataOperation.CHANGE);</span><br><span class=line>					handle(pair);</span><br><span class=line>				- 根据 CHANGE事件 还是 DELETE 事件，来执行对应的操作。</span><br><span class=line>					- 获取旧实例列表</span><br><span class=line>					- 检查新加入实例状态</span><br><span class=line>					- 移除要删除的实例</span><br><span class=line>					- 覆盖旧实例。</span><br><span class=line>			- distroProtocol.sync(...);</span><br><span class=line>				- 遍历集群所有节点（除了自己），交给线程池去执行。</span><br><span class=line>					NacosDelayTaskExecuteEngine.addTask(distroKeyWithTarget, distroDelayTask);</span><br><span class=line>					NacosDelayTaskExecuteEngine，这个类维护了一个线程池，并且接收任务，执行任务。</span><br><span class=line>					去除任务来执行是基于Distro模式的同步是异步进行的，并且失败时会将任务重新入队，因此不保证强一致性，属于AP模式的一致性策略。</span><br></pre></table></figure><h2 id=1-3、总结><a class=headerlink href=#1-3、总结 title=1.3、总结></a>1.3、总结</h2><p><strong>（1）Nacos的注册表结构是什么样的？</strong><p>Nacos是多级存储模型，最外层通过namespace来实现环境隔离，然后是group分组，分组下就是服务，一个服务可分不同的集群，集群中包含多个实例。因此其注册表结构是一个Map结构：<p><code>Map&LTString, Map&LTString, Service>></code>，key是<code>namespace_id</code>，value代表的map结构的key是<code>group+serviceName</code>.<p>Service内部维护一个Map结构：<code>Map&LTString,Cluster></code>，key是clusterName，值是集群信息，Cluster内部维护一个Set集合，元素是Instance类型，代表集群中的多个实例。<p><strong>（2）Nacos如何保证并发写的安全性？</strong><p>注册实例时会对service加锁，不同service之间本身就不存在并发写问题，互不影响。相同service时通过锁来互斥。并且，在更新实例列表时，是基于异步的线程池来完成，且线程池的线程数量为1。<p><strong>（3）Nacos如何避免并发读写的冲突？</strong><p>Nacos在更新实例列表时，会<strong>采用 CopyOnWrite 技术</strong>，首先将Old实例列表拷贝一份，然后更新拷贝的实例列表，再用更新后的实例列表来覆盖旧的实例列表。<p><strong>（4）Nacos如何应对阿里内部数十万服务的并发写请求？</strong><p>Nacos内部会将服务注册的任务放入<em><strong>阻塞队列</strong></em>，采用<em><strong>线程池异步</strong></em>来完成实例更新，从而提高并发写能力。<h1 id=2、服务心跳><a class=headerlink href=#2、服务心跳 title=2、服务心跳></a>2、服务心跳</h1><h2 id=2-1、客户端><a class=headerlink href=#2-1、客户端 title=2.1、客户端></a>2.1、客户端</h2><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>- 入口 NacosNamingService.registerInstance(...);</span><br><span class=line>	- 触发心跳：BeatReactor.addBeatInfo(groupedServiceName, beatInfo)</span><br><span class=line>		- 利用线程池，定期执行心跳任务，周期为 beatInfo.getPeriod()，默认5S</span><br><span class=line>			executorService.schedule(new BeatTask(beatInfo), beatInfo.getPeriod(), TimeUnit.MILLISECONDS);</span><br><span class=line></span><br><span class=line>			发送心跳，然后判断心跳结果，若失败则重新 注册实例。</span><br><span class=line>- 发送心跳 NamingProxy.sendBeat(...)</span><br><span class=line>	请求地址：/v1/ns/instance/beat</span><br></pre></table></figure><h2 id=2-2、服务端><a class=headerlink href=#2-2、服务端 title=2.2、服务端></a>2.2、服务端</h2><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>- 入口：InstanceController.beat();</span><br><span class=line></span><br><span class=line>- 从Nacos注册表中获取实例</span><br><span class=line>- 实例为null，表示获取失败 说明心跳失败，实例未注册</span><br><span class=line>	- 重新注册新实例</span><br><span class=line>- 实例不为null，则从注册表中获取服务service</span><br><span class=line>- 若service为null, 则服务不存在，抛出异常</span><br><span class=line>- 如果心跳没有问题，就处理 心跳结果。</span><br><span class=line></span><br><span class=line>- 处理心跳请求</span><br><span class=line>	- 从集群中找到当前的心跳实例</span><br><span class=line>	- 更新 该实例 最后一次心跳时间 lastBeat。</span><br></pre></table></figure><h3 id=2-2-1、异常检查><a class=headerlink href=#2-2-1、异常检查 title=2.2.1、异常检查></a>2.2.1、异常检查</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line>- 入口 Service.init(); 服务注册时会被调用。</span><br><span class=line></span><br><span class=line>- 开启心跳检测任务</span><br><span class=line>	HealthCheckReactor.scheduleCheck(clientBeatCheckTask);</span><br><span class=line>	该任务会 每5秒对实例心跳状态 做一次检测。</span><br><span class=line></span><br><span class=line>	- clientBeatCheckTask</span><br><span class=line>		- 拿到 所有临时实例列表</span><br><span class=line>		- 判断 心跳间隔（当前时间-最后一次心跳时间）是否大于 心跳超时时间，默认15S</span><br><span class=line>			- 超时，则标记实例为 不健康。</span><br><span class=line>			- 不超时，发布实例状态变事件。</span><br><span class=line>		- 判断心跳间隔（当前时间 - 最后一次心跳时间）是否大于 实例被删除的最长超时时间，默认30秒</span><br><span class=line>			- 超过30S，删除实例。</span><br></pre></table></figure><h3 id=2-2-2、主动检查><a class=headerlink href=#2-2-2、主动检查 title=2.2.2、主动检查></a>2.2.2、主动检查</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line>- 入口 ServiceManager.registerInstance(...)</span><br><span class=line></span><br><span class=line>- 若服务不存在，创建新服务。</span><br><span class=line>	- 尝试获取服务</span><br><span class=line>	- 服务不存在，开始创建新服务。</span><br><span class=line>	- 将服务写入注册表 并初始化。</span><br><span class=line>		- 初始化逻辑</span><br><span class=line>			- 开启心跳检测任务</span><br><span class=line>			- 遍历注册表中的集群</span><br><span class=line>			- 完成集群初始化</span><br><span class=line>				- 创建健康检测任务</span><br><span class=line>				- 开启对 非临时实例 的定时检测。</span><br><span class=line>- 非临时实例 定时检测逻辑</span><br><span class=line>	- 获取所有 非临时实例 集合</span><br><span class=line>	- 将检测信息 封装成 beat</span><br><span class=line>	- 放入阻塞队列中。</span><br><span class=line>	</span><br><span class=line>	- 拿出任务去执行</span><br><span class=line>		- 将任务封装为一个 TaskProcessor，并放入集合。</span><br><span class=line>		- 批量处理集合中的任务。</span><br><span class=line>			- 获取实例信息</span><br><span class=line>			- 基于NIO建立TCP连接</span><br><span class=line>			- 注册 连接、读取 事件。</span><br></pre></table></figure><h2 id=2-3、总结><a class=headerlink href=#2-3、总结 title=2.3、总结></a>2.3、总结</h2><p>Nacos的健康检测有两种模式：<ul><li>临时实例：<ul><li>采用客户端心跳检测模式，心跳周期5秒。<li>心跳间隔超过15秒就标记为不健康。<li>心跳间隔超过30秒会被从服务列表删除。</ul><li>永久实例：<ul><li>采用服务端主动健康检测方式。<li>周期为2000 + 5000毫秒内的随机数。<li>检测异常只会标记为不健康，不会删除。</ul></ul><p><strong>为什么Nacos有临时和永久两种实例呢？</strong><p>以淘宝为例，双十一大促期间，流量会比平常高出很多，此时需要增加更多实例来应对高并发，而这些实例在双十一之后就无需继续使用了，采用<strong>临时实例</strong>比较合适。而对于服务的一些常备实例，则使用<strong>永久实例</strong>更合适。<p>与eureka相比，Nacos与Eureka在临时实例上都是基于心跳模式实现，差别不大，主要是心跳周期不同，eureka是30秒，Nacos是5秒。<p>另外，Nacos支持永久实例，而Eureka不支持，Eureka只提供了心跳模式的健康监测，而没有主动检测功能。<h1 id=3、服务发现><a class=headerlink href=#3、服务发现 title=3、服务发现></a>3、服务发现</h1><h2 id=3-1、客户端><a class=headerlink href=#3-1、客户端 title=3.1、客户端></a>3.1、客户端</h2><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br></pre><td class=code><pre><span class=line>- 入口 NacosNamingService. getAllInstances(...);</span><br><span class=line></span><br><span class=line>- 判断 是否需要 订阅服务（默认true）</span><br><span class=line>	- 若要订阅，执行订阅逻辑。serviceInfo = hostReactor.getServiceInfo(...);</span><br><span class=line>	- 否则，执行拉取逻辑。serviceInfo = hostReactor.getServiceInfoDirectlyFromServer()</span><br><span class=line>- 从服务信息中获取实力列表并返回。</span><br><span class=line></span><br><span class=line>- 拉取服务</span><br><span class=line>	- 查看本地服务列表缓存是否存在，缓存是map</span><br><span class=line>	- 不存在</span><br><span class=line>		- 创建空ServiceInfo</span><br><span class=line>		- 放入缓存</span><br><span class=line>		- 放入待更新的服务列表</span><br><span class=line>		- 立即更新服务列表</span><br><span class=line>			- 执行HostReactor中的updateService()方法。</span><br><span class=line>				- 基于ServerProxy发起远程调用，查询服务列表</span><br><span class=line>		- 从 待更新服务列表 中删除</span><br><span class=line>	- 存在，但需要更新</span><br><span class=line>		- 执行更新逻辑。等待5秒中，待更新完成</span><br><span class=line>	- 开启定时更新服务列表的功能</span><br><span class=line>		scheduleUpdateIfAbsent(serviceName, clusters);</span><br><span class=line>	- 返回缓存中的服务信息</span><br><span class=line>		serviceInfoMap.get(serviceObj.getKey());</span><br><span class=line>	</span><br><span class=line>- 推送服务</span><br><span class=line>	基本思路是：</span><br><span class=line>		- 通过PushReceiver监听服务端推送的变更数据</span><br><span class=line>		- 解析数据后，通过NotifyCenter发布服务变更的事件</span><br><span class=line>		- InstanceChangeNotifier监听变更事件，完成对服务列表的更新</span><br><span class=line></span><br><span class=line>	入口 PushReceiver</span><br><span class=line>		- 创建 UDP客户端</span><br><span class=line>		- 准备线程池</span><br><span class=line>		- 开启线程任务，准备接收变更数据</span><br><span class=line>			- 接收推送数据</span><br><span class=line>			- 解析为json字符串</span><br><span class=line>			- 反序列化为对象</span><br><span class=line>			- 交给 HostReactor去处理</span><br><span class=line>			- 发送ACK回执</span><br><span class=line></span><br><span class=line>	- 处理接收到的数据 HostReactor.processServiceJson(String json);</span><br><span class=line>		- 解析 接收到的数据，解析出ServiceInfo</span><br><span class=line>		- 查询缓存中的 ServiceInfo</span><br><span class=line>		- 如果缓存存在，则需要校验哪些数据要更新</span><br><span class=line>			- 将接收到的ServiceInfo 放入缓存。</span><br><span class=line>			- 对缓存中的数据 与 接收到的数据 进行对比。拿到</span><br><span class=line>				新增实例、待删除实例、要修改实例。</span><br><span class=line>			- 发布实例状态修改事件。</span><br><span class=line>			- 将接收到的数据ServiceInfo写入缓存。</span><br><span class=line>		- 缓存不存在</span><br><span class=line>			- 放入缓存</span><br><span class=line>			- 直接发布状态修改事件。</span><br></pre></table></figure><h2 id=3-2、服务端><a class=headerlink href=#3-2、服务端 title=3.2、服务端></a>3.2、服务端</h2><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>- 入口 InstanceController.list();</span><br><span class=line></span><br><span class=line>- 获取客户端UDP端口</span><br><span class=line>- 获取服务列表并返回</span><br><span class=line>	- 将消费者UDP端口、IP等封装成一个PushClient对象，存储到PushService中，</span><br><span class=line>		后期服务变更时，方便推送消息。pushService.addClient()</span><br><span class=line>	- PushService实现了ApplicationListener接口，当服务列表变化时，就会通知我们。</span><br></pre></table></figure><h2 id=3-3、总结><a class=headerlink href=#3-3、总结 title=3.3、总结></a>3.3、总结</h2><p>Nacos的服务发现分为两种模式：<ul><li><strong>主动拉取模式</strong>。消费者定期主动从Nacos拉取服务列表并缓存起来，在调用服务时优先读取本地缓存中的服务列表。<li><strong>订阅模式</strong>。消费者订阅服务列表，并基于UDP协议来接收服务变更通知。服务列表更新时会发送UDP广播给所有订阅者。</ul><p>与Eureka相比，Nacos服务状态更新更及时，同步更新更快，避免了因同步慢造成的一系列问题。</div><footer class=post-footer><div class=post-eof></div></footer></article></div> <nav class=pagination><a class="extend prev" aria-label=上一页 href=/page/5/ rel=prev title=上一页><i class="fa fa-angle-left"></i></a><a class=page-number href=/>1</a><span class=space>…</span><a class=page-number href=/page/5/>5</a><span class="page-number current">6</span><a class=page-number href=/page/7/>7</a><span class=space>…</span><a class=page-number href=/page/12/>12</a><a class="extend next" aria-label=下一页 href=/page/7/ rel=next title=下一页><i class="fa fa-angle-right"></i></a></nav> <footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer> <div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div> <div class=sidebar-dimmer></div> <div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div> <noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript> <script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script> <script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script> <script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script> <script src=/js/third-party/search/local-search.js></script> 