<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hshz21.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content=豪哥博客 name=description><meta content=website property=og:type><meta content=豪哥博客 property=og:title><meta content=https://hshz21.gitee.io/page/5/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content=豪哥博客 property=og:description><meta content=zh_CN property=og:locale><meta content=豪哥 property=article:author><meta content=HG property=article:tag><meta content=summary name=twitter:card><link href=https://hshz21.gitee.io/page/5/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/5/index.html","title":""}</script><script class=next-config data-name=calendar type=application/json>""</script><title>豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <h1 class=site-title>豪哥博客</h1> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>116</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>36</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>129</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Sentinel%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Sentinel%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ itemprop=url>Sentinel系列-Sentinel原理解析</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-07 15:01:01" datetime=2023-08-07T15:01:01+08:00 itemprop=dateModified>2023-08-07</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Sentinel/ itemprop=url rel=index><span itemprop=name>Sentinel</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、基本概念><a class=headerlink href=#1、基本概念 title=1、基本概念></a>1、基本概念</h1><p>Sentinel实现限流、隔离、降级、熔断等功能，本质要做的就是两件事情：<ul><li><strong>统计数据</strong>：统计某个资源的访问数据（QPS、RT等信息）。<li><strong>规则判断</strong>：判断限流规则、隔离规则、降级规则、熔断规则是否满足。</ul><h2 id=1-1、ProcessorSlotChain><a class=headerlink href=#1-1、ProcessorSlotChain title=1.1、ProcessorSlotChain></a>1.1、ProcessorSlotChain</h2><p><strong>Sentinel核心骨架是类ProcessorSlotChain。该类基于责任链模式将不同功能（限流、降级、系统保护）封装成一个个的Slot，请求进入后会逐个执行。</strong><p><img alt=image-20220428170120087 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20220428170120087.png><p>责任链中的Slot也分为两大类：<ul><li><strong>统计数据构建部分（statistic）</strong><ul><li>NodeSelectorSlot：负责构建簇点链路中的节点（DefaultNode），将这些节点形成链路树。<li>ClusterBuilderSlot：负责构建某个资源的ClusterNode，ClusterNode可以保存资源的运行信息（响应时间、QPS、block 数目、线程数、异常数等）以及来源信息（origin名称）。<li>StatisticSlot：负责统计实时调用数据，包括运行信息、来源信息等。</ul><li><strong>规则判断部分（rule checking）</strong><ul><li>AuthoritySlot：负责授权规则（来源控制）。<li>SystemSlot：负责系统保护规则。<li>ParamFlowSlot：负责热点参数限流规则。<li>FlowSlot：负责限流规则。<li>DegradeSlot：负责降级规则。</ul></ul><h2 id=1-2、Node><a class=headerlink href=#1-2、Node title=1.2、Node></a>1.2、Node</h2><p>Sentinel中的簇点链路是由一个个Node组成，Node是一个接口，有其如下实现：<p><img alt=image-20220428170236302 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20220428170236302.png><p>按照作用分为两类Node：<ul><li><strong>DefaultNode</strong>：代表链路树中的每一个资源，一个资源出现在不同链路中时会创建不同的DefaultNode节点。而树的入口节点叫EntranceNode，是一种特殊的DefaultNode。<li><strong>ClusterNode</strong>：代表资源，一个资源不管出现在多少链路中，只会有一个ClusterNode。记录当前资源被访问的统计数据。</ul><h2 id=1-3、Entry><a class=headerlink href=#1-3、Entry title=1.3、Entry></a>1.3、Entry</h2><p>默认情况下Sentinel会将controller中的方法作为被保护资源，如何将一段代码标记为一个Sentinel资源呢？<p>Sentinel中的资源用Entry表示。声明Entry的API示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment>// 资源名可使用任意有业务语义的字符串，比如方法名、接口名或其它可唯一标识的字符串。</span></span><br><span class=line><span class=keyword>try</span> (<span class=type>Entry</span> <span class=variable>entry</span> <span class=operator>=</span> SphU.entry(<span class=string>"resourceName"</span>)) {</span><br><span class=line>  <span class=comment>// 被保护的业务逻辑</span></span><br><span class=line>  <span class=comment>// do something here...</span></span><br><span class=line>} <span class=keyword>catch</span> (BlockException ex) {</span><br><span class=line>  <span class=comment>// 资源访问阻止，被限流或被降级</span></span><br><span class=line>  <span class=comment>// 在此处进行相应的处理操作</span></span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-3-1、自定义资源><a class=headerlink href=#1-3-1、自定义资源 title=1.3.1、自定义资源></a>1.3.1、自定义资源</h3><p>1）首先在order-service中引入sentinel依赖。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!--sentinel--></span></span><br><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>com.alibaba.cloud<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>spring-cloud-starter-alibaba-sentinel<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><p>2）然后配置Sentinel地址。<figure class="highlight yaml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>cloud:</span></span><br><span class=line>    <span class=attr>sentinel:</span></span><br><span class=line>      <span class=attr>transport:</span></span><br><span class=line>        <span class=attr>dashboard:</span> <span class=string>localhost:8089</span> <span class=comment># 这里我的sentinel用了8089的端口</span></span><br></pre></table></figure><p>3）修改OrderService类的queryOrderById方法。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> Order <span class="title function_">queryOrderById</span><span class=params>(Long orderId)</span> {</span><br><span class=line>    <span class=comment>// 创建Entry，标记资源，资源名为resource1</span></span><br><span class=line>    <span class=keyword>try</span> (<span class=type>Entry</span> <span class=variable>entry</span> <span class=operator>=</span> SphU.entry(<span class=string>"resource1"</span>)) {</span><br><span class=line>        <span class=comment>// 1.查询订单，这里是假数据</span></span><br><span class=line>        <span class=type>Order</span> <span class=variable>order</span> <span class=operator>=</span> Order.build(<span class=number>101L</span>, <span class=number>4999L</span>, <span class=string>"小米 MIX4"</span>, <span class=number>1</span>, <span class=number>1L</span>, <span class=literal>null</span>);</span><br><span class=line>        <span class=comment>// 2.查询用户，基于Feign的远程调用</span></span><br><span class=line>        <span class=type>User</span> <span class=variable>user</span> <span class=operator>=</span> userClient.findById(order.getUserId());</span><br><span class=line>        <span class=comment>// 3.设置</span></span><br><span class=line>        order.setUser(user);</span><br><span class=line>        <span class=comment>// 4.返回</span></span><br><span class=line>        <span class=keyword>return</span> order;</span><br><span class=line>    }<span class=keyword>catch</span> (BlockException e){</span><br><span class=line>        log.error(<span class=string>"被限流或降级"</span>, e);</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>4）访问微服务后，打开Sentinel控制台，查看是否生效。<h3 id=1-3-2、通过注解标记资源><a class=headerlink href=#1-3-2、通过注解标记资源 title=1.3.2、通过注解标记资源></a>1.3.2、通过注解标记资源</h3><p>除编码外，还可以添加<code>@SentinelResource</code>注解来标记资源。<p>该功能的关键在于自动配置类<code>SentinelAutoConfiguration</code>。该配置类会注入<code>SentinelResourceAspect</code>。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br></pre><td class=code><pre><span class=line><span class=meta>@Aspect</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SentinelResourceAspect</span> <span class=keyword>extends</span> <span class="title class_">AbstractSentinelAspectSupport</span> {</span><br><span class=line>	<span class=comment>// 切点是添加了 @SentinelResource注解的类</span></span><br><span class=line>    <span class=meta>@Pointcut("@annotation(com.alibaba.csp.sentinel.annotation.SentinelResource)")</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">sentinelResourceAnnotationPointcut</span><span class=params>()</span> {</span><br><span class=line>    }</span><br><span class=line>	</span><br><span class=line>    <span class=comment>// 环绕增强</span></span><br><span class=line>    <span class=meta>@Around("sentinelResourceAnnotationPointcut()")</span></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">invokeResourceWithSentinel</span><span class=params>(ProceedingJoinPoint pjp)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>        <span class=comment>// 获取受保护的方法</span></span><br><span class=line>        <span class=type>Method</span> <span class=variable>originMethod</span> <span class=operator>=</span> resolveMethod(pjp);</span><br><span class=line>		<span class=comment>// 获取 @SentinelResource注解</span></span><br><span class=line>        <span class=type>SentinelResource</span> <span class=variable>annotation</span> <span class=operator>=</span> originMethod.getAnnotation(SentinelResource.class);</span><br><span class=line>        <span class=keyword>if</span> (annotation == <span class=literal>null</span>) {</span><br><span class=line>            <span class=comment>// Should not go through here.</span></span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalStateException</span>(<span class=string>"Wrong state for SentinelResource annotation"</span>);</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 获取注解上的资源名称</span></span><br><span class=line>        <span class=type>String</span> <span class=variable>resourceName</span> <span class=operator>=</span> getResourceName(annotation.value(), originMethod);</span><br><span class=line>        <span class=type>EntryType</span> <span class=variable>entryType</span> <span class=operator>=</span> annotation.entryType();</span><br><span class=line>        <span class=type>int</span> <span class=variable>resourceType</span> <span class=operator>=</span> annotation.resourceType();</span><br><span class=line>        <span class=type>Entry</span> <span class=variable>entry</span> <span class=operator>=</span> <span class=literal>null</span>;</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            <span class=comment>// 创建资源 Entry</span></span><br><span class=line>            entry = SphU.entry(resourceName, resourceType, entryType, pjp.getArgs());</span><br><span class=line>            <span class=comment>// 执行受保护的方法</span></span><br><span class=line>            <span class=type>Object</span> <span class=variable>result</span> <span class=operator>=</span> pjp.proceed();</span><br><span class=line>            <span class=keyword>return</span> result;</span><br><span class=line>        } <span class=keyword>catch</span> (BlockException ex) {</span><br><span class=line>            <span class=keyword>return</span> handleBlockException(pjp, annotation, ex);</span><br><span class=line>        } <span class=keyword>catch</span> (Throwable ex) {</span><br><span class=line>            Class&LT? <span class=keyword>extends</span> <span class="title class_">Throwable</span>>[] exceptionsToIgnore = annotation.exceptionsToIgnore();</span><br><span class=line>            <span class=comment>// The ignore list will be checked first.</span></span><br><span class=line>            <span class=keyword>if</span> (exceptionsToIgnore.length > <span class=number>0</span> && exceptionBelongsTo(ex, exceptionsToIgnore)) {</span><br><span class=line>                <span class=keyword>throw</span> ex;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (exceptionBelongsTo(ex, annotation.exceptionsToTrace())) {</span><br><span class=line>                traceException(ex);</span><br><span class=line>                <span class=keyword>return</span> handleFallback(pjp, annotation, ex);</span><br><span class=line>            }</span><br><span class=line></span><br><span class=line>            <span class=comment>// No fallback function can handle the exception, so throw it out.</span></span><br><span class=line>            <span class=keyword>throw</span> ex;</span><br><span class=line>        } <span class=keyword>finally</span> {</span><br><span class=line>            <span class=keyword>if</span> (entry != <span class=literal>null</span>) {</span><br><span class=line>                entry.exit(<span class=number>1</span>, pjp.getArgs());</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><strong><code>@SentinelResource</code>注解原理是基于AOP来对被标记方法做环绕增强，完成资源（<code>Entry</code>）创建。</strong><h2 id=1-4、Context><a class=headerlink href=#1-4、Context title=1.4、Context></a>1.4、Context</h2><p>簇点链路中除了controller方法、service方法两个资源外，还有一个默认入口节点<code>sentinel_spring_web_context</code>，是一个EntranceNode 类型节点，该节点在初始化Context时由Sentinel创建。<h3 id=1-4-1、Context定义><a class=headerlink href=#1-4-1、Context定义 title=1.4.1、Context定义></a>1.4.1、Context定义</h3><ul><li>Context 代表调用链路上下文，贯穿一次调用链路中的所有资源（ <code>Entry</code>），基于ThreadLocal。<li>Context 维持着入口节点（<code>entranceNode</code>）、本次调用链路的 curNode（当前资源节点）、调用来源（<code>origin</code>）等信息。<li>后续的Slot都可以通过Context拿到DefaultNode或者ClusterNode，从而获取统计数据，完成规则判断。<li>Context初始化的过程中，会创建EntranceNode，contextName就是EntranceNode的名称。</ul><p>对应API：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>// 创建context，包含两个参数：context名称、 来源名称</span></span><br><span class=line>ContextUtil.enter(<span class=string>"contextName"</span>, <span class=string>"originName"</span>);</span><br></pre></table></figure><h3 id=1-4-2、Context初始化><a class=headerlink href=#1-4-2、Context初始化 title=1.4.2、Context初始化></a>1.4.2、Context初始化</h3><h4 id=1-4-2-1、自动装配><a class=headerlink href=#1-4-2-1、自动装配 title=1.4.2.1、自动装配></a>1.4.2.1、自动装配</h4><p>sentine依赖包下的<code>spring.factories</code>文件中会注入很多配置类。<p><code>SentinelWebAutoConfiguration</code>实现了<code>WebMvcConfigurer</code>，且添加了拦截器<code>SentinelWebInterceptor</code>。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">addInterceptors</span><span class=params>(InterceptorRegistry registry)</span> {</span><br><span class=line>    <span class=keyword>if</span> (<span class=built_in>this</span>.sentinelWebInterceptorOptional.isPresent()) {</span><br><span class=line>        <span class=type>Filter</span> <span class=variable>filterConfig</span> <span class=operator>=</span> <span class=built_in>this</span>.properties.getFilter();</span><br><span class=line>        </span><br><span class=line>        registry.addInterceptor((HandlerInterceptor)<span class=built_in>this</span>.sentinelWebInterceptorOptional.get())</span><br><span class=line>        .order(filterConfig.getOrder())</span><br><span class=line>        .addPathPatterns(filterConfig.getUrlPatterns());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><code>SentinelWebInterceptors</code>实现了<code>HandlerInterceptor</code>接口，会拦截controller中的方法先执行拦截器的<code>preHandle</code>方法，Context初始化在这里完成。<h1 id=2、ProcessorSlotChain><a class=headerlink href=#2、ProcessorSlotChain title=2、ProcessorSlotChain></a>2、ProcessorSlotChain</h1><h2 id=2-1-入口><a class=headerlink href=#2-1-入口 title=2.1.入口></a>2.1.入口</h2><p>首先，回到一切的入口，<code>AbstractSentinelInterceptor</code>类的<code>preHandle</code>方法，还有<code>SentinelResourceAspect</code>的环绕增强方法。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>entry = SphU.entry(resourceName, resourceType, entryType, pjp.getArgs());</span><br><span class=line><span class=type>Object</span> <span class=variable>result</span> <span class=operator>=</span> pjp.proceed();</span><br><span class=line>var18 = result;</span><br><span class=line><span class=keyword>return</span> var18;</span><br></pre></table></figure><p>任何一个资源必定要执行<code>SphU.entry()</code>这个方法:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> Entry <span class="title function_">entry</span><span class=params>(String name, <span class=type>int</span> resourceType, EntryType trafficType, Object[] args)</span></span><br><span class=line>    <span class=keyword>throws</span> BlockException {</span><br><span class=line>    <span class=keyword>return</span> Env.sph.entryWithType(name, resourceType, trafficType, <span class=number>1</span>, args);</span><br><span class=line>}</span><br></pre></table></figure><p>继续进入<code>Env.sph.entryWithType(name, resourceType, trafficType, 1, args);</code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> Entry <span class="title function_">entryWithType</span><span class=params>(String name, <span class=type>int</span> resourceType, EntryType entryType, <span class=type>int</span> count, <span class=type>boolean</span> prioritized,</span></span><br><span class=line><span class=params>                           Object[] args)</span> <span class=keyword>throws</span> BlockException {</span><br><span class=line>    <span class=comment>// 将 资源名称等基本信息 封装为一个 StringResourceWrapper对象</span></span><br><span class=line>    <span class=type>StringResourceWrapper</span> <span class=variable>resource</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StringResourceWrapper</span>(name, entryType, resourceType);</span><br><span class=line>    <span class=comment>// 继续</span></span><br><span class=line>    <span class=keyword>return</span> entryWithPriority(resource, count, prioritized, args);</span><br><span class=line>}</span><br></pre></table></figure><p>进入<code>entryWithPriority</code>方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> Entry <span class="title function_">entryWithPriority</span><span class=params>(ResourceWrapper resourceWrapper, <span class=type>int</span> count, <span class=type>boolean</span> prioritized, Object... args)</span></span><br><span class=line>    <span class=keyword>throws</span> BlockException {</span><br><span class=line>    <span class=comment>// 获取 Context</span></span><br><span class=line>    <span class=type>Context</span> <span class=variable>context</span> <span class=operator>=</span> ContextUtil.getContext();</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (context == <span class=literal>null</span>) {</span><br><span class=line>        <span class=comment>// Using default context.</span></span><br><span class=line>        context = InternalContextUtil.internalEnter(Constants.CONTEXT_DEFAULT_NAME);</span><br><span class=line>    }</span><br><span class=line>、	<span class=comment>// 获取 Slot执行链，同一个资源，会创建一个执行链，放入缓存</span></span><br><span class=line>    ProcessorSlot&LTObject> chain = lookProcessChain(resourceWrapper);</span><br><span class=line></span><br><span class=line>	<span class=comment>// 创建 Entry，并将 resource、chain、context 记录在 Entry中</span></span><br><span class=line>    <span class=type>Entry</span> <span class=variable>e</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">CtEntry</span>(resourceWrapper, chain, context);</span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        <span class=comment>// 执行 slotChain</span></span><br><span class=line>        chain.entry(context, resourceWrapper, <span class=literal>null</span>, count, prioritized, args);</span><br><span class=line>    } <span class=keyword>catch</span> (BlockException e1) {</span><br><span class=line>        e.exit(count, args);</span><br><span class=line>        <span class=keyword>throw</span> e1;</span><br><span class=line>    } <span class=keyword>catch</span> (Throwable e1) {</span><br><span class=line>        <span class=comment>// This should not happen, unless there are errors existing in Sentinel internal.</span></span><br><span class=line>        RecordLog.info(<span class=string>"Sentinel unexpected exception"</span>, e1);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> e;</span><br><span class=line>}</span><br></pre></table></figure><p>在这段代码中，会获取<code>ProcessorSlotChain</code>对象，然后基于chain.entry()开始执行slotChain中的每一个Slot. 而这里创建的是其实现类：DefaultProcessorSlotChain.<p>获取ProcessorSlotChain以后会保存到一个Map中，key是ResourceWrapper，值是ProcessorSlotChain.<p>所以，<strong>一个资源只会有一个ProcessorSlotChain</strong>.<h2 id=2-2-DefaultProcessorSlotChain><a class=headerlink href=#2-2-DefaultProcessorSlotChain title=2.2.DefaultProcessorSlotChain></a>2.2.DefaultProcessorSlotChain</h2><p>进入DefaultProcessorSlotChain的entry方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">entry</span><span class=params>(Context context, ResourceWrapper resourceWrapper, Object t, <span class=type>int</span> count, <span class=type>boolean</span> prioritized, Object... args)</span></span><br><span class=line>    <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=comment>// first，就是责任链中的第一个 slot</span></span><br><span class=line>    first.transformEntry(context, resourceWrapper, t, count, prioritized, args);</span><br><span class=line>}</span><br></pre></table></figure><p>这里的 first 类型是AbstractLinkedProcessorSlot：<p>因此，first一定是这些实现类中的一个，按照最早讲的责任链顺序，first应该就是 <code>NodeSelectorSlot</code>。<p>不过，既然是基于责任链模式，所以这里只要记住下一个slot就可以了，也就是next，next确实是NodeSelectSlot类型。<p>而NodeSelectSlot的next一定是ClusterBuilderSlot，依次类推，责任链就建立起来了。<h2 id=2-3-NodeSelectorSlot><a class=headerlink href=#2-3-NodeSelectorSlot title=2.3.NodeSelectorSlot></a>2.3.NodeSelectorSlot</h2><p>NodeSelectorSlot负责构建簇点链路中的节点（DefaultNode），将这些节点形成链路树。<p>核心代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">entry</span><span class=params>(Context context, ResourceWrapper resourceWrapper, Object obj, <span class=type>int</span> count, <span class=type>boolean</span> prioritized, Object... args)</span></span><br><span class=line>    <span class=keyword>throws</span> Throwable {</span><br><span class=line>  	<span class=comment>// 尝试获取 当前资源的 DefaultNode</span></span><br><span class=line>    <span class=type>DefaultNode</span> <span class=variable>node</span> <span class=operator>=</span> map.get(context.getName());</span><br><span class=line>    <span class=keyword>if</span> (node == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>synchronized</span> (<span class=built_in>this</span>) {</span><br><span class=line>            node = map.get(context.getName());</span><br><span class=line>            <span class=keyword>if</span> (node == <span class=literal>null</span>) {</span><br><span class=line>                <span class=comment>// 如果为空，为当前资源创建一个新的 DefaultNode</span></span><br><span class=line>                node = <span class=keyword>new</span> <span class="title class_">DefaultNode</span>(resourceWrapper, <span class=literal>null</span>);</span><br><span class=line>                HashMap&LTString, DefaultNode> cacheMap = <span class=keyword>new</span> <span class="title class_">HashMap</span>&LTString, DefaultNode>(map.size());</span><br><span class=line>                cacheMap.putAll(map);</span><br><span class=line>                <span class=comment>// 放入缓存中，注意这里的 key是contextName，</span></span><br><span class=line>                <span class=comment>// 这样不同链路进入相同资源，就会创建多个 DefaultNode</span></span><br><span class=line>                cacheMap.put(context.getName(), node);</span><br><span class=line>                map = cacheMap;</span><br><span class=line>                <span class=comment>// 当前节点加入上一节点的 child中，这样就构成了调用链路树</span></span><br><span class=line>                ((DefaultNode) context.getLastNode()).addChild(node);</span><br><span class=line>            }</span><br><span class=line></span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// context中的curNode（当前节点）设置为新的 node</span></span><br><span class=line>    context.setCurNode(node);</span><br><span class=line>    <span class=comment>// 执行下一个 slot</span></span><br><span class=line>    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=line>}</span><br></pre></table></figure><p>这个Slot完成了这么几件事情：<ul><li>为当前资源创建 DefaultNode<li>将DefaultNode放入缓存中，key是contextName，这样不同链路入口的请求，将会创建多个DefaultNode，相同链路则只有一个DefaultNode<li>将当前资源的DefaultNode设置为上一个资源的childNode<li>将当前资源的DefaultNode设置为Context中的curNode（当前节点）</ul><p>下一个slot，就是ClusterBuilderSlot<h2 id=2-4-ClusterBuilderSlot><a class=headerlink href=#2-4-ClusterBuilderSlot title=2.4.ClusterBuilderSlot></a>2.4.ClusterBuilderSlot</h2><p>ClusterBuilderSlot负责构建某个资源的ClusterNode，核心代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">entry</span><span class=params>(Context context, ResourceWrapper resourceWrapper, DefaultNode node,</span></span><br><span class=line><span class=params>                  <span class=type>int</span> count, <span class=type>boolean</span> prioritized, Object... args)</span></span><br><span class=line>    <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=comment>// 判空，注意ClusterNode是共享的成员变量，也就是说一个资源只有一个ClusterNode，与链路无关</span></span><br><span class=line>    <span class=keyword>if</span> (clusterNode == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>synchronized</span> (lock) {</span><br><span class=line>            <span class=keyword>if</span> (clusterNode == <span class=literal>null</span>) {</span><br><span class=line>                <span class=comment>// 创建 cluster node.</span></span><br><span class=line>                clusterNode = <span class=keyword>new</span> <span class="title class_">ClusterNode</span>(resourceWrapper.getName(), resourceWrapper.getResourceType());</span><br><span class=line>                HashMap&LTResourceWrapper, ClusterNode> newMap = <span class=keyword>new</span> <span class="title class_">HashMap</span><>(Math.max(clusterNodeMap.size(), <span class=number>16</span>));</span><br><span class=line>                newMap.putAll(clusterNodeMap);</span><br><span class=line>                <span class=comment>// 放入缓存，可以是nodeId，也就是resource名称</span></span><br><span class=line>                newMap.put(node.getId(), clusterNode);</span><br><span class=line>                clusterNodeMap = newMap;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 将资源的 DefaultNode与 ClusterNode关联</span></span><br><span class=line>    node.setClusterNode(clusterNode);</span><br><span class=line>	<span class=comment>// 记录请求来源 origin 将 origin放入 entry</span></span><br><span class=line>    <span class=keyword>if</span> (!<span class=string>""</span>.equals(context.getOrigin())) {</span><br><span class=line>        <span class=type>Node</span> <span class=variable>originNode</span> <span class=operator>=</span> node.getClusterNode().getOrCreateOriginNode(context.getOrigin());</span><br><span class=line>        context.getCurEntry().setOriginNode(originNode);</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 继续下一个slot</span></span><br><span class=line>    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=line>}</span><br></pre></table></figure><h2 id=2-5-StatisticSlot><a class=headerlink href=#2-5-StatisticSlot title=2.5.StatisticSlot></a>2.5.StatisticSlot</h2><p>StatisticSlot负责统计实时调用数据，包括运行信息（访问次数、线程数）、来源信息等。<p>StatisticSlot是实现限流的关键，其中<strong>基于滑动时间窗口算法维护了计数器，统计进入某个资源的请求次数。</strong><p>核心代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">entry</span><span class=params>(Context context, ResourceWrapper resourceWrapper, DefaultNode node, </span></span><br><span class=line><span class=params>                  <span class=type>int</span> count, <span class=type>boolean</span> prioritized, Object... args)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        <span class=comment>// 放行到下一个 slot，做限流、降级等判断</span></span><br><span class=line>        fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 请求通过了, 线程计数器 +1 ，用作线程隔离</span></span><br><span class=line>        node.increaseThreadNum();</span><br><span class=line>        <span class=comment>// 请求计数器 +1 用作限流</span></span><br><span class=line>        node.addPassRequest(count);</span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> (context.getCurEntry().getOriginNode() != <span class=literal>null</span>) {</span><br><span class=line>            <span class=comment>// 如果有 origin，来源计数器也都要 +1</span></span><br><span class=line>            context.getCurEntry().getOriginNode().increaseThreadNum();</span><br><span class=line>            context.getCurEntry().getOriginNode().addPassRequest(count);</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=keyword>if</span> (resourceWrapper.getEntryType() == EntryType.IN) {</span><br><span class=line>            <span class=comment>// 如果是入口资源，还要给全局计数器 +1.</span></span><br><span class=line>            Constants.ENTRY_NODE.increaseThreadNum();</span><br><span class=line>            Constants.ENTRY_NODE.addPassRequest(count);</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=comment>// 请求通过后的回调.</span></span><br><span class=line>        <span class=keyword>for</span> (ProcessorSlotEntryCallback&LTDefaultNode> handler : StatisticSlotCallbackRegistry.getEntryCallbacks()) {</span><br><span class=line>            handler.onPass(context, resourceWrapper, node, count, args);</span><br><span class=line>        }</span><br><span class=line>    } <span class=keyword>catch</span> (Throwable e) {</span><br><span class=line>        <span class=comment>// 各种异常处理就省略了。。。</span></span><br><span class=line>        context.getCurEntry().setError(e);</span><br><span class=line></span><br><span class=line>        <span class=keyword>throw</span> e;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>另外，需要注意的是，所有的计数+1动作都包括两部分，以<code> node.addPassRequest(count);</code>为例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">addPassRequest</span><span class=params>(<span class=type>int</span> count)</span> {</span><br><span class=line>    <span class=comment>// DefaultNode的计数器，代表当前链路的 计数器</span></span><br><span class=line>    <span class=built_in>super</span>.addPassRequest(count);</span><br><span class=line>    <span class=comment>// ClusterNode计数器，代表当前资源的 总计数器</span></span><br><span class=line>    <span class=built_in>this</span>.clusterNode.addPassRequest(count);</span><br><span class=line>}</span><br></pre></table></figure><p>具体计数方式，我们后续再看。<p>接下来，进入规则校验的相关slot了，依次是：<ul><li>AuthoritySlot：负责授权规则（来源控制）<li>SystemSlot：负责系统保护规则<li>ParamFlowSlot：负责热点参数限流规则<li>FlowSlot：负责限流规则<li>DegradeSlot：负责降级规则</ul><h2 id=2-6-AuthoritySlot><a class=headerlink href=#2-6-AuthoritySlot title=2.6.AuthoritySlot></a>2.6.AuthoritySlot</h2><p>核心API：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">entry</span><span class=params>(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class=type>int</span> count, <span class=type>boolean</span> prioritized, Object... args)</span></span><br><span class=line>    <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=comment>// 校验黑白名单</span></span><br><span class=line>    checkBlackWhiteAuthority(resourceWrapper, context);</span><br><span class=line>    <span class=comment>// 进入下一个 slot</span></span><br><span class=line>    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=line>}</span><br></pre></table></figure><p>黑白名单校验的逻辑：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> <span class="title function_">checkBlackWhiteAuthority</span><span class=params>(ResourceWrapper resource, Context context)</span> <span class=keyword>throws</span> AuthorityException {</span><br><span class=line>    <span class=comment>// 获取授权规则</span></span><br><span class=line>    Map&LTString, Set&LTAuthorityRule>> authorityRules = AuthorityRuleManager.getAuthorityRules();</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (authorityRules == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    Set&LTAuthorityRule> rules = authorityRules.get(resource.getName());</span><br><span class=line>    <span class=keyword>if</span> (rules == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 遍历规则并判断</span></span><br><span class=line>    <span class=keyword>for</span> (AuthorityRule rule : rules) {</span><br><span class=line>        <span class=keyword>if</span> (!AuthorityRuleChecker.passCheck(rule, context)) {</span><br><span class=line>            <span class=comment>// 规则不通过，直接抛出异常</span></span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">AuthorityException</span>(context.getOrigin(), rule);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>再看下<code>AuthorityRuleChecker.passCheck(rule, context)</code>方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line><span class=keyword>static</span> <span class=type>boolean</span> <span class="title function_">passCheck</span><span class=params>(AuthorityRule rule, Context context)</span> {</span><br><span class=line>    <span class=comment>// 得到请求来源 origin</span></span><br><span class=line>    <span class=type>String</span> <span class=variable>requester</span> <span class=operator>=</span> context.getOrigin();</span><br><span class=line></span><br><span class=line>    <span class=comment>// 来源为空，或者规则为空，都直接放行</span></span><br><span class=line>    <span class=keyword>if</span> (StringUtil.isEmpty(requester) || StringUtil.isEmpty(rule.getLimitApp())) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// rule.getLimitApp()得到的就是 白名单 或 黑名单 的字符串，这里先用 indexOf方法判断</span></span><br><span class=line>    <span class=type>int</span> <span class=variable>pos</span> <span class=operator>=</span> rule.getLimitApp().indexOf(requester);</span><br><span class=line>    <span class=type>boolean</span> <span class=variable>contain</span> <span class=operator>=</span> pos > -<span class=number>1</span>;</span><br><span class=line></span><br><span class=line>    <span class=keyword>if</span> (contain) {</span><br><span class=line>        <span class=comment>// 如果包含 origin，还要进一步做精确判断，把名单列表以","分割，逐个判断</span></span><br><span class=line>        <span class=type>boolean</span> <span class=variable>exactlyMatch</span> <span class=operator>=</span> <span class=literal>false</span>;</span><br><span class=line>        String[] appArray = rule.getLimitApp().split(<span class=string>","</span>);</span><br><span class=line>        <span class=keyword>for</span> (String app : appArray) {</span><br><span class=line>            <span class=keyword>if</span> (requester.equals(app)) {</span><br><span class=line>                exactlyMatch = <span class=literal>true</span>;</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        contain = exactlyMatch;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 如果是黑名单，并且包含origin，则返回false</span></span><br><span class=line>    <span class=type>int</span> <span class=variable>strategy</span> <span class=operator>=</span> rule.getStrategy();</span><br><span class=line>    <span class=keyword>if</span> (strategy == RuleConstant.AUTHORITY_BLACK && contain) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 如果是白名单，并且不包含origin，则返回false</span></span><br><span class=line>    <span class=keyword>if</span> (strategy == RuleConstant.AUTHORITY_WHITE && !contain) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 其它情况返回true</span></span><br><span class=line>    <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>}</span><br></pre></table></figure><h2 id=2-7-SystemSlot><a class=headerlink href=#2-7-SystemSlot title=2.7.SystemSlot></a>2.7.SystemSlot</h2><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">entry</span><span class=params>(Context context, ResourceWrapper resourceWrapper, DefaultNode node, </span></span><br><span class=line><span class=params>                  <span class=type>int</span> count,<span class=type>boolean</span> prioritized, Object... args)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=comment>// 系统规则校验</span></span><br><span class=line>    SystemRuleManager.checkSystem(resourceWrapper);</span><br><span class=line>    <span class=comment>// 进入下一个 slot</span></span><br><span class=line>    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=line>}</span><br></pre></table></figure><p>来看下<code>SystemRuleManager.checkSystem(resourceWrapper);</code>的代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">checkSystem</span><span class=params>(ResourceWrapper resourceWrapper)</span> <span class=keyword>throws</span> BlockException {</span><br><span class=line>    <span class=keyword>if</span> (resourceWrapper == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// Ensure the checking switch is on.</span></span><br><span class=line>    <span class=keyword>if</span> (!checkSystemStatus.get()) {</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 只针对入口资源做校验，其它直接返回</span></span><br><span class=line>    <span class=keyword>if</span> (resourceWrapper.getEntryType() != EntryType.IN) {</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 全局 QPS校验</span></span><br><span class=line>    <span class=type>double</span> <span class=variable>currentQps</span> <span class=operator>=</span> Constants.ENTRY_NODE == <span class=literal>null</span> ? <span class=number>0.0</span> : Constants.ENTRY_NODE.successQps();</span><br><span class=line>    <span class=keyword>if</span> (currentQps > qps) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">SystemBlockException</span>(resourceWrapper.getName(), <span class=string>"qps"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 全局 线程数 校验</span></span><br><span class=line>    <span class=type>int</span> <span class=variable>currentThread</span> <span class=operator>=</span> Constants.ENTRY_NODE == <span class=literal>null</span> ? <span class=number>0</span> : Constants.ENTRY_NODE.curThreadNum();</span><br><span class=line>    <span class=keyword>if</span> (currentThread > maxThread) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">SystemBlockException</span>(resourceWrapper.getName(), <span class=string>"thread"</span>);</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 全局平均 RT校验</span></span><br><span class=line>    <span class=type>double</span> <span class=variable>rt</span> <span class=operator>=</span> Constants.ENTRY_NODE == <span class=literal>null</span> ? <span class=number>0</span> : Constants.ENTRY_NODE.avgRt();</span><br><span class=line>    <span class=keyword>if</span> (rt > maxRt) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">SystemBlockException</span>(resourceWrapper.getName(), <span class=string>"rt"</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 全局 系统负载 校验</span></span><br><span class=line>    <span class=keyword>if</span> (highestSystemLoadIsSet && getCurrentSystemAvgLoad() > highestSystemLoad) {</span><br><span class=line>        <span class=keyword>if</span> (!checkBbr(currentThread)) {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">SystemBlockException</span>(resourceWrapper.getName(), <span class=string>"load"</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 全局 CPU使用率 校验</span></span><br><span class=line>    <span class=keyword>if</span> (highestCpuUsageIsSet && getCurrentCpuUsage() > highestCpuUsage) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">SystemBlockException</span>(resourceWrapper.getName(), <span class=string>"cpu"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=2-8-ParamFlowSlot><a class=headerlink href=#2-8-ParamFlowSlot title=2.8.ParamFlowSlot></a>2.8.ParamFlowSlot</h2><p>是针对进入资源的请求，针对不同的请求参数值分别统计QPS的限流方式。<ul><li><p>这里的单机阈值，就是最大令牌数量：maxCount</p><li><p>这里的统计窗口时长，就是统计时长：duration</p></ul><p>含义是每隔duration时间长度内，最多生产maxCount个令牌，上图配置的含义是每1秒钟生产2个令牌。<p>核心API：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">entry</span><span class=params>(Context context, ResourceWrapper resourceWrapper, DefaultNode node,</span></span><br><span class=line><span class=params>                  <span class=type>int</span> count, <span class=type>boolean</span> prioritized, Object... args)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=comment>// 如果没有设置热点规则，直接放行</span></span><br><span class=line>    <span class=keyword>if</span> (!ParamFlowRuleManager.hasRules(resourceWrapper.getName())) {</span><br><span class=line>        fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 热点规则判断</span></span><br><span class=line>    checkFlow(resourceWrapper, count, args);</span><br><span class=line>    <span class=comment>// 进入下一个 slot</span></span><br><span class=line>    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=line>}</span><br></pre></table></figure><h3 id=2-8-1-令牌桶><a class=headerlink href=#2-8-1-令牌桶 title=2.8.1.令牌桶></a>2.8.1.令牌桶</h3><p>热点规则判断采用了令牌桶算法来实现参数限流，为每一个不同参数值设置令牌桶，Sentinel的令牌桶有两部分组成：<p>这两个Map的key都是请求的参数值，value却不同，其中：<ul><li>tokenCounters：用来记录剩余令牌数量<li>timeCounters：用来记录上一个请求的时间</ul><h2 id=2-9-FlowSlot><a class=headerlink href=#2-9-FlowSlot title=2.9.FlowSlot></a>2.9.FlowSlot</h2><p>包括：<ul><li>三种流控模式：直接模式、关联模式、链路模式<li>三种流控效果：快速失败、warm up、排队等待</ul><p>三种流控模式，从底层<strong>数据统计</strong>角度，分为两类：<ul><li>对进入资源的所有请求（ClusterNode）做限流统计：直接模式、关联模式<li>对进入资源的部分链路（DefaultNode）做限流统计：链路模式</ul><p>三种流控效果，从<strong>限流算法</strong>来看，分为两类：<ul><li>滑动时间窗口算法：快速失败、warm up<li>漏桶算法：排队等待效果</ul><h3 id=2-9-1-核心流程><a class=headerlink href=#2-9-1-核心流程 title=2.9.1.核心流程></a>2.9.1.核心流程</h3><p>核心API如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">entry</span><span class=params>(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class=type>int</span> count,</span></span><br><span class=line><span class=params>                  <span class=type>boolean</span> prioritized, Object... args)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=comment>// 限流规则检测</span></span><br><span class=line>    checkFlow(resourceWrapper, context, node, count, prioritized);</span><br><span class=line>	<span class=comment>// 放行</span></span><br><span class=line>    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=line>}</span><br></pre></table></figure><p>checkFlow方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> <span class="title function_">checkFlow</span><span class=params>(ResourceWrapper resource, Context context, DefaultNode node, <span class=type>int</span> count, <span class=type>boolean</span> prioritized)</span></span><br><span class=line>    <span class=keyword>throws</span> BlockException {</span><br><span class=line>    <span class=comment>// checker是 FlowRuleChecker 类的一个对象</span></span><br><span class=line>    checker.checkFlow(ruleProvider, resource, context, node, count, prioritized);</span><br><span class=line>}</span><br></pre></table></figure><p>跟入FlowRuleChecker：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">checkFlow</span><span class=params>(Function&LTString, Collection&LTFlowRule>> ruleProvider, </span></span><br><span class=line><span class=params>                      ResourceWrapper resource,Context context, DefaultNode node,</span></span><br><span class=line><span class=params>                      <span class=type>int</span> count, <span class=type>boolean</span> prioritized)</span> <span class=keyword>throws</span> BlockException {</span><br><span class=line>        <span class=keyword>if</span> (ruleProvider == <span class=literal>null</span> || resource == <span class=literal>null</span>) {</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 获取当前资源的所有限流规则</span></span><br><span class=line>        Collection&LTFlowRule> rules = ruleProvider.apply(resource.getName());</span><br><span class=line>        <span class=keyword>if</span> (rules != <span class=literal>null</span>) {</span><br><span class=line>            <span class=keyword>for</span> (FlowRule rule : rules) {</span><br><span class=line>                <span class=comment>// 遍历，逐个规则做校验</span></span><br><span class=line>                <span class=keyword>if</span> (!canPassCheck(rule, context, node, count, prioritized)) {</span><br><span class=line>                    <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">FlowException</span>(rule.getLimitApp(), rule);</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br></pre></table></figure><p>这里的FlowRule就是限流规则接口，其中的几个成员变量，刚好对应表单参数：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">FlowRule</span> <span class=keyword>extends</span> <span class="title class_">AbstractRule</span> {</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 阈值类型 (0: 线程, 1: QPS).</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>grade</span> <span class=operator>=</span> RuleConstant.FLOW_GRADE_QPS;</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 阈值.</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>private</span> <span class=type>double</span> count;</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 三种限流模式.</span></span><br><span class=line><span class=comment>     *</span></span><br><span class=line><span class=comment>     * {<span class=doctag>@link</span> RuleConstant#STRATEGY_DIRECT} 直连模式;</span></span><br><span class=line><span class=comment>     * {<span class=doctag>@link</span> RuleConstant#STRATEGY_RELATE} 关联模式;</span></span><br><span class=line><span class=comment>     * {<span class=doctag>@link</span> RuleConstant#STRATEGY_CHAIN} 链路模式.</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>strategy</span> <span class=operator>=</span> RuleConstant.STRATEGY_DIRECT;</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 关联模式关联的资源名称.</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>private</span> String refResource;</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 3种流控效果.</span></span><br><span class=line><span class=comment>     * 0. 快速失败, 1. warm up, 2. 排队等待, 3. warm up + 排队等待</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>controlBehavior</span> <span class=operator>=</span> RuleConstant.CONTROL_BEHAVIOR_DEFAULT;</span><br><span class=line>	<span class=comment>// 预热时长</span></span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>warmUpPeriodSec</span> <span class=operator>=</span> <span class=number>10</span>;</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 队列最大等待时间.</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>maxQueueingTimeMs</span> <span class=operator>=</span> <span class=number>500</span>;</span><br><span class=line>    <span class=comment>// 。。。 略</span></span><br><span class=line>}</span><br></pre></table></figure><p>校验的逻辑定义在<code>FlowRuleChecker</code>的<code>canPassCheck</code>方法中：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">canPassCheck</span><span class=params>(<span class=comment>/*@NonNull*/</span> FlowRule rule, Context context, DefaultNode node, <span class=type>int</span> acquireCount,</span></span><br><span class=line><span class=params>                            <span class=type>boolean</span> prioritized)</span> {</span><br><span class=line>    <span class=comment>// 获取限流资源名称</span></span><br><span class=line>    <span class=type>String</span> <span class=variable>limitApp</span> <span class=operator>=</span> rule.getLimitApp();</span><br><span class=line>    <span class=keyword>if</span> (limitApp == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 校验规则</span></span><br><span class=line>    <span class=keyword>return</span> passLocalCheck(rule, context, node, acquireCount, prioritized);</span><br><span class=line>}</span><br></pre></table></figure><p>进入<code>passLocalCheck()</code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=keyword>static</span> <span class=type>boolean</span> <span class="title function_">passLocalCheck</span><span class=params>(FlowRule rule, Context context, DefaultNode node,</span></span><br><span class=line><span class=params>                                      <span class=type>int</span> acquireCount,  <span class=type>boolean</span> prioritized)</span> {</span><br><span class=line>    <span class=comment>// 基于限流模式判断要统计的节点， </span></span><br><span class=line>    <span class=comment>// 如果是直连模式，关联模式，对ClusterNode统计，如果是链路模式，则对DefaultNode统计</span></span><br><span class=line>    <span class=type>Node</span> <span class=variable>selectedNode</span> <span class=operator>=</span> selectNodeByRequesterAndStrategy(rule, context, node);</span><br><span class=line>    <span class=keyword>if</span> (selectedNode == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 判断规则</span></span><br><span class=line>    <span class=keyword>return</span> rule.getRater().canPass(selectedNode, acquireCount, prioritized);</span><br><span class=line>}</span><br></pre></table></figure><p>这里对规则的判断先要通过<code>FlowRule#getRater()</code>获取流量控制器<code>TrafficShapingController</code>，然后再做限流。<p>而<code>TrafficShapingController</code>有3种实现：<ul><li>DefaultController：快速失败，默认的方式，基于滑动时间窗口算法<li>WarmUpController：预热模式，基于滑动时间窗口算法，只不过阈值是动态的<li>RateLimiterController：排队等待模式，基于漏桶算法</ul><p>最终的限流判断都在TrafficShapingController的canPass方法中。<h3 id=2-9-2-滑动时间窗口><a class=headerlink href=#2-9-2-滑动时间窗口 title=2.9.2.滑动时间窗口></a>2.9.2.滑动时间窗口</h3><p>滑动时间窗口的功能分两部分来看：<ul><li>一是时间区间窗口的QPS计数功能，这个是在StatisticSlot中调用的<li>二是对滑动窗口内的时间区间窗口QPS累加，这个是在FlowRule中调用的</ul><p>先来看时间区间窗口的QPS计数功能。<h4 id=2-9-2-1-时间窗口请求量统计><a class=headerlink href=#2-9-2-1-时间窗口请求量统计 title=2.9.2.1.时间窗口请求量统计></a>2.9.2.1.时间窗口请求量统计</h4><p>回顾2.5章节中的StatisticSlot部分，有这样一段代码：<p><img alt=image-20210925180522926 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925180522926.png><p>就是在统计通过该节点的QPS，我们跟入看看，这里进入了DefaultNode内部：<p><img alt=image-20210925180619492 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925180619492.png><p>发现同时对<code>DefaultNode</code>和<code>ClusterNode</code>在做QPS统计，我们知道<code>DefaultNode</code>和<code>ClusterNode</code>都是<code>StatisticNode</code>的子类，这里调用<code>addPassRequest()</code>方法，最终都会进入<code>StatisticNode</code>中。<p>随便跟入一个：<p><img alt=image-20210925180810181 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925180810181.png><p>这里有秒、分两种纬度的统计，对应两个计数器。找到对应的成员变量，可以看到：<p><img alt=image-20210925180954856 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925180954856.png><p>两个计数器都是ArrayMetric类型，并且传入了两个参数：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment>// intervalInMs：是滑动窗口的时间间隔，默认为 1 秒</span></span><br><span class=line><span class=comment>// sampleCount: 时间窗口的分隔数量，默认为 2，就是把 1秒分为 2个小时间窗</span></span><br><span class=line><span class=keyword>public</span> <span class="title function_">ArrayMetric</span><span class=params>(<span class=type>int</span> sampleCount, <span class=type>int</span> intervalInMs)</span> {</span><br><span class=line>    <span class=built_in>this</span>.data = <span class=keyword>new</span> <span class="title class_">OccupiableBucketLeapArray</span>(sampleCount, intervalInMs);</span><br><span class=line>}</span><br></pre></table></figure><p>如图：<p><img alt=image-20210925181359203 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925181359203.png><p>接下来，我们进入<code>ArrayMetric</code>类的<code>addPass</code>方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">addPass</span><span class=params>(<span class=type>int</span> count)</span> {</span><br><span class=line>    <span class=comment>// 获取当前时间所在的时间窗</span></span><br><span class=line>    WindowWrap&LTMetricBucket> wrap = data.currentWindow();</span><br><span class=line>    <span class=comment>// 计数器 +1</span></span><br><span class=line>    wrap.value().addPass(count);</span><br><span class=line>}</span><br></pre></table></figure><p>那么，计数器如何知道当前所在的窗口是哪个呢？<p>这里的data是一个LeapArray：<p><img alt=image-20210925181714605 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925181714605.png><p>LeapArray的四个属性：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">LeapArray</span>&LTT> {</span><br><span class=line>    <span class=comment>// 小窗口的时间长度，默认是500ms ，值 = intervalInMs / sampleCount</span></span><br><span class=line>    <span class=keyword>protected</span> <span class=type>int</span> windowLengthInMs;</span><br><span class=line>    <span class=comment>// 滑动窗口内的 小窗口 数量，默认为 2</span></span><br><span class=line>    <span class=keyword>protected</span> <span class=type>int</span> sampleCount;</span><br><span class=line>    <span class=comment>// 滑动窗口的时间间隔，默认为 1000ms</span></span><br><span class=line>    <span class=keyword>protected</span> <span class=type>int</span> intervalInMs;</span><br><span class=line>    <span class=comment>// 滑动窗口的时间间隔，单位为秒，默认为 1</span></span><br><span class=line>    <span class=keyword>private</span> <span class=type>double</span> intervalInSecond;</span><br><span class=line>}</span><br></pre></table></figure><p>LeapArray是一个环形数组，因为时间是无限的，数组长度不可能无限，因此数组中每一个格子放入一个时间窗（window），当数组放满后，角标归0，覆盖最初的window。<p><img alt=image-20210925182127206 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925182127206.png><p>因为滑动窗口最多分成sampleCount数量的小窗口，因此数组长度只要大于sampleCount，那么最近的一个滑动窗口内的2个小窗口就永远不会被覆盖，就不用担心旧数据被覆盖的问题了。<p>我们跟入<code> data.currentWindow();</code>方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> WindowWrap&LTT> <span class="title function_">currentWindow</span><span class=params>(<span class=type>long</span> timeMillis)</span> {</span><br><span class=line>    <span class=keyword>if</span> (timeMillis < <span class=number>0</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 计算当前时间对应的数组角标</span></span><br><span class=line>    <span class=type>int</span> <span class=variable>idx</span> <span class=operator>=</span> calculateTimeIdx(timeMillis);</span><br><span class=line>    <span class=comment>// 计算当前时间所在窗口的开始时间.</span></span><br><span class=line>    <span class=type>long</span> <span class=variable>windowStart</span> <span class=operator>=</span> calculateWindowStart(timeMillis);</span><br><span class=line></span><br><span class=line>    <span class=comment>/*</span></span><br><span class=line><span class=comment>         * 先根据角标获取数组中保存的 oldWindow 对象，可能是旧数据，需要判断.</span></span><br><span class=line><span class=comment>         *</span></span><br><span class=line><span class=comment>         * (1) oldWindow 不存在, 说明是第一次，创建新 window并存入，然后返回即可</span></span><br><span class=line><span class=comment>         * (2) oldWindow的 starTime = 本次请求的 windowStar, 说明正是要找的窗口，直接返回.</span></span><br><span class=line><span class=comment>         * (3) oldWindow的 starTime < 本次请求的 windowStar, 说明是旧数据，需要被覆盖，创建 </span></span><br><span class=line><span class=comment>         *     新窗口，覆盖旧窗口</span></span><br><span class=line><span class=comment>         */</span></span><br><span class=line>    <span class=keyword>while</span> (<span class=literal>true</span>) {</span><br><span class=line>        WindowWrap&LTT> old = array.get(idx);</span><br><span class=line>        <span class=keyword>if</span> (old == <span class=literal>null</span>) {</span><br><span class=line>            <span class=comment>// 创建新 window</span></span><br><span class=line>            WindowWrap&LTT> window = <span class=keyword>new</span> <span class="title class_">WindowWrap</span>&LTT>(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));</span><br><span class=line>            <span class=comment>// 基于CAS写入数组，避免线程安全问题</span></span><br><span class=line>            <span class=keyword>if</span> (array.compareAndSet(idx, <span class=literal>null</span>, window)) {</span><br><span class=line>                <span class=comment>// 写入成功，返回新的 window</span></span><br><span class=line>                <span class=keyword>return</span> window;</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=comment>// 写入失败，说明有并发更新，等待其它人更新完成即可</span></span><br><span class=line>                Thread.<span class=keyword>yield</span>();</span><br><span class=line>            }</span><br><span class=line>        } <span class=keyword>else</span> <span class=keyword>if</span> (windowStart == old.windowStart()) {</span><br><span class=line>            <span class=keyword>return</span> old;</span><br><span class=line>        } <span class=keyword>else</span> <span class=keyword>if</span> (windowStart > old.windowStart()) {</span><br><span class=line>            <span class=keyword>if</span> (updateLock.tryLock()) {</span><br><span class=line>                <span class=keyword>try</span> {</span><br><span class=line>                    <span class=comment>// 获取并发锁，覆盖旧窗口并返回</span></span><br><span class=line>                    <span class=keyword>return</span> resetWindowTo(old, windowStart);</span><br><span class=line>                } <span class=keyword>finally</span> {</span><br><span class=line>                    updateLock.unlock();</span><br><span class=line>                }</span><br><span class=line>            } <span class=keyword>else</span> {</span><br><span class=line>                <span class=comment>// 获取锁失败，等待其它线程处理就可以了</span></span><br><span class=line>                Thread.<span class=keyword>yield</span>();</span><br><span class=line>            }</span><br><span class=line>        } <span class=keyword>else</span> <span class=keyword>if</span> (windowStart < old.windowStart()) {</span><br><span class=line>            <span class=comment>// 这种情况不应该存在，写这里只是以防万一。</span></span><br><span class=line>            <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">WindowWrap</span>&LTT>(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>找到当前时间所在窗口（WindowWrap）后，只要调用WindowWrap对象中的add方法，计数器+1即可。<p>这里只负责统计每个窗口的请求量，不负责拦截。限流拦截要看FlowSlot中的逻辑。<h4 id=2-9-2-2-滑动窗口QPS计算><a class=headerlink href=#2-9-2-2-滑动窗口QPS计算 title=2.9.2.2.滑动窗口QPS计算></a>2.9.2.2.滑动窗口QPS计算</h4><p>在2.9.1小节我们讲过，FlowSlot的限流判断最终都由<code>TrafficShapingController</code>接口中的<code>canPass</code>方法来实现。该接口有三个实现类：<ul><li>DefaultController：快速失败，默认的方式，基于滑动时间窗口算法。<li>WarmUpController：预热模式，基于滑动时间窗口算法，只不过阈值是动态的。<li>RateLimiterController：排队等待模式，基于漏桶算法</ul><p>因此，我们跟入默认的DefaultController中的canPass方法来分析：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">canPass</span><span class=params>(Node node, <span class=type>int</span> acquireCount, <span class=type>boolean</span> prioritized)</span> {</span><br><span class=line>    <span class=comment>// 计算目前为止滑动窗口内已经存在的请求量</span></span><br><span class=line>    <span class=type>int</span> <span class=variable>curCount</span> <span class=operator>=</span> avgUsedTokens(node);</span><br><span class=line>    <span class=comment>// 判断：已使用请求量 + 需要的请求量（1） 是否大于 窗口的请求阈值</span></span><br><span class=line>    <span class=keyword>if</span> (curCount + acquireCount > count) {</span><br><span class=line>        <span class=comment>// 大于，说明超出阈值，返回false</span></span><br><span class=line>        <span class=keyword>if</span> (prioritized && grade == RuleConstant.FLOW_GRADE_QPS) {</span><br><span class=line>            <span class=type>long</span> currentTime;</span><br><span class=line>            <span class=type>long</span> waitInMs;</span><br><span class=line>            currentTime = TimeUtil.currentTimeMillis();</span><br><span class=line>            waitInMs = node.tryOccupyNext(currentTime, acquireCount, count);</span><br><span class=line>            <span class=keyword>if</span> (waitInMs < OccupyTimeoutProperty.getOccupyTimeout()) {</span><br><span class=line>                node.addWaitingRequest(currentTime + waitInMs, acquireCount);</span><br><span class=line>                node.addOccupiedPass(acquireCount);</span><br><span class=line>                sleep(waitInMs);</span><br><span class=line></span><br><span class=line>                <span class=comment>// PriorityWaitException indicates that the request will pass after waiting for {@link @waitInMs}.</span></span><br><span class=line>                <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">PriorityWaitException</span>(waitInMs);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 小于等于，说明在阈值范围内，返回true</span></span><br><span class=line>    <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>因此，判断的关键就是<code>int curCount = avgUsedTokens(node);</code><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=type>int</span> <span class="title function_">avgUsedTokens</span><span class=params>(Node node)</span> {</span><br><span class=line>    <span class=keyword>if</span> (node == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>return</span> DEFAULT_AVG_USED_TOKENS;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> grade == RuleConstant.FLOW_GRADE_THREAD ? node.curThreadNum() : (<span class=type>int</span>)(node.passQps());</span><br><span class=line>}</span><br></pre></table></figure><p>因为我们采用的是限流，走<code>node.passQps()</code>逻辑：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>// 这里又进入了 StatisticNode类</span></span><br><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=type>double</span> <span class="title function_">passQps</span><span class=params>()</span> {</span><br><span class=line>    <span class=comment>// 请求量 ÷ 滑动窗口时间间隔 ，得到的就是QPS</span></span><br><span class=line>    <span class=keyword>return</span> rollingCounterInSecond.pass() / rollingCounterInSecond.getWindowIntervalInSec();</span><br><span class=line>}</span><br></pre></table></figure><p>那么<code>rollingCounterInSecond.pass()</code>是如何得到请求量的呢？<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=comment>// rollingCounterInSecond 本质是ArrayMetric，之前说过</span></span><br><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=type>long</span> <span class="title function_">pass</span><span class=params>()</span> {</span><br><span class=line>    <span class=comment>// 获取当前窗口</span></span><br><span class=line>    data.currentWindow();</span><br><span class=line>    <span class=type>long</span> <span class=variable>pass</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=comment>// 获取 当前时间的 滑动窗口范围内 的所有小窗口</span></span><br><span class=line>    List&LTMetricBucket> list = data.values();</span><br><span class=line>	<span class=comment>// 遍历</span></span><br><span class=line>    <span class=keyword>for</span> (MetricBucket window : list) {</span><br><span class=line>        <span class=comment>// 累加求和</span></span><br><span class=line>        pass += window.pass();</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 返回</span></span><br><span class=line>    <span class=keyword>return</span> pass;</span><br><span class=line>}</span><br></pre></table></figure><p>来看看<code>data.values()</code>如何获取 滑动窗口范围内 的所有小窗口：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=comment>// 此处进入LeapArray类中：</span></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> List&LTT> <span class="title function_">values</span><span class=params>(<span class=type>long</span> timeMillis)</span> {</span><br><span class=line>    <span class=keyword>if</span> (timeMillis < <span class=number>0</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">ArrayList</span>&LTT>();</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 创建空集合，大小等于 LeapArray长度</span></span><br><span class=line>    <span class=type>int</span> <span class=variable>size</span> <span class=operator>=</span> array.length();</span><br><span class=line>    List&LTT> result = <span class=keyword>new</span> <span class="title class_">ArrayList</span>&LTT>(size);</span><br><span class=line>	<span class=comment>// 遍历 LeapArray</span></span><br><span class=line>    <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < size; i++) {</span><br><span class=line>        <span class=comment>// 获取每一个小窗口</span></span><br><span class=line>        WindowWrap&LTT> windowWrap = array.get(i);</span><br><span class=line>        <span class=comment>// 判断这个小窗口是否在 滑动窗口时间范围内（1秒内）</span></span><br><span class=line>        <span class=keyword>if</span> (windowWrap == <span class=literal>null</span> || isWindowDeprecated(timeMillis, windowWrap)) {</span><br><span class=line>            <span class=comment>// 不在范围内，则跳过</span></span><br><span class=line>            <span class=keyword>continue</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 在范围内，则添加到集合中</span></span><br><span class=line>        result.add(windowWrap.value());</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 返回集合</span></span><br><span class=line>    <span class=keyword>return</span> result;</span><br><span class=line>}</span><br></pre></table></figure><p>那么，<code>isWindowDeprecated(timeMillis, windowWrap)</code>又是如何判断窗口是否符合要求呢？<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">isWindowDeprecated</span><span class=params>(<span class=type>long</span> time, WindowWrap&LTT> windowWrap)</span> {</span><br><span class=line>    <span class=comment>// 当前时间 - 窗口开始时间  是否大于 滑动窗口的最大间隔（1秒）</span></span><br><span class=line>    <span class=comment>// 也就是说，我们要统计的时 距离当前时间1秒内的 小窗口的 count之和</span></span><br><span class=line>    <span class=keyword>return</span> time - windowWrap.windowStart() > intervalInMs;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=2-9-3-漏桶><a class=headerlink href=#2-9-3-漏桶 title=2.9.3.漏桶></a>2.9.3.漏桶</h3><p>上一节我们讲过，FlowSlot的限流判断最终都由<code>TrafficShapingController</code>接口中的<code>canPass</code>方法来实现。该接口有三个实现类：<ul><li>DefaultController：快速失败，默认的方式，基于滑动时间窗口算法<li>WarmUpController：预热模式，基于滑动时间窗口算法，只不过阈值是动态的<li>RateLimiterController：排队等待模式，基于漏桶算法</ul><p>因此，我们跟入默认的RateLimiterController中的canPass方法来分析：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">canPass</span><span class=params>(Node node, <span class=type>int</span> acquireCount, <span class=type>boolean</span> prioritized)</span> {</span><br><span class=line>    <span class=comment>// Pass when acquire count is less or equal than 0.</span></span><br><span class=line>    <span class=keyword>if</span> (acquireCount <= <span class=number>0</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 阈值小于等于 0 ，阻止请求</span></span><br><span class=line>    <span class=keyword>if</span> (count <= <span class=number>0</span>) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 获取当前时间</span></span><br><span class=line>    <span class=type>long</span> <span class=variable>currentTime</span> <span class=operator>=</span> TimeUtil.currentTimeMillis();</span><br><span class=line>    <span class=comment>// 计算两次请求之间允许的最小时间间隔</span></span><br><span class=line>    <span class=type>long</span> <span class=variable>costTime</span> <span class=operator>=</span> Math.round(<span class=number>1.0</span> * (acquireCount) / count * <span class=number>1000</span>);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 计算本次请求 允许执行的时间点 = 最近一次请求的可执行时间 + 两次请求的最小间隔</span></span><br><span class=line>    <span class=type>long</span> <span class=variable>expectedTime</span> <span class=operator>=</span> costTime + latestPassedTime.get();</span><br><span class=line>	<span class=comment>// 如果允许执行的时间点小于当前时间，说明可以立即执行</span></span><br><span class=line>    <span class=keyword>if</span> (expectedTime <= currentTime) {</span><br><span class=line>        <span class=comment>// 更新上一次的请求的执行时间</span></span><br><span class=line>        latestPassedTime.set(currentTime);</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>        <span class=comment>// 不能立即执行，需要计算 预期等待时长</span></span><br><span class=line>        <span class=comment>// 预期等待时长 = 两次请求的最小间隔 +最近一次请求的可执行时间 - 当前时间</span></span><br><span class=line>        <span class=type>long</span> <span class=variable>waitTime</span> <span class=operator>=</span> costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();</span><br><span class=line>        <span class=comment>// 如果预期等待时间超出阈值，则拒绝请求</span></span><br><span class=line>        <span class=keyword>if</span> (waitTime > maxQueueingTimeMs) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=comment>// 预期等待时间小于阈值，更新最近一次请求的可执行时间，加上costTime</span></span><br><span class=line>            <span class=type>long</span> <span class=variable>oldTime</span> <span class=operator>=</span> latestPassedTime.addAndGet(costTime);</span><br><span class=line>            <span class=keyword>try</span> {</span><br><span class=line>                <span class=comment>// 保险起见，再判断一次预期等待时间，是否超过阈值</span></span><br><span class=line>                waitTime = oldTime - TimeUtil.currentTimeMillis();</span><br><span class=line>                <span class=keyword>if</span> (waitTime > maxQueueingTimeMs) {</span><br><span class=line>                    <span class=comment>// 如果超过，则把刚才 加 的时间再 减回来</span></span><br><span class=line>                    latestPassedTime.addAndGet(-costTime);</span><br><span class=line>                    <span class=comment>// 拒绝</span></span><br><span class=line>                    <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>                }</span><br><span class=line>                <span class=comment>// in race condition waitTime may <= 0</span></span><br><span class=line>                <span class=keyword>if</span> (waitTime > <span class=number>0</span>) {</span><br><span class=line>                    <span class=comment>// 预期等待时间在阈值范围内，休眠要等待的时间，醒来后继续执行</span></span><br><span class=line>                    Thread.sleep(waitTime);</span><br><span class=line>                }</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>            } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>与我们之前分析的漏桶算法基本一致：<p><img alt=image-20210925210716675 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925210716675.png><h2 id=2-10-DegradeSlot><a class=headerlink href=#2-10-DegradeSlot title=2.10.DegradeSlot></a>2.10.DegradeSlot</h2><p>最后一关，就是降级规则判断了。<p>Sentinel的降级是基于状态机来实现的：<p><img alt=image-20210925211020881 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925211020881.png><p>对应的实现在DegradeSlot类中，核心API：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">entry</span><span class=params>(Context context, ResourceWrapper resourceWrapper, DefaultNode node, </span></span><br><span class=line><span class=params>                  <span class=type>int</span> count, <span class=type>boolean</span> prioritized, Object... args)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=comment>// 熔断降级规则判断</span></span><br><span class=line>    performChecking(context, resourceWrapper);</span><br><span class=line>	<span class=comment>// 继续下一个slot</span></span><br><span class=line>    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class=line>}</span><br></pre></table></figure><p>继续进入<code>performChecking</code>方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> <span class="title function_">performChecking</span><span class=params>(Context context, ResourceWrapper r)</span> <span class=keyword>throws</span> BlockException {</span><br><span class=line>    <span class=comment>// 获取当前资源上的所有的断路器 CircuitBreaker</span></span><br><span class=line>    List&LTCircuitBreaker> circuitBreakers = DegradeRuleManager.getCircuitBreakers(r.getName());</span><br><span class=line>    <span class=keyword>if</span> (circuitBreakers == <span class=literal>null</span> || circuitBreakers.isEmpty()) {</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>for</span> (CircuitBreaker cb : circuitBreakers) {</span><br><span class=line>        <span class=comment>// 遍历断路器，逐个判断</span></span><br><span class=line>        <span class=keyword>if</span> (!cb.tryPass(context)) {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">DegradeException</span>(cb.getRule().getLimitApp(), cb.getRule());</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=2-10-1-CircuitBreaker><a class=headerlink href=#2-10-1-CircuitBreaker title=2.10.1.CircuitBreaker></a>2.10.1.CircuitBreaker</h3><p>我们进入CircuitBreaker的tryPass方法中：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">tryPass</span><span class=params>(Context context)</span> {</span><br><span class=line>    <span class=comment>// 判断状态机状态</span></span><br><span class=line>    <span class=keyword>if</span> (currentState.get() == State.CLOSED) {</span><br><span class=line>        <span class=comment>// 如果是closed状态，直接放行</span></span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>if</span> (currentState.get() == State.OPEN) {</span><br><span class=line>        <span class=comment>// 如果是OPEN状态，断路器打开</span></span><br><span class=line>        <span class=comment>// 继续判断OPEN时间窗是否结束，如果是则把状态从OPEN切换到 HALF_OPEN，返回true</span></span><br><span class=line>        <span class=keyword>return</span> retryTimeoutArrived() && fromOpenToHalfOpen(context);</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// OPEN状态，并且时间窗未到，返回false</span></span><br><span class=line>    <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>有关时间窗的判断在<code>retryTimeoutArrived()</code>方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>protected</span> <span class=type>boolean</span> <span class="title function_">retryTimeoutArrived</span><span class=params>()</span> {</span><br><span class=line>    <span class=comment>// 当前时间 大于 下一次 HalfOpen的重试时间</span></span><br><span class=line>    <span class=keyword>return</span> TimeUtil.currentTimeMillis() >= nextRetryTimestamp;</span><br><span class=line>}</span><br></pre></table></figure><p>OPEN到HALF_OPEN切换在<code>fromOpenToHalfOpen(context)</code>方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=keyword>protected</span> <span class=type>boolean</span> <span class="title function_">fromOpenToHalfOpen</span><span class=params>(Context context)</span> {</span><br><span class=line>    <span class=comment>// 基于CAS修改状态，从 OPEN到 HALF_OPEN</span></span><br><span class=line>    <span class=keyword>if</span> (currentState.compareAndSet(State.OPEN, State.HALF_OPEN)) {</span><br><span class=line>        <span class=comment>// 状态变更的事件通知</span></span><br><span class=line>        notifyObservers(State.OPEN, State.HALF_OPEN, <span class=literal>null</span>);</span><br><span class=line>        <span class=comment>// 得到当前资源</span></span><br><span class=line>        <span class=type>Entry</span> <span class=variable>entry</span> <span class=operator>=</span> context.getCurEntry();</span><br><span class=line>        <span class=comment>// 给资源设置监听器，在资源Entry销毁时（资源业务执行完毕时）触发</span></span><br><span class=line>        entry.whenTerminate(<span class=keyword>new</span> <span class="title class_">BiConsumer</span>&LTContext, Entry>() {</span><br><span class=line>            <span class=meta>@Override</span></span><br><span class=line>            <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">accept</span><span class=params>(Context context, Entry entry)</span> {</span><br><span class=line>                <span class=comment>// 判断 资源业务是否异常</span></span><br><span class=line>                <span class=keyword>if</span> (entry.getBlockError() != <span class=literal>null</span>) {</span><br><span class=line>                    <span class=comment>// 如果异常，则再次进入OPEN状态</span></span><br><span class=line>                    currentState.compareAndSet(State.HALF_OPEN, State.OPEN);</span><br><span class=line>                    notifyObservers(State.HALF_OPEN, State.OPEN, <span class=number>1.0d</span>);</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        });</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>这里出现了从OPEN到HALF_OPEN、从HALF_OPEN到OPEN的变化，但是还有几个没有：<ul><li>从CLOSED到OPEN<li>从HALF_OPEN到CLOSED</ul><h3 id=2-10-2-触发断路器><a class=headerlink href=#2-10-2-触发断路器 title=2.10.2.触发断路器></a>2.10.2.触发断路器</h3><p>请求经过所有插槽 后，一定会执行exit方法，而在DegradeSlot的exit方法中：<p><img alt=image-20210925213440686 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925213440686.png><p>会调用CircuitBreaker的onRequestComplete方法。而CircuitBreaker有两个实现：<p><img alt=image-20210925213939035 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210925213939035.png><p>我们这里以异常比例熔断为例来看，进入<code>ExceptionCircuitBreaker</code>的<code>onRequestComplete</code>方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">onRequestComplete</span><span class=params>(Context context)</span> {</span><br><span class=line>    <span class=comment>// 获取资源 Entry</span></span><br><span class=line>    <span class=type>Entry</span> <span class=variable>entry</span> <span class=operator>=</span> context.getCurEntry();</span><br><span class=line>    <span class=keyword>if</span> (entry == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 尝试获取 资源中的 异常</span></span><br><span class=line>    <span class=type>Throwable</span> <span class=variable>error</span> <span class=operator>=</span> entry.getError();</span><br><span class=line>    <span class=comment>// 获取计数器，同样采用了滑动窗口来计数</span></span><br><span class=line>    <span class=type>SimpleErrorCounter</span> <span class=variable>counter</span> <span class=operator>=</span> stat.currentWindow().value();</span><br><span class=line>    <span class=keyword>if</span> (error != <span class=literal>null</span>) {</span><br><span class=line>        <span class=comment>// 如果出现异常，则 error计数器 +1</span></span><br><span class=line>        counter.getErrorCount().add(<span class=number>1</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 不管是否出现异常，total计数器 +1</span></span><br><span class=line>    counter.getTotalCount().add(<span class=number>1</span>);</span><br><span class=line>	<span class=comment>// 判断异常比例是否超出阈值</span></span><br><span class=line>    handleStateChangeWhenThresholdExceeded(error);</span><br><span class=line>}</span><br></pre></table></figure><p>来看阈值判断的方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">handleStateChangeWhenThresholdExceeded</span><span class=params>(Throwable error)</span> {</span><br><span class=line>    <span class=comment>// 如果当前已经是OPEN状态，不做处理</span></span><br><span class=line>    <span class=keyword>if</span> (currentState.get() == State.OPEN) {</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 如果已经是 HALF_OPEN 状态，判断是否需求切换状态</span></span><br><span class=line>    <span class=keyword>if</span> (currentState.get() == State.HALF_OPEN) {</span><br><span class=line>        <span class=keyword>if</span> (error == <span class=literal>null</span>) {</span><br><span class=line>            <span class=comment>// 没有异常，则从 HALF_OPEN 到 CLOSED</span></span><br><span class=line>            fromHalfOpenToClose();</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=comment>// 有一次，再次进入OPEN</span></span><br><span class=line>            fromHalfOpenToOpen(<span class=number>1.0d</span>);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line>	<span class=comment>// 说明当前是CLOSE状态，需要判断是否触发阈值</span></span><br><span class=line>    List&LTSimpleErrorCounter> counters = stat.values();</span><br><span class=line>    <span class=type>long</span> <span class=variable>errCount</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=type>long</span> <span class=variable>totalCount</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=comment>// 累加计算 异常请求数量、总请求数量</span></span><br><span class=line>    <span class=keyword>for</span> (SimpleErrorCounter counter : counters) {</span><br><span class=line>        errCount += counter.errorCount.sum();</span><br><span class=line>        totalCount += counter.totalCount.sum();</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 如果总请求数量未达到阈值，什么都不做</span></span><br><span class=line>    <span class=keyword>if</span> (totalCount < minRequestAmount) {</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=type>double</span> <span class=variable>curCount</span> <span class=operator>=</span> errCount;</span><br><span class=line>    <span class=keyword>if</span> (strategy == DEGRADE_GRADE_EXCEPTION_RATIO) {</span><br><span class=line>        <span class=comment>// 计算请求的异常比例</span></span><br><span class=line>        curCount = errCount * <span class=number>1.0d</span> / totalCount;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 如果比例超过阈值，切换到 OPEN</span></span><br><span class=line>    <span class=keyword>if</span> (curCount > threshold) {</span><br><span class=line>        transformToOpen(curCount);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/ itemprop=url>Sentinel系列-Sentinel规则持久化</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-07 15:02:46" datetime=2023-08-07T15:02:46+08:00 itemprop=dateModified>2023-08-07</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Sentinel/ itemprop=url rel=index><span itemprop=name>Sentinel</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、修改Sentinel源码><a class=headerlink href=#1、修改Sentinel源码 title=1、修改Sentinel源码></a>1、修改Sentinel源码</h1><h2 id=1-1、解压sentinel源码包><a class=headerlink href=#1-1、解压sentinel源码包 title=1.1、解压sentinel源码包></a>1.1、解压sentinel源码包</h2><h2 id=1-2、修改依赖><a class=headerlink href=#1-2、修改依赖 title=1.2、修改依赖></a>1.2、修改依赖</h2><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>com.alibaba.csp<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>sentinel-datasource-nacos<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><h2 id=1-3、添加Nacos支持><a class=headerlink href=#1-3、添加Nacos支持 title=1.3、添加Nacos支持></a>1.3、添加Nacos支持</h2><p>在 sentinel-dashboard 的 test 包下，已经编写了对nacos的支持，我们需要将其拷贝到main下。<h2 id=1-4、修改Nacos地址><a class=headerlink href=#1-4、修改Nacos地址 title=1.4、修改Nacos地址></a>1.4、修改Nacos地址</h2><p>修改测试代码中的NacosConfig类中的nacos地址，让其读取application.properties中的配置：<p><img alt=image-20220425114544209 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20220425114544209.png><p>在 sentinel-dashboard 的 application.properties 中添加 nacos 地址配置：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>nacos.addr</span>=<span class=string>localhost:8848</span></span><br></pre></table></figure><h2 id=1-5、配置Nacos数据源><a class=headerlink href=#1-5、配置Nacos数据源 title=1.5、配置Nacos数据源></a>1.5、配置Nacos数据源</h2><p>修改<code>com.alibaba.csp.sentinel.dashboard.controller.v2</code>包下的<code>FlowControllerV2</code>类，让添加的Nacos数据源生效：<p><img alt=image-20220425114700202 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20220425114700202.png><h2 id=1-6、修改前端页面><a class=headerlink href=#1-6、修改前端页面 title=1.6、修改前端页面></a>1.6、修改前端页面</h2><p>修改页面，添加nacos菜单。<p>修改src/main/webapp/resources/app/scripts/directives/sidebar/目录下的sidebar.html文件：<p>将其中的这部分注释打开：<p>![image-20220425114925941](D:/Cache Files/SHHBlogs/gitblogs/website-hexo-haogeblogs/source/imgs/javadev/image-20220425114925941.png)<p>修改其中的文本：<p>![image-20220425114957927](D:/Cache Files/SHHBlogs/gitblogs/website-hexo-haogeblogs/source/imgs/javadev/image-20220425114957927.png)<h2 id=1-7、编译打包><a class=headerlink href=#1-7、编译打包 title=1.7、编译打包></a>1.7、编译打包</h2><p>运行IDEA中的maven插件，编译和打包修改好的Sentinel-Dashboard：<p><img alt=image-20220425115105507 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20220425115105507.png><h2 id=1-8、启动测试><a class=headerlink href=#1-8、启动测试 title=1.8、启动测试></a>1.8、启动测试</h2><p>启动方式跟官方一样：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -jar sentinel-dashboard.jar</span><br></pre></table></figure><p>如果要修改nacos地址，需要添加参数：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -jar sentinel-dashboard.jar -Dnacos.addr=localhost:8848</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Seata%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Seata%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/ itemprop=url>Seata系列-Seata基础应用</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 16:38:20" datetime=2023-10-02T16:38:20+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Seata/ itemprop=url rel=index><span itemprop=name>Seata</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、服务端配置><a class=headerlink href=#1、服务端配置 title=1、服务端配置></a>1、服务端配置</h1><h2 id=1-1、Registry-conf><a class=headerlink href=#1-1、Registry-conf title=1.1、Registry.conf></a>1.1、Registry.conf</h2><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=attr>registry</span> <span class=string>{</span></span><br><span class=line><span class=comment>  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span></span><br><span class=line>  <span class=attr>type</span> = <span class=string>"nacos"</span></span><br><span class=line></span><br><span class=line>  <span class=attr>nacos</span> <span class=string>{</span></span><br><span class=line>    <span class=attr>application</span> = <span class=string>"seata-tc-server"</span></span><br><span class=line>    <span class=attr>serverAddr</span> = <span class=string>"127.0.0.1:8848"</span></span><br><span class=line>    <span class=attr>group</span> = <span class=string>"project-xx-group"</span></span><br><span class=line>    <span class=attr>namespace</span> = <span class=string>"5f90237f-3796-47e9-9afd-258fba2843ab"</span></span><br><span class=line>    <span class=attr>cluster</span> = <span class=string>"SH"</span></span><br><span class=line>    <span class=attr>username</span> = <span class=string>"nacos"</span></span><br><span class=line>    <span class=attr>password</span> = <span class=string>"nacos"</span></span><br><span class=line>  <span class=attr>}</span></span><br><span class=line><span class=attr>}</span></span><br><span class=line></span><br><span class=line><span class=attr>config</span> <span class=string>{</span></span><br><span class=line><span class=comment>  # file、nacos 、apollo、zk、consul、etcd3</span></span><br><span class=line>  <span class=attr>type</span> = <span class=string>"nacos"</span></span><br><span class=line></span><br><span class=line>  <span class=attr>nacos</span> <span class=string>{</span></span><br><span class=line>    <span class=attr>serverAddr</span> = <span class=string>"127.0.0.1:8848"</span></span><br><span class=line>    <span class=attr>namespace</span> = <span class=string>"5f90237f-3796-47e9-9afd-258fba2843ab"</span></span><br><span class=line>    <span class=attr>group</span> = <span class=string>"project-xx-group"</span></span><br><span class=line>    <span class=attr>username</span> = <span class=string>"nacos"</span></span><br><span class=line>    <span class=attr>password</span> = <span class=string>"nacos"</span></span><br><span class=line>    <span class=attr>dataId</span> = <span class=string>"seataServer.properties"</span></span><br><span class=line>  <span class=attr>}</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><h2 id=1-2、seataServer-properties><a class=headerlink href=#1-2、seataServer-properties title=1.2、seataServer.properties></a>1.2、seataServer.properties</h2><p>在nacos中新建远程配置，其中dataId为seataServer.properties，配置内容参考<a href=https://github.com/seata/seata/tree/develop/script/config-center rel=noopener target=_blank>https://github.com/seata/seata/tree/develop/script/config-center</a> 的config.txt并按需修改保存。<p>或者直接添加如下内容也可：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line><span class=comment># 数据存储方式，db代表数据库</span></span><br><span class=line><span class=attr>store.mode</span>=<span class=string>db</span></span><br><span class=line><span class=attr>store.db.datasource</span>=<span class=string>druid</span></span><br><span class=line><span class=attr>store.db.dbType</span>=<span class=string>mysql</span></span><br><span class=line><span class=attr>store.db.driverClassName</span>=<span class=string>com.mysql.cj.jdbc.Driver</span></span><br><span class=line><span class=attr>store.db.url</span>=<span class=string>jdbc:mysql://127.0.0.1:3307/shh_seata?useUnicode=true&characterEncoding=utf8&serverTimezone=GMT</span></span><br><span class=line><span class=attr>store.db.user</span>=<span class=string>root</span></span><br><span class=line><span class=attr>store.db.password</span>=<span class=string>root666</span></span><br><span class=line><span class=attr>store.db.minConn</span>=<span class=string>5</span></span><br><span class=line><span class=attr>store.db.maxConn</span>=<span class=string>30</span></span><br><span class=line><span class=attr>store.db.queryLimit</span>=<span class=string>100</span></span><br><span class=line><span class=attr>store.db.maxWait</span>=<span class=string>5000</span></span><br><span class=line><span class=attr>store.db.globalTable</span>=<span class=string>global_table</span></span><br><span class=line><span class=attr>store.db.branchTable</span>=<span class=string>branch_table</span></span><br><span class=line><span class=attr>store.db.lockTable</span>=<span class=string>lock_table</span></span><br><span class=line><span class=attr>store.db.distributedLock</span>=<span class=string>distributed_lock</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment># 事务、日志等配置</span></span><br><span class=line><span class=attr>server.recovery.committingRetryPeriod</span>=<span class=string>1000</span></span><br><span class=line><span class=attr>server.recovery.asynCommittingRetryPeriod</span>=<span class=string>1000</span></span><br><span class=line><span class=attr>server.recovery.rollbackingRetryPeriod</span>=<span class=string>1000</span></span><br><span class=line><span class=attr>server.recovery.timeoutRetryPeriod</span>=<span class=string>1000</span></span><br><span class=line><span class=attr>server.maxCommitRetryTimeout</span>=<span class=string>-1</span></span><br><span class=line><span class=attr>server.maxRollbackRetryTimeout</span>=<span class=string>-1</span></span><br><span class=line><span class=attr>server.rollbackRetryTimeoutUnlockEnable</span>=<span class=string>false</span></span><br><span class=line><span class=attr>server.undo.logSaveDays</span>=<span class=string>7</span></span><br><span class=line><span class=attr>server.undo.logDeletePeriod</span>=<span class=string>86400000</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment># 客户端与服务端传输方式</span></span><br><span class=line><span class=attr>transport.serialization</span>=<span class=string>seata</span></span><br><span class=line><span class=attr>transport.compressor</span>=<span class=string>none</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment># 关闭metrics功能，提高性能</span></span><br><span class=line><span class=attr>metrics.enabled</span>=<span class=string>false</span></span><br><span class=line><span class=attr>metrics.registryType</span>=<span class=string>compact</span></span><br><span class=line><span class=attr>metrics.exporterList</span>=<span class=string>prometheus</span></span><br><span class=line><span class=attr>metrics.exporterPrometheusPort</span>=<span class=string>9898</span></span><br></pre></table></figure><h2 id=1-3、创建数据库表><a class=headerlink href=#1-3、创建数据库表 title=1.3、创建数据库表></a>1.3、创建数据库表</h2><p>在MySQL中执行如下创建命令：<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br></pre><td class=code><pre><span class=line><span class=keyword>CREATE</span> <span class=keyword>TABLE</span> IF <span class=keyword>NOT</span> <span class=keyword>EXISTS</span> `global_table`(</span><br><span class=line>    `xid`                       <span class=type>VARCHAR</span>(<span class=number>128</span>) <span class=keyword>NOT</span> <span class=keyword>NULL</span>,</span><br><span class=line>    `transaction_id`            <span class=type>BIGINT</span>,</span><br><span class=line>    `status`                    TINYINT      <span class=keyword>NOT</span> <span class=keyword>NULL</span>,</span><br><span class=line>    `application_id`            <span class=type>VARCHAR</span>(<span class=number>32</span>),</span><br><span class=line>    `transaction_service_group` <span class=type>VARCHAR</span>(<span class=number>32</span>),</span><br><span class=line>    `transaction_name`          <span class=type>VARCHAR</span>(<span class=number>128</span>),</span><br><span class=line>    `timeout`                   <span class=type>INT</span>,</span><br><span class=line>    `begin_time`                <span class=type>BIGINT</span>,</span><br><span class=line>    `application_data`          <span class=type>VARCHAR</span>(<span class=number>2000</span>),</span><br><span class=line>    `gmt_create`                DATETIME,</span><br><span class=line>    `gmt_modified`              DATETIME,</span><br><span class=line>    <span class=keyword>PRIMARY</span> KEY (`xid`),</span><br><span class=line>    KEY `idx_status_gmt_modified` (`status` , `gmt_modified`),</span><br><span class=line>    KEY `idx_transaction_id` (`transaction_id`)</span><br><span class=line>) ENGINE <span class=operator>=</span> INNODB</span><br><span class=line>  <span class=keyword>DEFAULT</span> CHARSET <span class=operator>=</span> utf8mb4;</span><br><span class=line></span><br><span class=line><span class=comment>-- the table to store BranchSession data</span></span><br><span class=line><span class=keyword>CREATE</span> <span class=keyword>TABLE</span> IF <span class=keyword>NOT</span> <span class=keyword>EXISTS</span> `branch_table`(</span><br><span class=line>    `branch_id`         <span class=type>BIGINT</span>       <span class=keyword>NOT</span> <span class=keyword>NULL</span>,</span><br><span class=line>    `xid`               <span class=type>VARCHAR</span>(<span class=number>128</span>) <span class=keyword>NOT</span> <span class=keyword>NULL</span>,</span><br><span class=line>    `transaction_id`    <span class=type>BIGINT</span>,</span><br><span class=line>    `resource_group_id` <span class=type>VARCHAR</span>(<span class=number>32</span>),</span><br><span class=line>    `resource_id`       <span class=type>VARCHAR</span>(<span class=number>256</span>),</span><br><span class=line>    `branch_type`       <span class=type>VARCHAR</span>(<span class=number>8</span>),</span><br><span class=line>    `status`            TINYINT,</span><br><span class=line>    `client_id`         <span class=type>VARCHAR</span>(<span class=number>64</span>),</span><br><span class=line>    `application_data`  <span class=type>VARCHAR</span>(<span class=number>2000</span>),</span><br><span class=line>    `gmt_create`        DATETIME(<span class=number>6</span>),</span><br><span class=line>    `gmt_modified`      DATETIME(<span class=number>6</span>),</span><br><span class=line>    <span class=keyword>PRIMARY</span> KEY (`branch_id`),</span><br><span class=line>    KEY `idx_xid` (`xid`)</span><br><span class=line>) ENGINE <span class=operator>=</span> INNODB</span><br><span class=line>  <span class=keyword>DEFAULT</span> CHARSET <span class=operator>=</span> utf8mb4;</span><br><span class=line></span><br><span class=line><span class=comment>-- the table to store lock data</span></span><br><span class=line><span class=keyword>CREATE</span> <span class=keyword>TABLE</span> IF <span class=keyword>NOT</span> <span class=keyword>EXISTS</span> `lock_table`(</span><br><span class=line>    `row_key`        <span class=type>VARCHAR</span>(<span class=number>128</span>) <span class=keyword>NOT</span> <span class=keyword>NULL</span>,</span><br><span class=line>    `xid`            <span class=type>VARCHAR</span>(<span class=number>128</span>),</span><br><span class=line>    `transaction_id` <span class=type>BIGINT</span>,</span><br><span class=line>    `branch_id`      <span class=type>BIGINT</span>       <span class=keyword>NOT</span> <span class=keyword>NULL</span>,</span><br><span class=line>    `resource_id`    <span class=type>VARCHAR</span>(<span class=number>256</span>),</span><br><span class=line>    `table_name`     <span class=type>VARCHAR</span>(<span class=number>32</span>),</span><br><span class=line>    `pk`             <span class=type>VARCHAR</span>(<span class=number>36</span>),</span><br><span class=line>    `status`         TINYINT      <span class=keyword>NOT</span> <span class=keyword>NULL</span> <span class=keyword>DEFAULT</span> <span class=string>'0'</span> COMMENT <span class=string>'0:locked ,1:rollbacking'</span>,</span><br><span class=line>    `gmt_create`     DATETIME,</span><br><span class=line>    `gmt_modified`   DATETIME,</span><br><span class=line>    <span class=keyword>PRIMARY</span> KEY (`row_key`),</span><br><span class=line>    KEY `idx_status` (`status`),</span><br><span class=line>    KEY `idx_branch_id` (`branch_id`),</span><br><span class=line>    KEY `idx_xid_and_branch_id` (`xid` , `branch_id`)</span><br><span class=line>) ENGINE <span class=operator>=</span> INNODB</span><br><span class=line>  <span class=keyword>DEFAULT</span> CHARSET <span class=operator>=</span> utf8mb4;</span><br><span class=line></span><br><span class=line><span class=keyword>CREATE</span> <span class=keyword>TABLE</span> IF <span class=keyword>NOT</span> <span class=keyword>EXISTS</span> `distributed_lock`(</span><br><span class=line>    `lock_key`       <span class=type>CHAR</span>(<span class=number>20</span>) <span class=keyword>NOT</span> <span class=keyword>NULL</span>,</span><br><span class=line>    `lock_value`     <span class=type>VARCHAR</span>(<span class=number>20</span>) <span class=keyword>NOT</span> <span class=keyword>NULL</span>,</span><br><span class=line>    `expire`         <span class=type>BIGINT</span>,</span><br><span class=line>    <span class=keyword>PRIMARY</span> KEY (`lock_key`)</span><br><span class=line>) ENGINE <span class=operator>=</span> INNODB</span><br><span class=line>  <span class=keyword>DEFAULT</span> CHARSET <span class=operator>=</span> utf8mb4;</span><br><span class=line></span><br><span class=line><span class=keyword>INSERT</span> <span class=keyword>INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class=keyword>VALUES</span> (<span class=string>'AsyncCommitting'</span>, <span class=string>' '</span>, <span class=number>0</span>);</span><br><span class=line><span class=keyword>INSERT</span> <span class=keyword>INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class=keyword>VALUES</span> (<span class=string>'RetryCommitting'</span>, <span class=string>' '</span>, <span class=number>0</span>);</span><br><span class=line><span class=keyword>INSERT</span> <span class=keyword>INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class=keyword>VALUES</span> (<span class=string>'RetryRollbacking'</span>, <span class=string>' '</span>, <span class=number>0</span>);</span><br><span class=line><span class=keyword>INSERT</span> <span class=keyword>INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class=keyword>VALUES</span> (<span class=string>'TxTimeoutCheck'</span>, <span class=string>' '</span>, <span class=number>0</span>);</span><br></pre></table></figure><h1 id=2、微服务集成><a class=headerlink href=#2、微服务集成 title=2、微服务集成></a>2、微服务集成</h1><h2 id=2-1、加入依赖><a class=headerlink href=#2-1、加入依赖 title=2.1、加入依赖></a>2.1、加入依赖</h2><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>com.alibaba.cloud<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>spring-cloud-starter-alibaba-nacos-discovery<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>com.alibaba.cloud<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>spring-cloud-starter-alibaba-seata<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><h2 id=2-2、application-yml><a class=headerlink href=#2-2、application-yml title=2.2、application.yml></a>2.2、application.yml</h2><figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=attr>seata:</span></span><br><span class=line>  <span class=attr>registry:</span></span><br><span class=line>    <span class=attr>type:</span> <span class=string>nacos</span></span><br><span class=line>    <span class=attr>nacos:</span></span><br><span class=line>      <span class=attr>server-addr:</span> <span class=number>127.0</span><span class=number>.0</span><span class=number>.1</span><span class=string>:8848</span></span><br><span class=line>      <span class=attr>namespace:</span> <span class=string>5f90237f-3796-47e9-9afd-258fba2843ab</span></span><br><span class=line>      <span class=attr>group:</span> <span class=string>project-xx-group</span></span><br><span class=line>      <span class=attr>application:</span> <span class=string>seata-tc-server</span></span><br><span class=line>      <span class=attr>username:</span> <span class=string>nacos</span></span><br><span class=line>      <span class=attr>password:</span> <span class=string>nacos</span></span><br><span class=line>  <span class=attr>tx-service-group:</span> <span class=string>project-xx-group</span></span><br><span class=line>  <span class=attr>service:</span></span><br><span class=line>    <span class=attr>vgroup-mapping:</span></span><br><span class=line>      <span class=attr>project-xx-group:</span> <span class=string>SH</span></span><br></pre></table></figure><h1 id=3、事务模式切换><a class=headerlink href=#3、事务模式切换 title=3、事务模式切换></a>3、事务模式切换</h1><h2 id=3-1、XA事务模式><a class=headerlink href=#3-1、XA事务模式 title=3.1、XA事务模式></a>3.1、XA事务模式</h2><p>微服务项目中加如下配置：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>seata:</span></span><br><span class=line>  <span class=attr>data-source-proxy-mode:</span> <span class=string>XA</span></span><br></pre></table></figure><h2 id=3-2、AT事务模式><a class=headerlink href=#3-2、AT事务模式 title=3.2、AT事务模式></a>3.2、AT事务模式</h2><h3 id=3-2-1、创建数据库表><a class=headerlink href=#3-2-1、创建数据库表 title=3.2.1、创建数据库表></a>3.2.1、创建数据库表</h3><p>在微服务业务数据库中创建<code>undo_log</code>表：<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=comment>-- mysql --</span></span><br><span class=line><span class=keyword>CREATE</span> <span class=keyword>TABLE</span> IF <span class=keyword>NOT</span> <span class=keyword>EXISTS</span> `undo_log`(</span><br><span class=line>    `branch_id`     <span class=type>BIGINT</span>       <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'branch transaction id'</span>,</span><br><span class=line>    `xid`           <span class=type>VARCHAR</span>(<span class=number>128</span>) <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'global transaction id'</span>,</span><br><span class=line>    `context`       <span class=type>VARCHAR</span>(<span class=number>128</span>) <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'undo_log context,such as serialization'</span>,</span><br><span class=line>    `rollback_info` LONGBLOB     <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'rollback info'</span>,</span><br><span class=line>    `log_status`    <span class=type>INT</span>(<span class=number>11</span>)      <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'0:normal status,1:defense status'</span>,</span><br><span class=line>    `log_created`   DATETIME(<span class=number>6</span>)  <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'create datetime'</span>,</span><br><span class=line>    `log_modified`  DATETIME(<span class=number>6</span>)  <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'modify datetime'</span>,</span><br><span class=line>    <span class=keyword>UNIQUE</span> KEY `ux_undo_log` (`xid`, `branch_id`)</span><br><span class=line>) ENGINE <span class=operator>=</span> InnoDB</span><br><span class=line>  AUTO_INCREMENT <span class=operator>=</span> <span class=number>1</span></span><br><span class=line>  <span class=keyword>DEFAULT</span> CHARSET <span class=operator>=</span> utf8mb4 COMMENT <span class=operator>=</span><span class=string>'AT transaction mode undo table'</span>;</span><br></pre></table></figure><p>在seata服务对应的数据库中创建全局锁表<code>lock_table</code>：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line>CREATE TABLE `lock_table` (</span><br><span class=line>  `row_key` varchar(128) NOT NULL,</span><br><span class=line>  `xid` varchar(128) DEFAULT NULL,</span><br><span class=line>  `transaction_id` bigint(20) DEFAULT NULL,</span><br><span class=line>  `branch_id` bigint(20) NOT NULL,</span><br><span class=line>  `resource_id` varchar(256) DEFAULT NULL,</span><br><span class=line>  `table_name` varchar(32) DEFAULT NULL,</span><br><span class=line>  `pk` varchar(36) DEFAULT NULL,</span><br><span class=line>  `status` tinyint(4) NOT NULL DEFAULT '0' COMMENT '0:locked ,1:rollbacking',</span><br><span class=line>  `gmt_create` datetime DEFAULT NULL,</span><br><span class=line>  `gmt_modified` datetime DEFAULT NULL,</span><br><span class=line>  PRIMARY KEY (`row_key`),</span><br><span class=line>  KEY `idx_status` (`status`),</span><br><span class=line>  KEY `idx_branch_id` (`branch_id`),</span><br><span class=line>  KEY `idx_xid_and_branch_id` (`xid`,`branch_id`)</span><br><span class=line>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;</span><br></pre></table></figure><h3 id=3-2-2、微服务项目配置><a class=headerlink href=#3-2-2、微服务项目配置 title=3.2.2、微服务项目配置></a>3.2.2、微服务项目配置</h3><p>在微服务项目中的配置文件中添加或修改成如下配置：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>seata:</span></span><br><span class=line>  <span class=attr>data-source-proxy-mode:</span> <span class=string>AT</span></span><br></pre></table></figure><h2 id=3-3、TCC模型><a class=headerlink href=#3-3、TCC模型 title=3.3、TCC模型></a>3.3、TCC模型</h2><h3 id=3-3-1、创建数据库表><a class=headerlink href=#3-3-1、创建数据库表 title=3.3.1、创建数据库表></a>3.3.1、创建数据库表</h3><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=comment>-- mysql --</span></span><br><span class=line><span class=keyword>CREATE</span> <span class=keyword>TABLE</span> IF <span class=keyword>NOT</span> <span class=keyword>EXISTS</span> `tcc_fence_log`(</span><br><span class=line>    `xid`           <span class=type>VARCHAR</span>(<span class=number>128</span>)  <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'global id'</span>,</span><br><span class=line>    `branch_id`     <span class=type>BIGINT</span>        <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'branch id'</span>,</span><br><span class=line>    `action_name`   <span class=type>VARCHAR</span>(<span class=number>64</span>)   <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'action name'</span>,</span><br><span class=line>    `status`        TINYINT       <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'status(tried:1;committed:2;rollbacked:3;suspended:4)'</span>,</span><br><span class=line>    `gmt_create`    DATETIME(<span class=number>3</span>)   <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'create time'</span>,</span><br><span class=line>    `gmt_modified`  DATETIME(<span class=number>3</span>)   <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'update time'</span>,</span><br><span class=line>    <span class=keyword>PRIMARY</span> KEY (`xid`, `branch_id`),</span><br><span class=line>    KEY `idx_gmt_modified` (`gmt_modified`),</span><br><span class=line>    KEY `idx_status` (`status`)</span><br><span class=line>) ENGINE <span class=operator>=</span> InnoDB</span><br><span class=line><span class=keyword>DEFAULT</span> CHARSET <span class=operator>=</span> utf8mb4;</span><br></pre></table></figure><h3 id=3-3-2、代码><a class=headerlink href=#3-3-2、代码 title=3.3.2、代码></a>3.3.2、代码</h3><p>编写业务接口：<p><img alt=image-20220425191442155 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Seata-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-image-20220425191442155.png><p>实现接口，编写业务逻辑即可。业务逻辑可参考下图：<p><img alt=Seata-04-事务模式-7-TCC模式业务逻辑分析 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Seata-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-Seata-04-%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%BC%8F-7-TCC%E6%A8%A1%E5%BC%8F%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E5%88%86%E6%9E%90.png><p>业务代码示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br></pre><td class=code><pre><span class=line><span class=comment>// 接口</span></span><br><span class=line><span class=meta>@LocalTCC</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">TCCAccountService</span> {</span><br><span class=line>    <span class=meta>@TwoPhaseBusinessAction(name = "deductAccount", commitMethod = "confirm", rollbackMethod = "cancel")</span></span><br><span class=line>    <span class=type>int</span> <span class="title function_">deductAccount</span><span class=params>(<span class=meta>@BusinessActionContextParameter(paramName = "aid")</span> Long aid,</span></span><br><span class=line><span class=params>                       <span class=meta>@BusinessActionContextParameter(paramName = "money")</span><span class=type>int</span> money)</span>;</span><br><span class=line>    <span class=type>boolean</span> <span class="title function_">confirm</span><span class=params>(BusinessActionContext ctx)</span>;</span><br><span class=line>    <span class=type>boolean</span> <span class="title function_">cancel</span><span class=params>(BusinessActionContext ctx)</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 实现</span></span><br><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">TCCAccountServiceImpl</span> <span class=keyword>implements</span> <span class="title class_">TCCAccountService</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>final</span> <span class=type>Integer</span> <span class=variable>TRY</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>final</span> <span class=type>Integer</span> <span class=variable>COMMIT</span> <span class=operator>=</span> <span class=number>1</span>;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>final</span> <span class=type>Integer</span> <span class=variable>CANCEL</span> <span class=operator>=</span> <span class=number>2</span>;</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> ExampleSeataAccountMapper accountMapper;</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> TCCFenceLogMapper tccFenceLogMapper;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=meta>@Transactional</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">deductAccount</span><span class=params>(Long aid, <span class=type>int</span> money)</span> {</span><br><span class=line>        <span class=comment>// 0.获取事务id</span></span><br><span class=line>        <span class=type>String</span> <span class=variable>xid</span> <span class=operator>=</span> RootContext.getXID();</span><br><span class=line>        <span class=comment>// 1、业务悬挂处理</span></span><br><span class=line>        <span class=type>TCCFenceLog</span> <span class=variable>oldLog</span> <span class=operator>=</span> tccFenceLogMapper.selectById(xid);</span><br><span class=line>        <span class=keyword>if</span> (oldLog != <span class=literal>null</span>){</span><br><span class=line>            <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 2.扣减可用余额</span></span><br><span class=line>        <span class=type>int</span> <span class=variable>deductResult</span> <span class=operator>=</span> accountMapper.deductAccount(aid, money);</span><br><span class=line>        <span class=comment>// 3.记录冻结金额，事务状态</span></span><br><span class=line>        <span class=type>TCCFenceLog</span> <span class=variable>tccFenceLog</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TCCFenceLog</span>();</span><br><span class=line>        tccFenceLog.setXid(xid);</span><br><span class=line>        tccFenceLog.setAccountId(aid);</span><br><span class=line>        tccFenceLog.setAccountFreezeMoney(money);</span><br><span class=line>        tccFenceLog.setStatus(TRY);</span><br><span class=line>        tccFenceLog.setCreateTime(LocalDateTime.now());</span><br><span class=line>        tccFenceLog.setUpdateTime(LocalDateTime.now());</span><br><span class=line>        <span class=type>int</span> <span class=variable>result</span> <span class=operator>=</span> tccFenceLogMapper.insert(tccFenceLog);</span><br><span class=line>        <span class=keyword>return</span> result;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">confirm</span><span class=params>(BusinessActionContext ctx)</span> {</span><br><span class=line>        <span class=comment>// 1.获取事务id</span></span><br><span class=line>        <span class=type>String</span> <span class=variable>xid</span> <span class=operator>=</span> ctx.getXid();</span><br><span class=line>        <span class=comment>// 2.根据id删除冻结记录</span></span><br><span class=line>        <span class=type>int</span> <span class=variable>deleteResult</span> <span class=operator>=</span> tccFenceLogMapper.deleteById(xid);</span><br><span class=line>        <span class=keyword>return</span> <span class=number>1</span> == deleteResult;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">cancel</span><span class=params>(BusinessActionContext ctx)</span> {</span><br><span class=line>        <span class=comment>// 0.查询冻结记录</span></span><br><span class=line>        <span class=type>String</span> <span class=variable>xid</span> <span class=operator>=</span> ctx.getXid();</span><br><span class=line>        <span class=comment>// 1.1、空回滚（如果TRY没有执行过，那么不能直接执行正常CANCEL，只能执行一次空的CANCEL）</span></span><br><span class=line>        <span class=type>TCCFenceLog</span> <span class=variable>tccFenceLog</span> <span class=operator>=</span> tccFenceLogMapper.selectById(xid);</span><br><span class=line>        <span class=keyword>if</span> (tccFenceLog == <span class=literal>null</span>){</span><br><span class=line>            tccFenceLog = <span class=keyword>new</span> <span class="title class_">TCCFenceLog</span>();</span><br><span class=line>            tccFenceLog.setXid(xid);</span><br><span class=line>            tccFenceLog.setAccountId(Long.parseLong(ctx.getActionContext(<span class=string>"aid"</span>).toString()));</span><br><span class=line>            tccFenceLog.setAccountFreezeMoney(<span class=number>0</span>);</span><br><span class=line>            tccFenceLog.setStatus(CANCEL);</span><br><span class=line>            tccFenceLog.setCreateTime(LocalDateTime.now());</span><br><span class=line>            tccFenceLog.setUpdateTime(LocalDateTime.now());</span><br><span class=line>            tccFenceLogMapper.insert(tccFenceLog);</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 1.2、幂等处理（已经执行过了，无需重复执行）</span></span><br><span class=line>        <span class=keyword>if</span> (tccFenceLog.getStatus() == CANCEL){</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 2、恢复可用余额</span></span><br><span class=line>        accountMapper.refund(tccFenceLog.getAccountId(), tccFenceLog.getAccountFreezeMoney());</span><br><span class=line>        <span class=comment>// 2.将冻结金额清零，状态改为CANCEL</span></span><br><span class=line>        tccFenceLog.setAccountFreezeMoney(<span class=number>0</span>);</span><br><span class=line>        tccFenceLog.setStatus(CANCEL);</span><br><span class=line>        <span class=type>int</span> <span class=variable>result</span> <span class=operator>=</span> tccFenceLogMapper.updateById(tccFenceLog);</span><br><span class=line>        <span class=keyword>return</span> <span class=number>1</span> == result;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=3-4、SAGA模式><a class=headerlink href=#3-4、SAGA模式 title=3.4、SAGA模式></a>3.4、SAGA模式</h2><h3 id=3-4-1、创建数据库表><a class=headerlink href=#3-4-1、创建数据库表 title=3.4.1、创建数据库表></a>3.4.1、创建数据库表</h3><p>MySQL脚本：<figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br></pre><td class=code><pre><span class=line><span class=keyword>CREATE</span> <span class=keyword>TABLE</span> IF <span class=keyword>NOT</span> <span class=keyword>EXISTS</span> `seata_state_machine_def`(</span><br><span class=line>    `id`               <span class=type>VARCHAR</span>(<span class=number>32</span>)  <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'id'</span>,</span><br><span class=line>    `name`             <span class=type>VARCHAR</span>(<span class=number>128</span>) <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'name'</span>,</span><br><span class=line>    `tenant_id`        <span class=type>VARCHAR</span>(<span class=number>32</span>)  <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'tenant id'</span>,</span><br><span class=line>    `app_name`         <span class=type>VARCHAR</span>(<span class=number>32</span>)  <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'application name'</span>,</span><br><span class=line>    `type`             <span class=type>VARCHAR</span>(<span class=number>20</span>)  COMMENT <span class=string>'state language type'</span>,</span><br><span class=line>    `comment_`         <span class=type>VARCHAR</span>(<span class=number>255</span>) COMMENT <span class=string>'comment'</span>,</span><br><span class=line>    `ver`              <span class=type>VARCHAR</span>(<span class=number>16</span>)  <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'version'</span>,</span><br><span class=line>    `gmt_create`       DATETIME(<span class=number>3</span>)  <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'create time'</span>,</span><br><span class=line>    `status`           <span class=type>VARCHAR</span>(<span class=number>2</span>)   <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'status(AC:active|IN:inactive)'</span>,</span><br><span class=line>    `content`          TEXT COMMENT <span class=string>'content'</span>,</span><br><span class=line>    `recover_strategy` <span class=type>VARCHAR</span>(<span class=number>16</span>) COMMENT <span class=string>'transaction recover strategy(compensate|retry)'</span>,</span><br><span class=line>    <span class=keyword>PRIMARY</span> KEY (`id`)</span><br><span class=line>) ENGINE <span class=operator>=</span> InnoDB</span><br><span class=line>  <span class=keyword>DEFAULT</span> CHARSET <span class=operator>=</span> utf8mb4;</span><br><span class=line></span><br><span class=line><span class=keyword>CREATE</span> <span class=keyword>TABLE</span> IF <span class=keyword>NOT</span> <span class=keyword>EXISTS</span> `seata_state_machine_inst`(</span><br><span class=line>    `id`                  <span class=type>VARCHAR</span>(<span class=number>128</span>)            <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'id'</span>,</span><br><span class=line>    `machine_id`          <span class=type>VARCHAR</span>(<span class=number>32</span>)             <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'state machine definition id'</span>,</span><br><span class=line>    `tenant_id`           <span class=type>VARCHAR</span>(<span class=number>32</span>)             <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'tenant id'</span>,</span><br><span class=line>    `parent_id`           <span class=type>VARCHAR</span>(<span class=number>128</span>) COMMENT <span class=string>'parent id'</span>,</span><br><span class=line>    `gmt_started`         DATETIME(<span class=number>3</span>)             <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'start time'</span>,</span><br><span class=line>    `business_key`        <span class=type>VARCHAR</span>(<span class=number>48</span>) COMMENT <span class=string>'business key'</span>,</span><br><span class=line>    `start_params`        TEXT COMMENT <span class=string>'start parameters'</span>,</span><br><span class=line>    `gmt_end`             DATETIME(<span class=number>3</span>) COMMENT <span class=string>'end time'</span>,</span><br><span class=line>    `excep`               <span class=type>BLOB</span> COMMENT <span class=string>'exception'</span>,</span><br><span class=line>    `end_params`          TEXT COMMENT <span class=string>'end parameters'</span>,</span><br><span class=line>    `status`              <span class=type>VARCHAR</span>(<span class=number>2</span>) COMMENT <span class=string>'status(SU succeed|FA failed|UN unknown|SK skipped|RU running)'</span>,</span><br><span class=line>    `compensation_status` <span class=type>VARCHAR</span>(<span class=number>2</span>) COMMENT <span class=string>'compensation status(SU succeed|FA failed|UN unknown|SK skipped|RU running)'</span>,</span><br><span class=line>    `is_running`          TINYINT(<span class=number>1</span>) COMMENT <span class=string>'is running(0 no|1 yes)'</span>,</span><br><span class=line>    `gmt_updated`         DATETIME(<span class=number>3</span>) <span class=keyword>NOT</span> <span class=keyword>NULL</span>,</span><br><span class=line>    <span class=keyword>PRIMARY</span> KEY (`id`),</span><br><span class=line>    <span class=keyword>UNIQUE</span> KEY `unikey_buz_tenant` (`business_key`, `tenant_id`)</span><br><span class=line>) ENGINE <span class=operator>=</span> InnoDB</span><br><span class=line>  <span class=keyword>DEFAULT</span> CHARSET <span class=operator>=</span> utf8mb4;</span><br><span class=line></span><br><span class=line><span class=keyword>CREATE</span> <span class=keyword>TABLE</span> IF <span class=keyword>NOT</span> <span class=keyword>EXISTS</span> `seata_state_inst`(</span><br><span class=line>    `id`                       <span class=type>VARCHAR</span>(<span class=number>48</span>)  <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'id'</span>,</span><br><span class=line>    `machine_inst_id`          <span class=type>VARCHAR</span>(<span class=number>128</span>) <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'state machine instance id'</span>,</span><br><span class=line>    `name`                     <span class=type>VARCHAR</span>(<span class=number>128</span>) <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'state name'</span>,</span><br><span class=line>    `type`                     <span class=type>VARCHAR</span>(<span class=number>20</span>)  COMMENT <span class=string>'state type'</span>,</span><br><span class=line>    `service_name`             <span class=type>VARCHAR</span>(<span class=number>128</span>) COMMENT <span class=string>'service name'</span>,</span><br><span class=line>    `service_method`           <span class=type>VARCHAR</span>(<span class=number>128</span>) COMMENT <span class=string>'method name'</span>,</span><br><span class=line>    `service_type`             <span class=type>VARCHAR</span>(<span class=number>16</span>) COMMENT <span class=string>'service type'</span>,</span><br><span class=line>    `business_key`             <span class=type>VARCHAR</span>(<span class=number>48</span>) COMMENT <span class=string>'business key'</span>,</span><br><span class=line>    `state_id_compensated_for` <span class=type>VARCHAR</span>(<span class=number>50</span>) COMMENT <span class=string>'state compensated for'</span>,</span><br><span class=line>    `state_id_retried_for`     <span class=type>VARCHAR</span>(<span class=number>50</span>) COMMENT <span class=string>'state retried for'</span>,</span><br><span class=line>    `gmt_started`              DATETIME(<span class=number>3</span>)  <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'start time'</span>,</span><br><span class=line>    `is_for_update`            TINYINT(<span class=number>1</span>) COMMENT <span class=string>'is service for update'</span>,</span><br><span class=line>    `input_params`             TEXT COMMENT <span class=string>'input parameters'</span>,</span><br><span class=line>    `output_params`            TEXT COMMENT <span class=string>'output parameters'</span>,</span><br><span class=line>    `status`                   <span class=type>VARCHAR</span>(<span class=number>2</span>)   <span class=keyword>NOT</span> <span class=keyword>NULL</span> COMMENT <span class=string>'status(SU succeed|FA failed|UN unknown|SK skipped|RU running)'</span>,</span><br><span class=line>    `excep`                    <span class=type>BLOB</span> COMMENT <span class=string>'exception'</span>,</span><br><span class=line>    `gmt_updated`              DATETIME(<span class=number>3</span>) COMMENT <span class=string>'update time'</span>,</span><br><span class=line>    `gmt_end`                  DATETIME(<span class=number>3</span>) COMMENT <span class=string>'end time'</span>,</span><br><span class=line>    <span class=keyword>PRIMARY</span> KEY (`id`, `machine_inst_id`)</span><br><span class=line>) ENGINE <span class=operator>=</span> InnoDB</span><br><span class=line>  <span class=keyword>DEFAULT</span> CHARSET <span class=operator>=</span> utf8mb4;</span><br></pre></table></figure><h3 id=3-4-2、代码><a class=headerlink href=#3-4-2、代码 title=3.4.2、代码></a>3.4.2、代码</h3><p>生产中使用不多，这里不再编写，可参考网上的案例。</div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/RocketMQ%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/RocketMQ%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/ itemprop=url>RocketMQ系列-RocketMQ基础应用</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 20:21:44" datetime=2023-10-02T20:21:44+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/RocketMQ/ itemprop=url rel=index><span itemprop=name>RocketMQ</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、RocketMQ是啥><a class=headerlink href=#1、RocketMQ是啥 title=1、RocketMQ是啥></a>1、RocketMQ是啥</h1><h2 id=1-1-、RocketMQ简介><a class=headerlink href=#1-1-、RocketMQ简介 title=1.1.、RocketMQ简介></a>1.1.、RocketMQ简介</h2><p><strong>RocketMQ 是一个 开源分布式消息系统，提供低延时、高可靠的消息发布与订阅服务。</strong><h2 id=1-2、角色成员><a class=headerlink href=#1-2、角色成员 title=1.2、角色成员></a>1.2、角色成员</h2><h3 id=1-2-1、Message-Model（消息模型）><a title="1.2.1、Message Model（消息模型）" class=headerlink href=#1-2-1、Message-Model（消息模型）></a>1.2.1、Message Model（消息模型）</h3><p><strong>RocketMQ主要由Producer、Broker、Consumer三部分组成，其中Producer负责生产消息，Consumer负责消费消息，Broker负责存储消息。</strong><p>Broker 对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic消息也可以分片存储于不同的 Broker。MessageQueue 用于存储 消息物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer实例构成。<h3 id=1-2-2、Message（消息）><a class=headerlink href=#1-2-2、Message（消息） title=1.2.2、Message（消息）></a>1.2.2、Message（消息）</h3><p>消息系统传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。每个消息都有唯一的Message ID，且可携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。<h4 id=Normal-Ordered-Message（普通顺序消息）><a title="Normal Ordered Message（普通顺序消息）" class=headerlink href=#Normal-Ordered-Message（普通顺序消息）></a>Normal Ordered Message（普通顺序消息）</h4><p>普通顺序消费模式下，消费者通过同一个消息队列（ Topic 分区，称作 Message Queue） 收到的消息是【有序】的，不同消息队列收到的消息则可能是无序的。<h4 id=Strictly-Ordered-Message（严格顺序消息）><a title="Strictly Ordered Message（严格顺序消息）" class=headerlink href=#Strictly-Ordered-Message（严格顺序消息）></a>Strictly Ordered Message（严格顺序消息）</h4><p>严格顺序消息模式下，消费者收到的所有消息均【有序】。<h3 id=1-2-3、Tag（消息标签）><a class=headerlink href=#1-2-3、Tag（消息标签） title=1.2.3、Tag（消息标签）></a>1.2.3、Tag（消息标签）</h3><p><strong>为消息设置的标志，用于同一主题下区分不同类型的消息。</strong>来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。<h3 id=1-2-4、Producer（消息生产者）><a class=headerlink href=#1-2-4、Producer（消息生产者） title=1.2.4、Producer（消息生产者）></a>1.2.4、Producer（消息生产者）</h3><p><strong>负责生产消息，一般由业务系统负责生产消息。</strong>消息生产者会把消息发送到broker服务器。RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。<h3 id=1-2-5、Producer-Group（消息生产者组）><a title="1.2.5、Producer Group（消息生产者组）" class=headerlink href=#1-2-5、Producer-Group（消息生产者组）></a>1.2.5、Producer Group（消息生产者组）</h3><p><strong>同一类Producer的集合，同类Producer发送同一类消息且发送逻辑一致。</strong>如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。<h3 id=1-2-6、Consumer（消息消费者）><a class=headerlink href=#1-2-6、Consumer（消息消费者） title=1.2.6、Consumer（消息消费者）></a>1.2.6、Consumer（消息消费者）</h3><p><strong>负责消费消息，一般是后台系统负责异步消费。</strong>一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。有两种消费形式：拉取式消费、推动式消费。<h4 id=Pull-Consumer（拉取式消费）><a title="Pull Consumer（拉取式消费）" class=headerlink href=#Pull-Consumer（拉取式消费）></a>Pull Consumer（拉取式消费）</h4><p>Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。<h4 id=Push-Consumer（推送式消费）><a title="Push Consumer（推送式消费）" class=headerlink href=#Push-Consumer（推送式消费）></a>Push Consumer（推送式消费）</h4><p>Consumer消费的一种类型，该模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。<h3 id=1-2-7、Consumer-Group（消费者组）><a title="1.2.7、Consumer Group（消费者组）" class=headerlink href=#1-2-7、Consumer-Group（消费者组）></a>1.2.7、Consumer Group（消费者组）</h3><p><strong>同一类Consumer的集合，同类Consumer通常消费同一类消息且消费逻辑一致。</strong>消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。<h3 id=1-2-8、Topic（主题）><a class=headerlink href=#1-2-8、Topic（主题） title=1.2.8、Topic（主题）></a>1.2.8、Topic（主题）</h3><p><strong>一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</strong><h3 id=1-2-9、Name-Server（名字服务）><a title="1.2.9、Name Server（名字服务）" class=headerlink href=#1-2-9、Name-Server（名字服务）></a>1.2.9、Name Server（名字服务）</h3><p><strong>名称服务充当路由消息提供者。生产者或消费者能够通过 名字服务 查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。</strong><h3 id=1-2-10、Broker-Server（代理服务器）><a title="1.2.10、Broker Server（代理服务器）" class=headerlink href=#1-2-10、Broker-Server（代理服务器）></a>1.2.10、Broker Server（代理服务器）</h3><p><strong>消息中转角色，负责存储消息、转发消息。</strong>代理服务器负责接收生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移、主题、队列消息等。<h2 id=1-3、产品特性><a class=headerlink href=#1-3、产品特性 title=1.3、产品特性></a>1.3、产品特性</h2><h3 id=1-3-1、订阅与发布><a class=headerlink href=#1-3-1、订阅与发布 title=1.3.1、订阅与发布></a>1.3.1、订阅与发布</h3><p>消息的发布 是指 某个生产者向某个topic发送消息；消息的订阅是指某个消费者关注了某个topic中带有某些tag的消息，进而从该topic消费数据。<h3 id=1-3-2、消息顺序><a class=headerlink href=#1-3-2、消息顺序 title=1.3.2、消息顺序></a>1.3.2、消息顺序</h3><p><strong>消息有序指的是一类消息消费时，能按照 发送顺序 来消费。</strong>RocketMQ可以严格保证消息有序。<p><strong>顺序消息分为 全局顺序消息 与 分区顺序消息。全局顺序是指某个Topic下的所有消息都要保证顺序；部分顺序消息只要保证每一组消息被顺序消费即可。</strong><ul><li>全局顺序：指定Topic下的所有消息按照<strong>先入先出（FIFO）顺序</strong>进行发布和消费。 适用于对性能要求不高，需要按FIFO规则顺序发布和消费消息的场景。<li>分区顺序：指定Topic下的所有消息<strong>根据sharding key进行区块分区</strong>。 同一个分区内的消息按照严格的FIFO顺序进行发布和消费。 Sharding key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Key 是完全不同的概念。 适用场景：性能要求高，以 sharding key 作为分区字段，在同一个区块中严格的按照 FIFO 原则进行消息发布和消费的场景。</ul><h3 id=1-3-3、消息过滤><a class=headerlink href=#1-3-3、消息过滤 title=1.3.3、消息过滤></a>1.3.3、消息过滤</h3><p>消费者 可以 根据Tag进行消息过滤，也支持自定义属性过滤。消息过滤目前是在Broker端实现，优点是减少了对于Consumer无用消息的网络传输，缺点是增加了Broker的负担、而且实现相对复杂。<h3 id=1-3-4、消息可靠性><a class=headerlink href=#1-3-4、消息可靠性 title=1.3.4、消息可靠性></a>1.3.4、消息可靠性</h3><p>RocketMQ支持消息高可靠，影响消息可靠性的几种情况如下：<ol><li>Broker非正常关闭<li>Broker异常Crash<li>OS Crash<li>机器掉电，但是能立即恢复供电情况<li>机器无法开机（可能是cpu、主板、内存等关键设备损坏）<li>磁盘设备损坏</ol><p>1)、2)、3)、4) 四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。<p>5)、6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。注：RocketMQ从3.0版本开始支持同步双写。<h3 id=1-3-5、至少一次><a class=headerlink href=#1-3-5、至少一次 title=1.3.5、至少一次></a>1.3.5、至少一次</h3><p>至少一次说的是每个消息至少投递一次。Consumer先Pull消息到本地，消费完成后，才会向服务器返回ack，如果没有消费则一定不会返回ack消息，所以RocketMQ可以很好的支持此特性。<h3 id=1-3-6、回溯消费><a class=headerlink href=#1-3-6、回溯消费 title=1.3.6、回溯消费></a>1.3.6、回溯消费</h3><p>回溯消费说的是Consumer已经消费完毕的消息，由于业务需求需要重新消费时可以再次消费，Broker在向Consumer投递消息后，消息仍然需要保留。并且重新消费一般是按照时间维度，例如由于Consumer系统故障，恢复后需要重新消费1小时前的数据，那么Broker要提供一种机制，可以按照时间维度来回退消费进度。RocketMQ支持按照时间回溯消费，时间维度精确到毫秒。<h3 id=1-3-7、事务消息><a class=headerlink href=#1-3-7、事务消息 title=1.3.7、事务消息></a>1.3.7、事务消息</h3><p>RocketMQ事务消息（Transactional Message）是指【应用本地事务】和【发送消息操作】可以被定义到全局事务中，要么同时成功，要么同时失败。RocketMQ事务消息 提供类似 X/Open XA 的分布式事务功能，通过【事务消息】能达到 分布式事务的最终一致。<h3 id=1-3-8、定时消息><a class=headerlink href=#1-3-8、定时消息 title=1.3.8、定时消息></a>1.3.8、定时消息</h3><p>定时消息（延迟队列）是指 消息发送到broker后，不会立即被消费，而会等待一段时间后再投递给topic。broker有配置项messageDelayLevel，默认值为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，18个level。可以配置自定义messageDelayLevel。注意，messageDelayLevel是broker的属性，不属于某个topic。发消息时，设置delayLevel等级即可：msg.setDelayLevel(level)。level有以下三种情况：<ul><li>level == 0，消息为非延迟消息。<li>1<=level<=maxLevel，消息延迟特定时间，例如level==1，延迟1s。<li>level > maxLevel，则level== maxLevel，例如level==20，延迟2h。</ul><p>定时消息会暂存在名为SCHEDULE_TOPIC_XXXX的topic中，并根据delayTimeL。evel存入特定的queue，queueId = delayTimeLevel – 1，即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。<p>需要注意的是，定时消息会在第一次写入和调度写入真实topic时都会计数，因此发送数量、tps都会变高。<h3 id=1-3-9、消息重试><a class=headerlink href=#1-3-9、消息重试 title=1.3.9、消息重试></a>1.3.9、消息重试</h3><p>Consumer 消费消息失败后，要提供一种重试机制，使得消息可被再次消费。Consumer消费消息失败 通常有以下几种情况：<ul><li>消息本身原因，例如反序列化失败，消息数据本身无法处理。针对该错误，通常要跳过这条消息，再消费其它消息。这种无法被处理的消息，需要一种【定时重试机制】，即过10秒后再重试。<li>由于依赖的下游应用服务不可用，例如db连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用sleep 30s，再消费下一条消息，这样可以减轻Broker重试消息的压力。</ul><p>RocketMQ会为每个消费组都设置一个Topic名称为<code>%RETRY%+consumerGroup</code>的重试队列（该 重试队列 只针对 消费者组，而不针对每个Topic设置），用于暂时保存因为各种异常而导致Consumer端无法消费的消息。考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ对于重试消息的处理是先保存至Topic名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行Delay后重新保存至“%RETRY%+consumerGroup”的重试队列中。<h3 id=1-3-10、消息重投><a class=headerlink href=#1-3-10、消息重投 title=1.3.10、消息重投></a>1.3.10、消息重投</h3><p><strong>生产者在发送消息时，同步消息失败会重投，异步消息有重试，没有任何保证</strong>。消息重投 是为了保证 消息发送成功，但同时可能会造成消息重复，消息重复在RocketMQ中是无法避免的问题。消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会是大概率事件。另外，生产者主动重发、consumer负载变化也会导致重复消息。消息重试策略可通过如下方式设置：<ul><li><font color=orange>retryTimesWhenSendFailed</font>：同步发送失败重投次数，默认为2，因此生产者会最多尝试发送retryTimesWhenSendFailed + 1次。不会选择上次失败的broker，尝试向其他broker发送，最大程度保证消息不丢。超过重投次数，抛出异常，由客户端保证消息不丢。当出现RemotingException、MQClientException和部分MQBrokerException时会重投。<li><font color=orange>retryTimesWhenSendAsyncFailed</font>：异步发送失败重试次数，异步重试不会选择其他broker，仅在同一个broker上做重试，不保证消息不丢。<li><font color=orange>retryAnotherBrokerWhenNotStoreOK</font>：消息刷盘（主或备）超时或slave不可用（返回状态非SEND_OK），是否尝试发送到其他broker，默认false。十分重要消息可以开启。</ul><h3 id=1-3-11、流量控制><a class=headerlink href=#1-3-11、流量控制 title=1.3.11、流量控制></a>1.3.11、流量控制</h3><p>生产者流控，broker处理能力有限；消费者流控，消费能力有限。<p>生产者流控：<ul><li>commitLog文件被锁时间超过osPageCacheBusyTimeOutMills时，参数默认为1000ms，返回流控。<li>如果开启transientStorePoolEnable == true，且broker为异步刷盘的主机，且transientStorePool中资源不足，拒绝当前send请求，返回流控。<li>broker每隔10ms检查send请求队列头部请求的等待时间，如果超过waitTimeMillsInSendQueue，默认200ms，拒绝当前send请求，返回流控。<li>broker通过拒绝send 请求方式实现流量控制。</ul><p>注意，生产者流控，不会尝试消息重投。<p>消费者流控：<ul><li>消费者本地缓存消息数超过pullThresholdForQueue时，默认1000。<li>消费者本地缓存消息大小超过pullThresholdSizeForQueue时，默认100MB。<li>消费者本地缓存消息跨度超过consumeConcurrentlyMaxSpan时，默认2000。</ul><p>消费者流控的结果是降低拉取频率。<h3 id=1-3-12、死信队列><a class=headerlink href=#1-3-12、死信队列 title=1.3.12、死信队列></a>1.3.12、死信队列</h3><p>死信队列 用于 处理无法被正常消费的消息。当一条消息初次消费失败，消息队列会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明 消费者无法正确消费该消息，此时 会将该消息 发送到 该消费者对应的特殊队列中。<p>无法被消费的消息通常称为死信消息（Dead-Letter Message），将存储死信消息的队列称为死信队列（Dead-Letter Queue）。RocketMQ中可以通过使用console控制台对死信队列中的消息进行重发来使得消费者实例再次进行消费。<h2 id=1-4、架构设计><a class=headerlink href=#1-4、架构设计 title=1.4、架构设计></a>1.4、架构设计</h2><h3 id=1-4-1、技术架构><a class=headerlink href=#1-4-1、技术架构 title=1.4.1、技术架构></a>1.4.1、技术架构</h3><p><img alt=image-20210818115339147 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8-RocketMQ%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%9B%BE01.png><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8-RocketMQ%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%9B%BE02.png><p>RocketMQ架构上主要分为四部分：<ul><li><font color=orange>Producer</font>：消息发布的角色，支持分布式集群方式部署。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。<li><font color=orange>Consumer</font>：消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用户的需求。<li><font color=orange>NameServer</font>：NameServer是一个非常简单的Topic路由注册中心，其角色类似Dubbo中的zookeeper，支持Broker的动态注册与发现。主要包括两个功能：Broker管理，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活；路由信息管理，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费。NameServer通常也是集群的方式部署，各实例间相互不进行信息通讯。Broker是向每一台NameServer注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息，Producer,Consumer仍然可以动态感知Broker的路由的信息。<li><font color=orange>BrokerServer</font>：Broker主要负责消息的存储、投递和查询以及服务高可用保证，为了实现这些功能，Broker包含了以下几个重要子模块。<ol><li>Remoting Module：整个Broker的实体，负责处理来自clients端的请求。<li>Client Manager：负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息<li>Store Service：提供方便简单的API接口处理消息存储到物理硬盘和查询功能。<li>HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。<li>Index Service：根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息的快速查询。</ol></ul><h3 id=1-4-2、部署架构><a class=headerlink href=#1-4-2、部署架构 title=1.4.2、部署架构></a>1.4.2、部署架构</h3><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8-RocketMQ%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84%E5%9B%BE01.png><p>RocketMQ 网络部署特点：<ul><li>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。<li>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。 注意：当前RocketMQ版本在部署架构上支持一Master多Slave，但只有BrokerId=1的从服务器才会参与消息的读负载。<li>Producer与NameServer集群 某节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic 服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。<li>Consumer与NameServer集群 某节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，消费者在向Master拉取消息时，Master服务器会根据拉取偏移量与最大偏移量的距离（判断是否读老消息，产生读I/O），以及从服务器是否可读等因素建议下一次是从Master还是Slave拉取。</ul><p>集群 工作流程 简述如下：<ul><li>启动NameServer，然后监听端口，等待Broker、Producer、Consumer连接，相当于路由控制中心。<li>启动Broker，与所有NameServer保持长连接，定时发送心跳包。注册成功后，NameServer集群中就有Topic与Broker的映射关系。<li>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。<li>Producer发送消息，启动时与NameServer集群中某一个建立长连接，从中获取当前发送的Topic存在于哪些Broker，从队列列表中轮询选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。<li>Consumer跟Producer类似，跟其中一台NameServer建立长连接，查询当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。</ul><h1 id=2、RocketMQ安装><a class=headerlink href=#2、RocketMQ安装 title=2、RocketMQ安装></a>2、RocketMQ安装</h1><h2 id=2-1、下载><a class=headerlink href=#2-1、下载 title=2.1、下载></a>2.1、下载</h2><p>下载链接：<a href=http://rocketmq.apache.org/release_notes/ rel=noopener target=_blank>http://rocketmq.apache.org/release_notes/</a><h2 id=2-2、安装><a class=headerlink href=#2-2、安装 title=2.2、安装></a>2.2、安装</h2><h3 id=2-2-1、安装步骤><a class=headerlink href=#2-2-1、安装步骤 title=2.2.1、安装步骤></a>2.2.1、安装步骤</h3><ol><li>解压 安装包；<li>进入 安装目录；</ol><h3 id=2-2-2、目录介绍><a class=headerlink href=#2-2-2、目录介绍 title=2.2.2、目录介绍></a>2.2.2、目录介绍</h3><ul><li>bin：启动脚本，包括shell脚本和CMD脚本；<li>conf：实例配置文件 ，包括broker配置文件、logback配置文件等；<li>lib：依赖jar包，包括Netty、commons-lang、FastJSON等；</ul><h2 id=2-3、启动><a class=headerlink href=#2-3、启动 title=2.3、启动></a>2.3、启动</h2><h3 id=2-3-1、Linux环境><a class=headerlink href=#2-3-1、Linux环境 title=2.3.1、Linux环境></a>2.3.1、Linux环境</h3><ol><li><p>启动 NameServer</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>nohup</span> sh mqnamesrv &</span><br></pre></table></figure> <p>启动后可通过命令 <code>tail -f ~/logs/rocketmqlogs/namesrv.log</code> 查看日志。</p><li><p>启动 Broker</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>nohup</span> sh bin/mqbroker -n localhost:9876 &</span><br></pre></table></figure> <p>启动后可通过命令 <code>tail -f ~/logs/rocketmqlogs/broker.log </code> 查看日志。</p></ol><h3 id=2-3-2、Windows环境><a class=headerlink href=#2-3-2、Windows环境 title=2.3.2、Windows环境></a>2.3.2、Windows环境</h3><ol><li><p>启动 NameServer</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>start mqnamesrv.cmd -n 127.0.0.1:9876</span><br></pre></table></figure> <p>启动后可通过命令 <code>tail -f ~/logs/rocketmqlogs/namesrv.log</code> 查看日志。</p><li><p>启动 Broker</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>start bin\mqbroker.cmd -n 127.0.0.1:9876 -c conf\broker.conf autoCreateTopicEnable=<span class=literal>true</span></span><br></pre></table></figure> <p>启动后可通过命令 <code>tail -f ~/logs/rocketmqlogs/broker.log </code> 查看日志。</p></ol><h3 id=2-3-3、优化><a class=headerlink href=#2-3-3、优化 title=2.3.3、优化></a>2.3.3、优化</h3><h4 id=修改虚拟机内存><a class=headerlink href=#修改虚拟机内存 title=修改虚拟机内存></a>修改虚拟机内存</h4><p>RocketMQ 默认虚拟机内存较大，可能导致Broker启动失败。可修改虚拟机内存大小来解决。修改方式如下：<ol><li><p>编辑文件 runbroker.sh / runserver.sh；</p><li><p>修改虚拟机内存大小配置项：</p> <figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>AVA_OPT</span>=<span class=string>"${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span></span><br></pre></table></figure></ol><h4 id=修改broker-conf文件><a class=headerlink href=#修改broker-conf文件 title=修改broker.conf文件></a>修改broker.conf文件</h4><p>编辑broker.conf文件，添加如下配置项：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>brokerIP1</span>=<span class=string>127.0.0.1</span></span><br></pre></table></figure><h2 id=2-4、测试><a class=headerlink href=#2-4、测试 title=2.4、测试></a>2.4、测试</h2><h3 id=2-4-1、发送消息><a class=headerlink href=#2-4-1、发送消息 title=2.4.1、发送消息></a>2.4.1、发送消息</h3><ol><li><p>设置环境变量</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>export</span> NAMESRV_ADDR=localhost:9876</span><br></pre></table></figure><li><p>使用安装包demo发送消息</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br></pre></table></figure></ol><h3 id=2-4-2、消费消息><a class=headerlink href=#2-4-2、消费消息 title=2.4.2、消费消息></a>2.4.2、消费消息</h3><ol><li><p>设置环境变量</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>export</span> NAMESRV_ADDR=localhost:9876</span><br></pre></table></figure><li><p>消费消息</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></table></figure></ol><h2 id=2-5、关闭><a class=headerlink href=#2-5、关闭 title=2.5、关闭></a>2.5、关闭</h2><ol><li><p>关闭NameServer</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># linux env</span></span><br><span class=line>sh bin/mqshutdown namesrv</span><br></pre></table></figure><li><p>关闭Broker</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>sh bin/mqshutdown broker</span><br></pre></table></figure></ol><h1 id=3、Dledger集群搭建><a class=headerlink href=#3、Dledger集群搭建 title=3、Dledger集群搭建></a>3、Dledger集群搭建</h1><p>RocketMQ-on-DLedger Group 是指一组相同名称的 Broker，至少需要 3 个节点，通过 Raft 自动选举出一个 Leader，其余节点 作为 Follower，并在 Leader 和 Follower 之间复制数据以保证高可用。<p>RocketMQ-on-DLedger Group 能自动容灾切换，并保证数据一致。<p>RocketMQ-on-DLedger Group 是可以水平扩展的，也即可以部署任意多个 RocketMQ-on-DLedger Group 同时对外提供服务。<h2 id=3-1、新集群部署><a class=headerlink href=#3-1、新集群部署 title=3.1、新集群部署></a>3.1、新集群部署</h2><h3 id=3-1-1、编写配置><a class=headerlink href=#3-1-1、编写配置 title=3.1.1、编写配置></a>3.1.1、编写配置</h3><p>每个 RocketMQ-on-DLedger Group 至少准备三台机器。编写 3 个配置文件，建议参考 conf/dledger 目录下的配置文件样例。<p>关键配置解析：<table><thead><tr><th align=center>name<th align=center>含义<th align=center>举例<tbody><tr><td align=center>enableDLegerCommitLog<td align=center>是否启动 DLedger<td align=center>true<tr><td align=center>dLegerGroup<td align=center>DLedger Raft Group的名字，建议和 brokerName 保持一致<td align=center>RaftNode00<tr><td align=center>dLegerPeers<td align=center>DLedger Group 内各节点的端口信息，同一个 Group 内的各个节点配置必须要保证一致<td align=center>n0-127.0.0.1:40911;n1-127.0.0.1:40912;n2-127.0.0.1:40913<tr><td align=center>dLegerSelfId<td align=center>节点 id, 必须属于 dLegerPeers 中的一个；同 Group 内各个节点要唯一<td align=center>n0<tr><td align=center>sendMessageThreadPoolNums<td align=center>发送线程个数，建议配置成 Cpu 核数<td align=center>16</table><p><code>conf/dledger/broker-n0.conf</code>配置示例：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=attr>brokerClusterName</span> = <span class=string>RaftCluster</span></span><br><span class=line><span class=attr>brokerName</span>=<span class=string>RaftNode00</span></span><br><span class=line><span class=attr>listenPort</span>=<span class=string>30911</span></span><br><span class=line><span class=attr>namesrvAddr</span>=<span class=string>127.0.0.1:9876</span></span><br><span class=line><span class=attr>storePathRootDir</span>=<span class=string>/tmp/rmqstore/node00</span></span><br><span class=line><span class=attr>storePathCommitLog</span>=<span class=string>/tmp/rmqstore/node00/commitlog</span></span><br><span class=line><span class=attr>enableDLegerCommitLog</span>=<span class=string>true</span></span><br><span class=line><span class=attr>dLegerGroup</span>=<span class=string>RaftNode00</span></span><br><span class=line><span class=attr>dLegerPeers</span>=<span class=string>n0-127.0.0.1:40911;n1-127.0.0.1:40912;n2-127.0.0.1:40913</span></span><br><span class=line><span class=comment>## must be unique</span></span><br><span class=line><span class=attr>dLegerSelfId</span>=<span class=string>n0</span></span><br><span class=line><span class=attr>sendMessageThreadPoolNums</span>=<span class=string>16</span></span><br></pre></table></figure><h3 id=3-1-2、启动Broker><a class=headerlink href=#3-1-2、启动Broker title=3.1.2、启动Broker></a>3.1.2、启动Broker</h3><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=built_in>nohup</span> sh bin/mqbroker -c conf/dledger/xxx-n0.conf &</span><br><span class=line><span class=built_in>nohup</span> sh bin/mqbroker -c conf/dledger/xxx-n1.conf &</span><br><span class=line><span class=built_in>nohup</span> sh bin/mqbroker -c conf/dledger/xxx-n2.conf &</span><br></pre></table></figure><h2 id=3-2、旧集群升级><a class=headerlink href=#3-2、旧集群升级 title=3.2、旧集群升级></a>3.2、旧集群升级</h2><p>如果旧集群采用 Master 方式部署，则每个 Master 都需要转换成一个 RocketMQ-on-DLedger Group。如果旧集群采用 Master-Slave 方式部署，则每个 Master-Slave 组都需要转换成一个 RocketMQ-on-DLedger Group。<h3 id=3-2-1、停掉旧Broker><a class=headerlink href=#3-2-1、停掉旧Broker title=3.2.1、停掉旧Broker></a>3.2.1、停掉旧Broker</h3><p>可以通过 kill 命令来完成，也可以调用 <code>bin/mqshutdown broker</code>。<h3 id=3-2-2、检查旧Commitlog><a class=headerlink href=#3-2-2、检查旧Commitlog title=3.2.2、检查旧Commitlog></a>3.2.2、检查旧Commitlog</h3><p>RocketMQ-on-DLedger 组中的每个节点，可以兼容旧Commitlog ，但其 Raft 复制过程只能针对新增加的消息。因此，为了避免出现异常，需要保证 旧Commitlog 是一致的。<p>如果旧集群采用 Master-Slave 方式部署，那么在shutdown时有可能出现数据不一致，建议通过md5sum方式检查最近的最少 2个Commmitlog文件，如果发现不一致，则通过拷贝方式进行对齐。<p>虽然 RocketMQ-on-DLedger Group 可以适用 2 节点方式部署，但其会丧失 容灾切换能力（2n + 1 原则，至少需要3个节点才能容忍其中 1 个宕机）。所以在对齐了 Master 和 Slave 的 Commitlog 之后，还需要准备第 3 台机器，并把旧的 Commitlog 从 Master 拷贝到 第 3 台机器（记得同时拷贝一下 config 文件夹）。<p>3台机器准备好后 且 旧Commitlog文件也一致后，就可以进行下一步修改配置了。<h3 id=3-2-3、修改配置><a class=headerlink href=#3-2-3、修改配置 title=3.2.3、修改配置></a>3.2.3、修改配置</h3><p>参考 新集群部署。<h3 id=3-2-4、重新启动Broker><a class=headerlink href=#3-2-4、重新启动Broker title=3.2.4、重新启动Broker></a>3.2.4、重新启动Broker</h3><p>参考 新集群部署。<h1 id=4、RocketMQ集群搭建><a class=headerlink href=#4、RocketMQ集群搭建 title=4、RocketMQ集群搭建></a>4、RocketMQ集群搭建</h1><h2 id=4-1、集群模式><a class=headerlink href=#4-1、集群模式 title=4.1、集群模式></a>4.1、集群模式</h2><h3 id=4-1-1、单Master模式><a class=headerlink href=#4-1-1、单Master模式 title=4.1.1、单Master模式></a>4.1.1、单Master模式</h3><p>这种方式风险较大，一旦Broker重启或者宕机时，会导致整个服务不可用。不建议线上环境使用,可以用于本地测试。<h3 id=4-1-2、多Master模式><a class=headerlink href=#4-1-2、多Master模式 title=4.1.2、多Master模式></a>4.1.2、多Master模式</h3><p>这种模式的优缺点如下：<ul><li>优点：配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；<li>缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。</ul><h3 id=4-1-3、多Master多Slave模式（同步）><a class=headerlink href=#4-1-3、多Master多Slave模式（同步） title=4.1.3、多Master多Slave模式（同步）></a>4.1.3、多Master多Slave模式（同步）</h3><p>每个Master配置一个Slave，有多对Master-Slave，HA采用同步双写方式，即只有主备都写成功，才向应用返回成功，这种模式的优缺点如下：<ul><li>优点：数据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；<li>缺点：性能比异步复制模式略低（大约低10%左右），发送单个消息的RT会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。</ul><h3 id=4-1-4、多Master多Slave模式（异步）><a class=headerlink href=#4-1-4、多Master多Slave模式（异步） title=4.1.4、多Master多Slave模式（异步）></a>4.1.4、多Master多Slave模式（异步）</h3><p>每个Master配置一个Slave，有多对Master-Slave，HA采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：<ul><li>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样；<li>缺点：Master宕机，磁盘损坏情况下会丢失少量消息。</ul><h2 id=4-2、双主双从集群搭建><a class=headerlink href=#4-2、双主双从集群搭建 title=4.2、双主双从集群搭建></a>4.2、双主双从集群搭建</h2><h3 id=4-2-1、整体架构><a class=headerlink href=#4-2-1、整体架构 title=4.2.1、整体架构></a>4.2.1、整体架构</h3><p>消息高可用采用2m-2s（同步双写）方式：<p><img alt=image-20210820190620581 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8-image-20210820190620581.png><h3 id=4-2-2、服务器环境><a class=headerlink href=#4-2-2、服务器环境 title=4.2.2、服务器环境></a>4.2.2、服务器环境</h3><table><thead><tr><th><strong>序号</strong><th><strong>IP</strong><th><strong>角色</strong><th><strong>架构模式</strong><tbody><tr><td>1<td>192.168.93.129<td>nameserver、brokerserver<td>Master1、Slave2<tr><td>2<td>192.168.93.130<td>nameserver、brokerserver<td>Master2、Slave1</table><h3 id=4-2-3、准备环境><a class=headerlink href=#4-2-3、准备环境 title=4.2.3、准备环境></a>4.2.3、准备环境</h3><h4 id=Host环境配置><a class=headerlink href=#Host环境配置 title=Host环境配置></a>Host环境配置</h4><p>编辑 /etc/hosts 文件<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment># nameserver</span></span><br><span class=line><span class=attr>192.168.25.135</span> <span class=string>rocketmq-nameserver1</span></span><br><span class=line><span class=attr>192.168.25.138</span> <span class=string>rocketmq-nameserver2</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment># broker</span></span><br><span class=line><span class=attr>192.168.25.135</span> <span class=string>rocketmq-master1</span></span><br><span class=line><span class=attr>192.168.25.135</span> <span class=string>rocketmq-slave2</span></span><br><span class=line><span class=attr>192.168.25.138</span> <span class=string>rocketmq-master2</span></span><br><span class=line><span class=attr>192.168.25.138</span> <span class=string>rocketmq-slave1</span></span><br></pre></table></figure><p>配置完后，重启网卡<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>systemctl restart network</span><br></pre></table></figure><h4 id=防火墙配置><a class=headerlink href=#防火墙配置 title=防火墙配置></a>防火墙配置</h4><p>宿主机需要远程访问虚拟机的rocketmq服务和web服务，需要开放相关的端口号，简单粗暴的方式是直接关闭防火墙：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment># 关闭防火墙</span></span><br><span class=line>systemctl stop firewalld.service</span><br><span class=line></span><br><span class=line><span class=comment># 查看防火墙的状态</span></span><br><span class=line>firewall-cmd --state </span><br><span class=line></span><br><span class=line><span class=comment># 禁止firewall开机启动</span></span><br><span class=line>systemctl <span class=built_in>disable</span> firewalld.service</span><br></pre></table></figure><p>为了安全，只开放特定的端口号，RocketMQ默认使用3个端口：9876 、10911 、11011 。如果防火墙没有关闭的话，那么防火墙就必须开放这些端口：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=comment># 开放name server默认端口</span></span><br><span class=line>firewall-cmd --remove-port=9876/tcp --permanent</span><br><span class=line></span><br><span class=line><span class=comment># 开放master默认端口</span></span><br><span class=line>firewall-cmd --remove-port=10911/tcp --permanent</span><br><span class=line></span><br><span class=line><span class=comment># 开放slave默认端口 (当前集群模式可不开启)</span></span><br><span class=line>firewall-cmd --remove-port=11011/tcp --permanent </span><br><span class=line></span><br><span class=line><span class=comment># 重启防火墙</span></span><br><span class=line>firewall-cmd --reload</span><br></pre></table></figure><h4 id=环境变量配置><a class=headerlink href=#环境变量配置 title=环境变量配置></a>环境变量配置</h4><p>编辑 /etc/profile 文件，并添加相关配置：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>#set rocketmq</span></span><br><span class=line><span class=attr>ROCKETMQ_HOME</span>=<span class=string>/usr/local/rocketmq/rocketmq-all-4.4.0-bin-release</span></span><br><span class=line><span class=attr>PATH</span>=<span class=string>$PATH:$ROCKETMQ_HOME/bin</span></span><br><span class=line><span class=attr>export</span> <span class=string>ROCKETMQ_HOME PATH</span></span><br></pre></table></figure><p>测试执行文件，使配置生效：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>source</span> /etc/profile</span><br></pre></table></figure><h4 id=创建-消息存储-目录><a title="创建 消息存储 目录" class=headerlink href=#创建-消息存储-目录></a>创建 消息存储 目录</h4><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=built_in>mkdir</span> /usr/local/rocketmq/store</span><br><span class=line><span class=built_in>mkdir</span> /usr/local/rocketmq/store/commitlog</span><br><span class=line><span class=built_in>mkdir</span> /usr/local/rocketmq/store/consumequeue</span><br><span class=line><span class=built_in>mkdir</span> /usr/local/rocketmq/store/index</span><br></pre></table></figure><h3 id=4-2-4、Broker配置文件><a class=headerlink href=#4-2-4、Broker配置文件 title=4.2.4、Broker配置文件></a>4.2.4、Broker配置文件</h3><h4 id=4-2-4-1、服务器1><a class=headerlink href=#4-2-4-1、服务器1 title=4.2.4.1、服务器1></a>4.2.4.1、服务器1</h4><h5 id=Master1><a class=headerlink href=#Master1 title=Master1></a>Master1</h5><p>编辑 /usr/soft/rocketmq/conf/2m-2s-sync/broker-a.properties 文件，加入如下配置：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br></pre><td class=code><pre><span class=line><span class=comment>#所属集群名字</span></span><br><span class=line><span class=attr>brokerClusterName</span>=<span class=string>rocketmq-cluster</span></span><br><span class=line><span class=comment>#broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class=line><span class=attr>brokerName</span>=<span class=string>broker-a</span></span><br><span class=line><span class=comment>#0 表示 Master，>0 表示 Slave</span></span><br><span class=line><span class=attr>brokerId</span>=<span class=string>0</span></span><br><span class=line><span class=comment>#nameServer地址，分号分割</span></span><br><span class=line><span class=attr>namesrvAddr</span>=<span class=string>rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span></span><br><span class=line><span class=comment>#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class=line><span class=attr>defaultTopicQueueNums</span>=<span class=string>4</span></span><br><span class=line><span class=comment>#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class=line><span class=attr>autoCreateTopicEnable</span>=<span class=string>true</span></span><br><span class=line><span class=comment>#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class=line><span class=attr>autoCreateSubscriptionGroup</span>=<span class=string>true</span></span><br><span class=line><span class=comment>#Broker 对外服务的监听端口</span></span><br><span class=line><span class=attr>listenPort</span>=<span class=string>10911</span></span><br><span class=line><span class=comment>#删除文件时间点，默认凌晨 4点</span></span><br><span class=line><span class=attr>deleteWhen</span>=<span class=string>04</span></span><br><span class=line><span class=comment>#文件保留时间，默认 48 小时</span></span><br><span class=line><span class=attr>fileReservedTime</span>=<span class=string>120</span></span><br><span class=line><span class=comment>#commitLog每个文件的大小默认1G</span></span><br><span class=line><span class=attr>mapedFileSizeCommitLog</span>=<span class=string>1073741824</span></span><br><span class=line><span class=comment>#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class=line><span class=attr>mapedFileSizeConsumeQueue</span>=<span class=string>300000</span></span><br><span class=line><span class=comment>#destroyMapedFileIntervalForcibly=120000</span></span><br><span class=line><span class=comment>#redeleteHangedFileInterval=120000</span></span><br><span class=line><span class=comment>#检测物理文件磁盘空间</span></span><br><span class=line><span class=attr>diskMaxUsedSpaceRatio</span>=<span class=string>88</span></span><br><span class=line><span class=comment>#存储路径</span></span><br><span class=line><span class=attr>storePathRootDir</span>=<span class=string>/usr/local/rocketmq/store</span></span><br><span class=line><span class=comment>#commitLog 存储路径</span></span><br><span class=line><span class=attr>storePathCommitLog</span>=<span class=string>/usr/local/rocketmq/store/commitlog</span></span><br><span class=line><span class=comment>#消费队列存储路径存储路径</span></span><br><span class=line><span class=attr>storePathConsumeQueue</span>=<span class=string>/usr/local/rocketmq/store/consumequeue</span></span><br><span class=line><span class=comment>#消息索引存储路径</span></span><br><span class=line><span class=attr>storePathIndex</span>=<span class=string>/usr/local/rocketmq/store/index</span></span><br><span class=line><span class=comment>#checkpoint 文件存储路径</span></span><br><span class=line><span class=attr>storeCheckpoint</span>=<span class=string>/usr/local/rocketmq/store/checkpoint</span></span><br><span class=line><span class=comment>#abort 文件存储路径</span></span><br><span class=line><span class=attr>abortFile</span>=<span class=string>/usr/local/rocketmq/store/abort</span></span><br><span class=line><span class=comment>#限制的消息大小</span></span><br><span class=line><span class=attr>maxMessageSize</span>=<span class=string>65536</span></span><br><span class=line><span class=comment>#flushCommitLogLeastPages=4</span></span><br><span class=line><span class=comment>#flushConsumeQueueLeastPages=2</span></span><br><span class=line><span class=comment>#flushCommitLogThoroughInterval=10000</span></span><br><span class=line><span class=comment>#flushConsumeQueueThoroughInterval=60000</span></span><br><span class=line><span class=comment>#Broker 的角色</span></span><br><span class=line><span class=comment>#- ASYNC_MASTER 异步复制Master</span></span><br><span class=line><span class=comment>#- SYNC_MASTER 同步双写Master</span></span><br><span class=line><span class=comment>#- SLAVE</span></span><br><span class=line><span class=attr>brokerRole</span>=<span class=string>SYNC_MASTER</span></span><br><span class=line><span class=comment>#刷盘方式</span></span><br><span class=line><span class=comment>#- ASYNC_FLUSH 异步刷盘</span></span><br><span class=line><span class=comment>#- SYNC_FLUSH 同步刷盘</span></span><br><span class=line><span class=attr>flushDiskType</span>=<span class=string>SYNC_FLUSH</span></span><br><span class=line><span class=comment>#checkTransactionMessageEnable=false</span></span><br><span class=line><span class=comment>#发消息线程池数量</span></span><br><span class=line><span class=comment>#sendMessageThreadPoolNums=128</span></span><br><span class=line><span class=comment>#拉消息线程池数量</span></span><br><span class=line><span class=comment>#pullMessageThreadPoolNums=128</span></span><br></pre></table></figure><h5 id=Slave2><a class=headerlink href=#Slave2 title=Slave2></a>Slave2</h5><p>编辑 /usr/soft/rocketmq/conf/2m-2s-sync/broker-b-s.properties 文件，并添加如下配置：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br></pre><td class=code><pre><span class=line><span class=comment>#所属集群名字</span></span><br><span class=line><span class=attr>brokerClusterName</span>=<span class=string>rocketmq-cluster</span></span><br><span class=line><span class=comment>#broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class=line><span class=attr>brokerName</span>=<span class=string>broker-b</span></span><br><span class=line><span class=comment>#0 表示 Master，>0 表示 Slave</span></span><br><span class=line><span class=attr>brokerId</span>=<span class=string>1</span></span><br><span class=line><span class=comment>#nameServer地址，分号分割</span></span><br><span class=line><span class=attr>namesrvAddr</span>=<span class=string>rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span></span><br><span class=line><span class=comment>#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class=line><span class=attr>defaultTopicQueueNums</span>=<span class=string>4</span></span><br><span class=line><span class=comment>#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class=line><span class=attr>autoCreateTopicEnable</span>=<span class=string>true</span></span><br><span class=line><span class=comment>#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class=line><span class=attr>autoCreateSubscriptionGroup</span>=<span class=string>true</span></span><br><span class=line><span class=comment>#Broker 对外服务的监听端口</span></span><br><span class=line><span class=attr>listenPort</span>=<span class=string>11011</span></span><br><span class=line><span class=comment>#删除文件时间点，默认凌晨 4点</span></span><br><span class=line><span class=attr>deleteWhen</span>=<span class=string>04</span></span><br><span class=line><span class=comment>#文件保留时间，默认 48 小时</span></span><br><span class=line><span class=attr>fileReservedTime</span>=<span class=string>120</span></span><br><span class=line><span class=comment>#commitLog每个文件的大小默认1G</span></span><br><span class=line><span class=attr>mapedFileSizeCommitLog</span>=<span class=string>1073741824</span></span><br><span class=line><span class=comment>#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class=line><span class=attr>mapedFileSizeConsumeQueue</span>=<span class=string>300000</span></span><br><span class=line><span class=comment>#destroyMapedFileIntervalForcibly=120000</span></span><br><span class=line><span class=comment>#redeleteHangedFileInterval=120000</span></span><br><span class=line><span class=comment>#检测物理文件磁盘空间</span></span><br><span class=line><span class=attr>diskMaxUsedSpaceRatio</span>=<span class=string>88</span></span><br><span class=line><span class=comment>#存储路径</span></span><br><span class=line><span class=attr>storePathRootDir</span>=<span class=string>/usr/local/rocketmq/store</span></span><br><span class=line><span class=comment>#commitLog 存储路径</span></span><br><span class=line><span class=attr>storePathCommitLog</span>=<span class=string>/usr/local/rocketmq/store/commitlog</span></span><br><span class=line><span class=comment>#消费队列存储路径存储路径</span></span><br><span class=line><span class=attr>storePathConsumeQueue</span>=<span class=string>/usr/local/rocketmq/store/consumequeue</span></span><br><span class=line><span class=comment>#消息索引存储路径</span></span><br><span class=line><span class=attr>storePathIndex</span>=<span class=string>/usr/local/rocketmq/store/index</span></span><br><span class=line><span class=comment>#checkpoint 文件存储路径</span></span><br><span class=line><span class=attr>storeCheckpoint</span>=<span class=string>/usr/local/rocketmq/store/checkpoint</span></span><br><span class=line><span class=comment>#abort 文件存储路径</span></span><br><span class=line><span class=attr>abortFile</span>=<span class=string>/usr/local/rocketmq/store/abort</span></span><br><span class=line><span class=comment>#限制的消息大小</span></span><br><span class=line><span class=attr>maxMessageSize</span>=<span class=string>65536</span></span><br><span class=line><span class=comment>#flushCommitLogLeastPages=4</span></span><br><span class=line><span class=comment>#flushConsumeQueueLeastPages=2</span></span><br><span class=line><span class=comment>#flushCommitLogThoroughInterval=10000</span></span><br><span class=line><span class=comment>#flushConsumeQueueThoroughInterval=60000</span></span><br><span class=line><span class=comment>#Broker 的角色</span></span><br><span class=line><span class=comment>#- ASYNC_MASTER 异步复制Master</span></span><br><span class=line><span class=comment>#- SYNC_MASTER 同步双写Master</span></span><br><span class=line><span class=comment>#- SLAVE</span></span><br><span class=line><span class=attr>brokerRole</span>=<span class=string>SLAVE</span></span><br><span class=line><span class=comment>#刷盘方式</span></span><br><span class=line><span class=comment>#- ASYNC_FLUSH 异步刷盘</span></span><br><span class=line><span class=comment>#- SYNC_FLUSH 同步刷盘</span></span><br><span class=line><span class=attr>flushDiskType</span>=<span class=string>ASYNC_FLUSH</span></span><br><span class=line><span class=comment>#checkTransactionMessageEnable=false</span></span><br><span class=line><span class=comment>#发消息线程池数量</span></span><br><span class=line><span class=comment>#sendMessageThreadPoolNums=128</span></span><br><span class=line><span class=comment>#拉消息线程池数量</span></span><br><span class=line><span class=comment>#pullMessageThreadPoolNums=128</span></span><br></pre></table></figure><h4 id=4-2-4-2、服务器2><a class=headerlink href=#4-2-4-2、服务器2 title=4.2.4.2、服务器2></a>4.2.4.2、服务器2</h4><h5 id=Master2><a class=headerlink href=#Master2 title=Master2></a>Master2</h5><p>编辑 /usr/soft/rocketmq/conf/2m-2s-sync/broker-b.properties 文件，添加如下配置：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br></pre><td class=code><pre><span class=line><span class=comment>#所属集群名字</span></span><br><span class=line><span class=attr>brokerClusterName</span>=<span class=string>rocketmq-cluster</span></span><br><span class=line><span class=comment>#broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class=line><span class=attr>brokerName</span>=<span class=string>broker-b</span></span><br><span class=line><span class=comment>#0 表示 Master，>0 表示 Slave</span></span><br><span class=line><span class=attr>brokerId</span>=<span class=string>0</span></span><br><span class=line><span class=comment>#nameServer地址，分号分割</span></span><br><span class=line><span class=attr>namesrvAddr</span>=<span class=string>rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span></span><br><span class=line><span class=comment>#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class=line><span class=attr>defaultTopicQueueNums</span>=<span class=string>4</span></span><br><span class=line><span class=comment>#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class=line><span class=attr>autoCreateTopicEnable</span>=<span class=string>true</span></span><br><span class=line><span class=comment>#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class=line><span class=attr>autoCreateSubscriptionGroup</span>=<span class=string>true</span></span><br><span class=line><span class=comment>#Broker 对外服务的监听端口</span></span><br><span class=line><span class=attr>listenPort</span>=<span class=string>10911</span></span><br><span class=line><span class=comment>#删除文件时间点，默认凌晨 4点</span></span><br><span class=line><span class=attr>deleteWhen</span>=<span class=string>04</span></span><br><span class=line><span class=comment>#文件保留时间，默认 48 小时</span></span><br><span class=line><span class=attr>fileReservedTime</span>=<span class=string>120</span></span><br><span class=line><span class=comment>#commitLog每个文件的大小默认1G</span></span><br><span class=line><span class=attr>mapedFileSizeCommitLog</span>=<span class=string>1073741824</span></span><br><span class=line><span class=comment>#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class=line><span class=attr>mapedFileSizeConsumeQueue</span>=<span class=string>300000</span></span><br><span class=line><span class=comment>#destroyMapedFileIntervalForcibly=120000</span></span><br><span class=line><span class=comment>#redeleteHangedFileInterval=120000</span></span><br><span class=line><span class=comment>#检测物理文件磁盘空间</span></span><br><span class=line><span class=attr>diskMaxUsedSpaceRatio</span>=<span class=string>88</span></span><br><span class=line><span class=comment>#存储路径</span></span><br><span class=line><span class=attr>storePathRootDir</span>=<span class=string>/usr/local/rocketmq/store</span></span><br><span class=line><span class=comment>#commitLog 存储路径</span></span><br><span class=line><span class=attr>storePathCommitLog</span>=<span class=string>/usr/local/rocketmq/store/commitlog</span></span><br><span class=line><span class=comment>#消费队列存储路径存储路径</span></span><br><span class=line><span class=attr>storePathConsumeQueue</span>=<span class=string>/usr/local/rocketmq/store/consumequeue</span></span><br><span class=line><span class=comment>#消息索引存储路径</span></span><br><span class=line><span class=attr>storePathIndex</span>=<span class=string>/usr/local/rocketmq/store/index</span></span><br><span class=line><span class=comment>#checkpoint 文件存储路径</span></span><br><span class=line><span class=attr>storeCheckpoint</span>=<span class=string>/usr/local/rocketmq/store/checkpoint</span></span><br><span class=line><span class=comment>#abort 文件存储路径</span></span><br><span class=line><span class=attr>abortFile</span>=<span class=string>/usr/local/rocketmq/store/abort</span></span><br><span class=line><span class=comment>#限制的消息大小</span></span><br><span class=line><span class=attr>maxMessageSize</span>=<span class=string>65536</span></span><br><span class=line><span class=comment>#flushCommitLogLeastPages=4</span></span><br><span class=line><span class=comment>#flushConsumeQueueLeastPages=2</span></span><br><span class=line><span class=comment>#flushCommitLogThoroughInterval=10000</span></span><br><span class=line><span class=comment>#flushConsumeQueueThoroughInterval=60000</span></span><br><span class=line><span class=comment>#Broker 的角色</span></span><br><span class=line><span class=comment>#- ASYNC_MASTER 异步复制Master</span></span><br><span class=line><span class=comment>#- SYNC_MASTER 同步双写Master</span></span><br><span class=line><span class=comment>#- SLAVE</span></span><br><span class=line><span class=attr>brokerRole</span>=<span class=string>SYNC_MASTER</span></span><br><span class=line><span class=comment>#刷盘方式</span></span><br><span class=line><span class=comment>#- ASYNC_FLUSH 异步刷盘</span></span><br><span class=line><span class=comment>#- SYNC_FLUSH 同步刷盘</span></span><br><span class=line><span class=attr>flushDiskType</span>=<span class=string>SYNC_FLUSH</span></span><br><span class=line><span class=comment>#checkTransactionMessageEnable=false</span></span><br><span class=line><span class=comment>#发消息线程池数量</span></span><br><span class=line><span class=comment>#sendMessageThreadPoolNums=128</span></span><br><span class=line><span class=comment>#拉消息线程池数量</span></span><br><span class=line><span class=comment>#pullMessageThreadPoolNums=128</span></span><br></pre></table></figure><h5 id=Slave1><a class=headerlink href=#Slave1 title=Slave1></a>Slave1</h5><p>编辑 /usr/soft/rocketmq/conf/2m-2s-sync/broker-a-s.properties 文件，添加如下配置：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br></pre><td class=code><pre><span class=line><span class=comment>#所属集群名字</span></span><br><span class=line><span class=attr>brokerClusterName</span>=<span class=string>rocketmq-cluster</span></span><br><span class=line><span class=comment>#broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class=line><span class=attr>brokerName</span>=<span class=string>broker-a</span></span><br><span class=line><span class=comment>#0 表示 Master，>0 表示 Slave</span></span><br><span class=line><span class=attr>brokerId</span>=<span class=string>1</span></span><br><span class=line><span class=comment>#nameServer地址，分号分割</span></span><br><span class=line><span class=attr>namesrvAddr</span>=<span class=string>rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span></span><br><span class=line><span class=comment>#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class=line><span class=attr>defaultTopicQueueNums</span>=<span class=string>4</span></span><br><span class=line><span class=comment>#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class=line><span class=attr>autoCreateTopicEnable</span>=<span class=string>true</span></span><br><span class=line><span class=comment>#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class=line><span class=attr>autoCreateSubscriptionGroup</span>=<span class=string>true</span></span><br><span class=line><span class=comment>#Broker 对外服务的监听端口</span></span><br><span class=line><span class=attr>listenPort</span>=<span class=string>11011</span></span><br><span class=line><span class=comment>#删除文件时间点，默认凌晨 4点</span></span><br><span class=line><span class=attr>deleteWhen</span>=<span class=string>04</span></span><br><span class=line><span class=comment>#文件保留时间，默认 48 小时</span></span><br><span class=line><span class=attr>fileReservedTime</span>=<span class=string>120</span></span><br><span class=line><span class=comment>#commitLog每个文件的大小默认1G</span></span><br><span class=line><span class=attr>mapedFileSizeCommitLog</span>=<span class=string>1073741824</span></span><br><span class=line><span class=comment>#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class=line><span class=attr>mapedFileSizeConsumeQueue</span>=<span class=string>300000</span></span><br><span class=line><span class=comment>#destroyMapedFileIntervalForcibly=120000</span></span><br><span class=line><span class=comment>#redeleteHangedFileInterval=120000</span></span><br><span class=line><span class=comment>#检测物理文件磁盘空间</span></span><br><span class=line><span class=attr>diskMaxUsedSpaceRatio</span>=<span class=string>88</span></span><br><span class=line><span class=comment>#存储路径</span></span><br><span class=line><span class=attr>storePathRootDir</span>=<span class=string>/usr/local/rocketmq/store</span></span><br><span class=line><span class=comment>#commitLog 存储路径</span></span><br><span class=line><span class=attr>storePathCommitLog</span>=<span class=string>/usr/local/rocketmq/store/commitlog</span></span><br><span class=line><span class=comment>#消费队列存储路径存储路径</span></span><br><span class=line><span class=attr>storePathConsumeQueue</span>=<span class=string>/usr/local/rocketmq/store/consumequeue</span></span><br><span class=line><span class=comment>#消息索引存储路径</span></span><br><span class=line><span class=attr>storePathIndex</span>=<span class=string>/usr/local/rocketmq/store/index</span></span><br><span class=line><span class=comment>#checkpoint 文件存储路径</span></span><br><span class=line><span class=attr>storeCheckpoint</span>=<span class=string>/usr/local/rocketmq/store/checkpoint</span></span><br><span class=line><span class=comment>#abort 文件存储路径</span></span><br><span class=line><span class=attr>abortFile</span>=<span class=string>/usr/local/rocketmq/store/abort</span></span><br><span class=line><span class=comment>#限制的消息大小</span></span><br><span class=line><span class=attr>maxMessageSize</span>=<span class=string>65536</span></span><br><span class=line><span class=comment>#flushCommitLogLeastPages=4</span></span><br><span class=line><span class=comment>#flushConsumeQueueLeastPages=2</span></span><br><span class=line><span class=comment>#flushCommitLogThoroughInterval=10000</span></span><br><span class=line><span class=comment>#flushConsumeQueueThoroughInterval=60000</span></span><br><span class=line><span class=comment>#Broker 的角色</span></span><br><span class=line><span class=comment>#- ASYNC_MASTER 异步复制Master</span></span><br><span class=line><span class=comment>#- SYNC_MASTER 同步双写Master</span></span><br><span class=line><span class=comment>#- SLAVE</span></span><br><span class=line><span class=attr>brokerRole</span>=<span class=string>SLAVE</span></span><br><span class=line><span class=comment>#刷盘方式</span></span><br><span class=line><span class=comment>#- ASYNC_FLUSH 异步刷盘</span></span><br><span class=line><span class=comment>#- SYNC_FLUSH 同步刷盘</span></span><br><span class=line><span class=attr>flushDiskType</span>=<span class=string>ASYNC_FLUSH</span></span><br><span class=line><span class=comment>#checkTransactionMessageEnable=false</span></span><br><span class=line><span class=comment>#发消息线程池数量</span></span><br><span class=line><span class=comment>#sendMessageThreadPoolNums=128</span></span><br><span class=line><span class=comment>#拉消息线程池数量</span></span><br><span class=line><span class=comment>#pullMessageThreadPoolNums=128</span></span><br></pre></table></figure><h3 id=4-2-5、修改启动脚本><a class=headerlink href=#4-2-5、修改启动脚本 title=4.2.5、修改启动脚本></a>4.2.5、修改启动脚本</h3><p>编辑 /usr/local/rocketmq/bin/runbroker.sh 文件，修改如下配置项：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>JAVA_OPT</span>=<span class=string>"${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m"</span></span><br></pre></table></figure><p>编辑 /usr/local/rocketmq/bin/runserver.sh 文件，修改如下配置项：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>JAVA_OPT</span>=<span class=string>"${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span></span><br></pre></table></figure><h3 id=4-2-6、启动服务><a class=headerlink href=#4-2-6、启动服务 title=4.2.6、启动服务></a>4.2.6、启动服务</h3><h4 id=启动NameServer集群><a class=headerlink href=#启动NameServer集群 title=启动NameServer集群></a>启动NameServer集群</h4><p>分别在192.168.93.129 和 192.168.93.130中执行如下命令：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>nohup</span> sh /usr/local/rocketmq/bin/mqnamesrv &</span><br></pre></table></figure><h4 id=启动Broker集群><a class=headerlink href=#启动Broker集群 title=启动Broker集群></a>启动Broker集群</h4><p>在192.168.93.129 中启动 master1 和 slave2。执行如下命令：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment># master1</span></span><br><span class=line><span class=built_in>cd</span> /usr/local/rocketmq/bin</span><br><span class=line><span class=built_in>nohup</span> sh mqbroker -c /usr/local/rocketmq/conf/2m-2s-syncbroker-a.properties &</span><br><span class=line></span><br><span class=line><span class=comment>#slave2</span></span><br><span class=line><span class=built_in>cd</span> /usr/local/rocketmq/bin</span><br><span class=line><span class=built_in>nohup</span> sh mqbroker -c /usr/local/rocketmq/conf/2m-2s-<span class=built_in>sync</span>/broker-b-s.properties &</span><br></pre></table></figure><p>在192.168.93.130 中启动 master2 和 slave1。执行如下命令：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>#master2</span></span><br><span class=line><span class=built_in>cd</span> /usr/local/rocketmq/bin</span><br><span class=line><span class=built_in>nohup</span> sh mqbroker -c /usr/local/rocketmq/conf/2m-2s-<span class=built_in>sync</span>/broker-b.properties &</span><br><span class=line></span><br><span class=line><span class=comment>#slave1</span></span><br><span class=line><span class=built_in>cd</span> /usr/local/rocketmq/bin</span><br><span class=line><span class=built_in>nohup</span> sh mqbroker -c /usr/local/rocketmq/conf/2m-2s-<span class=built_in>sync</span>/broker-a-s.properties &</span><br></pre></table></figure><h3 id=4-2-7、查看进程状态和日志><a class=headerlink href=#4-2-7、查看进程状态和日志 title=4.2.7、查看进程状态和日志></a>4.2.7、查看进程状态和日志</h3><h4 id=查看进程状态><a class=headerlink href=#查看进程状态 title=查看进程状态></a>查看进程状态</h4><p>启动成功后，通过 命令<code>jps</code> 即可查看进程状态。<h4 id=查看日志><a class=headerlink href=#查看日志 title=查看日志></a>查看日志</h4><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment># 查看nameServer日志</span></span><br><span class=line><span class=built_in>tail</span> -500f ~/logs/rocketmqlogs/namesrv.log</span><br><span class=line></span><br><span class=line><span class=comment># 查看broker日志</span></span><br><span class=line><span class=built_in>tail</span> -500f ~/logs/rocketmqlogs/broker.log</span><br></pre></table></figure><h3 id=4-2-8、注意事项><a class=headerlink href=#4-2-8、注意事项 title=4.2.8、注意事项></a>4.2.8、注意事项</h3><ul><li>几乎所有命令都需要配置-n表示NameServer地址，格式为ip:port；<li>几乎所有命令都可以通过-h获取帮助；<li>如果既有Broker地址（-b）配置项又有clusterName（-c）配置项，则优先以Broker地址执行命令；如果不配置Broker地址，则对集群中所有主机执行命令；</ul><h2 id=4-3、集群监控平台搭建><a class=headerlink href=#4-3、集群监控平台搭建 title=4.3、集群监控平台搭建></a>4.3、集群监控平台搭建</h2><h3 id=4-3-1、概述><a class=headerlink href=#4-3-1、概述 title=4.3.1、概述></a>4.3.1、概述</h3><p><code>RocketMQ</code>有一个对其扩展的开源项目<a href=https://github.com/apache/rocketmq-externals rel=noopener target=_blank>incubator-rocketmq-externals</a>，这个项目中有一个子模块叫<code>rocketmq-console</code>，这个便是管理控制台项目了，下面将介绍如何安装使用该控制平台。<h3 id=4-3-2、下载编译打包><a class=headerlink href=#4-3-2、下载编译打包 title=4.3.2、下载编译打包></a>4.3.2、下载编译打包</h3><h4 id=下载><a class=headerlink href=#下载 title=下载></a>下载</h4><p>rabbitmq-console 下载地址：<a href=https://github.com/apache/rocketmq-externals/releases/tag/rocketmq-console-1.0.0%E3%80%82 rel=noopener target=_blank>https://github.com/apache/rocketmq-externals/releases/tag/rocketmq-console-1.0.0。</a><h4 id=编译打包><a class=headerlink href=#编译打包 title=编译打包></a>编译打包</h4><p>进入到rocketmq-console目录，执行如下命令：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>mvn clean package -Dmaven.test.skip=<span class=literal>true</span></span><br></pre></table></figure><p>注意：打包前在<code>rocketmq-console</code>中配置<code>namesrv</code>集群地址：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>rocketmq.config.namesrvAddr</span>=<span class=string>192.168.25.135:9876;192.168.25.138:9876</span></span><br></pre></table></figure><h3 id=4-3-3、启动并访问控制台><a class=headerlink href=#4-3-3、启动并访问控制台 title=4.3.3、启动并访问控制台></a>4.3.3、启动并访问控制台</h3><h3 id=4-3-1、方式一><a class=headerlink href=#4-3-1、方式一 title=4.3.1、方式一></a>4.3.1、方式一</h3><p>启动rocketmq-console：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -jar rocketmq-console-ng-1.0.0.jar</span><br></pre></table></figure><p>启动成功后，我们就可以通过浏览器访问<code>http://localhost:8080</code>进入控制台界面了。<h3 id=4-3-2、方式二><a class=headerlink href=#4-3-2、方式二 title=4.3.2、方式二></a>4.3.2、方式二</h3><p>将下载下来的rocketmq-console项目导入IDEA中，因为其是一个springboot项目，故直接启动注解@SpringBootApplication标记的类的main方法既可，启动成功后，同样通过访问<code>http://localhost:8080</code>即可进入控制台界面。</div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/RocketMQ%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/RocketMQ%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ itemprop=url>RocketMQ系列-RocketMQ原理解析</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 20:24:56" datetime=2023-10-02T20:24:56+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/RocketMQ/ itemprop=url rel=index><span itemprop=name>RocketMQ</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、消息存储><a class=headerlink href=#1、消息存储 title=1、消息存储></a>1、消息存储</h1><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-RocketMQ%E8%AE%BE%E8%AE%A1-%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%8401.png><p>消息存储是RocketMQ中最复杂和最重要的一部分，下面将从 RocketMQ消息存储整体架构、PageCache与Mmap内存映射、RocketMQ中两种不同的刷盘方式等 三方面来展开叙述。<h2 id=1-1、消息存储架构><a class=headerlink href=#1-1、消息存储架构 title=1.1、消息存储架构></a>1.1、消息存储架构</h2><p>消息存储架构图中 与 消息存储相关的文件有 3个：<ul><li><p><font color=orange>CommitLog</font></p> <p><font color=orange>定义</font>：消息主体、元数据的存储主体。</p> <p><font color=orange>工作过程</font>：Producer端写入的消息内容 并非是定长 的。单个文件大小默认1G ，文件名长度为20位，左边补零，剩余为起始偏移量。</p> <p>比如 00000000000000000000 代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件；</p><li><p><font color=orange>ConsumeQueue</font></p> <p><font color=orange>定义</font>：消息消费队列。是基于topic的commitlog索引文件，故consumequeue文件夹的组织方式如下：topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。</p> <p><font color=orange>设计</font>：consumequeue文件采取定长设计，每一个条目共20个字节，分别为8字节的commitlog物理偏移量、4字节的消息长度、8字节tag hashcode，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M；</p> <p><font color=orange>作用</font>：主要为了提高消息消费的性能。</p> <p><font color=orange>工作过程</font>：消息的消费是针对主题进行的，Consumer可根据ConsumeQueue来查找待消费的消息。</p> <p><font color=orange>保存内容</font>：ConsumeQueue作为消费消息的索引，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset、消息大小size 和 消息Tag的HashCode值。</p><li><p><font color=orange>IndexFile</font></p> <p><font color=orange>作用</font>：通过 key 或 时间区间 查询消息 的方法。</p> <p><font color=orange>文件大小</font>：文件名fileName是以创建时的时间戳命名的。固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引。</p> <p><font color=orange>存储位置c</font>：$HOME \store\index${fileName}。</p> <p><font color=orange>底层设计</font>：IndexFile的底层存储设计为在文件系统中实现HashMap结构，故rocketmq的索引文件其底层实现为hash索引。</p></ul><p><strong>RocketMQ采用 混合型存储结构，即单个Broker实例下所有的队列共用一个日志数据文件（CommitLog）来存储。</strong><p>RocketMQ混合型存储结构（多个Topic消息实体内容都存储于一个CommitLog中）针对 Producer 和 Consumer 分别采用了【数据 和 索引 相分离的 存储结构】。Producer发送消息至Broker，然后Broker通过同步或异步方式将消息保存至CommitLog。一旦保存其中，Producer发送的消息就不会丢失。<p>无法拉取消息 时 可以等下一次消息拉取，同时服务端也支持【长轮询模式】。如果 一个消息拉取请求 未拉取到 消息，Broker允许等待30s时间，只要这段时间内有新消息到达，将直接返回给消费端。RocketMQ具体做法：使用Broker后台服务线程ReputMessageService不停 分发请求 并 异步构建ConsumeQueue（逻辑消费队列）和 IndexFile（索引文件）数据。<h2 id=1-2、页缓存与内存映射><a class=headerlink href=#1-2、页缓存与内存映射 title=1.2、页缓存与内存映射></a>1.2、页缓存与内存映射</h2><h3 id=1-2-1、页缓存><a class=headerlink href=#1-2-1、页缓存 title=1.2.1、页缓存></a>1.2.1、页缓存</h3><p><strong>页缓存是OS对文件的缓存，用于加速文件读写。</strong><p>程序 顺序读写速度 接近于 内存读写速度，主要原因是 OS 使用 PageCache机制 优化了 读写。<ul><li><p><font color=orange>写入数据</font></p> <p>OS先写入Cache中，后通过 异步方式 由 pdflush内核线程 将 Cache中的数据刷新至物理磁盘。</p><li><p><font color=orange>读取数据</font></p> <p>如果一次读取文件 未命中PageChche，那么OS从物理磁盘读取文件时会将相邻数据文件一块读取。</p></ul><blockquote><p>ConsumeQueue逻辑消费队列存储的数据较少，且是顺序读取，在page cache辅助下其读性能接近于内存，即使是消息堆积也不会影响性能。<p>对 CommitLog日志数据文件的读取是随机的，严重影响性能。但如果选择合适的系统IO调度算法，那么性能也会有一定的提升。</blockquote><h3 id=1-2-2、内存映射><a class=headerlink href=#1-2-2、内存映射 title=1.2.2、内存映射></a>1.2.2、内存映射</h3><p>RocketMQ主要通过 MappedByteBuffer 对文件进行读写操作。利用了NIO 的 FileChannel模型 将磁盘上的物理文件 直接映射到 用户态内存地址中，将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率（正因为需要使用内存映射机制，故RocketMQ的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存）。<h2 id=1-3、消息刷盘><a class=headerlink href=#1-3、消息刷盘 title=1.3、消息刷盘></a>1.3、消息刷盘</h2><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-RocketMQ%E8%AE%BE%E8%AE%A1-%E6%B6%88%E6%81%AF%E5%88%B7%E7%9B%9801.png><p>消息刷盘 主要有 两种：<ul><li><p><font color=orange>同步刷盘</font></p> <p>消息 成功持久化至 磁盘后 Broker端才会返回成功的ACK响应给Producer端。同步刷盘可有效保证 MQ消息的可靠性，但对性能会有较大影响，一般适用于金融业务。</p><li><p><font color=orange>异步刷盘</font></p> <p>能充分利用【OS PageCache】优势，消息写入PageCache后就可返回ACK给Producer端。消息刷盘 采用 后台异步线程 进行，降低了读写延迟，提高了MQ性能和吞吐量。</p></ul><h1 id=2、通信机制><a class=headerlink href=#2、通信机制 title=2、通信机制></a>2、通信机制</h1><h2 id=2-1、简介><a class=headerlink href=#2-1、简介 title=2.1、简介></a>2.1、简介</h2><p><strong>RocketMQ集群 主要包括 NameServer、Broker(Master/Slave)、Producer、Consumer4个角色，</strong>基本通讯流程如下：<ol><li>Broker启动后需将自己【注册】至NameServer；随后每隔30s定时向NameServer【上报】Topic路由信息。<li>Producer发送消息时 需要根据 消息的Topic 从本地缓存TopicPublishInfoTable中获取路由信息。如果没有则更新路由信息并从NameServer上重新拉取，同时Producer会默认每隔30s向NameServer拉取一次路由信息。<li>Producer 根据 第2步中获取的路由信息 选择 一个队列 来发送消息；Broker 接收消息 并 落盘存储。<li>Consumer 根据 第2步中获取的路由信息，并在完成客户端负载均衡后，选择其中的某一个或某几个消息队列来拉取消息并消费。</ol><p>从 第1步~第3步 中可以看出 消息在生产者、Broker和NameServer之间都会发生通信。<p>rocketmq-remoting 负责网络通信。为了实现客户端与服务器之间的高效通信，自定义了通信协议并在Netty基础上扩展了通信模块。<h2 id=2-2、Remoting通信类结构><a class=headerlink href=#2-2、Remoting通信类结构 title=2.2、Remoting通信类结构></a>2.2、Remoting通信类结构</h2><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-RocketMQ%E8%AE%BE%E8%AE%A1-Remoting%E9%80%9A%E4%BF%A1%E7%B1%BB%E7%BB%93%E6%9E%84.png><h2 id=2-3、协议设计与编解码><a class=headerlink href=#2-3、协议设计与编解码 title=2.3、协议设计与编解码></a>2.3、协议设计与编解码</h2><p><strong>Producer发送消息 需要协议 来约定，故有必要自定义RocketMQ消息协议。为 高效 网络传输消息 和 读取消息，需要对消息进行编解码。</strong>类RemotingCommand在消息传输过程中会对所有数据内容进行封装，不但包含了所有的数据结构，还包含了编码解码操作。<table><thead><tr><th align=center>Header字段<th align=center>类型<th align=center>Request说明<th align=center>Response说明<tbody><tr><td align=center>code<td align=center>int<td align=center>请求操作码，应答方根据不同的请求码进行不同的业务处理<td align=center>应答响应码。0表示成功，非0则表示各种错误<tr><td align=center>language<td align=center>LanguageCode<td align=center>请求方实现的语言<td align=center>应答方实现的语言<tr><td align=center>version<td align=center>int<td align=center>请求方程序的版本<td align=center>应答方程序的版本<tr><td align=center>opaque<td align=center>int<td align=center>相当于requestId，在同一个连接上的不同请求标识码，与响应消息中的相对应<td align=center>应答不做修改直接返回<tr><td align=center>flag<td align=center>int<td align=center>区分是普通RPC还是onewayRPC的标志<td align=center>区分是普通RPC还是onewayRPC的标志<tr><td align=center>remark<td align=center>String<td align=center>传输自定义文本信息<td align=center>传输自定义文本信息<tr><td align=center>extFields<td align=center>HashMap&LTString, String><td align=center>请求自定义扩展信息<td align=center>响应自定义扩展信息</table><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-image-20210819150130564.png><p>传输内容主要可分为以下4部分：<ul><li><font color=orange>消息长度</font>：总长度，四个字节存储，占用一个int类型；<li><font color=orange>序列化类型&消息头长度</font>：同样占用一个int类型，第一个字节表示序列化类型，后面三个字节表示消息头长度；<li><font color=orange>消息头数据</font>：经过序列化后的消息头数据；<li><font color=orange>消息主体数据</font>：消息主体的二进制字节数据内容；</ul><h2 id=2-4、消息的通信方式和流程><a class=headerlink href=#2-4、消息的通信方式和流程 title=2.4、消息的通信方式和流程></a>2.4、消息的通信方式和流程</h2><p><strong>RocketMQ通信方式主要有 同步(sync)、异步(async)、单向(oneway) 三种。</strong>其中“单向”通信模式相对简单，一般用在 发送心跳包 场景下，无需关注其Response。这里，主要介绍异步通信流程。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-RocketMQ%E8%AE%BE%E8%AE%A1-%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6-%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E5%92%8C%E6%B5%81%E7%A8%8B.png><h2 id=2-5、Reactor多线程设计><a class=headerlink href=#2-5、Reactor多线程设计 title=2.5、Reactor多线程设计></a>2.5、Reactor多线程设计</h2><p><strong>RocketMQ 基于Netty实现 RPC通信，遵循 Reactor多线程模型 同时又做了 扩展和优化。</strong><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-RocketMQ%E8%AE%BE%E8%AE%A1-%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6-Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png><p>根据上图所示，整个执行流程可描述如下：<ol><li>eventLoopGroupBoss负责监听 TCP网络连接请求，建立好连接，创建SocketChannel，并注册到selector上。<li>RocketMQ会根据OS类型自动选择NIO和Epoll。<li>监听真正的网络数据，拿到网络数据后丢给Worker线程池。<li>在执行业务逻辑前需要通过defaultEventExecutorGroup进行SSL验证、编解码、空闲检查、网络连接管理等操作。<li>根据 RomotingCommand 的业务请求码code 从 processorTable本地缓存变量中找到对应 processor，将其封装成task任务后提交给对应的业务processor处理线程池来执行。</ol><p>从入口到业务逻辑的几个步骤中线程池一直再增加，这跟每一步逻辑复杂性相关，越复杂，需要的并发通道越宽。<table><thead><tr><th align=center>线程数<th align=center>线程名<th align=center>线程具体说明<tbody><tr><td align=center>1<td align=center>NettyBoss_%d<td align=center>Reactor 主线程<tr><td align=center>N<td align=center>NettyServerEPOLLSelector_%d_%d<td align=center>Reactor 线程池<tr><td align=center>M1<td align=center>NettyServerCodecThread_%d<td align=center>Worker线程池<tr><td align=center>M2<td align=center>RemotingExecutorThread_%d<td align=center>业务processor处理线程池</table><h1 id=3、消息过滤><a class=headerlink href=#3、消息过滤 title=3、消息过滤></a>3、消息过滤</h1><p><strong>RocketMQ消息过滤方式是在Consumer端订阅消息时再做消息过滤，原因是 Producer端写入消息和Consumer端订阅消息采用 分离存储机制 实现。</strong>Consumer端订阅消息需要通过ConsumeQueue拿到一个索引，然后再从CommitLog里面读取真正的消息实体内容。<p>ConsumeQueue存储结构如下：<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-RocketMQ%E8%AE%BE%E8%AE%A1-%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A401.png><p>RocketMQ主要支持如下2种消息过滤方式：<ul><li><p><font color=orange>Tag过滤</font></p> <p>Consumer端订阅消息时 既可指定Topic 也可指定TAG，如果一个消息有多个TAG，可以用 || 分隔。</p> <p>Consumer端会将订阅请求构建成一个 SubscriptionData，发送一个Pull消息请求给Broker端。Broker端从RocketMQ的文件存储层—Store读取数据之前，会用这些数据先构建一个MessageFilter，然后传给Store。Store从 ConsumeQueue读取到一条记录后，会用它记录的消息tag hash值去做过滤，由于在服务端只是根据hashcode进行判断，无法精确对tag原始字符串进行过滤，故在消息消费端拉取到消息后，还需要对消息的原始tag字符串进行比对，如果不同，则丢弃该消息，不进行消息消费。</p><li><p><font color=orange>SQL92过滤</font></p> <p>大致与 Tag过滤方式 一样，只是在Store层的具体过滤过程有区别。rocketmq-filter模块负责 SQL expression 构建和执行。每次过滤都执行SQL表达式会影响效率，所以RocketMQ使用了BloomFilter避免了每次都去执行。SQL92表达式上下文 为 消息属性。</p></ul><h1 id=4、负载均衡><a class=headerlink href=#4、负载均衡 title=4、负载均衡></a>4、负载均衡</h1><p><strong>RocketMQ中的负载均衡都在Client端完成，主要分为 Producer端发送消息负载均衡 和 Consumer端订阅消息负载均衡。</strong><h2 id=4-1、Producer负载均衡><a class=headerlink href=#4-1、Producer负载均衡 title=4.1、Producer负载均衡></a>4.1、Producer负载均衡</h2><p>Producer端 发送消息时 会根据Topic找到对应TopicPublishInfo，然后客户端selectOneMessageQueue()方法会从TopicPublishInfo中的messageQueueList中选择一个队列来发送消息。<p>容错策略在MQFaultStrategy类中定义。如果开启sendLatencyFaultEnable，那么在随机递增取模的基础上会再过滤掉not available的Broker代理。latencyFaultTolerance是指 对之前失败的会按一定时间做退避。<p>例如，如果上次请求的latency超过550Lms，就退避3000Lms；超过1000L，就退避60000L；如果关闭，采用随机递增取模的方式选择一个队列来发送消息，latencyFaultTolerance机制是实现 消息发送高可用 的核心。<h2 id=4-2、Consumer负载均衡><a class=headerlink href=#4-2、Consumer负载均衡 title=4.2、Consumer负载均衡></a>4.2、Consumer负载均衡</h2><p>Consumer两种消费模式（Push/Pull）全都基于【<font color=orange>拉</font>】来获取消息，Push模式是对pull模式的一种封装，其本质实现为消息拉取线程从服务器拉取到一批消息后会提交到消息消费线程池，然后会继续尝试再次从服务器拉取消息。如果未拉取到消息，则延迟一下又继续拉取。<p>Consumerl两种消费方式的实现的前提是：Consumer知道从Broker端的哪一个消息队列中获取消息。故需要在Consumer端做负载均衡。<h3 id=4-2-1、Consumer心跳包发送><a class=headerlink href=#4-2-1、Consumer心跳包发送 title=4.2.1、Consumer心跳包发送></a>4.2.1、Consumer心跳包发送</h3><p><strong>Consumer启动后会通过 定时任务 不断向RocketMQ集群中的所有Broker实例发送 心跳包（其中包含了，消息消费分组名称、订阅关系集合、消息通信模式和客户端id的值等信息）。</strong>Broker端收到Consumer心跳消息后会将它维护在ConsumerManager的本地缓存变量consumerTable中，同时并将封装后的客户端网络通道信息保存在本地缓存变量—channelInfoTable中，后期为做Consumer端负载均衡提供可以依据的元数据信息。<h3 id=4-2-2、Consumer实现负载均衡的核心类——RebalanceImpl><a class=headerlink href=#4-2-2、Consumer实现负载均衡的核心类——RebalanceImpl title=4.2.2、Consumer实现负载均衡的核心类——RebalanceImpl></a>4.2.2、Consumer实现负载均衡的核心类——RebalanceImpl</h3><p><strong>Consumer实例启动流程中的启动MQClientInstance实例部分，会完成负载均衡服务线程RebalanceService的启动（每隔20s执行一次）。</strong>RebalanceService的run()方法最终会调用RebalanceImpl类的rebalanceByTopic()方法，该方法是实现Consumer端负载均衡的核心。<strong>rebalanceByTopic()方法会根据 消费者通信类型 为“广播模式”还是“集群模式”做不同的逻辑处理。</strong>集群模式主要处理流程可描述如下：<ol><li><p>从rebalanceImpl实例的opicSubscribeInfoTable中，获取该Topic主题下的消息消费队列集合（mqSet）；</p><li><p>根据topic和consumerGroup为参数调用mQClientFactory.findConsumerIdList()方法向Broker端发送获取该消费组下消费者Id列表的RPC通信请求（Broker端基于前面Consumer端上报的心跳包数据而构建的consumerTable做出响应返回，业务请求码：GET_CONSUMER_LIST_BY_GROUP）；</p><li><p>先对Topic下的消息消费队列、消费者Id排序，然后用消息队列分配策略算法（默认为：消息队列的平均分配算法），计算出待拉取的消息队列。这里的平均分配算法，类似于分页的算法，将所有MessageQueue排好序类似于记录，将所有消费端Consumer排好序类似页数，并求出每一页需要包含的平均size和每个页面记录的范围range，最后遍历整个range而计算出当前Consumer端应该分配到的记录（这里即为：MessageQueue）。</p> <p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-image-20210819184511921.png></p><li><p>然后，调用updateProcessQueueTableInRebalance()方法，具体的做法是，先将分配到的消息队列集合（mqSet）与processQueueTable做一个过滤比对。</p> <p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-image-20210819184609602.png></p> <ul><li>上图中processQueueTable标注的红色部分，表示与分配到的消息队列集合mqSet互不包含。将这些队列设置Dropped属性为true，然后查看这些队列是否可以移除出processQueueTable缓存变量，这里具体执行removeUnnecessaryMessageQueue()方法，即每隔1s 查看是否可以获取当前消费处理队列的锁，拿到的话返回true。如果等待1s后，仍然拿不到当前消费处理队列的锁则返回false。如果返回true，则从processQueueTable缓存变量中移除对应的Entry；<li>上图中processQueueTable的绿色部分，表示与分配到的消息队列集合mqSet的交集。判断该ProcessQueue是否已经过期了，在Pull模式的不用管，如果是Push模式的，设置Dropped属性为true，并且调用removeUnnecessaryMessageQueue()方法，像上面一样尝试移除Entry；</ul> <p>最后，为过滤后的消息队列集合（mqSet）中的每个MessageQueue创建一个ProcessQueue对象并存入RebalanceImpl的processQueueTable队列中（其中调用RebalanceImpl实例的computePullFromWhere(MessageQueue mq)方法获取该MessageQueue对象的下一个进度消费值offset，随后填充至接下来要创建的pullRequest对象属性中），并创建拉取请求对象—pullRequest添加到拉取列表—pullRequestList中，最后执行dispatchPullRequest()方法，将Pull消息的请求对象PullRequest依次放入PullMessageService服务线程的阻塞队列pullRequestQueue中，待该服务线程取出后向Broker端发起Pull消息的请求。其中，可以重点对比下，RebalancePushImpl和RebalancePullImpl两个实现类的dispatchPullRequest()方法不同，RebalancePullImpl类里面的该方法为空，这样子也就回答了上一篇中最后的那道思考题了。</p> <p>消息消费队列在同一消费组不同消费者之间的负载均衡，其核心设计理念是在一个消息消费队列在同一时间只允许被同一消费组内的一个消费者消费，一个消息消费者能同时消费多个消息队列。</p></ol><h1 id=5、事务消息><a class=headerlink href=#5、事务消息 title=5、事务消息></a>5、事务消息</h1><p>Apache RocketMQ在4.3.0版中已经支持分布式事务消息，RocketMQ采用了【2PC思想】实现了提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息，如下图所示。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-RocketMQ%E8%AE%BE%E8%AE%A1-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF.png><h2 id=5-1、事务消息流程><a class=headerlink href=#5-1、事务消息流程 title=5.1、事务消息流程></a>5.1、事务消息流程</h2><p>事务消息主要分两个流程：正常事务消息的发送及提交、事务消息的补偿流程。<ol><li><p>事务消息发送及提交</p> <ol><li>发送消息（half消息）；<li>服务端响应消息写入结果；<li>根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）；<li>根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）；</ol><li><p>补偿流程</p> <ol><li>对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”；<li>Producer收到回查消息，检查回查消息对应的本地事务的状态；<li>根据本地事务状态，重新Commit或者Rollback；</ol> <p>补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p></ol><h2 id=5-2、RocketMQ事务消息设计><a class=headerlink href=#5-2、RocketMQ事务消息设计 title=5.2、RocketMQ事务消息设计></a>5.2、RocketMQ事务消息设计</h2><h3 id=5-2-1、事务消息在一阶段对用户不可见><a class=headerlink href=#5-2-1、事务消息在一阶段对用户不可见 title=5.2.1、事务消息在一阶段对用户不可见></a>5.2.1、事务消息在一阶段对用户不可见</h3><p><strong>在RocketMQ事务消息的主要流程中，事务消息在一阶段对用户不可见。</strong>如何做到不可见呢？RocketMQ事务消息的做法是：<strong>如果消息是half消息，将备份原消息的主题与消息消费队列，然后改变主题为RMQ_SYS_TRANS_HALF_TOPIC。</strong>由于消费组未订阅该主题，故消费端无法消费half类型的消息，然后RocketMQ会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费，生产者组发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。<p>消息在服务端的存储结构如下，每条消息都会有对应的索引信息，Consumer通过ConsumeQueue这个二级索引来读取消息实体内容，其流程如下：<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-image-20210819185955464.png><p>RocketMQ具体实现策略：如果写入的是事务消息，则对该消息的Topic和Queue等属性进行替换，同时将原来的Topic和Queue信息存储到消息属性中，正因为消息主题被替换，故消息并不会转发到该原主题的消息消费队列，消费者无法感知消息的存在，不会消费。其实改变消息主题是RocketMQ的常用“套路”，回想一下延时消息的实现机制。<h3 id=5-2-2、Commit和Rollback操作以及Op消息引入><a class=headerlink href=#5-2-2、Commit和Rollback操作以及Op消息引入 title=5.2.2、Commit和Rollback操作以及Op消息引入></a>5.2.2、Commit和Rollback操作以及Op消息引入</h3><p><strong>在完成一阶段（写入一条对用户不可见的消息）后，二阶段如果是Commit操作，则需要使得消息对用户可见；如果是Rollback则需要撤销一阶段的消息。</strong><p>对于Rollback，本身一阶段的消息对用户是不可见的，其实不需要真正撤销消息（实际上RocketMQ也无法去真正的删除一条消息，因为是顺序写文件的）。但为了标记这条消息没有确定状态（Pending状态，事务悬而未决），则需要一个操作来标识这条消息的最终状态。<p><strong>RocketMQ事务消息方案中引入了Op消息概念，用Op消息标识事务消息已经确定的状态（Commit或者Rollback）。</strong>如果一条事务消息没有对应的Op消息，说明这个事务的状态还无法确定（可能是二阶段失败了）。引入Op消息后，事务消息无论是Commit或者Rollback都会记录一个Op操作。Commit相对于Rollback只是在写入Op消息前创建Half消息的索引。<h3 id=5-2-3、Op消息的存储和对应关系><a class=headerlink href=#5-2-3、Op消息的存储和对应关系 title=5.2.3、Op消息的存储和对应关系></a>5.2.3、Op消息的存储和对应关系</h3><p>通过TransactionalMessageUtil.buildOpTopic()方法可将Op消息写入到一个特定Topic中，这个Topic是一个内部Topic（像Half消息的Topic一样），故不会被用户消费。Op消息的内容为对应的Half消息的存储的Offset，这样通过Op消息能索引到Half消息进行后续的回查操作。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-image-20210819190132751.png><h3 id=5-2-4、Half消息的索引构建><a class=headerlink href=#5-2-4、Half消息的索引构建 title=5.2.4、Half消息的索引构建></a>5.2.4、Half消息的索引构建</h3><p><strong>在执行二阶段Commit操作时需要构建出Half消息的索引。</strong>一阶段的Half消息由于是写到一个特殊的Topic，所以二阶段构建索引时需要读取Half消息，并将Topic和Queue替换成真正的Topic和Queue，之后通过一次普通消息的写入操作来生成一条对用户可见的消息。所以RocketMQ事务消息二阶段其实是利用了一阶段存储的消息内容，在二阶段时恢复出一条完整的普通消息，然后走一遍消息写入流程。<h3 id=5-2-5、如何处理二阶段失败的消息><a class=headerlink href=#5-2-5、如何处理二阶段失败的消息 title=5.2.5、如何处理二阶段失败的消息></a>5.2.5、如何处理二阶段失败的消息</h3><p><strong>如果事务消息的二阶段失败了，那么RocketMQ提出了一种补偿机制，称为回查。</strong>Broker端对未确定状态的消息发起回查，将消息发送到对应的Producer端（同一个Group的Producer），由Producer根据消息来检查本地事务的状态，进而执行Commit或者Rollback。Broker端通过对比Half消息和Op消息进行事务消息的回查并且推进CheckPoint（记录那些事务消息的状态是确定的）。<p><font color=red>注意：rocketmq并不会无休止执行信息事务状态回查，默认回查15次，如果15次回查还是无法得知事务状态，rocketmq默认回滚该消息。</font><h2 id=5-3、使用限制><a class=headerlink href=#5-3、使用限制 title=5.3、使用限制></a>5.3、使用限制</h2><ol><li>事务消息 不支持 延时消息 和 批量消息。<li>为避免 单个消息被检查太多次而导致半队列消息累积，默认将检查次数限制为 15 次，但是用户可以通过 Broker配置文件的 <code>transactionCheckMax</code>参数来修改此限制。如果检查某条消息的次数超过 N 次的话（ N = <code>transactionCheckMax</code> ） 则 Broker 将丢弃此消息，并默认同时打印错误日志。用户可以通过重写 <code>AbstractTransactionCheckListener</code> 类来修改这个行为。<li>事务消息 将在特定时间后被检查，该时间由Broker配置文件中的参数transactionMsgTimeout决定 。当发送事务消息时，用户还可以通过设置用户属性 CHECK_IMMUNITY_TIME_IN_SECONDS 来改变这个限制，该参数优先于 <code>transactionMsgTimeout</code> 参数。<li>事务性消息可能不止一次被检查或消费。<li>提交给用户的目标主题消息可能会失败，目前 依据 日志的记录 而定。它的高可用性通过 RocketMQ 本身的高可用性机制来保证，如果希望确保事务消息不丢失、且保证事务的完整性，那么建议使用同步的双重写入机制。<li>事务消息的生产者ID 不能 与其他类型消息的生产者ID 共享。与其他类型的消息不同，事务消息允许反向查询、MQ服务器能通过它们的生产者ID 查询到 消费者。</ol><h1 id=6、消息查询><a class=headerlink href=#6、消息查询 title=6、消息查询></a>6、消息查询</h1><p><strong>RocketMQ支持 按照Message Id查询消息、按照Message Key查询消息 两种方式。</strong><h2 id=6-1、按照MessageId查询消息><a class=headerlink href=#6-1、按照MessageId查询消息 title=6.1、按照MessageId查询消息></a>6.1、按照MessageId查询消息</h2><p><strong>MessageId长度共16字节，包含了消息存储主机地址（IP地址和端口），消息Commit Log offset。</strong><p>按照MessageId查询消息具体做法：Client端从MessageId中解析出 Broker地址（IP地址和端口）和 Commit Log偏移地址后 封装成一个RPC请求后通过Remoting通信层发送（业务请求码：VIEW_MESSAGE_BY_ID）。Broker端走的是QueryMessageProcessor，读取消息的过程使用 commitLog offset 和 size 去 commitLog 中找到记录并解析成一个完整的消息并返回。<h2 id=6-2、按照Message-Key查询消息><a title="6.2、按照Message Key查询消息" class=headerlink href=#6-2、按照Message-Key查询消息></a>6.2、按照Message Key查询消息</h2><p>“按照Message Key查询消息” 是基于RocketMQ的IndexFile索引文件来实现。RocketMQ索引文件逻辑结构，类似JDK中HashMap。索引文件结构如下：<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-image-20210819190354734.png><p>IndexFile索引文件 为用户提供 消息索引查询服务，IndexFile文件存储位置是：$HOME\store\index${fileName}，文件名fileName是以创建时的时间戳命名，文件大小是固定的，等于40+500W * 4+2000W * 20= 420000040个字节大小。如果消息的properties中设置了UNIQ_KEY属性，就用 topic + “#” + UNIQ_KEY的value 作为 key 来做写入操作。如果消息设置了KEYS属性（多个KEY以空格分隔），也会用 topic + “#” + KEY 来做索引。<p><strong>索引数据包含了Key Hash / CommitLog Offset / Timestamp / NextIndex offset 四个字段，一共20 Byte。</strong>NextIndex offset 即前面读出来的 slotValue，如果有 hash冲突，就可以用这个字段将所有冲突的索引用链表的方式串起来了。Timestamp记录的是消息storeTimestamp之间的差，并不是一个绝对的时间。整个Index File的结构如图，40 Byte 的Header用于保存一些总的统计信息，4<em>500W的 Slot Table并不保存真正的索引数据，而是保存每个槽位对应的单向链表头。20</em>2000W 是真正的索引数据，即一个 Index File 可以保存 2000W个索引。<p>按照Message Key查询消息 具体做法：主要通过Broker端的QueryMessageProcessor业务处理器来查询，读取消息的过程就是用topic和key找到IndexFile索引文件中的一条记录，根据commitLog offset从CommitLog文件中读取消息的实体内容。</div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Redis%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Redis%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD/ itemprop=url>Redis系列-Redis业务场景落地</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-07 09:33:35" datetime=2023-08-07T09:33:35+08:00 itemprop=dateModified>2023-08-07</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Redis/ itemprop=url rel=index><span itemprop=name>Redis</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、点赞><a class=headerlink href=#1、点赞 title=1、点赞></a>1、点赞</h1><h2 id=1-1、需求><a class=headerlink href=#1-1、需求 title=1.1、需求></a>1.1、需求</h2><ul><li>一个用户只能点赞一次<li>已点赞就高亮显式</ul><h2 id=1-2、解决方法><a class=headerlink href=#1-2、解决方法 title=1.2、解决方法></a>1.2、解决方法</h2><p>SortedSet结构存储（后期做点赞排行功能），可去重，可判断是否存在。<h2 id=1-3、代码实现><a class=headerlink href=#1-3、代码实现 title=1.3、代码实现></a>1.3、代码实现</h2><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> Result <span class="title function_">likeBlog</span><span class=params>(Long id)</span> {</span><br><span class=line>    <span class=comment>// 1.获取登录用户</span></span><br><span class=line>    <span class=type>Long</span> <span class=variable>userId</span> <span class=operator>=</span> UserHolder.getUser().getId();</span><br><span class=line>    <span class=comment>// 2.判断当前登录用户是否已经点赞</span></span><br><span class=line>    <span class=type>String</span> <span class=variable>key</span> <span class=operator>=</span> BLOG_LIKED_KEY + id;</span><br><span class=line>    <span class=type>Double</span> <span class=variable>score</span> <span class=operator>=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class=line>    <span class=keyword>if</span> (score == <span class=literal>null</span>) {</span><br><span class=line>        <span class=comment>// 3.如果未点赞，可以点赞</span></span><br><span class=line>        <span class=comment>// 3.1.数据库点赞数 + 1</span></span><br><span class=line>        <span class=type>boolean</span> <span class=variable>isSuccess</span> <span class=operator>=</span> update().setSql(<span class=string>"liked = liked + 1"</span>).eq(<span class=string>"id"</span>, id).update();</span><br><span class=line>        <span class=comment>// 3.2.保存用户到Redis的set集合  zadd key value score</span></span><br><span class=line>        <span class=keyword>if</span> (isSuccess) {</span><br><span class=line>            stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span><br><span class=line>        }</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>        <span class=comment>// 4.如果已点赞，取消点赞</span></span><br><span class=line>        <span class=comment>// 4.1.数据库点赞数 -1</span></span><br><span class=line>        <span class=type>boolean</span> <span class=variable>isSuccess</span> <span class=operator>=</span> update().setSql(<span class=string>"liked = liked - 1"</span>).eq(<span class=string>"id"</span>, id).update();</span><br><span class=line>        <span class=comment>// 4.2.把用户从Redis的set集合移除</span></span><br><span class=line>        <span class=keyword>if</span> (isSuccess) {</span><br><span class=line>            stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> Result.ok();</span><br><span class=line>}</span><br></pre></table></figure><h1 id=2、点赞排行><a class=headerlink href=#2、点赞排行 title=2、点赞排行></a>2、点赞排行</h1><h2 id=2-1、需求分析><a class=headerlink href=#2-1、需求分析 title=2.1、需求分析></a>2.1、需求分析</h2><ul><li>使用SortedSet数据结构存储。<li>MySQL数据库强制查询结果按自定义顺序排列：order by field(ids, 自定义顺序)</ul><h2 id=2-2、代码实现><a class=headerlink href=#2-2、代码实现 title=2.2、代码实现></a>2.2、代码实现</h2><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> Result <span class="title function_">queryBlogLikes</span><span class=params>(Long id)</span> {</span><br><span class=line>    <span class=type>String</span> <span class=variable>key</span> <span class=operator>=</span> BLOG_LIKED_KEY + id;</span><br><span class=line>    <span class=comment>// 1.查询top5的点赞用户 zrange key 0 4</span></span><br><span class=line>    Set&LTString> top5 = stringRedisTemplate.opsForZSet().range(key, <span class=number>0</span>, <span class=number>4</span>);</span><br><span class=line>    <span class=keyword>if</span> (top5 == <span class=literal>null</span> || top5.isEmpty()) {</span><br><span class=line>        <span class=keyword>return</span> Result.ok(Collections.emptyList());</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 2.解析出其中的用户id</span></span><br><span class=line>    List&LTLong> ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class=line>    <span class=type>String</span> <span class=variable>idStr</span> <span class=operator>=</span> StrUtil.join(<span class=string>","</span>, ids);</span><br><span class=line>    <span class=comment>// 3.根据用户id查询用户 WHERE id IN ( 5 , 1 ) ORDER BY FIELD(id, 5, 1)</span></span><br><span class=line>    List&LTUserDTO> userDTOS = userService.query()</span><br><span class=line>        .in(<span class=string>"id"</span>, ids).last(<span class=string>"ORDER BY FIELD(id,"</span> + idStr + <span class=string>")"</span>).list()</span><br><span class=line>        .stream()</span><br><span class=line>        .map(user -> BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class=line>        .collect(Collectors.toList());</span><br><span class=line>    <span class=comment>// 4.返回</span></span><br><span class=line>    <span class=keyword>return</span> Result.ok(userDTOS);</span><br><span class=line>}</span><br></pre></table></figure><h1 id=3、用户关注><a class=headerlink href=#3、用户关注 title=3、用户关注></a>3、用户关注</h1><h2 id=3-1、需求分析><a class=headerlink href=#3-1、需求分析 title=3.1、需求分析></a>3.1、需求分析</h2><ul><li>关注/取关：数据库直接通过一张表实现，若用户量较大可选择SET。<li>共同关注：使用set数据结构来存储，求交集。</ul><h2 id=3-2、代码实现><a class=headerlink href=#3-2、代码实现 title=3.2、代码实现></a>3.2、代码实现</h2><h3 id=3-2-1、关注用户><a class=headerlink href=#3-2-1、关注用户 title=3.2.1、关注用户></a>3.2.1、关注用户</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> Result <span class="title function_">follow</span><span class=params>(Long followUserId, Boolean isFollow)</span> {</span><br><span class=line>    <span class=comment>// 1.获取登录用户</span></span><br><span class=line>    <span class=type>Long</span> <span class=variable>userId</span> <span class=operator>=</span> UserHolder.getUser().getId();</span><br><span class=line>    <span class=type>String</span> <span class=variable>key</span> <span class=operator>=</span> <span class=string>"follows:"</span> + userId;</span><br><span class=line>    <span class=comment>// 1.判断到底是关注还是取关</span></span><br><span class=line>    <span class=keyword>if</span> (isFollow) {</span><br><span class=line>        <span class=comment>// 2.关注，新增数据</span></span><br><span class=line>        <span class=type>Follow</span> <span class=variable>follow</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Follow</span>();</span><br><span class=line>        follow.setUserId(userId);</span><br><span class=line>        follow.setFollowUserId(followUserId);</span><br><span class=line>        <span class=type>boolean</span> <span class=variable>isSuccess</span> <span class=operator>=</span> save(follow);</span><br><span class=line>        <span class=keyword>if</span> (isSuccess) {</span><br><span class=line>            <span class=comment>// 把关注用户的id，放入redis的set集合 sadd userId followerUserId</span></span><br><span class=line>            stringRedisTemplate.opsForSet().add(key, followUserId.toString());</span><br><span class=line>        }</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>        <span class=comment>// 3.取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?</span></span><br><span class=line>        <span class=type>boolean</span> <span class=variable>isSuccess</span> <span class=operator>=</span> remove(<span class=keyword>new</span> <span class="title class_">QueryWrapper</span>&LTFollow>()</span><br><span class=line>                                   .eq(<span class=string>"user_id"</span>, userId).eq(<span class=string>"follow_user_id"</span>, followUserId));</span><br><span class=line>        <span class=keyword>if</span> (isSuccess) {</span><br><span class=line>            <span class=comment>// 把关注用户的id从Redis集合中移除</span></span><br><span class=line>            stringRedisTemplate.opsForSet().remove(key, followUserId.toString());</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> Result.ok();</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-2-2、共同关注><a class=headerlink href=#3-2-2、共同关注 title=3.2.2、共同关注></a>3.2.2、共同关注</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> Result <span class="title function_">followCommons</span><span class=params>(Long id)</span> {</span><br><span class=line>    <span class=comment>// 1.获取当前用户</span></span><br><span class=line>    <span class=type>Long</span> <span class=variable>userId</span> <span class=operator>=</span> UserHolder.getUser().getId();</span><br><span class=line>    <span class=type>String</span> <span class=variable>key</span> <span class=operator>=</span> <span class=string>"follows:"</span> + userId;</span><br><span class=line>    <span class=comment>// 2.求交集</span></span><br><span class=line>    <span class=type>String</span> <span class=variable>key2</span> <span class=operator>=</span> <span class=string>"follows:"</span> + id;</span><br><span class=line>    Set&LTString> intersect = stringRedisTemplate.opsForSet().intersect(key, key2);</span><br><span class=line>    <span class=keyword>if</span> (intersect == <span class=literal>null</span> || intersect.isEmpty()) {</span><br><span class=line>        <span class=comment>// 无交集</span></span><br><span class=line>        <span class=keyword>return</span> Result.ok(Collections.emptyList());</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 3.解析id集合</span></span><br><span class=line>    List&LTLong> ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class=line>    <span class=comment>// 4.查询用户</span></span><br><span class=line>    List&LTUserDTO> users = userService.listByIds(ids)</span><br><span class=line>        .stream()</span><br><span class=line>        .map(user -> BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class=line>        .collect(Collectors.toList());</span><br><span class=line>    <span class=keyword>return</span> Result.ok(users);</span><br><span class=line>}</span><br></pre></table></figure><h1 id=4、推送><a class=headerlink href=#4、推送 title=4、推送></a>4、推送</h1><h2 id=4-1、Feed流常见模式><a class=headerlink href=#4-1、Feed流常见模式 title=4.1、Feed流常见模式></a>4.1、Feed流常见模式</h2><p>（1）TimeLine<ul><li>优点：信息全面，不会有缺失，且实现简单。<li>缺点：噪音多，用户不一定感兴趣，内容获取率低。<li>实现方案：<ul><li>拉模式（读扩散）：不推荐<li>推模式（写扩散）：不推荐<li>推拉结合：推荐</ul></ul><p>（2）智能排序<ul><li>优点：投喂用户感兴趣的信息，用户黏度高，易沉迷。<li>缺点：若 算法不精准，可能起到相反作用。</ul><h2 id=4-2、收件箱><a class=headerlink href=#4-2、收件箱 title=4.2、收件箱></a>4.2、收件箱</h2><ul><li>使用SortedSet结构来存储。<li>Feed流滚动分页：ZSet：zrevrangebyscore … withscores limit …<ul><li>max / min / offset / count<ul><li>max：当前时间戳 | 上一次查询的最小时间戳<li>min：0<li>offset：0 | 上次结果中最小值相同的个数<li>count：3</ul></ul></ul><h1 id=5、签到><a class=headerlink href=#5、签到 title=5、签到></a>5、签到</h1><h2 id=5-1、需求分析><a class=headerlink href=#5-1、需求分析 title=5.1、需求分析></a>5.1、需求分析</h2><ul><li>bitmap<li>签到：通过redis的bitmap实现。<li>统计连续签到：统计bitmap中1的个数。</ul><h2 id=5-2、代码实现><a class=headerlink href=#5-2、代码实现 title=5.2、代码实现></a>5.2、代码实现</h2><h3 id=5-2-1、签到><a class=headerlink href=#5-2-1、签到 title=5.2.1、签到></a>5.2.1、签到</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> Result <span class="title function_">sign</span><span class=params>()</span> {</span><br><span class=line>    <span class=comment>// 1.获取当前登录用户</span></span><br><span class=line>    <span class=type>Long</span> <span class=variable>userId</span> <span class=operator>=</span> UserHolder.getUser().getId();</span><br><span class=line>    <span class=comment>// 2.获取日期</span></span><br><span class=line>    <span class=type>LocalDateTime</span> <span class=variable>now</span> <span class=operator>=</span> LocalDateTime.now();</span><br><span class=line>    <span class=comment>// 3.拼接key</span></span><br><span class=line>    <span class=type>String</span> <span class=variable>keySuffix</span> <span class=operator>=</span> now.format(DateTimeFormatter.ofPattern(<span class=string>":yyyyMM"</span>));</span><br><span class=line>    <span class=type>String</span> <span class=variable>key</span> <span class=operator>=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class=line>    <span class=comment>// 4.获取今天是本月的第几天</span></span><br><span class=line>    <span class=type>int</span> <span class=variable>dayOfMonth</span> <span class=operator>=</span> now.getDayOfMonth();</span><br><span class=line>    <span class=comment>// 5.写入Redis SETBIT key offset 1</span></span><br><span class=line>    stringRedisTemplate.opsForValue().setBit(key, dayOfMonth - <span class=number>1</span>, <span class=literal>true</span>);</span><br><span class=line>    <span class=keyword>return</span> Result.ok();</span><br><span class=line>}</span><br></pre></table></figure><h3 id=5-2-2、签到统计><a class=headerlink href=#5-2-2、签到统计 title=5.2.2、签到统计></a>5.2.2、签到统计</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> Result <span class="title function_">signCount</span><span class=params>()</span> {</span><br><span class=line>    <span class=comment>// 1.获取当前登录用户</span></span><br><span class=line>    <span class=type>Long</span> <span class=variable>userId</span> <span class=operator>=</span> UserHolder.getUser().getId();</span><br><span class=line>    <span class=comment>// 2.获取日期</span></span><br><span class=line>    <span class=type>LocalDateTime</span> <span class=variable>now</span> <span class=operator>=</span> LocalDateTime.now();</span><br><span class=line>    <span class=comment>// 3.拼接key</span></span><br><span class=line>    <span class=type>String</span> <span class=variable>keySuffix</span> <span class=operator>=</span> now.format(DateTimeFormatter.ofPattern(<span class=string>":yyyyMM"</span>));</span><br><span class=line>    <span class=type>String</span> <span class=variable>key</span> <span class=operator>=</span> USER_SIGN_KEY + userId + keySuffix;</span><br><span class=line>    <span class=comment>// 4.获取今天是本月的第几天</span></span><br><span class=line>    <span class=type>int</span> <span class=variable>dayOfMonth</span> <span class=operator>=</span> now.getDayOfMonth();</span><br><span class=line>    <span class=comment>// 5.获取本月截止今天为止的所有的签到记录，返回的是一个十进制的数字 BITFIELD sign:5:202203 GET u14 0</span></span><br><span class=line>    List&LTLong> result = stringRedisTemplate.opsForValue().bitField(</span><br><span class=line>        key,</span><br><span class=line>        BitFieldSubCommands.create()</span><br><span class=line>        .get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(<span class=number>0</span>)</span><br><span class=line>    );</span><br><span class=line>    <span class=keyword>if</span> (result == <span class=literal>null</span> || result.isEmpty()) {</span><br><span class=line>        <span class=comment>// 没有任何签到结果</span></span><br><span class=line>        <span class=keyword>return</span> Result.ok(<span class=number>0</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=type>Long</span> <span class=variable>num</span> <span class=operator>=</span> result.get(<span class=number>0</span>);</span><br><span class=line>    <span class=keyword>if</span> (num == <span class=literal>null</span> || num == <span class=number>0</span>) {</span><br><span class=line>        <span class=keyword>return</span> Result.ok(<span class=number>0</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 6.循环遍历</span></span><br><span class=line>    <span class=type>int</span> <span class=variable>count</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>while</span> (<span class=literal>true</span>) {</span><br><span class=line>        <span class=comment>// 6.1.让这个数字与1做与运算，得到数字的最后一个bit位  // 判断这个bit位是否为0</span></span><br><span class=line>        <span class=keyword>if</span> ((num & <span class=number>1</span>) == <span class=number>0</span>) {</span><br><span class=line>            <span class=comment>// 如果为0，说明未签到，结束</span></span><br><span class=line>            <span class=keyword>break</span>;</span><br><span class=line>        }<span class=keyword>else</span> {</span><br><span class=line>            <span class=comment>// 如果不为0，说明已签到，计数器+1</span></span><br><span class=line>            count++;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 把数字右移一位，抛弃最后一个bit位，继续下一个bit位</span></span><br><span class=line>        num >>>= <span class=number>1</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> Result.ok(count);</span><br><span class=line>}</span><br></pre></table></figure><h1 id=6、HyperLogLog><a class=headerlink href=#6、HyperLogLog title=6、HyperLogLog></a>6、HyperLogLog</h1><h2 id=6-1、简介><a class=headerlink href=#6-1、简介 title=6.1、简介></a>6.1、简介</h2><ul><li>UV：独立访问量，不管点击多少次，最终按1次计算。<li>PV：页面访问量/点击量，点击多少次 就算多少次。<li>命令：<ul><li>PFADD<li>PFCOUNT<li>PFMERGE</ul></ul><h2 id=6-2、代码测试><a class=headerlink href=#6-2、代码测试 title=6.2、代码测试></a>6.2、代码测试</h2><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testHyperLogLog</span><span class=params>()</span>{</span><br><span class=line>    String[] vals = <span class=keyword>new</span> <span class="title class_">String</span>[<span class=number>1000</span>];</span><br><span class=line>    <span class=type>int</span> <span class=variable>j</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < <span class=number>100_0000</span>; i++) {</span><br><span class=line>        j = j % <span class=number>1000</span>;</span><br><span class=line>        vals[j] = <span class=string>"user_"</span> + i;</span><br><span class=line>        <span class=keyword>if</span> (j == <span class=number>999</span>){</span><br><span class=line>            stringRedisTemplate.opsForHyperLogLog().add(<span class=string>"hl2"</span>, vals);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=type>Long</span> <span class=variable>count</span> <span class=operator>=</span> stringRedisTemplate.opsForHyperLogLog().size(<span class=string>"hl2"</span>);</span><br><span class=line>    System.out.println(<span class=string>"count: "</span> + count);</span><br><span class=line>}</span><br></pre></table></figure><h1 id=7、使用哨兵集群><a class=headerlink href=#7、使用哨兵集群 title=7、使用哨兵集群></a>7、使用哨兵集群</h1><h2 id=7-1、配置><a class=headerlink href=#7-1、配置 title=7.1、配置></a>7.1、配置</h2><figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=comment># Spring</span></span><br><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>redis:</span></span><br><span class=line>    <span class=comment># 哨兵集群</span></span><br><span class=line>    <span class=attr>sentinel:</span></span><br><span class=line>      <span class=attr>master:</span> <span class=string>mymaster</span></span><br><span class=line>      <span class=attr>nodes:</span></span><br><span class=line>        <span class=bullet>-</span> <span class=number>192.168</span><span class=number>.2</span><span class=number>.4</span><span class=string>:27001</span></span><br><span class=line>        <span class=bullet>-</span> <span class=number>192.168</span><span class=number>.2</span><span class=number>.4</span><span class=string>:27002</span></span><br><span class=line>        <span class=bullet>-</span> <span class=number>192.168</span><span class=number>.2</span><span class=number>.4</span><span class=string>:27003</span></span><br></pre></table></figure><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> LettuceClientConfigurationBuilderCustomizer <span class="title function_">configurationBuilderCustomizer</span><span class=params>()</span>{</span><br><span class=line>    <span class=keyword>return</span> config -> config.readFrom(ReadFrom.REPLICA_PREFERRED);</span><br><span class=line>}</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Redis%E5%94%AF%E5%BF%AB%E4%B8%8D%E7%A0%B4%E7%9A%84%E7%A7%98%E5%AF%86/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Redis%E5%94%AF%E5%BF%AB%E4%B8%8D%E7%A0%B4%E7%9A%84%E7%A7%98%E5%AF%86/ itemprop=url>Redis系列-Redis唯快不破</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 21:46:35" datetime=2023-10-02T21:46:35+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Redis/ itemprop=url rel=index><span itemprop=name>Redis</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、Redis唯快不破的秘密><a class=headerlink href=#1、Redis唯快不破的秘密 title=1、Redis唯快不破的秘密></a>1、Redis唯快不破的秘密</h1><h2 id=1-1、前言><a class=headerlink href=#1-1、前言 title=1.1、前言></a>1.1、前言</h2><h3 id=1-1-1、全景图><a class=headerlink href=#1-1-1、全景图 title=1.1.1、全景图></a>1.1.1、全景图</h3><p>全景图可以围绕两个维度展开，分别是：<ul><li>应用维度：缓存使用、集群运用、数据结构的巧妙使用；<li>系统维度：可以归类为三高：<ol><li><strong>高性能</strong>：线程模型、网络 IO 模型、数据结构、持久化机制；<li><strong>高可用</strong>：主从复制、哨兵集群、Cluster 分片集群；<li><strong>高拓展</strong>：负载均衡；</ol></ul><h3 id=1-1-2、官方介绍><a class=headerlink href=#1-1-2、官方介绍 title=1.1.2、官方介绍></a>1.1.2、官方介绍</h3><p><strong>根据官方数据，Redis 的 QPS 可达到约 10万（每秒请求数）</strong>，有兴趣的可以参考官方基准程序测试《How fast is Redis？》，地址：<a href=https://redis.io/topics/benchmarks%E3%80%82 rel=noopener target=_blank>https://redis.io/topics/benchmarks。</a><p><img alt=image-20210426102755528 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%94%AF%E5%BF%AB%E4%B8%8D%E7%A0%B4-image-20210426102755528.png><h2 id=1-2、底层实现><a class=headerlink href=#1-2、底层实现 title=1.2、底层实现></a>1.2、底层实现</h2><p>Redis之所以快，原因如下：<ol><li><strong>基于内存</strong><li><strong>使用IO多路复用模型，非阻塞IO</strong><li><strong>单线程模型</strong><li><strong>高效的数据结构</strong><ol><li>动态字符串<li>整数数组<li>双向链表<li>hash表<li>压缩列表<li>跳跃表</ol><li><strong>动态编码</strong></ol><h3 id=1-2-1、基于内存><a class=headerlink href=#1-2-1、基于内存 title=1.2.1、基于内存></a>1.2.1、基于内存</h3><p>内存直接由 CPU 控制，也就是 CPU 内部集成的内存控制器，所以说内存是直接与 CPU 对接，享受与 CPU 通信的最优带宽。<p><strong>Redis 将数据存储在内存中，读写操作不会受磁盘 IO 速度限制，所以速度很快！</strong><h3 id=1-2-2、IO多路复用-非阻塞IO><a title="1.2.2、IO多路复用 / 非阻塞IO" class=headerlink href=#1-2-2、IO多路复用-非阻塞IO></a>1.2.2、IO多路复用 / 非阻塞IO</h3><h4 id=1-2-2-1、多路复用定义><a class=headerlink href=#1-2-2-1、多路复用定义 title=1.2.2.1、多路复用定义></a>1.2.2.1、多路复用定义</h4><p><strong>多路指多个 socket 连接，复用指复用一个线程</strong>。<p>多路复用具体实现主要有三种select，poll，epoll。一般情况下 epoll 是最新最好的多路复用实现。<p><img alt=image-20210426105838269 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%94%AF%E5%BF%AB%E4%B8%8D%E7%A0%B4-image-20210426105838269.png><p>基本原理就是：<strong>内核并非是监视应用程序的连接，而是监视应用程序的文件描述符</strong>。<h4 id=1-2-2-2、为何采用><a class=headerlink href=#1-2-2-2、为何采用 title=1.2.2.2、为何采用></a>1.2.2.2、为何采用</h4><p><strong>Redis 采用 I/O 多路复用技术实现 并发处理连接 的效果。</strong>采用了 epoll + 自身实现的事件框架。epoll 中的读、写、关闭、连接都转化成了事件，然后利用 epoll 的多路复用特性提升IO效率。<p>Redis 线程不会阻塞在某一个特定的监听或已连接套接字上。<strong>Redis 可同时连接多个客户端处理请求，来提升并发性。</strong><h3 id=1-2-3、单线程模型><a class=headerlink href=#1-2-3、单线程模型 title=1.2.3、单线程模型></a>1.2.3、单线程模型</h3><p><strong>Redis 单线程说的是 Redis 网络 IO 以及键值对指令读写是一个线程来完成。 对于 Redis 持久化、集群数据同步、异步删除等操作由其它线程完成</strong>。<p>多线程缺点：<ol><li>通常可以 增加系统吞吐量，充分利用CPU资源。<li>导致上下文切换，消耗资源、降低性能。</ol><p>单线程好处：<ol><li>避免了 频繁创建线程 导致的性能消耗。<li>避免了 上下文切换引起的 CPU 消耗，无线程切换开销。<li>避免了 线程间竞争，比如添加锁、释放锁、死锁等，不需要考虑各种锁问题。<li>代码更清晰，逻辑更简单。</ol><blockquote><p>官方对此也做了解释：<p>Redis 通过内存来执行指令，故CPU不是瓶颈，Redis瓶颈最有可能是内存大小或网络带宽。既然单线程容易实现，且CPU不会成为瓶颈，所以采用单线程。</blockquote><h3 id=1-2-4、高效数据结构><a class=headerlink href=#1-2-4、高效数据结构 title=1.2.4、高效数据结构></a>1.2.4、高效数据结构</h3><p>Redis 常用 5 种数据类型 和 应用场景 如下：<ul><li>String：缓存、计数器、分布式锁等。<li>List：链表、队列、微博关注人时间轴列表等。<li>Hash：用户信息、Hash 表等。<li>Set：去重、赞、踩、共同好友等。<li>Zset：访问量排行、点击量排行等。</ul><p>为追求速度，这 5 种数据类型的底层都采用高效的数据结构来支持。<p>这些高效数据结构有如下几种：<ol><li><strong>SDS简单动态字符串</strong><li><strong>LinkedList双端列表</strong><li><strong>ZipList压缩列表</strong><li><strong>哈希表</strong><li><strong>整型数组</strong><li><strong>SkipList跳表</strong></ol><p>Redis数据类型和底层数据结构的对应关系参考下图：<p><img alt=image-20210426103940774 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/%E5%94%AF%E5%BF%AB%E4%B8%8D%E7%A0%B4-image-20210426103940774.png><h3 id=1-2-5、动态编码><a class=headerlink href=#1-2-5、动态编码 title=1.2.5、动态编码></a>1.2.5、动态编码</h3><p><strong>Redis 使用对象（redisObject）来表示数据库中的键值，当创建一个键值对时，至少创建两个对象，一个是键对象，另一个是值对象</strong>。<ul><li><p><strong>String</strong></p> <p>数字类型采用 int 类型编码，非数字采用 raw 编码。</p><li><p><strong>List</strong></p> <p>字符串长度 > 64 字节且元素个数 > 512 时使用 linkedlist 编码，否则转化为 ziplist 编码；</p> <p>注意：这两个条件可以在 redis.conf 中进行修改：</p> <figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>list-max-ziplist-entries</span> <span class=string>512</span></span><br><span class=line><span class=attr>list-max-ziplist-value</span> <span class=string>64</span></span><br></pre></table></figure><li><p><strong>Hash</strong></p> <p>Hash 对象同时满足以下两个条件时采用 ziplist 编码，否则使用 hashtable 编码。</p> <ul><li>Hash 对象所有键值对的键和值的字符串长度均小于 64 字节。<li>Hash 对象键值对数量小于 512 个。</ul><li><p><strong>Set</strong></p> <p>保存的元素为整数且元素个数小于一定范围时使用 intset 编码，任意一个条件不满足时使用 hashtable 编码；</p><li><p><strong>ZSet</strong></p> <p>ziplist 编码存储时，集合每个元素使用两个紧挨在一起的压缩列表来存储。Ziplist 压缩列表第一个节点存储元素的成员，第二个节点存储元素的分值，并且按分值从小到大有序排列。</p> <p>Zset 对象同时满足以下两个条件时采用 ziplist 编码，两者都不符合时采用 skiplist 编码。</p> <ul><li>Zset 元素个数小于 128。</ul><li><p>Zset 元素的成员长度都小于 64 字节。</p> <p>注意：两个条件可以在 redis.conf 中进行修改：</p> <figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>zset-max-ziplist-entries</span> <span class=string>128</span></span><br><span class=line><span class=attr>zset-max-ziplist-value</span> <span class=string>64</span></span><br></pre></table></figure></ul><h3 id=1-2-6、小结><a class=headerlink href=#1-2-6、小结 title=1.2.6、小结></a>1.2.6、小结</h3><ol><li><strong>纯内存操作</strong>。一般都是存取操作，线程占用时间多，时间花费主要集中在 IO 上，所以读取速度快。<li><strong>整个 Redis 就是一个全局哈希表，时间复杂度是 O(1)，为防止哈希冲突导致链表过长会执行 rehash 来扩充哈希桶数量。为防止重新映射大量数据导致线程阻塞会采用 渐进式 rehash</strong>。将一次性拷贝分摊到多次请求过程后，避免了阻塞。<li><strong>Redis 使用非阻塞 IO 及 IO 多路复用</strong>。使用了单线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，Redis 采用自己实现的事件分离器，效率比较高。<li><strong>采用单线程模型，保证了每个操作的原子性，也减少了线程的上下文切换和竞争</strong>。<li><strong>Redis 使用 hash 结构加快读取速度，使用压缩表减少空间占用成本，使用跳表加快查找速度</strong>。<li><strong>不同的数据类型会自动选择不同编码来存储</strong>。</ol></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87/ itemprop=url>Redis系列-Redis模拟面试题第一篇</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-07 09:59:37" datetime=2023-08-07T09:59:37+08:00 itemprop=dateModified>2023-08-07</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Redis/ itemprop=url rel=index><span itemprop=name>Redis</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、基础摸底><a class=headerlink href=#1、基础摸底 title=1、基础摸底></a>1、基础摸底</h1><h2 id=1-1、何为Redis><a class=headerlink href=#1-1、何为Redis title=1.1、何为Redis></a>1.1、何为Redis</h2><p><strong>Redis 是 NoSQL 数据库，也即非关系型数据库。</strong>。<h2 id=1-2、NoSQL-BASE理论><a title="1.2、NoSQL BASE理论" class=headerlink href=#1-2、NoSQL-BASE理论></a>1.2、NoSQL BASE理论</h2><p><strong>BASE理论是对CAP中一致性的妥协</strong>。与 传统事务ACID 不同，BASE不追求强一致性，只要最终达到一致就行。<blockquote><p>CAP是三个单词的首字母，其代表的意思如下：<ul><li>C：一致性<li>A：可用性<li>P：分区容错性</ul><p>BASE是Basically Available（基本可用）、Soft-state（软状态）和 Eventually Consistent（最终一致性）三个词语的缩写。</blockquote><h2 id=1-3、Redis常用命令><a class=headerlink href=#1-3、Redis常用命令 title=1.3、Redis常用命令></a>1.3、Redis常用命令</h2><ul><li><strong>读操作</strong>：get a 表示获取a对应的数据；<li><strong>写操作</strong>：setex a t b 表示将a的数据设置为b，并且在t秒后过期；</ul><h2 id=1-4、Redis-key清除策略><a title="1.4、Redis key清除策略" class=headerlink href=#1-4、Redis-key清除策略></a>1.4、Redis key清除策略</h2><p>过期键 清除策略 有三种，分别如下：<ul><li><strong>定时删除</strong>：为键设置过期时间时，创建一个定时器，让定时器在键过期时，立即删除该键；<li><strong>定期删除</strong>：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键；<li><strong>惰性删除</strong>：实际去使用时若发现Key过期了，此时再进行删除；</ul><p><strong>Redis采用的是 定期删除 和 惰性删除 相结合的方式</strong>。<h2 id=1-5、过期键没有被访问，且删除又跟不上新键速度，内存会耗尽吗？><a class=headerlink href=#1-5、过期键没有被访问，且删除又跟不上新键速度，内存会耗尽吗？ title=1.5、过期键没有被访问，且删除又跟不上新键速度，内存会耗尽吗？></a>1.5、过期键没有被访问，且删除又跟不上新键速度，内存会耗尽吗？</h2><p><strong>Redis支持内存淘汰，参数<code>maxmemory_policy</code>决定了内存淘汰策略的种类。</strong>这个参数一共有8个枚举值。<ul><li>不开启数据淘汰<ol><li>noeviction</ol><li>基于有过期时间的数据<ol><li>volatitle-lfu<li>volatitle-lru<li>volatitle-random<li>volatitle-ttl</ol><li>基于所有数据<ol><li>allkeys-lru<li>allkeys-random<li>allkeys-ttl</ol></ul><h2 id=1-6、内存淘汰用到的是LRU算法吗？><a class=headerlink href=#1-6、内存淘汰用到的是LRU算法吗？ title=1.6、内存淘汰用到的是LRU算法吗？></a>1.6、内存淘汰用到的是LRU算法吗？</h2><p>LRU算法需要一个双向链表来记录数据最近被访问的顺序，为节省内存，<strong>Redis的LRU算法并非是原生LRU算法</strong>。<p>Redis内存淘汰过程：<strong>Redis通过对少量键进行取样，然后与淘汰池中的进行综合比较，最终回收最久未被访问的键</strong>。<p>注意：通过<strong>调整每次回收时的采样数量<code>maxmemory-samples</code>，可以调整算法精度</strong>。<h1 id=2、数据结构><a class=headerlink href=#2、数据结构 title=2、数据结构></a>2、数据结构</h1><h2 id=2-1、Redis数据结构><a class=headerlink href=#2-1、Redis数据结构 title=2.1、Redis数据结构></a>2.1、Redis数据结构</h2><p>对外暴露5种Redis对象，分别是<code>String、List、Hash、Set、Zset</code>。底层实现依托于<code>sds、ziplist、skiplist、dict</code>等数据结构。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629223912586.png><h2 id=2-2、Redis字符串特点><a class=headerlink href=#2-2、Redis字符串特点 title=2.2、Redis字符串特点></a>2.2、Redis字符串特点</h2><p>如果保存的对象是整数就用int存储，否则使用SDS来存储。SDS通过记录长度，和预分配空间，可以高效计算长度，进行append操作。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629224144667.png><h2 id=2-3、Hash扩容><a class=headerlink href=#2-3、Hash扩容 title=2.3、Hash扩容></a>2.3、Hash扩容</h2><p><strong>两张Hash表，一般先使用0号表，当装载因子超过阈值时会进行Rehash，将0号表上的每一个bucket慢慢移动到1号表，所以叫渐进式Rehash。</strong>渐进式Rehash方式可以减少迁移大量数据造成的性能影响。<h2 id=2-4、Rehash过程><a class=headerlink href=#2-4、Rehash过程 title=2.4、Rehash过程></a>2.4、Rehash过程</h2><p>当周期函数发现装载因子超过阈值时就会进行Rehash。Rehash流程主要分成三步：<ol><li><p><strong>生成新Hash表ht[1]，为 ht[1] 分配空间</strong>。</p> <p>字典持有ht[0]和ht[1]两个哈希表。字典的偏移索引从-1变为0，表示Rehash 工作正式开始。</p><li><p>**迁移 ht[0] 数据到 ht[1]**。</p> <p>在 Rehash执行期间，每次对字典执行增删查改操作，程序会顺带迁移一个ht[0]上的数据，并更新偏移索引。与此同时，周期函数也会定时迁移一批。</p><li><p><strong>交换 ht[1] 和 ht[0] 的指针</strong>。</p> <p>随着字典操作的不断执行， 最终在某个时间点上，ht[0]的所有键值对都会被Rehash至 ht[1]，此时再将ht[1]和ht[0]的指针对象进行互换，同时把偏移索引的值设为-1，表示Rehash操作已完成。</p></ol><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629224615221.png><h2 id=2-5、rehash时有请求过来，redis会如何处理？><a class=headerlink href=#2-5、rehash时有请求过来，redis会如何处理？ title=2.5、rehash时有请求过来，redis会如何处理？></a>2.5、rehash时有请求过来，redis会如何处理？</h2><ul><li>插入请求：将数据插入到ht[1]中；<li>读取请求：先从ht[0]读取，若没有再从ht[1]中查找；<li>删除/更新请求：先找ht[0]，再找ht[1]，然后执行相关操作；</ul><h2 id=2-6、跳表><a class=headerlink href=#2-6、跳表 title=2.6、跳表></a>2.6、跳表</h2><p><strong>跳表本质是对链表的优化。通过逐层跳步采样构建索引，加快查找速度</strong>。跳表可高层索引，一次跳跃多个节点，如果找过头了，就使用下层索引。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629224859742.png><h2 id=2-7、每个节点多少层？><a class=headerlink href=#2-7、每个节点多少层？ title=2.7、每个节点多少层？></a>2.7、每个节点多少层？</h2><p>使用 概率均衡思路 确定新插入节点的层数。Redis <strong>使用随机函数决定层数</strong>。直观上来说，默认1层，和丢硬币一样，如果是正面就继续往上，这样持续迭代，<strong>最大层数 32 层</strong>。<p>可以看到，50%的概率被分配到第一层，25%的概率被分配到第二层，12.5%的概率被分配到第三层。这种方式保证了层数越高其数量越少，自然跨越起来越方便。<h2 id=2-8、Zset为何需要字典和跳表来实现？><a class=headerlink href=#2-8、Zset为何需要字典和跳表来实现？ title=2.8、Zset为何需要字典和跳表来实现？></a>2.8、Zset为何需要字典和跳表来实现？</h2><p>Zset是一个有序列表，<strong>字典和跳表分别适用 按成员查询数据 和 按范围查询</strong>。<h1 id=3、系统容灾><a class=headerlink href=#3、系统容灾 title=3、系统容灾></a>3、系统容灾</h1><h2 id=3-1、Redis服务重启，数据会丢失吗？><a class=headerlink href=#3-1、Redis服务重启，数据会丢失吗？ title=3.1、Redis服务重启，数据会丢失吗？></a>3.1、Redis服务重启，数据会丢失吗？</h2><p>不会丢失。可通过持久化机制来备份数据，有两种方式：<ol><li><strong>RDB持久化</strong>：RDB是Redis的二进制快照文件，优点是文件紧凑，占用空间小，恢复速度快。同时，由于是子进程Fork模式，对Redis本身读写性能影响很小。<li><strong>AOF持久化</strong>：AOF会以日志形式记录Redis操作命令，AOF文件 比 RDB大很多，恢复速度较慢；</ol><p>如果开启AOF，会将命令先记录在AOF缓冲，之后再刷入磁盘。数据刷入磁盘的时机是根据参数决定，有三种模式：1.关闭时刷入；2.每秒定期刷入；3.执行命令后立刻触发。<p>AOF优点 是 发生故障时丢失数据比RDB少。执行命令后立马刷入会拖慢执行速度，故一般设为每秒定期刷入。<h2 id=3-2、AOF文件会越来越大，最后磁盘不就装不下了？><a class=headerlink href=#3-2、AOF文件会越来越大，最后磁盘不就装不下了？ title=3.2、AOF文件会越来越大，最后磁盘不就装不下了？></a>3.2、AOF文件会越来越大，最后磁盘不就装不下了？</h2><p><strong>Redis会在AOF文件体积达到设定阈值时自动Fork一个子进程，用来对AOF文件进行重写</strong>。<p>重写过程中，Redis将新的操作记录在原有AOF缓冲区，且还会记录在AOF重写缓冲区。一旦新AOF文件创建完毕，Redis 就会将重写缓冲区内容追加到新AOF文件中，然后用 新AOF文件 替换 旧AOF文件。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629230205745.png><h2 id=3-3、Redis挂掉怎么办？><a class=headerlink href=#3-3、Redis挂掉怎么办？ title=3.3、Redis挂掉怎么办？></a>3.3、Redis挂掉怎么办？</h2><p>使用 主从模式 可避免 机器宕机问题。即有一个或多个备用机器，备用机将作为Slave同步Master数据，Redis出现问题时将Slave升级为Master。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629230331075.png><h2 id=3-4、主从可以自动切换吗？><a class=headerlink href=#3-4、主从可以自动切换吗？ title=3.4、主从可以自动切换吗？></a>3.4、主从可以自动切换吗？</h2><p>本身不能，但可通过 脚本 实现，不过考虑的问题较多。Redis解决方案：哨兵模式。<strong>哨兵来监测Redis服务是否正常，异常情况下将由哨兵代理切换。为避免哨兵单点故障问题，哨兵也要多机部署</strong>。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629230456394.png><h2 id=3-5、如果Master挂掉，会选择哪个Slave呢？><a class=headerlink href=#3-5、如果Master挂掉，会选择哪个Slave呢？ title=3.5、如果Master挂掉，会选择哪个Slave呢？></a>3.5、如果Master挂掉，会选择哪个Slave呢？</h2><p>哨兵集群选举出哨兵Leader后，哨兵Leader 会从Redis slave节点中选择一个节点作为主节点：<ol><li><strong>判断 salve 节点与 master 节点断开时间长短，时间超过（down-after-milliseconds * 10）则排除该节点</strong>；<li><strong>判断 slave节点的 slave-priority 值大小，越小优先级越高，如果值为 0 则不参与选举</strong>。如果相同继续。<li><strong>判断 slave 节点的 offset 值大小，值越大数据越新，优先级就越高</strong>。<li><strong>判断 slave 节点的 runid 大小，越小优先级越高</strong>。</ol><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629230808740.png><h2 id=3-6、哨兵Leader是如何选出来的？><a class=headerlink href=#3-6、哨兵Leader是如何选出来的？ title=3.6、哨兵Leader是如何选出来的？></a>3.6、哨兵Leader是如何选出来的？</h2><p>每一个哨兵节点都可以成为Leader，当一个哨兵节点确认Redis集群主节点主观下线后，会请求其他哨兵节点将自己选举为Leader。被请求的哨兵节点如果没有同意过其他哨兵节点的选举请求，则同意该请求，也就是选举票数+1，否则不同意。<p><strong>如果一个哨兵节点获得的选举票数超过节点数的一半，且大于<code>quorum</code>配置的值，则该哨兵节点选举为 Leader；否则重新进行选举</strong>。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629231059635.png><h1 id=4、性能优化><a class=headerlink href=#4、性能优化 title=4、性能优化></a>4、性能优化</h1><h2 id=4-1、Redis性能如何？><a class=headerlink href=#4-1、Redis性能如何？ title=4.1、Redis性能如何？></a>4.1、Redis性能如何？</h2><p>只能说在十万级。使用前要跑BenchMark，实际情况下会受带宽、负载、单个数据大小、是否开启多线程等因素影响，脱离具体场景谈性能没有意义。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629231239734.png><h2 id=4-2、Redis是协程模型，还是多线程模型？><a class=headerlink href=#4-2、Redis是协程模型，还是多线程模型？ title=4.2、Redis是协程模型，还是多线程模型？></a>4.2、Redis是协程模型，还是多线程模型？</h2><p>Redis是单线程Reactor模型，通过高效的IO复用以及内存处理来实现高性能。<p><strong>Redis 6.0之前是单线程，6.0之后还是单线程，但IO解包通过多线程做了优化，而处理逻辑还是单线程</strong>。<p>另外，如果考虑到RDB的Fork 和 一些定时任务处理，那么也可以说Redis是多进程。但要知道 Redis 处理数据 始终都是单线程。<h2 id=4-3、6-0多线程功能><a class=headerlink href=#4-3、6-0多线程功能 title=4.3、6.0多线程功能></a>4.3、6.0多线程功能</h2><p><strong>多线程主要用于提高解包效率</strong>。和Multi Reactor多线程模型不同，<strong>Redis多线程只负责处理网络 IO 解包和协议转换</strong>，一方面是单线程处理足够快，另一方面是为了兼容性考虑。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629231531238.png><h2 id=4-4、数据太大存不下怎么办？><a class=headerlink href=#4-4、数据太大存不下怎么办？ title=4.4、数据太大存不下怎么办？></a>4.4、数据太大存不下怎么办？</h2><p><strong>集群模式将数据分片，不同的 Key 根据 Hash 路由到不同节点</strong>。集群索引通过一致性Hash算法来完成，这种算法可以解决服务器数量发生改变时，所有服务器缓存同一时间失效问题。<p>基于Gossip协议，集群状态变化时，如新节点加入、节点宕机、Slave升为新Master等变化都能传播到整个集群所有节点并达成一致。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629231746172.png><h2 id=4-5、一致性hash><a class=headerlink href=#4-5、一致性hash title=4.5、一致性hash></a>4.5、一致性hash</h2><p><strong>传统Hash分片可以将某个Key落到某个节点。但当节点扩容或者缩容时路由会被打乱。如果是缓存场景，容易造成缓存雪崩问题</strong>。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629232059868.png><p>为了优化这种情况，一致性Hash就应运而生了。<p><strong>一致性 Hash 是将数据和服务器以相同的 Hash 函数映射到同一个 Hash 环上，针对一个对象，在哈希环上顺时针查找距其最近的机器，这个机器就负责处理该对象的相关请求</strong>。<p>这种情况下，增加节点只会分流后面一个节点的数据。减少节点会由后一个节点继承。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629232345450.png><h1 id=5、场景应用><a class=headerlink href=#5、场景应用 title=5、场景应用></a>5、场景应用</h1><h2 id=5-1、Redis数据一致性><a class=headerlink href=#5-1、Redis数据一致性 title=5.1、Redis数据一致性></a>5.1、Redis数据一致性</h2><p>从设计思路来说，有 Cache Aside 和 Read / Write Through 两种模式，前者会把缓存责任交给应用层，后者会把缓存责任交给服务提供方。<h2 id=5-2、两种模式哪个更好？><a class=headerlink href=#5-2、两种模式哪个更好？ title=5.2、两种模式哪个更好？></a>5.2、两种模式哪个更好？</h2><p>两种模式各有优缺点，<strong>从透明性考虑，服务方比较合适；从性能考虑来说，业务方会更有优势</strong>，可以减去服务RPC损耗。<h2 id=5-3、数据变化时如何更新缓存？><a class=headerlink href=#5-3、数据变化时如何更新缓存？ title=5.3、数据变化时如何更新缓存？></a>5.3、数据变化时如何更新缓存？</h2><p>更新方式大概有四种：<ol><li>先保存至缓存，然后再同步至数据库，同步成功后让缓存失效，等到读缓存没有命中时再加载进去；<li>通过消息队列更新缓存；<li>先更新缓存，再更新服务，这种情况相当于把Cache当作Buffer使用；<li>起一个同步服务，作为MySQL一个从节点，通过解析binlog同步重要缓存；</ol><h2 id=5-4、Redis缓存雪崩><a class=headerlink href=#5-4、Redis缓存雪崩 title=5.4、Redis缓存雪崩></a>5.4、Redis缓存雪崩</h2><p>缓存雪崩定义：某一时间段内 缓存集中失效，导致请求全部打到数据库，严重可能会导致整个服务瘫痪。<p>应对方案：让过期时间随机化，避免大量缓存在同一时间过期。同时也可考虑为热点数据使用双缓存。<h2 id=5-5、Redis缓存穿透><a class=headerlink href=#5-5、Redis缓存穿透 title=5.5、Redis缓存穿透></a>5.5、Redis缓存穿透</h2><p>缓存穿透定义：请求了数据库中没有的数据，高频请求不存在的Key，有可能是正常业务逻辑，也可能是黑客攻击。<p>应对方案：通过 布隆过滤器 来避免频繁请求不存在的数据。布隆过滤器是一种比较巧妙的概率型数据结构，特点是高效插入和查询，可以用来告诉我们某样东西一定不存在或者可能存在。<h2 id=5-6、布隆过滤器实现原理><a class=headerlink href=#5-6、布隆过滤器实现原理 title=5.6、布隆过滤器实现原理></a>5.6、布隆过滤器实现原理</h2><p><strong>布隆过滤器底层是一个64位整型，将字符串通过多个Hash函数映射到不同的二进制位上，然后将对应位置设置为1</strong>。<p><font color=red>注意：查询时，如果一个字符串所有Hash函数映射的值都存在，那么数据可能存在。为什么说可能呢，就是因为其他字符可能占据该值，提前点亮。</font><p>优缺点：优点是空间、时间消耗都很小，缺点是结果不是完全准确。<p><img alt=image-20210629233454825 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023%2F08%2F07%2FRedis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629233454825.png><h2 id=5-7、Redis缓存击穿><a class=headerlink href=#5-7、Redis缓存击穿 title=5.7、Redis缓存击穿></a>5.7、Redis缓存击穿</h2><p>缓存击穿定义：要获取的某个高频键值数据在数据库中存在，但缓存中过期了，此时大量请求打到后端数据库就可能导致服务崩溃。<p>应对方案：可以使用 分布式锁 或 分布式令牌桶 来限频。<h2 id=5-8、Redis支持消息队列功能吗？><a class=headerlink href=#5-8、Redis支持消息队列功能吗？ title=5.8、Redis支持消息队列功能吗？></a>5.8、Redis支持消息队列功能吗？</h2><p>支持消息队列，但不建议使用，因为 Redis的消息队列 缺少消息队列相关规范。<h2 id=5-9、Redis在秒杀场景中的应用><a class=headerlink href=#5-9、Redis在秒杀场景中的应用 title=5.9、Redis在秒杀场景中的应用></a>5.9、Redis在秒杀场景中的应用</h2><p>Redis应用场景分析如下：<ol><li>流量控制；<li>分布式锁；</ol><h2 id=5-10、Redis分布式锁><a class=headerlink href=#5-10、Redis分布式锁 title=5.10、Redis分布式锁></a>5.10、Redis分布式锁</h2><p>分布式锁 依赖 存储组件，针对请求量的不同，可以选择Etcd、MySQL、Redis等。前两者可靠性更强，Redis性能更高。<h2 id=5-11、Redis在限流场景中的应用><a class=headerlink href=#5-11、Redis在限流场景中的应用 title=5.11、Redis在限流场景中的应用></a>5.11、Redis在限流场景中的应用</h2><p>微服务架构中，<strong>实现流量控制的方式之一就是Redis令牌桶</strong>。<ul><li><p><strong>令牌获取</strong></p> <p>Redis管理令牌，微服务在执行函数操作前需向Redis申请令牌。若有 剩余令牌 就返回一个令牌给申请者，若没有剩余令牌就阻塞。</p><li><p><strong>令牌生成</strong></p> <p>为提高性能，令牌生成采用懒生成方式。也就是 在获取令牌时生成令牌，获取和生成操作可以在一个Lua脚本中实现，保证了原子性。</p></ul><p><img alt=image-20210629234221317 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023%2F08%2F07%2FRedis%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC%E4%B8%80%E7%AF%87-image-20210629234221317.png></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/ itemprop=url>Redis系列-Redis集群搭建</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-07 09:24:39" datetime=2023-08-07T09:24:39+08:00 itemprop=dateModified>2023-08-07</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Redis/ itemprop=url rel=index><span itemprop=name>Redis</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、Redis主从集群><a class=headerlink href=#1、Redis主从集群 title=1、Redis主从集群></a>1、Redis主从集群</h1><p>本集群模式为一主二从。<h2 id=1-1、准备3台服务器><a class=headerlink href=#1-1、准备3台服务器 title=1.1、准备3台服务器></a>1.1、准备3台服务器</h2><p>三台服务器信息如下：<table><thead><tr><th align=center>IP<th align=center>PORT<tbody><tr><td align=center>192.168.2.23<td align=center>6379<tr><td align=center>192.168.2.24<td align=center>6379<tr><td align=center>192.168.2.25<td align=center>6379</table><h2 id=1-2、Redis配置><a class=headerlink href=#1-2、Redis配置 title=1.2、Redis配置></a>1.2、Redis配置</h2><p>三台服务器的Redis配置相同，这里仅展示一份配置信息。<p>在redis.conf配置文件中加入如下配置：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=comment># 绑定地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问</span></span><br><span class=line><span class=attr>bind</span> <span class=string>0.0.0.0</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment># 数据库数量，设置为1</span></span><br><span class=line><span class=attr>databases</span> <span class=string>1</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment># 开启RDB</span></span><br><span class=line><span class=comment># save ""</span></span><br><span class=line><span class=attr>save</span> <span class=string>3600 1</span></span><br><span class=line><span class=attr>save</span> <span class=string>300 100</span></span><br><span class=line><span class=attr>save</span> <span class=string>60 10000</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment># 关闭AOF</span></span><br><span class=line><span class=attr>appendonly</span> <span class=string>no</span></span><br></pre></table></figure><h2 id=1-3、启动3台Redis服务><a class=headerlink href=#1-3、启动3台Redis服务 title=1.3、启动3台Redis服务></a>1.3、启动3台Redis服务</h2><p>分别在三台服务器中执行如下命令：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>redis-server redis.conf</span><br></pre></table></figure><h2 id=1-4、开启主从关系><a class=headerlink href=#1-4、开启主从关系 title=1.4、开启主从关系></a>1.4、开启主从关系</h2><p>将服务器<code>192.168.2.23</code>作为 master节点，剩下2台服务器作为 slave节点。所以只需在slave节点中执行如下命令：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment># 192.168.2.24</span></span><br><span class=line>redis-cli -p 6379</span><br><span class=line>slaveof 192.168.2.23 6379</span><br><span class=line></span><br><span class=line><span class=comment># 192.168.2.25</span></span><br><span class=line>redis-cli -p 6379</span><br><span class=line>slaveof 192.168.2.23 6379</span><br></pre></table></figure><p>执行完上述命令后，若没有什么错误，则表示配置成功。然后可以在master节点中查看集群状态：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=comment># 192.168.2.23</span></span><br><span class=line>redis-cli -p 6379</span><br><span class=line>info replication</span><br></pre></table></figure><h2 id=1-5、测试效果><a class=headerlink href=#1-5、测试效果 title=1.5、测试效果></a>1.5、测试效果</h2><p>执行如下命令，若一切正常则表示 一主二从集群 搭建成功。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment># master节点（192.168.2.23）</span></span><br><span class=line><span class=built_in>set</span> k1 v1</span><br><span class=line><span class=comment># slave节点（192.168.2.24）：</span></span><br><span class=line>get k1</span><br><span class=line><span class=built_in>set</span> k1 v2</span><br><span class=line><span class=comment># slave节点（192.168.2.25）：</span></span><br><span class=line>get k1</span><br><span class=line><span class=built_in>set</span> k1 v2</span><br></pre></table></figure><h1 id=2、Redis哨兵集群><a class=headerlink href=#2、Redis哨兵集群 title=2、Redis哨兵集群></a>2、Redis哨兵集群</h1><h2 id=2-1、准备三台服务器><a class=headerlink href=#2-1、准备三台服务器 title=2.1、准备三台服务器></a>2.1、准备三台服务器</h2><p>这里以Redis集群服务器为例。<h2 id=2-2、配置><a class=headerlink href=#2-2、配置 title=2.2、配置></a>2.2、配置</h2><p>三台服务器的Redis配置相同，这里仅展示一份配置信息。<p>在<code>sentinel.conf</code>配置文件中修改如下配置：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=attr>port</span> <span class=string>27001</span></span><br><span class=line><span class=attr>sentinel</span> <span class=string>monitor mymaster 192.168.2.4 6379 2</span></span><br><span class=line><span class=attr>sentinel</span> <span class=string>down-after-milliseconds mymaster 5000</span></span><br><span class=line><span class=attr>sentinel</span> <span class=string>failover-timeout mymaster 60000</span></span><br><span class=line><span class=attr>dir</span> <span class=string>"/opt/redis/data"</span></span><br></pre></table></figure><h2 id=2-3、启动Redis服务><a class=headerlink href=#2-3、启动Redis服务 title=2.3、启动Redis服务></a>2.3、启动Redis服务</h2><p>分别在三台服务器中执行如下命令：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>redis-sentinel sentinel.conf</span><br></pre></table></figure><h2 id=2-4、测试><a class=headerlink href=#2-4、测试 title=2.4、测试></a>2.4、测试</h2><p>关闭master节点服务，查看两个slave节点的状态，其中有一个会升级为master节点。<h2 id=2-5、SpringBoot集成><a class=headerlink href=#2-5、SpringBoot集成 title=2.5、SpringBoot集成></a>2.5、SpringBoot集成</h2><h3 id=2-5-1、配置><a class=headerlink href=#2-5-1、配置 title=2.5.1、配置></a>2.5.1、配置</h3><p>application.yml文件：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>redis:</span></span><br><span class=line>    <span class=attr>sentinel:</span></span><br><span class=line>      <span class=attr>master:</span> <span class=string>mymaster</span></span><br><span class=line>      <span class=attr>nodes:</span></span><br><span class=line>        <span class=bullet>-</span> <span class=number>192.168</span><span class=number>.2</span><span class=number>.4</span><span class=string>:27001</span></span><br><span class=line>        <span class=bullet>-</span> <span class=number>192.168</span><span class=number>.2</span><span class=number>.4</span><span class=string>:27002</span></span><br><span class=line>        <span class=bullet>-</span> <span class=number>192.168</span><span class=number>.2</span><span class=number>.4</span><span class=string>:27003</span></span><br></pre></table></figure><p>配置类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * RedisTemplate哨兵模式 - 配置主从读写分离</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * ReadFrom是配置Redis的读取策略，可选值如下：</span></span><br><span class=line><span class=comment> *      - MASTER                从master节点读取</span></span><br><span class=line><span class=comment> *      - MASTER_PREFERRED      优先读取master节点，master不可用再读取replica</span></span><br><span class=line><span class=comment> *      - REPLICA               从slave节点读取</span></span><br><span class=line><span class=comment> *      - REPLICA_PREFERRED     优先读取slave节点，slave不可用再读取master</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * <span class=doctag>@return</span></span></span><br><span class=line><span class=comment>*/</span></span><br><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> LettuceClientConfigurationBuilderCustomizer <span class="title function_">configurationBuilderCustomizer</span><span class=params>()</span>{</span><br><span class=line>    <span class=keyword>return</span> config -> config.readFrom(ReadFrom.REPLICA_PREFERRED);</span><br><span class=line>}</span><br></pre></table></figure><h1 id=3、Redis分片集群><a class=headerlink href=#3、Redis分片集群 title=3、Redis分片集群></a>3、Redis分片集群</h1><h2 id=3-1、准备服务器><a class=headerlink href=#3-1、准备服务器 title=3.1、准备服务器></a>3.1、准备服务器</h2><p>在同一台虚拟机中开启6个redis实例，模拟分片集群，信息如下：<table><thead><tr><th align=center>IP<th align=center>PORT<th align=center>角色<tbody><tr><td align=center>192.168.150.101<td align=center>7001<td align=center>master<tr><td align=center>192.168.150.101<td align=center>7002<td align=center>master<tr><td align=center>192.168.150.101<td align=center>7003<td align=center>master<tr><td align=center>192.168.150.101<td align=center>8001<td align=center>slave<tr><td align=center>192.168.150.101<td align=center>8002<td align=center>slave<tr><td align=center>192.168.150.101<td align=center>8003<td align=center>slave</table><h2 id=3-2、实例创建与配置><a class=headerlink href=#3-2、实例创建与配置 title=3.2、实例创建与配置></a>3.2、实例创建与配置</h2><p>创建7001、7002、7003、8001、8002、8003目录：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment># 进入/tmp目录</span></span><br><span class=line><span class=built_in>cd</span> /tmp</span><br><span class=line><span class=comment># 删除旧的，避免配置干扰</span></span><br><span class=line><span class=built_in>rm</span> -rf 7001 7002 7003</span><br><span class=line><span class=comment># 创建目录</span></span><br><span class=line><span class=built_in>mkdir</span> 7001 7002 7003 8001 8002 8003</span><br></pre></table></figure><p>在/tmp下准备一个新的redis.conf文件，内容如下：<figure class="highlight ini"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line>port 6379</span><br><span class=line><span class=comment># 开启集群功能</span></span><br><span class=line>cluster-enabled yes</span><br><span class=line><span class=comment># 集群的配置文件名称，不需要我们创建，由redis自己维护</span></span><br><span class=line>cluster-config-file /tmp/6379/nodes.conf</span><br><span class=line><span class=comment># 节点心跳失败的超时时间</span></span><br><span class=line>cluster-node-timeout 5000</span><br><span class=line><span class=comment># 持久化文件存放目录</span></span><br><span class=line>dir /tmp/6379</span><br><span class=line><span class=comment># 绑定地址</span></span><br><span class=line>bind 0.0.0.0</span><br><span class=line><span class=comment># 让redis后台运行</span></span><br><span class=line>daemonize yes</span><br><span class=line><span class=comment># 注册的实例ip</span></span><br><span class=line>replica-announce-ip 192.168.2.21</span><br><span class=line><span class=comment># 保护模式</span></span><br><span class=line>protected-mode no</span><br><span class=line><span class=comment># 数据库数量</span></span><br><span class=line>databases 1</span><br><span class=line><span class=comment># 日志</span></span><br><span class=line>logfile /tmp/6379/run.log</span><br></pre></table></figure><p>将这个文件拷贝到每个目录下：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># 进入/tmp目录</span></span><br><span class=line><span class=built_in>cd</span> /tmp</span><br><span class=line><span class=comment># 执行拷贝</span></span><br><span class=line><span class=built_in>echo</span> 7001 7002 7003 8001 8002 8003 | xargs -t -n 1 <span class=built_in>cp</span> redis.conf</span><br></pre></table></figure><p>修改每个目录下的redis.conf，将其中的6379修改为与所在目录一致：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># 进入/tmp目录</span></span><br><span class=line><span class=built_in>cd</span> /tmp</span><br><span class=line><span class=comment># 修改配置文件</span></span><br><span class=line><span class=built_in>printf</span> <span class=string>'%s\n'</span> 7001 7002 7003 8001 8002 8003 | xargs -I{} -t sed -i <span class=string>'s/6379/{}/g'</span> {}/redis.conf</span><br></pre></table></figure><h2 id=3-3、启动服务><a class=headerlink href=#3-3、启动服务 title=3.3、启动服务></a>3.3、启动服务</h2><p>因为已经配置了后台启动模式，所以可以直接启动服务：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># 进入/tmp目录</span></span><br><span class=line><span class=built_in>cd</span> /tmp</span><br><span class=line><span class=comment># 一键启动所有服务</span></span><br><span class=line><span class=built_in>printf</span> <span class=string>'%s\n'</span> 7001 7002 7003 8001 8002 8003 | xargs -I{} -t redis-server {}/redis.conf</span><br></pre></table></figure><p>通过ps查看状态：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>ps -ef | grep redis</span><br></pre></table></figure><p>如果要关闭所有进程，可以执行命令：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>ps -ef | grep redis | awk <span class=string>'{print $2}'</span> | xargs <span class=built_in>kill</span></span><br></pre></table></figure><p>或者（推荐这种方式）：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>printf</span> <span class=string>'%s\n'</span> 7001 7002 7003 8001 8002 8003 | xargs -I{} -t redis-cli -p {} shutdown</span><br></pre></table></figure><h2 id=3-4、创建集群><a class=headerlink href=#3-4、创建集群 title=3.4、创建集群></a>3.4、创建集群</h2><p>虽然服务启动了，但是目前每个服务之间都是独立的，没有任何关联。<p>我们需要执行命令来创建集群，在Redis5.0之前创建集群比较麻烦，5.0之后集群管理命令都集成到了redis-cli中。<h3 id=3-4-1、Redis5-0前><a class=headerlink href=#3-4-1、Redis5-0前 title=3.4.1、Redis5.0前></a>3.4.1、Redis5.0前</h3><p>Redis5.0之前集群命令都是用redis安装包下的src/redis-trib.rb来实现的。因为redis-trib.rb是有ruby语言编写的所以需要安装ruby环境。<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=comment># 安装依赖</span></span><br><span class=line>yum -y install zlib ruby rubygems</span><br><span class=line>gem install redis</span><br></pre></table></figure><p>然后通过命令来管理集群：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># 进入redis的src目录</span></span><br><span class=line><span class=built_in>cd</span> /tmp/redis-6.2.4/src</span><br><span class=line><span class=comment># 创建集群</span></span><br><span class=line>./redis-trib.rb create --replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003</span><br></pre></table></figure><h3 id=3-4-2、Redis5-0后><a class=headerlink href=#3-4-2、Redis5-0后 title=3.4.2、Redis5.0后></a>3.4.2、Redis5.0后</h3><p>我们使用的是Redis6.2.4版本，集群管理已经集成到了redis-cli中，格式如下：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>redis-cli --cluster create --cluster-replicas 1 192.168.2.21:7001 192.168.2.21:7002 192.168.2.21:7003 192.168.2.21:8001 192.168.2.21:8002 192.168.2.21:8003</span><br></pre></table></figure><p>命令说明：<ul><li><code>redis-cli --cluster</code>或者<code>./redis-trib.rb</code>：代表集群操作命令<li><code>create</code>：代表是创建集群<li><code>--replicas 1</code>或者<code>--cluster-replicas 1</code> ：指定集群中每个master的副本个数为1，此时<code>节点总数 ÷ (replicas + 1)</code> 得到的就是master的数量。因此节点列表中的前n个就是master，其它节点都是slave节点，随机分配到不同master</ul><p>通过命令可以查看集群状态：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>redis-cli -p 7001 cluster nodes</span><br></pre></table></figure><h2 id=3-5、测试><a class=headerlink href=#3-5、测试 title=3.5、测试></a>3.5、测试</h2><p>集群操作时，需要给<code>redis-cli</code>加上<code>-c</code>参数才可以：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>redis-cli -c -p 7001</span><br><span class=line><span class=built_in>set</span> num 123</span><br><span class=line>get num</span><br><span class=line><span class=built_in>set</span> a 1</span><br></pre></table></figure><p>测试成功。<h2 id=3-7、扩容缩容><a class=headerlink href=#3-7、扩容缩容 title=3.7、扩容缩容></a>3.7、扩容缩容</h2><h3 id=3-7-1、扩容><a class=headerlink href=#3-7-1、扩容 title=3.7.1、扩容></a>3.7.1、扩容</h3><p>在原有7001、7002、7003、8001、8002、8003的基础上，增加一个7004节点。<h4 id=3-7-1-1、实例准备与配置><a class=headerlink href=#3-7-1-1、实例准备与配置 title=3.7.1.1、实例准备与配置></a>3.7.1.1、实例准备与配置</h4><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=built_in>cd</span> /tmp</span><br><span class=line><span class=built_in>mkdir</span> 7004</span><br><span class=line><span class=built_in>cp</span> redis.conf 7004</span><br></pre></table></figure><p>修改配置，将其中的6379改为7004：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>sed -i s/6379/7004/g 7004/redis.conf</span><br></pre></table></figure><h4 id=3-7-1-2、启动7004节点><a class=headerlink href=#3-7-1-2、启动7004节点 title=3.7.1.2、启动7004节点></a>3.7.1.2、启动7004节点</h4><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>redis-server 7004/redis.conf</span><br></pre></table></figure><h4 id=3-7-1-3、将7004节点加入集群><a class=headerlink href=#3-7-1-3、将7004节点加入集群 title=3.7.1.3、将7004节点加入集群></a>3.7.1.3、将7004节点加入集群</h4><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>redis-cli --cluster add-node 192.168.2.23:7004 192.168.2.23:7001</span><br></pre></table></figure><p>查看集群状态：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>redis-cli -p 7001 cluster nodes</span><br></pre></table></figure><p>查看输出信息，发现7004节点中没有任何插槽，接下来要将其他节点中的插槽分给7004节点一部分。<h4 id=3-7-1-4、为7004节点分配插槽><a class=headerlink href=#3-7-1-4、为7004节点分配插槽 title=3.7.1.4、为7004节点分配插槽></a>3.7.1.4、为7004节点分配插槽</h4><p>执行如下命令来分配插槽：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>redis-cli --cluster reshard 192.168.2.23:7001</span><br></pre></table></figure><p>上述命令执行过程中会提示四次，每次都需要输入：<ul><li>第一个值：表示需要移动多少的槽位？该值最好是(16384 / master节点数量)计算结果。<li>第二个值：将这些槽位分配给哪个节点，这里填写要分配给的节点ID。节点ID可通过查看集群状态信息来获得。（查看命令：<code> redis-cli -p 7001 cluster nodes</code>）<li>第三个值：从哪个节点抽取插槽来分配要分配的节点，这里以7001节点为例，填写7001节点ID即可。<li>第四个值：填写<code>done</code>，然后回车即可。</ul><p>等待插槽分配完毕后，通过如下命令查看集群状态：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>redis-cli -p 7001 cluster nodes</span><br></pre></table></figure><p>通过输出信息，发现7004节点中已经拥有了刚刚分配的插槽。<h3 id=3-7-2、缩容><a class=headerlink href=#3-7-2、缩容 title=3.7.2、缩容></a>3.7.2、缩容</h3><h4 id=3-7-2-1、迁移7004节点槽位到7001节点><a class=headerlink href=#3-7-2-1、迁移7004节点槽位到7001节点 title=3.7.2.1、迁移7004节点槽位到7001节点></a>3.7.2.1、迁移7004节点槽位到7001节点</h4><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>redis-cli --cluster reshard 192.168.2.23:7004</span><br></pre></table></figure><p>上述命令执行期间，需要输入五个值：<ul><li>How many slots do you want to move (from 1 to 16384)?<br>需要移动的槽位数量，这些槽位来自 节点7004。<li>What is the receiving node ID?<br>将移动的槽位分配给哪个节点，这里填写节点ID。比如分配给节点7001，那么就写节点7001的ID值。<li>Source node #1:<br>从哪个节点中移动槽位。比如填写节点7004的ID值，那么就表示从节点7004中移动槽位到其它节点。<li>Source node #2:<br>输入done即可。<li>Do you want to proceed with the proposed reshard plan (yes/no)?<br>输入yes即可。</ul><h4 id=3-7-2-2、删除7004节点><a class=headerlink href=#3-7-2-2、删除7004节点 title=3.7.2.2、删除7004节点></a>3.7.2.2、删除7004节点</h4><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>redis-cli --cluster del-node 192.168.2.23:7004 7004节点的ID号</span><br></pre></table></figure><p>删除7004节点后，通过如下命令查看集群状态：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>redis-cli -p 7001 cluster nodes</span><br></pre></table></figure><p>通过输出信息，发现7004节点已经不在集群，证明删除成功。<h2 id=3-8、故障转移><a class=headerlink href=#3-8、故障转移 title=3.8、故障转移></a>3.8、故障转移</h2><h3 id=3-8-1、场景描述><a class=headerlink href=#3-8-1、场景描述 title=3.8.1、场景描述></a>3.8.1、场景描述</h3><p>假如 master节点6381机器 宕机，那么跟随其的 slave节点6386 是否会升级为master节点呢？下面一一验证。<h3 id=3-8-2、模拟宕机><a class=headerlink href=#3-8-2、模拟宕机 title=3.8.2、模拟宕机></a>3.8.2、模拟宕机</h3><p>这里通过 关闭master节点6381 来模拟真实的宕机。<h3 id=3-8-3、节点升级><a class=headerlink href=#3-8-3、节点升级 title=3.8.3、节点升级></a>3.8.3、节点升级</h3><p>master节点6381 宕机后，跟随其的slave节点8386会升级为master节点。这个升级过程是自动完成的。<h3 id=3-8-4、宕机恢复><a class=headerlink href=#3-8-4、宕机恢复 title=3.8.4、宕机恢复></a>3.8.4、宕机恢复</h3><p>master节点宕机后再次恢复时只会作为slave节点 跟随 master节点6386。<p>详情信息可通过 集群查看命令 来查看。<h2 id=3-9、SpringBoot集成><a class=headerlink href=#3-9、SpringBoot集成 title=3.9、SpringBoot集成></a>3.9、SpringBoot集成</h2><h3 id=3-9-1、配置><a class=headerlink href=#3-9-1、配置 title=3.9.1、配置></a>3.9.1、配置</h3><p>application.yml文件：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>redis:</span></span><br><span class=line>    <span class=attr>cluster:</span></span><br><span class=line>      <span class=attr>nodes:</span></span><br><span class=line>        <span class=bullet>-</span> <span class=number>192.168</span><span class=number>.2</span><span class=number>.4</span><span class=string>:7001</span></span><br><span class=line>        <span class=bullet>-</span> <span class=number>192.168</span><span class=number>.2</span><span class=number>.4</span><span class=string>:7002</span></span><br><span class=line>        <span class=bullet>-</span> <span class=number>192.168</span><span class=number>.2</span><span class=number>.4</span><span class=string>:7003</span></span><br><span class=line>        <span class=bullet>-</span> <span class=number>192.168</span><span class=number>.2</span><span class=number>.4</span><span class=string>:7004</span></span><br><span class=line>        <span class=bullet>-</span> <span class=number>192.168</span><span class=number>.2</span><span class=number>.4</span><span class=string>:7005</span></span><br><span class=line>        <span class=bullet>-</span> <span class=number>192.168</span><span class=number>.2</span><span class=number>.4</span><span class=string>:7006</span></span><br></pre></table></figure><p>配置类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> LettuceClientConfigurationBuilderCustomizer <span class="title function_">configurationBuilderCustomizer</span><span class=params>()</span>{</span><br><span class=line>    <span class=keyword>return</span> config -> config.readFrom(ReadFrom.REPLICA_PREFERRED);</span><br><span class=line>}</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Redis%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/ itemprop=url>Redis系列-Redis基础应用</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-07 09:24:05" datetime=2023-08-07T09:24:05+08:00 itemprop=dateModified>2023-08-07</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Redis/ itemprop=url rel=index><span itemprop=name>Redis</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、Redis概述><a class=headerlink href=#1、Redis概述 title=1、Redis概述></a>1、Redis概述</h1><h1 id=2、常用命令><a class=headerlink href=#2、常用命令 title=2、常用命令></a>2、常用命令</h1><h1 id=3、Redis的Java客户端><a class=headerlink href=#3、Redis的Java客户端 title=3、Redis的Java客户端></a>3、Redis的Java客户端</h1><h2 id=3-1、客户端对比><a class=headerlink href=#3-1、客户端对比 title=3.1、客户端对比></a>3.1、客户端对比</h2><p>Redis比较常用的Java客户端有如下几个：<ul><li><p><strong>Jedis</strong></p> <p>以Redis命令作为方法名称，学习成本低。Jedis实例线程不安全，多线程环境下需要使用线程池。</p><li><p><strong>Lettuce</strong></p> <p>基于Netty实现，支持同步、异步、响应式编程，且线程安全。支持哨兵模式、集群模式、管道模式。</p><li><p><strong>Redisson</strong></p> <p>基于Redis实现的分布式、可伸缩的Java数据结构集合。对多种数据结构进行了封装和优化。</p></ul><p>为了更方便的使用Redis的Java客户端，可以使用Spring提供的SpringDataRedis技术来实现操作Redis。SpringDataRedis底层既可以选择基于Jedis实现，也可以选择基于Lettuce来实现，扩展性较强，要注意的是默认基于Lettuce来实现。<p>SpringDataRedis有如下特点：<ul><li>支持 Redis 发布订阅、哨兵、集群等。<li>支持基于 Lettuce 的响应式编程。<li>支持常见对象的序列号和反序列化。<li>支持基于 Redis 的 JDKCollection 实现。</ul><h2 id=3-2、SpringDataRedis><a class=headerlink href=#3-2、SpringDataRedis title=3.2、SpringDataRedis></a>3.2、SpringDataRedis</h2><h3 id=3-2-1、注意事项><a class=headerlink href=#3-2-1、注意事项 title=3.2.1、注意事项></a>3.2.1、注意事项</h3><p><strong>SpringDataRedis默认的键、值序列化策略是JDK序列化，基于该序列化方式来存储的键、值，存在可读性差、内存占用大等问题。为了避免该问题，建议使用其它序列化策略，比如 SpringDataRedis 依赖包自带的<code>GenericJackson2JsonRedisSerializer</code>。</strong></div><footer class=post-footer><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" aria-label=上一页 href=/page/4/ rel=prev title=上一页><i class="fa fa-angle-left"></i></a><a class=page-number href=/>1</a><span class=space>…</span><a class=page-number href=/page/4/>4</a><span class="page-number current">5</span><a class=page-number href=/page/6/>6</a><span class=space>…</span><a class=page-number href=/page/12/>12</a><a class="extend next" aria-label=下一页 href=/page/6/ rel=next title=下一页><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script>