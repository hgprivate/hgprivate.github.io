<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hshz21.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content=豪哥博客 name=description><meta content=website property=og:type><meta content=豪哥博客 property=og:title><meta content=https://hshz21.gitee.io/page/2/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content=豪哥博客 property=og:description><meta content=zh_CN property=og:locale><meta content=豪哥 property=article:author><meta content=HG property=article:tag><meta content=summary name=twitter:card><link href=https://hshz21.gitee.io/page/2/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script><script class=next-config data-name=calendar type=application/json>""</script><title>豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <h1 class=site-title>豪哥博客</h1> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>109</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>33</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>126</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/%E6%A0%91%E5%9E%8B%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/%E6%A0%91%E5%9E%8B%E7%BB%93%E6%9E%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=url>数据与算法系列-树结构</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:15" datetime=2024-08-21T21:39:15+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-06 09:36:43" datetime=2023-10-06T09:36:43+08:00 itemprop=dateModified>2023-10-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%AE%97%E6%B3%95/ itemprop=url rel=index><span itemprop=name>数据与算法</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、二叉排序树><a class=headerlink href=#1、二叉排序树 title=1、二叉排序树></a>1、二叉排序树</h1><h2 id=1-1、简介><a class=headerlink href=#1-1、简介 title=1.1、简介></a>1.1、简介</h2><p><strong>二叉排序树又称二叉查找树、二叉搜索树</strong>。是数据结构的一种。通常情况下，查询效率比链表要高。<h2 id=1-2、定义><a class=headerlink href=#1-2、定义 title=1.2、定义></a>1.2、定义</h2><p>空树，或拥有如下特点的二叉树：<ol><li>左子树上所有节点的值 均小于 根节点的值；<li>右子树上所有节点的值 均大于 根节点的值；<li>左、右子树也分别为二叉排序树；<li>没有键值相等的节点。</ol><h2 id=1-3、插入删除><a class=headerlink href=#1-3、插入删除 title=1.3、插入删除></a>1.3、插入删除</h2><p>与次优二叉树相对，二叉排序树是一种动态树表。特点是：树结构通常并非是一次生成，而是在查找过程中，当树中不存在关键字等于给定值的节点时再进行插入。新插入的节点一定是一个新添加的叶子节点，并且是查找不成功时查找路径上访问的最后一个节点的左孩子或右孩子节点。<h2 id=1-4、性能分析><a class=headerlink href=#1-4、性能分析 title=1.4、性能分析></a>1.4、性能分析</h2><p>每个节点的C(i) 就是 该节点的层次数。最坏情况下，当插入的关键字有序时，会形成单支树，树深为平均查找长度(n+1)/2（和顺序查找相同），最好情况就是 与折半查找相同，平均查找长度和log2(n)成正比。<p>**最好情况下时间复杂度为O(1)，最坏情况下时间复杂度为O(n)**。<h2 id=1-5、优化><a class=headerlink href=#1-5、优化 title=1.5、优化></a>1.5、优化</h2><p>使用其它数据结构代替，查找树复杂度均为O(log(n))。<ol><li>Size Balanced Tree(SBT)<li>AVL树<li>红黑树<li>Treap</ol><h1 id=2、AVL树><a class=headerlink href=#2、AVL树 title=2、AVL树></a>2、AVL树</h1><h2 id=2-1、简介><a class=headerlink href=#2-1、简介 title=2.1、简介></a>2.1、简介</h2><p><strong>AVL树是一种高效的自平衡二叉搜索树，它的特点在于它可以自动保持平衡</strong>。<blockquote><p>windows对进程地址空间的管理用到了 AVL树。</blockquote><h2 id=2-2、特点><a class=headerlink href=#2-2、特点 title=2.2、特点></a>2.2、特点</h2><p>AVL树本质上是二叉搜索树，其特点如下：<ol><li>是二叉搜索树。<li>带有平衡条件：每个节点的左右子树高度差绝对值（平衡因子）最大为1。</ol><h2 id=2-3、优缺点><a class=headerlink href=#2-3、优缺点 title=2.3、优缺点></a>2.3、优缺点</h2><h3 id=2-3-1、优点（严格平衡）><a class=headerlink href=#2-3-1、优点（严格平衡） title=2.3.1、优点（严格平衡）></a>2.3.1、优点（严格平衡）</h3><p><strong>AVL树是严格的平衡二叉树，所有节点的左右子树高度差不能超过1</strong>。<h3 id=2-3-2、缺点（旋转耗时）><a class=headerlink href=#2-3-2、缺点（旋转耗时） title=2.3.2、缺点（旋转耗时）></a>2.3.2、缺点（旋转耗时）</h3><p>AVL的平衡得益于旋转操作：插入和删除可能会破坏二叉树的平衡，此时需要旋转 。<p>插入操作最多需要1次旋转（单旋转或双旋转）；删除节点需要维护从被删节点到根节点路径上所有节点的平衡，旋转复杂度为O(log n)。<p>因旋转耗时，故删除数据效率很低；删除操作较多时，维护平衡所需的代价可能高于其带来的好处，因此AVL实际使用并不广泛。<h1 id=3、红黑树><a class=headerlink href=#3、红黑树 title=3、红黑树></a>3、红黑树</h1><h2 id=3-1、简介><a class=headerlink href=#3-1、简介 title=3.1、简介></a>3.1、简介</h2><p><strong>红黑树（Red Black Tree） 是一种自平衡二叉查找树，是一种常用的数据结构，主要用于实现关联数组</strong>。<p>红黑树是一种特化版AVL树，插入、删除时可通过变换节点颜色来保持树平衡，进而获得高性能。<p>红黑树虽复杂，但最坏情况下其表现也很好。<strong>可在 O(log n，n是树中元素的数量) 时间内实现查找、插入和删除</strong>。<h2 id=3-2、特征><a class=headerlink href=#3-2、特征 title=3.2、特征></a>3.2、特征</h2><ol><li>节点不是红色就是黑色。<li>根节点是黑色；所有叶子节点是NUll节点且是黑色；<li>红色节点的两个子节点是黑色；红色节点不能相邻。<li>从根节点到任意一个叶子节点，路径中的黑色节点数量都一样。</ol><h2 id=3-3、使用场景><a class=headerlink href=#3-3、使用场景 title=3.3、使用场景></a>3.3、使用场景</h2><p><strong>红黑树多用于内部排序，即全放在内存中，STL的 map 和 set 内部实现就是红黑树</strong>。<h2 id=3-4、应用><a class=headerlink href=#3-4、应用 title=3.4、应用></a>3.4、应用</h2><ol><li><p><strong>在Linux非实时任务调度中的应用</strong></p> <p>Linux 的稳定内核版本在 2.6.24 之后，使用了新的调度程序 CFS，所有非实时可运行进程都以虚拟运行时间为 key 值挂在一棵红黑树上，以完成更公平高效地调度所有任务。CFS 弃用 active /expired 数组和动态计算优先级，不再跟踪任务的睡眠时间和区别是否交互任务，并且在调度中采用基于时间计算键值的红黑树来选取下一个任务，根据所有任务占用 CPU 时间的状态来确定调度任务优先级。</p><li><p><strong>在Linux虚拟内存中的应用</strong></p> <p>32 位 Linux 内核虚拟地址空间划分 0 － 3G 为用户空间，3 － 4G 为内核空间，因此每个进程可以使用 4GB的虚拟空间。同时，Linux 定义了虚拟存储区域( VMA) 以便于更好表示进程所使用的虚拟空间，每个 VMA是某个进程的一段连续虚拟空间，其中的单元具有相同的特征，所有的虚拟区域按照地址排序由指针链接为一个链表。当发生缺页中断时搜索 VMA 到指定区域时，则需要频繁操作，因此选用了红黑树以减少查找时间。</p><li><p><strong>在检测树平衡性上的应用</strong></p> <p>红黑树是一种自平衡二叉搜索树，它的每个节点都被“着色”为红色或者黑色，这些节点的颜色被用来检测树的平衡性。红黑树作为嵌入式数据库中的索引机制，可以获得更好的性能，对于SQLite数据库，可以采用红黑树实现索引机制的优化。</p></ol><h2 id=3-5、数据结构><a class=headerlink href=#3-5、数据结构 title=3.5、数据结构></a>3.5、数据结构</h2><p>红黑树 统计性能 要优于平衡二叉树。目前，红黑树已广泛应用于Linux 进程管理、内存管理，设备驱动、虚拟内存跟踪等场景。<h2 id=3-6、优缺点><a class=headerlink href=#3-6、优缺点 title=3.6、优缺点></a>3.6、优缺点</h2><h3 id=3-6-1、优点><a class=headerlink href=#3-6-1、优点 title=3.6.1、优点></a>3.6.1、优点</h3><ol><li><strong>红黑树不追求严格平衡：只需保证根到叶子的最长路径长度不超过最短路径的2倍</strong>。<li><strong>红黑树删除效率较高</strong>，因O(1)次数的旋转及变色就能保证基本平衡，无需像AVL树一样进行O(lgn)次的旋转。<li><strong>红黑树适用于内存操作场景。其统计性能高于AVL树</strong>。</ol><h3 id=3-6-2、缺点（树太高）><a class=headerlink href=#3-6-2、缺点（树太高） title=3.6.2、缺点（树太高）></a>3.6.2、缺点（树太高）</h3><ol><li><p>较AVL数来说，红黑树查询效率差，因为树平衡性较差，高度更高。</p><li><p>对于磁盘等辅助存储设备中数据的操作来说（如 MySQL），红黑树并不擅长，因为红黑树高度太高。</p> <blockquote><p>当数据在磁盘中时，磁盘IO会成为最大性能瓶颈；树高度越高，IO次数也会越多，性能影响也会越严重。</blockquote></ol><h1 id=4、B树><a class=headerlink href=#4、B树 title=4、B树></a>4、B树</h1><h2 id=4-1、简介><a class=headerlink href=#4-1、简介 title=4.1、简介></a>4.1、简介</h2><p>B-树 查找关键字 方法是：先拿到 根节点 ，在根节点 所包含的关键字K1,…,Kn中 查找给定关键字（可用顺序查找或二分查找法）。若找到关键字就表示查找成功；否则，一定可以确定要查找的关键字在Ki与Ki+1之间，拿到 指针Pi 指向的节点 继续查找，直至找到，指针Pi为空时查找失败。（Pi为指向子树根节点的指针）<h2 id=4-2、定义><a class=headerlink href=#4-2、定义 title=4.2、定义></a>4.2、定义</h2><p><strong>1970年，R.Bayer和E.mccreight提出了一种平衡多叉树，称为B树（或B-树、B_树）</strong>。<p>一棵 m 阶 B树 是一棵平衡的m路搜索树。它可能是空树，也可能是如下特点的树：<ol><li>根节点至少有两个子女；<li>每个 非根节点 所包含的关键字个数 j 满足：┌m/2┐ - 1 <= j <= m - 1；<li>除根节点以外的所有节点（不包括叶子节点）的度数正好是关键字总数加1，故内部子树个数 k 满足：┌m/2┐ <= k <= m ；<li>所有叶子节点都位于同一层。</ol><p>B-树每个节点中的关键字从小到大排列，且当该节点的孩子是非叶子节点时，该k-1个关键字正好是k个孩子包含的关键字的值域的分划。<p>因为叶子节点不包含关键字，所以可以把叶子节点看成在树里实际上并不存在外部节点，指向这些外部节点的指针为空，叶子节点的数目正好等于树中所包含的关键字总个数加1。<p>B-树中的一个包含n个关键字，n+1个指针的节点的一般形式为：（n、P0、K1、P1、K2、P2,…,Kn、Pn）。<p>其中，Ki为关键字，K1&LTK2<…&LTKn, Pi 是指向包括Ki到Ki+1之间的关键字的子树的指针。<h2 id=4-3、性能分析><a class=headerlink href=#4-3、性能分析 title=4.3、性能分析></a>4.3、性能分析</h2><p>设B-树包含N个关键字，因此有N+1个叶子节点，叶子都在第I层。因为根至少有两个孩子，因此第二层至少有两个节点。除根和叶子外，其它节点至少有┌m/2┐个孩子，因此在第三层至少有2<em>┌m/2┐个节点，在第四层至少有2</em>(┌m/2┐^2)个节点，．．．，在第I层至少有2*(┌m/2┐^(l-2) )个节点，于是有：<p>N+1 ≥ 2*┌m/2┐I-2<p>考虑第L层的节点个数为N+1，那么2*(┌m/2┐^(l-2)）≤N+1，也就是L层的最少节点数刚好达到N+1个。<p>即： I≤ log┌m/2┐((N+1)/2 )+2<p>所以，当B-树包含N个关键字时，B-树最大高度为l-1（因为计算B-树高度时，叶节点所在层不计算在内）。<p>即：log┌m/2┐((N+1)/2 )+1。<p>这个公式保证了B-树 较高 的查询率。<h2 id=4-4、优缺点><a class=headerlink href=#4-4、优缺点 title=4.4、优缺点></a>4.4、优缺点</h2><h3 id=4-4-1、优点><a class=headerlink href=#4-4-1、优点 title=4.4.1、优点></a>4.4.1、优点</h3><ol><li><strong>B树适用于磁盘等辅存设备</strong>，B树每个非叶节点可以有多个子树，降低了树的高度。<li><strong>B树提供了局部性访问</strong>。换句话说，B树缓存命中率更高。（局部性原理是指：一个数据被使用时其附近数据有较大概率在短时间内被使用。B树会将相邻数据存储在同一节点，当访问其中某个数据时会将整个节点读到缓存中；当相邻数据被访问时，可直接从缓存中读取，无需执行磁盘IO；）</ol><h3 id=4-4-2、缺点><a class=headerlink href=#4-4-2、缺点 title=4.4.2、缺点></a>4.4.2、缺点</h3><ol><li>仅适用于 磁盘存储操作 场景。<li>B树 叶子和非叶子节点 都存储数据，所以树高度还是会太高。<li>B树 叶子节点 没有指针连接，且叶子节点中的元素是无序排列。<li>不适合范围查询。</ol><h1 id=5、B-树><a class=headerlink href=#5、B-树 title=5、B+树></a>5、B+树</h1><h2 id=5-1、简介><a class=headerlink href=#5-1、简介 title=5.1、简介></a>5.1、简介</h2><p><strong>B+树通常用于数据库和操作系统的文件系统</strong>。<p>B+树 能够保持 数据稳定有序，插入、修改 拥有 稳定的 时间复杂度。B+树元素自底向上插入，这与二叉树恰好相反。<blockquote><p>B+ 树创造者 Rudolf Bayer 没有解释 B 代表什么。通常 B 代表平衡（balanced），因为所有叶子节点都在树的统一级别上。<em>B</em>也可能代表<em>Bayer</em>，或者是波音（Boeing），因为他曾经工作于波音科学研究实验室。</blockquote><p><strong>B+树适用于磁盘文件组织、数据索引和数据库索引</strong>。<h2 id=5-2、定义><a class=headerlink href=#5-2、定义 title=5.2、定义></a>5.2、定义</h2><p><strong>B+树叶子节点存储页号、行记录，非叶子节点作为索引使用</strong>。一棵m阶的B+树定义如下:<ol><li>每个节点至多有m个子女；<li>除根节点外，每个节点至少有[m/2]个子女，根节点至少有两个子女；<li>有k个子女的节点必有k个关键字。</ol><p>与B树的查找操作不同，B+树在 索引关键字与待找关键字匹配时并不停止查找，而会 沿着该关键字左边指针向下，一直找到该关键字所在的叶子节点为止。<h2 id=5-3、特征><a class=headerlink href=#5-3、特征 title=5.3、特征></a>5.3、特征</h2><p>B+树是B树的一种变形，比B树具有更广泛的应用，m阶 B+树 有如下特征:<ol><li>每个节点的关键字个数与孩子个数相等，所有非最下层的内层节点的关键字是对应子树上的最大关键字，最下层内部节点包含了全部关键字。 [3]<li>除根节点以外，每个内部节点有<img alt=img src=https://bkimg.cdn.bcebos.com/formula/b6d57d975fb784adc5203ddf01a692ee.svg>到m个孩子。<li>所有叶节点在树结构的同一层，并且不含任何信息(可看成是外部节点或查找失败的节点)，因此，树结构总是树高平衡的。</ol><h2 id=5-4、算法><a class=headerlink href=#5-4、算法 title=5.4、算法></a>5.4、算法</h2><h3 id=5-4-1、查找><a class=headerlink href=#5-4-1、查找 title=5.4.1、查找></a>5.4.1、查找</h3><p>查找以典型的方式进行，类似于二叉查找树。起始于根节点，自顶向下遍历树，选择其分离值在要查找值的任意一边的子指针。在节点内部典型的使用是二分查找来确定这个位置。<h3 id=5-4-2、插入><a class=headerlink href=#5-4-2、插入 title=5.4.2、插入></a>5.4.2、插入</h3><p>节点要处于违规状态，它必须包含在可接受范围之外数目的元素。<ol><li>首先，查找要插入其中的节点的位置。接着把值插入这个节点中。<li>如果没有节点处于违规状态则处理结束。<li>如果某个节点有过多元素，则把它分裂为两个节点，每个都有最小数目的元素。在树上递归向上继续这个处理直到到达根节点，如果根节点被分裂，则创建一个新根节点。为了使它工作，元素的最小和最大数目典型的必须选择为使最小数不小于最大数的一半。</ol><h3 id=5-4-3、删除><a class=headerlink href=#5-4-3、删除 title=5.4.3、删除></a>5.4.3、删除</h3><ol><li><p>首先，查找要删除的值。接着从包含它的节点中删除这个值。</p><li><p>如果没有节点处于违规状态则处理结束。</p><li><p>如果节点处于违规状态则有两种可能情况：</p> <ol><li>它的兄弟节点，就是同一个父节点的子节点，可以把一个或多个它的子节点转移到当前节点，而把它返回为合法状态。如果是这样，在更改父节点和两个兄弟节点的分离值之后处理结束。<li>它的兄弟节点由于处在低边界上而没有额外的子节点。在这种情况下把两个兄弟节点合并到一个单一的节点中，而且我们递归到父节点上，因为它被删除了一个子节点。持续这个处理直到当前节点是合法状态或者到达根节点，在其上根节点的子节点被合并而且合并后的节点成为新的根节点。</ol></ol><h2 id=5-5、优缺点><a class=headerlink href=#5-5、优缺点 title=5.5、优缺点></a>5.5、优缺点</h2><h3 id=5-5-1、优点><a class=headerlink href=#5-5-1、优点 title=5.5.1、优点></a>5.5.1、优点</h3><ol><li>B+树只会在叶子节点存储键值和数据，非叶子节点只存储键值和指针，而B树叶子和非叶子节点都会存储。<li>B+树叶子节点通过指针连接在一起且有序，而B树没有这个特性。<li>IO次数更少。<li>适合范围查询。<li>查询效率稳定。</ol><h3 id=5-5-2、缺点><a class=headerlink href=#5-5-2、缺点 title=5.5.2、缺点></a>5.5.2、缺点</h3><ol><li><font color=red>由于键会重复出现，因此会占用更多空间。</font>但是与带来的性能优势相比，空间劣势往往可以接受，因此B+树在数据库中的使用 较B树 更广泛。</ol><h2 id=5-6、使用场景><a class=headerlink href=#5-6、使用场景 title=5.6、使用场景></a>5.6、使用场景</h2><p>B+树多用于磁盘存储等场景。<h2 id=5-7、B树-VS-B-树><a title="5.7、B树 VS B+树" class=headerlink href=#5-7、B树-VS-B-树></a>5.7、B树 VS B+树</h2><p>B+树是应文件系统所需而产生的一种B树的变形树。m阶B+树 和 m阶B树 的区别是：<ol><li>有n棵子树的节点中含有n个关键码；<li>所有的叶子节点中包含了全部关键码的信息，及指向含有这些关键码记录的指针，且叶子节点本身依关键码的大小自小而大的顺序链接；<li>所有的非终端节点可以看成是索引部分，节点中仅含有其子树根节点中最大(或最小)关键码。</ol><h2 id=5-8、知识点扩展><a class=headerlink href=#5-8、知识点扩展 title=5.8、知识点扩展></a>5.8、知识点扩展</h2><p>MySQL中的表在被插入数据时，建议主键值是递增的，其目的是为了避免B+树节点的频繁分裂进而降低整体的性能。<h1 id=6、Trie树（字典树）><a class=headerlink href=#6、Trie树（字典树） title=6、Trie树（字典树）></a>6、Trie树（字典树）</h1><h2 id=6-1、简介><a class=headerlink href=#6-1、简介 title=6.1、简介></a>6.1、简介</h2><p>Trie树 又称 单词查找树，Trie树是一种树形结构，是一种 变种哈希树。通常用于统计、排序、保存大量字符串（但不仅限于字符串），所以经常被搜索引擎用于文本词频统计。优点是：<strong>利用字符串的公共前缀来减少查询时间，最大限度地减少字符串比较，查询效率比哈希树高</strong>。<h2 id=6-2、性质><a class=headerlink href=#6-2、性质 title=6.2、性质></a>6.2、性质</h2><ol><li>根节点不包含字符，其它节点都只包含一个字符；<li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；<li>每个节点的所有子节点包含的字符都不相同。</ol><h2 id=6-3、基本操作><a class=headerlink href=#6-3、基本操作 title=6.3、基本操作></a>6.3、基本操作</h2><p>基本操作：查找、插入和删除，当然删除操作比较少见。<h2 id=6-4、实现方法><a class=headerlink href=#6-4、实现方法 title=6.4、实现方法></a>6.4、实现方法</h2><p>搜索字典项目的方法为：<ol><li>从根节点开始一次搜索；<li>取得要查找关键词的第一个字母，并根据该字母选择对应的子树并转到该子树继续进行检索；<li>在相应的子树上，取得要查找关键词的第二个字母,并进一步选择对应的子树进行检索。<li>迭代过程……<li>在某个节点处，关键词的所有字母已被取出，则读取附在该节点上的信息，即完成查找。</ol><p>其他操作类似处理。<h1 id=7、总结><a class=headerlink href=#7、总结 title=7、总结></a>7、总结</h1><h2 id=7-1、二叉查找树-BST><a class=headerlink href=#7-1、二叉查找树-BST title=7.1、二叉查找树(BST)></a>7.1、二叉查找树(BST)</h2><p>解决了排序的基本问题，但可能退化为链表；<h2 id=7-2、平衡二叉树-AVL><a class=headerlink href=#7-2、平衡二叉树-AVL title=7.2、平衡二叉树(AVL)></a>7.2、平衡二叉树(AVL)</h2><p>通过旋转可解决平衡问题，但旋转频率较高且效率太低；<h2 id=7-3、红黑树><a class=headerlink href=#7-3、红黑树 title=7.3、红黑树></a>7.3、红黑树</h2><p>解决了AVL旋转效率过低的问题，但红黑树在磁盘IO场景下，树仍然太高，IO次数太多；<h2 id=7-4、B树><a class=headerlink href=#7-4、B树 title=7.4、B树></a>7.4、B树</h2><p>将二叉树改为多路平衡查找树，解决了树过高问题；<h2 id=7-5、B-树><a class=headerlink href=#7-5、B-树 title=7.5、B+树></a>7.5、B+树</h2><p>在B树基础上将非叶子节点改造为索引节点，增加了节点的分支数量，进一步降低了树高；叶子节点使用指针连接成双向链表，范围查询更加高效。<h1 id=X、知识拓展><a class=headerlink href=#X、知识拓展 title=X、知识拓展></a>X、知识拓展</h1><h2 id=X-1、为什么MySQL索引使用B-树而不使用红黑树><a class=headerlink href=#X-1、为什么MySQL索引使用B-树而不使用红黑树 title=X.1、为什么MySQL索引使用B+树而不使用红黑树?></a>X.1、为什么MySQL索引使用B+树而不使用红黑树?</h2><p>B+树适用于文件存储IO。<p>数据库文件通常位于磁盘中，定位一行信息需要查找该文件所在柱面号，磁盘号，扇区号，页号等。一次请求要做一次IO，因此减少IO次数是提高性能的关键。<p>IO次数与索引树的高度有关，树越低查询次数越少。相同节点个数（个数为n）环境下，红黑树高度最高为<code>2log(n+1)</code>，B+树高度最高为<code>(log(n+1)/2)+1</code>，随着 n 增大B+树高度会更小，IO次数会更少。</div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=url>Java系列-设计模式</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-05 16:13:04" datetime=2023-10-05T16:13:04+08:00 itemprop=dateModified>2023-10-05</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ itemprop=url rel=index><span itemprop=name>设计模式</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=0、前言><a class=headerlink href=#0、前言 title=0、前言></a>0、前言</h1><h2 id=0-1、软件设计基本原则><a class=headerlink href=#0-1、软件设计基本原则 title=0.1、软件设计基本原则></a>0.1、软件设计基本原则</h2><ol><li>高内聚，低耦合；<li>面向抽象编程；<li>多用组合少用继承；<li>遵循开闭原则；</ol><h2 id=0-2、设计模式引入><a class=headerlink href=#0-2、设计模式引入 title=0.2、设计模式引入></a>0.2、设计模式引入</h2><p>设计模式是计算机软件领域较抽象的东西，设计模式的作用：使 软件系统 变得 更加稳定、更易扩展、更易维护。<h2 id=0-3、设计模式简介><a class=headerlink href=#0-3、设计模式简介 title=0.3、设计模式简介></a>0.3、设计模式简介</h2><p><strong>设计模式不分语言，共23种，分3种类型：创建型、行为型、结构型</strong>。<h1 id=1、设计模式><a class=headerlink href=#1、设计模式 title=1、设计模式></a>1、设计模式</h1><h2 id=1-1、创建型（5种）><a class=headerlink href=#1-1、创建型（5种） title=1.1、创建型（5种）></a>1.1、创建型（5种）</h2><h3 id=1-1-1、Singleton（单例模式）><a class=headerlink href=#1-1-1、Singleton（单例模式） title=1.1.1、Singleton（单例模式）></a>1.1.1、Singleton（单例模式）</h3><h4 id=简介><a class=headerlink href=#简介 title=简介></a>简介</h4><p><strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。常见单例模式实现有：饿汉式、懒汉式、枚举式等</strong>。<h4 id=实现><a class=headerlink href=#实现 title=实现></a>实现</h4><ol><li>构造方法设为私有，禁止它人创建对象。</ol><h4 id=何时使用><a class=headerlink href=#何时使用 title=何时使用></a>何时使用</h4><p>当您想控制实例数目，节省系统资源的时候。<h4 id=优缺点><a class=headerlink href=#优缺点 title=优缺点></a>优缺点</h4><ul><li><p>优点：</p> <ol><li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。<li>避免对资源的多重占用（比如写文件操作）。</ol><li><p>缺点：</p> <p>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p></ul><h4 id=应用实例><a class=headerlink href=#应用实例 title=应用实例></a>应用实例</h4><ol><li>一个班级只有一个班主任。<li>Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。<li>一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</ol><h4 id=使用场景><a class=headerlink href=#使用场景 title=使用场景></a>使用场景</h4><ol><li>要求生产唯一序列号。<li>WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。<li>创建一个对象消耗资源过多时可通过单例降低多次创建带来的消耗，比如 I/O 与数据库的连接等。</ol><h4 id=注意事项><a class=headerlink href=#注意事项 title=注意事项></a>注意事项</h4><ol><li><font color=red>注意序列化对单例的破坏；</font><li><font color=red>注意反射对单例的破坏；</font></ol><h4 id=代码实例><a class=headerlink href=#代码实例 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br><span class=line>105</span><br><span class=line>106</span><br><span class=line>107</span><br><span class=line>108</span><br><span class=line>109</span><br><span class=line>110</span><br><span class=line>111</span><br><span class=line>112</span><br><span class=line>113</span><br><span class=line>114</span><br><span class=line>115</span><br></pre><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 实例一：基于双重校验锁方式实现单例</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * - 优点：懒加载，效率较好。</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * - 缺点：反序列化会对单例造成破坏</span></span><br><span class=line><span class=comment> *   应对方案：要想防止序列化对单例的破坏，只要添加readResolve方法就可避免。</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Singleton</span> <span class=keyword>implements</span> <span class="title class_">Serializable</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>volatile</span> <span class=keyword>static</span> Singleton singleton;</span><br><span class=line>    <span class=keyword>private</span> <span class="title function_">Singleton</span> <span class=params>()</span>{}</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> Singleton <span class="title function_">getSingleton</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>if</span> (singleton == <span class=literal>null</span>) {</span><br><span class=line>            <span class=keyword>synchronized</span> (Singleton.class) {</span><br><span class=line>                <span class=keyword>if</span> (singleton == <span class=literal>null</span>) {</span><br><span class=line>                    singleton = <span class=keyword>new</span> <span class="title class_">Singleton</span>();</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> singleton;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>private</span> Object <span class="title function_">readResolve</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> singleton;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 实例二：基于 CAS 实现单例</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * - 优点：</span></span><br><span class=line><span class=comment> *   - 不需要使用传统的锁机制来保证线程安全；</span></span><br><span class=line><span class=comment> *   - 相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度；</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * - 缺点：</span></span><br><span class=line><span class=comment> *   - 如果等待一直执行不成功(一直在死循环中)，会对CPU造成较大的执行开销；</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SingletonByCAS</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>final</span> AtomicReference&LTSingletonByCAS> INSTANCE = <span class=keyword>new</span> <span class="title class_">AtomicReference</span>&LTSingletonByCAS>();</span><br><span class=line>    <span class=keyword>private</span> <span class="title function_">SingletonByCAS</span><span class=params>()</span>{}</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> SingletonByCAS <span class="title function_">getInstance</span><span class=params>()</span>{</span><br><span class=line>        <span class=keyword>for</span> (;;){</span><br><span class=line>            <span class=type>SingletonByCAS</span> <span class=variable>single</span> <span class=operator>=</span> INSTANCE.get();</span><br><span class=line>            <span class=keyword>if</span> (<span class=literal>null</span> != single){</span><br><span class=line>                <span class=keyword>return</span> single;</span><br><span class=line>            }</span><br><span class=line>            single = <span class=keyword>new</span> <span class="title class_">SingletonByCAS</span>();</span><br><span class=line>            <span class=keyword>if</span> (INSTANCE.compareAndSet(<span class=literal>null</span>, single)){</span><br><span class=line>                <span class=keyword>return</span> single;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 实例三：基于 枚举 实现单例</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>enum</span> <span class="title class_">SingletonByEnum</span> {</span><br><span class=line>    INSTANCE;</span><br><span class=line>    <span class=comment>// 其它方法</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 实例四：基于双重校验锁方式实现单例（优化版）</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * - 优点：懒加载，利用局部变量提高效率；</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * - 缺点：反序列化会对单例造成破坏</span></span><br><span class=line><span class=comment> *   应对方案：要想防止序列化对单例的破坏，只要添加readResolve方法就可避免。</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SingletonByLocalVariable</span> <span class=keyword>implements</span> <span class="title class_">Serializable</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>volatile</span> <span class=keyword>static</span> SingletonByLocalVariable singleton;</span><br><span class=line>    <span class=keyword>private</span> <span class="title function_">SingletonByLocalVariable</span><span class=params>()</span>{}</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> SingletonByLocalVariable <span class="title function_">getSingleton</span><span class=params>()</span> {</span><br><span class=line>        <span class=type>SingletonByLocalVariable</span> <span class=variable>tmp</span> <span class=operator>=</span> singleton;</span><br><span class=line>        <span class=keyword>if</span> (tmp == <span class=literal>null</span>) {</span><br><span class=line>            <span class=keyword>synchronized</span> (SingletonByLocalVariable.class) {</span><br><span class=line>                tmp = singleton;</span><br><span class=line>                <span class=keyword>if</span> (tmp == <span class=literal>null</span>) {</span><br><span class=line>                    tmp = <span class=keyword>new</span> <span class="title class_">SingletonByLocalVariable</span>();</span><br><span class=line>                    singleton = tmp;</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> singleton;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>private</span> Object <span class="title function_">readResolve</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> singleton;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 实例五：基于静态内部类实现单例</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * - 原理：利用了classloder的机制来保证初始化instance时只有一个线程。</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * - 优点：这是一种懒加载，就是说Singleton类被装载了，instance不一定被初始化。</span></span><br><span class=line><span class=comment> *        因为SingletonHolder类没有被主动使用，只有显式调用getInstance方法时，</span></span><br><span class=line><span class=comment> *        才会装载SingletonHolder类，从而实例化instance。</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SingletonByStaticInnerClass</span> {</span><br><span class=line>    <span class=comment>// 私有构造，禁止通过new创建对象。</span></span><br><span class=line>    <span class=keyword>private</span> <span class="title function_">SingletonByStaticInnerClass</span><span class=params>()</span>{</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">SingletonHholder</span>{</span><br><span class=line>        <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>final</span> <span class=type>SingletonByStaticInnerClass</span> <span class=variable>INSTANCE</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SingletonByStaticInnerClass</span>();</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>final</span> SingletonByStaticInnerClass <span class="title function_">getInstance</span><span class=params>()</span>{</span><br><span class=line>        <span class=keyword>return</span> SingletonHholder.INSTANCE;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-1-2、AbstractFactory（抽象工厂）><a class=headerlink href=#1-1-2、AbstractFactory（抽象工厂） title=1.1.2、AbstractFactory（抽象工厂）></a>1.1.2、AbstractFactory（抽象工厂）</h3><h4 id=定义><a class=headerlink href=#定义 title=定义></a>定义</h4><p><strong>任何可以生成对象的方法或类，都可以称之为工厂。单例也是一个工厂</strong>。主要解决接口选择问题。<h4 id=何时使用-1><a class=headerlink href=#何时使用-1 title=何时使用></a>何时使用</h4><p>系统产品有多于一个的产品族，而系统只消费其中某一族的产品。<h4 id=优缺点-1><a class=headerlink href=#优缺点-1 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>可以实现从工厂得到的产品彼此兼容。<li>可以避免具体产品和客户端代码之间的紧密耦合。<li>符合单一职责原则。<li>符合开闭原则。</ol><li>缺点<ol><li>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体实现中加代码。</ol></ul><h4 id=应用场景><a class=headerlink href=#应用场景 title=应用场景></a>应用场景</h4><ol><li>QQ 换皮肤，一整套一起换。<li>生成不同操作系统对应的程序。</ol><h4 id=应用实例-1><a class=headerlink href=#应用实例-1 title=应用实例></a>应用实例</h4><p>为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些都是成套的，即一系列具体产品。<p>假设一种情况，在您的家中，某一个衣柜（具体工厂）只能存放某一种衣服（成套，一系列具体产品），每次拿这种成套衣服时自然要从这个衣柜中取出。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。<h4 id=注意事项-1><a class=headerlink href=#注意事项-1 title=注意事项></a>注意事项</h4><p>产品族难扩展，产品等级易扩展。<h4 id=QA><a class=headerlink href=#QA title=QA></a>QA</h4><ol><li><p>为何还需要工厂?</p> <ol><li>灵活控制生产过程。<li>权限、修饰、日志等。</ol></ol><h4 id=代码实例-1><a class=headerlink href=#代码实例-1 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 抽象工厂模式</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * 抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供</span></span><br><span class=line><span class=comment> * 方便，但不能为新的产品等级结构的增加提供这样的方便。</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * 三种工厂模式之间的关系：</span></span><br><span class=line><span class=comment> *      当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存</span></span><br><span class=line><span class=comment> *      在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> *      抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是</span></span><br><span class=line><span class=comment> *      一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> *      当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创</span></span><br><span class=line><span class=comment> *      建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模</span></span><br><span class=line><span class=comment> *      式退化成简单工厂模式。</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * 总结：</span></span><br><span class=line><span class=comment> *      抽象工厂模式是所有工厂模式中最为抽象和最具一般性的一种形态。</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> *      抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知</span></span><br><span class=line><span class=comment> *      道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个</span></span><br><span class=line><span class=comment> *      对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方</span></span><br><span class=line><span class=comment> *      便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和</span></span><br><span class=line><span class=comment> *      所有具体工厂类，对“开闭原则”的支持呈现倾斜性。</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">App</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>CarFactory</span> <span class=variable>sportCarFactory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SportCarFactory</span>();</span><br><span class=line>        <span class=type>TeslaCar</span> <span class=variable>teslaCar</span> <span class=operator>=</span> sportCarFactory.getTeslaCar();</span><br><span class=line>        <span class=type>BenzCar</span> <span class=variable>benzCar</span> <span class=operator>=</span> sportCarFactory.getBenzCar();</span><br><span class=line>        teslaCar.charge();</span><br><span class=line>        benzCar.gasUp();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-1-3、FactoryMethod（工厂方法）><a class=headerlink href=#1-1-3、FactoryMethod（工厂方法） title=1.1.3、FactoryMethod（工厂方法）></a>1.1.3、FactoryMethod（工厂方法）</h3><h4 id=简介-1><a class=headerlink href=#简介-1 title=简介></a>简介</h4><p><strong>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟到了子类</strong>。<h4 id=何时使用-2><a class=headerlink href=#何时使用-2 title=何时使用></a>何时使用</h4><p>明确地计划不同条件下创建不同实例。<h4 id=优缺点-2><a class=headerlink href=#优缺点-2 title=优缺点></a>优缺点</h4><ul><li><p>优点</p> <ol><li>将具体产品和创建者解耦。<li>符合单一职责原则。<li>符合开闭原则。</ol><li><p>缺点</p> <p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</p></ul><h4 id=应用场景-1><a class=headerlink href=#应用场景-1 title=应用场景></a>应用场景</h4><ol><li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。<li>数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。<li>设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</ol><h4 id=应用实例-2><a class=headerlink href=#应用实例-2 title=应用实例></a>应用实例</h4><ol><li>您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是如何生产出来的。<li>Hibernate 换数据库只需换驱动就可以。</ol><h4 id=源码应用><a class=headerlink href=#源码应用 title=源码应用></a>源码应用</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>Calendar.getInstance();</span><br><span class=line>java.text.NumberFormat.getInstance();</span><br><span class=line>java.util.ResourceBundle.getBundle();</span><br><span class=line></span><br><span class=line>java.net.URLStreamHandlerFactory</span><br><span class=line>java.xml.bind.JAXBContext.createMarshaller</span><br></pre></table></figure><h4 id=注意事项-2><a class=headerlink href=#注意事项-2 title=注意事项></a>注意事项</h4><p><font color=red>在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意：复杂对象适合使用工厂模式，而简单对象不适合。</font><h4 id=代码实例-2><a class=headerlink href=#代码实例-2 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br></pre><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 计算器 - 工厂方法模式</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * 工厂方法模式优点：</span></span><br><span class=line><span class=comment> *    1、使用工厂来创建对象，隐藏了具体产品类将被实例化的细节。</span></span><br><span class=line><span class=comment> *    2、能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全</span></span><br><span class=line><span class=comment> *       封装在具体工厂内部。</span></span><br><span class=line><span class=comment> *    3、每种对象对应单独一个工厂，其目的主要为了解耦。</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * 工厂方法模式缺点：</span></span><br><span class=line><span class=comment> *    1、在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂</span></span><br><span class=line><span class=comment> *       类，系统中类的个数将成对增加，这增加了系统的复杂度。</span></span><br><span class=line><span class=comment> *    2、考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，</span></span><br><span class=line><span class=comment> *       增加了系统的抽象性和理解难度。且在实现时可能需要用到DOM、反射等技术，</span></span><br><span class=line><span class=comment> *       增加了系统的实现难度。</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">FactoryMethodApp</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>IFactory</span> <span class=variable>factory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AddFactory</span>();</span><br><span class=line>        <span class=type>Operation</span> <span class=variable>operationAdd</span> <span class=operator>=</span> factory.createOperation();</span><br><span class=line>        operationAdd.setVal1(<span class=number>15.2</span>);</span><br><span class=line>        operationAdd.setVal2(<span class=number>19.3</span>);</span><br><span class=line>        System.out.println(operationAdd.getResult());</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 计算器 - 简单工厂模式</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * 简单工厂模式优点:</span></span><br><span class=line><span class=comment> *    1、一个调用者想创建一个对象，只要知道其名称就行了。</span></span><br><span class=line><span class=comment> *    2、屏蔽产品的具体实现，调用者只关心产品的接口。</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * 简单工厂模式缺点：</span></span><br><span class=line><span class=comment> *    1、增加新算法时，需要编写一个新类并继承Operation。</span></span><br><span class=line><span class=comment> *    2、同时需要修改OperationFactory类的代码，这违反了“开闭原则”。</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SimpleFactoryApp</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>Operation</span> <span class=variable>operationAdd</span> <span class=operator>=</span> OperationFactory.create(<span class=string>"+"</span>);</span><br><span class=line>        operationAdd.setVal1(<span class=number>10</span>);</span><br><span class=line>        operationAdd.setVal2(<span class=number>5</span>);</span><br><span class=line>        System.out.println(operationAdd.getResult());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-1-4、Builder（建造者模式）><a class=headerlink href=#1-1-4、Builder（建造者模式） title=1.1.4、Builder（建造者模式）></a>1.1.4、Builder（建造者模式）</h3><h4 id=简介-2><a class=headerlink href=#简介-2 title=简介></a>简介</h4><p><strong>将一个复杂对象的创建与它的表示分离，使得同样的构建过程可以创建不同的表示</strong>。<h4 id=何时使用-3><a class=headerlink href=#何时使用-3 title=何时使用></a>何时使用</h4><p>一些基本部件不会变，而其组合经常变化的时候。<h4 id=优缺点-3><a class=headerlink href=#优缺点-3 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>建造者独立，易扩展。<li>便于控制细节风险。</ol><li>缺点<ol><li>产品必须有共同点，范围有限制。<li>内部变化复杂，有很多建造类。</ol></ul><h4 id=应用场景-2><a class=headerlink href=#应用场景-2 title=应用场景></a>应用场景</h4><ol><li>需要生成的对象具有复杂的内部结构。<li>需要生成的对象内部属性本身相互依赖。<li>与不可变对象配合使用。</ol><h4 id=应用实例-3><a class=headerlink href=#应用实例-3 title=应用实例></a>应用实例</h4><ol><li>去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的 “套餐”。<li>JAVA 中的 StringBuilder。</ol><h4 id=源码应用-1><a class=headerlink href=#源码应用-1 title=源码应用></a>源码应用</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>org.springframework.web.service.mvc.method.RequestMappingInfo</span><br><span class=line>org.springframework.benas.factory.support.BeanDefinitionBuilder</span><br></pre></table></figure><h4 id=注意事项-3><a class=headerlink href=#注意事项-3 title=注意事项></a>注意事项</h4><p><font color=red>与工厂模式的区别：建造者模式更加关注零件装配的顺序。</font><h4 id=代码实例-3><a class=headerlink href=#代码实例-3 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br><span class=line>105</span><br><span class=line>106</span><br><span class=line>107</span><br><span class=line>108</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Role</span> {</span><br><span class=line>    <span class=keyword>private</span> String head; <span class=comment>//头部</span></span><br><span class=line>    <span class=keyword>private</span> String face; <span class=comment>//脸部（脸部依赖于头部）</span></span><br><span class=line>    <span class=keyword>private</span> String body; <span class=comment>//身体</span></span><br><span class=line>    <span class=keyword>private</span> Double hp;   <span class=comment>//生命值</span></span><br><span class=line>    <span class=keyword>private</span> Double sp;   <span class=comment>//能量值</span></span><br><span class=line>    <span class=keyword>private</span> Double mp;   <span class=comment>//魔法值</span></span><br><span class=line>    </span><br><span class=line>    <span class=comment>// get/set/toString methods ...</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">Builder</span> {</span><br><span class=line>    <span class=keyword>protected</span> <span class=type>Role</span> <span class=variable>role</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Role</span>();</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">buildHead</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">buildFace</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">buildBody</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">buildHp</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">buildSp</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">buildMp</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> Role <span class="title function_">getResult</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> role;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CommonRoleBuilder</span> <span class=keyword>extends</span> <span class="title class_">Builder</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>Role</span> <span class=variable>role</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Role</span>();</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">buildHead</span><span class=params>()</span> {</span><br><span class=line>        role.setHead(<span class=string>"common head"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">buildFace</span><span class=params>()</span> {</span><br><span class=line>        role.setFace(<span class=string>"common face"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">buildBody</span><span class=params>()</span> {</span><br><span class=line>        role.setBody(<span class=string>"common body"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">buildHp</span><span class=params>()</span> {</span><br><span class=line>        role.setHp(<span class=number>100d</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">buildSp</span><span class=params>()</span> {</span><br><span class=line>        role.setSp(<span class=number>100d</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">buildMp</span><span class=params>()</span> {</span><br><span class=line>        role.setMp(<span class=number>100d</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Role <span class="title function_">getResult</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> role;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Director</span> {</span><br><span class=line>    <span class=keyword>public</span> Role <span class="title function_">constructAndGet</span><span class=params>(Builder builder)</span>{</span><br><span class=line>        builder.buildBody();</span><br><span class=line>        builder.buildHead();</span><br><span class=line>        builder.buildFace();</span><br><span class=line>        builder.buildHp();</span><br><span class=line>        builder.buildMp();</span><br><span class=line>        builder.buildSp();</span><br><span class=line>        <span class=keyword>return</span> builder.getResult();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 建造者模式</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * 定义：</span></span><br><span class=line><span class=comment> *      建造者模式（英：Builder Pattern）是一种创建型设计模式，又名：</span></span><br><span class=line><span class=comment> *      生成器模式。GOF 给建造者模式的定义为：将一个复杂对象的构建与</span></span><br><span class=line><span class=comment> *      它的表示分离，使得同样的构建过程可以创建不同的表示。这句话说的</span></span><br><span class=line><span class=comment> *      比较抽象，其实解释一下就是：将建造复杂对象的过程和组成对象的部</span></span><br><span class=line><span class=comment> *      件解耦。</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * 建造者模式包含如下角色：</span></span><br><span class=line><span class=comment> *      Builder：抽象建造者</span></span><br><span class=line><span class=comment> *      ConcreteBuilder：具体建造者</span></span><br><span class=line><span class=comment> *      Director：指挥者</span></span><br><span class=line><span class=comment> *      Product：产品角色</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * 优缺点：</span></span><br><span class=line><span class=comment> *      -优点：较好封装性、客户端无需知道产品内部组成的细节、</span></span><br><span class=line><span class=comment> *            可以更精细控制产品的创建过程、容易扩展。</span></span><br><span class=line><span class=comment> *      -缺点：不适合产品间差异大的场景、使用范围受到影响、</span></span><br><span class=line><span class=comment> *             产品内部变化大，可能需要定义很多具体建造者</span></span><br><span class=line><span class=comment> *             来适应，这可能导致系统很庞大。</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * 适用场景：</span></span><br><span class=line><span class=comment> *      1、需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个</span></span><br><span class=line><span class=comment> *         成员属性。</span></span><br><span class=line><span class=comment> *      2、需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</span></span><br><span class=line><span class=comment> *      3、对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥</span></span><br><span class=line><span class=comment> *         者类，将创建过程封装在指挥者类中，而不在建造者类中。</span></span><br><span class=line><span class=comment> *      4、隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的</span></span><br><span class=line><span class=comment> *         产品。</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">App</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>Builder</span> <span class=variable>commonBuilder</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">CommonRoleBuilder</span>();</span><br><span class=line>        <span class=type>Director</span> <span class=variable>director</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Director</span>();</span><br><span class=line>        <span class=type>Role</span> <span class=variable>commonRole</span> <span class=operator>=</span> director.constructAndGet(commonBuilder);</span><br><span class=line>        System.out.println(commonRole);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-1-5、Prototype（原型模式）><a class=headerlink href=#1-1-5、Prototype（原型模式） title=1.1.5、Prototype（原型模式）></a>1.1.5、Prototype（原型模式）</h3><h4 id=简介-3><a class=headerlink href=#简介-3 title=简介></a>简介</h4><p><strong>原型实例指定创建对象的种类，且通过 拷贝原型 创建新对象</strong>。<p>相关知识点：Cloneable接口/Object.clone方法；浅拷贝/深拷贝；序列化实现深拷贝。<h4 id=何时使用-4><a class=headerlink href=#何时使用-4 title=何时使用></a>何时使用</h4><ol><li>当一个系统应该独立于它的产品创建，构成和表示时。<li>当要实例化的类是在运行时刻指定时，例如，通过动态装载。<li>为了避免创建一个与产品类层次平行的工厂类层次时。<li>当一个类的实例只能由几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</ol><h4 id=优缺点-4><a class=headerlink href=#优缺点-4 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>性能提高。<li>逃避构造函数的约束。<li>可以不耦合具体类的情况下克隆对象。<li>避免重复的初始化代码。<li>更方便的构建复杂对象。</ol><li>缺点<ol><li>设计克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构时。<li>必须实现 Cloneable 接口。</ol></ul><h4 id=应用场景-3><a class=headerlink href=#应用场景-3 title=应用场景></a>应用场景</h4><ol><li>资源优化场景；<li>类初始化需要消化非常多的资源；<li>性能和安全要求的场景；<li>通过 new 创建对象需要繁杂步骤时；<li>一个对象有多个修改；<li>当多个对象需要对同一对象执行操作时，可以将共享对象拷贝多个来应付每一个调用者对象；<li>实际开发中，原型模式一般和工厂方法一起使用。工厂方法可以将 原型模式拷贝生成的对象提供给调用者；</ol><h4 id=应用实例-4><a class=headerlink href=#应用实例-4 title=应用实例></a>应用实例</h4><ol><li>细胞分裂。<li>JAVA 中的 Object clone() 方法。</ol><h4 id=源码中的应用><a class=headerlink href=#源码中的应用 title=源码中的应用></a>源码中的应用</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>org.springframework.beans.factory.support.AbstracBeanDefinition</span><br><span class=line>java.util.Arrays</span><br></pre></table></figure><h4 id=注意事项-4><a class=headerlink href=#注意事项-4 title=注意事项></a>注意事项</h4><p><font color=red>原型模式是通过拷贝现有对象来生成新对象。浅拷贝实现 Cloneable，重写，深拷贝通过实现 Serializable 读取二进制流。</font><h4 id=代码实例-4><a class=headerlink href=#代码实例-4 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br><span class=line>105</span><br><span class=line>106</span><br><span class=line>107</span><br><span class=line>108</span><br><span class=line>109</span><br><span class=line>110</span><br><span class=line>111</span><br><span class=line>112</span><br><span class=line>113</span><br><span class=line>114</span><br></pre><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 深拷贝/浅拷贝 测试注意事项：</span></span><br><span class=line><span class=comment> * 1、测试浅拷贝时，去掉Cloneable接口 和 clone方法。</span></span><br><span class=line><span class=comment> * 2、测试深拷贝时，加上Cloneable接口 和 clone方法。</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">PeopleInfo</span> <span class=keyword>implements</span> <span class="title class_">Cloneable</span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> age;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">PeopleInfo</span><span class=params>(<span class=type>int</span> age)</span> {</span><br><span class=line>        <span class=built_in>this</span>.age = age;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">getAge</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> age;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setAge</span><span class=params>(<span class=type>int</span> age)</span> {</span><br><span class=line>        <span class=built_in>this</span>.age = age;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">toString</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"PeopleInfo{"</span> +</span><br><span class=line>                <span class=string>"age="</span> + age +</span><br><span class=line>                <span class=string>'}'</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>/** 测试 浅拷贝 时去掉该方法 */</span></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> Object <span class="title function_">clone</span><span class=params>()</span> <span class=keyword>throws</span> CloneNotSupportedException {</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>super</span>.clone();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">People</span> <span class=keyword>implements</span> <span class="title class_">Cloneable</span>{</span><br><span class=line>    <span class=keyword>private</span> PeopleInfo peopleInfo;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> type; <span class=comment>// 0 / 1</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">People</span><span class=params>()</span>{}</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">People</span><span class=params>(PeopleInfo peopleInfo, <span class=type>int</span> type)</span> {</span><br><span class=line>        <span class=built_in>this</span>.peopleInfo = peopleInfo;</span><br><span class=line>        <span class=built_in>this</span>.type = type;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> PeopleInfo <span class="title function_">getPeopleInfo</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> peopleInfo;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setPeopleInfo</span><span class=params>(PeopleInfo peopleInfo)</span> {</span><br><span class=line>        <span class=built_in>this</span>.peopleInfo = peopleInfo;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">getType</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> type;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setType</span><span class=params>(<span class=type>int</span> type)</span> {</span><br><span class=line>        <span class=built_in>this</span>.type = type;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">toString</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"People{"</span> +</span><br><span class=line>                <span class=string>"peopleInfo="</span> + <span class=built_in>this</span>.getPeopleInfo().toString() +</span><br><span class=line>                <span class=string>", type="</span> + <span class=built_in>this</span>.getType() +</span><br><span class=line>                <span class=string>'}'</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>/** 浅复制 clone方法实现 */</span></span><br><span class=line><span class=comment>//    @Override</span></span><br><span class=line><span class=comment>//    protected People clone() throws CloneNotSupportedException {</span></span><br><span class=line><span class=comment>//        return (People) super.clone();</span></span><br><span class=line><span class=comment>//    }</span></span><br><span class=line></span><br><span class=line>    <span class=comment>/** 深复制 clone方法实现 */</span></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> People <span class="title function_">clone</span><span class=params>()</span> <span class=keyword>throws</span> CloneNotSupportedException {</span><br><span class=line>        <span class=type>People</span> <span class=variable>people</span> <span class=operator>=</span> (People) <span class=built_in>super</span>.clone();</span><br><span class=line>        people.peopleInfo = (PeopleInfo) people.getPeopleInfo().clone();</span><br><span class=line>        <span class=keyword>return</span> people;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 设计模式 - 原型模式</span></span><br><span class=line><span class=comment> * </span></span><br><span class=line><span class=comment> * 深拷贝：引用和基本数据类型 都会拷贝；</span></span><br><span class=line><span class=comment> * 浅拷贝：只会拷贝基本数据类型；</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">PrototypeApp</span> {</span><br><span class=line></span><br><span class=line>    <span class=comment>/** 浅拷贝 测试 */</span></span><br><span class=line>    <span class=meta>@Test</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">shallowReplication</span><span class=params>()</span> <span class=keyword>throws</span> CloneNotSupportedException {</span><br><span class=line>        <span class=type>PeopleInfo</span> <span class=variable>peopleInfo</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">PeopleInfo</span>(<span class=number>30</span>);</span><br><span class=line>        <span class=type>People</span> <span class=variable>p1</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">People</span>(peopleInfo, <span class=number>0</span>);</span><br><span class=line>        <span class=type>People</span> <span class=variable>p2</span> <span class=operator>=</span> p1.clone();</span><br><span class=line>        System.out.println(<span class=string>"p1-1: "</span> + p1.toString()); <span class=comment>// 30 0</span></span><br><span class=line>        System.out.println(<span class=string>"p2-1: "</span> + p2.toString()); <span class=comment>// 30 0</span></span><br><span class=line></span><br><span class=line>        p1.setType(<span class=number>1</span>);</span><br><span class=line>        peopleInfo.setAge(<span class=number>35</span>);</span><br><span class=line></span><br><span class=line>        System.out.println(<span class=string>"p1-2: "</span> + p1.toString()); <span class=comment>// 35 1</span></span><br><span class=line>        System.out.println(<span class=string>"p2-2: "</span> + p2.toString()); <span class=comment>// 35 0</span></span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>/** 深拷贝 测试 */</span></span><br><span class=line>    <span class=meta>@Test</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">deepReplication</span><span class=params>()</span> <span class=keyword>throws</span> CloneNotSupportedException {</span><br><span class=line>        <span class=type>PeopleInfo</span> <span class=variable>peopleInfo</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">PeopleInfo</span>(<span class=number>30</span>);</span><br><span class=line>        <span class=type>People</span> <span class=variable>p1</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">People</span>(peopleInfo, <span class=number>0</span>);</span><br><span class=line>        <span class=type>People</span> <span class=variable>p2</span> <span class=operator>=</span> p1.clone();</span><br><span class=line>        System.out.println(<span class=string>"p1-1: "</span> + p1.toString()); <span class=comment>// 30 0</span></span><br><span class=line>        System.out.println(<span class=string>"p2-1: "</span> + p2.toString()); <span class=comment>// 30 0</span></span><br><span class=line></span><br><span class=line>        p1.setType(<span class=number>1</span>);</span><br><span class=line>        peopleInfo.setAge(<span class=number>35</span>);</span><br><span class=line></span><br><span class=line>        System.out.println(<span class=string>"p1-2: "</span> + p1.toString()); <span class=comment>// 35 1</span></span><br><span class=line>        System.out.println(<span class=string>"p2-2: "</span> + p2.toString()); <span class=comment>// 30 0</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=1-2、行为型（11种）><a class=headerlink href=#1-2、行为型（11种） title=1.2、行为型（11种）></a>1.2、行为型（11种）</h2><h3 id=1-2-1、Iterator（迭代器模式）><a class=headerlink href=#1-2-1、Iterator（迭代器模式） title=1.2.1、Iterator（迭代器模式）></a>1.2.1、Iterator（迭代器模式）</h3><h4 id=简介-4><a class=headerlink href=#简介-4 title=简介></a>简介</h4><p><strong>在不暴露对象内部的前提下，可以顺序访问对象的内部元素</strong>。<h4 id=何时使用-5><a class=headerlink href=#何时使用-5 title=何时使用></a>何时使用</h4><p>需要对容器/集合遍历时，可以使用迭代器模式。<h4 id=实现-1><a class=headerlink href=#实现-1 title=实现></a>实现</h4><ul><li>数组实现<li>链表实现</ul><h4 id=优缺点-5><a class=headerlink href=#优缺点-5 title=优缺点></a>优缺点</h4><ul><li><p>优点</p> <ol><li>它支持以不同方式遍历一个聚合对象；<li>迭代器简化了聚合类；<li>在同一聚合上可以有多个遍历；<li>迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码；</ol><li><p>缺点</p> <p>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p></ul><h4 id=应用场景-4><a class=headerlink href=#应用场景-4 title=应用场景></a>应用场景</h4><ol><li>访问一个聚合对象的内部元素而无须暴露其内部表示。<li>需要为聚合对象提供多种遍历方式。<li>为遍历不同的聚合结构提供一个统一的接口。</ol><h4 id=应用实例-5><a class=headerlink href=#应用实例-5 title=应用实例></a>应用实例</h4><p>JAVA 中的 iterator。<h4 id=注意事项-5><a class=headerlink href=#注意事项-5 title=注意事项></a>注意事项</h4><p><font color=red>迭代器模式分离了集合对象的遍历行为，抽象出一个迭代器类，可实现不爆露对象内部就可访问其内部元素；</font><h4 id=代码实例-5><a class=headerlink href=#代码实例-5 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Iterator</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">hasNext</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">next</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">remove</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">IPerson</span> {</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getPersonInfo</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">IPersonList</span> {</span><br><span class=line>    <span class=keyword>public</span> ArrayList&LTIPerson> <span class="title function_">getPersonList</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> Iterator <span class="title function_">iterator</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Person</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Person</span><span class=params>(String name)</span>{</span><br><span class=line>        System.out.println(<span class=string>"构造器进来了！"</span>);</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">PersonIterator</span> <span class=keyword>implements</span> <span class="title class_">Iterator</span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> ArrayList&LTIPerson> personList;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> <span class=variable>index</span> <span class=operator>=</span> -<span class=number>1</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">PersonIterator</span><span class=params>(ArrayList&LTIPerson> personList)</span>{</span><br><span class=line>        <span class=built_in>this</span>.personList = personList;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">hasNext</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> (<span class=built_in>this</span>.personList == <span class=literal>null</span> ? <span class=literal>false</span> : (index < <span class=built_in>this</span>.personList.size() - <span class=number>1</span>));</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">next</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>this</span>.personList != <span class=literal>null</span> && (index < <span class=built_in>this</span>.personList.size() - <span class=number>1</span>)){</span><br><span class=line>            <span class=keyword>return</span> <span class=built_in>this</span>.personList.get(++index);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">remove</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>this</span>.personList != <span class=literal>null</span>){</span><br><span class=line>            <span class=keyword>return</span> <span class=built_in>this</span>.personList.remove(index);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">PersonList</span> <span class=keyword>implements</span> <span class="title class_">IPersonList</span>{</span><br><span class=line>    <span class=keyword>private</span> ArrayList&LTIPerson> personList = <span class=keyword>new</span> <span class="title class_">ArrayList</span>&LTIPerson>();</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">PersonList</span><span class=params>()</span>{</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < <span class=number>10</span>; i++){</span><br><span class=line>            <span class=type>IPerson</span> <span class=variable>person</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Person</span>(<span class=string>"孙悟空"</span>, <span class=number>30</span>);</span><br><span class=line>            <span class=built_in>this</span>.personList.add(person);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> ArrayList&LTIPerson> <span class="title function_">getPersonList</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.personList;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Iterator <span class="title function_">iterator</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">PersonIterator</span>(<span class=built_in>this</span>.personList);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">IteratorApp</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>IPersonList</span> <span class=variable>personList</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">PersonList</span>();</span><br><span class=line>        ArrayList&LTIPerson> list = personList.getPersonList();</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < list.size(); i++){</span><br><span class=line>            System.out.println(list.get(i).getPersonInfo());</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        System.out.println(<span class=string>"----------------------------------"</span>);</span><br><span class=line></span><br><span class=line>        <span class=type>Iterator</span> <span class=variable>iterator</span> <span class=operator>=</span> personList.iterator();</span><br><span class=line>        <span class=keyword>while</span> (iterator.hasNext()){</span><br><span class=line>            <span class=type>IPerson</span> <span class=variable>person</span> <span class=operator>=</span> (IPerson) iterator.next();</span><br><span class=line>            <span class=keyword>if</span> (person != <span class=literal>null</span>){</span><br><span class=line>                System.out.println(person.getPersonInfo());</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-2、Observer（观察者模式）><a class=headerlink href=#1-2-2、Observer（观察者模式） title=1.2.2、Observer（观察者模式）></a>1.2.2、Observer（观察者模式）</h3><h4 id=简介-5><a class=headerlink href=#简介-5 title=简介></a>简介</h4><p><strong>多个参与者对象同时监听参考对象A，当参考对象A发生变化时，所有参与者对象依据该变化会做出相应的改变；</strong><h4 id=何时使用-6><a class=headerlink href=#何时使用-6 title=何时使用></a>何时使用</h4><p>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。<h4 id=优缺点-6><a class=headerlink href=#优缺点-6 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>观察者和被观察者是抽象耦合的。<li>建立一套触发机制。</ol><li>缺点<ol><li>参与者太多 导致 参照者发送通知会消耗很多资源；<li>参与者和参照者中间发生 循坏依赖可能导致系统崩溃。<li>参与者只知道参照者发生了变化，而如何变化却不知道；</ol></ul><h4 id=应用场景-5><a class=headerlink href=#应用场景-5 title=应用场景></a>应用场景</h4><ol><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。<li>一个对象必须通知其他对象，而并不知道这些对象是谁。<li>需要在系统中创建一个触发链，A 对象的行为将影响 B 对象，B 对象的行为将影响 C 对象……，可以使用观察者模式创建一种链式触发机制。</ol><h4 id=应用实例-6><a class=headerlink href=#应用实例-6 title=应用实例></a>应用实例</h4><ol><li>拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。<li>西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</ol><h4 id=源码应用-2><a class=headerlink href=#源码应用-2 title=源码应用></a>源码应用</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>java.util.Observable</span><br><span class=line>org.springframework.context.ApplicationListener</span><br></pre></table></figure><h4 id=注意事项-6><a class=headerlink href=#注意事项-6 title=注意事项></a>注意事项</h4><ol><li><font color=red>JAVA 中存在相关支持类；</font><li><font color=red>应该避免循环引用；</font><li><font color=red>顺序执行将导致某一观察者错误进而导致系统卡壳，故一般采用异步方式；</font></ol><h4 id=代码实例-6><a class=headerlink href=#代码实例-6 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.Observable;</span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 观察目标</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * 观察目标的逻辑是先发表文章，再改变观察目标的状态，再通知观察者。</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ObserverTarget</span> <span class=keyword>extends</span> <span class="title class_">Observable</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> String article;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> String <span class="title function_">getArticle</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> article;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">publish</span><span class=params>(String article)</span>{</span><br><span class=line>        <span class=built_in>this</span>.article = article;</span><br><span class=line>        <span class=comment>// 改变状态</span></span><br><span class=line>        <span class=built_in>this</span>.setChanged();</span><br><span class=line>        <span class=comment>/* 作用：通知所有观察者；内部逻辑：先获取同步锁，判断状态是否更新，若更新了则清空</span></span><br><span class=line><span class=comment>         * 观察目标状态，然后再使用for循环遍历所有观察者，一一调用观察者的更新方法通知观</span></span><br><span class=line><span class=comment>         * 察者更新。 **/</span></span><br><span class=line>        <span class=built_in>this</span>.notifyObservers();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.util.Observable;</span><br><span class=line><span class=keyword>import</span> java.util.Observer;</span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 观察者：读者</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ReaderObserver</span> <span class=keyword>implements</span> <span class="title class_">Observer</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> String article;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ReaderObserver</span><span class=params>(String name)</span>{</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">update</span><span class=params>(Observable o, Object arg)</span> {</span><br><span class=line>        updateArticle(o);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">updateArticle</span><span class=params>(Observable o)</span> {</span><br><span class=line>        <span class=type>ObserverTarget</span> <span class=variable>target</span> <span class=operator>=</span> (ObserverTarget) o;</span><br><span class=line>        <span class=built_in>this</span>.article = ObserverTarget.getArticle();</span><br><span class=line>        System.out.printf(<span class=string>"读者 %s，你好，文章已更新：%s\n"</span>, <span class=built_in>this</span>.name, <span class=built_in>this</span>.article);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ObserverApp</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=comment>// 创建一个观察目标</span></span><br><span class=line>        <span class=type>ObserverTarget</span> <span class=variable>target</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ObserverTarget</span>();</span><br><span class=line>        <span class=comment>// 添加观察者</span></span><br><span class=line>        target.addObserver(<span class=keyword>new</span> <span class="title class_">ReaderObserver</span>(<span class=string>"小明"</span>));</span><br><span class=line>        target.addObserver(<span class=keyword>new</span> <span class="title class_">ReaderObserver</span>(<span class=string>"小王"</span>));</span><br><span class=line>        target.addObserver(<span class=keyword>new</span> <span class="title class_">ReaderObserver</span>(<span class=string>"小张"</span>));</span><br><span class=line>        <span class=comment>// 发表文章</span></span><br><span class=line>        target.publish(<span class=string>"啥是观察者模式。"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-3、TemplateMethod（模板方法）><a class=headerlink href=#1-2-3、TemplateMethod（模板方法） title=1.2.3、TemplateMethod（模板方法）></a>1.2.3、TemplateMethod（模板方法）</h3><h4 id=简介-6><a class=headerlink href=#简介-6 title=简介></a>简介</h4><p><strong>也称钩子函数，其定义一个操作算法骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结果，即可重定义该算法的某些特定步骤。</strong><h4 id=何时使用-7><a class=headerlink href=#何时使用-7 title=何时使用></a>何时使用</h4><p>系统中存在一部分通用方法。<h4 id=优缺点-7><a class=headerlink href=#优缺点-7 title=优缺点></a>优缺点</h4><ul><li><p>优点</p> <ol><li>封装不变部分，扩展可变部分。<li>提取公共代码，便于维护。<li>行为由父类控制，子类实现。</ol><li><p>缺点</p> <p>每一个不同的实现都需要一个子类来实现，类的数量增加导致系统愈加庞大。</p></ul><h4 id=应用场景-6><a class=headerlink href=#应用场景-6 title=应用场景></a>应用场景</h4><ol><li>有多个子类共有的方法，且逻辑相同。<li>重要的、复杂的方法，可以考虑作为模板方法。</ol><h4 id=应用实例-7><a class=headerlink href=#应用实例-7 title=应用实例></a>应用实例</h4><ol><li>在造房子的时候，地基、走线、水管都一样，只有后期加壁橱加栅栏等差异。<li>西游记中的 81 难，就是一个顶层逻辑骨架。<li>spring 对 Hibernate 的支持，将一些规定好的方法封装起来，编程人员直接使用即可。</ol><h4 id=注意事项-7><a class=headerlink href=#注意事项-7 title=注意事项></a>注意事项</h4><p><font color=red>为防止恶意操作，模板方法一般会使用 final 修饰。</font><h4 id=代码实例-7><a class=headerlink href=#代码实例-7 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">AbstractTemplate</span> {</span><br><span class=line>    <span class=comment>// 模板方法</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">templateMethod</span><span class=params>()</span>{</span><br><span class=line>        init();</span><br><span class=line>        apply();  <span class=comment>// 重点</span></span><br><span class=line>        end();    <span class=comment>// 可以作为钩子方法</span></span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>void</span> <span class="title function_">init</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"init 抽象层已经实现，子类也可以选择覆写"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 留给子类实现</span></span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">apply</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>void</span> <span class="title function_">end</span><span class=params>()</span> {}</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ConcreteTemplate</span> <span class=keyword>extends</span> <span class="title class_">AbstractTemplate</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">apply</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"子类实现抽象方法 apply"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">end</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">TemplateMethodApp</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>AbstractTemplate</span> <span class=variable>t</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ConcreteTemplate</span>();</span><br><span class=line>        <span class=comment>// 调用模板方法</span></span><br><span class=line>        t.templateMethod();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-4、Strategy（策略模式）><a class=headerlink href=#1-2-4、Strategy（策略模式） title=1.2.4、Strategy（策略模式）></a>1.2.4、Strategy（策略模式）</h3><h4 id=简介-7><a class=headerlink href=#简介-7 title=简介></a>简介</h4><p><strong>一个类的行为或算法可在运行时修改。创建各种策略对象和一个随策略对象改变而会改变行为的context对象。策略对象会改变context对象的执行算法。</strong><h4 id=何时使用-8><a class=headerlink href=#何时使用-8 title=何时使用></a>何时使用</h4><p>一个系统有许多类，而区分它们的只是他们直接的行为。<h4 id=优缺点-8><a class=headerlink href=#优缺点-8 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>算法可以自由切换。<li>避免使用多重条件判断。<li>扩展性良好。</ol><li>缺点<ol><li>策略类会增多。<li>所有策略类都需要对外暴露。</ol></ul><h4 id=应用场景-7><a class=headerlink href=#应用场景-7 title=应用场景></a>应用场景</h4><ol><li>一个系统中的许多类只存在行为上的区别时，该模式可以动态让一个对象在许多行为中选择一种行为。<li>一个系统需要动态地在几种算法中选择一种。<li>如果一个对象有很多行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</ol><h4 id=应用实例-8><a class=headerlink href=#应用实例-8 title=应用实例></a>应用实例</h4><ol><li>诸葛亮的锦囊妙计，每一个锦囊就是一个策略。<li>旅行的交通方式可以选择骑自行车、开汽车等，每一种旅行方式都是一个策略。<li>JAVA AWT 中的 LayoutManager。</ol><h4 id=注意事项-8><a class=headerlink href=#注意事项-8 title=注意事项></a>注意事项</h4><p><font color=red>如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</font>、<h4 id=代码实例-8><a class=headerlink href=#代码实例-8 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br></pre><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 会员接口</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Member</span> {</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 计算应付价格</span></span><br><span class=line><span class=comment>     * <span class=doctag>@param</span> bookPrice 书籍原价(针对金额,建议使用BigDecimal,double会损失精度)</span></span><br><span class=line><span class=comment>     * <span class=doctag>@return</span> 应付金额</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>double</span> <span class="title function_">calPrice</span><span class=params>(<span class=type>double</span> bookPrice)</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 初级会员</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">PrimaryMember</span> <span class=keyword>implements</span> <span class="title class_">Member</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>double</span> <span class="title function_">calPrice</span><span class=params>(<span class=type>double</span> bookPrice)</span> {</span><br><span class=line>        System.out.println(<span class=string>"对于初级会员的没有折扣"</span>);</span><br><span class=line>        <span class=keyword>return</span> bookPrice;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 中级会员，买书打九折</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">IntermediateMember</span> <span class=keyword>implements</span> <span class="title class_">Member</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>double</span> <span class="title function_">calPrice</span><span class=params>(<span class=type>double</span> bookPrice)</span> {</span><br><span class=line>        System.out.println(<span class=string>"对于中级会员的折扣为10%"</span>);</span><br><span class=line>        <span class=keyword>return</span> bookPrice * <span class=number>0.9</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 高级会员，买书打八折</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AdvancedMember</span> <span class=keyword>implements</span> <span class="title class_">Member</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>double</span> <span class="title function_">calPrice</span><span class=params>(<span class=type>double</span> bookPrice)</span> {</span><br><span class=line>        System.out.println(<span class=string>"对于高级会员的折扣为20%"</span>);</span><br><span class=line>        <span class=keyword>return</span> bookPrice * <span class=number>0.8</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 书籍价格类</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Cashier</span> {</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 会员,策略对象</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>private</span> Member member;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Cashier</span><span class=params>(Member member)</span>{</span><br><span class=line>        <span class=built_in>this</span>.member = member;</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 计算应付价格</span></span><br><span class=line><span class=comment>     * <span class=doctag>@param</span> booksPrice</span></span><br><span class=line><span class=comment>     * <span class=doctag>@return</span></span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>public</span> <span class=type>double</span> <span class="title function_">quote</span><span class=params>(<span class=type>double</span> booksPrice)</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.member.calPrice(booksPrice);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BookStoreApp</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=comment>//选择并创建需要使用的策略对象</span></span><br><span class=line>        <span class=type>Member</span> <span class=variable>strategy</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AdvancedMember</span>();</span><br><span class=line>        <span class=comment>//创建环境</span></span><br><span class=line>        <span class=type>Cashier</span> <span class=variable>cashier</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Cashier</span>(strategy);</span><br><span class=line>        <span class=comment>//计算价格</span></span><br><span class=line>        <span class=type>double</span> <span class=variable>quote</span> <span class=operator>=</span> cashier.quote(<span class=number>300</span>);</span><br><span class=line>        System.out.println(<span class=string>"高级会员图书的最终价格为："</span> + quote);</span><br><span class=line></span><br><span class=line>        strategy = <span class=keyword>new</span> <span class="title class_">IntermediateMember</span>();</span><br><span class=line>        cashier = <span class=keyword>new</span> <span class="title class_">Cashier</span>(strategy);</span><br><span class=line>        quote = cashier.quote(<span class=number>300</span>);</span><br><span class=line>        System.out.println(<span class=string>"中级会员图书的最终价格为："</span> + quote);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-5、ChainOfResponsibility（职责链模式）><a class=headerlink href=#1-2-5、ChainOfResponsibility（职责链模式） title=1.2.5、ChainOfResponsibility（职责链模式）></a>1.2.5、ChainOfResponsibility（职责链模式）</h3><h4 id=简介-8><a class=headerlink href=#简介-8 title=简介></a>简介</h4><p><strong>创建一个请求接收者链，每一个请求接收者通过一个引用与其它接收者相连。请求发送者发送的请求会经过 接收者链，链中的每一个接收者都有机会处理该请求。实现了发送者与接收者的解耦。</strong><h4 id=何时使用-9><a class=headerlink href=#何时使用-9 title=何时使用></a>何时使用</h4><p>过滤消息中各种不雅内容；<h4 id=优缺点-9><a class=headerlink href=#优缺点-9 title=优缺点></a>优缺点</h4><ol><li>请求的发送者和接收者解耦。<li>可以执行控制顺序。<li>符合开闭原则和单一职责原则。</ol><h4 id=应用场景-8><a class=headerlink href=#应用场景-8 title=应用场景></a>应用场景</h4><ol><li>多个对象都能处理同一个请求，具体由哪个对象处理该请求则在运行时自动确定。<li>在不明确指定接收者的情况下，向多个对象中的某个对象发送一个请求。<li>动态指定一组对象处理请求的场景。</ol><h4 id=应用实例-9><a class=headerlink href=#应用实例-9 title=应用实例></a>应用实例</h4><ol><li>红楼梦中的 “击鼓传花”。<li>JS 中的事件冒泡。<li>JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</ol><h4 id=源码应用-3><a class=headerlink href=#源码应用-3 title=源码应用></a>源码应用</h4><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>javax.servlet.Filter</span><br><span class=line>javax.servlet.FilterChain</span><br></pre></table></figure><h4 id=注意事项-9><a class=headerlink href=#注意事项-9 title=注意事项></a>注意事项</h4><p><font color=red>JAVA WEB 中有很多应用。</font><h4 id=代码实例-9><a class=headerlink href=#代码实例-9 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.Random;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">App</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>ProcessHandler</span> <span class=variable>processHandler</span> <span class=operator>=</span> ProcessHandler.getInstance();</span><br><span class=line>        <span class=type>Random</span> <span class=variable>random</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Random</span>();</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < <span class=number>3</span>; i++){</span><br><span class=line>            <span class=type>int</span> <span class=variable>radom</span> <span class=operator>=</span> random.nextInt(<span class=number>3</span>);</span><br><span class=line>            <span class=type>IStudent</span> <span class=variable>student</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Student</span>(radom, <span class=string>"学生"</span> + i + <span class=string>"生病了，需要请假。"</span>);</span><br><span class=line></span><br><span class=line>            System.out.println(<span class=string>"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>);</span><br><span class=line>            processHandler.sendMsg(student);</span><br><span class=line>            System.out.println(<span class=string>"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-6、Mediator（中介者模式）><a class=headerlink href=#1-2-6、Mediator（中介者模式） title=1.2.6、Mediator（中介者模式）></a>1.2.6、Mediator（中介者模式）</h3><h4 id=简介-9><a class=headerlink href=#简介-9 title=简介></a>简介</h4><p><strong>创建一个中介类来处理不同类之间的通信，且支持松耦合，代码易维护。</strong><h4 id=何时使用-10><a class=headerlink href=#何时使用-10 title=何时使用></a>何时使用</h4><p>多个类相互耦合，形成了网状结构。<h4 id=优缺点-10><a class=headerlink href=#优缺点-10 title=优缺点></a>优缺点</h4><ul><li><p>优点</p> <ol><li>降低了类的复杂度，将一对多转化成了一对一。<li>实现了类之间的解耦。<li>符合迪米特原则。</ol><li><p>缺点</p> <p>中介者会庞大，变得复杂难以维护。</p></ul><h4 id=应用场景-9><a class=headerlink href=#应用场景-9 title=应用场景></a>应用场景</h4><ol><li>对象间存在复杂引用关系，内部结构复杂难以使用；<li>通过一个中间类来封装多个类中的行为，而又不想生成太多的子类；</ol><h4 id=应用实例-10><a class=headerlink href=#应用实例-10 title=应用实例></a>应用实例</h4><ol><li>中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。<li>机场调度系统。<li>MVC 框架中 C（控制器）就是 M（模型）和 V（视图）的中介者。</ol><h4 id=注意事项-10><a class=headerlink href=#注意事项-10 title=注意事项></a>注意事项</h4><p><font color=red>不应当在职责混乱时使用。</font><h4 id=代码实例-10><a class=headerlink href=#代码实例-10 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br><span class=line>105</span><br><span class=line>106</span><br><span class=line>107</span><br><span class=line>108</span><br></pre><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 用户接口</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">IUser</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">receiveMsg</span><span class=params>(String msg)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">sendMsg</span><span class=params>(String msg)</span>;</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getMsg</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 中介者接口</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">IMediator</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">regist</span><span class=params>(IUser iUser)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">notifyAllMsg</span><span class=params>(IUser iUser)</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">AbstractUser</span> <span class=keyword>implements</span> <span class="title class_">IUser</span>{</span><br><span class=line>    <span class=keyword>protected</span> IMediator mediator;</span><br><span class=line>    <span class=keyword>protected</span>  String name;</span><br><span class=line>    <span class=keyword>protected</span> String msg;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AbstractUser</span><span class=params>(IMediator mediator, String name)</span>{</span><br><span class=line>        <span class=built_in>this</span>.mediator = mediator;</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">sendMsg</span><span class=params>(String msg)</span>{</span><br><span class=line>        <span class=built_in>this</span>.msg = msg;</span><br><span class=line>        System.out.println(<span class=built_in>this</span>.name + <span class=string>"说： "</span> + <span class=built_in>this</span>.msg );</span><br><span class=line>        mediator.notifyAllMsg(<span class=built_in>this</span>);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getMsg</span><span class=params>()</span>{</span><br><span class=line>        <span class=keyword>return</span> msg;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ConcreteMediator</span> <span class=keyword>implements</span> <span class="title class_">IMediator</span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> List&LTIUser> userList = <span class=keyword>new</span> <span class="title class_">ArrayList</span>&LTIUser>();</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">regist</span><span class=params>(IUser iUser)</span> {</span><br><span class=line>        <span class=keyword>if</span> (iUser != <span class=literal>null</span> && !userList.contains(iUser)){</span><br><span class=line>            userList.add(iUser);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">notifyAllMsg</span><span class=params>(IUser iUser)</span> {</span><br><span class=line>        Iterator&LTIUser> iterator = userList.iterator();</span><br><span class=line>        <span class=type>IUser</span> <span class=variable>tmp</span> <span class=operator>=</span> <span class=literal>null</span>;</span><br><span class=line>        <span class=keyword>while</span> (iterator.hasNext()){</span><br><span class=line>            tmp = iterator.next();</span><br><span class=line>            <span class=keyword>if</span> (tmp != <span class=literal>null</span> && !tmp.equals(iUser)){</span><br><span class=line>                tmp.receiveMsg(iUser.getMsg());</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">UserA</span> <span class=keyword>extends</span> <span class="title class_">AbstractUser</span>{</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">UserA</span><span class=params>(IMediator mediator, String name)</span>{</span><br><span class=line>        <span class=built_in>super</span>(mediator, name);</span><br><span class=line>        mediator.regist(<span class=built_in>this</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">receiveMsg</span><span class=params>(String msg)</span> {</span><br><span class=line>        System.out.println(<span class=string>"UserA received msg: "</span> + msg);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">UserB</span> <span class=keyword>extends</span> <span class="title class_">AbstractUser</span>{</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">UserB</span><span class=params>(IMediator mediator, String name)</span>{</span><br><span class=line>        <span class=built_in>super</span>(mediator, name);</span><br><span class=line>        mediator.regist(<span class=built_in>this</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">receiveMsg</span><span class=params>(String msg)</span> {</span><br><span class=line>        System.out.println(<span class=string>"UserB received msg: "</span> + msg);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">UserC</span> <span class=keyword>extends</span> <span class="title class_">AbstractUser</span>{</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">UserC</span><span class=params>(IMediator mediator, String name)</span>{</span><br><span class=line>        <span class=built_in>super</span>(mediator, name);</span><br><span class=line>        mediator.regist(<span class=built_in>this</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">receiveMsg</span><span class=params>(String msg)</span> {</span><br><span class=line>        System.out.println(<span class=string>"UserC received msg: "</span> + msg);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MediatorApp</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>IMediator</span> <span class=variable>mediator</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ConcreteMediator</span>();</span><br><span class=line>        <span class=type>IUser</span> <span class=variable>userA</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">UserA</span>(mediator, <span class=string>"孙悟空"</span>);</span><br><span class=line>        <span class=type>IUser</span> <span class=variable>userB</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">UserB</span>(mediator, <span class=string>"猪八戒"</span>);</span><br><span class=line>        <span class=type>IUser</span> <span class=variable>userC</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">UserC</span>(mediator, <span class=string>"沙和尚"</span>);</span><br><span class=line></span><br><span class=line>        userA.sendMsg(<span class=string>"大家好，我乃齐天大圣 孙悟空！"</span>);</span><br><span class=line>        userB.sendMsg(<span class=string>"大家好，我乃高老庄 猪八戒！"</span>);</span><br><span class=line>        userC.sendMsg(<span class=string>"大家好，我乃 沙和尚！"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-7、Interpreter（解释器模式）><a class=headerlink href=#1-2-7、Interpreter（解释器模式） title=1.2.7、Interpreter（解释器模式）></a>1.2.7、Interpreter（解释器模式）</h3><h4 id=简介-10><a class=headerlink href=#简介-10 title=简介></a>简介</h4><p><strong>实现一个表达式接口，该接口解释一个特定上下文。该模式在SQL解析、符号处理引擎中有使用。</strong><h4 id=何时使用-11><a class=headerlink href=#何时使用-11 title=何时使用></a>何时使用</h4><p>某一个类型的问题发送频率特高，可以将该类型问题的各实例封装成一个简单描述，然后通过解释器来解释处理该描述。<h4 id=优缺点-11><a class=headerlink href=#优缺点-11 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>可扩展性比较好，灵活。<li>增加了新的解释表达式的方式。<li>易于实现简单文法。</ol><li>缺点<ol><li>可利用场景比较少。<li>对于复杂的文法比较难维护。<li>解释器模式会引起类膨胀。<li>解释器模式采用递归调用方法。</ol></ul><h4 id=应用场景-10><a class=headerlink href=#应用场景-10 title=应用场景></a>应用场景</h4><ol><li>将一个解释执行语言中的句子表示为一个抽象语法树。<li>重复出现的问题可以用一种简单的语言来进行表达。<li>简单语法需要解释的场景。</ol><h4 id=应用实例-11><a class=headerlink href=#应用实例-11 title=应用实例></a>应用实例</h4><p>编译器、运算表达式计算。<h4 id=注意事项-11><a class=headerlink href=#注意事项-11 title=注意事项></a>注意事项</h4><p><font color=red>可利用场景比较少，JAVA 中可以用 expression4J 代替。</font><h4 id=代码实例-11><a class=headerlink href=#代码实例-11 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br><span class=line>105</span><br><span class=line>106</span><br><span class=line>107</span><br><span class=line>108</span><br><span class=line>109</span><br><span class=line>110</span><br><span class=line>111</span><br><span class=line>112</span><br><span class=line>113</span><br><span class=line>114</span><br><span class=line>115</span><br><span class=line>116</span><br><span class=line>117</span><br><span class=line>118</span><br><span class=line>119</span><br><span class=line>120</span><br><span class=line>121</span><br><span class=line>122</span><br><span class=line>123</span><br><span class=line>124</span><br><span class=line>125</span><br><span class=line>126</span><br><span class=line>127</span><br><span class=line>128</span><br><span class=line>129</span><br><span class=line>130</span><br><span class=line>131</span><br><span class=line>132</span><br><span class=line>133</span><br><span class=line>134</span><br><span class=line>135</span><br><span class=line>136</span><br><span class=line>137</span><br><span class=line>138</span><br><span class=line>139</span><br><span class=line>140</span><br><span class=line>141</span><br><span class=line>142</span><br><span class=line>143</span><br><span class=line>144</span><br><span class=line>145</span><br><span class=line>146</span><br><span class=line>147</span><br><span class=line>148</span><br><span class=line>149</span><br><span class=line>150</span><br><span class=line>151</span><br><span class=line>152</span><br><span class=line>153</span><br><span class=line>154</span><br><span class=line>155</span><br><span class=line>156</span><br><span class=line>157</span><br><span class=line>158</span><br><span class=line>159</span><br><span class=line>160</span><br><span class=line>161</span><br><span class=line>162</span><br><span class=line>163</span><br><span class=line>164</span><br><span class=line>165</span><br><span class=line>166</span><br><span class=line>167</span><br><span class=line>168</span><br><span class=line>169</span><br><span class=line>170</span><br><span class=line>171</span><br><span class=line>172</span><br><span class=line>173</span><br><span class=line>174</span><br><span class=line>175</span><br><span class=line>176</span><br><span class=line>177</span><br><span class=line>178</span><br><span class=line>179</span><br><span class=line>180</span><br><span class=line>181</span><br><span class=line>182</span><br><span class=line>183</span><br><span class=line>184</span><br><span class=line>185</span><br><span class=line>186</span><br><span class=line>187</span><br><span class=line>188</span><br><span class=line>189</span><br><span class=line>190</span><br><span class=line>191</span><br><span class=line>192</span><br><span class=line>193</span><br><span class=line>194</span><br><span class=line>195</span><br><span class=line>196</span><br><span class=line>197</span><br><span class=line>198</span><br><span class=line>199</span><br><span class=line>200</span><br><span class=line>201</span><br><span class=line>202</span><br><span class=line>203</span><br><span class=line>204</span><br><span class=line>205</span><br><span class=line>206</span><br><span class=line>207</span><br><span class=line>208</span><br><span class=line>209</span><br><span class=line>210</span><br><span class=line>211</span><br><span class=line>212</span><br><span class=line>213</span><br><span class=line>214</span><br><span class=line>215</span><br><span class=line>216</span><br><span class=line>217</span><br><span class=line>218</span><br><span class=line>219</span><br><span class=line>220</span><br><span class=line>221</span><br><span class=line>222</span><br><span class=line>223</span><br><span class=line>224</span><br><span class=line>225</span><br><span class=line>226</span><br></pre><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 上下文环境</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Context</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> StringTokenizer stringTokenizer;</span><br><span class=line>    <span class=keyword>private</span> String currentToken;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> Map&LTString, Object> map = <span class=keyword>new</span> <span class="title class_">HashMap</span>&LTString, Object>();</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Context</span><span class=params>(String text)</span>{</span><br><span class=line>        <span class=built_in>this</span>.stringTokenizer = <span class=keyword>new</span> <span class="title class_">StringTokenizer</span>(text);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">next</span><span class=params>()</span>{</span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>this</span>.stringTokenizer.hasMoreTokens()){</span><br><span class=line>            currentToken = <span class=built_in>this</span>.stringTokenizer.nextToken();</span><br><span class=line>        }<span class=keyword>else</span> {</span><br><span class=line>            currentToken = <span class=literal>null</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> currentToken;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=type>boolean</span> <span class="title function_">equalsWithCommand</span><span class=params>(String command)</span>{</span><br><span class=line>        <span class=keyword>if</span> (command == <span class=literal>null</span> || !command.equals(<span class=built_in>this</span>.currentToken)){</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getCurrentToken</span><span class=params>()</span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.currentToken;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getTokenContext</span><span class=params>(String text)</span>{</span><br><span class=line>        <span class=type>String</span> <span class=variable>str</span> <span class=operator>=</span> text;</span><br><span class=line>        <span class=keyword>if</span> (str != <span class=literal>null</span>){</span><br><span class=line>            Iterator&LTString> iterator = <span class=built_in>this</span>.map.keySet().iterator();</span><br><span class=line>            <span class=keyword>while</span> (iterator.hasNext()){</span><br><span class=line>                <span class=type>String</span> <span class=variable>key</span> <span class=operator>=</span> iterator.next();</span><br><span class=line>                <span class=type>Object</span> <span class=variable>obj</span> <span class=operator>=</span> map.get(key);</span><br><span class=line>                str = str.replaceAll(key, obj.toString());</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> str;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">put</span><span class=params>(String key, Object value)</span>{</span><br><span class=line>        <span class=built_in>this</span>.map.put(key, value);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">clear</span><span class=params>(String key)</span>{</span><br><span class=line>        <span class=built_in>this</span>.map.remove(key);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">IExpressions</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">parse</span><span class=params>(Context context)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">interpret</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ListExpression</span> <span class=keyword>implements</span> <span class="title class_">IExpressions</span>{</span><br><span class=line>    <span class=keyword>private</span> Context context;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> ArrayList&LTIExpressions> list = <span class=keyword>new</span> <span class="title class_">ArrayList</span>&LTIExpressions>();</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">parse</span><span class=params>(Context context)</span> {</span><br><span class=line>        <span class=built_in>this</span>.context = context;</span><br><span class=line>        <span class=keyword>while</span> (<span class=literal>true</span>){</span><br><span class=line>            <span class=keyword>if</span> (<span class=built_in>this</span>.context.getCurrentToken() == <span class=literal>null</span>){</span><br><span class=line>                System.out.println(<span class=string>"Error: the experssion missing end! "</span>);</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            }<span class=keyword>else</span> <span class=keyword>if</span> (<span class=built_in>this</span>.context.equalsWithCommand(<span class=string>"END"</span>)){</span><br><span class=line>                <span class=built_in>this</span>.context.next();</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            }<span class=keyword>else</span> {</span><br><span class=line>                <span class=type>IExpressions</span> <span class=variable>expressions</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">CommandExperssion</span>(<span class=built_in>this</span>.context);</span><br><span class=line>                list.add(expressions);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">interpret</span><span class=params>()</span> {</span><br><span class=line>        Iterator&LTIExpressions> iterator = list.iterator();</span><br><span class=line>        <span class=keyword>while</span> (iterator.hasNext()){</span><br><span class=line>            iterator.next().interpret();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">PrimitiveExpression</span> <span class=keyword>implements</span> <span class="title class_">IExpressions</span>{</span><br><span class=line>    <span class=keyword>private</span> Context context;</span><br><span class=line>    <span class=keyword>private</span> String tokenName;</span><br><span class=line>    <span class=keyword>private</span> String text;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">PrimitiveExpression</span><span class=params>(Context context)</span>{</span><br><span class=line>        <span class=built_in>this</span>.parse(context);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">parse</span><span class=params>(Context context)</span> {</span><br><span class=line>        <span class=built_in>this</span>.context = context;</span><br><span class=line>        <span class=built_in>this</span>.tokenName = <span class=built_in>this</span>.context.getCurrentToken();</span><br><span class=line>        <span class=built_in>this</span>.context.next();</span><br><span class=line>        <span class=keyword>if</span> (<span class=string>"PRINTLN"</span>.equals(<span class=built_in>this</span>.tokenName)){</span><br><span class=line>            <span class=built_in>this</span>.text = <span class=built_in>this</span>.context.getCurrentToken();</span><br><span class=line>            <span class=built_in>this</span>.context.next();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">interpret</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>if</span> (<span class=string>"PRINTLN"</span>.equals(tokenName)){</span><br><span class=line>            System.out.println(<span class=built_in>this</span>.context.getTokenContext(<span class=built_in>this</span>.text));</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ProgramExpression</span> <span class=keyword>implements</span> <span class="title class_">IExpressions</span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> Context context;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>String</span> <span class=variable>COMMAND</span> <span class=operator>=</span> <span class=string>"PROGRAM"</span>;</span><br><span class=line>    <span class=keyword>private</span> IExpressions expressions;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ProgramExpression</span><span class=params>(String text)</span>{</span><br><span class=line>        <span class=built_in>this</span>.context = <span class=keyword>new</span> <span class="title class_">Context</span>(text);</span><br><span class=line>        <span class=built_in>this</span>.parse(<span class=built_in>this</span>.context);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">parse</span><span class=params>(Context context)</span> {</span><br><span class=line>        <span class=built_in>this</span>.context.next();</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">interpret</span><span class=params>()</span>{</span><br><span class=line>        <span class=keyword>if</span> (!<span class=built_in>this</span>.context.equalsWithCommand(COMMAND)){</span><br><span class=line>            System.out.println(<span class=string>"the "</span> + COMMAND + <span class=string>"is Excepted for start!"</span>);</span><br><span class=line>        }<span class=keyword>else</span> {</span><br><span class=line>            <span class=built_in>this</span>.context.next();</span><br><span class=line>            <span class=built_in>this</span>.expressions = <span class=keyword>new</span> <span class="title class_">ListExpression</span>();</span><br><span class=line>            <span class=built_in>this</span>.expressions.parse(<span class=built_in>this</span>.context);</span><br><span class=line>            <span class=built_in>this</span>.expressions.interpret();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ForExpression</span> <span class=keyword>implements</span> <span class="title class_">IExpressions</span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> Context context;</span><br><span class=line>    <span class=keyword>private</span> String variable;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> start_index;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> end_index;</span><br><span class=line>    <span class=keyword>private</span> IExpressions expressions;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ForExpression</span><span class=params>(Context context)</span>{</span><br><span class=line>        <span class=built_in>this</span>.context = context;</span><br><span class=line>        <span class=built_in>this</span>.parse(<span class=built_in>this</span>.context);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">parse</span><span class=params>(Context context)</span> {</span><br><span class=line>        <span class=built_in>this</span>.context.next();</span><br><span class=line>        <span class=keyword>while</span> (<span class=literal>true</span>){</span><br><span class=line>            <span class=keyword>if</span> (<span class=built_in>this</span>.context.equalsWithCommand(<span class=string>"FROM"</span>)){</span><br><span class=line>                <span class=type>String</span> <span class=variable>nextStr</span> <span class=operator>=</span> <span class=built_in>this</span>.context.next();</span><br><span class=line>                <span class=keyword>try</span> {</span><br><span class=line>                    <span class=built_in>this</span>.start_index = Integer.parseInt(nextStr);</span><br><span class=line>                }<span class=keyword>catch</span> (Exception e){</span><br><span class=line>                    e.printStackTrace();</span><br><span class=line>                    <span class=keyword>break</span>;</span><br><span class=line>                }</span><br><span class=line>                <span class=built_in>this</span>.context.next();</span><br><span class=line>            }<span class=keyword>else</span> <span class=keyword>if</span> (<span class=built_in>this</span>.context.equalsWithCommand(<span class=string>"TO"</span>)){</span><br><span class=line>                <span class=type>String</span> <span class=variable>nextStr</span> <span class=operator>=</span> <span class=built_in>this</span>.context.next();</span><br><span class=line>                <span class=keyword>try</span> {</span><br><span class=line>                    <span class=built_in>this</span>.end_index = Integer.parseInt(nextStr);</span><br><span class=line>                }<span class=keyword>catch</span> (Exception e){</span><br><span class=line>                    e.printStackTrace();</span><br><span class=line>                }</span><br><span class=line>                <span class=built_in>this</span>.context.next();</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            }<span class=keyword>else</span> {</span><br><span class=line>                <span class=keyword>if</span> (<span class=built_in>this</span>.variable == <span class=literal>null</span>){</span><br><span class=line>                    <span class=built_in>this</span>.variable = <span class=built_in>this</span>.context.getCurrentToken();</span><br><span class=line>                }</span><br><span class=line>                <span class=built_in>this</span>.context.next();</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=built_in>this</span>.expressions = <span class=keyword>new</span> <span class="title class_">ListExpression</span>();</span><br><span class=line>        <span class=built_in>this</span>.expressions.parse(<span class=built_in>this</span>.context);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">interpret</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>x</span> <span class=operator>=</span> <span class=built_in>this</span>.start_index; x < <span class=built_in>this</span>.end_index; x++){</span><br><span class=line>            <span class=built_in>this</span>.context.put(<span class=string>""</span> + <span class=built_in>this</span>.variable, x);</span><br><span class=line>            <span class=built_in>this</span>.expressions.interpret();</span><br><span class=line>        }</span><br><span class=line>        <span class=built_in>this</span>.context.clear(<span class=string>""</span> + <span class=built_in>this</span>.variable);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CommandExperssion</span> <span class=keyword>implements</span> <span class="title class_">IExpressions</span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> Context context;</span><br><span class=line>    <span class=keyword>private</span> IExpressions expressions;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">CommandExperssion</span><span class=params>(Context context)</span>{</span><br><span class=line>        <span class=built_in>this</span>.context = context;</span><br><span class=line>        <span class=built_in>this</span>.parse(<span class=built_in>this</span>.context);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">parse</span><span class=params>(Context context)</span> {</span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>this</span>.context.equalsWithCommand(<span class=string>"FOR"</span>)){</span><br><span class=line>            expressions = <span class=keyword>new</span> <span class="title class_">ForExpression</span>(<span class=built_in>this</span>.context);</span><br><span class=line>        }<span class=keyword>else</span>{</span><br><span class=line>            expressions = <span class=keyword>new</span> <span class="title class_">PrimitiveExpression</span>(<span class=built_in>this</span>.context);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">interpret</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>this</span>.expressions.interpret();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">InterpreterApp</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>String</span> <span class=variable>str</span> <span class=operator>=</span> <span class=string>"PROGRAM PRINTLN start... FOR i FROM 90 TO 100 PRINTLN i END PRINTLN end... END"</span>;</span><br><span class=line>        System.out.println(<span class=string>"str: "</span> + str);</span><br><span class=line>        <span class=type>IExpressions</span> <span class=variable>expressions</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ProgramExpression</span>(str);</span><br><span class=line>        expressions.interpret();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-8、Command（命令模式）><a class=headerlink href=#1-2-8、Command（命令模式） title=1.2.8、Command（命令模式）></a>1.2.8、Command（命令模式）</h3><h4 id=简介-11><a class=headerlink href=#简介-11 title=简介></a>简介</h4><p><strong>将请求以 命令形式 封装至对象A中，然后调用对象B将对象A传递给 能处理A对象中命令的 对象C，对象C拿到A对象后执行其中的命令。</strong><h4 id=何时使用-12><a class=headerlink href=#何时使用-12 title=何时使用></a>何时使用</h4><p>在某些场合，比如要对行为进行 “记录、撤销 / 重做、事务” 等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将 “行为请求者” 与 “行为实现者” 解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。<h4 id=优缺点-12><a class=headerlink href=#优缺点-12 title=优缺点></a>优缺点</h4><ul><li><p>优点</p> <ol><li>降低了系统耦合度。<li>新命令可以很容易添加到系统中去。</ol><li><p>缺点</p> <p>可能会导致某些系统有过多的具体命令类。</p></ul><h4 id=应用场景-11><a class=headerlink href=#应用场景-11 title=应用场景></a>应用场景</h4><ol><li>GUI 中每一个按钮都是一条命令。<li>模拟 CMD。</ol><h4 id=应用实例-12><a class=headerlink href=#应用实例-12 title=应用实例></a>应用实例</h4><p>struts 1 中 action 的核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层也会有对应不同的模型类，相当于具体的 Command。<h4 id=注意事项-12><a class=headerlink href=#注意事项-12 title=注意事项></a>注意事项</h4><p><font color=red>需要支持命令的撤销 (Undo) 操作和恢复 (Redo) 操作。</font><h4 id=代码实例-12><a class=headerlink href=#代码实例-12 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br></pre><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 邮局接口</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">IPost</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">sendMail</span><span class=params>(String msg)</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">IReceiver</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">readMail</span><span class=params>(String msg)</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 邮局实现</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Post</span> <span class=keyword>implements</span> <span class="title class_">IPost</span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> IReceiver receiver;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Post</span><span class=params>(IReceiver receiver)</span>{</span><br><span class=line>        <span class=built_in>this</span>.receiver = receiver;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">sendMail</span><span class=params>(String msg)</span> {</span><br><span class=line>        System.out.println(<span class=string>"邮局发送信件给收件人......"</span> );</span><br><span class=line>        <span class=built_in>this</span>.receiver.readMail(msg);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 发信人</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Invoker</span> {</span><br><span class=line>    <span class=keyword>private</span> IPost iPost;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setiPost</span><span class=params>(IPost iPost)</span> {</span><br><span class=line>        <span class=built_in>this</span>.iPost = iPost;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">postMail</span><span class=params>(String msg)</span> {</span><br><span class=line>        System.out.println(<span class=string>"发信人投递邮件给邮局......"</span>);</span><br><span class=line>        <span class=built_in>this</span>.iPost.sendMail(msg);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 接收人</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Receiver</span>  <span class=keyword>implements</span> <span class="title class_">IReceiver</span>{</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">readMail</span><span class=params>(String msg)</span>{</span><br><span class=line>        System.out.println(<span class=string>"收件人收到信件，开始读取消息: "</span> + msg);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CommandApp</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>Receiver</span> <span class=variable>receiver</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Receiver</span>();</span><br><span class=line>        <span class=type>IPost</span> <span class=variable>iPost</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Post</span>(receiver);</span><br><span class=line></span><br><span class=line>        <span class=type>Invoker</span> <span class=variable>invoker</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Invoker</span>();</span><br><span class=line>        invoker.setiPost(iPost);</span><br><span class=line>        invoker.postMail(<span class=string>"好久不见，近来如何？"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-9、State（状态模式）><a class=headerlink href=#1-2-9、State（状态模式） title=1.2.9、State（状态模式）></a>1.2.9、State（状态模式）</h3><h4 id=简介-12><a class=headerlink href=#简介-12 title=简介></a>简介</h4><p><strong>状态模式下 会创建各种状态对象 和 一个会随状态对象改变而改变其行为的context对象。</strong><h4 id=何时使用-13><a class=headerlink href=#何时使用-13 title=何时使用></a>何时使用</h4><p>代码中包含大量与对象状态有关的条件语句。<h4 id=优缺点-13><a class=headerlink href=#优缺点-13 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>封装了转换规则。<li>枚举可能的状态，在枚举状态之前需要确定状态种类。<li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。<li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。<li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</ol><li>缺点<ol><li>状态模式的使用必然会增加系统类和对象的个数。<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。<li>状态模式对 “开闭原则” 的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</ol></ul><h4 id=应用场景-12><a class=headerlink href=#应用场景-12 title=应用场景></a>应用场景</h4><ol><li>行为随状态改变而改变的场景。<li>条件、分支语句的代替者。</ol><h4 id=应用实例-13><a class=headerlink href=#应用实例-13 title=应用实例></a>应用实例</h4><ol><li>打篮球的时候运动员可以有正常状态. 不正常状态和超常状态。<li>‘曾侯乙编钟’是具体环境(Context)，钟是抽象接口，钟 A是具体状态。</ol><h4 id=注意事项-13><a class=headerlink href=#注意事项-13 title=注意事项></a>注意事项</h4><p><font color=red>行为受状态约束时使用状态模式，而且状态不超过 5 个。</font><h4 id=代码实例-13><a class=headerlink href=#代码实例-13 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Context</span> {</span><br><span class=line>    <span class=keyword>private</span> State state;</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Context</span><span class=params>(String name)</span> {</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setState</span><span class=params>(State state)</span> {</span><br><span class=line>        <span class=built_in>this</span>.state = state;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> State <span class="title function_">getState</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>this</span>.state;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">State</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doAction</span><span class=params>(Context context)</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DeductState</span> <span class=keyword>implements</span> <span class="title class_">State</span> {</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">toString</span><span class=params>()</span>{</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"Deduct State"</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doAction</span><span class=params>(Context context)</span> {</span><br><span class=line>        System.out.println(<span class=string>"商品卖出，准备减库存"</span>);</span><br><span class=line>        context.setState(<span class=built_in>this</span>);</span><br><span class=line></span><br><span class=line>        <span class=comment>//... 执行减库存的具体操作</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RevertState</span> <span class=keyword>implements</span> <span class="title class_">State</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doAction</span><span class=params>(Context context)</span> {</span><br><span class=line>        System.out.println(<span class=string>"给此商品补库存"</span>);</span><br><span class=line>        context.setState(<span class=built_in>this</span>);</span><br><span class=line></span><br><span class=line>        <span class=comment>//... 执行加库存的具体操作</span></span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">toString</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"Revert State"</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">StateApp</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=comment>// 我们需要操作的是 iPhone X</span></span><br><span class=line>        <span class=type>Context</span> <span class=variable>context</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Context</span>(<span class=string>"iPhone X"</span>);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 看看怎么进行补库存操作</span></span><br><span class=line>        <span class=type>State</span> <span class=variable>revertState</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">RevertState</span>();</span><br><span class=line>        revertState.doAction(context);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 同样的，减库存操作也非常简单</span></span><br><span class=line>        <span class=type>State</span> <span class=variable>deductState</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">DeductState</span>();</span><br><span class=line>        deductState.doAction(context);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 如果需要我们可以获取当前的状态</span></span><br><span class=line>        <span class=comment>// context.getState().toString();</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-10、Visitor（访问者模式）><a class=headerlink href=#1-2-10、Visitor（访问者模式） title=1.2.10、Visitor（访问者模式）></a>1.2.10、Visitor（访问者模式）</h3><h4 id=简介-13><a class=headerlink href=#简介-13 title=简介></a>简介</h4><p><strong>元素类的执行算法可以随着访问者改变而改变。访问者对象可以处理元素对象上的操作。</strong><h4 id=何时使用-14><a class=headerlink href=#何时使用-14 title=何时使用></a>何时使用</h4><p>对一个对象执行多种不同操作，且要避免这些操作影响对象关联的类，可以使用该模式将这些操作封装到类中。<h4 id=优缺点-14><a class=headerlink href=#优缺点-14 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>符合单一职责原则。<li>优秀的扩展性。<li>灵活性。</ol><li>缺点<ol><li>具体元素对访问者公布细节，违反了迪米特原则。<li>具体元素变更比较困难。<li>违反了依赖倒置原则，依赖具体类，没有依赖抽象。</ol></ul><h4 id=应用场景-13><a class=headerlink href=#应用场景-13 title=应用场景></a>应用场景</h4><ol><li>对象对应的类很少改变，但需要在对象上添加新操作。<li>需要对一个对象执行多种不同操作，且要避免这些操作影响对象对应的类，且在添加新操作时也不想修改该类的场景；</ol><h4 id=应用实例-14><a class=headerlink href=#应用实例-14 title=应用实例></a>应用实例</h4><p>你去朋友家做客，您是访问者，朋友接受您的访问，然后对朋友的描述做出一个判断，这就是访问者模式。<h4 id=注意事项-14><a class=headerlink href=#注意事项-14 title=注意事项></a>注意事项</h4><p><font color=red>访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。</font><h4 id=代码实例-14><a class=headerlink href=#代码实例-14 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br><span class=line>105</span><br><span class=line>106</span><br><span class=line>107</span><br><span class=line>108</span><br><span class=line>109</span><br><span class=line>110</span><br><span class=line>111</span><br><span class=line>112</span><br><span class=line>113</span><br><span class=line>114</span><br><span class=line>115</span><br><span class=line>116</span><br><span class=line>117</span><br><span class=line>118</span><br><span class=line>119</span><br><span class=line>120</span><br><span class=line>121</span><br><span class=line>122</span><br><span class=line>123</span><br><span class=line>124</span><br><span class=line>125</span><br><span class=line>126</span><br><span class=line>127</span><br><span class=line>128</span><br><span class=line>129</span><br><span class=line>130</span><br><span class=line>131</span><br><span class=line>132</span><br><span class=line>133</span><br><span class=line>134</span><br><span class=line>135</span><br><span class=line>136</span><br><span class=line>137</span><br><span class=line>138</span><br><span class=line>139</span><br><span class=line>140</span><br><span class=line>141</span><br><span class=line>142</span><br><span class=line>143</span><br><span class=line>144</span><br><span class=line>145</span><br><span class=line>146</span><br><span class=line>147</span><br><span class=line>148</span><br><span class=line>149</span><br><span class=line>150</span><br><span class=line>151</span><br><span class=line>152</span><br><span class=line>153</span><br><span class=line>154</span><br><span class=line>155</span><br><span class=line>156</span><br><span class=line>157</span><br><span class=line>158</span><br><span class=line>159</span><br><span class=line>160</span><br><span class=line>161</span><br><span class=line>162</span><br><span class=line>163</span><br><span class=line>164</span><br><span class=line>165</span><br><span class=line>166</span><br><span class=line>167</span><br><span class=line>168</span><br><span class=line>169</span><br><span class=line>170</span><br><span class=line>171</span><br><span class=line>172</span><br><span class=line>173</span><br><span class=line>174</span><br><span class=line>175</span><br><span class=line>176</span><br><span class=line>177</span><br><span class=line>178</span><br><span class=line>179</span><br><span class=line>180</span><br><span class=line>181</span><br><span class=line>182</span><br><span class=line>183</span><br><span class=line>184</span><br><span class=line>185</span><br><span class=line>186</span><br><span class=line>187</span><br><span class=line>188</span><br></pre><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 访问者接口</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">IVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(Manager manager)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(Employees employees)</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 计算薪资访问者</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">ISalaryVisitor</span> <span class=keyword>extends</span> <span class="title class_">IVisitor</span>{</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">printManagerTotalSalary</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">printEmployeesTotalSalary</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">printTotalSalary</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 抽象员工类</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">Staff</span> {</span><br><span class=line>    <span class=keyword>protected</span> String no;</span><br><span class=line>    <span class=keyword>protected</span> String name;</span><br><span class=line>    <span class=keyword>protected</span> String position;</span><br><span class=line>    <span class=keyword>protected</span> <span class=type>float</span> salary;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> length;</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Staff</span><span class=params>(String no, String name, String position, <span class=type>float</span> salary)</span> {</span><br><span class=line>        <span class=built_in>this</span>.no = no;</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>        <span class=built_in>this</span>.position = position;</span><br><span class=line>        <span class=built_in>this</span>.salary = salary;</span><br><span class=line></span><br><span class=line>        <span class=built_in>this</span>.length += (no == <span class=literal>null</span> || <span class=string>""</span>.equals(no.trim())) ? <span class=number>0</span> : no.getBytes().length;</span><br><span class=line>        <span class=built_in>this</span>.length += (no == <span class=literal>null</span> || <span class=string>""</span>.equals(name.trim())) ? <span class=number>0</span> : name.getBytes().length;</span><br><span class=line>        <span class=built_in>this</span>.length += (no == <span class=literal>null</span> || <span class=string>""</span>.equals(position.trim())) ? <span class=number>0</span> : position.getBytes().length;</span><br><span class=line>        <span class=built_in>this</span>.length += String.valueOf(salary).getBytes().length;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">printUserBaseInfo</span><span class=params>()</span>{</span><br><span class=line>        System.out.println(<span class=built_in>this</span>.no + <span class=string>"/"</span> + <span class=built_in>this</span>.name + <span class=string>"/"</span> + <span class=built_in>this</span>.position + <span class=string>"/"</span> + <span class=built_in>this</span>.salary);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">add</span><span class=params>(Staff staff)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> Staff <span class="title function_">remove</span><span class=params>(String no)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">accept</span><span class=params>(IVisitor visitor)</span>;</span><br><span class=line></span><br><span class=line>	<span class=comment>// set/get methods ...</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Manager</span> <span class=keyword>extends</span> <span class="title class_">Staff</span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> ArrayList&LTStaff> staffList = <span class=keyword>new</span> <span class="title class_">ArrayList</span>&LTStaff>();</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Manager</span><span class=params>(String no, String name, String position, <span class=type>float</span> salary)</span>{</span><br><span class=line>        <span class=built_in>super</span>(no, name, position, salary);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">add</span><span class=params>(Staff staff)</span> {</span><br><span class=line>        <span class=built_in>this</span>.staffList.add(staff);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Staff <span class="title function_">remove</span><span class=params>(String no)</span> {</span><br><span class=line>        <span class=type>Staff</span> <span class=variable>staff</span> <span class=operator>=</span> <span class=literal>null</span>;</span><br><span class=line>        <span class=keyword>if</span> (no != <span class=literal>null</span> && !<span class=string>""</span>.equals(no.trim())){</span><br><span class=line>            <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < <span class=built_in>this</span>.staffList.size(); i++){</span><br><span class=line>                <span class=keyword>if</span> (<span class=built_in>this</span>.staffList.get(i) == <span class=literal>null</span>){</span><br><span class=line>                    <span class=keyword>continue</span>;</span><br><span class=line>                }</span><br><span class=line>                <span class=keyword>if</span> (no.equals(<span class=built_in>this</span>.staffList.get(i).getNo())){</span><br><span class=line>                    staff = <span class=built_in>this</span>.staffList.remove(i);</span><br><span class=line>                    <span class=keyword>break</span>;</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> staff;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">accept</span><span class=params>(IVisitor visitor)</span> {</span><br><span class=line>        visitor.visit(<span class=built_in>this</span>);</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < <span class=built_in>this</span>.staffList.size(); i++){</span><br><span class=line>            <span class=keyword>if</span> (<span class=built_in>this</span>.staffList.get(i) == <span class=literal>null</span>){</span><br><span class=line>                <span class=keyword>continue</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=built_in>this</span>.staffList.get(i).accept(visitor);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Employees</span> <span class=keyword>extends</span> <span class="title class_">Staff</span>{</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Employees</span><span class=params>(String no, String name, String position, <span class=type>float</span> salary)</span>{</span><br><span class=line>        <span class=built_in>super</span>(no, name, position, salary);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">add</span><span class=params>(Staff staff)</span> {</span><br><span class=line>        <span class=keyword>return</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Staff <span class="title function_">remove</span><span class=params>(String no)</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">accept</span><span class=params>(IVisitor visitor)</span> {</span><br><span class=line>        visitor.visit(<span class=built_in>this</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 打印基本信息访问者</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">PrintBaseInfoVisitor</span> <span class=keyword>implements</span> <span class="title class_">IVisitor</span>{</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(Manager manager)</span> {</span><br><span class=line>        System.out.print(<span class=string>"管理者: "</span>);</span><br><span class=line>        manager.printUserBaseInfo();</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(Employees employees)</span> {</span><br><span class=line>        System.out.print(<span class=string>"普通员工: "</span>);</span><br><span class=line>        employees.printUserBaseInfo();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SalaryVisitor</span> <span class=keyword>implements</span> <span class="title class_">ISalaryVisitor</span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=type>float</span> managerSalary;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>float</span> employeesSalary;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">SalaryVisitor</span><span class=params>()</span>{</span><br><span class=line>        managerSalary = <span class=number>0</span>;</span><br><span class=line>        employeesSalary = <span class=number>0</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">printManagerTotalSalary</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"管理者薪资总和："</span> + managerSalary);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">printEmployeesTotalSalary</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"一般员工薪资总和："</span> + employeesSalary);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">printTotalSalary</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"员工薪资总和："</span> + (managerSalary + employeesSalary));</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(Manager manager)</span> {</span><br><span class=line>        managerSalary += manager.getSalary();</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(Employees employees)</span> {</span><br><span class=line>        employeesSalary += employees.getSalary();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">VisitorApp</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>Staff</span> <span class=variable>boss</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Manager</span>(<span class=string>"1"</span>, <span class=string>"大老板"</span>, <span class=string>"CEO"</span>, <span class=number>100000</span>);</span><br><span class=line></span><br><span class=line>        <span class=type>Staff</span> <span class=variable>financeManager</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Manager</span>(<span class=string>"11"</span>, <span class=string>"张总"</span>, <span class=string>"财务部经理"</span>, <span class=number>60000</span>);</span><br><span class=line>        <span class=type>Staff</span> <span class=variable>personnelManager</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Manager</span>(<span class=string>"12"</span>, <span class=string>"王总"</span>, <span class=string>"人事部经理"</span>, <span class=number>60000</span>);</span><br><span class=line></span><br><span class=line>        <span class=type>Staff</span> <span class=variable>technicalManager</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Manager</span>(<span class=string>"13"</span>, <span class=string>"陈总"</span>, <span class=string>"技术部经理"</span>, <span class=number>60000</span>);</span><br><span class=line>        <span class=type>Staff</span> <span class=variable>deptAssistant</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Manager</span>(<span class=string>"1301"</span>, <span class=string>"王助理"</span>, <span class=string>"技术部助理"</span>, <span class=number>20000</span>);</span><br><span class=line>        <span class=type>Staff</span> <span class=variable>deptManager1</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Manager</span>(<span class=string>"1302"</span>, <span class=string>"主管1"</span>, <span class=string>"技术部主管"</span>, <span class=number>30000</span>);</span><br><span class=line>        <span class=type>Staff</span> <span class=variable>softwareEngineer1</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Employees</span>(<span class=string>"1302001"</span>, <span class=string>"张三"</span>, <span class=string>"软件工程师"</span>, <span class=number>5000</span>);</span><br><span class=line>        <span class=type>Staff</span> <span class=variable>softwareEngineer2</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Employees</span>(<span class=string>"1302002"</span>, <span class=string>"李四"</span>, <span class=string>"软件工程师"</span>, <span class=number>5500</span>);</span><br><span class=line>        <span class=type>Staff</span> <span class=variable>softwareEngineer3</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Employees</span>(<span class=string>"1302003"</span>, <span class=string>"王五"</span>, <span class=string>"软件工程师"</span>, <span class=number>4500</span>);</span><br><span class=line></span><br><span class=line>        deptManager1.add(softwareEngineer1);</span><br><span class=line>        deptManager1.add(softwareEngineer2);</span><br><span class=line>        deptManager1.add(softwareEngineer3);</span><br><span class=line></span><br><span class=line>        <span class=type>Staff</span> <span class=variable>deptManager2</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Manager</span>(<span class=string>"1302"</span>, <span class=string>"主管2"</span>, <span class=string>"技术部主管"</span>, <span class=number>30000</span>);</span><br><span class=line>        technicalManager.add(deptAssistant);</span><br><span class=line>        technicalManager.add(deptManager1);</span><br><span class=line>        technicalManager.add(deptManager2);</span><br><span class=line></span><br><span class=line>        <span class=type>Staff</span> <span class=variable>marketingManager</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Manager</span>(<span class=string>"14"</span>, <span class=string>"吴总"</span>, <span class=string>"市场部经理"</span>, <span class=number>60000</span>);</span><br><span class=line></span><br><span class=line>        boss.add(financeManager);</span><br><span class=line>        boss.add(personnelManager);</span><br><span class=line>        boss.add(technicalManager);</span><br><span class=line>        boss.add(marketingManager);</span><br><span class=line></span><br><span class=line>        boss.printUserBaseInfo();</span><br><span class=line>        boss.accept(<span class=keyword>new</span> <span class="title class_">PrintBaseInfoVisitor</span>());</span><br><span class=line></span><br><span class=line>        <span class=type>SalaryVisitor</span> <span class=variable>visitor</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SalaryVisitor</span>();</span><br><span class=line>        boss.accept(visitor);</span><br><span class=line>        visitor.printManagerTotalSalary();</span><br><span class=line>        visitor.printEmployeesTotalSalary();</span><br><span class=line>        visitor.printTotalSalary();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-11、Memento（备忘录模式）><a class=headerlink href=#1-2-11、Memento（备忘录模式） title=1.2.11、Memento（备忘录模式）></a>1.2.11、Memento（备忘录模式）</h3><h4 id=简介-14><a class=headerlink href=#简介-14 title=简介></a>简介</h4><p><strong>在不破坏封装性的前提下捕获一个对象的内部状态，并将该状态存于对象外。后续可恢复对象至该状态；</strong><h4 id=何时使用-15><a class=headerlink href=#何时使用-15 title=何时使用></a>何时使用</h4><p>用户需要取消不确定或者错误的操作时，能够恢复到他原先的状态，使得他有 “后悔药” 可吃。<h4 id=优缺点-15><a class=headerlink href=#优缺点-15 title=优缺点></a>优缺点</h4><ul><li><p>优点</p> <ol><li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。<li>实现了信息的封装，使得用户不需要关心状态的保存细节。</ol><li><p>缺点</p> <p>消耗资源。类成员数量多导致占用大量资源，且保存时会占用内存。</p></ul><h4 id=应用场景-14><a class=headerlink href=#应用场景-14 title=应用场景></a>应用场景</h4><ol><li>需要保存 / 恢复数据的相关状态场景。<li>提供一个可回滚的操作。</ol><h4 id=应用实例-15><a class=headerlink href=#应用实例-15 title=应用实例></a>应用实例</h4><ol><li>后悔药。<li>打游戏时的存档。<li>Windows 里的 ctri + z。<li>IE 中的后退。<li>数据库的事务管理。</ol><h4 id=注意事项-15><a class=headerlink href=#注意事项-15 title=注意事项></a>注意事项</h4><ol><li><font color=red>为了符合迪米特原则，还要增加一个管理备忘录的类。</font><li><font color=red>为了节约内存，可使用原型模式 + 备忘录模式。</font></ol><h4 id=代码实例-15><a class=headerlink href=#代码实例-15 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">INarrowMemento</span> {</span><br><span class=line></span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Hero</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> blood;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> sword;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> <span class=type>Random</span> <span class=variable>random</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Random</span>();</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Hero</span><span class=params>()</span>{</span><br><span class=line>        <span class=built_in>this</span>.blood = <span class=number>100</span>;</span><br><span class=line>        <span class=built_in>this</span>.sword = <span class=number>100</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> INarrowMemento <span class="title function_">createMemento</span><span class=params>()</span>{</span><br><span class=line>        System.out.println(<span class=string>"创建备忘录..."</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">Memento</span>(<span class=built_in>this</span>.blood, <span class=built_in>this</span>.sword);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">restoreFromMemento</span><span class=params>(INarrowMemento memento)</span>{</span><br><span class=line>        System.out.println(<span class=string>"修改备忘录的状态..."</span>);</span><br><span class=line>        <span class=keyword>if</span> (memento != <span class=literal>null</span>){</span><br><span class=line>            <span class=type>Memento</span> <span class=variable>memento2</span> <span class=operator>=</span> (Memento) memento;</span><br><span class=line>            <span class=built_in>this</span>.blood = memento2.getBlood();</span><br><span class=line>            <span class=built_in>this</span>.sword = memento2.getSword();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">koBoss</span><span class=params>()</span>{</span><br><span class=line>        <span class=keyword>if</span> (<span class=built_in>this</span>.blood <= <span class=number>0</span> || <span class=built_in>this</span>.sword <= <span class=number>0</span>){</span><br><span class=line>            System.out.println(<span class=built_in>this</span>.toString());</span><br><span class=line>            System.out.println(<span class=string>"挑战BOSS失败！！！"</span>);</span><br><span class=line>            <span class=keyword>return</span> -<span class=number>1</span>;</span><br><span class=line>        }<span class=keyword>else</span> {</span><br><span class=line>            <span class=type>double</span> <span class=variable>win</span> <span class=operator>=</span> Math.random();</span><br><span class=line>            <span class=keyword>if</span> (win <= <span class=number>0.02</span>){</span><br><span class=line>                System.out.println(<span class=built_in>this</span>.toString());</span><br><span class=line>                System.out.println(<span class=string>"恭喜您，挑战BOSS成功。"</span>);</span><br><span class=line>                <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>            }<span class=keyword>else</span> {</span><br><span class=line>                System.out.println(<span class=built_in>this</span>.toString());</span><br><span class=line>                System.out.println(<span class=string>"继续攻击BOSS..."</span>);</span><br><span class=line>                <span class=type>int</span> <span class=variable>blood_sub</span> <span class=operator>=</span> random.nextInt(<span class=number>10</span>);</span><br><span class=line>                <span class=type>int</span> <span class=variable>sword_sub</span> <span class=operator>=</span> random.nextInt(<span class=number>10</span>);</span><br><span class=line>                <span class=built_in>this</span>.blood -= blood_sub;</span><br><span class=line>                <span class=built_in>this</span>.sword -= sword_sub;</span><br><span class=line>                <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">toString</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"当前血量："</span> + <span class=built_in>this</span>.blood + <span class=string>", 当前力量："</span> + <span class=built_in>this</span>.sword;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>class</span> <span class="title class_">Memento</span> <span class=keyword>implements</span> <span class="title class_">INarrowMemento</span>{</span><br><span class=line>        <span class=keyword>private</span> <span class=type>int</span> blood;</span><br><span class=line>        <span class=keyword>private</span> <span class=type>int</span> sword;</span><br><span class=line>        <span class=keyword>public</span> <span class="title function_">Memento</span><span class=params>(<span class=type>int</span> blood, <span class=type>int</span> sword)</span>{</span><br><span class=line>            <span class=built_in>this</span>.blood = blood;</span><br><span class=line>            <span class=built_in>this</span>.sword = sword;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">getBlood</span><span class=params>()</span> {</span><br><span class=line>            <span class=keyword>return</span> blood;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">getSword</span><span class=params>()</span> {</span><br><span class=line>            <span class=keyword>return</span> sword;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Caretaker</span> {</span><br><span class=line>    <span class=keyword>private</span> INarrowMemento memento;</span><br><span class=line>    <span class=keyword>public</span> INarrowMemento <span class="title function_">getMemento</span><span class=params>()</span>{</span><br><span class=line>        <span class=keyword>return</span> memento;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setMemento</span><span class=params>(INarrowMemento memento)</span> {</span><br><span class=line>        <span class=built_in>this</span>.memento = memento;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MementoOfBlackApp</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>Hero</span> <span class=variable>hero</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Hero</span>();</span><br><span class=line>        <span class=type>Caretaker</span> <span class=variable>caretaker</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Caretaker</span>();</span><br><span class=line>        caretaker.setMemento(hero.createMemento());</span><br><span class=line>        <span class=type>int</span> <span class=variable>cnt</span> <span class=operator>=</span> <span class=number>1</span>;</span><br><span class=line>        <span class=type>int</span> <span class=variable>ko</span> <span class=operator>=</span> -<span class=number>1</span>;</span><br><span class=line>        <span class=keyword>while</span> (ko != <span class=number>1</span> && cnt <= <span class=number>3</span>){</span><br><span class=line>            System.out.println(<span class=string>"第 "</span> + cnt + <span class=string>" 次挑战！"</span>);</span><br><span class=line>            ko = hero.koBoss();</span><br><span class=line>            <span class=keyword>while</span> (<span class=literal>true</span>){</span><br><span class=line>                <span class=keyword>if</span> (ko == -<span class=number>1</span>){</span><br><span class=line>                    hero.restoreFromMemento(caretaker.getMemento());</span><br><span class=line>                    cnt += <span class=number>1</span>;</span><br><span class=line>                    <span class=keyword>break</span>;</span><br><span class=line>                }<span class=keyword>else</span> <span class=keyword>if</span> (ko == <span class=number>0</span>){</span><br><span class=line>                    ko = hero.koBoss();</span><br><span class=line>                }<span class=keyword>else</span> <span class=keyword>if</span> (ko == <span class=number>1</span>){</span><br><span class=line>                    <span class=keyword>break</span>;</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=1-3、结构型（7种）><a class=headerlink href=#1-3、结构型（7种） title=1.3、结构型（7种）></a>1.3、结构型（7种）</h2><h3 id=1-3-1、Composite（组合模式）><a class=headerlink href=#1-3-1、Composite（组合模式） title=1.3.1、Composite（组合模式）></a>1.3.1、Composite（组合模式）</h3><h4 id=简介-15><a class=headerlink href=#简介-15 title=简介></a>简介</h4><p><strong>将对象组合成树形结构以表示 部分和整体 的层次结构。它使得客户对单个对象和复合对象的使用具有一致性</strong>。<h4 id=何时使用-16><a class=headerlink href=#何时使用-16 title=何时使用></a>何时使用</h4><ol><li>想表示对象部分 - 整体的层次结构（树形结构）。<li>忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</ol><h5 id=优缺点-16><a class=headerlink href=#优缺点-16 title=优缺点></a>优缺点</h5><ul><li><p>优点</p> <ol><li>高层模块调用简单。<li>节点自由增加。</ol><li><p>缺点</p> <p>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p></ul><h4 id=应用场景-15><a class=headerlink href=#应用场景-15 title=应用场景></a>应用场景</h4><p>部分. 整体场景，如树形菜单，文件. 文件夹的管理。<h4 id=应用实例-16><a class=headerlink href=#应用实例-16 title=应用实例></a>应用实例</h4><ol><li>算术表达式包括操作数. 操作符和另一个操作数，其中，另一个操作符也可以是操作数. 操作符和另一个操作数。<li>在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</ol><h4 id=注意事项-16><a class=headerlink href=#注意事项-16 title=注意事项></a>注意事项</h4><p><font color=red>定义时 为 具体类。</font><h4 id=代码实例-16><a class=headerlink href=#代码实例-16 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.ArrayList;</span><br><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Employee</span> {</span><br><span class=line>    <span class=keyword>private</span> String name;</span><br><span class=line>    <span class=keyword>private</span> String dept;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> salary;</span><br><span class=line>    <span class=keyword>private</span> List&LTEmployee> subordinates; <span class=comment>// 下属</span></span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Employee</span><span class=params>(String name,String dept, <span class=type>int</span> sal)</span> {</span><br><span class=line>        <span class=built_in>this</span>.name = name;</span><br><span class=line>        <span class=built_in>this</span>.dept = dept;</span><br><span class=line>        <span class=built_in>this</span>.salary = sal;</span><br><span class=line>        subordinates = <span class=keyword>new</span> <span class="title class_">ArrayList</span>&LTEmployee>();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">add</span><span class=params>(Employee e)</span> {</span><br><span class=line>        subordinates.add(e);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">remove</span><span class=params>(Employee e)</span> {</span><br><span class=line>        subordinates.remove(e);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> List&LTEmployee> <span class="title function_">getSubordinates</span><span class=params>()</span>{</span><br><span class=line>        <span class=keyword>return</span> subordinates;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">toString</span><span class=params>()</span>{</span><br><span class=line>        <span class=keyword>return</span> (<span class=string>"Employee :[ Name : "</span> + name + <span class=string>", dept : "</span> + dept + <span class=string>", salary :"</span> + salary+<span class=string>" ]"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-3-2、Facade（外观模式）><a class=headerlink href=#1-3-2、Facade（外观模式） title=1.3.2、Facade（外观模式）></a>1.3.2、Facade（外观模式）</h3><h4 id=简介-16><a class=headerlink href=#简介-16 title=简介></a>简介</h4><p><strong>为子系统内部一系列小接口提供一个高层接口，通过高层接口来统一访问操作系统，提高了使用子系统的便利性；</strong><h4 id=何时使用-17><a class=headerlink href=#何时使用-17 title=何时使用></a>何时使用</h4><ol><li>无需知道系统内部，只需提供一个系统 “接待员” 即可。<li>定义系统的入口。</ol><h4 id=优缺点-17><a class=headerlink href=#优缺点-17 title=优缺点></a>优缺点</h4><ul><li><p>优点</p> <ol><li>减少系统相互依赖。<li>提高灵活性。<li>提高了安全性。</ol><li><p>缺点</p> <p>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p></ul><h4 id=应用场景-16><a class=headerlink href=#应用场景-16 title=应用场景></a>应用场景</h4><ol><li>为复杂的模块或子系统提供外界访问的模块。<li>子系统相对独立。<li>预防低水平人员带来的风险。</ol><h4 id=应用实例-17><a class=headerlink href=#应用实例-17 title=应用实例></a>应用实例</h4><ol><li>去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。<li>JAVA 的三层开发模式。</ol><h4 id=注意事项-17><a class=headerlink href=#注意事项-17 title=注意事项></a>注意事项</h4><p><font color=red>在层次化结构中，可以使用外观模式定义系统每一层的入口。</font><h4 id=代码实例-17><a class=headerlink href=#代码实例-17 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Shape</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">draw</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Circle</span> <span class=keyword>implements</span> <span class="title class_">Shape</span>{</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">draw</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Circle::draw()"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Rectangle</span> <span class=keyword>implements</span> <span class="title class_">Shape</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">draw</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"Rectangle::draw()"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">FacadeApp</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=comment>// 画一个圆形</span></span><br><span class=line>        <span class=type>Shape</span> <span class=variable>circle</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Circle</span>();</span><br><span class=line>        circle.draw();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 画一个长方形</span></span><br><span class=line>        <span class=type>Shape</span> <span class=variable>rectangle</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Rectangle</span>();</span><br><span class=line>        rectangle.draw();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ShapeMaker</span> {</span><br><span class=line>    <span class=keyword>private</span> Shape circle;</span><br><span class=line>    <span class=keyword>private</span> Shape rectangle;</span><br><span class=line>    <span class=keyword>private</span> Shape square;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ShapeMaker</span><span class=params>()</span> {</span><br><span class=line>        circle = <span class=keyword>new</span> <span class="title class_">Circle</span>();</span><br><span class=line>        rectangle = <span class=keyword>new</span> <span class="title class_">Rectangle</span>();</span><br><span class=line>        square = <span class=keyword>new</span> <span class="title class_">Square</span>();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">drawCircle</span><span class=params>()</span>{</span><br><span class=line>        circle.draw();</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">drawRectangle</span><span class=params>()</span>{</span><br><span class=line>        rectangle.draw();</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">drawSquare</span><span class=params>()</span>{</span><br><span class=line>        square.draw();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ShapeMakerApp</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>ShapeMaker</span> <span class=variable>shapeMaker</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ShapeMaker</span>();</span><br><span class=line>        <span class=comment>// 客户端调用现在更加清晰了</span></span><br><span class=line>        shapeMaker.drawCircle();</span><br><span class=line>        shapeMaker.drawRectangle();</span><br><span class=line>        shapeMaker.drawSquare();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-3-3、Proxy（代理模式）><a class=headerlink href=#1-3-3、Proxy（代理模式） title=1.3.3、Proxy（代理模式）></a>1.3.3、Proxy（代理模式）</h3><h4 id=简介-17><a class=headerlink href=#简介-17 title=简介></a>简介</h4><p><strong>为某个动作生成一个代理，用来控制对目标对象的访问。</strong><h4 id=实现-2><a class=headerlink href=#实现-2 title=实现></a>实现</h4><ul><li>静态代理<li>动态代理</ul><h4 id=何时使用-18><a class=headerlink href=#何时使用-18 title=何时使用></a>何时使用</h4><p>想在访问一个类时做一些控制。<h4 id=优缺点-18><a class=headerlink href=#优缺点-18 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>职责清晰。<li>高扩展性。<li>智能化。</ol><li>缺点<ol><li>由于增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。<li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</ol></ul><h4 id=应用场景-17><a class=headerlink href=#应用场景-17 title=应用场景></a>应用场景</h4><ol><li>远程代理。<li>虚拟代理。<li>Copy-on-Write 代理。<li>保护（Protect or Access）代理。<li>Cache 代理。<li>防火墙（Firewall）代理。<li>同步化（Synchronization）代理。<li>智能引用（Smart Reference）代理。</ol><h4 id=应用实例-18><a class=headerlink href=#应用实例-18 title=应用实例></a>应用实例</h4><ol><li>Windows 中的快捷方式。<li>猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。<li>买火车票不一定在火车站买，也可以去代售点。<li>一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。<li>spring aop。</ol><h4 id=注意事项-18><a class=headerlink href=#注意事项-18 title=注意事项></a>注意事项</h4><ol><li><font color=red>与适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</font><li><font color=red>与装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</font></ol><h4 id=代码实例-18><a class=headerlink href=#代码实例-18 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">Food</span> {</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">setChicken</span><span class=params>(String chicken)</span> { }</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">setSpicy</span><span class=params>(String spicy)</span> { }</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">setNoodle</span><span class=params>(String noodle)</span> { }</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">setSalt</span><span class=params>(String salt)</span> { }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">FoodService</span> {</span><br><span class=line>    Food <span class="title function_">makeChicken</span><span class=params>()</span>;</span><br><span class=line>    Food <span class="title function_">makeNoodle</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">FoodServiceImpl</span> <span class=keyword>implements</span> <span class="title class_">FoodService</span>{</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Food <span class="title function_">makeChicken</span><span class=params>()</span> {</span><br><span class=line>        <span class=type>Food</span> <span class=variable>f</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Chicken</span>();</span><br><span class=line>        f.setChicken(<span class=string>"1kg"</span>);</span><br><span class=line>        f.setSpicy(<span class=string>"1g"</span>);</span><br><span class=line>        f.setSalt(<span class=string>"3g"</span>);</span><br><span class=line>        <span class=keyword>return</span> f;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Food <span class="title function_">makeNoodle</span><span class=params>()</span> {</span><br><span class=line>        <span class=type>Food</span> <span class=variable>f</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Noodle</span>();</span><br><span class=line>        f.setNoodle(<span class=string>"500g"</span>);</span><br><span class=line>        f.setSalt(<span class=string>"5g"</span>);</span><br><span class=line>        <span class=keyword>return</span> f;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Chicken</span> <span class=keyword>extends</span> <span class="title class_">Food</span>{</span><br><span class=line>    <span class=keyword>private</span> String chicken;</span><br><span class=line>    <span class=keyword>private</span> String spicy;</span><br><span class=line>    <span class=keyword>private</span> String salt;</span><br><span class=line>	</span><br><span class=line>    <span class=comment>// set/get methods... </span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Noodle</span> <span class=keyword>extends</span> <span class="title class_">Food</span>{</span><br><span class=line>    <span class=keyword>private</span> String noodle;</span><br><span class=line>    <span class=keyword>private</span> String salt;</span><br><span class=line></span><br><span class=line>    <span class=comment>// set/get methods...</span></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">FoodServiceProxy</span> <span class=keyword>implements</span> <span class="title class_">FoodService</span> {</span><br><span class=line>    <span class=comment>// 内部一定要有一个真实的实现类，当然也可以通过构造方法注入</span></span><br><span class=line>    <span class=keyword>private</span> <span class=type>FoodService</span> <span class=variable>foodService</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">FoodServiceImpl</span>();</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> Food <span class="title function_">makeChicken</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"我们马上要开始制作鸡肉了"</span>);</span><br><span class=line></span><br><span class=line>        <span class=comment>// 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，</span></span><br><span class=line>        <span class=comment>// 代理只是在核心代码前后做些“无足轻重”的事情</span></span><br><span class=line>        <span class=type>Food</span> <span class=variable>food</span> <span class=operator>=</span> foodService.makeChicken();</span><br><span class=line></span><br><span class=line>        System.out.println(<span class=string>"鸡肉制作完成啦，加点胡椒粉"</span>); <span class=comment>// 增强</span></span><br><span class=line>        food.addCondiment(<span class=string>"pepper"</span>);</span><br><span class=line></span><br><span class=line>        <span class=keyword>return</span> food;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> Food <span class="title function_">makeNoodle</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"准备制作拉面~"</span>);</span><br><span class=line>        <span class=type>Food</span> <span class=variable>food</span> <span class=operator>=</span> foodService.makeNoodle();</span><br><span class=line>        System.out.println(<span class=string>"制作完成啦"</span>);</span><br><span class=line>        <span class=keyword>return</span> food;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ProxyApp</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>FoodService</span> <span class=variable>foodService</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">FoodServiceProxy</span>();</span><br><span class=line>        foodService.makeChicken();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-3-4、Adpter（适配器模式）><a class=headerlink href=#1-3-4、Adpter（适配器模式） title=1.3.4、Adpter（适配器模式）></a>1.3.4、Adpter（适配器模式）</h3><h4 id=简介-18><a class=headerlink href=#简介-18 title=简介></a>简介</h4><p>Adapter模式可以使得 不兼容的接口变得兼容。<h4 id=实现-3><a class=headerlink href=#实现-3 title=实现></a>实现</h4><ul><li>Object Adapter<li>Class Adapter</ul><h4 id=何时使用-19><a class=headerlink href=#何时使用-19 title=何时使用></a>何时使用</h4><ol><li>系统需要使用现有的类，而此类的接口不符合系统需要。<li>想要建立一个可以重复使用的类，可以使得不兼容的类变得兼容起来。<li>通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</ol><h4 id=优缺点-19><a class=headerlink href=#优缺点-19 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>可以让任何两个没有关联的类一起运行。<li>提高了类的复用。<li>增加了类的透明度。<li>灵活性好。</ol><li>缺点<ol><li>过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。<li>由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</ol></ul><h4 id=应用场景-18><a class=headerlink href=#应用场景-18 title=应用场景></a>应用场景</h4><ol><li>希望使用某些现有类，但接口与代码不兼容时，可以使用适配器模式。<li>希望重用几个现有子类，这些子类缺少一些不能添加到超类中的公共功能时，可以使用适配器模式。</ol><h4 id=应用实例-19><a class=headerlink href=#应用实例-19 title=应用实例></a>应用实例</h4><ol><li>美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。<li>JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。<li>在 LINUX 上运行 WINDOWS 程序。 4. JAVA 中的 jdbc。</ol><h4 id=源码应用-4><a class=headerlink href=#源码应用-4 title=源码应用></a>源码应用</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>java.util.Arrays#asList();</span><br><span class=line>java.util.Collections#list();</span><br><span class=line>org.springframework.context.event.GenericApplicationListenerAdapter</span><br></pre></table></figure><h4 id=注意事项-19><a class=headerlink href=#注意事项-19 title=注意事项></a>注意事项</h4><p><font color=red>适配器不是在详细设计时添加的，而是解决正在服役的项目问题。</font><h4 id=代码实例-19><a class=headerlink href=#代码实例-19 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br></pre><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 适配器模式</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * 简介：</span></span><br><span class=line><span class=comment> *      GOF是这样给适配器模式(Adapter)定义的：将一个类的接口转化成用户需要的</span></span><br><span class=line><span class=comment> *      另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类</span></span><br><span class=line><span class=comment> *      可以一起工作。</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * 实现方式-包含以下角色：</span></span><br><span class=line><span class=comment> *      Target：目标抽象类</span></span><br><span class=line><span class=comment> *      Adapter：适配器类</span></span><br><span class=line><span class=comment> *      Adaptee：适配者类</span></span><br><span class=line><span class=comment> *      Client：客户类</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> * 优缺点：</span></span><br><span class=line><span class=comment> *      - 优点：将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者</span></span><br><span class=line><span class=comment> *             类，而无须修改原有代码。</span></span><br><span class=line><span class=comment> *             增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客</span></span><br><span class=line><span class=comment> *             户端类来说是透明的，而且提高了适配者的复用性。</span></span><br><span class=line><span class=comment> *             灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配</span></span><br><span class=line><span class=comment> *             器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开</span></span><br><span class=line><span class=comment> *             闭原则”。</span></span><br><span class=line><span class=comment> *      - 缺点：过多地使用适配器，会让系统非常零乱，不易整体进行把握。</span></span><br><span class=line><span class=comment> *             对于类适配器而言，由于 JAVA 至多继承一个类，所以至多只能适配一</span></span><br><span class=line><span class=comment> *             个适配者类，而且目标类必须是抽象类</span></span><br><span class=line><span class=comment> *</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">App</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>Iphone6Plus</span> <span class=variable>iphone6Plus</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Iphone6Plus</span>(<span class=keyword>new</span> <span class="title class_">AppleCharger</span>());</span><br><span class=line>        iphone6Plus.charge();</span><br><span class=line></span><br><span class=line>        System.out.println(<span class=string>"=============================="</span>);</span><br><span class=line></span><br><span class=line>        <span class=type>GalaxyS7</span> <span class=variable>galaxyS7</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">GalaxyS7</span>(<span class=keyword>new</span> <span class="title class_">AndroidCharger</span>());</span><br><span class=line>        galaxyS7.charge();</span><br><span class=line></span><br><span class=line>        System.out.println(<span class=string>"=============================="</span>);</span><br><span class=line></span><br><span class=line>        <span class=type>Adapter</span> <span class=variable>adapter</span>  <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Adapter</span>(<span class=keyword>new</span> <span class="title class_">AndroidCharger</span>());</span><br><span class=line>        <span class=type>Iphone6Plus</span> <span class=variable>newIphone</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Iphone6Plus</span>();</span><br><span class=line>        newIphone.setLightningInterface(adapter);</span><br><span class=line>        newIphone.charge();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-3-5、Decorator（装饰模式）><a class=headerlink href=#1-3-5、Decorator（装饰模式） title=1.3.5、Decorator（装饰模式）></a>1.3.5、Decorator（装饰模式）</h3><h4 id=简介-19><a class=headerlink href=#简介-19 title=简介></a>简介</h4><p><strong>动态地给一个对象添加一些额外职责</strong>。<h4 id=何时使用-20><a class=headerlink href=#何时使用-20 title=何时使用></a>何时使用</h4><p>既想扩展类，又不想通过子类的方式实现。<h4 id=优缺点-20><a class=headerlink href=#优缺点-20 title=优缺点></a>优缺点</h4><ul><li><p>优点</p> <ol><li>不改变原有对象的情况下给一个对象扩展功能。<li>使用不同的组合可以实现不同的效果。<li>符合开闭原则。</ol><li><p>缺点</p> <p>多层装饰比较复杂。</p></ul><h4 id=应用场景-19><a class=headerlink href=#应用场景-19 title=应用场景></a>应用场景</h4><ol><li>扩展一个类的功能。<li>动态增加功能，动态撤销。</ol><h4 id=应用实例-20><a class=headerlink href=#应用实例-20 title=应用实例></a>应用实例</h4><ol><li>孙悟空有 72 变，当他变成 “庙宇” 后，他的根本还是一只猴子，但是他又有了庙宇的功能。<li>不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</ol><h4 id=源码中的应用-1><a class=headerlink href=#源码中的应用-1 title=源码中的应用></a>源码中的应用</h4><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>Servlet API</span><br><span class=line>javax.servlet.http.HttpServletRequestWrapper</span><br><span class=line>javax.servlet.http.HttpServletResponseWrapper</span><br></pre></table></figure><h4 id=注意事项-20><a class=headerlink href=#注意事项-20 title=注意事项></a>注意事项</h4><p><font color=red>可代替继承。</font><h4 id=代码实例-20><a class=headerlink href=#代码实例-20 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">Beverage</span> {</span><br><span class=line>    <span class=comment>// 返回描述</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> String <span class="title function_">getDescription</span><span class=params>()</span>;</span><br><span class=line>    <span class=comment>// 返回价格</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> <span class=type>double</span> <span class="title function_">cost</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BlackTea</span> <span class=keyword>extends</span> <span class="title class_">Beverage</span> {</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getDescription</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"红茶"</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>double</span> <span class="title function_">cost</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=number>10</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">GreenTea</span> <span class=keyword>extends</span> <span class="title class_">Beverage</span> {</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getDescription</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"绿茶"</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>double</span> <span class="title function_">cost</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=number>11</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 调料</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">Condiment</span> <span class=keyword>extends</span> <span class="title class_">Beverage</span> {</span><br><span class=line></span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Mango</span> <span class=keyword>extends</span> <span class="title class_">Condiment</span> {</span><br><span class=line>    <span class=keyword>private</span> Beverage bevarage;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Mango</span><span class=params>(Beverage bevarage)</span> {</span><br><span class=line>        <span class=built_in>this</span>.bevarage = bevarage;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getDescription</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> bevarage.getDescription() + <span class=string>", 加芒果"</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>double</span> <span class="title function_">cost</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> bevarage.cost() + <span class=number>3</span>; <span class=comment>// 加芒果需要 3 元</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Lemon</span> <span class=keyword>extends</span> <span class="title class_">Condiment</span> {</span><br><span class=line>    <span class=keyword>private</span> Beverage bevarage;</span><br><span class=line>    <span class=comment>// 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，</span></span><br><span class=line>    <span class=comment>// 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶</span></span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">Lemon</span><span class=params>(Beverage bevarage)</span> {</span><br><span class=line>        <span class=built_in>this</span>.bevarage = bevarage;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getDescription</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// 装饰</span></span><br><span class=line>        <span class=keyword>return</span> bevarage.getDescription() + <span class=string>", 加柠檬"</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=type>double</span> <span class="title function_">cost</span><span class=params>()</span> {</span><br><span class=line>        <span class=comment>// 装饰</span></span><br><span class=line>        <span class=keyword>return</span> bevarage.cost() + <span class=number>2</span>; <span class=comment>// 加柠檬需要 2 元</span></span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DecoratorApp</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=comment>// 首先，我们需要一个基础饮料，红茶、绿茶或咖啡</span></span><br><span class=line>        <span class=type>Beverage</span> <span class=variable>beverage</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">GreenTea</span>();</span><br><span class=line>        <span class=comment>// 开始装饰</span></span><br><span class=line>        beverage = <span class=keyword>new</span> <span class="title class_">Lemon</span>(beverage); <span class=comment>// 先加一份柠檬</span></span><br><span class=line>        beverage = <span class=keyword>new</span> <span class="title class_">Mango</span>(beverage); <span class=comment>// 再加一份芒果</span></span><br><span class=line></span><br><span class=line>        System.out.println(beverage.getDescription() + <span class=string>" 价格：￥"</span> + beverage.cost());</span><br><span class=line>        <span class=comment>//"绿茶, 加柠檬, 加芒果 价格：￥16"</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-3-6、Bridge（桥接模式）><a class=headerlink href=#1-3-6、Bridge（桥接模式） title=1.3.6、Bridge（桥接模式）></a>1.3.6、Bridge（桥接模式）</h3><h4 id=简介-20><a class=headerlink href=#简介-20 title=简介></a>简介</h4><p><strong>将抽象与实现分离，使它们都可以独立地变化</strong>。<h4 id=何时使用-21><a class=headerlink href=#何时使用-21 title=何时使用></a>何时使用</h4><p>系统的实现有多个方案，每一种都可能变化。<h4 id=优缺点-21><a class=headerlink href=#优缺点-21 title=优缺点></a>优缺点</h4><ul><li><p>优点</p> <ol><li>抽象和实现的分离。<li>优秀的扩展能力。<li>实现细节对客户透明。</ol><li><p>缺点</p> <p>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p></ul><h4 id=应用场景-20><a class=headerlink href=#应用场景-20 title=应用场景></a>应用场景</h4><ol><li>不希望在抽象类和它的实现之间有一个固定的绑定关系；<li>类的抽象和实现都应该可以通过生成子类的方法加以扩充；<li>对一个抽象的实现部分的修改应对客户不产生影响，即客户代码无需重新编译；</ol><h4 id=应用实例-21><a class=headerlink href=#应用实例-21 title=应用实例></a>应用实例</h4><ol><li>猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。<li>墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。</ol><h4 id=注意事项-21><a class=headerlink href=#注意事项-21 title=注意事项></a>注意事项</h4><p><font color=red>对于两个独立变化的维度，使用桥接模式非常合适。</font><h4 id=代码实例-21><a class=headerlink href=#代码实例-21 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br><span class=line>101</span><br><span class=line>102</span><br><span class=line>103</span><br><span class=line>104</span><br><span class=line>105</span><br><span class=line>106</span><br></pre><td class=code><pre><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 电灯接口</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">ILight</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">electricConnected</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">light</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">electricClosed</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 开关顶层类</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BaseSwitch</span> {</span><br><span class=line>    <span class=keyword>protected</span> ILight light;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">BaseSwitch</span><span class=params>(ILight light)</span>{</span><br><span class=line>        <span class=built_in>this</span>.light = light;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>void</span> <span class="title function_">makeLight</span><span class=params>()</span>{</span><br><span class=line>        <span class=built_in>this</span>.light.electricConnected();</span><br><span class=line>        <span class=built_in>this</span>.light.light();</span><br><span class=line>        <span class=built_in>this</span>.light.electricClosed();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 遥控开关</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoteControISwitch</span> <span class=keyword>extends</span> <span class="title class_">BaseSwitch</span>{</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RemoteControISwitch</span><span class=params>(ILight light)</span>{</span><br><span class=line>        <span class=built_in>super</span>(light);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>void</span> <span class="title function_">makeRemoteLight</span><span class=params>(<span class=type>int</span> operColor)</span>{</span><br><span class=line>        <span class=built_in>this</span>.light.electricConnected();</span><br><span class=line>        <span class=built_in>this</span>.light.light();</span><br><span class=line>        <span class=type>String</span> <span class=variable>color</span> <span class=operator>=</span> <span class=string>""</span>;</span><br><span class=line>        <span class=keyword>switch</span> (operColor){</span><br><span class=line>            <span class=keyword>case</span> <span class=number>1</span>:</span><br><span class=line>                color = <span class=string>"暖色"</span>;</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            <span class=keyword>case</span> <span class=number>2</span>:</span><br><span class=line>                color = <span class=string>"蓝色"</span>;</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            <span class=keyword>case</span> <span class=number>3</span>:</span><br><span class=line>                color = <span class=string>"红色"</span>;</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            <span class=keyword>default</span>:</span><br><span class=line>                color = <span class=string>"白色"</span>;</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>        }</span><br><span class=line>        System.out.println(<span class=string>"当前灯光颜色为："</span> + color);</span><br><span class=line>        <span class=built_in>this</span>.light.electricClosed();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 白炽灯实现</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">IncandescentLight</span> <span class=keyword>implements</span> <span class="title class_">ILight</span>{</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">electricConnected</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"白炽灯被打开了！"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">light</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"白炽灯在照明！"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">electricClosed</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"白炽灯被关闭了！"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">CrystalLight</span> <span class=keyword>implements</span> <span class="title class_">ILight</span>{</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">electricConnected</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"水晶灯被打开了！"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">light</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"水晶灯在照明！"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">electricClosed</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"水晶灯被关闭了！"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BridgeApp</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>ILight</span> <span class=variable>incandescentLight</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">IncandescentLight</span>();</span><br><span class=line>        <span class=type>ILight</span> <span class=variable>crystalLight</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">CrystalLight</span>();</span><br><span class=line></span><br><span class=line>        <span class=type>BaseSwitch</span> <span class=variable>baseSwitch</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">BaseSwitch</span>(incandescentLight);</span><br><span class=line>        baseSwitch.makeLight();</span><br><span class=line></span><br><span class=line>        System.out.println(<span class=string>"--------------------------"</span>);</span><br><span class=line></span><br><span class=line>        <span class=type>RemoteControISwitch</span> <span class=variable>controISwitch</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">RemoteControISwitch</span>(crystalLight);</span><br><span class=line>        controISwitch.makeRemoteLight(<span class=number>1</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-3-7、Flyweight（享元模式）><a class=headerlink href=#1-3-7、Flyweight（享元模式） title=1.3.7、Flyweight（享元模式）></a>1.3.7、Flyweight（享元模式）</h3><h4 id=简介-21><a class=headerlink href=#简介-21 title=简介></a>简介</h4><p>主要用于减少创建对象的数量，减少内存占用以提高性能。该模式会尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。<h4 id=何时使用-22><a class=headerlink href=#何时使用-22 title=何时使用></a>何时使用</h4><ol><li>系统中有大量对象。<li>这些对象消耗大量内存。<li>这些对象的状态大部分可以外部化。<li>这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中拿出来时，每组对象都可用一个对象来代替。<li>系统不依赖于对象身份，因对象不可分辨。</ol><h4 id=优缺点-22><a class=headerlink href=#优缺点-22 title=优缺点></a>优缺点</h4><ul><li>优点：减少对象创建，降低内存消耗，效率提高。<li>缺点：提高了系统复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统混乱。</ul><h4 id=应用场景-21><a class=headerlink href=#应用场景-21 title=应用场景></a>应用场景</h4><ol><li>系统有大量相似对象。<li>需要缓冲池的场景。</ol><h4 id=应用实例-22><a class=headerlink href=#应用实例-22 title=应用实例></a>应用实例</h4><ol><li>JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。<li>数据库的数据池。</ol><h4 id=源码应用-5><a class=headerlink href=#源码应用-5 title=源码应用></a>源码应用</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>String / Integer / Long....</span><br><span class=line>com.sun.org.apache.bcel.internal.generic.InstructionConstants</span><br></pre></table></figure><h4 id=注意事项-22><a class=headerlink href=#注意事项-22 title=注意事项></a>注意事项</h4><ol><li><font color=red>注意划分外部状态和内部状态，否则可能会引起线程安全问题。</font><li><font color=red>这些类必须有一个工厂对象加以控制。</font></ol><h4 id=代码实例-22><a class=headerlink href=#代码实例-22 title=代码实例></a>代码实例</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">AbstractChessman</span> {</span><br><span class=line>    <span class=keyword>protected</span> <span class=type>int</span> x;</span><br><span class=line>    <span class=keyword>protected</span> <span class=type>int</span> y;</span><br><span class=line>    <span class=keyword>protected</span> String chess;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AbstractChessman</span><span class=params>(String chess)</span>{</span><br><span class=line>        <span class=built_in>this</span>.chess = chess;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">point</span><span class=params>(<span class=type>int</span> x, <span class=type>int</span> y)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">show</span><span class=params>()</span>{</span><br><span class=line>        System.out.println(<span class=built_in>this</span>.chess + <span class=string>": "</span> + <span class=built_in>this</span>.x + <span class=string>"/"</span> + <span class=built_in>this</span>.y);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">BlackChessman</span> <span class=keyword>extends</span> <span class="title class_">AbstractChessman</span>{</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">BlackChessman</span><span class=params>()</span>{</span><br><span class=line>        <span class=built_in>super</span>(<span class=string>"."</span>);</span><br><span class=line>        System.out.println(<span class=string>"BlackChessman construction exec!"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">point</span><span class=params>(<span class=type>int</span> x, <span class=type>int</span> y)</span> {</span><br><span class=line>        <span class=built_in>this</span>.x = x;</span><br><span class=line>        <span class=built_in>this</span>.y = y;</span><br><span class=line>        <span class=built_in>this</span>.show();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">WhiteChessman</span> <span class=keyword>extends</span> <span class="title class_">AbstractChessman</span>{</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">WhiteChessman</span><span class=params>()</span>{</span><br><span class=line>        <span class=built_in>super</span>(<span class=string>"o"</span>);</span><br><span class=line>        System.out.println(<span class=string>"WhiteChessman construction exec!"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">point</span><span class=params>(<span class=type>int</span> x, <span class=type>int</span> y)</span> {</span><br><span class=line>        <span class=built_in>this</span>.x = x;</span><br><span class=line>        <span class=built_in>this</span>.y = y;</span><br><span class=line>        <span class=built_in>this</span>.show();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">FiveChessmanFactory</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>FiveChessmanFactory</span> <span class=variable>fiveChessmanFactory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">FiveChessmanFactory</span>();</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> Hashtable&LTCharacter, AbstractChessman> cache = <span class=keyword>new</span> <span class="title class_">Hashtable</span>&LTCharacter, AbstractChessman>();</span><br><span class=line>    <span class=keyword>private</span> <span class="title function_">FiveChessmanFactory</span><span class=params>()</span>{</span><br><span class=line></span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> FiveChessmanFactory <span class="title function_">getInstance</span><span class=params>()</span>{</span><br><span class=line>        <span class=keyword>return</span> fiveChessmanFactory;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> AbstractChessman <span class="title function_">getChessmanObject</span><span class=params>(<span class=type>char</span> c)</span>{</span><br><span class=line>        <span class=type>AbstractChessman</span> <span class=variable>chessman</span> <span class=operator>=</span> <span class=built_in>this</span>.cache.get(c);</span><br><span class=line>        <span class=keyword>if</span> (chessman == <span class=literal>null</span>){</span><br><span class=line>            <span class=keyword>switch</span> (c){</span><br><span class=line>                <span class=keyword>case</span> <span class=string>'B'</span>:</span><br><span class=line>                    chessman = <span class=keyword>new</span> <span class="title class_">BlackChessman</span>();</span><br><span class=line>                    <span class=keyword>break</span>;</span><br><span class=line>                <span class=keyword>case</span> <span class=string>'W'</span>:</span><br><span class=line>                    chessman = <span class=keyword>new</span> <span class="title class_">WhiteChessman</span>();</span><br><span class=line>                    <span class=keyword>break</span>;</span><br><span class=line>                <span class=keyword>default</span>:</span><br><span class=line>                    <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (chessman != <span class=literal>null</span>){</span><br><span class=line>                <span class=built_in>this</span>.cache.put(c, chessman);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> chessman;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">FlyweightApp</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>FiveChessmanFactory</span> <span class=variable>fiveChessmanFactory</span> <span class=operator>=</span> FiveChessmanFactory.getInstance();</span><br><span class=line>        </span><br><span class=line>        <span class=type>Random</span> <span class=variable>random</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Random</span>();</span><br><span class=line>        <span class=type>int</span> <span class=variable>radom</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>        <span class=type>AbstractChessman</span> <span class=variable>abstractChessman</span> <span class=operator>=</span> <span class=literal>null</span>;</span><br><span class=line>        </span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < <span class=number>10</span>; i++){</span><br><span class=line>            radom = random.nextInt(<span class=number>2</span>);</span><br><span class=line>            <span class=keyword>switch</span> (radom){</span><br><span class=line>                <span class=keyword>case</span> <span class=number>0</span>:</span><br><span class=line>                    abstractChessman = fiveChessmanFactory.getChessmanObject(<span class=string>'B'</span>);</span><br><span class=line>                    <span class=keyword>break</span>;</span><br><span class=line>                <span class=keyword>case</span> <span class=number>1</span>:</span><br><span class=line>                    abstractChessman = fiveChessmanFactory.getChessmanObject(<span class=string>'W'</span>);</span><br><span class=line>                    <span class=keyword>break</span>;</span><br><span class=line>            }</span><br><span class=line>            <span class=keyword>if</span> (abstractChessman != <span class=literal>null</span>){</span><br><span class=line>                abstractChessman.point(i, random.nextInt(<span class=number>15</span>));</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=1-4、设计模式间的关系><a class=headerlink href=#1-4、设计模式间的关系 title=1.4、设计模式间的关系></a>1.4、设计模式间的关系</h2><p><img alt=设计模式间的关系 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210420203056818.png?token=AIGEF3L6P4ZSWPM3RWVOD3LEZZZVE><h1 id=2、设计模式原则><a class=headerlink href=#2、设计模式原则 title=2、设计模式原则></a>2、设计模式原则</h1><h2 id=2-1、开闭原则（OCP）><a class=headerlink href=#2-1、开闭原则（OCP） title=2.1、开闭原则（OCP）></a>2.1、开闭原则（OCP）</h2><h3 id=2-1-1、简介><a class=headerlink href=#2-1-1、简介 title=2.1.1、简介></a>2.1.1、简介</h3><p><strong>开闭原则规定：软件中的对象（类，模块，函数等）对于扩展应该开放，对于修改应该封闭。</strong>也就是说，应该在不修改类源代码前提下来更改类的行为。<h3 id=2-1-2、分类><a class=headerlink href=#2-1-2、分类 title=2.1.2、分类></a>2.1.2、分类</h3><ul><li><p><strong>梅耶开闭原则</strong></p> <p>梅耶原则 提倡继承实现。具体实现可以通过继承来重用，但是接口规格不必如此。已存在的实现对于修改是封闭的，但是新的实现不必实现原有接口。</p><li><p><strong>多态开闭原则</strong></p> <p>多态开闭原则 倡导继承抽象类。接口规约可以通过继承来重用，但是实现不必如此。已存在的接口对于修改是封闭的，并且新的实现必须至少实现那个接口。</p></ul><h2 id=2-2、单一职责原则（SRP）><a class=headerlink href=#2-2、单一职责原则（SRP） title=2.2、单一职责原则（SRP）></a>2.2、单一职责原则（SRP）</h2><h3 id=2-2-1、简介><a class=headerlink href=#2-2-1、简介 title=2.2.1、简介></a>2.2.1、简介</h3><p>面向对象五个基本原则（SOLID）之一。<p><strong>单一职责原则（SRP：Single responsibility principle）又称单一功能原则。该原则规定：一个类或者模块应该有且只有一个改变原因。</strong><p>单一职责原则由罗伯特·C·马丁（Robert C. Martin）于《敏捷软件开发：原则、模式和实践》一书中给出。马丁表示此原则是基于汤姆·狄马克(Tom DeMarco)和Meilir Page-Jones的=著作中的 内聚性原则 来实现。<p><strong>所谓职责是指类变化的原因。如果类改变的原因多于一个，那就违反了该职责。</strong><h3 id=2-2-2、问题由来><a class=headerlink href=#2-2-2、问题由来 title=2.2.2、问题由来></a>2.2.2、问题由来</h3><p>之所以会出现单一职责原则就是因为在软件设计时会出现以下类似场景：<p>T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。也就是说职责P1和P2耦合在了一起。<h3 id=2-2-3、产生原因><a class=headerlink href=#2-2-3、产生原因 title=2.2.3、产生原因></a>2.2.3、产生原因</h3><p>很多耦合常常发生在不经意之间，原因就是 职责扩散：因为某种原因，某一职责被分化为颗粒度更细多个职责。<h3 id=2-2-4、解决方法><a class=headerlink href=#2-2-4、解决方法 title=2.2.4、解决方法></a>2.2.4、解决方法</h3><p>遵守单一职责原则，将不同的职责封装到不同的类或模块中。<h2 id=2-3、依赖倒置原则（DIP）><a class=headerlink href=#2-3、依赖倒置原则（DIP） title=2.3、依赖倒置原则（DIP）></a>2.3、依赖倒置原则（DIP）</h2><h3 id=2-3-1、简介><a class=headerlink href=#2-3-1、简介 title=2.3.1、简介></a>2.3.1、简介</h3><p><strong>开闭原则的基础。依赖倒置原则（Dependence Inversion Principle）是指：程序要依赖于抽象接口，不要依赖于具体实现。</strong>简单说就是一定要面向抽象编程，而不要面向实现编程，这样就降低了客户与实现模块间的耦合。<h3 id=2-3-2、意图><a class=headerlink href=#2-3-2、意图 title=2.3.2、意图></a>2.3.2、意图</h3><p><strong>面向过程开发，上层调用下层，上层依赖于下层，当下层剧烈变动时上层也要跟着变动，这就会降低模块的复用性且大大提高了开发成本</strong><p>面向对象开发解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。<h3 id=2-3-3、注意事项><a class=headerlink href=#2-3-3、注意事项 title=2.3.3、注意事项></a>2.3.3、注意事项</h3><ol><li>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。<li>抽象不应该依赖于具体，而是具体应该依赖于抽象。</ol><h2 id=2-4、接口隔离原则（ISP）><a class=headerlink href=#2-4、接口隔离原则（ISP） title=2.4、接口隔离原则（ISP）></a>2.4、接口隔离原则（ISP）</h2><h3 id=2-4-1、简介><a class=headerlink href=#2-4-1、简介 title=2.4.1、简介></a>2.4.1、简介</h3><p>接口隔离原则（Interface Segregation Principle，ISP）是面向对象设计中的一个原则，它强调的是 <strong>客户端不应该依赖它不需要的接口，将臃肿的接口拆分为更小、更具体的接口，避免接口的冗余</strong>。<p>接口隔离原则的核心思想是 <strong>定义接口时要精简、单一，不应该包含不需要的方法，这样可以减少类与接口之间的耦合，提高代码可读性、可维护性、可扩展性</strong>。<p>接口隔离原则可以参考如下几点来实现：<ul><li>将庞大的接口拆分为多个小接口。<li>根据需要只使用特定的接口。<li>接口的职责要单一。</ul><h3 id=2-4-2、优点><a class=headerlink href=#2-4-2、优点 title=2.4.2、优点></a>2.4.2、优点</h3><p>接口隔离原则可以使得系统的接口设计更加灵活、可扩展和易于维护。能降低类与接口之间的耦合度，减少不必要的依赖关系，使得系统的各个模块能够独立地发展与演化。<h2 id=2-5、里氏替换原则（LSP）><a class=headerlink href=#2-5、里氏替换原则（LSP） title=2.5、里氏替换原则（LSP）></a>2.5、里氏替换原则（LSP）</h2><h3 id=2-5-1、简介><a class=headerlink href=#2-5-1、简介 title=2.5.1、简介></a>2.5.1、简介</h3><p>里氏代换原则（Liskov Substitution Principle LSP）是指：<strong>基类可以出现的地方，子类也可以出现</strong>。<p>LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。<em><strong>里氏代换原则是对“开闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化</strong></em>。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。<h3 id=2-5-2、注意事项><a class=headerlink href=#2-5-2、注意事项 title=2.5.2、注意事项></a>2.5.2、注意事项</h3><p><strong>设计时，尽量继承抽象类，而不要继承具体类。</strong>如果从继承等级树来看，所有叶子节点应当是具体类，而所有的树枝节点应当是抽象类或者接口。当然这只是一般性的指导原则，使用时还需具体情况具体分析。<p>简单的理解为一个软件实体如果使用的是一个父类，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，软件里面，把父类都替换成它的子类，程序的行为没有变化。<h2 id=2-6、迪米特原则（LOD）><a class=headerlink href=#2-6、迪米特原则（LOD） title=2.6、迪米特原则（LOD）></a>2.6、迪米特原则（LOD）</h2><h3 id=2-6-1、简介><a class=headerlink href=#2-6-1、简介 title=2.6.1、简介></a>2.6.1、简介</h3><p>迪米特原则（Law Of Demeter）也被称为最少知道原则，是面向对象设计中的一个原则。迪米特原则的核心思想是 <strong>降低对象之间的耦合，使得对象之间的通信变得简单和直接</strong>。<p>迪米特原则的目标是 实现高内聚、低耦合。具体包括如下几点：<ul><li>减少对象之间的耦合<li>保护对象的隐私<li>提高代码可维护性</ul><p>迪米特原则可以参考如下几个方面来实现：<ul><li>在类中尽量减少对其它类的引用，不应该直接引用与本类关系较远的类。<li>通过封装和信息隐藏，将对象的内部细节隐藏起来，只暴漏必要的接口。<li>使用中介者模式或外观模式来降低对象之间的直接依赖关系。</ul><h2 id=2-7、合成复用原则（CRP）><a class=headerlink href=#2-7、合成复用原则（CRP） title=2.7、合成复用原则（CRP）></a>2.7、合成复用原则（CRP）</h2><h3 id=2-7-1、简介><a class=headerlink href=#2-7-1、简介 title=2.7.1、简介></a>2.7.1、简介</h3><p>合成复用原则是设计模式中的一个原则，也称之为CRP原则。它指的是在软件设计中，<strong>优先使用对象组合而不是继承来实现代码的复用</strong>。<p>合成复用原则的核心思想是：<strong>通过将现有的对象组合成新的对象，实现代码复用和灵活性</strong>。相对于通过继承实现复用，使用对象组合可以更好的控制类之间的关系，且可以动态改变对象的行为。<h3 id=2-7-2、优点><a class=headerlink href=#2-7-2、优点 title=2.7.2、优点></a>2.7.2、优点</h3><p>合成复用有如下几个优点：<ul><li>减少类之间的耦合：继承会导致子类和父类之间的紧耦合，而对象组合可以在对象之间建立松散的关系，减少类之间的依赖。<li>提高系统灵活性：对象组合可以动态改变对象的行为，通过替换组合中的对象，可以灵活扩展和修改系统的功能。<li>更好地复用代码：组合现有对象，可以构建出具有不同功能的新对象，实现代码复用。<li>更好的维护：对象组合关系松散，需要修改系统行为时，可以更容易的定位和修改相关的对象。</ul></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=url>数据与算法系列-原码反码补码移码转换</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-06 09:14:28" datetime=2023-10-06T09:14:28+08:00 itemprop=dateModified>2023-10-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%AE%97%E6%B3%95/ itemprop=url rel=index><span itemprop=name>数据与算法</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=原码-反码-补码-移码><a class=headerlink href=#原码-反码-补码-移码 title=原码/反码/补码/移码></a>原码/反码/补码/移码</h1><h2 id=原码><a class=headerlink href=#原码 title=原码></a>原码</h2><p>原码是最简单机器数表示法。用最高位表示符号位，‘1’表示负号，‘0’表示正号。其它位存放该数的二进制的绝对值。<p>注意：<ol><li>数0的原码有两种形式： [+0]原=00000000B [-0]原=10000000B。<li>8位二进制原码的表示范围：-127～+127。</ol><h2 id=反码><a class=headerlink href=#反码 title=反码></a>反码</h2><p><strong>符号位0表示正，1表示负</strong>。正数的原码、反码、补码都一样。负数的反码等于原码按位数取反，（绝对值按位求反）。<p>步骤：先将这个负数化为原码，再根据原码取反。比如该负数原码是：00000001，那么它取反就是0 1111110。<h2 id=补码><a class=headerlink href=#补码 title=补码></a>补码</h2><p><strong>符号位0表示正，1表示负</strong>。正数的原码、反码、补码都一样。负数的补码等于反码末位加1，<p>步骤：先将这个负数化为原码再化为反码，末位加1。比如该负数的反码是11111110，那么它末位加1就是11111111。<h2 id=移码><a class=headerlink href=#移码 title=移码></a>移码</h2><p>负数的移码等于补码的符号（第一位数字）位取反。<p>步骤：先把这个数化为补码，然后再根据补码的第一位数字取反即可。（移码和补码的关系：同一数值的移码与补码符号位相反，其它各位相同。）<h2 id=小总结><a class=headerlink href=#小总结 title=小总结></a>小总结</h2><ol><li>正数的原码、反码、补码都相同；<li>负数的反码 就是 原码的各个位取反。<li>负数的补码 就是 反码末位加1。<li>负数的移码 就是 补码的符号位（第一位数字）取反。</ol></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=url>微服务系列-分布式事务</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 16:30:51" datetime=2023-10-02T16:30:51+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/ itemprop=url rel=index><span itemprop=name>分布式事务</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、事务概述><a class=headerlink href=#1、事务概述 title=1、事务概述></a>1、事务概述</h1><h2 id=1-1、何为事务><a class=headerlink href=#1-1、何为事务 title=1.1、何为事务></a>1.1、何为事务</h2><p><strong>数据库事务是指数据库执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成</strong>。<p>事务拥有以下四个特性，习惯上被称为ACID特性：<ul><li>**原子性(Atomicity)**：事务作为一个整体被执行，要么全部被执行，要么都不执行。<li>**一致性(Consistency)**：事务执行完毕后其数据的多个副本应保证最新且一致。<li>**隔离性(Isolation)**：一个事务的执行不能影响其它事务的执行。<li>**持久性(Durability)**：已提交事务对数据库的修改应准确同步至数据库。</ul><h2 id=1-2、本地事务><a class=headerlink href=#1-2、本地事务 title=1.2、本地事务></a>1.2、本地事务</h2><p>起初，事务 仅限于 单一数据库资源访问控制。架构服务化以后，事务的概念延伸到了服务中。若 将一个单一的服务操作作为一个事务，那么整个 服务操作 只能涉及 一个单一的数据库资源：<p><strong>基于单个服务、单一数据库资源访问的事务，被称为本地事务（Local Transaction）</strong>。<h2 id=1-3、分布式事务><a class=headerlink href=#1-3、分布式事务 title=1.3、分布式事务></a>1.3、分布式事务</h2><p>本地事务主要限制在单个会话内，不涉及多个数据库资源。但是在基于 SOA（Service-Oriented Architecture，面向服务架构）的分布式应用环境下，需要将多个数据库资源，多个服务访问都纳入到同一个事务当中，分布式事务应运而生。<h3 id=1-3-1、CAP理论><a class=headerlink href=#1-3-1、CAP理论 title=1.3.1、CAP理论></a>1.3.1、CAP理论</h3><p>CAP定理规定一个分布式系统不可能同时满足以下三点特性：<ul><li><p><strong>一致性（Consistercy）</strong></p> <p>一致性 是指 多个数据副本 保持最新且一致（多副本可能是单机上的多副本，也可能是多实例上的副本）。在一致性需求下，执行更新操作后，应该保证系统的数据仍然处于一致状态。</p><li><p><strong>可用性（Availability）</strong></p> <p>每次请求都能获取到正确的响应，但是不保证获取的数据为最新数据。</p><li><p><strong>分区容错性（Partition tolerance）</strong></p> <p>分布式系统在遇到任何网络分区故障时，仍然能够对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</p></ul><p>分布式系统最多只能同时满足 CAP理论中的两项。其中P必须，故只能在CP和AP中选择，zookeeper保证CP（一致性/分区容错），注册中心eruka保证AP（可用性/分区容错）。<h3 id=1-3-2、BASE理论><a class=headerlink href=#1-3-2、BASE理论 title=1.3.2、BASE理论></a>1.3.2、BASE理论</h3><p><strong>BASE是 Basically Available（基本可用）、Soft-state（软状态）和 Eventually Consistent（最终一致性）三个词语的缩写</strong>。<ul><li><p><strong>基本可用</strong></p> <p>分布式系统出现故障时，允许损失部分可用性（服务降级、页面降级）。</p><li><p><strong>软状态</strong></p> <p>允许分布式系统出现中间状态。中间状态 不影响 系统可用性。中间状态 是指 不同的data replication（数据备份节点）之间的数据更新可以出现延时的最终一致性。</p><li><p><strong>最终一致性</strong></p> <p>data replications经过一段时间后才达到一致性。</p></ul><p>BASE理论 是对 CAP中一致性和可用性 权衡的结果，核心思想：<strong>虽然无法达到强一致性，但可达到最终一致性</strong>。<h3 id=1-3-3、分布式事务分类><a class=headerlink href=#1-3-3、分布式事务分类 title=1.3.3、分布式事务分类></a>1.3.3、分布式事务分类</h3><p>分布式事务，本质上是对多个数据库的事务进行统一控制，按照控制力度可以分为：<ol><li>不控制：不控制就是不引入分布式事务；<li>部分控制：部分控制就是各种变种的两阶段提交，包括上面提到的 消息事务+最终一致性、TCC模式；<li>完全控制：完全实现两阶段提交；</ol><p>部分控制的好处是并发量和性能很好，缺点是数据一致性减弱了，完全控制则是牺牲了性能，保障了一致性，具体用哪种方式，最终还是取决于业务场景。<blockquote><p>技术为业务服务，根据不同业务选择合适的技术也是一种能力。</blockquote><h1 id=3、解决方案><a class=headerlink href=#3、解决方案 title=3、解决方案></a>3、解决方案</h1><h2 id=3-1、XA><a class=headerlink href=#3-1、XA title=3.1、XA></a>3.1、XA</h2><p>XA是一个分布式事务协议，由Tuxedo提出。<p>XA大致分为两部分：<ul><li><p><strong>事务管理器</strong></p> <p>事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。</p><li><p><strong>本地资源管理器</strong></p> <p>本地资源管理器往往由数据库实现，比如Oracle、DB2都实现了XA接口。</p></ul><h3 id=3-1-1、原理><a class=headerlink href=#3-1-1、原理 title=3.1.1、原理></a>3.1.1、原理</h3><p>XA实现分布式事务的原理如下：<p>第一阶段</p><img alt=image-20201008160639230 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20201008160639230.png><p>第二阶段</p><img alt=image-20201008160732023 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20201008160732023.png><h3 id=3-1-2、优缺点><a class=headerlink href=#3-1-2、优缺点 title=3.1.2、优缺点></a>3.1.2、优缺点</h3><p>XA协议 比较简单，商业数据库实现XA协议，使用分布式事务的成本也较低。但<strong>XA有致命缺点，即性能不理想</strong>，特别是交易场景下，XA无法满足高并发场景。<p>XA在商业数据库中的支持较理想，在MySQL中就不大支持，MySQL 的 XA 实现，没有记录prepare阶段日志，主备切换会导致 主备库数据不一致。许多nosql也没有支持XA，这让XA的应用场景变得很少。<h2 id=3-2、2PC><a class=headerlink href=#3-2、2PC title=3.2、2PC></a>3.2、2PC</h2><p><strong>2PC（Two-phase commit protocol），中文叫二阶段提交</strong>。 <strong>二阶段提交是一种强一致性设计</strong>，2PC 引入一个事务协调者来协调管理各参与者（可称为各本地资源）的提交和回滚。<p>二阶段包括 <strong>准备、提交</strong> 两个阶段：<ul><li><strong>准备阶段</strong>：协调者 发送准备命令 给 参与者，准备命令 可理解为 除了提交事务，全部工作都做完了。<li><strong>提交阶段</strong>：同步等待 所有资源响应之后 就进入第二阶段，即提交阶段（提交阶段 可以是 提交事务 或 回滚事务）。</ul><p>第二阶段提交失败咋办？有两种情况：<ol><li>第二阶段执行的是事务回滚操作：不断重试，直到 所有参与者 回滚成功，否则 第一阶段准备成功的参与者将一直阻塞。<li>第二阶段执行的是事务提交操作：不断重试，直到 所有参与者 提交成功，实在不行就人工介入处理。</ol><blockquote><p>注意：2PC 是一个同步阻塞协议。<p>第一阶段所有参与者都响应了，协调者才会执行下一阶段操作，第一阶段协调者有超时机制，如果协调者没有收到所有参与者的响应，或超时了，那么都将判定事务失败，会向所有参与者发送回滚命令。</blockquote><p><strong>协调者是一个单点，存在 单点故障 问题</strong>，如果协调者：<ol><li><strong>发送准备命令前</strong>挂了，则还行，等于事务还没开始。<li><strong>发送准备命令后</strong>挂了，就不太行，有些参与者等于都执行了处于事务资源锁定的状态。不仅事务执行不下去，还会因为锁定了一些公共资源而阻塞系统其它操作。<li><strong>发送回滚事务命令前</strong>挂了，那么事务也是执行不下去，且在第一阶段那些准备成功参与者都阻塞着。<li><strong>发送回滚事务命令后</strong>挂了，这个还行，至少命令发出去了，很大的概率都会回滚成功，资源都会释放。但是如果出现网络分区问题，某些参与者将因为收不到命令而阻塞。<li><strong>发送提交事务命令前</strong>挂了，这个不行，傻了！这下是所有资源都阻塞着。<li><strong>发送提交事务命令后</strong>挂了，这个还行，至少命令发出去了，很大概率都会提交成功，然后释放资源，但是如果出现网络分区问题某些参与者将因为收不到命令而阻塞着。</ol><p>协调者故障后，会通过选举得到新协调者，但 新协调者不知道当前事务进行到了哪一阶段？（准备阶段？提交阶段？）。<h2 id=3-3、3PC><a class=headerlink href=#3-3、3PC title=3.3、3PC></a>3.3、3PC</h2><h3 id=3-3-1、3PC简介><a class=headerlink href=#3-3-1、3PC简介 title=3.3.1、3PC简介></a>3.3.1、3PC简介</h3><p><strong>为解决 2PC 中的问题，3PC出现了。3PC在参与者中也引入了超时机制，新增一个阶段使得参与者可以利用这一个阶段统一各自状态。</strong><p><strong>3PC指<code>CanCommit、PreCommit 和 DoCommit</code> 三个阶段</strong>：<ul><li><strong>准备阶段</strong>：询问参与者自身状况，是否准备就绪。<li><strong>预提交阶段</strong>：和 2PC 的准备阶段一样，除了事务提交外，其它都做了。<li><strong>提交阶段</strong>：与 2PC 提交阶段一样。</ul><h3 id=3-3-2、3PC-阶段变更影响><a title="3.3.2、3PC 阶段变更影响" class=headerlink href=#3-3-2、3PC-阶段变更影响></a>3.3.2、3PC 阶段变更影响</h3><p>准备阶段会先询问所有参与者是否可以接收事务操作指令。避免一来就干活而可能导致的所有参与者都被阻塞。<p>预提交阶段 起到了统一状态的作用，在预提交阶段前所有参与者其实都未回应，在预处理阶段则表示所有参与者都已经回应了。<blockquote><p>注意：进入 预提交状态 的 参与者可以推断出来其他参与者也都进入了预提交状态。</blockquote><p><strong>多一个阶段多一个交互，且绝大情况下明知资源可用但还要走流程，故性能会相对差一点</strong>。<h3 id=3-3-3、参与者超时影响><a class=headerlink href=#3-3-3、参与者超时影响 title=3.3.3、参与者超时影响></a>3.3.3、参与者超时影响</h3><p><strong>如果等待提交命令 超时，那么 参与者会自动提交事务。如果等待预提交命令超时，那啥都不做</strong>。<p><font color=red>注意：超时机制也会带来数据不一致问题，参与者 等待提交命令超时后【默认执行提交操作】，但实际需要执行的可能是回滚操作。</font><blockquote><p>从维基百科上看，3PC 的引入是为了解决提交阶段 2PC 协调者和某参与者都挂了之后新选举的协调者不知道当前应该提交还是回滚的问题。<p>新协调者来的时候发现有一个参与者处于预提交或者提交阶段，那么表明所有参与者都已经确认了，所以此时执行的就是提交命令。所以说 3PC 就是通过引入预提交阶段来使得参与者之间的状态得到统一，也就是留了一个时间让大家同步一下。<p>但是这也只能让协调者知道该如果做，但不能保证这样做一定对，这其实和上面 2PC 分析一致，因为挂了的参与者到底有没有执行事务无法断定。所以说 3PC 通过预提交阶段可以减少故障恢复时候的复杂性，但是不能保证数据一致，除非挂了的那个参与者恢复。</blockquote><h3 id=3-3-4、3PC-VS-2PC><a title="3.3.4、3PC  VS  2PC" class=headerlink href=#3-3-4、3PC-VS-2PC></a>3.3.4、3PC VS 2PC</h3><p>3PC 引入参与者超时机制、预提交阶段，降低了故障恢复后协调者的决策复杂度。但整体交互过程变长，性能下降，且会存在数据不一致问题。所以 2PC 和 3PC 都不能保证数据100%一致，故通常都需要定时扫描补偿。<h2 id=3-4、TCC模型><a class=headerlink href=#3-4、TCC模型 title=3.4、TCC模型></a>3.4、TCC模型</h2><h3 id=3-4-1、TCC简介><a class=headerlink href=#3-4-1、TCC简介 title=3.4.1、TCC简介></a>3.4.1、TCC简介</h3><p><strong>TCC是Try、Confirm、Cancel三个词的首字母</strong>，分别对应如下三个阶段：<ol><li><strong>Try（初步操作）</strong>：完成所有业务检查，预留必须的业务资源。<li><strong>Confirm（确认操作）</strong>：真正去执行业务逻辑，不作任何业务检查，只使用 Try 阶段预留的业务资源。因此，只要 Try 操作成功，Confirm 必能成功。且Confirm 需满足 幂等性（一个分布式事务有且只能成功一次）。<li><strong>Cancel（取消操作）</strong>：释放 Try 阶段预留的业务资源。Cancel 操作也需要满足幂等性。</ol><p>TCC分布式事务模型不依赖资源管理器对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务。<p><strong>TCC 分布式事务模型包括三部分</strong>：<ol><li><strong>主业务服务</strong>：整个业务活动的发起方，服务的编排者，负责完成整个业务活动。<li><strong>从业务服务</strong>：整个业务活动的参与方，负责提供 TCC 业务操作，实现初步操作(Try)、确认操作(Confirm)、取消操作(Cancel)三个接口，供主业务服务调用。<li><strong>业务活动管理器</strong>：管理控制整个业务活动，包括记录维护 TCC 全局事务的事务状态和每个从业务服务的子事务状态，并在业务活动提交时调用所有从业务服务的 Confirm 操作，在业务活动取消时调用所有从业务服务的 Cancel 操作。</ol><h3 id=3-4-2、TCC流程><a class=headerlink href=#3-4-2、TCC流程 title=3.4.2、TCC流程></a>3.4.2、TCC流程</h3><p>一个完整的 TCC 分布式事务流程如下：<ol><li>主业务服务 首先开启 本地事务;<li>主业务服务 向业务活动管理器 申请启动 分布式事务主业务活动;<li>主业务活动 先向业务活动管理器 注册 从业务活动，然后调用从业务服务的 Try 接口;<li>当所有从业务服务的 Try 接口调用成功，主业务服务提交本地事务；若调用失败，主业务服务回滚本地事务;<li>若主业务服务提交本地事务，则 TCC 模型分别调用所有从业务服务的 Confirm 接口；若主业务服务回滚本地事务，则分别调用 Cancel 接口;<li>所有从业务服务的 Confirm 或 Cancel 操作完成后，全局事务结束。</ol><h3 id=3-4-3、TCC模型小结><a class=headerlink href=#3-4-3、TCC模型小结 title=3.4.3、TCC模型小结></a>3.4.3、TCC模型小结</h3><p>TCC编程模式也是两阶段提交的一个变种。TCC提供了一个编程框架，将整个业务逻辑分为三块：Try、Confirm和Cancel。以在线下单为例，Try阶段会去扣库存，Confirm阶段去更新订单状态，如果更新订单失败，则进入Cancel阶段，会去恢复库存。<p>TCC就是通过代码人为实现了两阶段提交，不同的业务场景所写的代码都不一样，复杂度也不一样，因此，这种模式并不能很好地被复用。<h2 id=3-5、本地消息表><a class=headerlink href=#3-5、本地消息表 title=3.5、本地消息表></a>3.5、本地消息表</h2><p>本地消息表其实是国外 ebay 搞出来的逻辑。<p>大概流程逻辑如下：<ol><li>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；<li>A 系统将这个消息发送到 MQ 中去；<li>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样<strong>保证不会重复处理消息</strong>；<li>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；<li>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；<li>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。</ol><p>该方案 最大问题 在于 <font color=red>严重依赖于数据库的消息表来管理事务</font>，如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。<h2 id=3-6、可靠消息最终一致性><a class=headerlink href=#3-6、可靠消息最终一致性 title=3.6、可靠消息最终一致性></a>3.6、可靠消息最终一致性</h2><p><strong>基于 MQ 实现分布式事务。RocketMQ 支持消息事务</strong>。<p>大概流程逻辑如下：<ol><li>A 系统先发送一个 prepared 消息到 mq，如果发送失败就取消操作，如果发送成功则执行本地事务，如果本地事务执行成功就让 mq 发送确认消息，如果失败让 mq 发送回滚消息；<li>如果A系统发送了确认消息，B系统也收到了确认消息，则B系统会执行自己的本地事务；<li>mq 会自动定时轮询，检测prepared消息是否发送成功，本地事务是否执行成功，确认消息或回滚消息是否发送成功。<li>如果 B系统 本地事务执行失败 则不断重试直到成功，如果实在是不行，且事务比较重要则发送警报由人工来处理。</ol><p>基于消息中间件的两阶段提交往往用在高并发场景下，将一个分布式事务拆成一个消息事务（A系统的本地操作+发消息）+ B系统的本地操作，其中B系统的操作由消息驱动，只要消息事务成功，那么A操作一定成功，消息也一定发出来了，这时候B会收到消息去执行本地操作，如果本地操作失败，消息会重投，直到B操作成功，这样就变相地实现了A与B的分布式事务。原理如下：<p><img alt=image-20201008161449305 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20201008161449305.png><p>上面方案能够完成A和B的操作，但A和B 并不 严格一致，而是 最终一致，牺牲一致性，换来 性能的大幅度提升。该方式 有风险，如果B一直执行不成功，那么一致性会被破坏，具体要不要玩，还是得看业务能够承担多少风险。<h2 id=3-7、最大努力通知><a class=headerlink href=#3-7、最大努力通知 title=3.7、最大努力通知></a>3.7、最大努力通知</h2><p>该方案大概流程逻辑如下：<ol><li>系统 A 本地事务执行完之后，发送消息到 MQ；<li>最大努力通知服务会一直检测MQ中是否有消息，若存在消息则进行持久化处理，并调用系统B的接口；<li>如果系统B 执行成功则完事，如果执行执行失败，那么“最大努力通知服务”就会定时重试调用系统B，反复 N 次，最后还是不行就放弃；</ol><h2 id=3-8、小结><a class=headerlink href=#3-8、小结 title=3.8、小结></a>3.8、小结</h2><ul><li>2PC/3PC：<strong>是一种强一致性事务</strong>，但依然可能存在数据不一致，阻塞等情况，且只能用在数据库层面。<li>TCC：<strong>是一种补偿性事务</strong>，适用范围更广，在业务层面实现，因此对业务的侵入性较大，每一个操作都需要实现对应的三个方法。<li>本地消息/事务消息/最大努力通知：<strong>是最终一致性事务</strong>，因此适用于一些对时间不敏感的业务。</ul></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ itemprop=url>Java系列-多线程与高并发</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-05 15:04:34" datetime=2023-10-05T15:04:34+08:00 itemprop=dateModified>2023-10-05</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E5%B9%B6%E5%8F%91/ itemprop=url rel=index><span itemprop=name>并发</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、并发编程基础><a class=headerlink href=#1、并发编程基础 title=1、并发编程基础></a>1、并发编程基础</h1><h2 id=1-1、线程简介><a class=headerlink href=#1-1、线程简介 title=1.1、线程简介></a>1.1、线程简介</h2><h3 id=1-1-1、重要概念><a class=headerlink href=#1-1-1、重要概念 title=1.1.1、重要概念></a>1.1.1、重要概念</h3><h4 id=1-1-1-1、进程><a class=headerlink href=#1-1-1-1、进程 title=1.1.1.1、进程></a>1.1.1.1、进程</h4><p><strong>系统资源分配的基本单位</strong>。<p>若要实现多程序并发执行，操作系统需要一个结构来抽象和表示程序的运行。<ul><li>进程 是 操作系统 对正在运行程序的一种抽象。<li>进程 是 由一组机器指令、数据和堆栈等组成的能独立运行的活动实体。<li>操作系统 可以 同时运行多个进程，多个进程可并发执行和交换信息。<li>进程 在运行时需要资源，如CPU、存储空间和I/O设备等。</ul><blockquote><p>并发：同一时刻 只有一个进程或线程 在运行，但因 切换较快 而带给人的感觉像同时在运行。<p>并行：同一时刻 有多个进程或线程 在运行。</blockquote><h4 id=1-1-1-2、线程><a class=headerlink href=#1-1-1-2、线程 title=1.1.1.2、线程></a>1.1.1.2、线程</h4><p><strong>CPU调度的基本单位</strong>。<p>进程调度成本较高（存储空间，CPU，I/O资源等，进程现场保护）并发切换效率较低。为提高调度效率，提出了比进程更轻量的线程。<ul><li>线程较进程更轻量。<li>线程能独立运行，独立调度，拥有资源（CPU资源，程序计数器等）。<li>线程调度成本较低（相对于进程来说），线程切换 不会导致 进程切换。<li>线程能并发执行，进一步提高系统并发性。<li>同一个进程的多个线程可以共享进程资源。</ul><h4 id=1-1-1-3、协程（coroutine）><a class=headerlink href=#1-1-1-3、协程（coroutine） title=1.1.1.3、协程（coroutine）></a>1.1.1.3、协程（coroutine）</h4><h5 id=简介><a class=headerlink href=#简介 title=简介></a>简介</h5><p><strong>最初多数用户线程被设计成协同式调度 （Cooperative Scheduling），故起名为协程（Coroutine）</strong>。由于协程会做调用栈保护、恢复工作，故又称为【有栈协程（Stackfull Coroutine）】，相反也有【无栈协程（Stackless Coroutine）】。<p>无栈协程的典型应用是各种语言中的await、async、yield等关键字。无栈协程本质上是一种有限状态机，状态保存在闭包里，比有栈协程恢复调用栈要轻量，但功能也相对有限。<p>协程主要优势是轻量，无论是有栈协程还是无栈协程，都要比传统内核线程要轻量得多。<blockquote><p>有栈协程有一种实现称为 纤程（Fiber）。</blockquote><h5 id=优缺点><a class=headerlink href=#优缺点 title=优缺点></a>优缺点</h5><p>协程特点如下：<ul><li>协程是【用户模式】下的【轻量级线程】，操作系统内核对协程一无所知。<li>协程调度 由 应用程序控制。<li>一个线程可以包含一个或多个协程。<li>协程有自己的寄存器上下文和栈，协程在调度切换时会将之保存，切换回来时可恢复至保存的状态。<li>协程可以保存上次的调用状态。<li>Windows下的实现叫【纤程】。<li>子程序调用总是一个入口对应一次返回，调用顺序明确。而协程的调用和子程序不同。</ul><p>协程主要一个线程执行，与多线程比，协程有如下优势：<ul><li>执行效率极高：子程序切换由程序控制，【没有线程切换】。<li>无需多线程锁机制：因为只有一个线程，也不存在同时写变量冲突。协程中操作共享资源无需加锁，只判断状态即可，故 执行效率 较 多线程 要高。</ul><h4 id=1-1-1-4、仟程（fiber）><a class=headerlink href=#1-1-1-4、仟程（fiber） title=1.1.1.4、仟程（fiber）></a>1.1.1.4、仟程（fiber）</h4><p>代码移植性一直是平台间交互考虑的重点，将应用程序从Unix移植到Windows的过程中会存在一系列问题，增加了移植难度和成本。<p><strong>为了更正确地将代码移植到Windows，Microsoft 在操作系统中增加了纤程（Fiber）</strong>。纤程与线程对比，有如下特性：<ul><li>线程在Windows内核中实现，操作系统会根据系统的调度算法对线程进行调度；纤程在用户模式下实现，内核对纤程一无所知。<li>纤程是【轻量级线程】，一个线程可包含一个或多个纤程。<li>内核会对线程进行抢占式调度，线程一次只能执行一个纤程代码（具体执行哪一个纤程由用户调度算法决定）。<li>纤程调度与线程调度没有直接关系，操作系统随时可能会夺取纤程所在线程的运行权。<li>正在运行的纤程显式切换到另一个纤程时这个纤程才可以运行。<li>Windows有一套API来实现线程转纤程或在一个线程里面创建多个纤程。</ul><h4 id=1-1-1-5、管程><a class=headerlink href=#1-1-1-5、管程 title=1.1.1.5、管程></a>1.1.1.5、管程</h4><p>临界资源 定义如下：<ul><li>一次只允许一个进程访问的资源；<li>多个进程只能互斥访问的资源；</ul><p>访问临界资源需要同步，比如 信号量 就是一种 进程同步机制。信号量要求每个访问临界资源的进程都具有wait和signal操作。这样使大量的同步操作分散在各个进程中，不仅给系统管理带来了麻烦，且会因同步操作使用不当而导致死锁。为了解决这些问题，管程出现了。<blockquote><p>操作系统中管理的各种软件和硬件资源，均可用 数据结构 抽象地描述其资源特性。利用共享数据结构抽象地表示系统中的共享资源。而把对共享数据结构实施的操作定义为一组过程，如资源的请求和释放过程request和release。进程对共享资源的申请、释放和其他操作，都是通过这组过程来实现，这组过程还可以根据资源情况来选择接受或阻塞进程的访问，确保每次仅有一个进程使用该共享资源，实现临界资源互斥访问。</blockquote><p>管程 就是 共享资源的数据结构 和 对该共享数据结构实施的操作 两者组成的 【资源管理程序】。管程 由 【请求和释放临界资源的进程】 所调用。<p><strong>管程定义了一个数据结构和管理该数据结构的一组操作</strong>。<h3 id=1-1-2、超线程><a class=headerlink href=#1-1-2、超线程 title=1.1.2、超线程></a>1.1.2、超线程</h3><p><strong>超线程（Hyper-Threading，简写HT）是Intel公司为CPU设计的一项技术，旨在提高每个处理器核心的性能</strong>。超线程技术允许单个物理核心模拟多个逻辑核心，从而能够并行处理多个线程。<p>背景：传统单核CPU中，当一个线程等待数据时核心会处于闲置状态。超线程的出现就是为了利用这种等待时间，使得CPU可以处理另一个线程，提高CPU的利用率。<p>工作原理：<ol><li>超线程技术允许CPU具有多于一个的线程执行单元，使得单个物理核心可以执行多个线程。<li>当一个线程因等待数据或其它原因被阻塞时，另一个线程可以使用该核心的资源，增加了核心利用率。<li>通过超线程技术进一步提升了处理器的工作效率和吞吐量。</ol><h3 id=1-1-3、线程优先级><a class=headerlink href=#1-1-3、线程优先级 title=1.1.3、线程优先级></a>1.1.3、线程优先级</h3><p>如今的操作系统基本<strong>采用时间片规则来调度运行线程</strong>，操作系统会分出一个个时间片，然后分配给每个线程，当线程的时间片用完了就会发生线程调度，并等待着下次分配。线程得到时间片的多少就决定了线程能使用处理器资源的多少，而线程优先级就可以一定程度上决定线程得到时间片的多少。<p><strong>Java线程可通过变量<code>priority</code>来控制优先级，优先级范围从1至10。创建线程时可通过方法<code>setPriority(int)</code>来设置优先级，默认优先级为5，优先级高的线程得到时间片的数量要多于优先级低的线程</strong>。<p>针对频繁阻塞（休眠或I/O操作）的线程需要设置较高的优先级，而偏重计算（需要较多CPU时间）的线程则可以设置较低的优先级，确保处理器不会被独占。<p><font color=red>注意：线程优先级的设定并非一定起作用，因为操作系统不一定会重视。</font><h3 id=1-1-4、线程状态><a class=headerlink href=#1-1-4、线程状态 title=1.1.4、线程状态></a>1.1.4、线程状态</h3><p><img alt=image-20210426211305027 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210426211305027.png?token=AIGEF3PT62JG3PZWEBS73BLEZZXC4><p>Java线程在整个生命周期中有6种不同的状态，某一个时间， 线程只能处于其中的一个状态。<ol><li><p><strong>NEW（初始状态）</strong>：线程被构建，但没有调用start方法。</p><li><p><strong>RUNNABLE（运行状态）</strong>：Java线程将就绪和运行两种状态统称为“运行中”。</p><li><p><strong>BLOCKED（阻塞状态）</strong>：表示线程阻塞于锁。</p><li><p><strong>WAITING（等待状态）</strong>：表示当前线程需要等待其它线程做出一些特定操作（通知或中断）。</p><li><p><strong>TIME_WAITING（超时等待状态）</strong>：该状态不同于WAITING，它可以在指定时间内自动返回。</p><li><p><strong>TERMINATED（终止状态）</strong>：表示当前线程已经执行完毕。</p></ol><h3 id=1-1-5、daemon线程><a class=headerlink href=#1-1-5、daemon线程 title=1.1.5、daemon线程></a>1.1.5、daemon线程</h3><p>Daemon（守护）线程是一种支持型线程，主要被用于程序后台调度及支持性工作。当Java虚拟机中不存在非Daemon线程时，Java虚拟机将会退出。可通过调用<code>Thread.setDaemon(true)</code>将线程设置为Daemon线程。<p><font color=red>注意：Daemon属性需要在线程启动之前设置。且Java虚拟机退出时Daemon线程中的finally块并不一定会执行。</font><h2 id=1-2、启动终止线程><a class=headerlink href=#1-2、启动终止线程 title=1.2、启动终止线程></a>1.2、启动终止线程</h2><h3 id=1-2-1、启动线程><a class=headerlink href=#1-2-1、启动线程 title=1.2.1、启动线程></a>1.2.1、启动线程</h3><h4 id=1-2-1-1、启动线程的方式><a class=headerlink href=#1-2-1-1、启动线程的方式 title=1.2.1.1、启动线程的方式></a>1.2.1.1、启动线程的方式</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.Callable;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.ExecutorService;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.Executors;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.FutureTask;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">T02_HowToCreateThread</span> {</span><br><span class=line>    <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">MyThread</span> <span class=keyword>extends</span> <span class="title class_">Thread</span> {</span><br><span class=line>        <span class=meta>@Override</span></span><br><span class=line>        <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">run</span><span class=params>()</span> {</span><br><span class=line>            System.out.println(<span class=string>"Hello MyThread!"</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">MyRun</span> <span class=keyword>implements</span> <span class="title class_">Runnable</span> {</span><br><span class=line>        <span class=meta>@Override</span></span><br><span class=line>        <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">run</span><span class=params>()</span> {</span><br><span class=line>            System.out.println(<span class=string>"Hello MyRun!"</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">MyCall</span> <span class=keyword>implements</span> <span class="title class_">Callable</span>&LTString> {</span><br><span class=line>        <span class=meta>@Override</span></span><br><span class=line>        <span class=keyword>public</span> String <span class="title function_">call</span><span class=params>()</span> {</span><br><span class=line>            System.out.println(<span class=string>"Hello MyCall"</span>);</span><br><span class=line>            <span class=keyword>return</span> <span class=string>"success"</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>//启动线程的5种方式</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=keyword>new</span> <span class="title class_">MyThread</span>().start();</span><br><span class=line>        <span class=keyword>new</span> <span class="title class_">Thread</span>(<span class=keyword>new</span> <span class="title class_">MyRun</span>()).start();</span><br><span class=line>        <span class=keyword>new</span> <span class="title class_">Thread</span>(()->{</span><br><span class=line>            System.out.println(<span class=string>"Hello Lambda!"</span>);</span><br><span class=line>        }).start();</span><br><span class=line></span><br><span class=line>        <span class=type>Thread</span> <span class=variable>t</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Thread</span>(<span class=keyword>new</span> <span class="title class_">FutureTask</span>&LTString>(<span class=keyword>new</span> <span class="title class_">MyCall</span>()));</span><br><span class=line>        t.start();</span><br><span class=line></span><br><span class=line>        <span class=type>ExecutorService</span> <span class=variable>service</span> <span class=operator>=</span> Executors.newCachedThreadPool();</span><br><span class=line>        service.execute(()->{</span><br><span class=line>            System.out.println(<span class=string>"Hello ThreadPool"</span>);</span><br><span class=line>        });</span><br><span class=line>        service.shutdown();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h4 id=1-2-1-2、Callable的使用><a class=headerlink href=#1-2-1-2、Callable的使用 title=1.2.1.2、Callable的使用></a>1.2.1.2、Callable的使用</h4><h5 id=相关类结构图><a class=headerlink href=#相关类结构图 title=相关类结构图></a>相关类结构图</h5><p>接口Callable是一个单独的接口，与之相关的类内部结构图可参考如下：<p><img alt=image-20210706113047202 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210706113047202.png?token=AIGEF3IIKOSDUDGRO73RRQTEZZXEK><h5 id=Callable使用实例><a class=headerlink href=#Callable使用实例 title=Callable使用实例></a>Callable使用实例</h5><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">StartThreadByCallable</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>MyCallable</span> <span class=variable>callable</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">MyCallable</span>();</span><br><span class=line>        <span class=type>FutureTask</span> <span class=variable>futureTask</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">FutureTask</span><>(callable);</span><br><span class=line>        <span class=keyword>new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class=line></span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            <span class=type>Object</span> <span class=variable>result</span> <span class=operator>=</span> futureTask.get();</span><br><span class=line>            System.out.println(<span class=string>"result: "</span> + result);</span><br><span class=line>        }<span class=keyword>catch</span> (InterruptedException | ExecutionException e){</span><br><span class=line>            e.printStackTrace();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>class</span> <span class="title class_">MyCallable</span> <span class=keyword>implements</span> <span class="title class_">Callable</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">call</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>int</span> <span class=variable>sum</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>1</span>; i <= <span class=number>100</span>; i++){</span><br><span class=line>            <span class=keyword>if</span> (i % <span class=number>2</span> == <span class=number>0</span>){</span><br><span class=line>                sum += i;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> sum;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-2、理解中断><a class=headerlink href=#1-2-2、理解中断 title=1.2.2、理解中断></a>1.2.2、理解中断</h3><p>中断可理解为线程的标识位属性，它表示一个运行中的线程是否被其他线程执行了中断操作。通过调用线程的<code>interrupt()</code>方法可以实现中断线程的操作。<p>线程通过检查自身是否被中断来进行响应，方法<code>isInterrupted()</code>返回线程是否被中断，静态方法<code>Thread.interrupted()</code>返回当前中断状态，并将中断标识设为false。<p><font color=red>注意：终结状态下的线程，即使曾经被中断过，那么方法 isInterrupted() 依旧会返回false。</font><h3 id=1-2-3、过期方法><a class=headerlink href=#1-2-3、过期方法 title=1.2.3、过期方法></a>1.2.3、过期方法</h3><p>suspend()、resume() 和 stop()方法可以实现线程的暂停、恢复和终止。但这些API已经过期，不建议使用。<p>不推荐原因：<font color=red>调用方法suspend()后线程会占用资源进入睡眠状态，易引发死锁问题。stop()方法在终结线程时不能保证正常释放线程资源。</font><blockquote><p>暂停和恢复操作可以用 等待/通知 机制来替代。</blockquote><h3 id=1-2-4、安全终止线程><a class=headerlink href=#1-2-4、安全终止线程 title=1.2.4、安全终止线程></a>1.2.4、安全终止线程</h3><p><strong>通过 标识位或中断操作  可以实现线程终止时有机会清理资源，而非立即停止。这种方法更加安全和优雅</strong>。<h3 id=1-2-5、小结><a class=headerlink href=#1-2-5、小结 title=1.2.5、小结></a>1.2.5、小结</h3><p>可中断的场景如下：<ol><li>Lock<li>Object相关方法（wait）<li>Thread相关方法（join、sleep）</ol><p>不可中断场景如下：<ol><li>synchronized锁</ol><h2 id=1-3、线程间通信><a class=headerlink href=#1-3、线程间通信 title=1.3、线程间通信></a>1.3、线程间通信</h2><h3 id=1-3-1、volatile-synchronized><a title="1.3.1、volatile / synchronized" class=headerlink href=#1-3-1、volatile-synchronized></a>1.3.1、volatile / synchronized</h3><ul><li><p>volatile</p> <p>关键字volatile 可修饰字段，访问该变量时需要从共享内存中获取，对该变量的修改必须同步刷新至共享内存，它能保证所有线程对变量访问的可见性。</p><li><p>synchronized</p> <p>关键字synchronized可修饰方法 或 以同步块形式使用，可保证多个线程在同一时刻只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p></ul><h3 id=1-3-2、等待-通知机制及范式><a class=headerlink href=#1-3-2、等待-通知机制及范式 title=1.3.2、等待/通知机制及范式></a>1.3.2、等待/通知机制及范式</h3><h4 id=1-3-2-1、等待通知机制><a class=headerlink href=#1-3-2-1、等待通知机制 title=1.3.2.1、等待通知机制></a>1.3.2.1、等待通知机制</h4><p>等待/通知机制是指：<strong>线程A调用对象O的wait()方法后会进入等待状态，线程B调用对象O的notify()或notifyAll()方法后会通知线程A结束等待继续执行</strong>。<p>调用wait()、notify()、notifyAll()时的注意事项如下：<ol><li>使用 wait()、notify() 和 notifyAll() 时需要先对调用对象加锁。<li>调用 wait() 方法后，会将当前线程放入对象的 等待队列，线程状态由RUNNING变为WAITING。<li>调用 notify()、notifyAll() 方法的线程释放锁之后，等待线程才会从wait()返回。<li>notify()方法会将等待队列中的一个等待线程移到同步队列中，而notifyAll() 方法会作用于全部线程，被移动线程的状态会由WAITING变为 BLOCKED。<li>获得调用对象的锁后才能从wait()方法返回。</ol><h4 id=1-3-2-2、等待通知范式><a class=headerlink href=#1-3-2-2、等待通知范式 title=1.3.2.2、等待通知范式></a>1.3.2.2、等待通知范式</h4><p><strong>范式分为两部分：等待方（消费者）、通知方（生产者）</strong>。<p>（1）等待方<ol><li>获取对象的锁；<li>如果条件不满足，那么调用对象的wait方法，被通知后仍要检查条件；<li>条件满足则执行对应的逻辑；</ol><p>（2）通知方<ol><li>获得对象的锁；<li>改变条件；<li>通知所有等待在对象上的线程；</ol><h3 id=1-3-3、管道输入-输出流><a class=headerlink href=#1-3-3、管道输入-输出流 title=1.3.3、管道输入/输出流></a>1.3.3、管道输入/输出流</h3><p><strong>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流的不同之处在于，基于内存实现线程间的数据传输</strong>。<p>管道输入/输出流主要包括了4种具体实现：<ul><li>面向字节：PipedInputStream、PipedOutputStream；<li>面向字符：PipedReader、PipedWriter；</ul><h3 id=1-3-4、Thread-join><a class=headerlink href=#1-3-4、Thread-join title=1.3.4、Thread.join></a>1.3.4、Thread.join</h3><p><strong>线程A执行thread.join()方法表示：线程A等待thread线程终止之后才从thread.join()返回</strong>。<p>除了<code>join()</code>方法外，还提供了<code>join(long millis)</code>和<code>join(long millis, int nanos)</code>两个超时方法。两个超时方法作用：如果线程在给定的超时时间内没有终止，那么会直接返回。<h3 id=1-3-5、ThreadLocal><a class=headerlink href=#1-3-5、ThreadLocal title=1.3.5、ThreadLocal></a>1.3.5、ThreadLocal</h3><p>ThreadLocal是一个以ThreadLocal对象为键、任意对象为值的存储结构。该结构存在于线程上，故一个线程可以根据一个ThreadLocal对象来查询绑定在该线程上的数据。<p>对于线程A，可以通过A.set(T)方法来设置一个值，然后通过A.get()方法获取到原先设置的值。<h1 id=2、CPU><a class=headerlink href=#2、CPU title=2、CPU></a>2、CPU</h1><h2 id=2-1、缓存行><a class=headerlink href=#2-1、缓存行 title=2.1、缓存行></a>2.1、缓存行</h2><h3 id=2-1-1、概述><a class=headerlink href=#2-1-1、概述 title=2.1.1、概述></a>2.1.1、概述</h3><p><strong>CPU缓存行是计算机体系架构中的一个概念，用于描述主存储器和CPU缓存之间的数据传输单位</strong>。缓存行是CPU缓存中最小的可寻址单位，也是一次从主存储器中读取数据块的大小。<p><strong>缓存行的大小是固定的，通常为32字节或64字节，具体取决于CPU设计。缓存行是按连续的内存地址来分割主存储器，且在CPU缓存中以相同方式进行组织。</strong><blockquote><p>为何CPU缓存行大小通常为64字节？原因分析有以下几点：<ul><li><strong>空间局部性</strong>。相邻数据被访问的可能性较大，一次加载连续的内存数据到缓存行中，可以利用这种局部性，减少对主存储器的访问次数，提高数据访问效率。<li><strong>数据传输效率</strong>。CPU与主存储器之间的数据传递是通过总线进行了，总线传输带宽是有限的，一次性加载较大的缓存行可以充分利用总线的宽度，减少数据传输的次数，提高数据传输效率。<li><strong>缓存行对齐</strong>。通常来说，数据的访问需要满足对齐要求。对齐要求是指数据存储在内存中的起始地址必需是某个值（缓存行大小）的倍数。如果不满足对齐要求，CPU需要做额外的工作来获取正确的数据，这增加了访问延迟。通过设定缓存行大小为64字节，可以确保大多数数据类型都能满足对齐要求。<li><strong>缓存容量与成本均衡</strong>。增加缓存行的大小可以提高缓存命中率，提高数据访问效率。但较大的缓存行也会占用更多的缓存容量。通过选择适当的缓存行大小，可以在缓存容量和性能之间取得平衡。</ul></blockquote><p>当CPU需要从主存储器中读取数据时，它会以缓存行为单位进行操作。如果要读取的数据位于缓存行中，CPU会一次性将整个缓存行加载到CPU缓存中，后期需要读取相邻数据时可直接从缓存中读取，提高了读取效率。<p>缓存行的引入是为了解决主存储器与CPU之间速度差异的问题。但缓存行的引入也带来了一些问题，第一个问题就是缓存行对内存的占用，加载到缓存的数据可能只使用了部分，而剩余的空间被浪费了，这也被称为缓存行浪费或缓存行膨胀。第二个问题就是缓存一致性问题，当多个CPU访问共享内存时，由于每个CPU都有自己的缓存，可能造成缓存的不一致，而这可以通过缓存一致性协议来解决。<h3 id=2-1-2、四个状态><a class=headerlink href=#2-1-2、四个状态 title=2.1.2、四个状态></a>2.1.2、四个状态</h3><p><strong>Modified（修改）、Exclusive（独占）、Shared（共享）、Invalid（无效）。</strong><h2 id=2-2、用户态与内核态><a class=headerlink href=#2-2、用户态与内核态 title=2.2、用户态与内核态></a>2.2、用户态与内核态</h2><h3 id=2-2-1、概述><a class=headerlink href=#2-2-1、概述 title=2.2.1、概述></a>2.2.1、概述</h3><p><strong>用户态与内核态是操作系统中的两种执行模式，用于区分运行在不同特权级别下的程序和系统内核。</strong><p><strong>用户态是为用户应用程序提供的一种执行缓存。</strong>用户态下的程序只能访问有限的资源和执行有限的操作。<p><strong>内核态是操作系统的特权执行模式，拥有对操作系统核心和硬件资源的完全控制权。</strong>内核态下的系统内核程序可以执行任何指令和访问任何资源。内核态程序可以执行特权指令、管理内存、调度任务等。<p>当用户程序需要执行特权操作时，会触发一次用户态到内核态的转变，系统内核会接管特权并执行相关操作，操作完成后，再交给用户程序，用户程序继续执行。<h3 id=2-2-2、ring-0-1-2-3><a title="2.2.2、ring 0  1  2  3" class=headerlink href=#2-2-2、ring-0-1-2-3></a>2.2.2、ring 0 1 2 3</h3><p><strong>CPU Ring 0、1、2、3是一种权限级别划分，这种划分通常用于X86体系结构中的操作系统和处理器。</strong><p>X86体系结构中，特权级别使用4个环（Ring）来表示，每个环对应一种特权级别，这些环被称为Ring0、1、2、3，也被称为内核态、系统态、用户态、应用态。<ul><li><p><strong>Ring 0（内核态）</strong>：是操作系统内核运行的特权级别，拥有最高的特权和访问权限。系统内核可以执行所有指令，访问系统的所有资源和硬件设备。</p><li><p><strong>Ring 1（系统态）</strong>：是保留给操作系统的第二特权级别，拥有较高的特权和访问权限。系统可以执行受限的指令集和访问部分授权的资源。</p><li><p><strong>Ring 2（用户态）</strong>：是保留给操作系统的第三特权级别，比Ring 3有更高的特权。系统可以执行受限的指令集和访问部分授权的资源。</p><li><p><strong>Ring 3（应用态）</strong>：是用户程序运行的特权级别，拥有最低的特权和访问权限。程序只能执行授权的指令集，访问有限的资源和执行授权动作。</p></ul><p><strong>CPU运行级别在 Ring3 和 Ring0 间的切换称为用户态和内核态的切换</strong>。<h3 id=2-2-3、上下文切换><a class=headerlink href=#2-2-3、上下文切换 title=2.2.3、上下文切换></a>2.2.3、上下文切换</h3><h4 id=2-2-3-1、简介><a class=headerlink href=#2-2-3-1、简介 title=2.2.3.1、简介></a>2.2.3.1、简介</h4><p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个 任务。在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以<strong>任务从保存到再加载的过程就是一次上下文切换。</strong><p>上下文切换 会影响 多线程执行速度。<h4 id=2-2-3-2、测试上下文切换><a class=headerlink href=#2-2-3-2、测试上下文切换 title=2.2.3.2、测试上下文切换></a>2.2.3.2、测试上下文切换</h4><p>使用<code>Lmbench3</code>可以测量上下文切换时长。使用<code>vmstat</code>可以测量上下文切换次数。<h4 id=2-2-3-3、减少上下文切换><a class=headerlink href=#2-2-3-3、减少上下文切换 title=2.2.3.3、减少上下文切换></a>2.2.3.3、减少上下文切换</h4><p><strong>减少上下文切换的方法：无锁并发编程、CAS算法、使用最少线程和使用协程。</strong><p>实战示例：<ol><li><p>用<code>jstack</code>命令 dump 线程信息，看看 pid 为 3117 的进程中的线程在做什么。</p> <figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>sudo</span> -u admin /opt/ifeve/java/bin/jstack 31177 > /home/tengfei.fangtf/dump17</span><br></pre></table></figure><li><p>统计所有线程分别处于什么状态，发现300多个线程处于 WAITING 状态。</p> <figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>grep java.lang.Thread.State dump17 | awk <span class=string>'{print $2$3$4$5}'</span> | <span class=built_in>sort</span> | <span class=built_in>uniq</span> -c</span><br></pre></table></figure><li><p>打开dump文件查看处于 WAITING 线程在做什么。发现线程池中的线程接收任务太少，大量线程都闲着。</p><li><p>减少线程池中的线程数量。</p><li><p>重新启动服务并测试查看效果。</p></ol><h2 id=2-3、缓存一致性协议><a class=headerlink href=#2-3、缓存一致性协议 title=2.3、缓存一致性协议></a>2.3、缓存一致性协议</h2><h3 id=2-3-1、种类><a class=headerlink href=#2-3-1、种类 title=2.3.1、种类></a>2.3.1、种类</h3><p>协议类型主要有：MSI、MESI、MOSI、Synapse Firefly Dragon。<strong>intel CPU 使用的是MESI协议</strong>。<h3 id=2-3-2、MESI><a class=headerlink href=#2-3-2、MESI title=2.3.2、MESI></a>2.3.2、MESI</h3><p>M、E、S、I 标记 高速缓存行 四种独占状态（使用两个附加位编码）：<ol><li><strong>修改（M）</strong>：高速缓存行仅存在于当前高速缓存中，并且是脏的 - 它已从主存储器中的值修改（M状态）。在允许对（不再有效）主存储器状态的任何其他读取之前，需要高速缓存在将来的某个时间将数据写回主存储器。回写将该行更改为共享状态（S）。<li><strong>独占（E）</strong>：缓存行仅存在于当前缓存中，但是干净 - 它与主内存匹配。它可以随时更改为共享状态，以响应读取请求。或者，可以在写入时将其改变为修改状态。<li><strong>共享（S）</strong>：表示此高速缓存行可能存储在计算机的其他高速缓存中并且是干净的 - 它与主存储器匹配。可以随时丢弃该行（更改为无效状态）。<li><strong>无效（I）</strong>：表示此缓存行无效（未使用）。</ol><p>对于任何给定的高速缓存对，给定高速缓存行的允许状态如图：<p><img alt=image-20201008205937219 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20201008205937219.png?token=AIGEF3IXUJ63WEXUW5FGKLDEZZXHC><p><strong>当块被标记为M（已修改）时，其他高速缓存中关于该块的副本将会被标记为I（无效）</strong>。<h3 id=2-3-3、优缺点><a class=headerlink href=#2-3-3、优缺点 title=2.3.3、优缺点></a>2.3.3、优缺点</h3><h4 id=优点><a class=headerlink href=#优点 title=优点></a>优点</h4><p>MESI多了一个E——“独占”状态。独占状态有许多优点。<p>加入独占状态的缘由：<ol><li>对于“某个处理器需要读取其他处理器没有的块然后写入它”这种情况，会导致 MSI 下发生的两个总线事务（首先是BusRd请求，然后是BusRdX请求）中的第二个请求事务失效。而 MESI 通过添加Exclusive状态解决了这个问题。<li>MSI不适用于顺序执行的应用程序，MESI适用于高度并行的应用程序。</ol><h4 id=缺点><a class=headerlink href=#缺点 title=缺点></a>缺点</h4><p><font color=red>如果由特定块上的各种高速缓存执行 连续读取和写入 操作，则必须每次都将数据刷新到总线上。MOESI协议克服了这一问题。</font><h2 id=2-4、内存屏障><a class=headerlink href=#2-4、内存屏障 title=2.4、内存屏障></a>2.4、内存屏障</h2><h3 id=2-4-1、硬件屏障><a class=headerlink href=#2-4-1、硬件屏障 title=2.4.1、硬件屏障></a>2.4.1、硬件屏障</h3><ul><li>sfence：sava，sfence指令前写 先于 sfence指令后写。<li>lfence：load，lfence指令前读 先于 lfence指令后读。<li>mfence：modify/mix，mfence指令前读写 先于 mfence指令后读写。</ul><h3 id=2-4-2、JVM内存屏障><a class=headerlink href=#2-4-2、JVM内存屏障 title=2.4.2、JVM内存屏障></a>2.4.2、JVM内存屏障</h3><p><img alt=image-20200902211143739 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200902211143739.png?token=AIGEF3JUF3VDP2K4ZX3FWR3EZZXII><h1 id=3、JAVA对象><a class=headerlink href=#3、JAVA对象 title=3、JAVA对象></a>3、JAVA对象</h1><h2 id=3-1、JAVA对象组成><a class=headerlink href=#3-1、JAVA对象组成 title=3.1、JAVA对象组成></a>3.1、JAVA对象组成</h2><h3 id=3-1-1、对象结构><a class=headerlink href=#3-1-1、对象结构 title=3.1.1、对象结构></a>3.1.1、对象结构</h3><p>Java对象保存在内存中时，由以下三部分组成：<p><strong>（1）对象头</strong><ul><li>普通对象头：无压缩16字节，压缩后12字节；<li>数组对象头：无压缩24字节，压缩后16字节；</ul><p><strong>（2）实例数据</strong><p>HotSpot中，对象的实例数据会在对象头后分配空间。<p>字段的分配顺序受源码声明顺序以及HotSpot分配策略的影响。无论哪种分配策略，宽度相同的字段总是相邻分配的；不同宽度间的字段可能存在对其填充；<p>笼统说，基类声明的实例字段会出现在派生类声明的实例字段之前。但开启指针压缩后，派生类的较窄字段可能会插入到基类实例字段之间的对其填充部分。<p>相关参数：FieldsAllocationStyle CompactFields。<p><strong>（3）对齐填充（使得最终对象大小是8的倍数）</strong><p>HotSpot中，GC堆上的对象要求在8字节边界上分配；也就是说对象的起始地址必须是8的倍数，对象占用的空间也必须是8的倍数。<p>若对象时机需要的大小不足8的倍数，则用0填充不足的部分，直到8字节边界为止。<p>对齐填充可能出现在不同宽度的字段之间，也可能出现在对象的末尾；或者当不存在未对齐的数据时则不会出现对齐填充。<p>Java对象头由三部分组成：<p><strong>（1）Mark Word（普通对象头无压缩为8字节，压缩后不变；数组对象头为8字节；）</strong><p>HotSpot中，GC堆上的对象需要维持一些状态信息，如：<ul><li>身份哈希码（identity hash code）<li>是否已被GC标记（GC过程中需要）<li>当前对象年龄<li>当前是否被当作锁同步<li>持有对象锁的线程ID（用于偏向锁）<li>…….</ul><p>该部分会根据对象当前状态有选择性的记录其中一部分。<p><strong>（2）Klass Point（普通对象头无压缩为8字节，压缩后4字节；数组对象头4字节）</strong><p>开启压缩功能参数：<code>-XX:+UseCompressedClassPointers</code>。<p>HotSpot中，堆中的对象从C++角度看都是oopDesc子类的实例。每个对象都有一个_klass字段，指向一个描述自身的元数据的对象。<p>Java对象与数组的Klass并不是Java语言级的java.lang.class。Klass用于运行，而java.lang.class用于Java的反射API；前者中有_java_mirror字段指向后者。<p><strong>（3）数组长度（数组对象才会存在该项）（数组对象长度占用4字节）</strong><h3 id=3-1-2、Mark-Word><a title="3.1.2、Mark Word" class=headerlink href=#3-1-2、Mark-Word></a>3.1.2、Mark Word</h3><p>64位如下：<p><img alt=image-20230805145739393 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805145739393.png?token=AIGEF3L3JWHMKR3UAOTMM33EZZXJU><p>32位如下：<p><img alt=32位Java对象内存布局图01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/32%E4%BD%8DJava%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%9B%BE01.png?token=AIGEF3PUMAZYIJ32BFWNLNDEZZXLO><p>对于hashcode值来说，存在两种情况：<p><strong>（1）没有重写hashcode方法</strong><p>没有重写过hashcode方法时调用System.identityHashCode(…)方法可以拿到由os:random生成的hashcode。<p>os::random生成hashcode的规则为：<code>next_rand = (16807seed) mod (2^31 - 1)</code>，因此可以在对象的markword中用31位空间存储它。<p><strong>（2）重写过hashcode方法</strong><p>重写过的hashcode方法其计算结果不会存储在这里。<h3 id=3-1-3、测试案例><a class=headerlink href=#3-1-3、测试案例 title=3.1.3、测试案例></a>3.1.3、测试案例</h3><p>工具：JOL（Java Object Layout）<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>    <span class=comment>&LT!-- https://mvnrepository.com/artifact/org.openjdk.jol/jol-core --></span></span><br><span class=line>    <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>        <span class=tag><<span class=name>groupId</span>></span>org.openjdk.jol<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>artifactId</span>></span>jol-core<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>version</span>></span>0.9<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencies</span>></span></span><br></pre></table></figure><p>jdk8u: markOop.hpp<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=comment>// Bit-format of an object header (most significant first, big endian layout below):</span></span><br><span class=line><span class=comment>//</span></span><br><span class=line><span class=comment>//  32 bits:</span></span><br><span class=line><span class=comment>//  --------</span></span><br><span class=line><span class=comment>//             hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class=line><span class=comment>//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class=line><span class=comment>//             size:32 ------------------------------------------>| (CMS free block)</span></span><br><span class=line><span class=comment>//             PromotedObject*:29 ---------->| promo_bits:3 ----->| (CMS promoted object)</span></span><br><span class=line><span class=comment>//</span></span><br><span class=line><span class=comment>//  64 bits:</span></span><br><span class=line><span class=comment>//  --------</span></span><br><span class=line><span class=comment>//  unused:25 hash:31 -->| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class=line><span class=comment>//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class=line><span class=comment>//  PromotedObject*:61 --------------------->| promo_bits:3 ----->| (CMS promoted object)</span></span><br><span class=line><span class=comment>//  size:64 ----------------------------------------------------->| (CMS free block)</span></span><br><span class=line><span class=comment>//</span></span><br><span class=line><span class=comment>//  unused:25 hash:31 -->| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && normal object)</span></span><br><span class=line><span class=comment>//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && biased object)</span></span><br><span class=line><span class=comment>//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 ----->| (COOPs && CMS promoted object)</span></span><br><span class=line><span class=comment>//  unused:21 size:35 -->| cms_free:1 unused:7 ------------------>| (COOPs && CMS free block)</span></span><br></pre></table></figure><h2 id=3-2、Java数据类型><a class=headerlink href=#3-2、Java数据类型 title=3.2、Java数据类型></a>3.2、Java数据类型</h2><h3 id=3-2-1、类型占用字节><a class=headerlink href=#3-2-1、类型占用字节 title=3.2.1、类型占用字节></a>3.2.1、类型占用字节</h3><p><img alt=类型占用字节大小 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200915220817535.png?token=AIGEF3LFVBZGJEJXP4OIP4LEZZXNK><h4 id=3-2-1-1、扩展><a class=headerlink href=#3-2-1-1、扩展 title=3.2.1.1、扩展></a>3.2.1.1、扩展</h4><p>32位操作系统可以寻址到4G内存，因为 2^32 = 4 * 1024 * 1024 = 4G。64位近似无穷大（18EB）。<p>使用64位会有新问题：<strong>64位过长，给我们寻址带宽和对象内引用造成了负担。故引出了指针压缩技术。</strong><h3 id=3-2-2、指针压缩><a class=headerlink href=#3-2-2、指针压缩 title=3.2.2、指针压缩></a>3.2.2、指针压缩</h3><h4 id=3-2-2-1、底层实现><a class=headerlink href=#3-2-2-1、底层实现 title=3.2.2.1、底层实现></a>3.2.2.1、底层实现</h4><p><strong>JVM实现指针压缩的原理就是：不再保存所有引用，而是每隔8个字节保存一个引用。</strong>例如，原来保存每个引用0、1、2…，现在只保存0、8、16…。因此，指针压缩后，并不是所有引用都保存在堆中，而是以8个字节为间隔保存引用。<p>当引用被存入64位寄存器时，JVM会将其左移3位（相当于末尾添加3个0），例如0x0、0x1、0x2…分别被转换为0x0、0x8、0x10。当从寄存器中读出时，JVM又可以右移3位，丢弃末尾的0。（oop在堆中是32位，在寄存器中是35位，2的35次方=32G。也就是说，使用32位，来达到35位oop所能引用的堆内存空间）。<h4 id=3-2-2-2、指针压缩失效><a class=headerlink href=#3-2-2-2、指针压缩失效 title=3.2.2.2、指针压缩失效></a>3.2.2.2、指针压缩失效</h4><p>32G指针压缩失效问题：<strong>因为寄存器中2的35次方只能寻址到32G左右(不一定是32G，可能31G就会发生指压缩失效)，所以当内存超过32G时，JVM就默认停用压缩指针，进而改用64位寻址来寻址所有内存。改用64位寻址会导致对象变大，测试发现40G内存可以存储的对象个数要比30G内存少。</strong><h4 id=3-2-2-3、被压缩的数据><a class=headerlink href=#3-2-2-3、被压缩的数据 title=3.2.2.3、被压缩的数据></a>3.2.2.3、被压缩的数据</h4><ol><li>对象的全局静态变量(即类属性)。<li>对象头信息：64位平台下，原生对象头大小为16字节，压缩后为12字节。<li>对象引用：64位平台下，引用本身大小为8字节，压缩后为4字节。<li>对象数组：64位平台下，数组本身大小为24字节，压缩后16字节。</ol><h4 id=3-2-2-4、不会被压缩的数据><a class=headerlink href=#3-2-2-4、不会被压缩的数据 title=3.2.2.4、不会被压缩的数据></a>3.2.2.4、不会被压缩的数据</h4><ol><li>指向非Heap的对象指针。<li>局部变量、传参、返回值、NULL指针。</ol><h2 id=3-3、Java集合容器><a class=headerlink href=#3-3、Java集合容器 title=3.3、Java集合容器></a>3.3、Java集合容器</h2><h3 id=3-3-1、概述><a class=headerlink href=#3-3-1、概述 title=3.3.1、概述></a>3.3.1、概述</h3><p>Java集合容器整体结构如下图：<p>版本1：<p><img alt=Collection体系架构01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/Collection%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%8401.png?token=AIGEF3IOEOZ2Y5TSXSC4OSDEZZXP4><p>版本2：<p><img alt=集合结构图 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84%E5%9B%BE.jpg?token=AIGEF3POOXUNH77WTUNZZZTEZZXRS><h3 id=3-3-2、Collection><a class=headerlink href=#3-3-2、Collection title=3.3.2、Collection></a>3.3.2、Collection</h3><h4 id=3-3-2-1、List><a class=headerlink href=#3-3-2-1、List title=3.3.2.1、List></a>3.3.2.1、List</h4><h5 id=ArrayList><a class=headerlink href=#ArrayList title=ArrayList></a>ArrayList</h5><ol><li>数据结构：动态数组，需要连续内存。<li>元素特点：<ul><li>数组定义：<code>transient Object[] elementData;</code> 序列化时不考虑其存储元素；<li>允许为null值；</ul><li>增删改查：<ul><li>随机访问快；<li>首部插入速度较linkedlist要慢40%左右，尾部插入较linkedlist要快10%左右，中间插入较linkedlist要快65%左右，其它部分插入删除都会移动数据，性能较低；<li>可以利用CPU缓存，局部性原理。</ul><li>初始容量：<ul><li>JDK7：初始容量为10。<li>JDK8：初始为0，当第一次执行添加操作后才会扩容，扩容后容量为10；</ul><li>扩容：添加数据前已存在元素数量 等于 数组长度时，则扩大为原来的1.5倍，但底层并非是乘上1.5，而是根据公式：<code>原容量>>1+原容量</code>获得。<li>是否同步：非同步，线程不安全；但可以通过<code>Collections.synchronizedList(list)</code>返回一个线程安全的ArrayList，也可以使用concurrent包下的<code>CopyOnWriteArrayList</code>；<li>复杂度：添加n个元素需要O(n)时间；<li>使用场景：快速访问数据；单线程环境；</ol><h5 id=LinkedList><a class=headerlink href=#LinkedList title=LinkedList></a>LinkedList</h5><ol><li>数据结构：双向链表，不需要连续内存。<li>元素特点：<ul><li>链表节点底层实现就是内部类Node，变量Node first、Node last；<li>允许为null值；占用内存多；</ul><li>增删改查：<ul><li>随机访问慢，顺序访问性能还行；<li>首尾插入删除快，中间插入删除慢；</ul><li>初始容量：不需要指定容量；<li>扩容：随插入数据数量扩大；<li>是否同步：非同步，线程不安全；<li>复杂度：<li>使用场景：快速频繁增删数据场景；按顺序访问数据的场景；单线程环境；<li>扩展：可以实现栈、队列和双向队列；</ol><h5 id=Vector><a class=headerlink href=#Vector title=Vector></a>Vector</h5><ol><li>底层数据结构：动态数组；<li>元素特点：数组定义如：<code>Object[] elementData</code>；允许有空值；不支持序列化；<li>增删改查：插入删除效率低，查询效率高；<li>初始容量：默认10；<li>扩容：添加数据前先判断已存在元素数量 是否等于 数组长度，若等于则默认扩大为原来的2倍，如果显式设置了扩容量则按指定的扩容量来扩容，如果扩容后还是不够用，则直接根据要插入的元素数量长度来扩容；（默认容量为10，若首次发生扩容，则默认扩容后的容量为20。如果初始容量为10，然后直接一次性添加21个元素，那么扩容后的容量为21，而并非是40。容量21空闲为0的环境下，此时再添加1个元素，那么会再次扩容为原来的2倍，也即扩容为42）<li>是否同步：同步，线程安全，因其基于synchronized实现线程安全，故效率较差；可以使用concurrent包下的CopyOnWriteArrayList 来代替 Vector；<li>复杂度：<li>使用场景：多线程环境；</ol><h6 id=Stack><a class=headerlink href=#Stack title=Stack></a>Stack</h6><ol><li><p>底层数据结构：数组</p><li><p>元素特点：先进后出；</p><li><p>增删改查：</p> <ol><li>push方法：将元素推入栈底，即数组末尾；<li>pop方法：取出栈顶元素后并删除栈顶元素。<li>peek方法：取出栈顶元素，即数组首个元素。<li>empty方法：判断栈是否为空。<li>search方法：获取指定元素在栈中的位置。</ol> <p>注意：因其继承于Vector，所以其拥有Vector全部功能；</p><li><p>初始容量：空栈。</p><li><p>扩容：继承于vector，与之相同；</p><li><p>是否同步：线程安全；</p><li><p>复杂度：</p><li><p>使用场景：</p></ol><h5 id=CopyOnWriteArrayList><a class=headerlink href=#CopyOnWriteArrayList title=CopyOnWriteArrayList></a>CopyOnWriteArrayList</h5><ol><li>简介：写操作时（写操作加了锁，否则会拷贝多个副本），将原数组拷贝一份出来，然后在拷贝的新数组中执行写操作，操作完后再将原数组引用指向新数组；<li>底层数据结构：动态数组；<li>元素特点：<li>增删改查：<li>初始容量：<li>扩容：<li>是否同步：线程安全；<li>复杂度：<li>使用场景：读多写少，比如缓存；<li>注意事项：<ol><li>写操作需要拷贝数组，比较消耗内存，如果原数组容量比较大，则可能频繁发生YGC和FGC；<li>不能保证实时一致性，只能保证最终一致性；</ol></ol><h4 id=3-3-2-2、Set><a class=headerlink href=#3-3-2-2、Set title=3.3.2.2、Set></a>3.3.2.2、Set</h4><h5 id=HashSet><a class=headerlink href=#HashSet title=HashSet></a>HashSet</h5><ol><li>底层数据结构：基于HashMap和LinkedHashMap实现。具体实现方式：通过一个HashMap存储元素，元素存放在HashMap的key中，而value统一使用一个Object对象。<li>元素特点：<ol><li>无序不重复；<li>只允许1个null元素；</ol><li>增删改查：<li>初始容量：因基于HashMap实现，故规则参考HashMap实现规则；<li>扩容：因基于HashMap实现，故规则参考HashMap实现规则；<li>是否同步：线程不安全；<li>复杂度：<li>使用场景：去重，无需排序场景；</ol><h5 id=LinkedHashSet><a class=headerlink href=#LinkedHashSet title=LinkedHashSet></a>LinkedHashSet</h5><ol><li>底层数据结构：<ol><li>数组+双向链表；<li>基于LinkedHashMap和HashSet机制实现，所以可保证迭代顺序和元素的不重复；</ol><li>元素特点：<ol><li>Entry结构：before/hash/key/value/next/after；before和after用于维护整个双向链表；<li>元素不重复；<li>可以保证插入顺序和访问顺序；</ol><li>增删改查：<li>初始容量：因基于LinkedHashMap实现，参考其实现规则；<li>扩容：因基于LinkedHashMap实现，参考其实现规则；<li>是否同步：线程不安全；<li>复杂度：<li>使用场景：去重，需要保证插入或访问顺序；</ol><h5 id=SortedSet><a class=headerlink href=#SortedSet title=SortedSet></a>SortedSet</h5><ul><li>TreeSet<ol><li>底层实现：基于TreeMap实现。<li>元素特点：元素有序。支持两种排序方式：自然排序和定制排序，默认是自然排序。使用 无参构造时 默认自然排序；当需要使用定制排序时，需要使用 有参构造 来显式指定。<li>存储：通过compare和compareTo来判断是否相等。compare通过判断两个对象的id，相同id则认为是重复元素，不会加入到集合中。</ol></ul><h5 id=EnumSet><a class=headerlink href=#EnumSet title=EnumSet></a>EnumSet</h5><h5 id=CopyOnWriteSet><a class=headerlink href=#CopyOnWriteSet title=CopyOnWriteSet></a>CopyOnWriteSet</h5><ol><li>简介：写操作时（写操作加了锁，否则会拷贝多个副本），将原数组拷贝一份，然后在拷贝的那份数组中执行写操作，操作完后再将原数组引用指向新数组；<li>数组结构：动态数组；<li>原理：通过CopyOnWriteList机制实现；<li>是否同步：线程安全；<li>使用场景：读多写少，比如缓存；<li>注意事项：<ol><li>写操作需要拷贝数组，比较消耗内存，如果原数组容量比较大，则可能频繁发生YGC和FGC；<li>不能保证实时一致性（读取到的数据可能是旧的），只能保证最终一致性；</ol></ol><h5 id=CopyOnWriteArraySet><a class=headerlink href=#CopyOnWriteArraySet title=CopyOnWriteArraySet></a>CopyOnWriteArraySet</h5><ol><li>底层数据结构：动态数组；并非是散列表；<li>元素特点：不能存储重复元素；<li>增删改查>：<li>初始容量：<li>扩容：<li>是否同步：线程安全；<li>复杂度：<li>使用场景：读多写少，比如缓存；</ol><h5 id=ConcurrentSkipListSet><a class=headerlink href=#ConcurrentSkipListSet title=ConcurrentSkipListSet></a>ConcurrentSkipListSet</h5><h4 id=3-3-2-3、Queue><a class=headerlink href=#3-3-2-3、Queue title=3.3.2.3、Queue></a>3.3.2.3、Queue</h4><p>简介：offer()-添加数据后会返回一个布尔类型来表示是否添加成功；peek()-取数据；poll()-取数据后进行remove；<h5 id=Deque><a class=headerlink href=#Deque title=Deque></a>Deque</h5><ul><li>ArrayDeque<li>BlockingDeque<ul><li>LinkedBlockingDeque</ul></ul><h5 id=BlockingQueue（阻塞队列）><a class=headerlink href=#BlockingQueue（阻塞队列） title=BlockingQueue（阻塞队列）></a>BlockingQueue（阻塞队列）</h5><p>简介：在Queue的基础上添加<code>put()</code>和<code>take()</code>方法，这两个是阻塞方法。put装数据装满了会阻塞当前线程，take拿数据拿完了会阻塞当前线程。<ul><li><p>ArrayBlockingQueue</p> <p>简介：它是一个有界阻塞队列，且可以设置有界值，也就是容器的容量。注意本类实现的offer方法可以设置时间，在指定时间过后还是添加不进去再返回。</p><li><p>PriorityBlockingQueue</p><li><p>LinkedBlockingQueue</p> <p>简介：基于链表实现的无界阻塞队列，它可以一直装数据到你内存满为止。</p><li><p>TransferQueue</p> <p>简介：传递的意思，实际上是其它各种Queue的一个组合，它可以给线程传递任务且可以通过列表传递多个。该Queue新增了一个transfer()方法——其逻辑就是装完数据得等着，有线程把它拿走我才可以回去继续干我的事。</p> <p>应用场景：做了一件事，该事需要一个结果才能继续做下一件事。比如网购，我付钱成功后才能给发货，不成功不能发货。</p> <ul><li>LinkedTransferQueue</ul><li><p>SynchronousQueue</p> <p>简介：容量为0，它并非用来装数据，而是专门用来两个线程间传递数据和线程下达任务。该Queue用来进行阻塞式put调用，要求有线程从里面取数据时才能往里面装，相当于直接把数据递给取数据线程的手中。该Queue看似无用，其实不然，其在线程池中用处非常大，多线程取任务，互相间进行任务调度时用的就是这个Queue。</p></ul><h5 id=PriorityQueue><a class=headerlink href=#PriorityQueue title=PriorityQueue></a>PriorityQueue</h5><p>简介：内部结构是一个二叉树，该二叉树可以认为是堆排序里面的小顶堆（最小值为根节点）。PriorityQueue的特点是向里面装数据时不是按顺序装的，而是在内部进行了一个排序，按照优先级，最小的优先。<h5 id=ConcurrentLinkedQueue><a class=headerlink href=#ConcurrentLinkedQueue title=ConcurrentLinkedQueue></a>ConcurrentLinkedQueue</h5><h5 id=DelayQueue（双端队列）><a class=headerlink href=#DelayQueue（双端队列） title=DelayQueue（双端队列）></a>DelayQueue（双端队列）</h5><p>简介：DelayQueue可以基于时间排序。它是阻塞的队列的一种实现，这个阻塞队列在装数据时必须实现Delayed接口，也要实现Comparable接口并重写compareTo方法来实现任务排序的自定义逻辑；<h3 id=3-3-3、Map><a class=headerlink href=#3-3-3、Map title=3.3.3、Map></a>3.3.3、Map</h3><h4 id=3-3-3-1、HashMap><a class=headerlink href=#3-3-3-1、HashMap title=3.3.3.1、HashMap></a>3.3.3.1、HashMap</h4><ol><li><p>底层数据结构：JDK7是数组+单链表；JDK8是数组+单链表+红黑树；</p><li><p>元素特点：无序的key-value键值对；允许null key和null value；</p><li><p>增删改：插入、删除、查询效率较高；</p><li><p>初始容量：默认16（2的N次方）；</p><li><p>扩容：put后判断是否需要扩容；负载因子0.75，当容量 = (总容量*0.75)时触发扩容，扩大为原来的2倍；</p><li><p>是否同步：线程不安全；</p><li><p>复杂度：</p><li><p>使用场景：快速增删改查；随机读取；缓存；</p><li><p>哈希冲突对策：</p> <ul><li>开放定址法；<li>再散列函数法；<li>链地址法（拉链法，HashMap基于此实现）；</ul></ol><h5 id=3-3-3-1-1、LinkedHashMap><a class=headerlink href=#3-3-3-1-1、LinkedHashMap title=3.3.3.1.1、LinkedHashMap></a>3.3.3.1.1、LinkedHashMap</h5><ol><li>底层数据结构：数组+双向链表；<li>元素特点：<ol><li>entry结构：before/hash/key/value/next/after，before和after用于维护整个双向链表；<li>允许一个null key（多个覆盖），允许多个null value；</ol><li>增删改查：<ol><li>在HashMap基础上添加before和after两个属性保证迭代顺序；<li>迭代顺序可以是插入顺序，也可以是访问顺序；<li>使用LRU算法实现访问顺序排序；</ol><li>初始容量：<li>扩容：<li>是否同步：线程不安全；<li>复杂度：<li>使用场景：保证插入和访问顺序；</ol><h4 id=3-3-3-2、IdentityHashMap><a class=headerlink href=#3-3-3-2、IdentityHashMap title=3.3.3.2、IdentityHashMap></a>3.3.3.2、IdentityHashMap</h4><h4 id=3-3-3-3、TreeMap><a class=headerlink href=#3-3-3-3、TreeMap title=3.3.3.3、TreeMap></a>3.3.3.3、TreeMap</h4><ol><li><p><font color=orange>底层数据结构</font>：红黑树（高效检索二叉树）；</p><li><p><font color=orange>元素特点</font>：</p> <ol><li>有序的key-value集合，每一个元素都存储于红黑树的一个节点上；<li>Entry结构：key/value/left/right/parent/color；<li>不允许null key，但可允许多个null value；</ol><li><p><font color=orange>增删改查</font>：默认自然排序，也可定制排序；</p><li><p><font color=orange>初始容量</font>：</p><li><p><font color=orange>扩容</font>：</p><li><p><font color=orange>是否同步</font>：线程不安全；</p><li><p><font color=orange>复杂度</font>：</p><li><p><font color=orange>使用场景</font>：</p><li><p><font color=orange>存储</font>：TreeMap存储时会进行排序，会根据key来对key-value键值对进行排序，其排序方式分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法。</p> <p><font color=orange>自然排序</font>：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。</p> <p><font color=orange>定制排序</font>：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。</p><li><p><font color=orange>获取</font>：</p><li><p><font color=orange>检测元素异同</font>：TreeMap判断两个元素相等的标准：两个key执行equals返回true，且执行<code>compareTo()</code>方法返回0，则认为这两个key相等。</p><li><p><font color=orange>是否同步</font>：非同步。</p><li><p><font color=orange>注意事项</font>：如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的<code>equals()</code>方法，TreeMap中判断相等的标准是：两个key通过<code>equals()</code>方法返回为true，并且通过<code>compareTo()</code>方法比较应该返回为0。</p></ol><h4 id=3-3-3-4、WeakHashMap><a class=headerlink href=#3-3-3-4、WeakHashMap title=3.3.3.4、WeakHashMap></a>3.3.3.4、WeakHashMap</h4><h4 id=3-3-3-5、HashTable><a class=headerlink href=#3-3-3-5、HashTable title=3.3.3.5、HashTable></a>3.3.3.5、HashTable</h4><ol><li><font color=orange>底层数据结构</font>：数组 + 链表；<li><font color=orange>元素特点</font>：无序的key-value键值对，不允许null key 和 null value；<li><font color=orange>增删改查</font>：插入、删除、查询效率较低，因为被synchronized修饰；<li><font color=orange>初始容量</font>：默认11；<li><font color=orange>扩容</font>：put前判断是否需要扩容；负载因子0.75，当容量 >= (总容量*0.75)时触发扩容，扩大为2倍+1；<li><font color=orange>是否同步</font>：线程安全；基于重入锁synchronized实现线程安全；<li><font color=orange>复杂度</font>：<li><font color=orange>使用场景</font>：无序、不重复元素的存储。</ol><h4 id=3-3-3-6、IdentityHashMap><a class=headerlink href=#3-3-3-6、IdentityHashMap title=3.3.3.6、IdentityHashMap></a>3.3.3.6、IdentityHashMap</h4><h4 id=3-3-3-7、ConcurrentHashMap（JDK8）><a class=headerlink href=#3-3-3-7、ConcurrentHashMap（JDK8） title=3.3.3.7、ConcurrentHashMap（JDK8）></a>3.3.3.7、ConcurrentHashMap（JDK8）</h4><ol><li><font color=orange>底层数据结构</font>：数组+单链表+红黑树；<li><font color=orange>锁实现</font>：CAS+Synchronized；<li><font color=orange>元素特点</font>：Node改名为HashEntry；<li><font color=orange>增删改查</font>：<li><font color=orange>初始容量</font>：默认16；<li><font color=orange>扩容</font>：数据等于容量3/4时就扩容为原容量的2倍。<li><font color=orange>是否同步</font>：线程安全；基于 CAS+Synchronized 实现安全；<li><font color=orange>复杂度</font>：<li><font color=orange>使用场景</font>：多线程，高并发场景；</ol><h4 id=3-3-3-8、ConcurrentKipListMap><a class=headerlink href=#3-3-3-8、ConcurrentKipListMap title=3.3.3.8、ConcurrentKipListMap></a>3.3.3.8、ConcurrentKipListMap</h4><h3 id=3-3-4、Iterator><a class=headerlink href=#3-3-4、Iterator title=3.3.4、Iterator></a>3.3.4、Iterator</h3><ul><li><p>Iterator</p> <ol><li>简介：是接口，是集合迭代器。<li>API：<ol><li>boolean hashNext()：判断集合中是否存在下一个元素，若存在，则返回true。<li>Object next()：返回集合中下一个元素。<li>void remove()：删除集合上一次next方法返回的元素。</ol><li>注意事项：<ol><li>iterator()只能单向移动。<li>iterator.remove()可以唯一安全修改迭代过程中集合元素的方法；如果在迭代过程中以任何其它的方式修改了集合，那么将会产生未知行为。且每调用一次<code>next()</code>方法，<code>remove()</code>方法只能被调用一次，如果违反这个规则将抛出一个异常。</ol></ol> <ul><li>ListIterator<ol><li>简介：是一个 功能更强 的迭代器，继承于Iterator接口，只能适用于List。可以通过调用<code>listIterator()</code>方法产生一个指向List开始处的ListIterator，还可以调用<code>listIterator(n)</code>方法创建一个一开始就指向列表索引为n的元素的ListIterator。<li>特点：<ol><li>双向移动（向前向后遍历）<li>产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引。<li>可以使用set方法替换它访问过的最后一个元素。<li>可以使用add方法在next方法返回的元素之前或previous方法返回元素之后插入一个元素。</ol></ol></ul></ul><h3 id=3-3-5、Collection-Collections><a title="3.3.5、Collection / Collections" class=headerlink href=#3-3-5、Collection-Collections></a>3.3.5、Collection / Collections</h3><h4 id=3-3-5-1、Collection><a class=headerlink href=#3-3-5-1、Collection title=3.3.5.1、Collection></a>3.3.5.1、Collection</h4><p><strong>Collection是集合类顶级接口。提供操作集合的通用方法，其继承接口有List与Set</strong>。<h4 id=3-3-5-2、Collections><a class=headerlink href=#3-3-5-2、Collections title=3.3.5.2、Collections></a>3.3.5.2、Collections</h4><p>java.util.Collections 是<strong>集合工具类</strong>。拥有多种操作集合的静态方法，可对集合中的元素执行排序、搜索以及线程安全等操作，服务于Java的Collection框架。<h3 id=3-3-6、总结><a class=headerlink href=#3-3-6、总结 title=3.3.6、总结></a>3.3.6、总结</h3><h4 id=3-3-6-1、HashMap原理><a class=headerlink href=#3-3-6-1、HashMap原理 title=3.3.6.1、HashMap原理></a>3.3.6.1、HashMap原理</h4><h5 id=底层数据结构><a class=headerlink href=#底层数据结构 title=底层数据结构></a>底层数据结构</h5><p>（1）JDK7<p>JDK7底层基于数组 + 单链表实现。<p>JDK7中底层使用HashMap的静态内部类Entry来存储数据：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">Entry</span>&LTK,V> <span class=keyword>implements</span> <span class="title class_">Map</span>.Entry&LTK,V> {</span><br><span class=line>    <span class=keyword>final</span> K key;</span><br><span class=line>    V value;</span><br><span class=line>    Entry&LTK,V> next;</span><br><span class=line>    <span class=type>int</span> hash;</span><br><span class=line>    <span class=comment>// method...</span></span><br><span class=line>}</span><br></pre></table></figure><p>（2）JDK8<p>JDK8底层基于数组 + 单链表 + 红黑树实现。<p>JDK8中底层使用HashMap的静态内部类Node来存储数据：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">Node</span>&LTK,V> <span class=keyword>implements</span> <span class="title class_">Map</span>.Entry&LTK,V>{</span><br><span class=line>    <span class=keyword>final</span> <span class=type>int</span> hash;</span><br><span class=line>    <span class=keyword>final</span> K key;</span><br><span class=line>    V value;</span><br><span class=line>    Node&LTK,V> next;</span><br><span class=line>    <span class=comment>// method...</span></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>解决哈希冲突的常见方法：开放地址法、链地址法等。HashMap采用了链地址法。</blockquote><h5 id=元素特点><a class=headerlink href=#元素特点 title=元素特点></a>元素特点</h5><p><strong>HashMap支持一个null key 和多个 null value</strong>，原因如下：<ol><li><p>对于 null key 来说，在求hash值时会直接返回0，故只能有一个 null key。</p><li><p>对于 null value 来说，在执行put方法时不会对之进行校验，故可以有多个 null value。</p> <p>这里要注意，HashMap 的get方法执行逻辑是：如果没有查询到指定key的键值对时会返回 null 对象。故get(key)方法的返回结果为null有两种可能：</p> <ol><li>HashMap中不存在这个 key 对应的键值对；<li>HashMap中这个key对应的value为null；</ol> <p>故，在判断HashMap中是否存在某个key时，应该使用containsKey方法；</p></ol><h5 id=常见字段><a class=headerlink href=#常见字段 title=常见字段></a>常见字段</h5><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=comment>/** 保存Node&LTK,V>节点的数组，该表在首次使用时初始化，并根据需要调整大小。 分配时，长度始终是2的幂。 */</span></span><br><span class=line><span class=keyword>transient</span> Node&LTK,V>[] table;</span><br><span class=line><span class=comment>/** 存放具体元素的集合 */</span></span><br><span class=line><span class=keyword>transient</span> Set&LTMap.Entry&LTK,V>> entrySet;</span><br><span class=line></span><br><span class=line><span class=comment>/** 默认初始容量16 */</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=type>int</span> <span class=variable>DEFAULT_INITIAL_CAPACITY</span> <span class=operator>=</span> <span class=number>1</span> << <span class=number>4</span>;</span><br><span class=line><span class=comment>/** 最大容量 */</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=type>int</span> <span class=variable>MAXIMUM_CAPACITY</span> <span class=operator>=</span> <span class=number>1</span> << <span class=number>30</span>;</span><br><span class=line><span class=comment>/** 加载因子，用来计算threshold */</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=type>float</span> <span class=variable>DEFAULT_LOAD_FACTOR</span> <span class=operator>=</span> <span class=number>0.75f</span>;</span><br><span class=line><span class=comment>/** 触发扩容的阈值，实际大小（容量*加载因子）超过该阈值时会触发扩容  */</span></span><br><span class=line><span class=type>int</span> threshold;</span><br><span class=line><span class=comment>/** 负载因子：要调整大小的下一个大小值（容量*加载因子）。</span></span><br><span class=line><span class=comment>通过调节负载因子，可使 HashMap 在时间和空间复杂度上有不同表现。调低负载因子时，扩容效率增高，扩容过程中hash碰撞减少、链表长度变短，这是典型的拿空间换时间； 调高负载因子时，容纳键值对数量变多、空间利用率增高，但碰撞也增高了，最终效率下降。故一般使用默认值即可。*/</span></span><br><span class=line><span class=keyword>final</span> <span class=type>float</span> loadFactor;</span><br><span class=line></span><br><span class=line><span class=comment>/** 进行resize操作时，若桶中数量少于6则从树转成链表 */</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=type>int</span> <span class=variable>UNTREEIFY_THRESHOLD</span> <span class=operator>=</span> <span class=number>6</span>;</span><br><span class=line><span class=comment>/** 链表长度大于8时转化为红黑树 */</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=type>int</span> <span class=variable>TREEIFY_THRESHOLD</span> <span class=operator>=</span> <span class=number>8</span>;</span><br><span class=line><span class=comment>/** 链表转为红黑树时，需先判断当前数组容量是否小于64。若小于64且hash冲突太多，则不进行红黑树转化，而要通过resize函数继续扩容。 */</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=type>int</span> <span class=variable>MIN_TREEIFY_CAPACITY</span> <span class=operator>=</span> <span class=number>64</span>;</span><br><span class=line></span><br><span class=line><span class=comment>/** 记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。 */</span></span><br><span class=line><span class=type>int</span> modCount;  </span><br><span class=line><span class=comment>/** HashMap当前存储的元素数量  */</span></span><br><span class=line><span class=type>int</span> size;</span><br></pre></table></figure><p><strong>HashMap中哈希桶数组table的长度length大小必须为2的n次方（合数）</strong>。<h5 id=hash方法><a class=headerlink href=#hash方法 title=hash方法></a>hash方法</h5><ul><li><p>key为空，则hashcode为0，这也是HashMap只允许存在一个key为null的原因。</p><li><p>key不为空，则计算公式如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>int</span> <span class=variable>hash</span> <span class=operator>=</span> (h = key.hashCode()) ^ (h >>> <span class=number>16</span>); 	<span class=comment>// 求hash值</span></span><br><span class=line><span class=type>int</span> <span class=variable>index</span> <span class=operator>=</span> (n - <span class=number>1</span>) & hash; 					<span class=comment>// 定位下标</span></span><br></pre></table></figure></ul><h5 id=put-操作><a class=headerlink href=#put-操作 title=put()操作></a>put()操作</h5><p><strong>JDK1.7采用头插法，JDK1.8采用尾插法</strong>。<p>JDK8执行流程如下：<ol><li>计算待新增数据key的hash值；<li>判断Node[]是否为空，若为空需要进行初始化；<li>通过运算(hash &(len-e))得出待插入元素要存储在数组中的下标位置idx，如果该位置idx没有数据，那么该元素数据添加成功。如果该位置idx有数据，则继续判断：<ol><li>如果该位置idx处Node节点的key与待插入数据的key相等，则直接覆盖已存在的值，然后返回旧值；<li>如果该结构是树形，则按照树的方式插入数据；<li>如果该结构是链表，则从上到下遍历该链表。如果当前节点的下一节点为null，则将待插入数据放在这个null位置，然后判断链表长度是否大于阈值8，如果 >= 8 且数组长度 >= 64 才转为红黑树，如果 >= 8 且数组长度 < 64 则仅仅进行链表的扩容；如果当前节点的下一个节点不为null，且该节点hash、key与待插入元素数据的hash和key都相同，则将待插入数据替换该节点，然后返回旧值。如果该节点hash、key与待插入数据的hash和key不一样，那就继续遍历该链表。</ol><li>判断数组长度是否大于阈值，如果是则进入扩容阶段；</ol><h5 id=resize-操作><a class=headerlink href=#resize-操作 title=resize()操作></a>resize()操作</h5><p><strong>当数组元素数量 = 数组长度*0.75时触发扩容，扩容后数组长度是旧的2倍。</strong><p>Java8与Java7的迁移算法不一样，Java8不需要每一个元素都重新计算hash值；JDK8只需根据原hash值新增的那个bit是1还是0来判断，是0的话索引没变，是1的话索引变成：(原索引+oldCap)。<p><font color=red>注意：JDK1.7中旧链表迁移至新链表时，如果与新表数组索引位置相同，则链表元素会倒置；而JDK1.8不会倒置。</font><h5 id=get-key-操作><a class=headerlink href=#get-key-操作 title=get(key)操作></a>get(key)操作</h5><ol><li>根据put()方法中计算hash的方式得到一个数组下标index；<li>遍历数组下标为index所对应的链表，若找到key和hash值同时相等的就返回该值，否则返回null；</ol><h5 id=remove-操作><a class=headerlink href=#remove-操作 title=remove()操作></a>remove()操作</h5><ol><li>根据get()方法中的方式计算出要删除的key对应的Node节点；<li>如果待删除节点是头节点，则将它的next节点作为头节点；<li>如果待删除节点是红黑树，则直接调用红黑树的删除算法进行删除；<li>如果待删除节点是链表中的一个节点，则将待删除节点的前一个节点的next属性指向待删除节点的下一个节点即可；<li>如果删除成功则返回被删除节点的value，否则返回null；</ol><p><font color=red>注意：删除单个key时，返回的是键值对中的value；</font><h5 id=iterator迭代器><a class=headerlink href=#iterator迭代器 title=iterator迭代器></a>iterator迭代器</h5><p><code>Hashtable</code> 和 <code>HashMap</code> 有相同的迭代器 Iterator，<code>HashMap</code>和<code>Hashtable</code> 的 Iterator 都是快速失败 fail-fast。但<code>Hashtable</code> 还有另外一个迭代器 Enumeration，该迭代器是 安全失败 fail-safe，<code>HashTable</code> 中有一个 keys 方法可以返回 Enumeration 迭代器。<blockquote><p><strong>fail-safe 和 fail-fast 是一种思想，一种机制，属于系统设计范畴，并非 Java 集合所特有</strong>。<p><strong>（1）快速失败 fail-fast</strong><p>一种快速发现系统故障的机制。一旦发生异常，立即停止当前操作，并上报给上层的系统来处理这些故障。<p>当 Iterator 这个迭代器被创建后，除了迭代器本身的方法 remove 可以改变集合的结构外，其他的因素若改变了集合的结构（改变只包含插入和删除），都将会抛出 <code>ConcurrentModificationException</code> 异常。<p><strong>java.util 包下的集合类都是 fail-fast 的</strong>。<p><strong>（2）安全失败 fail-safe</strong><p>在故障发生之后会维持系统继续运行。 fail-safe 不会抛出异常的原因如下：<ol><li>当集合的结构被改变时，fail-safe 机制会复制一份原集合数据，然后在复制的那份数据上进行遍历。</ol><p>虽然 fail-safe 不会抛出异常，但存在以下缺点：<ol><li>不能保证遍历的是最新内容。也就是说迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的；<li>复制时需要额外的空间和时间开销。</ol><p>顾名思义，和 fail-fast 恰恰相反，当我们对集合的结构做出改变的时候，fail-safe 机制不会抛出异常。<p><strong>java.util.concurrent 包下的容器都是 fail-safe 的。</strong></blockquote><h5 id=线程安全><a class=headerlink href=#线程安全 title=线程安全></a>线程安全</h5><p>HashMap非线程安全，而ConcurrentHashMap线程安全。<p>ConcurrentHashMap底层结构在JDK1.7和1.8中也不同：<ul><li>JDK1.7： 分段锁；<li>JDK1.8：CAS + Synchronized；</ul><h5 id=并发问题><a class=headerlink href=#并发问题 title=并发问题></a>并发问题</h5><p>常见问题如下：<ol><li>多线程扩容，引起死循环问题；<li>多线程put时可能导致元素丢失；<li>put非null元素后get出来的是null；</ol><p>应对措施：使用HashTable 或者 ConcurrentHashMap。<h5 id=Key取值问题><a class=headerlink href=#Key取值问题 title=Key取值问题></a>Key取值问题</h5><ol><li><p>key只允许有一个null，value允许有多个null；（key为null的hashcode总是0）</p><li><p>key取值范围有哪些？</p> <p>一般使用String、Integer，且String最常用。原因如下：</p> <ol><li>字符串是不可变的，它在被创建时其hashcode就缓存了，无需计算，且效率要比其它对象高。<li>获取对象时需要用到equals方法和hashCode方法，而String已经规范的重写过了。</ol><li><p>可变类可以作为key使用吗？</p> <p>不可以，因为hashcode可能会发生变化，导致put进去的值，无法get出来。</p><li><p>如何自定义一个类，其可以作为HashMap的key？</p> <p>该问题考察两个知识点：</p> <ol><li><p>如何重写equals方法和hashCode方法？</p> <p>根据如下4条规则来设计即可：</p> <ol><li>两个对象相等，hashcode⼀定相等；<li>两个对象不等，hashcode不⼀定不等；<li>hashcode相等，两个对象不⼀定相等；<li>hashcode不等，两个对象⼀定不等；</ol><li><p>如何设计一个不变类？</p> <ol><li>使用final修饰类，保证类不能被继承。<li>将所有成员变量访问权限设为私有，且加上final修饰，保证成员变量不可变；<li>不提供修改成员变量的方法；<li>通过构造器初始化所有成员，进行深拷贝；<li>getter方法中不要直接返回对象本身，而要返回克隆对象，防止逃逸。</ol></ol></ol><h5 id=位运算-VS-取模运算><a title="位运算 VS 取模运算" class=headerlink href=#位运算-VS-取模运算></a>位运算 VS 取模运算</h5><p>HashMap采用 位运算 的原因如下<ol><li><strong>效率高。</strong>位运算直接对内存数据进行操作，不需要转换为十进制，因此处理速度快；<li><strong>可以解决取模运算的负数问题。</strong>比如：-15 % 10 = -5；</ol><h5 id=JDK7和JDK8下HashMap的异同><a class=headerlink href=#JDK7和JDK8下HashMap的异同 title=JDK7和JDK8下HashMap的异同></a>JDK7和JDK8下HashMap的异同</h5><ol><li>存放数据的节点名称不同；JDK7使用 Entry 命名；JDK8使用 Node 命名；<li>定位数组下标位置方法不同；<ul><li>JDK7：计算key的hash，然后进行四次扰动，再与数组长度取模得出；<li>JDK8：计算key的hash，将hash值进行高低16位异或操作，再与数组长度取模得出；</ul><li>扩容时机不同：JDK7添加数据前先判断是否需要扩容；JDK8添加数据后再判断是否需要扩容；<li>扩容迁移定位方法不同；<ul><li>JDK7：扩容后需要重新计算hash；<li>JDK8：扩容后不需要重新计算hash；</ul><li>put方法插入链表位置不同：<ul><li>JDK7：头插法；<li>JDK8：尾插法；</ul><li>红黑树升级和退化<ul><li>链表升级为红黑树：<strong>JDK8引入红黑树，当链表长度 >= 8 且 数组长度 >= 64 时，链表转为红黑树；</strong><li>红黑树退化为链表：有两个地方会判断并退化成链表：<ol><li><strong>remove时退化；</strong><li><strong>扩容时会调用<code>split()</code>进行红黑树的扩容移动处理。</strong>split方法中，会将当前红黑树左右子树分别放入low，high两个w变量（treeNode类型）中。可理解为两条链表，当low链表中元素<=6时会将low转换为真正的链表（Node类型），当low链表中元素>6时会进行树化处理， 例如对链表中节点的left、right等进行赋值，high链表同理。</ol></ul></ol><h5 id=HashMap-VS-HashTable><a title="HashMap VS HashTable" class=headerlink href=#HashMap-VS-HashTable></a>HashMap VS HashTable</h5><ol><li>初始容：HashMap是16；HashTable是11；<li>定位数组下标位置：<ul><li>HashMap：key.hashcode()后 通过 位运算 定位下标；<li>HashTable：key.hashcode()后 通过 取模运算 定位下标；</ul><li>判断扩容时机：HashMap在put后判断；HashTable在put前判断；<li>扩容大小：HashMap扩大为原容量的2倍；HashTable扩大为原容量的2倍+1；<li>null key 和 null value<ul><li>HashMap：允许1个null key（多个覆盖）和 多个null value；<li>HashTable：不允许null key 和 null value；</ul><li>线程安全：HashMap线程不安全；HashTable线程安全；<li>接口实现：HashMap实现Map接口且继承AbstractMap类；HashTable实现Map接口且继承Dictionary类；</ol><h5 id=HashMap-VS-TreeMap><a title="HashMap VS TreeMap" class=headerlink href=#HashMap-VS-TreeMap></a>HashMap VS TreeMap</h5><ol><li>数据结构：HashMap是数组+链表+红黑树；TreeMap是红黑树；<li>存储方式：HashMap是随机存储；TreeMap是按key的字典升序排序存储；<li>null key 和 null value<ul><li>HashMap：允许1个null key（多个覆盖），允许多个null value；<li>TreeMap：不允许null key，但允许多个null value；</ul><li>效率高低：HashMap效率高；TreeMap效率低；</ol><h4 id=3-3-6-2、HashTable原理><a class=headerlink href=#3-3-6-2、HashTable原理 title=3.3.6.2、HashTable原理></a>3.3.6.2、HashTable原理</h4><h5 id=底层数据结构-1><a class=headerlink href=#底层数据结构-1 title=底层数据结构></a>底层数据结构</h5><p>使用哈希表来存储键值对，数据结构创建了一个继承<code>Map.Entry</code>的私有静态内部类<code>Entry</code>，每一个Entry对象表示存储在哈希表中的一个键值对。<h5 id=元素特点-1><a class=headerlink href=#元素特点-1 title=元素特点></a>元素特点</h5><p><strong>HashTable不支持 null key和null value</strong>，原因如下：<ol><li>对于 null value 来说，在执行put方法时会直接抛出异常NullPointerException。<li>对于 null key 来说，在定位元素时会执行key.hashCode方法，会抛出NullPointerException。<li>若允许 null key 和 null value，则多线程环境下会出现问题。（ConcurrentHashMap也不允许null key 和 null value。）</ol><h5 id=rehash方法（扩容）><a class=headerlink href=#rehash方法（扩容） title=rehash方法（扩容）></a>rehash方法（扩容）</h5><p><strong>当前容量 >=（总容量 * 负载因子）时，Hashtable 扩大为旧容量的2倍+1；</strong><h4 id=3-3-6-3、ArrayList原理><a class=headerlink href=#3-3-6-3、ArrayList原理 title=3.3.6.3、ArrayList原理></a>3.3.6.3、ArrayList原理</h4><h5 id=add-element-操作><a class=headerlink href=#add-element-操作 title=add(element)操作></a>add(element)操作</h5><ol><li><p>判断当前数组是否为空，若是则创建长度为10的数组，因为new ArrayList 时没有初始化；</p><li><p>判断是否需要扩容，即：当前数组中元素数+1后（size+1）判断其是否大于当前数组长度，是则进行扩容（执行grow()方法）;</p> <p>grow()方法流程如下：</p> <ol><li>创建新数组，其长度为原数组长度的1.5倍；<li>如果扩大1.5倍后依然不够，则根据实际长度来扩容，比如addAll()场景；<li>将原数组的数据通过<code>System.arraycopy</code>方法（native方法）复制到新数组中；</ol><li><p>在数组末尾添加数据，并将size+1；</p></ol><h5 id=add-index-element-操作><a title="add(index, element)操作" class=headerlink href=#add-index-element-操作></a>add(index, element)操作</h5><ol><li>检查index是否在数组范围内，假如数组长度是2，则index必须 >= 0 且 <= 2，否则抛出异常IndexOutOfBoundsException异常；<li>扩容检查；<li>通过拷贝方式，把数组位置为index至size-1的元素都往后移动一位，腾出位置后放入元素，并将size+1；</ol><h5 id=set-index-element-操作><a title="set(index, element)操作" class=headerlink href=#set-index-element-操作></a>set(index, element)操作</h5><ol><li>检查index是否在数组范围内，加入数组长度为2，则index必须 >= 0 且 < 2；<li>保存被覆盖的值，因为最终需要返回旧值；<li>新元素放至index位置，并返回该位置旧值；</ol><h5 id=remove-index-操作><a class=headerlink href=#remove-index-操作 title=remove(index)操作></a>remove(index)操作</h5><ol><li>检查index是否在数组范围内，假如数组长度是2，则index必须 >= 0 且 <= 2；<li>保留要删除的值，因为最终要返回该值（旧值）；<li>计算需要移动元素的个数，再通过拷贝使数组中位置为 index+1 到 size-1 的元素向前移动一位，然后把数组最后一位元素设为null，返回旧值；</ol><h5 id=注意事项><a class=headerlink href=#注意事项 title=注意事项></a>注意事项</h5><ol><li><strong>new ArrayList创建对象时，如果没有指定容量则初始化为0；如果有指定，则按照指定大小进行初始化；</strong><li><strong>扩容时，将容量扩大1.5倍，如果还是不够则根据实际元素数量来扩大，保证能存储所有数据，比如addAll场景；</strong><li><strong>若扩容后数组长度大于 (Integer.MAX_VALUE - 8)，则抛出异常OutOfMemoryError。</strong></ol><h5 id=ArrayList-VS-Vector><a title="ArrayList VS Vector" class=headerlink href=#ArrayList-VS-Vector></a>ArrayList VS Vector</h5><ol><li>线程安全：ArrayList不安全；Vector安全；<li>扩容倍数：ArrayList默认1.5倍；Vector默认扩大为原容量的2倍，创建时也可显式设置扩容量；<li>支持序列化：ArrayList支持序列化；Vector不支持；<li>indexOf()接口支持：ArrayList提供了indexOf(obj, start)接口；Vector没有提供；<li>指定扩容系数：ArrayList不可以指定；Vector可以指定；</ol><h5 id=ArrayList-VS-LinkedList><a title="ArrayList VS LinkedList" class=headerlink href=#ArrayList-VS-LinkedList></a>ArrayList VS LinkedList</h5><ol><li>底层数据结构：ArrayList是动态数组；LinkedList是双向链表；<li>增删改查特点：ArrayList查询快增删慢；LinkedList随机查询慢，顺序查询快，增删快；<li>空间浪费：ArrayList会在数组末尾保留一定空间；LinkedList会在每一个节点都要消耗空间来存储prev、next信息；</ol><h4 id=3-3-6-4、LinkedList原理><a class=headerlink href=#3-3-6-4、LinkedList原理 title=3.3.6.4、LinkedList原理></a>3.3.6.4、LinkedList原理</h4><h5 id=add-操作><a class=headerlink href=#add-操作 title=add()操作></a>add()操作</h5><ol><li>创建一个新节点，节点元素为传入的参数，前继节点是 当前节点的last节点，后继节点next为null；<li>判断当前链表last节点是否为null，如果是，则把新建的节点作为头节点，否则把新建的节点作为last节点；<li>最后返回true；</ol><h5 id=get-index-element-操作><a title="get(index, element)操作" class=headerlink href=#get-index-element-操作></a>get(index, element)操作</h5><ol><li>检擦index是否在数组长度范围内，假如数组长度为2，则index必须 >= 0 且 < 2；<li>如果 index 小于 (双向链表长度的1/2)，则从头开始遍历查找，否则从链表末尾向前遍历查找；</ol><h5 id=remove-操作-1><a class=headerlink href=#remove-操作-1 title=remove()操作></a>remove()操作</h5><ol><li>判断first节点是否为空，如果是则抛出异常NoSuchElementException；<li>如果不为空，则把待删除节点的next节点的prev属性值设为null，达到 删除头节点的效果；<li>返回删除值；</ol><h4 id=3-3-6-5、ConcurrentHashMap><a class=headerlink href=#3-3-6-5、ConcurrentHashMap title=3.3.6.5、ConcurrentHashMap></a>3.3.6.5、ConcurrentHashMap</h4><h5 id=put-操作-1><a class=headerlink href=#put-操作-1 title=put()操作></a>put()操作</h5><ol><li>判断待插入数据key和value是否为空，如果是则抛出空指针异常；<li>判断Node[] 数组是否为空，若是则需要初始化；<li>根据hash值通过位运算计算出Node数组的下标，判断该数组第一个Node节点是否有数据，如果没有数据则通过CAS将新值插入；<li>如果有数据则判断头节点的hashcode是否等于MOVED（即-1），即检查是否正在扩容，如果等于-1则帮助扩容；<li>若有数据，则对头节点进行加锁，如果头节点的hashcode >= 0，则说明是链表，遍历链表。如果找到key和hahs同时相等，则进行覆盖；若没有找到，则将新值插入到链表的最后面；如果hashCode < 0，说明红黑树，调用红黑树的 插值方法 插入新节点；<li>插值完成后，判断链表元素是否 >= 8，如果 >=8 且数组长度 > 64则转为红黑树。如果 >= 8 且数组长度 < 64 则仅仅进行扩容；</ol><h5 id=resize-操作-1><a class=headerlink href=#resize-操作-1 title=resize()操作></a>resize()操作</h5><p>创建新数组，其长度为原数组长度的2倍；多线程环境下旧数组迁移至新数组时会发生线程安全问题；<h5 id=get-操作><a class=headerlink href=#get-操作 title=get()操作></a>get()操作</h5><ol><li>计算获取数据key的hash值；<li>根据hashCode并通过位运算得到Node数组的下标，即得到头节点；<li>如果头节点为空，则返回null；<li>如果头节点的key与参数key可以相等，则返回头节点的值；<li>如果头节点的hashcode小于0，说明是红黑树，则调用find方法按照树的方式获取值；<li>如果不满足3、4、5条件，说明是链表，则按照链表的方式遍历获取值，整个过程不需要加锁；</ol><p>注意：整个过程无需加锁，因为读取的数据被volatile修饰，实现线程可见性；<h5 id=remove-操作-2><a class=headerlink href=#remove-操作-2 title=remove()操作></a>remove()操作</h5><ol><li>计算待插入数据key的hash值；<li>判断Node[]数组是否为空，如果是则返回null；如果不是，则根据hashCode通过位运算定位到数组下标，即得到头节点；<li>判断头节点hashCode是否等于MOVED（即-1），检查是否正在扩容，如果是则帮助扩容；<li>如果2、3条件都不满足，则加锁进行删除操作；<li>首先判断头节点有无发生变化，如果有改变则返回null；<li>如果头节点hashCode大于0，说明是链表，则按照链表方式遍历删除值；<li>如果头节点是TreeBin类型，说明是红黑树，则按照红黑树方式删除值；</ol><p><font color=red>注意：remove()底层是调用replaceNode()函数实现节点删除；</font><h5 id=JDK7、JDK8-下ConcurrentHashMap的区别><a title="JDK7、JDK8 下ConcurrentHashMap的区别" class=headerlink href=#JDK7、JDK8-下ConcurrentHashMap的区别></a>JDK7、JDK8 下ConcurrentHashMap的区别</h5><ol><li><font color=orange>底层结构</font><ul><li>JDK7：<strong>以 segment 作为每组数据的容器，对segment加锁只能锁住当前segment，segment数量等于并发度。 segment数组 + entry数组 + 链表。</strong><li>JDK8：<strong>没有segment数组。 直接 entry数组 + 链表，锁粒度为entry数组中每个索引节点。</strong></ul><li><font color=orange>初始化</font>：JDK7直接初始化。JDK8会在第一次put时初始化。<li><font color=orange>锁实现</font>：JDK7<strong>使用分段锁Segment；</strong>JDK8<strong>使用CAS+Synchronized；</strong><li><font color=orange>查询遍历</font>：JDK7基于链表实现，遍历效率低；JDK8基于红黑树实现，遍历效率高；<li><font color=orange>数据存放命名</font>：JDK7使用HashEntry容器来存储数据；JDK8改名为Node容器来存储数据；<li><font color=orange>数据插入</font><ul><li>JDK7：<strong>头插法</strong>；<ol><li>segment下标位置：并发度为16，因 2^4 = 16，故下标位置就是二次hash值的二进制位的 高4位 对应的 十进制数值。<li>数组索引位置：数组长度为8，因2^3 = 8，故索引位置就是二次hash值的二进制位的 低3位 对应的 十进制数值。</ol><li>JDK8：<strong>尾插法；</strong><ol><li>1.8 中的capacity不再表示全部容量，而是一定会放入的数据数量。如果capacity为16，那么第一次会初始化一个容量为32的数组，因为容量为16，加载因子为0.75，超过12（16*0.75）才扩容，而你直接放入16个元素，那更应该扩容了。</ol></ul><li><font color=orange>扩容</font><ul><li>JDK7：<strong>容量超过3/4时才扩容，先扩容再插入值；</strong>在其它segment中创建数组时会以segment[0]中的数组大小为原型来创建。segment[0]位置初始容量：总容量 / 并发度。<li>JDK8：<strong>容量等于3/4时就扩容，先插入值再扩容；</strong>迁移数据时，从旧数组中拿数据的顺序是从右到左。</ul><li><font color=orange>锁的粒度</font><ul><li>JDK7：<strong>最大并发数是Segment的个数，默认16，锁住整个段，不影响其它段；</strong><li>JDK8：<strong>去掉分段锁，更细粒度，只锁住一个Node节点，不影响其它Node节点；</strong></ul><li><font color=orange>读写限制及扩容</font><ul><li>JDK7：扩容时锁住一个段，当前段可读不可写，其它段可读写，只开启1个线程进行扩容；<li>JDK8：锁住一个Node节点，当前节点可读不可写，其它节点可读写，1个线程+可能多个put/remove线程帮助扩容；</ul></ol><h4 id=3-3-6-6、TreeMap><a class=headerlink href=#3-3-6-6、TreeMap title=3.3.6.6、TreeMap></a>3.3.6.6、TreeMap</h4><h5 id=put-操作-2><a class=headerlink href=#put-操作-2 title=put()操作></a>put()操作</h5><p>主要分为两个步骤：<ol><li><strong>构建排序二叉树</strong><ol><li>从根节点root开始查找；<li>如果root节点比待插入节点值小，则在root节点左子树查找，如果大于，则在右子树查找；<li>递归循步骤2，找到合适节点为止；<li>把待插入节点与步骤3中查找到的节点进行对比，如果待插入节点小于找到节点，则把待插入节点作为找到节点的左子树，否则作为右子树；</ol><li><strong>构建平衡二叉树</strong></ol><h5 id=remove-操作-3><a class=headerlink href=#remove-操作-3 title=remove()操作></a>remove()操作</h5><p>比put操作复杂，同样分为两个步骤：<ol><li><strong>删除节点</strong><ol><li>待删除节点，如果没有左和右子树时，则直接删除；<li>待删除节点，如果有一个字节点时，则把它的子节点指向它的上级节点（父节点）；<li>待删除节点，如果有两个非空的子节点时，流程复杂，暂不解释；</ol><li><strong>着色旋转</strong><ol><li>进行颜色对调和旋转，达到红黑树的特征；</ol></ol><h2 id=3-4、JAVA引用><a class=headerlink href=#3-4、JAVA引用 title=3.4、JAVA引用></a>3.4、JAVA引用</h2><h3 id=3-4-1、引用类型><a class=headerlink href=#3-4-1、引用类型 title=3.4.1、引用类型></a>3.4.1、引用类型</h3><h4 id=3-4-1-1、强引用><a class=headerlink href=#3-4-1-1、强引用 title=3.4.1.1、强引用></a>3.4.1.1、强引用</h4><ul><li><p>定义：new一个对象就是强引用。</p><li><p>回收时机：<strong>引用为null时就可以回收它。</strong></p><li><p>代码实现</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>Person</span> <span class=variable>p</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Person</span>();</span><br><span class=line>p = <span class=literal>null</span>;</span><br></pre></table></figure></ul><blockquote><p>new一个对象，这个引用就是强引用。代码中的<code>p</code>就是一个强引用。当p = null时，GC就可以回收它了。</blockquote><h4 id=3-4-1-2、软引用><a class=headerlink href=#3-4-1-2、软引用 title=3.4.1.2、软引用></a>3.4.1.2、软引用</h4><ul><li><p>定义：被SoftReference类对象指向的引用。</p><li><p>回收时机：<strong>内存不够时才会回收。</strong></p><li><p>代码实现</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>SoftReference<<span class=type>byte</span>[]> softReference = <span class=keyword>new</span> <span class="title class_">SoftReference</span>(<span class=keyword>new</span> <span class="title class_">byte</span>[<span class=number>1024</span>*<span class=number>1024</span>*<span class=number>10</span>]);</span><br></pre></table></figure> <p>只有在内存不够时，才会回收 byte字节数组。</p><li><p>应用场景：做缓存使用。</p></ul><h4 id=3-4-1-3、弱引用><a class=headerlink href=#3-4-1-3、弱引用 title=3.4.1.3、弱引用></a>3.4.1.3、弱引用</h4><ul><li><p>定义：被WeakReference类对象指向的引用。</p><li><p>回收时机：<strong>GC看到就回收（下次gc时回收）。</strong></p><li><p>代码实现</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>WeakReference&LTPerson> weakReference = <span class=keyword>new</span> <span class="title class_">WeakReference</span>(<span class=keyword>new</span> <span class="title class_">Person</span>());</span><br></pre></table></figure><li><p>应用场景：用在容器中。</p></ul><h4 id=3-4-1-4、虚引用><a class=headerlink href=#3-4-1-4、虚引用 title=3.4.1.4、虚引用></a>3.4.1.4、虚引用</h4><ul><li><p>定义：被PhantomReference类对象指向的应用。相当于不存在，get操作不能获取到值。</p><li><p>回收时机：<strong>GC看到就回收。（队列不为null，说明已经被回收了）。</strong></p><li><p>代码实现</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>ReferenceQueue&LTPerson> rq = <span class=keyword>new</span> <span class="title class_">ReferenceQueue</span><>();</span><br><span class=line>PhantomReference&LTPerson> phantomReference = <span class=keyword>new</span> <span class="title class_">PhantomReference</span>(<span class=keyword>new</span> <span class="title class_">Person</span>(), rq);</span><br></pre></table></figure> <p>PhantomReference的构造函数有两个参数，第二个参数必须是一个队列。虚引用就是给你一个通知，通知时放在队列中，你只需判断队列中是否为null，如果队列不为 null 说明虚引用已被回收。</p><li><p>应用场景：处理堆外内存。（参考NIO中的DirectByteBuffer，意为直接内存，直接内存不受JVM管理，而是被系统管理，故又叫堆外内存。堆外内存的回收可以使用虚引用来实现。）</p></ul><h1 id=4、Java内存模型><a class=headerlink href=#4、Java内存模型 title=4、Java内存模型></a>4、Java内存模型</h1><h2 id=4-1、简介><a class=headerlink href=#4-1、简介 title=4.1、简介></a>4.1、简介</h2><h3 id=4-1-1、前言><a class=headerlink href=#4-1-1、前言 title=4.1.1、前言></a>4.1.1、前言</h3><p>并发编程中，需要处理两个关键问题：<strong>线程之间如何通信及线程之间如何同步。</strong><ul><li><p>通信</p> <p>通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：</p> <ul><li><p>共享内存</p> <p>在共享内存的并发模型里，线程之间共享程序的公共状态，通过写-读内存中的公共状态 进行隐式通信。</p><li><p>消息传递。</p> <p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。</p></ul><li><p>同步</p> <p>同步是指程序中用于控制不同线程间操作发生相对顺序的机制。</p> <p>在共享内存并发模型 里，同步显式进行。在消息传递的并发模型里，由于消息发送必须在消息接收前，因此同步是隐式进行的。</p></ul><p><strong>Java并发采用的是共享内存模型，Java线程间的通信是隐式进行，整个通信过程对程序员完全透明。</strong><h3 id=4-1-2、认识JMM><a class=headerlink href=#4-1-2、认识JMM title=4.1.2、认识JMM></a>4.1.2、认识JMM</h3><p><strong>Java内存模型是根据英文Java Memory Model（JMM）翻译过来。其实JMM并不像JVM内存结构一样真实存在。他只是一个抽象概念。</strong><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了主内存变量的副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间无法直接访问对方工作内存中的变量，线程间的通信需要通过主内存来实现。<p><strong>JMM作用于工作内存和主存之间的数据同步过程。它规定了如何做数据同步以及什么时候做数据同步。</strong><p><img alt=image-20210424211138529 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210424211138529.png?token=AIGEF3JZVGM2SSRA5JMZNGDEZZXWK><p>Java内存模型的相关知识在<code>JSR-133: Java Memory Model and Thread Specification</code>中有描述。JMM是和多线程相关，它描述了一组规则或规范，这个规范规定了一个线程对共享变量的写入对另一个线程是可见的。<p><strong>Java内存模型（Java Memory Model，JMM）就是一种符合内存模型规范，屏蔽了各种硬件和操作系统访问差异，保证了Java程序在各种平台下对内存的访问都能得到一致效果的机制及规范。目的是解决多线程环境中基于共享内存进行通信时，存在的原子性、可见性（缓存一致性）以及有序性问题。</strong><h2 id=4-2、重要概念><a class=headerlink href=#4-2、重要概念 title=4.2、重要概念></a>4.2、重要概念</h2><h3 id=4-2-1、原子性问题><a class=headerlink href=#4-2-1、原子性问题 title=4.2.1、原子性问题></a>4.2.1、原子性问题</h3><p><strong>线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。</strong>所以在多线程场景下，就会发生原子性问题。<p>例如：线程要完成一个读、改、写操作，但在执行完读、改之后，时间片耗完了，此时就要放弃CPU，并等待重新调度。这种情况下，读改写就不是一个原子操作。即存在原子性问题。<h3 id=4-2-2、一致性问题><a class=headerlink href=#4-2-2、一致性问题 title=4.2.2、一致性问题></a>4.2.2、一致性问题</h3><p><strong>多核CPU 和 多线程场景中，每个核都至少有一个L1 缓存。</strong>多个线程访问进程中的某个共享内存，且多个线程分别在不同的核心上执行，则每个核心都会在各自的cache中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自缓存的情况，而各自cache之间的数据就有可能不同。<p>在CPU和主存之间增加缓存可能导致在多线程场景下出现缓存一致性问题，多核CPU的每个核的缓存中，对于同一数据可能有不同的副本。<h3 id=4-2-3、有序性问题><a class=headerlink href=#4-2-3、有序性问题 title=4.2.3、有序性问题></a>4.2.3、有序性问题</h3><p><strong>现代的处理器使用 写缓冲区 临时保存向内存写入的数据。</strong>写缓冲区可以保证指令流水线持续运行，可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。它可以通过 批处理 刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写来减少对内存总线的占用。<p>但要注意，<strong>每个处理器上的写缓冲区，仅仅对它所在的处理器可见。</strong>这个特性会对内存操作的执行顺序产生重要影响：<strong>处理器对内存读/写操作的执行顺序不一定与内存实际发生的读/写操作顺序一致。</strong><p>由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的 顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此 现代的处理器都会允许对写-读操作进行重排序。<p>为提高性能，编译器和处理器会对指令做重排序。重排序分3种类型：<ol><li>编译器优化重排序。（编译器重排序）<li>指令级并行重排序。（处理器重排序）<li>内存系统重排序。（处理器重排序）</ol><p>从Java源代码到最终执行的指令序列，会经历下面3种重排序：<p><img alt=Java内存模型-1.1-指令重排序-源码到执行指令间的重排序过程 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-1.1-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F-%E6%BA%90%E7%A0%81%E5%88%B0%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4%E9%97%B4%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B.png?token=AIGEF3PREC67A44L2UZB5ADEZZX4Q><p><strong>重排序可能会导致多线程程序出现内存可见性问题。</strong><h3 id=4-2-4、内存模型><a class=headerlink href=#4-2-4、内存模型 title=4.2.4、内存模型></a>4.2.4、内存模型</h3><p><strong>CPU多级缓存导致的一致性问题、CPU时间片机制导致的原子性问题、以及处理器优化和指令重排导致的有序性问题等，都是由硬件不断升级导致。</strong><p>为了保证并发编程中可以满足原子性、可见性及有序性，内存模型 就出现了。<p>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器、缓存、并发、编译器有关。它解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。<p><strong>Java语言为了屏蔽掉底层差异，定义了一套属于Java语言的内存模型规范，即Java内存模型。</strong><h2 id=4-3、底层实现><a class=headerlink href=#4-3、底层实现 title=4.3、底层实现></a>4.3、底层实现</h2><h3 id=4-3-1、happens-before><a class=headerlink href=#4-3-1、happens-before title=4.3.1、happens-before></a>4.3.1、happens-before</h3><p>happens-before的概念最初由<em><strong>Leslie Lamport</strong></em>在其一篇影响深远的论文（《Time，Clocks and the Ordering of Events in a Distributed System》）中提出。<p>从JDK 5开始，Java使用新的JSR-133内存模型。JSR-133使用happens-before的概念来指定两个操作之间的执行顺序。<p>在JMM中，<strong>如果一 个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。</strong>这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。<p><strong>happens-before规则有8个</strong>，详情如下：<ul><li><strong>程序次序规则</strong>：一个线程中的每个操作，happens-before于该线程中的任意后续操作。（线程中的代码顺序执行）<li><strong>管程锁定规则</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。（先解锁后加锁）<li><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的 读。（先volatile写后volatile读）<li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。<li><strong>对象终结规则</strong>：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize()方法的开始。<li><strong>线程启动规则</strong>：Thread对象的start()方法先行发生于此线程的每一个动作。<li><strong>线程中断规则</strong>：对线程interrupt()方法的调用先行发生于被中断线程 的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生。<li><strong>线程终止规则</strong>：线程中的所有操作都先行发生于对此线程的终止检 测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。</ul><p>JMM把happens-before 要求禁止的重排序分为下面两种：<ul><li><p><strong>会改变程序执行结果的重排序</strong>。</p> <p>对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。</p><li><p><strong>不会改变程序执行结果的重排序</strong>。</p> <p>对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM允许这种 重排序）。</p></ul><blockquote><p>两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个 操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一 个操作按顺序排在第二个操作之前。<p>如果前一个操作的结果不需要对后一个操作可见，且前后两个操作按happens-before关系来执行 与 不按照happens-before关系来执行的结果如果完全一致，那么JMM允许这种重排序。</blockquote><h3 id=4-3-2、as-if-serial><a class=headerlink href=#4-3-2、as-if-serial title=4.3.2、as-if-serial></a>4.3.2、as-if-serial</h3><p>as-if-serial语义是：<strong>不管怎么重排序（编译器和处理器为了提高并行度），（单线程） 程序的执行结果不能被改变。</strong>编译器、runtime和处理器都必须遵守as-if-serial语义。<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。<p>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证了正确同步的多线程程序执行结果的正确性。<h3 id=4-3-3、volatile内存语义><a class=headerlink href=#4-3-3、volatile内存语义 title=4.3.3、volatile内存语义></a>4.3.3、volatile内存语义</h3><h4 id=volatile写内存语义><a class=headerlink href=#volatile写内存语义 title=volatile写内存语义></a>volatile写内存语义</h4><p><strong>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</strong><h4 id=volatile读内存语义><a class=headerlink href=#volatile读内存语义 title=volatile读内存语义></a>volatile读内存语义</h4><p><strong>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</strong><h4 id=底层实现><a class=headerlink href=#底层实现 title=底层实现></a>底层实现</h4><p><strong>为了实现volatile内存语义，JMM会限制 编译器重排序 和 处理器重排序。</strong><p>JMM禁止 编译器重排序 的规则如下：<p><img alt=image-20230805235157835 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805235157835.png?token=AIGEF3KZOENBUAHU2SOPZ2DEZZYFW><blockquote><p>在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量重排序。</blockquote><h3 id=4-3-4、锁内存语义><a class=headerlink href=#4-3-4、锁内存语义 title=4.3.4、锁内存语义></a>4.3.4、锁内存语义</h3><h4 id=锁获取内存语义><a class=headerlink href=#锁获取内存语义 title=锁获取内存语义></a>锁获取内存语义</h4><p><strong>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的 临界区代码必须从主内存中读取共享变量。</strong><h4 id=锁释放内存语义><a class=headerlink href=#锁释放内存语义 title=锁释放内存语义></a>锁释放内存语义</h4><p><strong>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。</strong><blockquote><p>对比锁释放-获取的内存语义与volatile写-读的内存语义可以看出：锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。</blockquote><h4 id=公平锁和非公平锁内存语义><a class=headerlink href=#公平锁和非公平锁内存语义 title=公平锁和非公平锁内存语义></a>公平锁和非公平锁内存语义</h4><ul><li>公平锁和非公平锁释放时，最后都要写一个volatile变量state。<li>公平锁获取时，首先会去读volatile变量。<li>非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile 写的内存语义。</ul><h3 id=4-3-4、final域内存语义><a class=headerlink href=#4-3-4、final域内存语义 title=4.3.4、final域内存语义></a>4.3.4、final域内存语义</h3><p>对于final域，编译器和处理器要遵守两个重排序规则：<ol><li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两者不能重排序。<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能 重排序。</ol><h3 id=4-4-1、原子性><a class=headerlink href=#4-4-1、原子性 title=4.4.1、原子性></a>4.4.1、原子性</h3><p><strong>Java为了保证原子性，提供了两个高级字节码指令<code>monitorenter</code>和<code>monitorexit</code>。在Java中对应的关键字就是synchronized。</strong><p>Java中可以使用synchronized来保证方法和代码块内操作的原子性。<h3 id=4-4-2、可见性><a class=headerlink href=#4-4-2、可见性 title=4.4.2、可见性></a>4.4.2、可见性</h3><p>Java中的关键字volatile有一个功能：<strong>被其修饰的变量在被修改后必须立即同步到主内存，被其修饰的变量在每次使用时都必须从主内存获取。</strong>因此，可以使用volatile来保证多线程操作时变量的可见性。<p>除了volatile，Java中的synchronized和final关键字也可以实现可见性。只不过实现方式不同。<h3 id=4-4-3、有序性><a class=headerlink href=#4-4-3、有序性 title=4.4.3、有序性></a>4.4.3、有序性</h3><p><strong>Java在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。</strong>JMM把内存屏障指令分为4类：<p><img alt=Java内存模型-1.2-可见性-内存屏障类型 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-1.2-%E5%8F%AF%E8%A7%81%E6%80%A7-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E7%B1%BB%E5%9E%8B.png?token=AIGEF3LKY332SGI2CDZSVN3EZZYI2><p><strong>StoreLoad Barriers是一个全能型屏障，它同时具有其他3个屏障的效果。</strong>目前 处理器大多支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为 处理器 要把 写缓冲区数据 全部刷新到内存中（Buffer Fully Flush）。<p>Java中的 synchronized 和 volatile 都可以保证多线程之间操作的有序性。区别：<ul><li>volatile关键字 能 禁止指令重排。<li>synchronized关键字 能 保证同一时刻只有一条线程运行。</ul><h1 id=5、JAVA并发><a class=headerlink href=#5、JAVA并发 title=5、JAVA并发></a>5、JAVA并发</h1><h2 id=5-1、Synchronized><a class=headerlink href=#5-1、Synchronized title=5.1、Synchronized></a>5.1、Synchronized</h2><h3 id=5-1-1、简介><a class=headerlink href=#5-1-1、简介 title=5.1.1、简介></a>5.1.1、简介</h3><p>synchronized一直被认为是重量级锁。随着Java SE 1.6对<code>synchronized</code>进行了各种优化之后，它就并不那么重了。<p><strong>Java SE 1.6中，锁共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，这几个状态会随着竞争情况逐渐升级。</strong>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。<h3 id=5-1-2、底层实现><a class=headerlink href=#5-1-2、底层实现 title=5.1.2、底层实现></a>5.1.2、底层实现</h3><ul><li><p>Java源码层级：synchronized(o)。</p><li><p>字节码层级：</p> <ul><li>synchronized修饰方法（包括实例方法和静态方法）：添加访问标志<code>ACC_SYNCHRONIZED</code>。<li>synchronized修饰同步块：一般情况下都是添加 1个monitor enter 和 2个monitor exit，如果在同步方法中显式抛出异常，那么只会有1个monitor enter 和 1个monitor exit。</ul><li><p>JVM层级：基于操作系统提供的同步机制。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">T01_Sync1</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>Object</span> <span class=variable>o</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Object</span>();</span><br><span class=line>        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>com.T01_Sync1$Lock object internals:</span><br><span class=line> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class=line>      <span class=number>0</span>     <span class=number>4</span>   (object header)  <span class=number>05</span> <span class=number>00</span> <span class=number>00</span> <span class=number>00</span> (<span class=number>00000101</span> <span class=number>00000000</span> <span class=number>00000000</span> <span class=number>00000000</span>) (<span class=number>5</span>)</span><br><span class=line>      <span class=number>4</span>     <span class=number>4</span>   (object header)  <span class=number>00</span> <span class=number>00</span> <span class=number>00</span> <span class=number>00</span> (<span class=number>00000000</span> <span class=number>00000000</span> <span class=number>00000000</span> <span class=number>00000000</span>) (<span class=number>0</span>)</span><br><span class=line>      <span class=number>8</span>     <span class=number>4</span>   (object header)  <span class=number>49</span> ce <span class=number>00</span> <span class=number>20</span> (<span class=number>01001001</span> <span class=number>11001110</span> <span class=number>00000000</span> <span class=number>00100000</span>) (<span class=number>536923721</span>)</span><br><span class=line>     <span class=number>12</span>     <span class=number>4</span>        (loss due to the next object alignment)</span><br><span class=line>Instance size: <span class=number>16</span> bytes</span><br><span class=line>Space losses: <span class=number>0</span> bytes internal + <span class=number>4</span> <span class=type>bytes</span> <span class=variable>external</span> <span class=operator>=</span> <span class=number>4</span> bytes total</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>com.T02_Sync2$Lock object internals:</span><br><span class=line> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class=line>      <span class=number>0</span>     <span class=number>4</span>   (object header)  <span class=number>05</span> <span class=number>90</span> 2e 1e (<span class=number>00000101</span> <span class=number>10010000</span> <span class=number>00101110</span> <span class=number>00011110</span>) (<span class=number>506368005</span>)</span><br><span class=line>      <span class=number>4</span>     <span class=number>4</span>   (object header)  1b <span class=number>02</span> <span class=number>00</span> <span class=number>00</span> (<span class=number>00011011</span> <span class=number>00000010</span> <span class=number>00000000</span> <span class=number>00000000</span>) (<span class=number>539</span>)</span><br><span class=line>      <span class=number>8</span>     <span class=number>4</span>   (object header)  <span class=number>49</span> ce <span class=number>00</span> <span class=number>20</span> (<span class=number>01001001</span> <span class=number>11001110</span> <span class=number>00000000</span> <span class=number>00100000</span>) (<span class=number>536923721</span>)</span><br><span class=line>     <span class=number>12</span>     <span class=number>4</span>        (loss due to the next object alignment)</span><br><span class=line>Instance size: <span class=number>16</span> bytes</span><br><span class=line>Space losses: <span class=number>0</span> bytes internal + <span class=number>4</span> <span class=type>bytes</span> <span class=variable>external</span> <span class=operator>=</span> <span class=number>4</span> bytes tota</span><br></pre></table></figure><li><p>OS/硬件层面</p> <ul><li>X86：使用指令 lock cmpxchg xxx 来实现。</ul></ul><h3 id=5-1-3、锁优化><a class=headerlink href=#5-1-3、锁优化 title=5.1.3、锁优化></a>5.1.3、锁优化</h3><h4 id=自旋锁与自适应自旋><a class=headerlink href=#自旋锁与自适应自旋 title=自旋锁与自适应自旋></a>自旋锁与自适应自旋</h4><p><strong>JDK 1.4.2引入了自旋锁，默认关闭，可使用参数<code>-XX:+UseSpinning</code>开启，JDK 6中改为默认开启。</strong><p>自旋等待不能代替阻塞，自旋等待虽然避免了线程切换的开销，但它要占用处理器时间，如果锁被占用的时间很短，自旋等待效果就会非常好，反之如果锁被占用时间很长，那么自旋线程只会白白消耗处理器资源，这会带来性能的浪费。因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍没有获得锁，就应当使用传统方式挂起线程。<strong>自旋次数默认是十次，也可以使用参数<code>-XX:PreBlockSpin</code>来修改。</strong><p><strong>JDK 6对自旋锁做了优化，引入了自适应自旋。</strong>自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待更长时间。另一方面，如果对于某个锁，自旋很少成功获得锁，那么后期再获取这个锁时可能直接省略自旋过程，以避免浪费处理器资源。<p><strong>JDK7之后就不能控制是否开启自旋功能了。</strong><h4 id=锁消除><a class=headerlink href=#锁消除 title=锁消除></a>锁消除</h4><p><strong>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但实际不会发生共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">add</span><span class=params>(String str1,String str2)</span>{</span><br><span class=line>    <span class=type>StringBuffer</span> <span class=variable>sb</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StringBuffer</span>();</span><br><span class=line>    sb.append(str1).append(str2);</span><br><span class=line>}</span><br></pre></table></figure><p>StringBuffer是线程安全的，因为它的关键方法被<code>synchronized</code>修饰。引用sb只会在<code>add</code>方法中使用，不会发生方法逃逸和线程逃逸，故JVM会自动消除掉StringBuffer对象内部的锁。<blockquote><p>在JDK 5之前，字符串加法会转化为StringBuffer 对象的连续append()操作，在JDK 5及以后的版本中，会转化为StringBuilder对象的连续append()操作。</blockquote><h4 id=锁粗化><a class=headerlink href=#锁粗化 title=锁粗化></a>锁粗化</h4><p>原则上，在编写代码时，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了尽可能减少需要同步的操作数量，即使存在锁竞争，等待锁的线程也能尽快地拿到锁。<p>大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作出现在循环体之中，那即使没有线程竞争，频繁进行互斥同步操作也会导致不必要的性能损耗。<p>比如以下代码，没有锁粗化时需要执行100次加锁/解锁操作，执行 锁粗化 优化后只需要加一次锁即可。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> String <span class="title function_">test</span><span class=params>(String str)</span>{</span><br><span class=line>    <span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=type>StringBuffer</span> <span class=variable>sb</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StringBuffer</span>():</span><br><span class=line>    <span class=keyword>while</span>(i < <span class=number>100</span>){</span><br><span class=line>    	sb.append(str);</span><br><span class=line>    	i++;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> sb.toString():</span><br><span class=line>}</span><br></pre></table></figure><h4 id=偏向锁><a class=headerlink href=#偏向锁 title=偏向锁></a>偏向锁</h4><h5 id=简介-1><a class=headerlink href=#简介-1 title=简介></a>简介</h5><p><strong>JDK 6引入偏向锁，目的是消除数据在无竞争情况下的同步原语， 进一步提高程序运行性能。</strong>如果说轻量级锁是在无竞争情况下 使用CAS 来替换 使用互斥量，那偏向锁就是在无竞争情况下去掉同步和CAS。<p>偏向锁中的“偏”，就是偏心的“偏”、偏袒的“偏”。它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，没有其它线程来获取这个锁，则持有偏向锁的线程将永远不需要再进行同步。<h5 id=工作过程><a class=headerlink href=#工作过程 title=工作过程></a>工作过程</h5><p><strong>当锁对象第一次被线程获取时，虚拟机会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后再次进入同步块时，就不需要再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作 等）。</strong><p>若有其它线程尝试获取锁，偏向模式会马上结束。根据锁对象目前是否处于被锁定的状态来决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位 为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照轻量级锁工作流程来执行。<h5 id=总结><a class=headerlink href=#总结 title=总结></a>总结</h5><p>当对象进入偏向状态时，Mark Word大部分的空间（23个比特）都用于存储持有锁的线程ID了，这部分空间占用了原有存储对象哈希码的位置，那原来对象的哈希码怎么办呢？<p>一个对象如果计算过哈希码，就应该一直保持该值不变（推荐但不强制，因为用户可以重载hashCode()方法），否则很多依赖对象哈希码的API都可能存在出错风险。而作为绝大多数对象哈希码来源的Object::hashCode()方法，返回的是对象的一致性哈希码（Identity Hash Code），这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一 次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变。因此，<strong>当一个对象已经计算过一 致性哈希码后，它就再也无法进入偏向锁状态了</strong>；而<strong>当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁</strong>。在重量级锁实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码。<blockquote><p><font color=red>注意：如果请求获取的hashcode值来源于对Object::hashCode()或者System::identityHashCode(Object)方法的调用，那么才会撤销偏向锁并升级为重量级锁；反之，如果重写了对象的hashCode()方法，计算哈希码时并不会触发偏向锁的撤销和重量级锁的升级。</font></blockquote><p>偏向锁可以提高带有同步但无竞争的程序性能，但它同样是一个带有效益权衡（Trade Off）性质的优化，也就是说它并非总是对程序运行有利。如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数<code>-XX:-UseBiasedLocking</code>来禁止偏向锁优化反而可以提升性能。<h4 id=轻量级锁><a class=headerlink href=#轻量级锁 title=轻量级锁></a>轻量级锁</h4><h5 id=简介-2><a class=headerlink href=#简介-2 title=简介></a>简介</h5><p><strong>JDK 6引入了轻量级锁。</strong>“轻量级”是相对于使用操作系统互斥量来实现锁而言，因此传统锁机制被称为“重量级”锁。轻量级锁并不能代替重量级锁，它设计的初衷是在没有多线程竞争的前提下，减少重量级锁使用操作系统互斥量产生的性能消耗。<h5 id=工作过程-1><a class=headerlink href=#工作过程-1 title=工作过程></a>工作过程</h5><p><strong>在代码即将进入同步块时，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word）。</strong><p>然后，虚拟机将<strong>使用CAS操作尝试把锁对象的Mark Word更新为指向Lock Record的指针</strong>。<ul><li>如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且锁对象Mark Word的锁标志位（Mark Word的 最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。<li>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志状态值变为“10”，此时锁对象Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。</ul><p>上面描述的是轻量级锁的加锁过程，它的解锁过程也同样是通过CAS操作来进行，如果对象的 Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，那么就要在释放锁的同时，唤醒被挂起的线程。<h5 id=总结-1><a class=headerlink href=#总结-1 title=总结></a>总结</h5><p>轻量级锁能提升程序同步性能的依据是”对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下， 轻量级锁反而会比传统的重量级锁更慢。<p>偏向锁、轻量级锁的状态转化及对象Mark Word的关系如下图所示：<p><img alt=偏向锁、轻量级锁与MarkWord的关系 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E4%B8%8EMarkWord%E7%9A%84%E5%85%B3%E7%B3%BB.png?token=AIGEF3IKANGCKSJOPH3WQ2LEZZYK6><h3 id=5-1-4、锁升级><a class=headerlink href=#5-1-4、锁升级 title=5.1.4、锁升级></a>5.1.4、锁升级</h3><h4 id=5-1-4-1、无锁状态><a class=headerlink href=#5-1-4-1、无锁状态 title=5.1.4.1、无锁状态></a>5.1.4.1、无锁状态</h4><p><strong>new一个对象，默认就是无锁状态。</strong><h4 id=5-1-4-2、偏向锁><a class=headerlink href=#5-1-4-2、偏向锁 title=5.1.4.2、偏向锁></a>5.1.4.2、偏向锁</h4><h5 id=偏向锁来历><a class=headerlink href=#偏向锁来历 title=偏向锁来历></a>偏向锁来历</h5><p>HotSpot作者研究发现，通常不存在锁竞争，而是一个线程经常多次获得同一个锁。所以每次都要竞争锁会消耗很多资源，为了降低获取锁的代价就引入了偏向锁。<h5 id=偏向锁获取><a class=headerlink href=#偏向锁获取 title=偏向锁获取></a>偏向锁获取</h5><p><strong>首次访问锁的线程，偏向锁会偏向于该线程。有其它线程争夺锁时会撤销偏向锁，然后升级为轻量级锁。</strong><p>偏向锁 获取和撤销 过程描述如下：<p>当锁对象首次被线程获取时，会将获取到该锁的线程ID记录在锁对象的Mark Word中，以后该线程在进入和退出 同步块时不需要执行CAS操作来加锁和解锁：<ul><li>如果一致（依然是线程1获取锁对象），则无需通过CAS进行加锁、解锁；<li>如果不一致（其他线程（线程2）要竞争锁对象），则需要检查Java对象头中记录的线程1是否存活：<ul><li>如果没有存活，那么锁状态将被重置为无锁状态，其它线程（线程2）可以将其设为偏向锁；<li>如果存活，那么检查该线程（线程1）的栈帧信息，如果线程1依然需要这个锁，则暂停当前线程1并撤销偏向锁，然后升级为轻量级锁。如果线程1 不再使用该锁对象，那么锁状态将被设为无锁状态，然后重新偏向新的线程。</ul></ul><p>获取偏向锁详细步骤 参考如下：<ol><li>验证对象的bias位。如果是0，则表示该对象不可偏向，应该使用轻量级锁算法。<li>验证对象所属InstanceKlass的prototype的bias位是否被设置。如果没有设置，则该类所有对象全部不允许被偏向锁定，且所有对象的bias位都需要被重置，使用轻量级锁来替换。<li>校验epoch位。校验对象头中MarkWord的epoch位是否与该对象所属InstanceKlass的prototype的MarkWord的epoch匹配。如果不匹配，则表明偏向已过期，需要重新偏向。偏向线程可以通过CAS指令重新偏向于这个锁对象。<li>校验owner线程。比较偏向线程ID与当前线程ID。如果匹配，则表明当前线程已经获得了偏向，可以安全返回。如果不匹配，对象锁被假定为匿名偏向状态，当前线程应该尝试使用CAS指令获得偏向。如果失败的话，就尝试撤销(很可能引入安全点)，然后回退到轻量级锁；如果成功，当前线程成功获得偏向，可直接返回。</ol><h5 id=偏向锁关闭><a class=headerlink href=#偏向锁关闭 title=偏向锁关闭></a>偏向锁关闭</h5><p><strong>偏向锁在Java 6和Java 7中默认启用，但它仅在程序启动几秒后才激活，可通过JVM参数<code>-XX:BiasedLockingStartupDelay=0</code>来关闭该延迟。</strong><p><strong>如果程序线程通常处于竞争状态，可以通过JVM参数<code>-XX:-UseBiasedLocking</code>关闭偏向锁，那么程序默认会直接进入轻量级锁状态。</strong><p>HotSpot支持 存储/释放 偏向锁，以及偏向锁的批量重偏向和撤销。这个特性可以通过JVM参数进行切换，且默认支持。Unlock状态下MarkWord的一个比特位用于标识该对象偏向锁是否被使用或者是否被禁止。如果该bit位为0，则该对象未被锁定，并且禁止偏向；如果该bit位为1，则意味着该对象处于以下三种状态：<ol><li><font color=orange>匿名偏向(Anonymously Biased)</font><li><font color=orange>可重偏向(Rebiasable)</font><li><font color=orange>已偏向(Biased)</font></ol><h4 id=5-1-4-3、轻量级锁><a class=headerlink href=#5-1-4-3、轻量级锁 title=5.1.4.3、轻量级锁></a>5.1.4.3、轻量级锁</h4><h5 id=轻量级锁来历><a class=headerlink href=#轻量级锁来历 title=轻量级锁来历></a>轻量级锁来历</h5><p><strong>轻量级锁适用于 并发高但执行时间短的场景。</strong>线程阻塞将导致用户态与内核态的切换，若阻塞时间很短后锁就被释放了，那么代价会更大。为解决该问题，轻量级锁就出现了。<h5 id=轻量级锁加锁><a class=headerlink href=#轻量级锁加锁 title=轻量级锁加锁></a>轻量级锁加锁</h5><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用 CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。<h5 id=轻量级锁解锁><a class=headerlink href=#轻量级锁解锁 title=轻量级锁解锁></a>轻量级锁解锁</h5><p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。<h5 id=轻量级锁升级><a class=headerlink href=#轻量级锁升级 title=轻量级锁升级></a>轻量级锁升级</h5><p>轻量级锁的升级过程描述如下：<ol><li>线程1获取轻量级锁时会先把锁对象对象头的MarkWord拷贝一份放到线程1栈帧中（称为DisplacedMarkWord），然后通过CAS方式把对象头中的内容替换为指向线程1中锁记录（DisplacedMarkWord）的指针。<li>线程1在修改替换对象头时，线程2进来也需要执行相关操作，但线程2在执行CAS时发现线程1已经把对象头换了，此时线程2的CAS会失败，然后线程2会尝试使用自旋锁来等待线程1释放锁。<li>线程2自旋次数达到上限时还没有获取锁，那么线程2就会将轻量级锁升级为重量级锁，然后线程2会进入到重量级锁的等待队列中进行等待，后续来的线程也会进入该队列进行等待，直到线程1执行完毕释放了锁，然后唤醒等待队列中的线程。</ol><blockquote><p>自旋达到上限时会升级到重量级锁，这里的上限分两种情况：<ul><li><p>Java6之前</p> <ol><li>默认启用，自旋次数的默认值是10次，也可以使用参数<code>-XX：PreBlockSpin</code>来修改。<li>或者，自旋线程数量超过CPU核数一半时升级为重量级锁。</ol><li><p>Java6之后，引入自适应自旋，自旋次数不再固定，而是根据：同一把锁上次的自旋时间 和 拥有锁的线程的状态来决定。</p> <ol><li>如果线程自旋成功，那么下次自旋的最大次数就会增加，因为JVM会认为上次都已经成功了，那么这次一定也会成功。<li>如果自旋很少成功，那么下次会减少自旋次数甚至是不再自旋，避免CPU空转，消费资源。</ol></ul></blockquote><p><font color=red>注意：</font><p>使用CAS自旋去争夺锁，会导致无意义的CPU占用。所以，<strong>轻量级锁适用于 线程少且执行时间短 的场景。</strong><h4 id=5-1-4-4、重量级锁><a class=headerlink href=#5-1-4-4、重量级锁 title=5.1.4.4、重量级锁></a>5.1.4.4、重量级锁</h4><p>重量级锁竞争时，可以使用自旋来优化。如果当前线程自旋成功（其它线程释放了锁，当前线程获取了锁），那么就可以避免当前线程被阻塞。如果自旋次数达到上限时还没有获取锁，那么就会将轻量级锁升级为重量级锁，然后当前线程会进入到重量级锁的等待队列中进行等待，后续来的线程也会进入该队列进行等待，直到拿到锁的线程执行完毕释放了锁，然后才会唤醒等待队列中的线程。<p><strong>重量级锁底层实现是一个Monitor对象，俗称Monitor锁，该对象有WaitSet、EntryList、Owner等重要成员。</strong><p><strong>获取轻量级锁失败的线程会将轻量级锁升级为重量级锁，此时会创建Monitor锁对象，然后会在synchronized修饰的锁对象头的markword中存入Monitor对象的地址并设置锁标识位为10，并设置Monitor锁对象的Owner指向获取锁的线程，获取锁失败的线程会进入到Monitor锁对象的EntryList中进行等待，直到获取锁的线程释放了锁，并将Owner设置为null，然后会唤醒EntryList中等待的线程来重新竞争锁。</strong><h4 id=小结><a class=headerlink href=#小结 title=小结></a>小结</h4><p>锁升级注意事项：<ol><li>为了避免无用自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁；<li>偏向锁升级为轻量级锁也不能再降级为偏向锁；<li>偏向锁状态可以被重置为无锁状态；</ol><p>锁优缺点对比：<p><img alt=Synachonized-1.1-锁的优缺点 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/Synachonized-1.1-%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png?token=AIGEF3NTWUVMKCIFTZIAWITEZZYNA><h3 id=5-1-5、锁降级><a class=headerlink href=#5-1-5、锁降级 title=5.1.5、锁降级></a>5.1.5、锁降级</h3><p><a href=https://zhuanlan.zhihu.com/p/28505703 rel=noopener target=_blank>https://zhuanlan.zhihu.com/p/28505703</a><p><strong>只被<code>VM Thread</code>访问，降级也就没啥意义了。所以可以认为锁降级不存在！</strong><h4 id=降级目的和过程><a class=headerlink href=#降级目的和过程 title=降级目的和过程></a>降级目的和过程</h4><p>因为BasicLocking的实现优先于重量级锁的使用，JVM会尝试在STW的停顿中对处于“空闲(idle)”状态的重量级锁进行降级(deflate)。我们知道在STW时，所有的Java线程都会暂停在“安全点(SafePoint)”，此时VM Thread通过对所有Monitor进行遍历，或者通过对所有依赖于<code>MonitorInUseLists</code>值的当前正在“使用”中的<code>Monitor</code>子序列进行遍历，从而得到那些未被使用的“Monitor”并将之作为降级对象。<h4 id=降级对象><a class=headerlink href=#降级对象 title=降级对象></a>降级对象</h4><p><strong>重量级锁的降级发生于STW阶段，降级对象就是那些仅仅能被 VM Thread 访问而没有被其它 Java Thread 访问的Monitor对象。</strong><h4 id=HotSpot-VM实现><a title="HotSpot VM实现" class=headerlink href=#HotSpot-VM实现></a>HotSpot VM实现</h4><p>HotSpot VM锁降级底层实现，可以参考：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> ObjectSynchronizer::deflate_idle_monitors() {</span><br><span class=line>  <span class=keyword>assert</span>(SafepointSynchronize::is_at_safepoint(), <span class=string>"must be at safepoint"</span>);</span><br><span class=line>  <span class=type>int</span> <span class=variable>nInuse</span> <span class=operator>=</span> <span class=number>0</span> ;              <span class=comment>// currently associated with objects</span></span><br><span class=line>  <span class=type>int</span> <span class=variable>nInCirculation</span> <span class=operator>=</span> <span class=number>0</span> ;      <span class=comment>// extant</span></span><br><span class=line>  <span class=type>int</span> <span class=variable>nScavenged</span> <span class=operator>=</span> <span class=number>0</span> ;          <span class=comment>// reclaimed</span></span><br><span class=line>  <span class=type>bool</span> <span class=variable>deflated</span> <span class=operator>=</span> <span class=literal>false</span>;</span><br><span class=line></span><br><span class=line>  ObjectMonitor * FreeHead = NULL ;  <span class=comment>// Local SLL of scavenged monitors</span></span><br><span class=line>  ObjectMonitor * FreeTail = NULL ;</span><br><span class=line></span><br><span class=line>  TEVENT (deflate_idle_monitors) ;</span><br><span class=line><span class=comment>// Prevent omFlush from changing mids in Thread dtor's during deflation</span></span><br><span class=line><span class=comment>// And in case the vm thread is acquiring a lock during a safepoint</span></span><br><span class=line><span class=comment>// See e.g. 6320749</span></span><br><span class=line>  Thread::muxAcquire (&ListLock, <span class=string>"scavenge - return"</span>) ;</span><br><span class=line></span><br><span class=line>  <span class=keyword>if</span> (MonitorInUseLists) {</span><br><span class=line>    <span class=type>int</span> <span class=variable>inUse</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>for</span> (JavaThread* cur = Threads::first(); cur != NULL; cur = cur->next()) {</span><br><span class=line>      nInCirculation+= cur->omInUseCount;</span><br><span class=line>      <span class=type>int</span> <span class=variable>deflatedcount</span> <span class=operator>=</span> walk_monitor_list(cur->omInUseList_addr(), &FreeHead, &FreeTail);</span><br><span class=line>      cur->omInUseCount-= deflatedcount;</span><br><span class=line><span class=comment>// verifyInUse(cur);</span></span><br><span class=line>      nScavenged += deflatedcount;</span><br><span class=line>      nInuse += cur->omInUseCount;</span><br><span class=line>     }</span><br><span class=line></span><br><span class=line><span class=comment>// For moribund threads, scan gOmInUseList</span></span><br><span class=line>   <span class=keyword>if</span> (gOmInUseList) {</span><br><span class=line>     nInCirculation += gOmInUseCount;</span><br><span class=line>     <span class=type>int</span> <span class=variable>deflatedcount</span> <span class=operator>=</span> walk_monitor_list((ObjectMonitor **)&gOmInUseList, &FreeHead, &FreeTail);</span><br><span class=line>     gOmInUseCount-= deflatedcount;</span><br><span class=line>     nScavenged += deflatedcount;</span><br><span class=line>     nInuse += gOmInUseCount;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>  } <span class=keyword>else</span> <span class=keyword>for</span> (ObjectMonitor* block = gBlockList; block != NULL; block = next(block)) {</span><br><span class=line>	<span class=comment>// Iterate over all extant monitors - Scavenge all idle monitors.</span></span><br><span class=line>    <span class=keyword>assert</span>(block->object() == CHAINMARKER, <span class=string>"must be a block header"</span>);</span><br><span class=line>    nInCirculation += _BLOCKSIZE ;</span><br><span class=line>    <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>1</span> ; i < _BLOCKSIZE; i++) {</span><br><span class=line>      ObjectMonitor* mid = &block[i];</span><br><span class=line>      <span class=type>oop</span> <span class=variable>obj</span> <span class=operator>=</span> (oop) mid->object();</span><br><span class=line></span><br><span class=line>      <span class=keyword>if</span> (obj == NULL) {</span><br><span class=line>          <span class=comment>// The monitor is not associated with an object.</span></span><br><span class=line>          <span class=comment>// The monitor should either be a thread-specific private</span></span><br><span class=line>          <span class=comment>// free list or the global free list.</span></span><br><span class=line>          <span class=comment>// obj == NULL IMPLIES mid->is_busy() == 0</span></span><br><span class=line>        guarantee (!mid->is_busy(), <span class=string>"invariant"</span>) ;</span><br><span class=line>        <span class=keyword>continue</span> ;</span><br><span class=line>      }</span><br><span class=line>      deflated = deflate_monitor(mid, obj, &FreeHead, &FreeTail);</span><br><span class=line></span><br><span class=line>      <span class=keyword>if</span> (deflated) {</span><br><span class=line>        mid->FreeNext = NULL ;</span><br><span class=line>        nScavenged ++ ;</span><br><span class=line>      } <span class=keyword>else</span> {</span><br><span class=line>        nInuse ++;</span><br><span class=line>      }</span><br><span class=line>    }</span><br><span class=line>  }</span><br><span class=line>  MonitorFreeCount += nScavenged;</span><br><span class=line></span><br><span class=line>	<span class=comment>// Consider: audit gFreeList to ensure that MonitorFreeCount and list agree.</span></span><br><span class=line>  <span class=keyword>if</span> (ObjectMonitor::Knob_Verbose) {</span><br><span class=line>    ::printf (<span class=string>"Deflate: InCirc=%d InUse=%d Scavenged=%d ForceMonitorScavenge=%d : pop=%d free=%d\n"</span>,</span><br><span class=line>        nInCirculation, nInuse, nScavenged, ForceMonitorScavenge,</span><br><span class=line>        MonitorPopulation, MonitorFreeCount) ;</span><br><span class=line>    ::fflush(stdout) ;</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  ForceMonitorScavenge = <span class=number>0</span>;    <span class=comment>// Reset</span></span><br><span class=line></span><br><span class=line><span class=comment>// Move the scavenged monitors back to the global free list.</span></span><br><span class=line>  <span class=keyword>if</span> (FreeHead != NULL) {</span><br><span class=line>     guarantee (FreeTail != NULL && nScavenged > <span class=number>0</span>, <span class=string>"invariant"</span>) ;</span><br><span class=line>     <span class=keyword>assert</span> (FreeTail->FreeNext == NULL, <span class=string>"invariant"</span>) ;</span><br><span class=line><span class=comment>// constant-time list splice - prepend scavenged segment to gFreeList</span></span><br><span class=line>     FreeTail->FreeNext = gFreeList ;</span><br><span class=line>     gFreeList = FreeHead ;</span><br><span class=line>  }</span><br><span class=line>  Thread::muxRelease (&ListLock) ;</span><br><span class=line></span><br><span class=line>  <span class=keyword>if</span> (ObjectMonitor::_sync_Deflations != NULL) ObjectMonitor::_sync_Deflations->inc(nScavenged) ;</span><br><span class=line>  <span class=keyword>if</span> (ObjectMonitor::_sync_MonExtant  != NULL) ObjectMonitor::_sync_MonExtant ->set_value(nInCirculation);</span><br><span class=line></span><br><span class=line><span class=comment>// <span class=doctag>TODO:</span> Add objectMonitor leak detection.</span></span><br><span class=line><span class=comment>// Audit/inventory the objectMonitors -- make sure they're all accounted for.</span></span><br><span class=line>  GVars.stwRandom = os::random() ;</span><br><span class=line>  GVars.stwCycle ++ ;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=5-1-6、注意事项><a class=headerlink href=#5-1-6、注意事项 title=5.1.6、注意事项></a>5.1.6、注意事项</h3><ol><li>synchronized(Object)模式下，不能用String常量、Integer、Long等类型来作为锁角色。<li>锁定方法与非锁定方法可同时执行。<li>多个线程必须锁定同一个锁（对象）。（需用final修饰锁对象，防止修改）<li>自旋锁在 JDK1.4.2 中引入，使用 -XX:+UseSpinning 来开启。JDK 6 中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。<li>自适应自旋锁意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。<li>偏向锁由于有锁撤销的过程，会消耗系统资源，所以，在锁争用特别激烈的时候，用偏向锁未必效率高。还不如直接使用轻量级锁。</ol><h2 id=5-2、CAS><a class=headerlink href=#5-2、CAS title=5.2、CAS></a>5.2、CAS</h2><h3 id=5-2-1、简介><a class=headerlink href=#5-2-1、简介 title=5.2.1、简介></a>5.2.1、简介</h3><p><strong>CAS是 Compare And Set/Swap/exchange 的简写，意为比较并交换。</strong><p>cas(V, Expected, NewValue)：V为原值，Expected为期望值。NewValue为新值。在修改原值为新值时，判断原值是否与期望值相同，相同则修改，否则拿到和期望值不同的原值再次进行相同逻辑的修改，一直到修改成功为止，这个过程就称为“自旋”。自旋会无意义消耗CPU，故是否选择使用CAS自旋技术，要根据实际场景来选择：<ul><li>线程数量多且执行时间长，就要避免使用CAS自旋，而要选用重量级锁来代替，因为重量级锁使用的是等待队列，不会消耗CPU。<li>线程数量少且执行时间短，选用CAS自旋会较好。</ul><h3 id=5-2-2、底层实现><a class=headerlink href=#5-2-2、底层实现 title=5.2.2、底层实现></a>5.2.2、底层实现</h3><ol><li>底层指令实现：<ul><li>IA64、X86下：通过<code>lock、cmpxchg</code>指令实现。单纯的<code>cmpxchg</code>不能保证原子性。<li>sparc-TSO下：通过<code>case</code>指令实现。<li>ARM和PowerPC下：通过一对<code>Idrex/strex</code>指令实现。</ul><li>硬件情况下：lock指令在执行后面指令的时候锁定一个北桥信号。<li>拓展知识：处理器 使用总线锁和缓存锁来实现原子操作。</ol><h3 id=5-2-3、CAS缺点><a class=headerlink href=#5-2-3、CAS缺点 title=5.2.3、CAS缺点></a>5.2.3、CAS缺点</h3><ol><li><p>ABA问题。解决方法：加版本号。</p><li><p>自旋时间长。解决方法：如果JVM支持处理器提供的pause指令，那么效率会有一点提升。</p> <ul><li><p>PAUSE指令作用：</p> <ol><li>提升<code>spin-wait loops(自旋锁循环等待)</code>的性能。在执行一个<code>spin-wait loop</code>时，Pentium4 处理器会遇到严重的性能损失，PAUSE 指令会向处理器发起提醒：告诉处理器所执行的代码序列是一个 spin-wait loop。处理器会根据这个提醒而避开内存序列冲突(memory order violation)，也就是说对 spin-wait loop 不做缓存，不做指令重新排序等动作。这样就可以大大的提高了处理器的性能。正是基于此，才建议在 spin-wait loops 中使用 pasuse 指令。<li>减少 Pentium4 处理器在执行 spin-wait loop 时的电源消耗。在等待资源而执行自旋锁等待时，Pentium4 处理器会极速执行从而导致消耗很多电能，而<code>pause</code>指令则可以极大的减少处理器的电能消耗。</ol><li><p>PAUSE指令拓展：</p> <p>PAUSE 指令在 Pentium4 处理器中引入，但它也是向前兼容的。在早先的 IA-32 处理器中，PAUSE 指令实际上就相当于 NOP 指令。</p> <p>Pentium4 处理器以一种 预延迟(pre-defined delay)的技术来实现 PAUSE 指令。这种延迟是有限度的，且在一些处理器上是零延迟。该指令不会改变处理器的处理器状态。</p></ul><li><p>只能保证一个共享变量的原子操作。解决方法：加锁；AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象中执行CAS操作。</p></ol><h3 id=5-2-4、自增操作><a class=headerlink href=#5-2-4、自增操作 title=5.2.4、自增操作></a>5.2.4、自增操作</h3><ul><li><p>Synchronized操作：执行时间长，因为需要用户态与内核态的切换，从而降低了执行效率。</p><li><p>AtomicXXX操作：执行时间较Synch要少，因为使用了CAS自旋/无锁操作。</p><li><p>LongAdder操作：执行时间长，因为使用了分段锁。 适用于并发量大的情况。</p></ul><h2 id=5-3、Volatile><a class=headerlink href=#5-3、Volatile title=5.3、Volatile></a>5.3、Volatile</h2><h3 id=5-3-1、简介><a class=headerlink href=#5-3-1、简介 title=5.3.1、简介></a>5.3.1、简介</h3><p>volatile是轻量级的 synchronized，它在多处理器开发中保证了共享变量的“可见性”。<strong>可见性指的是 当一个线程修改了一个共享变量后，另外一个线程能读到这个共享变量被修改后的值。</strong><p><strong>volatile比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</strong><p>几个重要的CPU术语如下：<p><img alt=CPU术语001 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/CPU%E6%9C%AF%E8%AF%AD001.png?token=AIGEF3NKAFXF6QJXCEDLJ63EZZYPO><p>volatile变量自身具有如下特性。<ul><li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</ul><h3 id=5-3-2、底层实现><a class=headerlink href=#5-3-2、底层实现 title=5.3.2、底层实现></a>5.3.2、底层实现</h3><h4 id=字节码层面><a class=headerlink href=#字节码层面 title=字节码层面></a>字节码层面</h4><p>在volatile修饰的元素前加了一个访问标志：ACC_VOLATILE。<h4 id=JVM层面（规范）><a class=headerlink href=#JVM层面（规范） title=JVM层面（规范）></a>JVM层面（规范）</h4><ol><li><p>StoreStore Barriers - volatile写 - StoreLoad Barriers。</p><li><p>volatile读 - LoadLoad Barriers - LoadStore Barriers。</p></ol><h4 id=hotspot><a class=headerlink href=#hotspot title=hotspot></a>hotspot</h4><p><strong>底层基于大多数CPU都支持的 lock addl 汇编代码指令来实现。</strong><p>Lock前缀的指令在多核处理器下的作用：<ul><li>将当前处理器缓存行的数据写回到系统内存。<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</ul><blockquote><p>对volatile修饰的变量执行写操作时会向处理器发送一条Lock前缀指令，将该变量所在缓存行的数据【写回到系统内存】。但要注意，虽然已经写回内存但其它处理器中关于该变量的缓存依然是旧的，对旧的数据执行操作就会有问题。所以，多处理器下，为了保证各个处理器缓存的一致性，就会实现【缓存一 致性协议】，每个处理器通过嗅探总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作时会重新从系统内存中把数据读到处理器缓存里。<p>volatile有两个实现原则：<ol><li>Lock前缀指令会引起处理器缓存回写到内存。<li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效。</ol></blockquote><h4 id=CPU层面><a class=headerlink href=#CPU层面 title=CPU层面></a>CPU层面</h4><ul><li><p>X86 CPU内存屏障（有序性保证）</p> <ol><li><font color=orange>sfence指令</font>：sfence指令前写 优先于 sfence指令后写。<li><font color=orange>lfence指令</font>：lfence指令前读 优先于 lfence指令后读。<li><font color=orange>mfence指令</font>：mfence指令前读写 优先于 sfence指令后读写。</ol> <p>可惜大多数CPU并不支持这种指令，故hotspor并没有选择这种方案来实现有序性，而是采用大多数CPU都支持的其它指令：lock addl 来实现。</p></ul><h3 id=5-3-3、实现一致性-可见性><a class=headerlink href=#5-3-3、实现一致性-可见性 title=5.3.3、实现一致性/可见性></a>5.3.3、实现一致性/可见性</h3><ol><li>MESI能解决就用MESI。<li>锁总线。</ol><p>为了保证内存可见性，Java编译器会在生成指令序列的适当位置插入 内存屏障指令 来禁止特定类型的处理器重排序。<p><strong>JMM把内存屏障指令分为4类：LoadLoad屏障、StoreStore屏障、LoadStore屏障、StoreLoad屏障。</strong>（详情参考本教程2.4.2节）<h3 id=5-3-4、实现有序性><a class=headerlink href=#5-3-4、实现有序性 title=5.3.4、实现有序性></a>5.3.4、实现有序性</h3><ol><li>内存屏障、sfence mfence lfence等系统原语/指令。sfence mfence lfence为什么不用？因为可移植性差。<li>锁总线。</ol><h3 id=5-3-5、解决指令重排序><a class=headerlink href=#5-3-5、解决指令重排序 title=5.3.5、解决指令重排序></a>5.3.5、解决指令重排序</h3><ol><li><p>代码级别：volatile修饰变量。</p><li><p>字节码级别：加访问修饰符 ACC_VOLATILE。</p><li><p>JVM级别：JVM内存屏障。（屏障两边的指令禁止重排）</p><li><p>Hotspot实现：lock addl指令。</p> <p>为何lock指令可以解决重排序和可见性问题？因为：lock用于在多处理器中执行指令时会对共享内存进行独占使用，其能够将当前处理器对应的缓存的内容刷新到内存中，并使其它处理器相同缓存中的内容失效。此外还提供有序指令无法越过内存屏障的作用。</p><li><p>系统级别：load fence、store fence原语指令。</p></ol><blockquote><p>编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。<p>这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作， 不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。<p>处理器对读/写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守as-if-serial语义，处理器不会对存在数据依赖性的两个内存操作做重排序）。<p>as-if-serial语义：不管怎么重排序（编译器和处理器为了提高并行度），（单线程） 程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。<p><font color=red>注意：在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但允许volatile变量与普通变量重排序。</font></blockquote><p>bytecodeinterpreter.cpp<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=type>int</span> field_offset = cache-><span class=built_in>f2_as_index</span>();</span><br><span class=line><span class=keyword>if</span> (cache-><span class=built_in>is_volatile</span>()) {</span><br><span class=line>    <span class=keyword>if</span> (support_IRIW_for_not_multiple_copy_atomic_cpu) {</span><br><span class=line>        OrderAccess::<span class=built_in>fence</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>orderaccess_linux_x86.inline.hpp<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>inline</span> <span class=type>void</span> <span class=title>OrderAccess::fence</span><span class=params>()</span> </span>{</span><br><span class=line>  <span class=keyword>if</span> (os::<span class=built_in>is_MP</span>()) {</span><br><span class=line>    <span class=comment>// always use locked addl since mfence is sometimes expensive</span></span><br><span class=line>	<span class=meta>#<span class=keyword>ifdef</span> AMD64</span></span><br><span class=line>    	<span class=function>__asm__ <span class=title>volatile</span> <span class=params>(<span class=string>"lock; addl $0,0(%%rsp)"</span> : : : <span class=string>"cc"</span>, <span class=string>"memory"</span>)</span></span>;</span><br><span class=line>	<span class=meta>#<span class=keyword>else</span></span></span><br><span class=line>    	<span class=function>__asm__ <span class=title>volatile</span> <span class=params>(<span class=string>"lock; addl $0,0(%%esp)"</span> : : : <span class=string>"cc"</span>, <span class=string>"memory"</span>)</span></span>;</span><br><span class=line>	<span class=meta>#<span class=keyword>endif</span></span></span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=5-3-6、volatile优化><a class=headerlink href=#5-3-6、volatile优化 title=5.3.6、volatile优化></a>5.3.6、volatile优化</h3><h4 id=追加到64字节><a class=headerlink href=#追加到64字节 title=追加到64字节></a>追加到64字节</h4><p><strong>著名的Java并发编程大师Doug lea在JDK 7的并发包里新增一个队列集合类LinkedTransferQueue，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能。</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=comment>/** 队列中的头部节点 */</span> </span><br><span class=line><span class=keyword>private</span> <span class=keyword>transient</span> <span class=keyword>final</span> PaddedAtomicReference&LTQNode> head; </span><br><span class=line><span class=comment>/** 队列中的尾部节点 */</span> </span><br><span class=line><span class=keyword>private</span> <span class=keyword>transient</span> <span class=keyword>final</span> PaddedAtomicReference&LTQNode> tail; </span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AtomicReference</span>&LTV> <span class=keyword>implements</span> <span class="title class_">java</span>.io.Serializable { </span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>volatile</span> V value; </span><br><span class=line>    <span class=comment>// 省略其他代码 </span></span><br><span class=line>｝</span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=keyword>class</span> <span class="title class_">PaddedAtomicReference</span>&LTT> <span class=keyword>extends</span> <span class="title class_">AtomicReference</span>&LTT> { </span><br><span class=line>    <span class=comment>// 使用很多4个字节的引用追加到64个字节 </span></span><br><span class=line>    Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe; </span><br><span class=line>    PaddedAtomicReference(T r) {</span><br><span class=line>        <span class=built_in>super</span>(r); </span><br><span class=line>    } </span><br><span class=line>}</span><br></pre></table></figure><h4 id=为何追加到64字节？><a class=headerlink href=#为何追加到64字节？ title=为何追加到64字节？></a>为何追加到64字节？</h4><p>因为对于英特尔酷睿i7、酷睿、Atom和 NetBurst，以及Core Solo和Pentium M处理器的L1、L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行。这意味着，如果队列的头节点和尾节点都不足64字节，则处理器会将它们都读到同一个高速缓存行中，多处理器环境下的每个处理器都会缓存同样的头、尾节点，当一 个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致 其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作则需要不断修改头节点，这样一来效率就会大大降低。<p>为解决这种问题，就可以把不足64字节的数据后面追加到64字节，也就是说让队列的头节点和尾节点各占一个缓存行，这样就避免了阻塞节点操作，大大提高效率。<h4 id=注意事项-1><a class=headerlink href=#注意事项-1 title=注意事项></a>注意事项</h4><p>使用volatile变量时一定要追加至64字节的说法并非一定成立。在以下两种场景中不适合：<ol><li><strong>缓存行非64字节宽的处理器</strong>。如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个 字节宽。<li><strong>共享变量不会被频繁地写</strong>。因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。</ol><blockquote><p><font color=red>注意：追加字节的方式在Java 7下可能不生效，因为Java 7更加智慧，它会淘汰或重新排列无用字段，所以，需要使用其它追加字节的方式。除了volatile，Java并发编程中应用较多的是synchronized。</font></blockquote><h3 id=5-3-7、volatile使用指南><a class=headerlink href=#5-3-7、volatile使用指南 title=5.3.7、volatile使用指南></a>5.3.7、volatile使用指南</h3><p>使用volatile时可参考如下两条规则：<ul><li>写后加写屏障，阻止写屏障前代码跑到后面。（写屏障箭头朝上）<li>读前加读屏障，防止读屏障后面代码跑到前面。（读屏障箭头朝下）</ul><p>代码示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line> <span class=keyword>volatile</span> <span class=type>int</span> a;</span><br><span class=line><span class=type>int</span> b;</span><br><span class=line><span class=type>int</span> c;</span><br><span class=line></span><br><span class=line>a = <span class=number>1</span>;	</span><br><span class=line><span class=comment>// 屏障^^^^^^</span></span><br><span class=line>b = <span class=number>2</span>;</span><br><span class=line><span class=comment>// 屏障vvvvvv</span></span><br><span class=line>c = a;</span><br></pre></table></figure><h2 id=5-4、Lock（锁）><a class=headerlink href=#5-4、Lock（锁） title=5.4、Lock（锁）></a>5.4、Lock（锁）</h2><h3 id=5-4-1、简介><a class=headerlink href=#5-4-1、简介 title=5.4.1、简介></a>5.4.1、简介</h3><h4 id=锁类架构图><a class=headerlink href=#锁类架构图 title=锁类架构图></a>锁类架构图</h4><p><img alt=Java中的锁和AQS类结构图01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%92%8CAQS%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE01.png?token=AIGEF3KXLEK2VZACCYGNWBDEZZYRQ><h4 id=Lock接口特性><a class=headerlink href=#Lock接口特性 title=Lock接口特性></a>Lock接口特性</h4><p>Lock接口提供了synchronized不具备的特性，详情如下：<p><img alt=锁-1.1-Lock接口提供了synchronized不具备的特性 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E9%94%81-1.1-Lock%E6%8E%A5%E5%8F%A3%E6%8F%90%E4%BE%9B%E4%BA%86synchronized%E4%B8%8D%E5%85%B7%E5%A4%87%E7%9A%84%E7%89%B9%E6%80%A7.png?token=AIGEF3PVCAV2TJT2GI66CC3EZZYTA><h3 id=5-4-2、乐观锁><a class=headerlink href=#5-4-2、乐观锁 title=5.4.2、乐观锁></a>5.4.2、乐观锁</h3><h4 id=5-4-2-1、简介><a class=headerlink href=#5-4-2-1、简介 title=5.4.2.1、简介></a>5.4.2.1、简介</h4><p><strong>乐观锁代表是 AtomicInteger，使用 CAS 保证原子性。</strong><p>乐观锁 核心思想：无需加锁，每次只有一个线程能 成功修改 共享变量，其它线程会不断重试直到成功。<blockquote><p>乐观锁常见实现就是CAS算法，java java.util.concurrent包下原子类(例如<code>AtomicBoolean</code>，<code>AtomicInteger</code>，<code>AtomicLong</code>)中的递增操作就是通过CAS自旋来实现。</blockquote><h4 id=5-4-2-2、特点><a class=headerlink href=#5-4-2-2、特点 title=5.4.2.2、特点></a>5.4.2.2、特点</h4><ul><li>线程一直运行，不会阻塞，故不存在线程上下文切换。<li>需要多核CPU支持，线程数不应该超过 CPU核心数量。</ul><h4 id=5-4-2-3、适用场景><a class=headerlink href=#5-4-2-3、适用场景 title=5.4.2.3、适用场景></a>5.4.2.3、适用场景</h4><p><strong>乐观锁适用于多读场景，不加锁可以提高读操作性能。</strong><h3 id=5-4-3、悲观锁><a class=headerlink href=#5-4-3、悲观锁 title=5.4.3、悲观锁></a>5.4.3、悲观锁</h3><h4 id=5-4-3-1、简介><a class=headerlink href=#5-4-3-1、简介 title=5.4.3.1、简介></a>5.4.3.1、简介</h4><p><strong>悲观锁代表是 synchronized 和 Lock 锁。</strong><p>悲观锁核心思想：线程占有了锁，才能操作共享变量，每次只能有一个线程占有锁，其它获线程都要等待。<h4 id=5-4-3-2、特点><a class=headerlink href=#5-4-3-2、特点 title=5.4.3.2、特点></a>5.4.3.2、特点</h4><ul><li>线程从运行到阻塞，再从阻塞到唤醒，期间经历 线程上下文切换，若频繁发生，则会严重影响性能。<li>获取 synchronized 和 Lock 锁时，若锁已被占用，那么会默认重试几次，减少阻塞机会。</ul><h4 id=5-4-3-3、适用场景><a class=headerlink href=#5-4-3-3、适用场景 title=5.4.3.3、适用场景></a>5.4.3.3、适用场景</h4><p><strong>悲观锁适用于多写场景，先加锁可以保证写操作时数据的正确性。</strong><h3 id=5-4-4、重入锁><a class=headerlink href=#5-4-4、重入锁 title=5.4.4、重入锁></a>5.4.4、重入锁</h3><h4 id=简介-3><a class=headerlink href=#简介-3 title=简介></a>简介</h4><p>重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对 资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。<p>ReentrantLock虽然没能像synchronized关键字一样支持隐式的重进入，但是在调用lock()方 法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。<h4 id=重入锁特点><a class=headerlink href=#重入锁特点 title=重入锁特点></a>重入锁特点</h4><ol><li>线程A获取锁L后，可以在不释放锁L的同时再次获取锁L，且不会出现死锁现象；<li>线程A释放掉锁L后，其它线程才能获取锁L；</ol><p><strong>可重入锁的使命就是防止自己锁自己，进而提高程序执行性能。</strong><p>Java中可重入锁的常见实现如下：<ol><li>Synchronized<li>ReentrantLock</ol><h3 id=5-4-5、ReentrantLock><a class=headerlink href=#5-4-5、ReentrantLock title=5.4.5、ReentrantLock></a>5.4.5、ReentrantLock</h3><h4 id=5-4-5-1、简介><a class=headerlink href=#5-4-5-1、简介 title=5.4.5.1、简介></a>5.4.5.1、简介</h4><p><strong>ReentrantLock是一个可重入锁、独占式锁，与synchronized关键字相比，它更灵活、更强大，增加了轮询、超时、中断等高级功能。除此外，还提供了对公平锁与非公平锁的选择。</strong><p>ReentrantLock的内部类Sync继承了AQS，分为公平锁FairSync和非公平锁NonfairSync。ReentrantLock使用公平锁还是非公平锁，可以通过它的构造函数来决定。<blockquote><p>公平锁：按照请求的顺序来获取锁；非公平锁：不管请求顺序的先后，谁抢到锁，这把锁就是谁的。</blockquote><p>事实上，公平锁往往没有非公平锁的效率高，但是，并不是任何场景都是以TPS作为唯一指标，公平锁能够减少“饥饿”发生的概率，等待越久的请求越能够得到优先满足。<h4 id=5-4-5-2、原理><a class=headerlink href=#5-4-5-2、原理 title=5.4.5.2、原理></a>5.4.5.2、原理</h4><p><strong>ReentrantLock 主要通过unsafe的 CAS 和 park 两个功能实现锁机制。</strong><p>Sync类是ReentrantLock自定义同步组件，它是ReentrantLock的一个内部类，其继承自AQS，它有两个子类：公平锁FairSync和非公平锁NonfairSync。ReentrantLock的获取与释放锁操作都是委托给该同步组件来实现。<h3 id=5-4-6、读写锁><a class=headerlink href=#5-4-6、读写锁 title=5.4.6、读写锁></a>5.4.6、读写锁</h3><h4 id=5-4-6-1、简介><a class=headerlink href=#5-4-6-1、简介 title=5.4.6.1、简介></a>5.4.6.1、简介</h4><p><strong>读多写少情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。读写锁的实现是 ReentrantReadWriteLock。</strong><p>ReadWriteLock仅定义了获取读锁和写锁的两个方法，其实现ReentrantReadWriteLock，除了接口方法之外，还提供了一些便于外界监控内部工作状态的方法。<h4 id=5-4-6-2、特点><a class=headerlink href=#5-4-6-2、特点 title=5.4.6.2、特点></a>5.4.6.2、特点</h4><p><img alt=锁-1.2-读写锁特性 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E9%94%81-1.2-%E8%AF%BB%E5%86%99%E9%94%81%E7%89%B9%E6%80%A7.png?token=AIGEF3MBYW4434TSKNMP7ULEZZYVI><h4 id=5-4-6-3、底层实现><a class=headerlink href=#5-4-6-3、底层实现 title=5.4.6.3、底层实现></a>5.4.6.3、底层实现</h4><h5 id=读写状态><a class=headerlink href=#读写状态 title=读写状态></a>读写状态</h5><p>读写锁 同样依赖 自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。ReentrantLock中自定义同步器的同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状 态，使得该状态的设计成为读写锁实现的关键。<p><strong>如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将 变量切分成了两个部分，高16位表示读，低16位表示写</strong>，划分方式如下图：<p><img alt=锁-1.3-读写锁状态划分设计图 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E9%94%81-1.3-%E8%AF%BB%E5%86%99%E9%94%81%E7%8A%B6%E6%80%81%E5%88%92%E5%88%86%E8%AE%BE%E8%AE%A1%E5%9B%BE.png?token=AIGEF3KMLEL744A7NPZTJKLEZZYXY><p>读写锁是如何迅速确定读和写各自的状态呢？答案是通过位运算。假设当前同步状态 值为S，写状态等于S&0x0000FFFF（将高16位全部抹去），读状态等于S>>>16（无符号补0右移 16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1<&LT16)，也就是 S+0x00010000。<h5 id=写锁获取与释放><a class=headerlink href=#写锁获取与释放 title=写锁获取与释放></a>写锁获取与释放</h5><p>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程， 则当前线程进入等待状态。<blockquote><p>如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果 允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。</blockquote><p>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0 时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对 后续读写线程可见。<h5 id=读锁获取与释放><a class=headerlink href=#读锁获取与释放 title=读锁获取与释放></a>读锁获取与释放</h5><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问 （或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程 获取，则进入等待状态。<p>读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少值是（1<&LT16）。<h4 id=5-4-6-4、锁升级-降级><a class=headerlink href=#5-4-6-4、锁升级-降级 title=5.4.6.4、锁升级/降级></a>5.4.6.4、锁升级/降级</h4><h5 id=锁降级><a class=headerlink href=#锁降级 title=锁降级></a>锁降级</h5><p><strong>锁降级指的是写锁降级成为读锁。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。</strong><h5 id=锁升级（不存在）><a class=headerlink href=#锁升级（不存在） title=锁升级（不存在）></a>锁升级（不存在）</h5><p><font color=red>RentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。</font>目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。<h3 id=5-4-10、小总结><a class=headerlink href=#5-4-10、小总结 title=5.4.10、小总结></a>5.4.10、小总结</h3><h4 id=5-4-10-1、Synchronized和ReentrantLock区别><a class=headerlink href=#5-4-10-1、Synchronized和ReentrantLock区别 title=5.4.10.1、Synchronized和ReentrantLock区别></a>5.4.10.1、Synchronized和ReentrantLock区别</h4><h5 id=共同点><a class=headerlink href=#共同点 title=共同点></a>共同点</h5><ol><li>都是用来协调多线程对共享对象、变量的访问。<li>都是可重入锁，即同一线程可以多次获得同一个锁。<li>都保证了可见性和互斥性。</ol><h5 id=不同点><a class=headerlink href=#不同点 title=不同点></a>不同点</h5><ol><li><p>API方面</p> <ul><li>Synchronized：可修饰方法、代码块。隐式获取/释放锁。<li>ReentrantLock：显式获取/释放锁。（获取锁：ReentrantLock.lock；释放锁：ReentrantLock.unlock）</ul><li><p>等待可中断</p> <p>有两个线程：T1、T2，假设T1获取了对象object的锁，T2将等待T1释放object的锁。则：</p> <ul><li>Synchronized：T2会一直等待下去，不可被中断。<li>ReentrantLock：T2等待一定时间后，会中断操作，转而去做其它事。</ul><li><p>公平锁</p> <ul><li>Synchronized：是非公平锁。<li>ReenTrantLock：默认是非公平锁，可通过布尔值来控制使用公平锁。</ul><li><p>绑定多个条件</p> <ul><li>Synchronized：锁对象的wait和notify() 或notifyAll()方法可以实现一个隐含的条件。<li>ReenTrantLock：可以同时绑定多个Condition对象，只需多次调用newCondition方法即可。</ul><li><p>性能</p> <p>JDK1.5中的Synchronized有很大优化余地。JDK 1.6 中加入了很多针对锁的优化措施，故synchronized与ReentrantLock在性能方面基本持平。</p><li><p>其它</p> <ul><li>Synchronized是关键字，是内置语言的实现。Lock是一个接口。<li>Synchronized在发生异常时，会自动释放线程占有的锁，不会导致死锁发生。Lock必须通过unlock方法释放锁，否则会造成死锁。<li>Synchronized无法判断是否获取到锁；Lock可以。<li>Synchronized不管读写，都会阻塞线程，读效率低；Lock可以提供读写锁，可提高并发读的效率。</ul></ol><table><thead><tr><th align=center>比较方面<th align=center>synchronized<th align=center>ReenTrantLock<tbody><tr><td align=center>原始构成<td align=center>Java关键字，原生语法层面的互斥，需要JVM支持。<td align=center>JDK1.5之后提供的互斥锁<tr><td align=center>实现<td align=center>通过JVM自动加锁/解锁<td align=center>显式加锁/解锁<tr><td align=center>代码实现<td align=center>隐式自动获取锁/释放锁<td align=center>显式获取锁/释放锁<tr><td align=center>灵活性<td align=center>锁的范围可以随意控制<td align=center>Lock是方法调用，可跨方法，灵活性更大<tr><td align=center>等待可中断<td align=center>不可中断，除非抛出异常。<td align=center>可中断<tr><td align=center>公平<td align=center>非公平锁<td align=center>默认非公平锁，但可通过布尔值控制使用公平锁<tr><td align=center>条件Condition<td align=center><td align=center>通过多次newCondition可以获得多个Condition对象，可以简单的实现比较复杂的线程同步功能。<tr><td align=center>高级功能<td align=center><td align=center>getHoldCount()、getQueueLength()、isFair()、isHeldByCurrentThread()、isLocked()<tr><td align=center>便利性<td align=center>会自动释放获取锁，便利性好。<td align=center>需要手动获取释放锁，便利性差。<tr><td align=center>适用情况<td align=center>适用于并发度低的情况。<td align=center>适用于并发度高的情况。</table><h4 id=5-4-10-2、Lock-VS-Synchronized><a title="5.4.10.2、Lock VS Synchronized" class=headerlink href=#5-4-10-2、Lock-VS-Synchronized></a>5.4.10.2、Lock VS Synchronized</h4><p><strong>Lock可以非阻塞获取锁、被中断地获取锁、超时获取锁。</strong><h2 id=5-5、原子操作><a class=headerlink href=#5-5、原子操作 title=5.5、原子操作></a>5.5、原子操作</h2><h3 id=5-5-1、简介><a class=headerlink href=#5-5-1、简介 title=5.5.1、简介></a>5.5.1、简介</h3><p><strong>原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。</strong><p>原子操作相关术语如下：<p><img alt=原子操作-1.1-相关术语 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-1.1-%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD.png?token=AIGEF3KT2PLCG34WR36C2ZLEZZYZ2><h3 id=5-5-2、处理器原子操作><a class=headerlink href=#5-5-2、处理器原子操作 title=5.5.2、处理器原子操作></a>5.5.2、处理器原子操作</h3><p>首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。<p>为保证复杂内存操作的原子性，处理器提供了两种机制：<ul><li><p>总线锁</p> <p>所谓总线锁就是使用处理器提供的一个 LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该 处理器可以独占共享内存。</p><li><p>缓存锁</p> <p>总线锁定把CPU和内存之间的通信锁住了，开销较大，所以使用缓存锁定代替总线锁定来进行优化。</p> <p>有两种情况下处理器不会使用缓存锁定：</p> <ol><li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，处理器会调用总线锁定。<li>有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的 内存区域在处理器的缓存行中也会调用总线锁定。</ol></ul><h3 id=5-5-3、Java原子操作><a class=headerlink href=#5-5-3、Java原子操作 title=5.5.3、Java原子操作></a>5.5.3、Java原子操作</h3><p><strong>Java中可以通过 锁、循环CAS 方式来实现原子操作。</strong><h4 id=CAS实现原子操作><a class=headerlink href=#CAS实现原子操作 title=CAS实现原子操作></a>CAS实现原子操作</h4><p><strong>JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的</strong>。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。从Java 1.5开始，JDK的并发包里提供了一些原子操作类来支持原子操作。<p>CAS实现原子操作的三大问题：<ol><li>ABA问题。<li>循环时间长开销大。<li>只能保证一个共享变量的原子操作。</ol><h4 id=锁实现原子操作><a class=headerlink href=#锁实现原子操作 title=锁实现原子操作></a>锁实现原子操作</h4><p>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁 机制，有偏向锁、轻量级锁和互斥锁。除了偏向锁，JVM实现锁的方式都用了循环 CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时 候使用循环CAS释放锁。<h4 id=原子操作类><a class=headerlink href=#原子操作类 title=原子操作类></a>原子操作类</h4><p><strong>JDK 5开始提供了java.util.concurrent.atomic包，Atomic包里一共提供了13个类，属于4种类型的原子更新方式</strong>，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。Atomic包里的类基本都是使用Unsafe实现的包装类。<h5 id=基本类型><a class=headerlink href=#基本类型 title=基本类型></a>基本类型</h5><ul><li>AtomicBoolean：原子更新布尔类型。<li>AtomicInteger：原子更新整型。<li>AtomicLong：原子更新长整型。</ul><p>Java的基本类型里还有char、float和double等，对其这些基本类型，可以将它们转换成整型后，再使用compareAndSwapInt进行CAS更新。<h5 id=数组类型><a class=headerlink href=#数组类型 title=数组类型></a>数组类型</h5><ul><li>AtomicIntegerArray：原子更新整型数组里的元素。<li>AtomicLongArray：原子更新长整型数组里的元素。<li>AtomicReferenceArray：原子更新引用类型数组里的元素。</ul><h5 id=引用类型><a class=headerlink href=#引用类型 title=引用类型></a>引用类型</h5><ul><li>AtomicReference：原子更新引用类型。<li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。<li>AtomicMarkableReference：原子更新带有标记位的引用类型。</ul><h5 id=对象属性><a class=headerlink href=#对象属性 title=对象属性></a>对象属性</h5><ul><li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。<li>AtomicStampedReference：原子更新带有版本号的引用类型。</ul><h2 id=5-6、并发工具类><a class=headerlink href=#5-6、并发工具类 title=5.6、并发工具类></a>5.6、并发工具类</h2><h3 id=5-6-1、CountDownLatch><a class=headerlink href=#5-6-1、CountDownLatch title=5.6.1、CountDownLatch></a>5.6.1、CountDownLatch</h3><p><strong>CountDownLatch允许一个或多个线程等待其他线程完成操作。</strong><p><strong>调用CountDownLatch的countDown方法时，N会减1，CountDownLatch的await方法会阻塞当前线程，直到N变成零。</strong>由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程中时，只需要把这个 CountDownLatch的引用传递到线程里即可。<p><font color=red>注意：计数器必须大于等于0，如果等于0，则调用await方法时不会阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值。一个线程调用countDown方法happen-before另外一个线程调用await方法。</font><h3 id=5-6-2、CyclicBarrier><a class=headerlink href=#5-6-2、CyclicBarrier title=5.6.2、CyclicBarrier></a>5.6.2、CyclicBarrier</h3><p><strong>CyclicBarrier是可循环使用的屏障。它的目的：让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</strong><p>CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。<p>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier（int parties，Runnable barrierAction），用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景。<ul><li>CyclicBarrier VS CountDownLatch</ul><p><strong>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。</strong><h3 id=5-6-3、Semaphore><a class=headerlink href=#5-6-3、Semaphore title=5.6.3、Semaphore></a>5.6.3、Semaphore</h3><p><strong>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</strong><p>Semaphore的构造方法Semaphore(int permits) 接受一个整型的数字，表示可用的许可证数量。Semaphore(10) 表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用 Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。<h3 id=5-6-4、Exchanger><a class=headerlink href=#5-6-4、Exchanger title=5.6.4、Exchanger></a>5.6.4、Exchanger</h3><h4 id=简介-4><a class=headerlink href=#简介-4 title=简介></a>简介</h4><p><strong>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于线程间的数据交换。</strong>它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。<strong>两个线程通过 exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</strong><p><font color=red>注意：如果两个线程有一个没有执行exchange()方法则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用exchange(V x, longtimeout, TimeUnit unit)设置最大等待时长。</font><h4 id=应用场景><a class=headerlink href=#应用场景 title=应用场景></a>应用场景</h4><ol><li>Exchanger可以用于遗传算法，遗传算法中需要选出两个人作为交换对象，这时候会交换两人的数据，并使用交叉规则得出2个结果。<li>Exchanger也可以用于校对工作。</ol><h2 id=5-7、并发容器及框架><a class=headerlink href=#5-7、并发容器及框架 title=5.7、并发容器及框架></a>5.7、并发容器及框架</h2><h3 id=5-7-1、阻塞队列><a class=headerlink href=#5-7-1、阻塞队列 title=5.7.1、阻塞队列></a>5.7.1、阻塞队列</h3><h4 id=简介-5><a class=headerlink href=#简介-5 title=简介></a>简介</h4><p>JDK 7提供了7个阻塞队列，如下。<ul><li>ArrayBlockingQueue：一个由<strong>数组结构</strong>组成的<strong>有界阻塞</strong>队列。<li>LinkedBlockingQueue：一个由<strong>链表结构</strong>组成的<strong>有界阻塞</strong>队列。<li>PriorityBlockingQueue：一个<strong>支持优先级排序的无界阻塞</strong>队列。<li>DelayQueue：一个使用<strong>优先级队列</strong>实现的<strong>无界阻塞</strong>队列。<li>SynchronousQueue：一个<strong>不存储元素的阻塞队列</strong>。<li>LinkedTransferQueue：一个由<strong>链表结构</strong>组成的<strong>无界阻塞</strong>队列。<li>LinkedBlockingDeque：一个由<strong>链表结构</strong>组成的<strong>双向阻塞</strong>队列。</ul><h4 id=分析><a class=headerlink href=#分析 title=分析></a>分析</h4><h5 id=ArrayBlockingQueue><a class=headerlink href=#ArrayBlockingQueue title=ArrayBlockingQueue></a>ArrayBlockingQueue</h5><p><strong>此队列按照先进先出（FIFO）的原则对元素进行排序，默认情况下不保证线程访问队列的公平性。</strong><p>为了保证公平性，通常会降低吞吐量。可以使用以下代码创建一个公平的阻塞队列：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>ArrayBlockingQueue</span> <span class=variable>fairQueue</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class=number>1000</span>,<span class=literal>true</span>);</span><br></pre></table></figure><h5 id=LinkedBlockingQueue><a class=headerlink href=#LinkedBlockingQueue title=LinkedBlockingQueue></a>LinkedBlockingQueue</h5><p><strong>此队列的默认和最大长度为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</strong><h5 id=PriorityBlockingQueue><a class=headerlink href=#PriorityBlockingQueue title=PriorityBlockingQueue></a>PriorityBlockingQueue</h5><p><strong>默认情况下元素采取自然顺序 升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则</strong>，或者初始化 PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。<h5 id=DelayQueue><a class=headerlink href=#DelayQueue title=DelayQueue></a>DelayQueue</h5><p>DelayQueue是一个<strong>支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现</strong>。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。 只有在延迟期满时才能从队列中提取元素。<p>应用场景：<ul><li>缓存系统的设计<li>定时任务调度</ul><h5 id=SynchronousQueue><a class=headerlink href=#SynchronousQueue title=SynchronousQueue></a>SynchronousQueue</h5><p><strong>每一个put操作必须等待一个take操作， 否则不能继续添加元素。</strong><p>它支持公平访问队列，默认情况下线程采用非公平性策略访问队列。<p>SynchronousQueue的吞吐量高于 LinkedBlockingQueue和ArrayBlockingQueue。<h5 id=LinkedTransferQueue><a class=headerlink href=#LinkedTransferQueue title=LinkedTransferQueue></a>LinkedTransferQueue</h5><p>相对于其它 阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。<ul><li><p>transfer方法</p> <p>如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法 时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等 待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。</p><li><p>tryTransfer方法</p> <p>tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等 待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法 立即返回，而transfer方法是必须等到消费者消费了才返回。</p></ul><h5 id=LinkedBlockingDeque><a class=headerlink href=#LinkedBlockingDeque title=LinkedBlockingDeque></a>LinkedBlockingDeque</h5><p>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以 从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。<p>初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“工作窃取”模式中<h4 id=底层实现-1><a class=headerlink href=#底层实现-1 title=底层实现></a>底层实现</h4><p><strong>阻塞队列底层主要使用 通知模式 来实现生产者与消费者间的通信。</strong><p>ArrayBlockingQueue使用了Condition来实现，当往队列里插入一个元素时，如果队列不可用，那么阻塞生产者主要通过 LockSupport.park（this）来实现。<p>park这个方法会阻塞当前线程，但以下4种情况中的任何一种发生时，该方法就会返回：<ul><li>与park对应的unpark执行或已经执行过时。<li>线程被中断时。<li>等待完time参数指定的毫秒数时。<li>异常现象发生时，这个异常现象没有任何原因。</ul><h3 id=5-7-2、ForkJoin框架><a class=headerlink href=#5-7-2、ForkJoin框架 title=5.7.2、ForkJoin框架></a>5.7.2、ForkJoin框架</h3><h4 id=简介-6><a class=headerlink href=#简介-6 title=简介></a>简介</h4><p><strong>Fork/Join框架是Java 7提供的一个用于 并行执行任务 的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</strong><h4 id=工作窃取算法><a class=headerlink href=#工作窃取算法 title=工作窃取算法></a>工作窃取算法</h4><p><strong>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。</strong><p>工作窃取算法的优缺点如下：<ul><li><p>优点：充分利用线程进行并行计算，减少了线程间的竞争</p><li><p>缺点：某些情况下还是存在竞争，比如双端队列里只有一个任务时。并 且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p></ul><h4 id=异常处理><a class=headerlink href=#异常处理 title=异常处理></a>异常处理</h4><p>ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消，且可以通过ForkJoinTask的getException方法获取异常。<p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或没有抛出异常则返回null。<h4 id=底层设计><a class=headerlink href=#底层设计 title=底层设计></a>底层设计</h4><ul><li>步骤1，分割任务。<li>步骤2，执行任务并合并结果。</ul><p>Fork/Join使用两个类来完成以上两件事情：<ul><li><p><strong>ForkJoinTask</strong>：使用ForkJoin框架，必须首先创建一个ForkJoin任务。</p> <p>通常情况下，我们不需要直接继承ForkJoinTask类，只需要继 承它的子类：</p> <ul><li>RecursiveAction：用于没有返回结果的任务。<li>RecursiveTask：用于有返回结果的任务。</ul><li><p><strong>ForkJoinPool</strong>：ForkJoinTask需要通过ForkJoinPool来执行。</p></ul><p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责将存放程序提交给ForkJoinPool的任务，而ForkJoinWorkerThread数组负责执行这些任务。<ul><li><p>ForkJoinTask的fork方法</p> <p>调用ForkJoinTask的fork方法时，会异步调用ForkJoinWorkerThread的pushTask方法将任务放到ForkJoinTask数组中，然后调用ForkJoinPool的signalWork方法唤醒或创建一个线程去执行该任务。</p><li><p>ForkJoinTask的join方法</p> <p>调用Join方法会调用doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有4种：已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常 （EXCEPTIONAL）。</p></ul><h2 id=5-8、并发底层原理><a class=headerlink href=#5-8、并发底层原理 title=5.8、并发底层原理></a>5.8、并发底层原理</h2><h3 id=5-8-1、LockSupport工具><a class=headerlink href=#5-8-1、LockSupport工具 title=5.8.1、LockSupport工具></a>5.8.1、LockSupport工具</h3><p><strong>LockSupport是构建同步组件的基础工具。</strong>LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread) 方法来唤醒一个被阻塞的线程。<p>Java 6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos) 和parkUntil(Object blocker,long deadline)3个方法，用于实现阻塞当前线程的功能，其中参数 blocker是用来标识当前线程在等待的对象（以下称为阻塞对象），该对象主要用于问题排查和 系统监控。<h3 id=5-8-2、Condition接口><a class=headerlink href=#5-8-2、Condition接口 title=5.8.2、Condition接口></a>5.8.2、Condition接口</h3><h4 id=简介-7><a class=headerlink href=#简介-7 title=简介></a>简介</h4><p><strong>Java对象（wait/notify）配合Synchronized可以实现等待/通知模式。Condition接口配合Lock同样可以实现等待/通知模式，但是两者的使用方式和功能特性是有差别的。</strong><p>Object监视器 VS Condition接口：<p><img alt=image-20200620151112096 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200620151112096.png?token=AIGEF3LU66ZLAJQGHYYX6EDEZZY4A><p>Condition对象由Lock对象（调用Lock对象的newCondition()方法）创建出来，即通过Lock的newCondition()方法可以获取一个Condition。<p>Condition使用方式比较简单。当前线程调用await()方法后会释放锁并在此等待，其它线程调用Condition对象的signal()方法会导致当前线程获取锁并从await()方法返回。<h4 id=实现分析><a class=headerlink href=#实现分析 title=实现分析></a>实现分析</h4><p>ConditionObject是同步器AbstractQueuedSynchronizer的内部类，每个Condition对象都包含一个等待队列，该队列是Condition对象实现等待/通知功能的关键。<p><strong>Condition的实现主要包括：等待队列、等待和通知，下面提到的Condition，如果不加说明均指的是ConditionObject。</strong><p><strong>（1）等待队列</strong><p>等待队列是一个FIFO单向队列，队列中的每个节点都包含一个线程引用，该线程就是 在Condition对象上等待的线程，<strong>一个线程调用Condition.await()方法后会释放锁并被构造成节点放入到等待队列，然后进入等待状态</strong>。事实上，节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中的节点类型都是同步器的静态内部类 AbstractQueuedSynchronizer.Node。<p><strong>一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点 （lastWaiter）。</strong><p><img alt=image-20210221163426067 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210221163426067.png?token=AIGEF3OTFQWKT5ZQHHM4UODEZZY6G><p><strong>Object监视器模型中，一个对象拥有一个同步队列和等待队列，而并发包中的 Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列。</strong><p>Condition是同步器的内部类，因此每个Condition实例都能够访问 同步器提供的方法，相当于每个Condition都拥有所属同步器的引用。<p><strong>（2）等待</strong><p>调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。<p>如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同 步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。<p><strong>（3）通知</strong><p>调用Condition的signal()方法会导致：将等待队列的首节点移至同步队列中，然后唤醒该节点中的线程，被唤醒的线程会通过调用同步器的acquireQueued()方法来尝试获取同步状态。成功获取同步状态（锁）后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功获取了锁。<blockquote><p><font color=red>注意事项：</font><ol><li>当从await()方法返回时，当前线程一定获取了Condition相关联的锁。<li>调用signal()方法的前提是当前线程必须获取了锁；<li>如果节点不是通过Condition.signal()方法被唤醒，而是通过中断被唤醒的话，会抛出异常 InterruptedException。</ol></blockquote><p>Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点中的线程。<h4 id=知识扩展><a class=headerlink href=#知识扩展 title=知识扩展></a>知识扩展</h4><p><strong>为什么wait()、notyfy()、notifyAll()要放在同步块中？</strong><ol><li>调用wait()就是释放锁，释放锁的前提必须要先获得锁，先获得锁才能释放锁。<li>notify()、notifyAll()是将锁交给调用wait()方法的线程，让其继续执行下去，如果自身没有锁，怎么叫把锁交给其他线程呢；（本质是让处于入口队列的线程竞争锁）。</ol><h3 id=5-8-3、AQS（CLH）><a class=headerlink href=#5-8-3、AQS（CLH） title=5.8.3、AQS（CLH）></a>5.8.3、AQS（CLH）</h3><h4 id=简介-8><a class=headerlink href=#简介-8 title=简介></a>简介</h4><p><strong>AQS（Abstract Queued Synchronizer）：简称抽象队列同步器。</strong><p>CLH（Craig Landin and Hagersten locks）：是一种基于链表的可扩展、高性能、公平的自旋锁，能确保无饥饿性、公平性。申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。<h4 id=底层实现-2><a class=headerlink href=#底层实现-2 title=底层实现></a>底层实现</h4><p><strong>基于volatile + CAS + 队列来实现。</strong><h5 id=同步队列><a class=headerlink href=#同步队列 title=同步队列></a>同步队列</h5><p><strong>同步器依赖内部的 同步队列（FIFO双向队列）来完成同步状态管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node），然后基于CAS的方式放入到同步队列尾部，同时会阻塞当前线程，当同步队列首节点释放同步状态时，会唤醒后继节点来获取同步状态，后继节点获取同步状态成功后会将自己设置为首节点。</strong><p>同步队列中的节点（Node）保存的内容：<strong>获取同步状态失败的线程引用、等待状态以及前驱和后继节点。</strong><p>同步队列的基本结构如下图所示：<p><img alt=image-20200721002028762 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200721002028762.png?token=AIGEF3K7UBTFCK3VU76IGCTEZZY7U><p>同步器拥有首节点（head） 和尾节点（tail）。 当一个线程无法获取到同步状态时，会被构造成节点并放入到同步队列末尾。放入队列末尾的操作将通过调用CAS方法：<code>compareAndSetTail(Node expect,Node update)</code>来实现，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。 插入过程如图所示：<p><img alt=image-20200721002419902 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200721002419902.png?token=AIGEF3KHSKMLNT7SRLOKJKTEZZZA2><p>同步队列遵循FIFO规则，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点来获取同步状态，而后继节点在获取同步状态成功时会将自己设置为首节点。<p>注意：<strong>由于只有一个线程能够成功获取到同步状态，因此设置头节点的操作并不需要通过CAS来保证。</strong><h5 id=等待队列><a class=headerlink href=#等待队列 title=等待队列></a>等待队列</h5><p><strong>等待队列是一个FIFO单向队列。线程A调用Condition.await()方法将会导致线程A释放锁并被构造成节点放入到等待队列末尾，同时线程A进入等待状态。</strong><p>等待队列基本结构如下图所示：<p><img alt=image-20200721004540435 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200721004540435.png?token=AIGEF3NQLSRDPSWZXDGZACLEZZZEI><p><strong>Object监视器模型中，一个对象拥有一个同步队列和等待队列，而并发包中的 Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列，</strong>其对应关系如图所示：<p><img alt=image-20200721004716947 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200721004716947.png?token=AIGEF3IGGKYM4Z4T7SDOZYDEZZZFK><h5 id=独占式获取与释放><a class=headerlink href=#独占式获取与释放 title=独占式获取与释放></a>独占式获取与释放</h5><p><strong>调用同步器的acquire(int arg)方法可以获取同步状态，该方法对中断不敏感。</strong><p>当前线程调用<code>acquireQueued(final Node node,int arg)</code>方法会在“死循环”中尝试获取同步状态，而只有前驱节点是头节点才能够尝试获取同步状态，这是为什么？原因有两个：<ol><li>头节点是成功获取到同步状态的节点，头节点中的线程释放同步状态后会唤醒后继节点来获取同步状态，后继节点中的线程被唤醒后还需要检查自己的前驱节点是否是头节点。<li>维护同步队列的FIFO原则。</ol><p><strong>调用同步器的<code>release(int arg)</code>方法会释放同步状态，释放同步状态后会唤醒后继节点来尝试获取同步状态。</strong><h5 id=共享式获取与释放><a class=headerlink href=#共享式获取与释放 title=共享式获取与释放></a>共享式获取与释放</h5><p>共享式获取与独占式获取最主要的区别在于：<strong>同一时刻能否有多个线程同时获取到同步状态。</strong><p><strong>通过调用同步器的acquireShared(int arg)方法可以共享式获取同步状态。</strong>共享式成功获取到同步状态并退出自旋的条件是<code>tryAcquireShared(int arg)</code>方法返回值大于等于0。其具体过程：如果当前节点的前驱节点是头节点，则尝试获取同步状态，返回值大于等于0时标志着获取同步状态成功并从自旋过程中退出。<p>与独占式一样，共享式获取也需要释放同步状态，<strong>通过调用releaseShared(int arg)方法可以释放同步状态。</strong><h3 id=5-8-4、Unsafe><a class=headerlink href=#5-8-4、Unsafe title=5.8.4、Unsafe></a>5.8.4、Unsafe</h3><h4 id=简介-9><a class=headerlink href=#简介-9 title=简介></a>简介</h4><ol><li>主要用来操作JVM中的内存。<li>直接操作内存：allocateMemory、putXX、freeMemory、pageSize<li>直接生成实例：allocateInstance。<li>直接操作类或实例变量：objectFieldOffset、getInt、getObject。<li>CAS相关：weakCompareAndSetObject / int / Long。<li>Unsafe相当于C/C++中的指针。</ol><blockquote><p>注意：<strong>C分配/释放内存使用malloc/free，C++分配/释放内存使用new/delete。</strong></blockquote><h4 id=使用实例><a class=headerlink href=#使用实例 title=使用实例></a>使用实例</h4><p>Atomicinteger：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=type>int</span> <span class="title function_">incrementAndGet</span><span class=params>()</span> {</span><br><span class=line>    <span class=keyword>for</span> (;;) {</span><br><span class=line>    	<span class=type>int</span> <span class=variable>current</span> <span class=operator>=</span> get();</span><br><span class=line>    	<span class=type>int</span> <span class=variable>next</span> <span class=operator>=</span> current + <span class=number>1</span>;</span><br><span class=line>    	<span class=keyword>if</span> (compareAndSet(current, next))</span><br><span class=line>    	<span class=keyword>return</span> next;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=type>boolean</span> <span class="title function_">compareAndSet</span><span class=params>(<span class=type>int</span> expect, <span class=type>int</span> update)</span> {</span><br><span class=line>	<span class=keyword>return</span> unsafe.compareAndSwapInt(<span class=built_in>this</span>, valueOffset, expect, update);</span><br><span class=line>}</span><br></pre></table></figure><p>Unsafe:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>native</span> <span class=type>boolean</span> <span class="title function_">compareAndSwapInt</span><span class=params>(Object var1, <span class=type>long</span> var2, <span class=type>int</span> var4, <span class=type>int</span> var5)</span>;</span><br></pre></table></figure><p>运用：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> sun.misc.Unsafe;</span><br><span class=line><span class=keyword>import</span> java.lang.reflect.Field;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">T02_TestUnsafe</span> {</span><br><span class=line>    <span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>T02_TestUnsafe</span> <span class=variable>t</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">T02_TestUnsafe</span>();</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=comment>//Unsafe unsafe = Unsafe.getUnsafe();</span></span><br><span class=line></span><br><span class=line>        <span class=type>Field</span> <span class=variable>unsafeField</span> <span class=operator>=</span> Unsafe.class.getDeclaredFields()[<span class=number>0</span>];</span><br><span class=line>        unsafeField.setAccessible(<span class=literal>true</span>);</span><br><span class=line>        <span class=type>Unsafe</span> <span class=variable>unsafe</span> <span class=operator>=</span> (Unsafe) unsafeField.get(<span class=literal>null</span>);</span><br><span class=line></span><br><span class=line>        <span class=type>Field</span> <span class=variable>f</span> <span class=operator>=</span> T02_TestUnsafe.class.getDeclaredField(<span class=string>"i"</span>);</span><br><span class=line>        <span class=type>long</span> <span class=variable>offset</span> <span class=operator>=</span> unsafe.objectFieldOffset(f);</span><br><span class=line>        System.out.println(offset);</span><br><span class=line></span><br><span class=line>        <span class=type>boolean</span> <span class=variable>success</span> <span class=operator>=</span> unsafe.compareAndSwapInt(t, offset, <span class=number>0</span>, <span class=number>1</span>);</span><br><span class=line>        System.out.println(success);</span><br><span class=line>        System.out.println(t.i);</span><br><span class=line>        <span class=comment>//unsafe.compareAndSwapInt()</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>jdk8u: unsafe.cpp:<p>cmpxchg = compare and exchange<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=built_in>UNSAFE_ENTRY</span>(jboolean, <span class=built_in>Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class=line>  <span class=built_in>UnsafeWrapper</span>(<span class=string>"Unsafe_CompareAndSwapInt"</span>);</span><br><span class=line>  oop p = JNIHandles::<span class=built_in>resolve</span>(obj);</span><br><span class=line>  jint* addr = (jint *) <span class=built_in>index_oop_from_field_offset_long</span>(p, offset);</span><br><span class=line>  <span class=keyword>return</span> (jint)(Atomic::<span class=built_in>cmpxchg</span>(x, addr, e)) == e;</span><br><span class=line>UNSAFE_END</span><br></pre></table></figure><p>jdk8u: atomic_linux_x86.inline.hpp<p>is_MP = Multi Processor<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>inline</span> jint <span class=title>Atomic::cmpxchg</span><span class=params>(jint exchange_value, <span class=keyword>volatile</span> jint*dest, jint compare_value)</span> </span>{</span><br><span class=line>  <span class=type>int</span> mp = os::<span class=built_in>is_MP</span>();</span><br><span class=line>  <span class=function>__asm__ <span class=title>volatile</span> <span class=params>(LOCK_IF_MP(%<span class=number>4</span>) <span class=string>"cmpxchgl %1,(%3)"</span></span></span></span><br><span class=line><span class=params><span class=function>                    : <span class=string>"=a"</span> (exchange_value)</span></span></span><br><span class=line><span class=params><span class=function>                    : <span class=string>"r"</span> (exchange_value), <span class=string>"a"</span> (compare_value), <span class=string>"r"</span> (dest), <span class=string>"r"</span> (mp)</span></span></span><br><span class=line><span class=params><span class=function>                    : <span class=string>"cc"</span>, <span class=string>"memory"</span>)</span></span>;</span><br><span class=line>  <span class=keyword>return</span> exchange_value;</span><br><span class=line>}</span><br></pre></table></figure><p>jdk8u: os.hpp is_MP()<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=function><span class=type>static</span> <span class=keyword>inline</span> <span class=type>bool</span> <span class=title>is_MP</span><span class=params>()</span> </span>{</span><br><span class=line>  <span class=comment>// During bootstrap if _processor_count is not yet initialized</span></span><br><span class=line>  <span class=comment>// we claim to be MP as that is safest. If any platform has a</span></span><br><span class=line>  <span class=comment>// stub generator that might be triggered in this phase and for</span></span><br><span class=line>  <span class=comment>// which being declared MP when in fact not, is a problem - then</span></span><br><span class=line>  <span class=comment>// the bootstrap routine for the stub generator needs to check</span></span><br><span class=line>  <span class=comment>// the processor count directly and leave the bootstrap routine</span></span><br><span class=line>  <span class=comment>// in place until called after initialization has ocurred.</span></span><br><span class=line>  <span class=keyword>return</span> (_processor_count != <span class=number>1</span>) || AssumeMP;</span><br><span class=line>}</span><br></pre></table></figure><p>jdk8u: atomic_linux_x86.inline.hpp<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=keyword>define</span> LOCK_IF_MP(mp) <span class=string>"cmp $0, "</span> #mp <span class=string>"; je 1f; lock; 1: "</span></span></span><br></pre></table></figure><p>最终实现：cmpxchg = cas修改变量值<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>lock cmpxchg 指令</span><br></pre></table></figure><p>硬件：lock指令在执行后面指令的时候锁定一个北桥信号（不采用锁总线的方式）。<h1 id=6、Java线程池><a class=headerlink href=#6、Java线程池 title=6、Java线程池></a>6、Java线程池</h1><h2 id=6-1、认识线程池><a class=headerlink href=#6-1、认识线程池 title=6.1、认识线程池></a>6.1、认识线程池</h2><h3 id=6-1-1、线程池优点><a class=headerlink href=#6-1-1、线程池优点 title=6.1.1、线程池优点></a>6.1.1、线程池优点</h3><p>合理地使用线程池能够带来3个好处：<ol><li>降低资源消耗。<li>提高响应速度。<li>提高线程的可管理性。</ol><h3 id=6-1-2、提交任务><a class=headerlink href=#6-1-2、提交任务 title=6.1.2、提交任务></a>6.1.2、提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。<p>两者区别如下：<ol><li>execute方法没有返回值，submit方法有返回值；<li>execute方法会抛出异常，submit方法不会抛出异常，但可通过Future.get方法打印异常；<li>execute方法入参为Runnable，submit方法入参可以是Runnable，也可以是Callable；</ol><h3 id=6-1-3、执行任务><a class=headerlink href=#6-1-3、执行任务 title=6.1.3、执行任务></a>6.1.3、执行任务</h3><p>当提交一个新任务到线程池时，线程池的处理流程如下。<ol><li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。<li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。<li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</ol><h3 id=6-1-4、关闭线程池><a class=headerlink href=#6-1-4、关闭线程池 title=6.1.4、关闭线程池></a>6.1.4、关闭线程池</h3><p>调用线程池的shutdown或shutdownNow方法可以关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务 可能 永远无法终止。<p>shutdown和shutdownNow两者有区别：<ul><li><p><strong>shutdown</strong>：将线程池状态设置成SHUTDOWN状态，然后中断所有空闲线程。</p><li><p><strong>shutdownNow</strong>：先将线程池状态设置成STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。</p></ul><p>只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后才表示线程池关闭成功，这时调用isTerminaed方法会返回true。<h2 id=6-2、线程池实现><a class=headerlink href=#6-2、线程池实现 title=6.2、线程池实现></a>6.2、线程池实现</h2><h3 id=6-2-1、WorkStealingPool><a class=headerlink href=#6-2-1、WorkStealingPool title=6.2.1、WorkStealingPool></a>6.2.1、WorkStealingPool</h3><h4 id=简介-10><a class=headerlink href=#简介-10 title=简介></a>简介</h4><p><strong>WorkStealingPool是一种特殊线程池，核心很简单，和其它线程池的区别是：每一个线程都有自己单独的队列，任务会不断的插入到每一个线程对应的队列中，某个线程执行完自己队列中的任务后，会尝试从其它线程的队列中取出任务来执行，这个就是WorkStealingPool。</strong><h4 id=实现><a class=headerlink href=#实现 title=实现></a>实现</h4><p>本质上是一个ForkJoinPool。<h4 id=优缺点-1><a class=headerlink href=#优缺点-1 title=优缺点></a>优缺点</h4><p>针对通常意义上的线程池来说，如果某一个线程任务量非常庞大，一直占据着CPU，与此同时其它线程就算是闲着也不能去帮忙——无能为力；而WorkStealingPool就灵活了许多，遇到任务量庞大的线程，其它线程如果执行完了自己的任务后，可以帮忙执行这个任务量庞大的线程，提高了执行效率。<h3 id=6-2-2、ForkJoinPool><a class=headerlink href=#6-2-2、ForkJoinPool title=6.2.2、ForkJoinPool></a>6.2.2、ForkJoinPool</h3><h4 id=简介-11><a class=headerlink href=#简介-11 title=简介></a>简介</h4><p><strong>ForkJoinPool适合把大任务切分成一个个小任务去执行，如果觉得小任务还是太大，那就再切，切到满意为止。每一个小任务执行完成后需要进行汇总——小任务汇总到父任务，父任务最终汇总到根任务，最后得到最终期望的结果，这个汇总合并的过程叫join，故该线程池称为ForkJoinPool。</strong><p>Fork/Join默认会创建与CPU核数数量相同的线程池。<h4 id=注意事项-2><a class=headerlink href=#注意事项-2 title=注意事项></a>注意事项</h4><p>一般实现ForkJoinPool的时候需要定义为特定的类型——能进行切分的任务，故出现了该种类型的任务——ForkJoinTask。但ForkJoinTask太过于原始，我们可以使用RecursiveAction，其有两种形式：<ol><li>RecursiveAction递归：大任务可以切分成小任务，小任务还可以再切分成更小的任务，其隐含了一个递归过程，因此叫RecursiveAction递归，不带返回值。<li>从RecursiveTask继承，有返回值。</ol><h2 id=6-3、默认线程池><a class=headerlink href=#6-3、默认线程池 title=6.3、默认线程池></a>6.3、默认线程池</h2><p>Class Executors中提供了默认线程池创建API，不过最终还是会通过ThreadPoolExecutor去实现。<p>Executors常用线程池实现有：<ol><li>SingleThreadExecutor<li>CachedThreadPool<li>FixedThreadPool<li>ScheduledThreadPool</ol><h3 id=6-3-1、SingleThreadExecutor><a class=headerlink href=#6-3-1、SingleThreadExecutor title=6.3.1、SingleThreadExecutor></a>6.3.1、SingleThreadExecutor</h3><ul><li><p>简介：线程池中只有一个线程，一个线程的线程池可以保证扔进去的任务是顺序执行的。</p><li><p>特点（默认）：核心1，最大1，空闲0L，单位毫秒，队列LinkedBlockingQueue，工厂DefaultThreadFactory，拒绝策略AbortPolicy；</p><li><p>实例</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>ExecutorService</span> <span class=variable>service</span> <span class=operator>=</span> Executors.newSingleThreadExecutor();</span><br><span class=line><span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span><span class=number>0</span>; i < <span class=number>5</span>; i++){</span><br><span class=line>    <span class=keyword>final</span> <span class=type>int</span> <span class=variable>j</span> <span class=operator>=</span> i;</span><br><span class=line>    service.execute(() -> {</span><br><span class=line>        System.out.println(j + <span class=string>" "</span> + Thread.currentThread().getName());</span><br><span class=line>    });</span><br><span class=line>}</span><br></pre></table></figure></ul><h3 id=6-3-2、CachedThreadPool><a class=headerlink href=#6-3-2、CachedThreadPool title=6.3.2、CachedThreadPool></a>6.3.2、CachedThreadPool</h3><ul><li><p>简介：提交一个任务时，若线程池中没有线程则创建一个线程来执行该任务，若有则不创建。</p><li><p>特点（默认）：核心0，最大Integer.MAX_VALUE，空闲60，单位秒，队列SynchronousQueue(默认false非公平；fair ? new TransferQueue<e>() : new TransferStack<e>();)，工厂DefaultThreadFactory，拒绝策略AbortPolicy； <li><p>实例</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=type>ExecutorService</span> <span class=variable>service</span> <span class=operator>=</span> Executors.newCachedThreadPool();</span><br><span class=line>System.out.println(<span class=string>"1 service: "</span> + service);</span><br><span class=line><span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < <span class=number>2</span>; i++){</span><br><span class=line>    service.execute(() -> {</span><br><span class=line>        shhSleep(<span class=number>1</span>);</span><br><span class=line>        System.out.println(Thread.currentThread().getName());</span><br><span class=line>    });</span><br><span class=line>}</span><br><span class=line>System.out.println(<span class=string>"2 service: "</span> + service);</span><br><span class=line>shhSleep(<span class=number>3</span>);</span><br><span class=line>System.out.println(<span class=string>"3 service: "</span> + service);</span><br><span class=line></span><br><span class=line>---</span><br><span class=line></span><br><span class=line><span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">shhSleep</span><span class=params>(<span class=type>long</span> t)</span>{</span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        TimeUnit.SECONDS.sleep(t);</span><br><span class=line>    }<span class=keyword>catch</span> (InterruptedException e){</span><br><span class=line>        e.printStackTrace();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure></li> <h3 id=6-3-3、FixedThreadPool><a class=headerlink href=#6-3-3、FixedThreadPool title=6.3.3、FixedThreadPool></a>6.3.3、FixedThreadPool</h3><ul><li><p>简介：固定的线程数，核心线程数和最大线程数都一样，因此没有回收之说，故就指定为0。</p><li><p>特点（默认）：核心、最大显式指定且一样，空闲0，单位毫秒，队列LinkedBlockingQueue，工厂DefaultThreadFactory，拒绝策略AbortPolicy；</p><li><p>实例</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br></pre><td class=code><pre><span class=line><span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">FixedThreadPoolTest</span><span class=params>()</span>{</span><br><span class=line>    <span class=type>long</span> start, end;</span><br><span class=line>    <span class=keyword>final</span> <span class=type>int</span> <span class=variable>cpuCoreNum</span> <span class=operator>=</span> <span class=number>4</span>;</span><br><span class=line>    <span class=type>ExecutorService</span> <span class=variable>service</span> <span class=operator>=</span> Executors.newFixedThreadPool(cpuCoreNum);</span><br><span class=line>    <span class=type>Task</span> <span class=variable>task1</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Task</span>(<span class=number>1</span>, <span class=number>80000</span>);</span><br><span class=line>    <span class=type>Task</span> <span class=variable>task2</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Task</span>(<span class=number>80001</span>, <span class=number>130000</span>);</span><br><span class=line>    <span class=type>Task</span> <span class=variable>task3</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Task</span>(<span class=number>130001</span>, <span class=number>170000</span>);</span><br><span class=line>    <span class=type>Task</span> <span class=variable>task4</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Task</span>(<span class=number>170001</span>, <span class=number>200000</span>);</span><br><span class=line>    Future&LTList&LTInteger>> f1 = service.submit(task1);</span><br><span class=line>    Future&LTList&LTInteger>> f2 = service.submit(task2);</span><br><span class=line>    Future&LTList&LTInteger>> f3 = service.submit(task3);</span><br><span class=line>    Future&LTList&LTInteger>> f4 = service.submit(task4);</span><br><span class=line>    <span class=keyword>try</span>{</span><br><span class=line>        start = System.currentTimeMillis();</span><br><span class=line>        f1.get();</span><br><span class=line>        f2.get();</span><br><span class=line>        f3.get();</span><br><span class=line>        f4.get();</span><br><span class=line>        end = System.currentTimeMillis();</span><br><span class=line>        System.out.println(end - start);</span><br><span class=line>    }<span class=keyword>catch</span> (InterruptedException e){</span><br><span class=line>        e.printStackTrace();</span><br><span class=line>    }<span class=keyword>catch</span> (ExecutionException e){</span><br><span class=line>        e.printStackTrace();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line>---</span><br><span class=line></span><br><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">Task</span> <span class=keyword>implements</span> <span class="title class_">Callable</span>&LTList&LTInteger>>{</span><br><span class=line>    <span class=type>int</span> startPos, endPos;</span><br><span class=line>    Task(<span class=type>int</span> s, <span class=type>int</span> e){</span><br><span class=line>        <span class=built_in>this</span>.startPos = s;</span><br><span class=line>        <span class=built_in>this</span>.endPos = e;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> List&LTInteger> <span class="title function_">call</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        List&LTInteger> r = getPrime(startPos, endPos);</span><br><span class=line>        <span class=keyword>return</span> r;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>static</span> <span class=type>boolean</span> <span class="title function_">isPrime</span><span class=params>(<span class=type>int</span> num)</span>{</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>2</span>; i < num/<span class=number>2</span>; i++){</span><br><span class=line>            <span class=keyword>if</span> (num % i == <span class=number>0</span>)</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>static</span> List&LTInteger> <span class="title function_">getPrime</span><span class=params>(<span class=type>int</span> start, <span class=type>int</span> end)</span>{</span><br><span class=line>        List&LTInteger> results = <span class=keyword>new</span> <span class="title class_">ArrayList</span><>();</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> start; i <= end; i++){</span><br><span class=line>            <span class=keyword>if</span> (isPrime(i))</span><br><span class=line>                results.add(i);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> results;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure></ul> <h3 id=6-3-4、ScheduledThreadPool><a class=headerlink href=#6-3-4、ScheduledThreadPool title=6.3.4、ScheduledThreadPool></a>6.3.4、ScheduledThreadPool</h3><ul><li><p>简介：定时任务池，本质上还是ThreadPoolExecutor。</p><li><p>特点（默认）：核心指定，最大Integer.MAX_VALUE，空闲0，单位纳秒，队列DelayedWorkQueue，工厂DefaultThreadFactory，拒绝策略AbortPolicy；</p><li><p>实例</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">ScheduledThreadPoolTest</span><span class=params>()</span>{</span><br><span class=line>    <span class=type>ScheduledExecutorService</span> <span class=variable>service</span> <span class=operator>=</span> Executors.newScheduledThreadPool(<span class=number>4</span>);</span><br><span class=line>    service.scheduleAtFixedRate(() -> {</span><br><span class=line>        <span class=keyword>try</span>{</span><br><span class=line>            TimeUnit.MILLISECONDS.sleep(<span class=keyword>new</span> <span class="title class_">Random</span>().nextInt(<span class=number>1000</span>));</span><br><span class=line>        }<span class=keyword>catch</span> (InterruptedException e){</span><br><span class=line>            e.printStackTrace();</span><br><span class=line>        }</span><br><span class=line>        System.out.println(Thread.currentThread().getName());</span><br><span class=line>    }, <span class=number>0</span>, <span class=number>500</span>, TimeUnit.MILLISECONDS);</span><br><span class=line>}</span><br></pre></table></figure></ul> <h2 id=6-4、自定义线程池><a class=headerlink href=#6-4、自定义线程池 title=6.4、自定义线程池></a>6.4、自定义线程池</h2><h3 id=6-4-1、简介><a class=headerlink href=#6-4-1、简介 title=6.4.1、简介></a>6.4.1、简介</h3><p>自定义线程池可通过ThreadPoolExecutor来实现，其相关参数如下：</p> <ol><li><p>corePoolSize（核心线程数）</p><li><p>maximumPoolSize（最大线程数）</p><li><p>keepAliveTime（空闲时间）</p><li><p>TimeUnit unit（空闲时间单位）</p><li><p>BlockingQueue workQueue（阻塞队列）</p><li><p>ThreadFactory threadFactory（线程工厂）</p><li><p>RejectedExecutionHandler handler（拒绝策略）：拒绝策略有四种</p> <ol><li>AbortPolicy（默认）：抛异常RejectedExecutionException<li>DiscardPolicy：扔掉，不抛异常。<li>DiscardOldestPolicy：扔掉排队时间最久的。但是线程池如果关闭了，任务就会被丢弃。<li>CallerRunsPolicy：调用者来处理被拒绝的任务，比如主线程调用submit方法任务，但任务被拒绝，则主线程直接执行。但是线程池如果关闭了，任务就会被丢弃。</ol> <p>除此之外还可以自定义拒绝策略，方式为：实现接口<code>RejectedExecutionHandler</code>，并重写其<code>rejectedExecution(Runnable r, ThreadPoolExecutor executor)</code>方法。</p><li><p>boolean allowCoreThreadTimeOut：是否允许核心线程超时销毁，该参数不在构造函数中，但也极其重要。</p> <p><font color=orange>取值定义</font>：如果为false（默认），则表示即使处于空闲状态，核心线程也保持活动状态（不销毁）。如果为true，则核心线程使用keepAliveTime来超时等待工作（时间过后就销毁）。</p></ol> <h3 id=6-4-2、使用示例><a class=headerlink href=#6-4-2、使用示例 title=6.4.2、使用示例></a>6.4.2、使用示例</h3><p>拒绝策略使用示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>ThreadPoolExecutor</span> <span class=variable>executor</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class=number>2</span>, <span class=number>4</span>, <span class=number>60</span>, TimeUnit.SECONDS, <span class=keyword>new</span> <span class="title class_">ArrayBlockingQueue</span><>(<span class=number>4</span>),Executors.defaultThreadFactory(),<span class=keyword>new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></table></figure> <h3 id=6-4-3、最合适的线程数量><a class=headerlink href=#6-4-3、最合适的线程数量 title=6.4.3、最合适的线程数量></a>6.4.3、最合适的线程数量</h3><h4 id=6-4-3-1、CPU密集型运算><a class=headerlink href=#6-4-3-1、CPU密集型运算 title=6.4.3.1、CPU密集型运算></a>6.4.3.1、CPU密集型运算</h4><p><strong>CPU密集型业务通常采用 cpu核数+1 的数量值作为合适的线程数量。</strong>这样可以实现最优的CPU利用率，加1是保证当线程由于页缺失或其它问题导致暂停时，额外的线程就能顶上去，保证CPU时钟周期不浪费。</p> <h4 id=6-4-3-2、IO密集型运算><a class=headerlink href=#6-4-3-2、IO密集型运算 title=6.4.3.2、IO密集型运算></a>6.4.3.2、IO密集型运算</h4><p>CPU不总是处于繁忙状态，例如，当执行业务计算时会使用CPU资源，但当执行IO操作、RPC远程调用、数据库操作时，CPU不会工作会空闲下来，此时可以利用多线程来提高CPU利用率。</p> <p>经验公式如下：<br>$$<br>线程数量 = 核数 * CPU期望利用率 * 总时间(CPU计算时间+等待时间) / CPU计算时间。<br>$$<br>例如：4核CPU计算时间50%，其它等待时间是50%，期望CPU被100%利用，则</p> <p>线程数量 = 4 * 100% * 100% / 50% = 8个。</p> <p>例如：4核 CPU计算时间10%，其它等待时间是90%，期望CPU被100%利用，则</p> <p>线程数量 = 4 * 100% * 100% / 10% = 40个。</p> <h2 id=6-5、线程池监控><a class=headerlink href=#6-5、线程池监控 title=6.5、线程池监控></a>6.5、线程池监控</h2><h3 id=6-5-1、简介><a class=headerlink href=#6-5-1、简介 title=6.5.1、简介></a>6.5.1、简介</h3><p><strong>如果在系统中大量使用线程池，则有必要对线程池进行监控</strong>，方便在出现问题时，可以根据线程池的使用状况快速定位问题。</p> <h3 id=6-5-2、监控方式><a class=headerlink href=#6-5-2、监控方式 title=6.5.2、监控方式></a>6.5.2、监控方式</h3><h4 id=参数监控><a class=headerlink href=#参数监控 title=参数监控></a>参数监控</h4><p><strong>可以通过线程池提供的参数进行监控</strong>，监控线程池时可以使用以下属性。</p> <ul><li>taskCount：线程池需要执行的任务数量。<li>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。<li>largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是 否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。<li>getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。<li>getActiveCount：获取活动的线程数。</ul> <h4 id=扩展监控><a class=headerlink href=#扩展监控 title=扩展监控></a>扩展监控</h4><p>通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的 beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执 行一些代码来进行监控。</p> <p>例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。 这几个方法在线程池里是空方法。</p> <h2 id=6-6、Executor框架><a class=headerlink href=#6-6、Executor框架 title=6.6、Executor框架></a>6.6、Executor框架</h2><h3 id=6-6-1、Executor类结构图><a class=headerlink href=#6-6-1、Executor类结构图 title=6.6.1、Executor类结构图></a>6.6.1、Executor类结构图</h3><p><img alt=Executor类结构图01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/Executor%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE01.png?token=AIGEF3NWRCARP7IVE37JHV3EZZZKE></p> <h3 id=6-6-2、ThreadPoolExecutor源码解析（JDK8）><a class=headerlink href=#6-6-2、ThreadPoolExecutor源码解析（JDK8） title=6.6.2、ThreadPoolExecutor源码解析（JDK8）></a>6.6.2、ThreadPoolExecutor源码解析（JDK8）</h3><h4 id=addWorker><a class=headerlink href=#addWorker title=addWorker></a>addWorker</h4><p>addWorker的源码分两部分：</p> <ol><li>上面的嵌套for死循环，目的就是把worker数量加1。<ol><li>外层for循环：遍历检测状态值是否符合条件，如果状态值 >= shutdown，说明不符合条件，执行return false退出。<li>内层for循环：添加线程。先判断当前WC线程数量是否超过上限（数量 > 536870911或者 >= (corePoolSize /maximumPoolSize)），如果超过就不再添加，否则通过CAS方式进行添加。如果添加成功了，则执行break retr跳出双层循环，这说明第一步算是完成了；如果没有添加成功就继续AtomicInteger的get方法，然后跳到最外层循环处进行重新处理；</ol><li>创建一个Worker并执行这个Worker。</ol> <h4 id=execute><a class=headerlink href=#execute title=execute></a>execute</h4><ol><li><p>如果任务为null，则抛出异常。</p><li><p>工作线程数 是否小于 核心线程数，若小于则直接创建核心线程。否则将任务放入队列中。</p><li><p>如果线程池不是运行状态，或者任务进入队列失败了，则创建非核心线程执行任务。</p></ol> <p><font color=red>注意事项：</font></p> <ol><li>线程非运行状态时，addWorker内部会判断线程池状态。<li>addWorker的第二个参数表示是否创建核心线程。<li>addWorker返回false，说明任务执行失败，需要进行reject操作。</ol> <h4 id=runWorker><a class=headerlink href=#runWorker title=runWorker></a>runWorker</h4><p><strong>启动线程后会通过该方法去执行任务，期间需要加锁</strong>。</p> <ol><li><p>先执行Worker.unlock()方法来允许中断操作；变量boolean completedAbruptly 用于表示是否自旋。</p><li><p>自旋过程。如果firstTask不为null 或者 任务队列不为空，则从队列拿任务来执行，否则将 completedAbruptly设为false; 且最终执行processWorkerExit(w, completedAbruptly);</p> <p>从队列拿到任务后，执行任务的过程如下：</p> <ol><li>w.lock()加锁，任务执行的原子性。<li>如果线程池正在停止，则对当前线程进行中断操作。<li>执行任务的前后通过beforeExecute()、afterExecute()来扩展功能。但要注意这两个方法在该类中默认是空实现。<li>执行 completedAbruptly = false; 和 processWorkerExit(w, completedAbruptly);</ol></ol> <h3 id=6-6-3、ScheduledThreadPoolExecutor><a class=headerlink href=#6-6-3、ScheduledThreadPoolExecutor title=6.6.3、ScheduledThreadPoolExecutor></a>6.6.3、ScheduledThreadPoolExecutor</h3><h4 id=简介-12><a class=headerlink href=#简介-12 title=简介></a>简介</h4><p>继承自ThreadPoolExecutor，<strong>可在指定延迟之后运行任务，或者定期执行任务。</strong>其功能与Timer类似，但 ScheduledThreadPoolExecutor功能更强大、更灵活。Timer对应的是单个后台线程，而 ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。</p> <h4 id=运行机制><a class=headerlink href=#运行机制 title=运行机制></a>运行机制</h4><p>ScheduledThreadPoolExecutor的执行主要分为两大部分：</p> <ol><li>当调用ScheduledThreadPoolExecutor的scheduleAtFixedRate()方法或者scheduleWithFixedDelay()方法时，会向ScheduledThreadPoolExecutor的DelayQueue添加一个实现了 RunnableScheduledFutur接口的ScheduledFutureTask。<li>线程池中的线程从DelayQueue中获取ScheduledFutureTask，然后执行任务。</ol> <h4 id=底层实现-3><a class=headerlink href=#底层实现-3 title=底层实现></a>底层实现</h4><p>ScheduledThreadPoolExecutor会把待调度的任务（ScheduledFutureTask） 放到一个DelayQueue中。</p> <p>ScheduledFutureTask主要包含3个成员变量：</p> <ul><li>long型成员变量time，表示这个任务将要被执行的具体时间。<li>long型成员变量sequenceNumber，表示这个任务被添加到ScheduledThreadPoolExecutor中的序号。<li>long型成员变量period，表示任务执行的间隔周期。</ul> <h3 id=6-6-4、FutureTask><a class=headerlink href=#6-6-4、FutureTask title=6.6.4、FutureTask></a>6.6.4、FutureTask</h3><p>Future接口和实现Future接口的FutureTask类，代表异步计算的结果。</p> <h4 id=简介-13><a class=headerlink href=#简介-13 title=简介></a>简介</h4><p>FutureTask除了实现Future接口外，还实现了Runnable接口。因此，<strong>FutureTask可以交给 Executor执行，也可以由调用线程直接执行（FutureTask.run()）。</strong></p> <p>根据FutureTask.run()方法被执行的时机，FutureTask可处于3种状态：</p> <ul><li>未启动<ol><li>FutureTask.get()方法将导致调用线程阻塞；<li>FutureTask.cancel()方法将导致此任务永远不会被执行；</ol><li>已启动<ol><li>FutureTask.get()方法将导致调用线程阻塞；<li>FutureTask.cancel（true）方法将以中断执行此任务线程 的方式来试图停止任务；<li>FutureTask.cancel（false）方法将 不会对正在执行此任务的线程产生影响（让正在执行的任务运行完成）；</ol><li>已完成<ol><li>FutureTask.get()方法将导致调用线程立即返回结果或抛出异常；<li>FutureTask.cancel（…）方法将返回false。</ol></ul> <h4 id=底层实现-4><a class=headerlink href=#底层实现-4 title=底层实现></a>底层实现</h4><p>FutureTask的实现基于AbstractQueuedSynchronizer。</p> <p>AQS被作为“模板方法模式”的基础类提供给FutureTask的内部子类Sync，这个内部子类只需要实现状态检查和状态更新的方法即可，这些方法将控制FutureTask的获取和释放操作。具体来说，Sync实现了AQS的tryAcquireShared(int) 方法和 tryReleaseShared(int) 方法，Sync通过这两个方法来检查和更新同步状态。</p> <h2 id=6-7、总结><a class=headerlink href=#6-7、总结 title=6.7、总结></a>6.7、总结</h2><h3 id=6-7-1、建议使用ThreadPoolExecutor创建线程池？><a class=headerlink href=#6-7-1、建议使用ThreadPoolExecutor创建线程池？ title=6.7.1、建议使用ThreadPoolExecutor创建线程池？></a>6.7.1、建议使用ThreadPoolExecutor创建线程池？</h3><ol><li><p>Executors提供的线程池使用场景有限。</p><li><p>Executors底层还是调用ThreadPoolExecutor创建线程池。</p><li><p>OOM问题（阿里手册）</p> <ol><li><p>FixedThreadPool 和 SingleThreadPool</p> <p>两者允许的队列长度为Integer.MAX_VALUE，可能堆积大量请求，进而导致OOM。</p><li><p>CachedThreadPool</p> <p>允许创建的线程数量为Integer.MAX_VALUE，可能创建大量的线程，进而导致OOM。</p></ol></ol> <h3 id=6-7-2、生产中如何选择使用正确的队列？><a class=headerlink href=#6-7-2、生产中如何选择使用正确的队列？ title=6.7.2、生产中如何选择使用正确的队列？></a>6.7.2、生产中如何选择使用正确的队列？</h3><p>根据实际情况来选择：</p> <ol><li>高峰期的任务，建议使用LinkedBlockingQueue，这个是无界队列，不限制任务数量。<li>重要性较低的任务，建议使用ArrayBlockingQueue，这个队列需要指定大小，如果任务超出，会创建非核心线程执行任务。</ol> <h3 id=6-7-3、生产中如何保证线程池队列的可用性？><a class=headerlink href=#6-7-3、生产中如何保证线程池队列的可用性？ title=6.7.3、生产中如何保证线程池队列的可用性？></a>6.7.3、生产中如何保证线程池队列的可用性？</h3><ol><li>设计一个线程管理器，通过一个定时任务 定时检测 Map中线程池当前任务队列的状态，会设置一个报警阈值（waterThreshold - 水位线），超过该阈值就会报警，然后根据实际情况去应对。<li>线程池压测，如果发生超水位现象，就对线程按线程名做降级，动态调整核心线程数和队列，当然还有限流等保障。</ol> <h3 id=6-7-4、如何拆分线程池、核心任务数、队列大小呢？><a class=headerlink href=#6-7-4、如何拆分线程池、核心任务数、队列大小呢？ title=6.7.4、如何拆分线程池、核心任务数、队列大小呢？></a>6.7.4、如何拆分线程池、核心任务数、队列大小呢？</h3><ol><li><p>按照 任务类型 拆分任务，使用不同的线程池，分别命名。</p><li><p>区分 任务类型。其是 CPU密集型 还是 IO密集型，CPU密集型 可以设置 核心线程数为CPU核心数，上下文切换少；IO密集型则可以设置核心线程数大一点。</p><li><p>压测并估算，可以参考线程池变量largestPoolSize，它表示线程池达到过的最大线程任务。</p><li><p>设置核心线程数参考公式如下：</p> <p><strong>最佳线程数 = ((线程等待时间 + 线程CPU时间) / 线程CPU时间) * CPU数量;</strong></p></ol> <h1 id=7、高效存储工具><a class=headerlink href=#7、高效存储工具 title=7、高效存储工具></a>7、高效存储工具</h1><h2 id=7-1、Disruptor><a class=headerlink href=#7-1、Disruptor title=7.1、Disruptor></a>7.1、Disruptor</h2><h3 id=7-1-1、简介><a class=headerlink href=#7-1-1、简介 title=7.1.1、简介></a>7.1.1、简介</h3><p><strong>Disruptor是分裂、瓦解的意思。Disruptor是一个做金融、做股票的公司开发的，开源后受到广泛认可，2011年获得Duke奖。</strong>如果将之用作MQ的话，其是单机最快的MQ。该工具性能非常高，因为内部用了大量的CAS，另外把各种各样的性能开发到了极致。</p> <p><strong>Disruptor存储在内存中，简单理解就是内存中用于存储元素的一个高效队列。</strong></p> <p>Disruptor称为无锁的、高并发的、环形Buffer，直接覆盖旧数据，降低GC频率，用于生产者消费者模式。</p> <h3 id=7-1-2、核心及特点><a class=headerlink href=#7-1-2、核心及特点 title=7.1.2、核心及特点></a>7.1.2、核心及特点</h3><p><strong>Disruptor是一个环形队列、环形Buffer。</strong>Disruptor是用数组实现的一个队列，你也可以认为Disruptor就是用数组实现的ConcurrentArrayQueue，另外这个Queue是首尾相连。</p> <h3 id=7-1-3、实现原理><a class=headerlink href=#7-1-3、实现原理 title=7.1.3、实现原理></a>7.1.3、实现原理</h3><h4 id=Disruptor为啥快？><a class=headerlink href=#Disruptor为啥快？ title=Disruptor为啥快？></a>Disruptor为啥快？</h4><p>环形结构 只需维护 一个位置，就是sequence序列，该序列表示下一个元素在哪里，相当于只有一个指针在移动定位。位置可以通过数值与环形队列容量取模获得。</p> <p>由于采用覆盖方式，所以没有必要记录头指针和尾指针。我只需要一个指针就够用了，就这一点来说依然比ConcurrentLinkedQueue要快。</p> <h4 id=生产者装满数据后继续装会覆盖吗？><a class=headerlink href=#生产者装满数据后继续装会覆盖吗？ title=生产者装满数据后继续装会覆盖吗？></a>生产者装满数据后继续装会覆盖吗？</h4><p>不会覆盖的，因为有等待策略——生产者生产满了就要停止生产并进入等待状态。等待策略共有8种，详情见总结部分。</p> <h3 id=7-1-4、开发步骤><a class=headerlink href=#7-1-4、开发步骤 title=7.1.4、开发步骤></a>7.1.4、开发步骤</h3><p>开发步骤是比较固定的。</p> <ol><li>定义Event：队列中需要处理的元素。<li>定义Event工厂：用于填充队列。<li>定义EventHandle（消费者）：处理容器中的元素。</ol> <h3 id=7-1-5、入门案例><a class=headerlink href=#7-1-5、入门案例 title=7.1.5、入门案例></a>7.1.5、入门案例</h3><h4 id=OrderEvent-java><a class=headerlink href=#OrderEvent-java title=OrderEvent.java></a>OrderEvent.java</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">OrderEvent</span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=type>long</span> value;</span><br><span class=line>    <span class=keyword>public</span> <span class=type>long</span> <span class="title function_">getValue</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> value;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setValue</span><span class=params>(<span class=type>long</span> value)</span> {</span><br><span class=line>        <span class=built_in>this</span>.value = value;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=OrderEventFactory-java><a class=headerlink href=#OrderEventFactory-java title=OrderEventFactory.java></a>OrderEventFactory.java</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">OrderEventFactory</span> <span class=keyword>implements</span> <span class="title class_">EventFactory</span>&LTOrderEvent> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> OrderEvent <span class="title function_">newInstance</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">OrderEvent</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=OrderEventHandler-java><a class=headerlink href=#OrderEventHandler-java title=OrderEventHandler.java></a>OrderEventHandler.java</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">OrderEventHandler</span> <span class=keyword>implements</span> <span class="title class_">EventHandler</span>&LTOrderEvent> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">onEvent</span><span class=params>(OrderEvent event, <span class=type>long</span> sequence, <span class=type>boolean</span> endOfBatch)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        System.out.println(<span class=string>"消费者："</span> + event.getValue());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=OrderEventProducer-java><a class=headerlink href=#OrderEventProducer-java title=OrderEventProducer.java></a>OrderEventProducer.java</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">OrderEventProducer</span> {</span><br><span class=line>    <span class=keyword>private</span> RingBuffer&LTOrderEvent> ringBuffer;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">OrderEventProducer</span><span class=params>(RingBuffer&LTOrderEvent> ringBuffer)</span> {</span><br><span class=line>        <span class=built_in>this</span>.ringBuffer = ringBuffer;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">sendData</span><span class=params>(ByteBuffer data)</span>{</span><br><span class=line>        <span class=type>long</span> <span class=variable>sequence</span> <span class=operator>=</span> ringBuffer.next();</span><br><span class=line>        <span class=keyword>try</span>{</span><br><span class=line>            <span class=comment>//1. 在生产者发送消息的时候，首先需要从ringBuffer里面获取一个可用的序号</span></span><br><span class=line>            <span class=comment>//2. 根据这个序号 找到具体的“orderEvent”元素 此时获取的OrderEvent是一个空的对象</span></span><br><span class=line>            <span class=type>OrderEvent</span> <span class=variable>event</span> <span class=operator>=</span> ringBuffer.get(sequence);</span><br><span class=line>            <span class=comment>//3 进行实际的赋值操作</span></span><br><span class=line>            event.setValue(data.getLong(<span class=number>0</span>));</span><br><span class=line>        }<span class=keyword>finally</span> {</span><br><span class=line>            <span class=comment>// 4 提交操作</span></span><br><span class=line>            ringBuffer.publish(sequence);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=App-java><a class=headerlink href=#App-java title=App.java></a>App.java</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">App</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>OrderEventFactory</span> <span class=variable>orderEventFactory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">OrderEventFactory</span>();</span><br><span class=line>        <span class=type>ExecutorService</span> <span class=variable>executor</span> <span class=operator>=</span> Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class=line>        <span class=type>int</span> <span class=variable>ringBufferSize</span> <span class=operator>=</span> <span class=number>1024</span> * <span class=number>1024</span>;</span><br><span class=line></span><br><span class=line>        <span class=comment>/**</span></span><br><span class=line><span class=comment>         *  1 eventFacotry 消息工厂对象</span></span><br><span class=line><span class=comment>         *  2 ringBufferSize 容器的长度</span></span><br><span class=line><span class=comment>         *  3 executor 线程池</span></span><br><span class=line><span class=comment>         *  4 ProducerType 生产者类型</span></span><br><span class=line><span class=comment>         *  5 waitStartegy 等待策略</span></span><br><span class=line><span class=comment>         */</span></span><br><span class=line>        <span class=comment>// 1 实例化一个disruptor的对象</span></span><br><span class=line>        Disruptor&LTOrderEvent> disruptor = <span class=keyword>new</span> <span class="title class_">Disruptor</span><>(orderEventFactory, ringBufferSize, executor, ProducerType.SINGLE, <span class=keyword>new</span> <span class="title class_">BlockingWaitStrategy</span>());</span><br><span class=line>        <span class=comment>// 2 添加消费者的监听(Disruptor 与消费者的一个关联关系)</span></span><br><span class=line>        disruptor.handleEventsWith(<span class=keyword>new</span> <span class="title class_">OrderEventHandler</span>());</span><br><span class=line>        <span class=comment>// 3 启动disruptor</span></span><br><span class=line>        disruptor.start();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 4 获取实际存储数据的容器 RingBuffer</span></span><br><span class=line>        RingBuffer&LTOrderEvent> ringBuffer = disruptor.getRingBuffer();</span><br><span class=line>        <span class=type>OrderEventProducer</span> <span class=variable>producer</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">OrderEventProducer</span>(ringBuffer);</span><br><span class=line>        <span class=comment>// 生成一百个数 然后丢给producer</span></span><br><span class=line>        <span class=type>ByteBuffer</span> <span class=variable>bb</span> <span class=operator>=</span> ByteBuffer.allocate(<span class=number>8</span>);</span><br><span class=line>        <span class=keyword>for</span>(<span class=type>long</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < <span class=number>100</span>; i++){</span><br><span class=line>            bb.putLong(<span class=number>0</span>, i);</span><br><span class=line>            producer.sendData(bb);</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=comment>// 关闭disruptor和线程池</span></span><br><span class=line>        disruptor.shutdown();</span><br><span class=line>        executor.shutdown();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h3 id=7-1-6、总结><a class=headerlink href=#7-1-6、总结 title=7.1.6、总结></a>7.1.6、总结</h3><h4 id=ProducerType（生产者线程模式）><a class=headerlink href=#ProducerType（生产者线程模式） title=ProducerType（生产者线程模式）></a>ProducerType（生产者线程模式）</h4><p><strong>ProducerType有两种模式：Producer.MULTI 和 Producer.SINGLE。默认为MULTI，表示在多线程模式下产生sequence。如果确定是单线程生产者，可以指定SINGLE，效率会有提升。</strong></p> <h4 id=等待策略（8种）><a class=headerlink href=#等待策略（8种） title=等待策略（8种）></a>等待策略（8种）</h4><ol><li>BlockingWaitStrategy（常用）：通过线程阻塞的方式，等待生产者被唤醒，唤醒后再次检查依赖的sequence是否已经消费。<li>BusySpinWaitStrategy：线程一直自旋等待，可能比较消耗CPU。<li>LiteBlockingWaitStrategy：线程阻塞等待生产者被唤醒。与第1个的区别是——如果两个线程同时访问一个waitfor，一个访问signalAll时，可以减少lock加锁次数。<li>LiteTimeoutBlockingWaitStrategy：与第3个相比，该策略设置了阻塞时间，超过时间后抛出异常。<li>PhasedBackoffWaitStrategy：根据时间参数和等待的策略来决定使用哪种等待策略。<li>TimeoutBlockingWaitStrategy：相对于第1个来说，该策略设置了等待时间，超过后抛出异常。<li>YieldingWatitStrategy（常用）：尝试100次，然后Thread.yield()让出CPU。<li>SleepingWaitStrategy（常用）：sleep。</ol> <h4 id=消费者异常处理><a class=headerlink href=#消费者异常处理 title=消费者异常处理></a>消费者异常处理</h4><ol><li>默认：disruptor.setDefaultExceptionHandler()；<li>覆盖：disruptor.handleExceptionFor().wait()；</ol> <h1 id=8、高效测试工具><a class=headerlink href=#8、高效测试工具 title=8、高效测试工具></a>8、高效测试工具</h1><h2 id=8-1、JMH><a class=headerlink href=#8-1、JMH title=8.1、JMH></a>8.1、JMH</h2><h4 id=8-1-1、简介><a class=headerlink href=#8-1-1、简介 title=8.1.1、简介></a>8.1.1、简介</h4><p><strong>JMH全程为 java Microbenchmark Harness，意为Java微基准测试。它测试的是一个方法的性能，换了一种实现后再次观察其性能好坏。</strong></p> <p><font color=red>注意：该测试框架于2013年由JLT人员开发而成，后来归到了OpenJDK下面。</font></p> <h4 id=8-1-2、JMH相关概念><a class=headerlink href=#8-1-2、JMH相关概念 title=8.1.2、JMH相关概念></a>8.1.2、JMH相关概念</h4><ol><li>Benchmark mode：基准测试的模式。<li>Warmup：预热，由于JVM会对特定代码进行优化，预热对于测试很重要。<li>Measurement：共执行多少次测试。<li>Timeout：超时时间。<li>Threads：线程数，由fork指定。<li>Benchmark：测试哪一段代码。</ol> <h3 id=8-1-3、使用示例><a class=headerlink href=#8-1-3、使用示例 title=8.1.3、使用示例></a>8.1.3、使用示例</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.Benchmark;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.BenchmarkMode;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.Mode;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.OutputTimeUnit;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.State;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.Scope;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.Setup;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.TearDown;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.runner.Runner;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.util.ArrayList;</span><br><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line><span class=keyword>import</span> java.util.Random;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.TimeUnit;</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * JMH工具测试</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=meta>@State(Scope.Thread)</span></span><br><span class=line><span class=meta>@BenchmarkMode(Mode.AverageTime)</span>    <span class=comment>// 测试模式</span></span><br><span class=line><span class=meta>@OutputTimeUnit(TimeUnit.MILLISECONDS)</span>  <span class=comment>// 时间单位</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">JMHUseTest</span> {</span><br><span class=line>    <span class=keyword>private</span> List&LTInteger> list;</span><br><span class=line>    <span class=keyword>private</span> Random random;</span><br><span class=line></span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 测试前的初始化</span></span><br><span class=line><span class=comment>     *</span></span><br><span class=line><span class=comment>     * 初始化了一个由1000个随机整数组成的List</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=meta>@Setup</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setup</span><span class=params>()</span> {</span><br><span class=line>        list = <span class=keyword>new</span> <span class="title class_">ArrayList</span><>();</span><br><span class=line>        random = <span class=keyword>new</span> <span class="title class_">Random</span>();</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < <span class=number>1000</span>; i++) {</span><br><span class=line>            list.add(random.nextInt());</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 测试后的清理动作</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=meta>@TearDown</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">teardown</span><span class=params>()</span> {</span><br><span class=line>        list = <span class=literal>null</span>;</span><br><span class=line>        random = <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 排序</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=meta>@Benchmark</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testSort</span><span class=params>()</span> {</span><br><span class=line>        list.sort(Integer::compare);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 并行排序</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=meta>@Benchmark</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testParallelSort</span><span class=params>()</span> {</span><br><span class=line>        list.parallelStream().sorted(Integer::compare).toArray();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 常用方法解析：</span></span><br><span class=line><span class=comment>     * - `include(String classNameRegex)`：指定要测试的类，可以使用正则表达式来匹配多个类。</span></span><br><span class=line><span class=comment>     * - `forks(int count)`：指定测试时进行的fork数量，即测试时重复运行基准测试的次数。</span></span><br><span class=line><span class=comment>     * - `warmupIterations(int count)`：指定预热迭代次数，即在测量迭代次数前进行的预热迭代次数。</span></span><br><span class=line><span class=comment>     * - `measurementIterations(int count)`：指定测量迭代次数，即每个基准测试运行的迭代次数。</span></span><br><span class=line><span class=comment>     * - `mode(Mode mode)`：指定测试模式，包括平均时间（AverageTime）、平均吞吐量（Througput）、平均延迟（SampleTime）等。</span></span><br><span class=line><span class=comment>     * - `timeUnit(TimeUnit unit)`：指定测试结果的时间单位，包括纳秒（NANOSECONDS）、微秒（MICROSECONDS）、毫秒（MILLISECONDS）等。</span></span><br><span class=line><span class=comment>     * - `threads(int count)`：指定测试时使用的线程数。</span></span><br><span class=line><span class=comment>     * - `verbosity(VerboseMode mode)`：指定测试结果的详细程度，包括默认（NORMAL）、详细（EXTRA）、极度详细（DEBUG）等。</span></span><br><span class=line><span class=comment>     * - `jvmArgs(String... args)`：指定测试时使用的Java虚拟机参数。</span></span><br><span class=line><span class=comment>     * - `addProfiler(Class&LT? extends Profiler> profilerClass)`：指定测试时使用的分析器.</span></span><br><span class=line><span class=comment>     * - `resultFormat(ResultFormatType type)`：指定测试结果的输出格式，包括文本（TEXT）、CSV、JSON等。</span></span><br><span class=line><span class=comment>     *</span></span><br><span class=line><span class=comment>     * 创建`Options`对象后，可以使用`Runner`类来运行基准测试。`Runner`类提供了多个方法来运行基准测试，如：</span></span><br><span class=line><span class=comment>     * - `run()`：运行基准测试并输出测试结果。</span></span><br><span class=line><span class=comment>     * - `runAsync()`：异步运行基准测试。</span></span><br><span class=line><span class=comment>     * - `runTo(TimeValue time)`：运行基准测试并在指定时间后停止。</span></span><br><span class=line><span class=comment>     * - `runTo(TimeValue time, TimeUnit timeUnit)`：运行基准测试并在指定时间后停止。</span></span><br><span class=line><span class=comment>     *</span></span><br><span class=line><span class=comment>     * <span class=doctag>@param</span> args</span></span><br><span class=line><span class=comment>     * <span class=doctag>@throws</span> RunnerException</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> RunnerException {</span><br><span class=line>        <span class=type>Options</span> <span class=variable>options</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class=line>                .include(JMHUseTest.class.getSimpleName())</span><br><span class=line>                .forks(<span class=number>1</span>)   <span class=comment>// 运行基准测试的次数</span></span><br><span class=line>                .warmupIterations(<span class=number>1</span>)    <span class=comment>// 预热次数</span></span><br><span class=line>                .measurementIterations(<span class=number>3</span>)   <span class=comment>// 基准测试执行的次数</span></span><br><span class=line>                .build();</span><br><span class=line>        <span class=keyword>new</span> <span class="title class_">Runner</span>(options).run();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <footer class=post-footer><div class=post-eof></div></footer> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/%E5%AD%98%E5%82%A8%E5%99%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/%E5%AD%98%E5%82%A8%E5%99%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ itemprop=url>计算机系列-存储器</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-06 11:05:16" datetime=2023-10-06T11:05:16+08:00 itemprop=dateModified>2023-10-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/ itemprop=url rel=index><span itemprop=name>计算机</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、概述><a class=headerlink href=#1、概述 title=1、概述></a>1、概述</h1><p><strong>计算机的第二个主要部件就是存储器。</strong><p>理想情形下，存储器应该快、大 且便宜。但无法同时满足这三项，于是存储器系统采用一种分层结构，如下图所示。<p><img alt=存储管理-存储器分层结构图示 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86-%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%E5%9B%BE%E7%A4%BA.jpg?token=AIGEF3MKCMMKF6RE7JQNMQDEZZM4O><h1 id=2、存储分类><a class=headerlink href=#2、存储分类 title=2、存储分类></a>2、存储分类</h1><h2 id=2-1、寄存器><a class=headerlink href=#2-1、寄存器 title=2.1、寄存器></a>2.1、寄存器</h2><p><strong>存储器系统顶层一般说的是CPU中的寄存器。</strong><p>寄存器使用与CPU相同的材料制成，与CPU一样快。<p>寄存器存储容量在32位CPU中为32×32位，在64位CPU中为64×64位。在两种情形下，其存储容量都小于1 KB。程序必须在软件中自行管理这些寄存器（即决定如何使用它们）。<h2 id=2-2、高速缓存><a class=headerlink href=#2-2、高速缓存 title=2.2、高速缓存></a>2.2、高速缓存</h2><h3 id=2-2-1、简介><a class=headerlink href=#2-2-1、简介 title=2.2.1、简介></a>2.2.1、简介</h3><p><strong>高速缓存由硬件控制。高速缓存行大小通常为64个字节，地址0至63对应高速缓存行0，地址64至127对应高速缓存行1，以此类推。</strong><p>高速缓存行通常会放在CPU内部或接近CPU的高速缓存中。<h3 id=2-2-2、缓存命中><a class=headerlink href=#2-2-2、缓存命中 title=2.2.2、缓存命中></a>2.2.2、缓存命中</h3><p><strong>当程序需要读一个存储字时，高速缓存会检查自己的内存中是否存在需要的高速缓存行。如果存在，则称之为高速缓存命中。</strong><blockquote><p>高速缓存命中 通常需要两个时钟周期。<p>缓存满足了请求，就不需要通过总线把访问请求送往主存。高速缓存未命中就必须访问内存，这要消耗大量时间。</blockquote><h3 id=2-2-3、缓存功能><a class=headerlink href=#2-2-3、缓存功能 title=2.2.3、缓存功能></a>2.2.3、缓存功能</h3><p><strong>缓存通常可以提高性能。</strong><ol><li>在内存中保存频繁使用的文件，以避免从磁盘中重复调取这些文件。<li>长路径名转换成文件所在磁盘地址的结果，也可以放入缓存，以避免重复寻找地址。<li>一个Web页面（URL）地址 转换为 网络地址（IP地址）后，转换结果可以缓存起来以供将来使用。</ol><h3 id=2-2-4、L1-L2-L3><a class=headerlink href=#2-2-4、L1-L2-L3 title=2.2.4、L1/L2/L3></a>2.2.4、L1/L2/L3</h3><h4 id=2-2-4-1、简介><a class=headerlink href=#2-2-4-1、简介 title=2.2.4.1、简介></a>2.2.4.1、简介</h4><ul><li><p>L1：L1缓存在CPU内部，其使命通常是将已解码指令调入CPU执行引擎。对于频繁使用的数据字，大多芯片都会有第二个L1缓存。通常L1缓存大小为16KB。</p><li><p>L2：L2缓存 用来存放 最近所使用过若干兆字节 内存字。</p><li><p>L3：L3缓存 通常作为共享内存 来为所有CPU提供服务。</p></ul><h4 id=2-2-4-2、所属位置><a class=headerlink href=#2-2-4-2、所属位置 title=2.2.4.2、所属位置></a>2.2.4.2、所属位置</h4><p><img alt=存储管理-CPU中L1L2L3缓存的位置 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86-CPU%E4%B8%ADL1L2L3%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%8D%E7%BD%AE.jpg?token=AIGEF3JOEGZ6PAAZUO2QDT3EZZM66><p>L1缓存通常位于内核中。L2缓存所属位置通常有2种类型：<ul><li><p>所有核 共享L2缓存</p> <p>应用案例：Intel多核芯片采用了这个方法。</p> <p>缺点：共享L2缓存 依赖于复杂的缓存控制器。</p><li><p>所有核中 都存在L2缓存</p> <p>应用案例：AMD采用这个方法。</p> <p>缺点：很难设法保持L2缓存的一致性。</p></ul><p><strong>L3缓存位置通常在CPU外，L3缓存作为共享内存为所有CPU提供服务。</strong><h2 id=2-3、主存><a class=headerlink href=#2-3、主存 title=2.3、主存></a>2.3、主存</h2><h3 id=2-3-1、简介><a class=headerlink href=#2-3-1、简介 title=2.3.1、简介></a>2.3.1、简介</h3><p><strong>主存位于第五层，是存储系统的主力。主存通常称为随机访问存储器（Random Access Memory，RAM）。</strong><blockquote><p>过去有时称磁芯存储器，因为在20世纪50年代和60年代，通常使用很小的可磁化的铁磁体制作主存。</blockquote><h3 id=2-3-2、非易失性存储器><a class=headerlink href=#2-3-2、非易失性存储器 title=2.3.2、非易失性存储器></a>2.3.2、非易失性存储器</h3><p>除了主存之外，许多计算机已经在使用少量的非易失性随机访问存储器。它们与RAM不同，在电源切断之后，非易失性随机访问存储器并不丢失其内容。<p>只读存储器（Read Only Memory，ROM）在工厂中就被编程完毕，然后再也不能被修改。ROM速度快且便宜。<blockquote><p>个别计算机中，启动计算机 的引导加载模块 就存放在ROM中。另外，一些I/O卡也采用ROM处理底层设备控制。</blockquote><p>EEPROM（Electrically Erasable PROM，电可擦除可编程ROM）和闪存（flash memory）也是非易失性的，但与ROM相反的是它们可以擦除和重写。重写它们比写入RAM需要更多时间，所以其使用方式与ROM相同，而其与众不同的特点使它们有可能通过字段重写方式纠正所保存程序中的错误。<h3 id=2-3-3、易失性存储器><a class=headerlink href=#2-3-3、易失性存储器 title=2.3.3、易失性存储器></a>2.3.3、易失性存储器</h3><h4 id=2-3-3-1、简介><a class=headerlink href=#2-3-3-1、简介 title=2.3.3.1、简介></a>2.3.3.1、简介</h4><p><strong>CMOS是易失性存储器。</strong><p>CMOS存储器可以保存 当前时间和日期。CMOS存储器和递增时间的时钟电路由一块小电池驱动，所以，即使计算机没有上电，时间也仍然可以正确地更新。<p>CMOS存储器还可以保存配置参数，诸如，哪一个是启动磁盘等。<h4 id=2-3-3-2、CMOS优缺点><a class=headerlink href=#2-3-3-2、CMOS优缺点 title=2.3.3.2、CMOS优缺点></a>2.3.3.2、CMOS优缺点</h4><p>CMOS耗电量非常少，一块工厂原装电池能使用若干年。但当电池失效时计算机就会出现“Alzheimer病症”。<h2 id=2-4、磁盘><a class=headerlink href=#2-4、磁盘 title=2.4、磁盘></a>2.4、磁盘</h2><p><font color=red>详情内容请参考 【磁盘管理知识总结.md】文档。</font><h2 id=2-5、磁带><a class=headerlink href=#2-5、磁带 title=2.5、磁带></a>2.5、磁带</h2><h3 id=2-5-1、简介><a class=headerlink href=#2-5-1、简介 title=2.5.1、简介></a>2.5.1、简介</h3><p><strong>存储器体系最后一层是磁带。该种介质通常用于磁盘备份，且可保存大量数据集。</strong><p>访问磁带前要把磁带装到磁带机上，可人工安装也可机器安装（在大型数据库中通常安装有自动磁带处理设备）。磁带可能还需要向前绕转以便读取所请求的数据块。<h3 id=2-5-2、特点><a class=headerlink href=#2-5-2、特点 title=2.5.2、特点></a>2.5.2、特点</h3><p>磁带的每个二进制位成本极其便宜、可移动，为了在火灾、洪水、地震等灾害中能存活下来，离线存储的备份磁带非常重要。<h3 id=2-5-3、总结><a class=headerlink href=#2-5-3、总结 title=2.5.3、总结></a>2.5.3、总结</h3><p>上面说过存储器体系结构是典型的，但有的安装系统并不具备所有层次，或者有所差别（诸如光盘）。不过，在所有的系统中，当层次下降时，其随机访问时间 会 明显增加，容量也增加，而每个二进制位的成本则大幅度下降。</div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ itemprop=url>计算机系列-磁盘管理</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-06 10:54:18" datetime=2023-10-06T10:54:18+08:00 itemprop=dateModified>2023-10-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/ itemprop=url rel=index><span itemprop=name>计算机</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、磁盘存储><a class=headerlink href=#1、磁盘存储 title=1、磁盘存储></a>1、磁盘存储</h1><h2 id=1-1、磁盘存储简介><a class=headerlink href=#1-1、磁盘存储简介 title=1.1、磁盘存储简介></a>1.1、磁盘存储简介</h2><p><strong>为了提高计算机的IO性能，一般会通过一些容器将数据存储起来，这些容器我们称之为“磁盘”或“硬盘”。</strong><p>磁盘和硬盘 两者是有区别的，它们的区别如下：<ul><li>主体不同<ul><li>磁盘：利用 磁记录技术 存储数据的存储器；<li>硬盘：计算机主要存储设备；</ul><li>范围不同<ul><li>磁盘：计算机主要存储介质，包括软盘和硬盘；<li>硬盘：属于磁盘的一种，采用 温彻斯特式结构；</ul><li>发展不同<ul><li>磁盘：软盘已经被淘汰，磁盘也正在被固态硬盘所取代；<li>硬盘：发展成 固态硬盘与机械硬盘相结合；</ul></ul><h2 id=1-2、硬盘分类><a class=headerlink href=#1-2、硬盘分类 title=1.2、硬盘分类></a>1.2、硬盘分类</h2><h3 id=1-2-1、原理划分><a class=headerlink href=#1-2-1、原理划分 title=1.2.1、原理划分></a>1.2.1、原理划分</h3><p>按原理可将硬盘类型分为以下几种：<ul><li>机械硬盘（Hard Disk Drive，HDD）<li>固态硬盘（Solid State Disk，SSD）<li>固态混合硬盘（Solid State Hybrid Driver，SSHD）</ul><h4 id=1-2-1-1、机械硬盘（HDD）><a class=headerlink href=#1-2-1-1、机械硬盘（HDD） title=1.2.1.1、机械硬盘（HDD）></a>1.2.1.1、机械硬盘（HDD）</h4><p><strong>机械硬盘 是 传统硬盘，是电脑主要存储媒介之一。</strong>由一个或者多个铝制或玻璃制成的磁性碟片、磁头、转轴、控制电机、磁头控制器、数据转换器、接口和缓存等几个部分组成。机械硬盘 是集精密机械、微电子电路、电磁转换为一体 的电脑存储设备。<p>机械硬盘工作时，磁头悬浮在高速旋转的碟片上进行读写数据。<p>机械硬盘物理结构 如下图所示：<p><img alt=机械磁盘（HDD）物理结构02 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E6%9C%BA%E6%A2%B0%E7%A3%81%E7%9B%98%EF%BC%88HDD%EF%BC%89%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%8402.jpg?token=AIGEF3MH47FDUXPTESS2I3TEZZLSE><h4 id=1-2-1-2、固态硬盘（SSD）><a class=headerlink href=#1-2-1-2、固态硬盘（SSD） title=1.2.1.2、固态硬盘（SSD）></a>1.2.1.2、固态硬盘（SSD）</h4><p><strong>固态硬盘是由多个 闪存芯片、主控、缓存 组成的阵列存储，属于以 固态电子存储芯片阵列 制成的硬盘。</strong>相对机械硬盘，读取速度更快，寻道时间更少，可加快操作系统启动速度和软件启动速度。<p>固态硬盘物理结构 如下图所示：<p><img alt=固态硬盘（SSD）物理结构02 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%EF%BC%88SSD%EF%BC%89%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%8402.jpg?token=AIGEF3KSQDXRITM43CFV4B3EZZLV2><h4 id=1-2-1-3、混合硬盘（SSHD）><a class=headerlink href=#1-2-1-3、混合硬盘（SSHD） title=1.2.1.3、混合硬盘（SSHD）></a>1.2.1.3、混合硬盘（SSHD）</h4><p><strong>混合硬盘是 机械硬盘 与 固态硬盘 的结合体，采用 容量较小的闪存颗粒 来存储常用文件。</strong>磁盘是重要的存储介质，闪存仅起到了缓冲作用，将更多的常用文件保存到闪存内减小寻道时间，从而提升效率。<p>混合硬盘物理结构 如下图所示：<p><img alt=混合硬盘（SSHD）物理结构02 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E6%B7%B7%E5%90%88%E7%A1%AC%E7%9B%98%EF%BC%88SSHD%EF%BC%89%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%8402.jpg?token=AIGEF3KDVWN32JGEBFOYCX3EZZMLA><h3 id=1-2-2、接口划分><a class=headerlink href=#1-2-2、接口划分 title=1.2.2、接口划分></a>1.2.2、接口划分</h3><p>按接口可将硬盘类型分为以下几种：<ul><li>IDE：井口；<li>SATA：串口；<li>SCSI：SCSI 全称是 Small Computer System Interface，即 小型计算机系统接口；<li>SAS：SAS 全称是 Serial Attached SCSI，即 串行连接SCSI，是新一代SCSI技术<li>FC：光纤通道；</ul><h4 id=1-2-2-1、IDE><a class=headerlink href=#1-2-2-1、IDE title=1.2.2.1、IDE></a>1.2.2.1、IDE</h4><p>IDE 全称是 Integrated Drive Electronics，<strong>是指 控制器与盘体集成在一起的硬盘驱动器，是一种硬盘传输接口</strong>。另一种叫法是ATA，全称是 Advanced Technology Attachment，即相同的东西。<p><img alt=IDE src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/IDE.jpg?token=AIGEF3OXSS5DIDUQXPD2J73EZZMNQ><h4 id=1-2-2-2、SATA><a class=headerlink href=#1-2-2-2、SATA title=1.2.2.2、SATA></a>1.2.2.2、SATA</h4><p>SATA 全称是 Serial ATA，<strong>SATA口硬盘又叫串口硬盘，SATA以它串行的数据发送方式而得名</strong>。在数据传输过程中，数据线和信号线独立使用，并且传输的时钟频率保持独立，因此同PATA相比，SATA传输速率 可以 达到并行的30倍。可以说：SATA技术并非是PATA技术的改进，而是一种全新的总线架构。<p><img alt=SATA src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/SATA.jpg?token=AIGEF3MGUPQZDDSOLBEV4XLEZZMO6><h4 id=1-2-2-3、SCSI><a class=headerlink href=#1-2-2-3、SCSI title=1.2.2.3、SCSI></a>1.2.2.3、SCSI</h4><p>SCSI 全称是 Small Computer System Interface，它的出现<strong>主要是为了解决 IDE接口硬盘 转速太慢，传输速率太低 的问题</strong>。其实SCSI并不是专为硬盘设计，实际上它是一种【总线型接口】，独立于系统总线工作。<p><img alt=image-20230805091954853 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805091954853.png?token=AIGEF3MHJD7EHIGM5O5G4XDEZZMQ6><h4 id=1-2-2-4、SAS><a class=headerlink href=#1-2-2-4、SAS title=1.2.2.4、SAS></a>1.2.2.4、SAS</h4><p>SAS（Serial Attached SCSI）<strong>意为 串行连接SCSI，是新一代SCSI技术</strong>。与Serial ATA（SATA）硬盘相同，同样采用串行技术来获得更高的传输速度，并通过缩短连结线改善内部空间等。SAS是 并行SCSI接口 之后开发出的全新接口。其目的是改善存储系统的效能、可用性和扩充性，并且提升与SATA硬盘的兼容性。<p><strong>SAS接口技术可向下兼容SATA。具体来说，二者的兼容性主要体现在 物理层和协议层 的兼容。</strong><p><img alt=SAS src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/SAS.jpg?token=AIGEF3JMKUGI4VEYDTP2GELEZZMSK><h4 id=1-2-2-5、FC><a class=headerlink href=#1-2-2-5、FC title=1.2.2.5、FC></a>1.2.2.5、FC</h4><p>光纤通道的英文拼写是Fibre Channel，与SCIS接口一样，<strong>光纤通道最初是专门为网络系统设计</strong>，而并非是为磁盘设计。<strong>但随着存储系统对速度的需求和要求越来越高，后来才逐渐应用到硬盘系统中</strong>。<p>光纤通道硬盘 是为提高 多硬盘存储系统 速度和灵活性 而开发，它大大提高了多硬盘系统的通信速度。它以点对点(或是交换)的配置方式在系统之间采用了光缆连接。<p><font color=red>注意：硬盘本身不具备FC接口，而插硬盘的机柜上会带有FC接口，通过光纤与光纤交换机互联。</font><h1 id=2、硬盘结构><a class=headerlink href=#2、硬盘结构 title=2、硬盘结构></a>2、硬盘结构</h1><h2 id=2-1、机械硬盘><a class=headerlink href=#2-1、机械硬盘 title=2.1、机械硬盘></a>2.1、机械硬盘</h2><p>机械硬盘结构 主要由盘片、磁头、磁道、扇区、柱面等更部件组成。<h3 id=2-1-1、盘片与磁头><a class=headerlink href=#2-1-1、盘片与磁头 title=2.1.1、盘片与磁头></a>2.1.1、盘片与磁头</h3><p>硬盘一般会由多个盘片组成，每个盘片都有上下两个面，每个面都有一个读/写磁头。受到硬盘整体体积和生产成本的限制，<strong>盘片数量一般限制在5片以内</strong>。<p><strong>盘片的编号自下向上从0递增</strong>，例如 最下边的盘片有0面和1面，那么相邻的上一个盘片就是2面和3面，其它同理。<p>硬盘整体结构 如下图所示：<p><img alt=硬盘与整体结构 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E7%A1%AC%E7%9B%98%E4%B8%8E%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.jpg?token=AIGEF3MEJ4E262VSTOBQ27LEZZMUE><h3 id=2-1-2、扇区与磁道><a class=headerlink href=#2-1-2、扇区与磁道 title=2.1.2、扇区与磁道></a>2.1.2、扇区与磁道</h3><p>以下图为例，该图是一个盘面。盘面中一圈圈灰色同心圆就是 磁道。从圆心向外画直线，可以将磁道划分为若干个弧段，每个磁道上的一个弧段就是一个扇区（绿色填充部分）。<strong>扇区是磁盘的最小组成单元，通常是512字节。</strong>（如今由于磁盘容量越来越大，故每个扇区大小提高至4096字节）。<p>扇区与磁道 结构图 如下所示：<p><img alt=磁盘盘面结构图02 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E7%A3%81%E7%9B%98%E7%9B%98%E9%9D%A2%E7%BB%93%E6%9E%84%E5%9B%BE02.png?token=AIGEF3P4INJI6MLXKYMIUYTEZZMV4><h3 id=2-1-3、磁头和柱面><a class=headerlink href=#2-1-3、磁头和柱面 title=2.1.3、磁头和柱面></a>2.1.3、磁头和柱面</h3><p>硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。磁盘的柱面数与一个盘面上的磁道数是相等的。由于每个盘面都有自己的磁头，因此，盘面数 = 磁头总数。<p>磁盘与柱面 结构图 如下所示：<p><img alt=磁盘与柱面 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E7%A3%81%E7%9B%98%E4%B8%8E%E6%9F%B1%E9%9D%A2.jpg?token=AIGEF3MPEFYJXNZJKCV54DDEZZMXO><h3 id=2-1-4、磁盘容量计算><a class=headerlink href=#2-1-4、磁盘容量计算 title=2.1.4、磁盘容量计算></a>2.1.4、磁盘容量计算</h3><h4 id=2-1-4-1、计算公式><a class=headerlink href=#2-1-4-1、计算公式 title=2.1.4.1、计算公式></a>2.1.4.1、计算公式</h4><p>磁盘存储容量 可通过 如下公式 计算获得：<br>$$<br>磁盘存储容量 = 磁头数量 * 磁道(柱面)数量 * 每个磁道扇区数量 * 每个扇区字节数;<br>$$<h4 id=2-1-4-2、计算示例><a class=headerlink href=#2-1-4-2、计算示例 title=2.1.4.2、计算示例></a>2.1.4.2、计算示例</h4><p>环境：磁盘DISKA有 3个盘片、6个磁头、7个柱面，每个磁道有 12个扇区，每个扇区512字节。<p>磁盘DISKA的存储容量计算如下：<br>$$<br>DISKA存储容量 = 6 * 7 * 12 * 512 = 258048字节;<br>$$<h3 id=2-1-5、磁盘读取时间><a class=headerlink href=#2-1-5、磁盘读取时间 title=2.1.5、磁盘读取时间></a>2.1.5、磁盘读取时间</h3><p>磁盘读取涉及以下几个时间：<ul><li><p>寻道时间</p> <p>磁头从最初位置 移动到 数据所在位置所消耗的时间 称为 寻道时间。目前寻道时间一般在3－15ms之间。</p><li><p>旋转延迟</p> <p>将 请求盘片扇区中的数据 移动到 读写磁头下方 所消耗的时间 称为 旋转延迟。旋转延迟取决于磁盘转速，磁盘转速一般在5000rpm - 7200rpm之间。</p><li><p>数据传输时间</p> <p>传输完请求数据 所消耗的时间 称为 数据传输时间。</p></ul><p><strong>为提高磁盘传输效率，软件应着重考虑减少 寻道时间 和 延迟时间。</strong><h2 id=2-2、固态硬盘><a class=headerlink href=#2-2、固态硬盘 title=2.2、固态硬盘></a>2.2、固态硬盘</h2><h2 id=2-3、混合硬盘><a class=headerlink href=#2-3、混合硬盘 title=2.3、混合硬盘></a>2.3、混合硬盘</h2><h1 id=3、文件系统><a class=headerlink href=#3、文件系统 title=3、文件系统></a>3、文件系统</h1><h2 id=3-1、文件系统简介><a class=headerlink href=#3-1、文件系统简介 title=3.1、文件系统简介></a>3.1、文件系统简介</h2><h2 id=3-2、文件系统分类><a class=headerlink href=#3-2、文件系统分类 title=3.2、文件系统分类></a>3.2、文件系统分类</h2><h2 id=3-3、块与族><a class=headerlink href=#3-3、块与族 title=3.3、块与族></a>3.3、块与族</h2><h3 id=3-3-1、块><a class=headerlink href=#3-3-1、块 title=3.3.1、块></a>3.3.1、块</h3><p>扇区容量少且数量多，导致寻址较长，所以将 相邻的扇区组合在一起组成一个块，并以块为单位来执行相关操作。<p>Linux下，如Ext4等文件系统中称为块（block）。 操作系统与磁盘打交道的最小单位是磁盘块。<p>3.3.2、族<p>Windows下，如NTFS等文件系统中称为簇。每个簇或者块可以包括2、4、8、16、32、64…2的n次方个扇区。<h2 id=3-4、Page页><a class=headerlink href=#3-4、Page页 title=3.4、Page页></a>3.4、Page页</h2><h3 id=3-4-1、概述><a class=headerlink href=#3-4-1、概述 title=3.4.1、概述></a>3.4.1、概述</h3><p>操作系统常与内存和硬盘打交道，故以“页”为单位的内存操作模式就出现了。<p><strong>注意：内存操作最小单位是“页”，硬盘操作最小单位是“块”。</strong><h2 id=3-5、总结><a class=headerlink href=#3-5、总结 title=3.5、总结></a>3.5、总结</h2><h3 id=3-5-1、扇区、块-族、Page页之间的关系><a class=headerlink href=#3-5-1、扇区、块-族、Page页之间的关系 title=3.5.1、扇区、块/族、Page页之间的关系></a>3.5.1、扇区、块/族、Page页之间的关系</h3><ul><li>扇区：硬盘读写 最小单位；<li>块/族：操作系统 读写磁盘 的最小单位；<li>Page：操作系统 读写内存 的最小单位；</ul></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Zookeeper%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Zookeeper%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/ itemprop=url>Zookeeper系列-Zookeeper基础应用</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 17:38:21" datetime=2023-10-02T17:38:21+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Zookeeper/ itemprop=url rel=index><span itemprop=name>Zookeeper</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、概述><a class=headerlink href=#1、概述 title=1、概述></a>1、概述</h1><h2 id=1-1、何为Zookeeper><a class=headerlink href=#1-1、何为Zookeeper title=1.1、何为Zookeeper></a>1.1、何为Zookeeper</h2><p>官方文档解释：<strong>Zookeeper是一个分布式服务框架，是Apache Hadoop 的一个子项目，主要用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项管理等。</strong><p>简单来说，zookeeper = 文件系统 + 监听通知机制。<h2 id=1-2、使用场景><a class=headerlink href=#1-2、使用场景 title=1.2、使用场景></a>1.2、使用场景</h2><p><strong>zookeeper可实现 分布式应用配置管理、统一命名服务、状态同步服务、集群管理等功能。</strong><p>分布式系统中配置信息放入zookeeper中，所有系统都从zookeeper中读取配置信息。当配置信息修改后，<strong>通过 监听触发机制 通知每一个系统 重新读取最新配置。</strong><h2 id=1-3、文件系统架构><a class=headerlink href=#1-3、文件系统架构 title=1.3、文件系统架构></a>1.3、文件系统架构</h2><p>一个Zookeeper内部由一个根目录和多个子目录组成。每个子目录称为 znode，可以自由增加、删除znode，也可在znode中存储数据。<p>znode有四种类型：<ol><li><p><strong>PERSISTENT - 持久化目录节点</strong></p> <p>客户端与zookeeper断开连接后，该节点依旧存在。</p> <p>创建 持久目录节点 命令：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>create /tmp_zk01 data01</span><br></pre></table></figure><li><p><strong>PERSISTENT_SEQUENTIAL - 持久化 顺序编号 目录节点</strong></p> <p>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号。</p> <p>创建 持久顺序目录节点 命令：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>create -s /tmp_zk01 data01 1</span><br></pre></table></figure> <ul><li>-s：SEQUENTIAL的简写，代表顺序节点。</ul><li><p><strong>EPHEMERAL-临时目录节点</strong></p> <p>客户端与zookeeper断开连接后，该节点被删除。</p> <p>创建 临时目录节点 命令：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>create -e /tmp_zk01 data01</span><br></pre></table></figure> <ul><li>-e：EPHEMERAL的简写，代表临时节点。</ul><li><p><strong>EPHEMERAL_SEQUENTIAL-临时 顺序编号 目录节点</strong></p> <p>客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号。</p> <p>创建 临时顺序目录节点 命令：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>create -e -s /tmp_zk01 data01</span><br></pre></table></figure></ol><blockquote><p>顺序节点：创建znode时设置顺序标识，znode名称后会附加一个顺序号，顺序号是一个单调递增的计数器，由父节点维护。</blockquote><h2 id=1-4、监听通知机制><a class=headerlink href=#1-4、监听通知机制 title=1.4、监听通知机制></a>1.4、监听通知机制</h2><h3 id=1-4-1、监听机制简介><a class=headerlink href=#1-4-1、监听机制简介 title=1.4.1、监听机制简介></a>1.4.1、监听机制简介</h3><p>Watcher 监听机制是 Zookeeper 中非常重要的特性，节点可以绑定监听事件，比如可以监听<strong>节点数据变更、节点删除、子节点状态变更</strong>等事件，<strong>通过事件机制可以实现分布式锁、集群管理等功能。</strong><h3 id=1-4-2、watcher特性><a class=headerlink href=#1-4-2、watcher特性 title=1.4.2、watcher特性></a>1.4.2、watcher特性</h3><p><strong>当数据发生变化时会触发一个 watcher 事件 并通知客户端。但客户端只会收到一次通知，后续同一节点再次发生变化时客户端将不会再收到消息。不过可以通过循环监听 来达到 永久监听效果。</strong><h3 id=1-4-3、注册事件机制><a class=headerlink href=#1-4-3、注册事件机制 title=1.4.3、注册事件机制></a>1.4.3、注册事件机制</h3><p>ZooKeeper 的 Watcher 机制可分为三个过程：<ol><li>客户端注册 Watcher；<li>服务器处理 Watcher；<li>客户端回调 Watcher；</ol><p>注册 watcher 有 3 种方式：<ol><li><strong>getData</strong><li><strong>exists</strong><li><strong>getChildren</strong></ol><h3 id=1-4-4、watcher事件类型><a class=headerlink href=#1-4-4、watcher事件类型 title=1.4.4、watcher事件类型></a>1.4.4、watcher事件类型</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>None (-<span class=number>1</span>), 				  <span class=comment>// 客户端连接状态发生变化的时候 会收到none事件</span></span><br><span class=line>NodeCreated (<span class=number>1</span>), 		  <span class=comment>// 节点创建事件</span></span><br><span class=line>NodeDeleted (<span class=number>2</span>), 		  <span class=comment>// 节点删除事件</span></span><br><span class=line>NodeDataChanged (<span class=number>3</span>), 	   <span class=comment>// 节点数据变化</span></span><br><span class=line>NodeChildrenChanged (<span class=number>4</span>);   <span class=comment>// 子节点被创建，删除触发该事件</span></span><br></pre></table></figure><h1 id=3、Zookeeper单机安装><a class=headerlink href=#3、Zookeeper单机安装 title=3、Zookeeper单机安装></a>3、Zookeeper单机安装</h1><h2 id=3-1、zookeeper启动><a class=headerlink href=#3-1、zookeeper启动 title=3.1、zookeeper启动></a>3.1、zookeeper启动</h2><p>1、配置Java环境。<p>2、安装zookeeper。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># cd /usr/local</span></span><br><span class=line><span class=comment># wget http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz</span></span><br><span class=line><span class=comment># tar -zxvf zookeeper-3.4.12.tar.gz</span></span><br><span class=line><span class=comment># cd zookeeper-3.4.12</span></span><br></pre></table></figure><p>3、重命名配置文件zoo_sample.cfg。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=comment># cp conf/zoo_sample.cfg conf/zoo.cfg</span></span><br></pre></table></figure><p>4、启动zookeeper。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=comment># bin/zkServer.sh start</span></span><br></pre></table></figure><p>5、检测是否成功启动，用zookeeper客户端连接服务端。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=comment># bin/zkCli.sh</span></span><br></pre></table></figure><h2 id=3-2、zookeeper使用><a class=headerlink href=#3-2、zookeeper使用 title=3.2、zookeeper使用></a>3.2、zookeeper使用</h2><h3 id=3-2-1、客户端命令操作><a class=headerlink href=#3-2-1、客户端命令操作 title=3.2.1、客户端命令操作></a>3.2.1、客户端命令操作</h3><h4 id=3-2-1-1、ls命令><a class=headerlink href=#3-2-1-1、ls命令 title=3.2.1.1、ls命令></a>3.2.1.1、ls命令</h4><p>作用：查看某个路径下目录列表。<p>命令格式如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>ls</span> path</span><br></pre></table></figure><p>path代表路径，查看/runoob节点示例：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>ls</span> /runoob</span><br></pre></table></figure><h4 id=3-2-1-2、ls2命令><a class=headerlink href=#3-2-1-2、ls2命令 title=3.2.1.2、ls2命令></a>3.2.1.2、ls2命令</h4><p>作用：查看某个路径下的目录列表，它比ls命令列出更多信息。用法和<code>ls</code>命令相同。<h4 id=3-2-1-3、get命令><a class=headerlink href=#3-2-1-3、get命令 title=3.2.1.3、get命令></a>3.2.1.3、get命令</h4><p>作用：获取节点数据和状态信息。<p>命令格式及示例如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># 格式：</span></span><br><span class=line>get path [watch]</span><br><span class=line><span class=comment># 示例：</span></span><br><span class=line>get /runoob watch</span><br></pre></table></figure><ul><li>path：代表路径。<li>watch：对节点进行事件监听。</ul><h4 id=3-2-1-4、stat命令><a class=headerlink href=#3-2-1-4、stat命令 title=3.2.1.4、stat命令></a>3.2.1.4、stat命令</h4><p>作用：查看节点状态信息。<p>命令格式及示例如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># 格式：</span></span><br><span class=line><span class=built_in>stat</span> path [watch]</span><br><span class=line><span class=comment># 示例：</span></span><br><span class=line><span class=built_in>stat</span> /runoob</span><br></pre></table></figure><ul><li>path：代表路径。<li>watch：对节点进行事件监听。</ul><h4 id=3-2-1-5、create命令><a class=headerlink href=#3-2-1-5、create命令 title=3.2.1.5、create命令></a>3.2.1.5、create命令</h4><p>作用：创建节点并赋值。<p>命令格式及示例如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># 格式</span></span><br><span class=line>create [-s] [-e] path data acl</span><br><span class=line><span class=comment># 示例（添加临时顺序节点）</span></span><br><span class=line>create -s -e /runoob 0</span><br></pre></table></figure><ul><li>[-s] [-e]：两者都是可选项。-s代表顺序节点，-e代表临时节点，两者可同时使用，并且临时节点不能创建子节点。<li>path：指定要创建节点的路径。<li>data：要在此节点存储的数据。<li>acl：访问权限相关，默认是world，相当于全世界都能访问。</ul><h4 id=3-2-1-6、set命令><a class=headerlink href=#3-2-1-6、set命令 title=3.2.1.6、set命令></a>3.2.1.6、set命令</h4><p>作用：修改节点数据。<p>命令格式及示例如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment># 格式</span></span><br><span class=line><span class=built_in>set</span> path data [version]</span><br><span class=line><span class=comment># 示例（只有正确的版本号才能设置成功）</span></span><br><span class=line><span class=built_in>set</span> /runoob 0 1</span><br><span class=line><span class=built_in>set</span> /runoob 0 2</span><br><span class=line><span class=built_in>set</span> /runoob 0 10</span><br><span class=line><span class=built_in>set</span> /runoob 0 6</span><br></pre></table></figure><ul><li>path：节点路径。<li>data：要存储的数据。<li>[version]：可选项，版本号（可用于乐观锁）。</ul><h4 id=3-2-1-7、delete命令><a class=headerlink href=#3-2-1-7、delete命令 title=3.2.1.7、delete命令></a>3.2.1.7、delete命令</h4><p>作用：删除某节点。<p>命令格式及示例如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment># 格式</span></span><br><span class=line>delete path [version]</span><br><span class=line><span class=comment># 示例</span></span><br><span class=line><span class=built_in>ls</span> /runoob</span><br><span class=line>delete /runoob/child</span><br><span class=line>get /runoob/child</span><br></pre></table></figure><ul><li>path：节点路径。<li>[version]：可选项，版本号（同set命令）。</ul><h3 id=3-2-2、Java操作><a class=headerlink href=#3-2-2、Java操作 title=3.2.2、Java操作></a>3.2.2、Java操作</h3><p>1、加入Maven依赖<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>   <span class=tag><<span class=name>groupId</span>></span>org.apache.zookeeper<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>   <span class=tag><<span class=name>artifactId</span>></span>zookeeper<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>   <span class=tag><<span class=name>version</span>></span>3.4.12<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><p>2、添加一个目录节点<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>create /test demo01</span><br></pre></table></figure><p>3、启动两个zookeeper客户端程序<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.CountDownLatch;</span><br><span class=line><span class=keyword>import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class=line><span class=keyword>import</span> org.apache.zookeeper.Watcher;</span><br><span class=line><span class=keyword>import</span> org.apache.zookeeper.Watcher.Event.EventType;</span><br><span class=line><span class=keyword>import</span> org.apache.zookeeper.Watcher.Event.KeeperState;</span><br><span class=line><span class=keyword>import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class=line><span class=keyword>import</span> org.apache.zookeeper.data.Stat;</span><br><span class=line> </span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ZooKeeperProSync</span> <span class=keyword>implements</span> <span class="title class_">Watcher</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>CountDownLatch</span> <span class=variable>connectedSemaphore</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">CountDownLatch</span>(<span class=number>1</span>);</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>ZooKeeper</span> <span class=variable>zk</span> <span class=operator>=</span> <span class=literal>null</span>;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>Stat</span> <span class=variable>stat</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Stat</span>();</span><br><span class=line> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=comment>//zookeeper配置数据存放路径</span></span><br><span class=line>        <span class=type>String</span> <span class=variable>path</span> <span class=operator>=</span> <span class=string>"/username"</span>;</span><br><span class=line>        <span class=comment>//连接zookeeper并且注册一个默认的监听器</span></span><br><span class=line>        zk = <span class=keyword>new</span> <span class="title class_">ZooKeeper</span>(<span class=string>"192.168.31.100:2181"</span>, <span class=number>5000</span>, <span class=comment>//</span></span><br><span class=line>                <span class=keyword>new</span> <span class="title class_">ZooKeeperProSync</span>());</span><br><span class=line>        <span class=comment>//等待zk连接成功的通知</span></span><br><span class=line>        connectedSemaphore.await();</span><br><span class=line>        <span class=comment>//获取path目录节点的配置数据，并注册默认的监听器</span></span><br><span class=line>        System.out.println(<span class=keyword>new</span> <span class="title class_">String</span>(zk.getData(path, <span class=literal>true</span>, stat)));</span><br><span class=line> </span><br><span class=line>        Thread.sleep(Integer.MAX_VALUE);</span><br><span class=line>    }</span><br><span class=line> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">process</span><span class=params>(WatchedEvent event)</span> {</span><br><span class=line>        <span class=keyword>if</span> (KeeperState.SyncConnected == event.getState()) {  <span class=comment>//zk连接成功通知事件</span></span><br><span class=line>            <span class=keyword>if</span> (EventType.None == event.getType() && <span class=literal>null</span> == event.getPath()) {</span><br><span class=line>                connectedSemaphore.countDown();</span><br><span class=line>            } <span class=keyword>else</span> <span class=keyword>if</span> (event.getType() == EventType.NodeDataChanged) {  <span class=comment>//zk目录节点数据变化通知事件</span></span><br><span class=line>                <span class=keyword>try</span> {</span><br><span class=line>                    System.out.println(<span class=string>"配置已修改，新值为："</span> + <span class=keyword>new</span> <span class="title class_">String</span>(zk.getData(event.getPath(), <span class=literal>true</span>, stat)));</span><br><span class=line>                } <span class=keyword>catch</span> (Exception e) {</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>两个程序启动后都读到了<code>/test</code>目录节点下的数据<code>demo01</code>。<p>4、修改test节点下的数据。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>set</span> /test demo02</span><br></pre></table></figure><p>修改完成后，我们看见两个程序后台都及时收到了他们监听的目录节点数据变更后的值。<h1 id=4、数据类型><a class=headerlink href=#4、数据类型 title=4、数据类型></a>4、数据类型</h1><h2 id=4-1、数据结构><a class=headerlink href=#4-1、数据结构 title=4.1、数据结构></a>4.1、数据结构</h2><p><strong>zookeeper以 key/value 形式存储数据。</strong>整体结构类似于linux文件系统的模式以树形结构存储。其中根路径以<code>/</code>开头。<h2 id=4-2、znode状态属性><a class=headerlink href=#4-2、znode状态属性 title=4.2、znode状态属性></a>4.2、znode状态属性</h2><ol><li><font color=orange>ctime</font>：创建节点的时间。<li><font color=orange>mZxid</font>：最后修改节点时的事务ID。<li><font color=orange>mtime</font>：最后修改节点时的时间。<li><font color=orange>pZxid</font>：鄙视该节点的子节点列表最后以此修改的事务ID，添加子节点或删除子节点就会影响子节点列表，但是修改子节点的数据内容则不影响ID（注意，只有子节点列表变更了才会变更pzxid，子节点内容变更不会影响paxid）。<li><font color=orange>cversion</font>：子节点版本号，子节点每次修改时该版本号加1。<li><font color=orange>dataversion</font>：数据版本号，数据每次修改时该版本号加1，<li><font color=orange>aclversion</font>：权限版本号，权限每次修改时该版本号加1。<li><font color=orange>ephemeralOwner</font>：创建该临时节点的会话的sessionID。（如果该节点为持久节点，那么这个属性值为0。）<li><font color=orange>dataLength</font>：节点数据长度。<li><font color=orange>numChildren</font>：该节点拥有子节点数量。（只统计第一级子节点的数量）</ol><h1 id=5、zookeeper-session><a title="5、zookeeper session" class=headerlink href=#5、zookeeper-session></a>5、zookeeper session</h1><p><strong>客户端与服务端之间的连接是基于 TCP长连接，默认端口2181。第一次连接建立后，每个会话都可设置超时时间。</strong><h2 id=5-1、Session创建><a class=headerlink href=#5-1、Session创建 title=5.1、Session创建></a>5.1、Session创建</h2><ul><li><p>sessionID</p> <p>会话ID，用来唯一标识一个会话，每次客户端创建会话时，zookeeper都会为其分配一个全局唯一的sessionID。zookeeper创建sessionID类SessionTrackerImpl中的源码。</p><li><p>Timeout</p> <p>会话超时时间。客户端在构造Zookeeper实例时，向服务端发送配置的超时时间，server端会根据自己的超时时间限制最终确认会话的超时时间。</p><li><p>TickTime</p> <p>下次会话超时时间点，默认2000毫秒。可在zoo.cfg配置文件中进行配置，便于server端对session会话实行分桶策略管理。</p><li><p>isClosing</p> <p>该属性标记一个会话是否已经被关闭，当server端检测到会话已经超时失效，该会话标记为“已关闭”，不再处理该会话的新请求。</p></ul><h2 id=5-2、Session状态><a class=headerlink href=#5-2、Session状态 title=5.2、Session状态></a>5.2、Session状态</h2><ul><li><p>connecting</p> <p>连接中，session一旦建立，状态就是connecting状态，时间短。</p><li><p>connected</p> <p>已连接，连接成功之后的状态。</p><li><p>closed</p> <p>已关闭，session过期，因 网络故障 客户端重连失败，服务器宕机 或 客户端主动断开。</p></ul><h2 id=5-3、会话超时管理><a class=headerlink href=#5-3、会话超时管理 title=5.3、会话超时管理></a>5.3、会话超时管理</h2><p>zookeeper的 leader服务器 在运行期间会定时执行会话超时检查，时间间隔是<code>ExpirationInterval</code>，单位是毫秒，默认值为<code>tickTime</code>，每隔<code>tickTime</code>进行一次会话超时检查。<p><code>ExpirationTime</code>计算方式：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>ExpirationTime</span> = <span class=string>CurrentTime + SessionTimeout;</span></span><br><span class=line><span class=attr>ExpirationTime</span> = <span class=string>(ExpirationTime / ExpirationInterval + 1) * ExpirationInterval;</span></span><br></pre></table></figure><p>客户端在会话超时前向服务器发送请求来完成 会话激活，进而保持会话有效性。<h1 id=6、Zookeeper四字命令><a class=headerlink href=#6、Zookeeper四字命令 title=6、Zookeeper四字命令></a>6、Zookeeper四字命令</h1><h2 id=6-1、简介><a class=headerlink href=#6-1、简介 title=6.1、简介></a>6.1、简介</h2><p><strong>在客户端可以通过<code>telnet</code>或<code>nc（netcat）</code>向 zookeeper 提交命令。</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># centos</span></span><br><span class=line>yum install nc</span><br><span class=line><span class=comment># ubuntu</span></span><br><span class=line><span class=built_in>sudo</span> apt install netcat</span><br></pre></table></figure><p><strong>四字命令格式：</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>echo</span> [<span class=built_in>command</span>] | nc [ip] [port]</span><br></pre></table></figure><p><strong>常用四字命令如下：</strong><ol><li>conf：3.3.0版本引入，打印服务相关配置的详细信息。<li>cons：3.3.0版本引入，列出所有连接到这台服务器的客户端全部连接/会话详细信息。包括“接收/发送”的包数量、会话ID、操作延迟、最后的操作执行等信息。<li>crst：3.3.0版本引入。重置所有连接的连接和会话统计信息。<li>dump：列出那些比较重要的会话和临时节点。该命令只限于leader节点上使用。<li>envi：打印出服务环境的详细信息。<li>reqs：列出未经处理的请求。<li>ruok：测试服务是否处于正确状态。如果确实如此，那么服务返回“imok”，否则不做任何响应。<li>stat：输入关于性能和连接的客户端的列表。<li>srst：重置服务器的统计。<li>srvr：3.3.0版本引入。列出连接服务器的详细信息。<li>wchs：3.3.0版本引入。列出服务器watch的详细信息。<li>wchc：3.3.0版本引入。通过session列出服务器watch的详细信息，它的输出是一个与watch相关的会话的列表。<li>wchp：3.3.0版本引入。通过路径列出服务器watch的详细i信息。它输出一个与session相关的路径。<li>mntr：3.4.0版本引入，输出可用于检测集群健康状态的变量列表。</ol><h2 id=6-2、四字命令使用><a class=headerlink href=#6-2、四字命令使用 title=6.2、四字命令使用></a>6.2、四字命令使用</h2><h3 id=6-2-1、stat命令><a class=headerlink href=#6-2-1、stat命令 title=6.2.1、stat命令></a>6.2.1、stat命令</h3><p>查看zk状态信息。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>echo</span> <span class=built_in>stat</span> | nc 192.168.3.38 2181</span><br></pre></table></figure><h3 id=6-2-2、ruok命令><a class=headerlink href=#6-2-2、ruok命令 title=6.2.2、ruok命令></a>6.2.2、ruok命令</h3><p>查看zk是否启动，若返回imok表示正常。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>echo</span> ruok | nc 192.168.3.38 2181</span><br></pre></table></figure><h3 id=6-2-3、dump命令><a class=headerlink href=#6-2-3、dump命令 title=6.2.3、dump命令></a>6.2.3、dump命令</h3><p>列出未经处理的会话和临时节点。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>echo</span> dump | nc 192.168.3.38 2181</span><br></pre></table></figure><h3 id=6-2-4、conf命名><a class=headerlink href=#6-2-4、conf命名 title=6.2.4、conf命名></a>6.2.4、conf命名</h3><p>查看服务器配置。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>echo</span> conf | nc 192.168.3.38 2181</span><br></pre></table></figure><h3 id=6-2-5、cons命令><a class=headerlink href=#6-2-5、cons命令 title=6.2.5、cons命令></a>6.2.5、cons命令</h3><p>展示连接到服务器的客户端信息。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>echo</span> cons | nc 192.168.3.38 2181</span><br></pre></table></figure><h3 id=6-2-6、envi命令><a class=headerlink href=#6-2-6、envi命令 title=6.2.6、envi命令></a>6.2.6、envi命令</h3><p>查看环境变量。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>echo</span> envi | nc 192.168.3.38 2181</span><br></pre></table></figure><h1 id=7、Zookeeper安全管理><a class=headerlink href=#7、Zookeeper安全管理 title=7、Zookeeper安全管理></a>7、Zookeeper安全管理</h1><h2 id=7-1、安全简介><a class=headerlink href=#7-1、安全简介 title=7.1、安全简介></a>7.1、安全简介</h2><p><strong>ZooKeeper节点有5种操作权限：CREATE(增)、READ(查)、WRITE(改)、DELETE(删)、ADMIN(管理)等权限，这5种权限可以简写为crwda，每个单词的首字符拼接而成。</strong><h2 id=7-2、权限><a class=headerlink href=#7-2、权限 title=7.2、权限></a>7.2、权限</h2><p><strong>Zookeeper 权限由 scheme : id : permissions 三部分组成。</strong><p>Scheme可选项：<ul><li><strong>world</strong>：默认模式，所有客户端都拥有指定的权限。world 下只有一个 id 选项，就是 anyone，通常组合写法为 <code>world:anyone:[permissons]</code>；<li><strong>auth</strong>：只有经过认证的用户才拥有指定的权限。通常组合写法为 <code>auth:user:password:[permissons]</code>，使用这种模式时，你需要先进行登录，之后采用 auth 模式设置权限时，<code>user</code> 和 <code>password</code> 都将使用登录的用户名和密码；<li><strong>digest</strong>：只有经过认证的用户才拥有指定的权限。通常组合写法为 <code>auth:user:BASE64(SHA1(password)):[permissons]</code>，这种形式下的密码必须通过 SHA1 和 BASE64 进行双重加密；<li><strong>ip</strong>：限制只有特定 IP 的客户端才拥有指定的权限。通常组成写法为 <code>ip:182.168.0.168:[permissions]</code>；<li><strong>super</strong>：代表超级管理员，拥有所有的权限，需要修改 Zookeeper 启动脚本进行配置。</ul><p>Permissions可选项：<ul><li><strong>CREATE</strong>：允许创建子节点；<li><strong>READ</strong>：允许从节点获取数据并列出其子节点；<li><strong>WRITE</strong>：允许为节点设置数据；<li><strong>DELETE</strong>：允许删除子节点；<li><strong>ADMIN</strong>：允许为节点设置权限。</ul><h2 id=7-3、授权><a class=headerlink href=#7-3、授权 title=7.3、授权></a>7.3、授权</h2><h3 id=7-3-1、授权流程><a class=headerlink href=#7-3-1、授权流程 title=7.3.1、授权流程></a>7.3.1、授权流程</h3><p>操作流程分析如下：<p>1）添加授权用户。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>addauth digest smile:123456</span><br></pre></table></figure><p>2）创建节点。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>create /cicada cicada</span><br></pre></table></figure><p>3）节点授权。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>setAcl /cicada auth:smile:123456:cdrwa</span><br></pre></table></figure><p>4）查看授权。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>getAcl /cicada</span><br></pre></table></figure><h1 id=8、Zookeeper事件监听><a class=headerlink href=#8、Zookeeper事件监听 title=8、Zookeeper事件监听></a>8、Zookeeper事件监听</h1><h2 id=8-1、简介><a class=headerlink href=#8-1、简介 title=8.1、简介></a>8.1、简介</h2><p><strong>接口类<code>Watcher</code>表示一个事件处理器，定义了事件通知相关逻辑，包含<code>KeeperState</code>和<code>EventType</code>两个枚举类。</strong><p>Watcher接口定义了事件回调方法 <code>process(WatchedEvent event)</code>。定义一个Watcher实例很简单，代码如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=type>Watcher</span> <span class=variable>w</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Watcher</span>() {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">process</span><span class=params>(WatchedEvent watchedEvent)</span> {</span><br><span class=line>        log.info(<span class=string>"监听器watchedEvent："</span> + watchedEvent);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>使用Watcher监听器很简单，在Curator调用链上使用<code>usingWatcher</code>方法即可，代码如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>byte</span>[] content = client.getData().usingWatcher(w).forPath(workerPath);</span><br></pre></table></figure><h2 id=8-2、事件触发监听><a class=headerlink href=#8-2、事件触发监听 title=8.2、事件触发监听></a>8.2、事件触发监听</h2><h3 id=8-2-1、事件触发><a class=headerlink href=#8-2-1、事件触发 title=8.2.1、事件触发></a>8.2.1、事件触发</h3><h4 id=8-2-1-1、事件类型><a class=headerlink href=#8-2-1-1、事件类型 title=8.2.1.1、事件类型></a>8.2.1.1、事件类型</h4><ul><li>节点创建（NodeCreated）<li>节点删除（NodeDeleted）<li>节点数据变化（NodeDateChanged）<li>子节点变化（NodeChildrenChanged）</ul><h4 id=8-2-1-2、监听事件><a class=headerlink href=#8-2-1-2、监听事件 title=8.2.1.2、监听事件></a>8.2.1.2、监听事件</h4><p><font color=red>注意：事件监听是一次性的。</font><p>（1）监听节点创建、删除。<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=comment># 监听节点 /test，当节点 /test 创建或删除时会通知。</span></span><br><span class=line><span class=comment># java API：exists()</span></span><br><span class=line><span class=built_in>stat</span> -w /test</span><br></pre></table></figure><p>（2）监听节点数据变化<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=comment># 监听节点 /test 的数据变化，当节点 /test 的数据发生变化时会通知。</span></span><br><span class=line><span class=comment># java API：get()</span></span><br><span class=line>get -w /test</span><br></pre></table></figure><p>（3）监听子节点变化<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=comment># 监听节点 /test 的子节点是否发生变化，当节点 /test 的子节点发生变化时会通知。</span></span><br><span class=line><span class=comment># java API：getChildren()</span></span><br><span class=line><span class=built_in>ls</span> -w /test</span><br></pre></table></figure><h3 id=8-2-2、watcher机制><a class=headerlink href=#8-2-2、watcher机制 title=8.2.2、watcher机制></a>8.2.2、watcher机制</h3><p>zookeeper 的 watcher 机制，可分为四个过程：<ol><li><p>客户端注册 watcher；客户端注册watcher有3种方式：getData、exists、getCildren。</p><li><p>服务端处理 watcher；</p><li><p>服务端触发 watcher 事件；</p><li><p>客户端回调 watcher；</p></ol><p>以exists注册方式为例，客户端注册事件并触发事件通知的流程分析如下：<ol><li><p>客户端 发送 事件通知请求；</p> <p>调用 exists 方法会把事件监听封装到 request 对象中，watch 属性设置为 true，待服务端返回 response 后把监听事件封装到客户端类<code>ZKWatchManager</code>中。</p><li><p>服务端 处理 watcher事件请求；</p> <ol><li>服务端<code>NIOServerCnxn</code>类用来处理客户端请求，最终调用<code>FinalRequestProcessor</code>。<li>在类<code>DataTree</code>方法中添加 watcher 事件，并保存至<code>WatchManager</code>的<code>watchTable</code>与<code>watchTable</code>中。</ol><li><p>服务端 触发 watcher事件；</p> <ol><li>若服务端某个被监听的节点发生事务请求，服务端处理请求时调用<code>FinalRequestProcessor</code>类<code>processRequest</code>方法。<li>删除调用链最终到 DataTree 类中删除节点分支的触发代码段。<li>进入 WatchManager 类的 triggerWatch 方法。<li>构建了一个 xid 为 -1，zxid 为 -1 的 ReplyHeader 对象，然后再调用 sendResponse 方法。</ol><li><p>客户端 回调 watcher事件；</p> <p>客户端类<code>SendThread</code>的<code>readResponse</code>方法接收服务端触发的事件通知，进入 xid 为 -1 流程，处理 Event 事件。</p></ol></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Tomcat%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Tomcat%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/ itemprop=url>Tomcat系列-Tomcat原理解析</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-03 10:24:21" datetime=2023-10-03T10:24:21+08:00 itemprop=dateModified>2023-10-03</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Tomcat/ itemprop=url rel=index><span itemprop=name>Tomcat</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、启动初始化><a class=headerlink href=#1、启动初始化 title=1、启动初始化></a>1、启动初始化</h1><p><strong>入口是Connector.start()方法，但实际调用的是父类 LifecycleBase.start() 方法</strong>。<p><strong>（1）LifecycleBase.start()</strong><p>调用Connector.startInternal()方法来处理。<p><strong>（2）Connector.startInternal()</strong><p>调用AbstractProtocol.start()方法来处理。<p><strong>（3）AbstractProtocol.start()</strong><p>调用AbstractEndpoint.start()方法来处理。<p>使用ScheduledExecutorService开启一个延迟60秒调用一次AbstractProtocol.startAsyncTimeout()方法的线程。startAsyncTimeout()方法会判断当前Socket对应的web应用是否不再使用，如果不再使用那么进行超时处理。该方法会开启一个固定速率为1s执行一次的线程，该线程会遍历所有Processor，并对那些不再使用的web应用进行超时处理。<p><strong>（4）AbstractEndpoint.start()</strong><p>如果还没有绑定ip和端口，那么执行AbstractEndpoint.bindWithCleanup()方法，在该方法中一般会调用NioEndpoint.bind()方法进行绑定处理。调用NioEndpoint.startInternal()方法来初始化开启Acceptor、Poller线程等操作。<p><strong>（5）NioEndpoint.bind()</strong><p>调用NioEndpoint.initServerSocket()方法来初始化ServerSocket，设置该ServerSocket是阻塞式的。<p>为NioEndpoint创建一个CountDownLatch(2)。<p>如果开启了Ssl功能，那么初始化Ssl并进行相关操作。默认没有开启。<p><strong>（6）NioEndpoint.startInternal()</strong><p><strong>第一步：创建 Executor，初始化线程池</strong>。线程池默认参数值如下：<ul><li>最小线程数量：10。<li>最大线程数量：200。<li>超时时间：60秒。<li>队列：使用Tomcat重写的<code>TaskQueue</code>队列，该队列实现了<code>LinkedBlockingQueue</code>。<li>线程工厂：实现Tomcat重写的<code>TaskThreadFactory</code>。线程名字前缀是<code>http-nio-9001-exec-</code>，线程工厂生产的线程是守护线程，线程优先级是5。</ul><p><strong>第二步：初始化 LimitLatch 实例，设置其最大连接数量为 8192</strong>。<p><strong>第三步：创建 Poller 线程</strong>，线程名字是 <code>http-nio-9001-Poller</code>，线程优先级为5，是守护线程，然后启动该线程。<p><strong>第四步：调用 AbstractEndpoint.startAcceptorThread() 方法开启 Acceptor 线程</strong>。创建Acceptor线程，线程名字是<code>http-nio-9001-Acceptor</code>，线程优先级为5，是守护线程，然后启动该线程。<h1 id=2、HTTP请求处理><a class=headerlink href=#2、HTTP请求处理 title=2、HTTP请求处理></a>2、HTTP请求处理</h1><p>入口是<code>NioEndPoint.Poller.run()</code>方法。<p><strong>（1）NioEndPoint.Poller.events()</strong><p>从<code>Poller</code>的阻塞队列<code>SynchronizedQueue&LTPollerEvent></code>中不断获取<code>PollerEvent</code>，拿到<code>PollerEvent</code>中的<code>NioSocketWrapper</code>，将该<code>NioSocketWrapper</code>作为附件注册到<code>Poller</code>的<code>Selector</code>上，并设置要关注【读事件】。<p>调用selec()方法获取准备就绪的Socket，然后获取其selectedKey，并拿到该selectedKey上的附件NioSocketWrapper。将key和wrapper作为参数调用Poller的processKey方法来处理。<p><strong>（2）NioEndPoint.Poller.processKey()</strong><p>processKey方法会根据读事件或写事件调用AbstractEndpint的processSocket方法来处理，且将wrapper、事件类型等作为参数传给它。<p><strong>（3）AbstractEndpint.processSocket()</strong><p>processSocket方法会将wrapper、事件类型包装成实现了Runnable接口的SocketProcessorBase，然后调用线程池Executor的execute方法来执行该封装好的SocketProcessorBase，其实就是执行SocketProcessorBase的run()方法。<p><strong>（4）SocketProcessorBase.run()</strong><p><strong>run()方法中会先调用 ReentrantLock 的 lock 方法加锁，然后调用 NioEndpoint.SocketProcessor.doRun() 方法，最后再调用 unlock 方法解锁</strong>。<p><strong>（5）NioEndpoint.SocketProcessor.doRun()</strong><p>先处理三次握手，然后将Socket事件改为OPEN_READ。接下来调用AbstractProtoccol.ConnectionHandler.Process()方法来处理。<p><strong>（6）AbstractProtoccol.ConnectionHandler.process()</strong><p>调用AbstractProcessorLight.process()方法来处理。<p><strong>（7）AbstractProcessorLight.process()</strong><p>调用Http11Processor.service(socketWrapper)<p><strong>（8）Http11Processor.service(socketWrapper)</strong><p>调用CoyoteAdapter.service(request, response)方法来处理。<p><strong>（9）CoyoteAdapter.service(request, response)</strong><p>调用StandardEngineValue.invoke(request, response)方法来处理。<p><strong>（10）StandardEngineValue.invoke(request, response)</strong><p>调用ErrorReportValue.invoke(request, response)方法来处理。<p><strong>（11）ErrorReportValue.invoke(request, response)</strong><p>调用StandardHostValue.invoke(request, response)方法来处理<p><strong>（12）StandardHostValue.invoke(request, response)</strong><p>调用NonLoginAuthenticator.invoke(request, response)方法来处理，实际调用其父类AuthenticatorBase.invoke()方法来处理。<p><strong>（13）AuthenticatorBase.invoke(request, response)</strong><p>调用StandardContextValue.invoke(request, response)方法来处理。<p><strong>（14）StandardContextValue.invoke(request, response)</strong><p>调用StandardWrapperValue.invoke()(request, response)方法来处理<p><strong>（15）StandardWrapperValue.invoke()</strong><p>调用StandardWrapperd.allocate()方法来处理。<p>调用ApplicationFilterChain.doFilter(ServletRequest, ServletResponse)方法来处理。<p><strong>（16）StandardWrapperd.allocate()</strong><p>该方法内部会调用StandardWrapperd.initServlet(Servlet servlet)来初始化Servlet，如果使用SpringMVC，那么这里的servlet就是DispatcherServlet。该方法会调用GenericServlet.init()方法来初始化，然后内部再调用HttpServletBean.init()方法来初始化，然后内部再调用FrameworkServlet.initServletBean()方法来初始化，然后内部再调用initWebApplicationContext()方法来初始化Web容器。initWebApplicationContext()方法中会调用DispatcherServlet.initStrategies()方法来初始化9大组件，然后以<code>org.springframework.web.servlet.FrameworkServlet.CONTEXT.dispatcherServlet</code>为名字，以AnnotationConfigServletWebServerApplicationContext实例为值，将该键值对放入ApplicationContextFacade的Attribute中。<p><strong>（17）ApplicationFilterChain.doFilter(ServletRequest, ServletResponse)</strong><p>形参ServletRequest, ServletResponse其实是RequestFacade, ResponseFacade。<p>调用ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse)方法来处理。<p><strong>（18）ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse)</strong><p>形参ServletRequest, ServletResponse其实是RequestFacade, ResponseFacade。<p>调用OncePerRequestFilter.doFilter(ServletRequest, ServletResponse, this)<p><strong>（19）OncePerRequestFilter.doFilter(ServletRequest, ServletResponse, this)</strong><p>形参ServletRequest, ServletResponse其实是RequestFacade, ResponseFacade，this是ApplicationFilterChain。<p>调用CharacterEncodingFilter.doFilterInternal(HttpServletRequest, HttpServletResponse, FilterChain)方法来处理。<p><strong>（20）CharacterEncodingFilter.doFilterInternal(HttpServletRequest, HttpServletResponse, FilterChain)</strong><p>形参HttpServletRequest, HttpServletResponse其实是RequestFacade, ResponseFacade，FilterChain是ApplicationFilterChain。<p>为当前request设置字符集为UTF-8。<p>调用ApplicationFilterChain.doFilter(ServletRequest, ServletResponse)方法来处理。<p><strong>（21）ApplicationFilterChain.doFilter(ServletRequest, ServletResponse)</strong><p>调用ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse)方法来处理。<p><strong>（22）ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse)</strong><p>调用WsFilter.doFilter(ServletRequest, ServletResponse, FilterChain)方法来处理<p><strong>（23）WsFilter.doFilter(ServletRequest, ServletResponse, FilterChain)</strong><p>调用ApplicationFilterChain.doFilter(ServletRequest, ServletResponse)方法来处理。<p><strong>（24）ApplicationFilterChain.doFilter(ServletRequest, ServletResponse)</strong><p>调用ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse)方法来处理。<p><strong>（25）ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse)</strong><p><em><strong>调用 HttpServlet.service(ServletRequest, ServletResponse) 方法来处理</strong></em>。<p><strong>（26）HttpServlet.service(ServletRequest, ServletResponse)</strong><p>调用FrameworkServlet.service(HttpServletRequest, HttpServletResponse)方法来处理。<p><strong>（27）FrameworkServlet.service(HttpServletRequest, HttpServletResponse)</strong><p>调用HttpServlet.service(HttpServletRequest, HttpServletResponse)方法来处理。<p><strong>（28）HttpServlet.service(HttpServletRequest, HttpServletResponse)</strong><p>调用FrameworkServlet.doXXX()方法，在方法内调用FrameworkServlet.processRequest(HttpServletRequest, HttpServletResponse)方法来处理。<p><strong>（29）FrameworkServlet.processRequest(HttpServletRequest, HttpServletResponse)</strong><p>调用DispatcherServlet.doService(HttpServletRequest, HttpServletResponse)方法来处理。<p><strong>（30）DispatcherServlet.doService(HttpServletRequest, HttpServletResponse)</strong><p>调用DispatcherServlet.doDispatch(HttpServletRequest, HttpServletResponse)方法来处理。<p><strong>（31）DispatcherServlet.doDispatch(HttpServletRequest, HttpServletResponse)</strong><p>通过HandlerExecutionChain来处理请求，详情见SpringMVC章节。</div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Vue%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E5%9F%BA%E7%A1%80%E7%AF%87/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Vue%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E5%9F%BA%E7%A1%80%E7%AF%87/ itemprop=url>前端系列-Vue使用指南</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-11-09 23:26:32" datetime=2023-11-09T23:26:32+08:00 itemprop=dateModified>2023-11-09</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Vue/ itemprop=url rel=index><span itemprop=name>Vue</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=概述><a class=headerlink href=#概述 title=概述></a>概述</h1><h2 id=Vue生命周期><a class=headerlink href=#Vue生命周期 title=Vue生命周期></a>Vue生命周期</h2><p>vue生命周期图示如下：<p><img alt=Vue生命周期图 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/11/06/lifecycle.16e4c08e.png><h1 id=环境搭建><a class=headerlink href=#环境搭建 title=环境搭建></a>环境搭建</h1><h2 id=基础工程><a class=headerlink href=#基础工程 title=基础工程></a>基础工程</h2><h3 id=搭建步骤><a class=headerlink href=#搭建步骤 title=搭建步骤></a>搭建步骤</h3><p>（1）<strong>初始化vue项目</strong>。通过命令<code>npm init vue@latest</code>可实现创建一个基础工程。<p>（2）<strong>安装依赖</strong>。通过命令<code>npm install</code>可安装能使项目运行起来的核心基础依赖。<p>（3）<strong>启动项目，访问服务</strong>。通过命令<code>npm run dev</code>可启动运行项目，启动成功后访问指定IP和端口即可实现访问项目。<h3 id=工程目录说明><a class=headerlink href=#工程目录说明 title=工程目录说明></a>工程目录说明</h3><p>刚搭建好的基础工程目录如下，其个目录定义解释如下图所示。<p><img alt=image-20231106211310902 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/11/06/image-20231106211310902.png><h1 id=基础功能><a class=headerlink href=#基础功能 title=基础功能></a>基础功能</h1><h2 id=路由><a class=headerlink href=#路由 title=路由></a>路由</h2><h3 id=前言><a class=headerlink href=#前言 title=前言></a>前言</h3><p>Vue中关于路由的实现方案有多种，这里以Vue Router为例。<h3 id=使用步骤><a class=headerlink href=#使用步骤 title=使用步骤></a>使用步骤</h3><p><strong>（1）安装vue-router</strong>。安装命令为<code>npm install vue-router@4</code>。<p><strong>（2）创建配置路由</strong><p>在src/router路径下创建index.js文件，文件内容参考如下：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> { createRouter, createWebHistory } <span class=keyword>from</span> <span class=string>'vue-router'</span></span><br><span class=line><span class=keyword>import</span> { useUserStore } <span class=keyword>from</span> <span class=string>'@/stores'</span></span><br><span class=line></span><br><span class=line><span class=comment>// createRouter 创建路由实例</span></span><br><span class=line><span class=comment>// 配置 history 模式</span></span><br><span class=line><span class=comment>// 1. history模式：createWebHistory  地址栏不带 #</span></span><br><span class=line><span class=comment>// 2. hash模式：createWebHashHistory 地址栏带 #</span></span><br><span class=line><span class=comment>// console.log(import.meta.env.DEV)</span></span><br><span class=line></span><br><span class=line><span class=comment>// vite 中的环境变量 import.meta.env.BASE_URL  就是 vite.config.js 中的 base 配置项</span></span><br><span class=line><span class=keyword>const</span> router = <span class="title function_">createRouter</span>({</span><br><span class=line>  <span class=attr>history</span>: <span class="title function_">createWebHistory</span>(<span class=keyword>import</span>.<span class=property>meta</span>.<span class=property>env</span>.<span class=property>BASE_URL</span>),</span><br><span class=line>  <span class=attr>routes</span>: [</span><br><span class=line>    { <span class=attr>path</span>: <span class=string>'/login'</span>, <span class=attr>component</span>: <span class=function>() =></span> <span class=keyword>import</span>(<span class=string>'@/views/login/LoginPage.vue'</span>) }, <span class=comment>// 登录页</span></span><br><span class=line>    {</span><br><span class=line>      <span class=attr>path</span>: <span class=string>'/'</span>,</span><br><span class=line>      <span class=attr>component</span>: <span class=function>() =></span> <span class=keyword>import</span>(<span class=string>'@/views/layout/LayoutContainer.vue'</span>),</span><br><span class=line>      <span class=attr>redirect</span>: <span class=string>'/article/manage'</span>,</span><br><span class=line>      <span class=attr>children</span>: [</span><br><span class=line>        {</span><br><span class=line>          <span class=attr>path</span>: <span class=string>'/article/manage'</span>,</span><br><span class=line>          <span class=attr>component</span>: <span class=function>() =></span> <span class=keyword>import</span>(<span class=string>'@/views/article/ArticleManage.vue'</span>)</span><br><span class=line>        },</span><br><span class=line>        {</span><br><span class=line>          <span class=attr>path</span>: <span class=string>'/article/channel'</span>,</span><br><span class=line>          <span class=attr>component</span>: <span class=function>() =></span> <span class=keyword>import</span>(<span class=string>'@/views/article/ArticleChannel.vue'</span>)</span><br><span class=line>        },</span><br><span class=line>        {</span><br><span class=line>          <span class=attr>path</span>: <span class=string>'/user/profile'</span>,</span><br><span class=line>          <span class=attr>component</span>: <span class=function>() =></span> <span class=keyword>import</span>(<span class=string>'@/views/user/UserProfile.vue'</span>)</span><br><span class=line>        },</span><br><span class=line>        {</span><br><span class=line>          <span class=attr>path</span>: <span class=string>'/user/avatar'</span>,</span><br><span class=line>          <span class=attr>component</span>: <span class=function>() =></span> <span class=keyword>import</span>(<span class=string>'@/views/user/UserAvatar.vue'</span>)</span><br><span class=line>        },</span><br><span class=line>        {</span><br><span class=line>          <span class=attr>path</span>: <span class=string>'/user/password'</span>,</span><br><span class=line>          <span class=attr>component</span>: <span class=function>() =></span> <span class=keyword>import</span>(<span class=string>'@/views/user/UserPassword.vue'</span>)</span><br><span class=line>        }</span><br><span class=line>      ]</span><br><span class=line>    }</span><br><span class=line>  ]</span><br><span class=line>})</span><br><span class=line></span><br><span class=line><span class=comment>// 登录访问拦截</span></span><br><span class=line>router.<span class="title function_">beforeEach</span>(<span class=function>(<span class=params>to</span>) =></span> {</span><br><span class=line>  <span class=keyword>const</span> userStore = <span class="title function_">useUserStore</span>()</span><br><span class=line>  <span class=keyword>if</span> (!userStore.<span class=property>token</span> && to.<span class=property>path</span> !== <span class=string>'/login'</span>) <span class=keyword>return</span> <span class=string>'/login'</span></span><br><span class=line>})</span><br><span class=line></span><br><span class=line><span class=keyword>export</span> <span class=keyword>default</span> router</span><br></pre></table></figure><p><strong>（3）集成至Vue</strong><p>在<code>main.js</code>文件中加入路由相关配置，内容参考如下：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> <span class=string>'@/assets/main.scss'</span></span><br><span class=line><span class=keyword>import</span> <span class=string>'@/stores'</span></span><br><span class=line><span class=keyword>import</span> { createApp } <span class=keyword>from</span> <span class=string>'vue'</span></span><br><span class=line><span class=keyword>import</span> <span class="title class_">App</span> <span class=keyword>from</span> <span class=string>'@/App.vue'</span></span><br><span class=line><span class=comment>// 引入创建的路由,index.js名字可以省略，前提名字是index.js</span></span><br><span class=line><span class=keyword>import</span> router <span class=keyword>from</span> <span class=string>'@/router'</span></span><br><span class=line></span><br><span class=line><span class=keyword>const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class=line>app.<span class="title function_">use</span>(router)	<span class=comment>// 使用路由</span></span><br><span class=line>app.<span class="title function_">mount</span>(<span class=string>'#app'</span>)</span><br></pre></table></figure><p><strong>（4）使用router标签</strong><p>在App.vue文件中使用router标签，实现路由功能。参考内容如下：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line>&LTscript setup></span><br><span class=line>import zh from 'element-plus/es/locale/lang/zh-cn.mjs'</span><br><span class=line>&LT/script></span><br><span class=line></span><br><span class=line>&LTtemplate></span><br><span class=line>  &LTdiv></span><br><span class=line>    &LTel-config-provider :locale="zh"></span><br><span class=line>      &LTrouter-view>&LT/router-view></span><br><span class=line>    &LT/el-config-provider></span><br><span class=line>  &LT/div></span><br><span class=line>&LT/template></span><br><span class=line></span><br><span class=line>&LTstyle lang="scss">&LT/style></span><br></pre></table></figure><p>（5）vue页面中使用<p>在vue页面的script模块中使用路由来实现页面跳转，示例如下：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>&LTscript setup></span><br><span class=line>import { useRouter } from 'vue-router'</span><br><span class=line></span><br><span class=line>const router = useRouter();</span><br><span class=line>// 跳转到请求路径为/的vue页面，这里就是首页。</span><br><span class=line>// 这句代码可以作为登录逻辑处理中登录成功后要执行的代码。</span><br><span class=line>router.push('/');</span><br><span class=line>&LT/script></span><br></pre></table></figure><h2 id=Pinia管理库><a class=headerlink href=#Pinia管理库 title=Pinia管理库></a>Pinia管理库</h2><h3 id=概述-1><a class=headerlink href=#概述-1 title=概述></a>概述</h3><p>Pinia是Vue专属状态管理库，允许跨组件或页面共享状态。<p><font color=red>Pinia缺点</font>：默认是内存存储，刷新浏览器会丢失数据。对于该问题，可通过使用Persist插件持久化存储来解决。Persist插件使用步骤参考如下：<ol><li>通过命令<code>npm install pinia-persistedstate-plugin</code>可安装Persist插件。<li>在pinia实例中使用persist。详情可参考pinia使用步骤中的第（2）步。<li>定义store时通过持久化参数来设置。</ol><h3 id=使用步骤-1><a class=headerlink href=#使用步骤-1 title=使用步骤></a>使用步骤</h3><p>（1）安装Pinia。安装命令为<code>npm install pinia --save</code><p>（2）vue实例中使用pinia<p>想要自定义pinia实例时可以另外创建一个<code>stores/index.js</code>文件来配置，最终导出即可。自定义配置内容参考：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>// stores/index.js</span></span><br><span class=line><span class=keyword>import</span> { createPinia } <span class=keyword>from</span> <span class=string>'pinia'</span></span><br><span class=line><span class=keyword>import</span> { createPersistedState } <span class=keyword>from</span> <span class=string>'pinia-persistedstate=plugin'</span></span><br><span class=line><span class=keyword>const</span> persist = <span class="title function_">createPersistedState</span>()</span><br><span class=line><span class=keyword>const</span> pinia = <span class="title function_">createPinia</span>()</span><br><span class=line>pinia.<span class="title function_">use</span>(persist)</span><br><span class=line><span class=keyword>export</span> <span class=keyword>default</span> pinia</span><br></pre></table></figure><p>在<code>main.js</code>文件中编写如下内容：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> { createApp } <span class=keyword>from</span> <span class=string>'vue'</span></span><br><span class=line><span class=keyword>import</span> <span class="title class_">App</span> <span class=keyword>from</span> <span class=string>'@/App.vue'</span></span><br><span class=line><span class=keyword>import</span> pinia <span class=keyword>from</span> <span class=string>'./stores'</span>	<span class=comment>// 这里导入的就是自定义pinia实例的配置</span></span><br><span class=line></span><br><span class=line><span class=keyword>const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class=line>app.<span class="title function_">use</span>(pinia)</span><br><span class=line>app.<span class="title function_">mount</span>(<span class=string>'#app'</span>)</span><br></pre></table></figure><p>（3）pinia使用实例：定义store<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br></pre><td class=code><pre><span class=line><span class=comment>// 路径 stores/user.js</span></span><br><span class=line><span class=keyword>import</span> { defineStore } <span class=keyword>from</span> <span class=string>'pinia'</span></span><br><span class=line><span class=keyword>import</span> { ref } <span class=keyword>from</span> <span class=string>'vue'</span></span><br><span class=line><span class=keyword>import</span> { userGetInfoService } <span class=keyword>from</span> <span class=string>'@/apis/user'</span></span><br><span class=line></span><br><span class=line><span class=comment>//用户模块</span></span><br><span class=line><span class=keyword>export</span> <span class=keyword>const</span> useUserStore = <span class="title function_">defineStore</span>(</span><br><span class=line>  <span class=string>'big-user'</span>,	<span class=comment>// 当前store的名字，具备唯一性。</span></span><br><span class=line>  <span class=function>() =></span> {		<span class=comment>// 函数</span></span><br><span class=line>    <span class=comment>// 配置token</span></span><br><span class=line>    <span class=keyword>const</span> token = <span class="title function_">ref</span>(<span class=string>''</span>)</span><br><span class=line>    <span class=keyword>const</span> <span class="title function_">setToken</span> = (<span class=params>newToken</span>) => {</span><br><span class=line>      token.<span class=property>value</span> = newToken</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>const</span> <span class="title function_">removeToken</span> = (<span class=params></span>)=>{</span><br><span class=line>        token.<span class=property>value</span>=<span class=string>''</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>const</span> userInfo = <span class="title function_">ref</span>({})</span><br><span class=line>    <span class=keyword>const</span> <span class="title function_">getUserInfo</span> = <span class=keyword>async</span> (<span class=params></span>) => {</span><br><span class=line>      <span class=keyword>const</span> { data } = <span class=keyword>await</span> <span class="title function_">userGetInfoService</span>()</span><br><span class=line>      <span class=comment>// console.log(data);</span></span><br><span class=line>      userInfo.<span class=property>value</span> = data.<span class=property>code</span> === <span class=number>0</span> ? data.<span class=property>data</span> : {}</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>const</span> <span class="title function_">setUserInfo</span> = (<span class=params></span>) => {</span><br><span class=line>      userInfo.<span class=property>value</span> = {}</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> {</span><br><span class=line>      token,</span><br><span class=line>      setToken,</span><br><span class=line>      removeToken,</span><br><span class=line>      getUserInfo,</span><br><span class=line>      userInfo,</span><br><span class=line>      setUserInfo</span><br><span class=line>    }</span><br><span class=line>  },</span><br><span class=line>  {</span><br><span class=line>    <span class=attr>persist</span>: <span class=literal>true</span>,	<span class=comment>// 使用pinia persist插件配置持久化存储</span></span><br><span class=line>  }</span><br><span class=line>)</span><br></pre></table></figure><p>（4）頁面中使用store<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line>&LTscript setup></span><br><span class=line>import { useUserStore } from '@/stores/user.js'</span><br><span class=line>const userStore = useUserStore();</span><br><span class=line>const login = async()=>{</span><br><span class=line>    let result = await userLoginService(loginParam.value);</span><br><span class=line>    // 设置token</span><br><span class=line>    userStore.setToken(result.data);</span><br><span class=line>    router.push('/');</span><br><span class=line>}</span><br><span class=line>&LT/script></span><br></pre></table></figure><h1 id=工具整合><a class=headerlink href=#工具整合 title=工具整合></a>工具整合</h1><h2 id=前言-1><a class=headerlink href=#前言-1 title=前言></a>前言</h2><p>package.json中的dependencies和devdependencies的解释：<ul><li>dependencies：开发和上线都需要的第三方包，安装时推荐使用参数<code>--save</code>。<li>devdependencies：仅在开发阶段需要的第三方包，安装时推荐使用参数<code>--save-dev</code>。</ul><p>安装框架或第三方包时通常会使用一些参数，下面对这些参数进行总结和说明：<ul><li>-S：<code>--save</code>的缩写形式，表示将安装的包放在文件package.json里面的<code>dependencies</code>下。<li>-D：<code>--save-dev</code>的缩写形式，表示将安装的第三方包放在文件package.json里面的<code>devdependencies</code>下。</ul><h2 id=框架整合><a class=headerlink href=#框架整合 title=框架整合></a>框架整合</h2><h3 id=整合Element-Plus><a class=headerlink href=#整合Element-Plus title=整合Element-Plus></a>整合Element-Plus</h3><h4 id=概述-2><a class=headerlink href=#概述-2 title=概述></a>概述</h4><h4 id=使用步骤-2><a class=headerlink href=#使用步骤-2 title=使用步骤></a>使用步骤</h4><p><strong>（1）安装Element-Plus</strong><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>npm install element-plus --save</span><br></pre></table></figure><p>参数解析：<ul><li>save：将下载的包放在文件<code>package.json</code>里面的<code>dependencies</code>下。</ul><p><strong>（2）集成</strong><p><strong>完整引入</strong>只需在<code>main.ts</code>文件中加入如下内容：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=comment>// main.ts</span></span><br><span class=line><span class=keyword>import</span> { createApp } <span class=keyword>from</span> <span class=string>'vue'</span></span><br><span class=line><span class=keyword>import</span> <span class="title class_">ElementPlus</span> <span class=keyword>from</span> <span class=string>'element-plus'</span></span><br><span class=line><span class=keyword>import</span> <span class=string>'element-plus/dist/index.css'</span></span><br><span class=line><span class=keyword>import</span> <span class="title class_">App</span> <span class=keyword>from</span> <span class=string>'./App.vue'</span></span><br><span class=line></span><br><span class=line><span class=keyword>const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class=line></span><br><span class=line>app.<span class="title function_">use</span>(<span class="title class_">ElementPlus</span>)</span><br><span class=line>app.<span class="title function_">mount</span>(<span class=string>'#app'</span>)</span><br></pre></table></figure><p><strong>按需自动导入</strong>使用步骤如下：<ol><li><p>安装<code>unplugin-vue-components</code> 和 <code>unplugin-auto-import</code>这两款插件。安装命令：<code>npm install -D unplugin-vue-components unplugin-auto-import</code>。</p><li><p>在vite.config.ts中加入如下内容：</p> <figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=comment>// vite.config.ts</span></span><br><span class=line><span class=keyword>import</span> { defineConfig } <span class=keyword>from</span> <span class=string>'vite'</span></span><br><span class=line><span class=keyword>import</span> <span class="title class_">AutoImport</span> <span class=keyword>from</span> <span class=string>'unplugin-auto-import/vite'</span></span><br><span class=line><span class=keyword>import</span> <span class="title class_">Components</span> <span class=keyword>from</span> <span class=string>'unplugin-vue-components/vite'</span></span><br><span class=line><span class=keyword>import</span> { <span class="title class_">ElementPlusResolver</span> } <span class=keyword>from</span> <span class=string>'unplugin-vue-components/resolvers'</span></span><br><span class=line></span><br><span class=line><span class=keyword>export</span> <span class=keyword>default</span> <span class="title function_">defineConfig</span>({</span><br><span class=line>  <span class=comment>// ...</span></span><br><span class=line>  <span class=attr>plugins</span>: [</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>    <span class="title class_">AutoImport</span>({</span><br><span class=line>      <span class=attr>resolvers</span>: [<span class="title class_">ElementPlusResolver</span>()],</span><br><span class=line>    }),</span><br><span class=line>    <span class="title class_">Components</span>({</span><br><span class=line>      <span class=attr>resolvers</span>: [<span class="title class_">ElementPlusResolver</span>()],</span><br><span class=line>    }),</span><br><span class=line>  ],</span><br><span class=line>})</span><br></pre></table></figure></ol><h4 id=切换语言包><a class=headerlink href=#切换语言包 title=切换语言包></a>切换语言包</h4><p>这里以中文语言包为例。使用中文语言包可实现分页小插件提示信息中文展示。<p>使用方法很简单，首先在<code>src/main.js</code>文件中导入中文包的js文件，然后在配置vue实例使用element时传递进去即可。内容参考如下：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> { createApp } <span class=keyword>from</span> <span class=string>'vue'</span></span><br><span class=line><span class=keyword>import</span> <span class="title class_">ElementPlus</span> <span class=keyword>from</span> <span class=string>'element-plus'</span></span><br><span class=line><span class=keyword>import</span> locale <span class=keyword>from</span> <span class=string>'element-plus/dist/locale/zh-cn.js'</span></span><br><span class=line><span class=keyword>import</span> <span class="title class_">App</span> <span class=keyword>from</span> <span class=string>'./App.vue'</span></span><br><span class=line><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">use</span>(<span class="title class_">ElementPlus</span>, {locale});</span><br></pre></table></figure><h3 id=整合Axios><a class=headerlink href=#整合Axios title=整合Axios></a>整合Axios</h3><p>官网文档：<a href=https://axios-http.com/zh/docs/intro rel=noopener target=_blank>https://axios-http.com/zh/docs/intro</a><p><strong>（1）安装Axios</strong><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>npm install axios</span><br></pre></table></figure><p><strong>（2）集成封装</strong><p>通常情况下，可以基于axios创建一个API请求调用工具类来来使用。下面将创建一个工具类request.js来示范：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> axios <span class=keyword>from</span> <span class=string>'axios'</span></span><br><span class=line><span class=keyword>import</span> { useUserStore } <span class=keyword>from</span> <span class=string>'@/stores'</span></span><br><span class=line><span class=keyword>import</span> { <span class="title class_">ElMessage</span> } <span class=keyword>from</span> <span class=string>'element-plus'</span></span><br><span class=line><span class=keyword>import</span> router <span class=keyword>from</span> <span class=string>'@/router'</span></span><br><span class=line></span><br><span class=line><span class=keyword>const</span> baseURL = <span class=string>'http://big-event-vue-api-t.itheima.net'</span></span><br><span class=line></span><br><span class=line><span class=keyword>const</span> instance = axios.<span class="title function_">create</span>({</span><br><span class=line>  <span class=comment>// TODO 1. 基础地址，超时时间</span></span><br><span class=line>  baseURL,</span><br><span class=line>  <span class=attr>timeout</span>: <span class=number>10000</span></span><br><span class=line>})</span><br><span class=line></span><br><span class=line><span class=comment>//请求拦截器</span></span><br><span class=line>instance.<span class=property>interceptors</span>.<span class=property>request</span>.<span class="title function_">use</span>(</span><br><span class=line>  <span class=function>(<span class=params>config</span>) =></span> {</span><br><span class=line>    <span class=comment>// TODO 2. 携带token</span></span><br><span class=line>    <span class=keyword>const</span> userStore = <span class="title function_">useUserStore</span>()</span><br><span class=line>    <span class=keyword>if</span> (userStore.<span class=property>token</span>) {</span><br><span class=line>      config.<span class=property>headers</span>.<span class=property>Authorization</span> = userStore.<span class=property>token</span></span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> config</span><br><span class=line>  },</span><br><span class=line>  <span class=function>(<span class=params>err</span>) =></span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class=line>)</span><br><span class=line></span><br><span class=line><span class=comment>//响应拦截器</span></span><br><span class=line>instance.<span class=property>interceptors</span>.<span class=property>response</span>.<span class="title function_">use</span>(</span><br><span class=line>  <span class=function>(<span class=params>res</span>) =></span> {</span><br><span class=line>    <span class=comment>// TODO 3. 处理业务失败</span></span><br><span class=line>    <span class=comment>// TODO 4. 摘取核心响应数据</span></span><br><span class=line>    <span class=keyword>if</span> (res.<span class=property>data</span>.<span class=property>code</span> === <span class=number>0</span>) <span class=keyword>return</span> res</span><br><span class=line>    <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(res.<span class=property>data</span>.<span class=property>message</span> || <span class=string>'服务异常'</span>)</span><br><span class=line>    <span class=keyword>return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(res.<span class=property>data</span>)</span><br><span class=line>  },</span><br><span class=line>  <span class=function>(<span class=params>err</span>) =></span> {</span><br><span class=line>    <span class=comment>// TODO 5. 处理401错误</span></span><br><span class=line>    <span class=comment>//错误的特殊情况 => 权限不足 或 token过期 => 拦截到登录</span></span><br><span class=line>    <span class=keyword>if</span> (err.<span class=property>response</span>?.<span class=property>status</span> === <span class=number>401</span>) {</span><br><span class=line>      router.<span class="title function_">push</span>(<span class=string>'/login'</span>)</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>//错误的默认提示</span></span><br><span class=line>    <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(err.<span class=property>response</span>.<span class=property>data</span>.<span class=property>message</span> || <span class=string>'服务异常'</span>)</span><br><span class=line>    <span class=keyword>return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class=line>  }</span><br><span class=line>)</span><br><span class=line></span><br><span class=line><span class=keyword>export</span> <span class=keyword>default</span> instance</span><br><span class=line><span class=keyword>export</span> { baseURL }</span><br></pre></table></figure><p><strong>（3）使用示例</strong><p>js文件：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> request <span class=keyword>from</span> <span class=string>'@/utils/request'</span></span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 用户注册接口</span></span><br><span class=line><span class=comment> * <span class=doctag>@param</span> {<span class=type>*</span>} <span class=variable>param0</span></span></span><br><span class=line><span class=comment> * <span class=doctag>@returns</span></span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>export</span> <span class=keyword>const</span> <span class="title function_">userRegisterService</span> = (<span class=params>{ username, password, repassword }</span>) => {</span><br><span class=line>  <span class=keyword>return</span> request.<span class="title function_">post</span>(<span class=string>'/api/reg'</span>, { username, password, repassword })</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 用户登录接口</span></span><br><span class=line><span class=comment> * <span class=doctag>@param</span> {<span class=type>*</span>} <span class=variable>param0</span></span></span><br><span class=line><span class=comment> * <span class=doctag>@returns</span></span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>export</span> <span class=keyword>const</span> <span class="title function_">userLoginService</span> = (<span class=params>{ username, password }</span>) => {</span><br><span class=line>  <span class=keyword>return</span> request.<span class="title function_">post</span>(<span class=string>'/api/login'</span>, { username, password })</span><br><span class=line>}</span><br></pre></table></figure><p>vue页面文件：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br></pre><td class=code><pre><span class=line>&LTscript setup></span><br><span class=line>import { ref, watch } from 'vue'</span><br><span class=line>import { useRouter } from 'vue-router'</span><br><span class=line>import { useUserStore } from '@/stores'</span><br><span class=line>import { userRegisterService, userLoginService } from '@/apis/user'</span><br><span class=line></span><br><span class=line>// 模型数据定义</span><br><span class=line>const userStore = useUserStore()</span><br><span class=line>const isRegister = ref(false)</span><br><span class=line>const refObj = ref(null)</span><br><span class=line>const formModel = ref({</span><br><span class=line>  username: '',</span><br><span class=line>  password: '',</span><br><span class=line>  repassword: '',</span><br><span class=line>  rememberme: false</span><br><span class=line>})</span><br><span class=line></span><br><span class=line>// 注册</span><br><span class=line>const registerFn = async () => {</span><br><span class=line>  // console.log("register");</span><br><span class=line>  await refObj.value.validate()</span><br><span class=line>  const { data } = await userRegisterService(formModel.value)</span><br><span class=line>  // console.log(res);</span><br><span class=line>  if (data.code === 0) {</span><br><span class=line>    ElMessage.success(data.message)</span><br><span class=line>    isRegister.value = false</span><br><span class=line>    clearFormModel()</span><br><span class=line>  } else {</span><br><span class=line>    ElMessage.error(data.message)</span><br><span class=line>  }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line>// 登录</span><br><span class=line>const router = useRouter()</span><br><span class=line>const loginFn = async () => {</span><br><span class=line>  await refObj.value.validate()</span><br><span class=line>  const { data } = await userLoginService(formModel.value)</span><br><span class=line>  if (data.code === 0) {</span><br><span class=line>    ElMessage.success(data.message)</span><br><span class=line>    // console.log(data);</span><br><span class=line>    userStore.setToken(data.token)</span><br><span class=line>    clearFormModel()</span><br><span class=line>    router.push('/')</span><br><span class=line>  } else {</span><br><span class=line>    ElMessage.error(data.message)</span><br><span class=line>  }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line>const clearFormModel = () => {</span><br><span class=line>  formModel.value.username = ''</span><br><span class=line>  formModel.value.password = ''</span><br><span class=line>  formModel.value.repassword = ''</span><br><span class=line>  formModel.value.rememberme = false</span><br><span class=line>}</span><br><span class=line></span><br><span class=line>watch(isRegister, () => {</span><br><span class=line>  clearFormModel()</span><br><span class=line>})</span><br><span class=line>&LT/script></span><br><span class=line>&LTtemplate>&LT/template></span><br><span class=line>&LTstyle lang="scss" scoped>&LT/style></span><br></pre></table></figure><h3 id=整合Sass><a class=headerlink href=#整合Sass title=整合Sass></a>整合Sass</h3><p><strong>（1）安装Sass</strong><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>npm install sass sass-loader -D</span><br></pre></table></figure><p><strong>（2）集成</strong><p>全局使用可在<code>vite.config.js</code>文件添加如下内容：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> { defineConfig } <span class=keyword>from</span> <span class=string>'vite'</span>;</span><br><span class=line><span class=keyword>import</span> vue <span class=keyword>from</span> <span class=string>'@vitejs/plugin-vue'</span>;</span><br><span class=line></span><br><span class=line><span class=keyword>export</span> <span class=keyword>default</span> <span class="title function_">defineConfig</span>({</span><br><span class=line>  <span class=attr>plugins</span>: [<span class="title function_">vue</span>()],</span><br><span class=line>  <span class=attr>css</span>: {</span><br><span class=line>    <span class=attr>preprocessorOptions</span>: {</span><br><span class=line>      <span class=attr>scss</span>: {</span><br><span class=line>        <span class=attr>additionalData</span>: <span class=string>`@import '@/styles/main.scss';`</span></span><br><span class=line>      }</span><br><span class=line>    }</span><br><span class=line>  }</span><br><span class=line>});</span><br></pre></table></figure><p><strong>（3）使用示例</strong><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line>&LTtemplate></span><br><span class=line>  &LTdiv class="demo-component"></span><br><span class=line>    &LT!-- Component HTML code here --></span><br><span class=line>  &LT/div></span><br><span class=line>&LT/template></span><br><span class=line></span><br><span class=line>&LTscript></span><br><span class=line>export default {</span><br><span class=line>  // Component configuration options</span><br><span class=line>};</span><br><span class=line></span><br><span class=line>&LTstyle lang="scss" module></span><br><span class=line>.demo-component {</span><br><span class=line>  // Sass code for the component</span><br><span class=line>}</span><br><span class=line>&LT/style></span><br></pre></table></figure><p>注意：vue3中<code>scoped</code>属性已被<code>module</code>属性替换。<h2 id=插件整合><a class=headerlink href=#插件整合 title=插件整合></a>插件整合</h2><h3 id=整合vue-quill（富文本编辑器）><a class=headerlink href=#整合vue-quill（富文本编辑器） title=整合vue-quill（富文本编辑器）></a>整合vue-quill（富文本编辑器）</h3><h4 id=概述-3><a class=headerlink href=#概述-3 title=概述></a>概述</h4><p>官网地址：<a href=https://vueup.github.io/vue-quill rel=noopener target=_blank>https://vueup.github.io/vue-quill</a><h4 id=使用步骤-3><a class=headerlink href=#使用步骤-3 title=使用步骤></a>使用步骤</h4><p>（1）安装vueup。安装命令为<code>npm install @vueup/vue-quill@latest --save</code>。<p>（2）导入组件和样式。<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> { <span class="title class_">QuillEditor</span> } <span class=keyword>from</span> <span class=string>'@vueup/vue-quill'</span></span><br><span class=line><span class=keyword>import</span> <span class=string>'@vueup/vue-quill/dist/vue-quill.snow.css'</span></span><br></pre></table></figure><p>（3）使用quill组件<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>&LTquill-editor </span><br><span class=line>	ref="editRef"</span><br><span class=line>	theme="snow"</span><br><span class=line>	v-model:content="formModel.content"</span><br><span class=line>	contentType="html"></span><br><span class=line>&LT/quill-editor></span><br></pre></table></figure><h3 id=整合js-cookie（cookie管理）><a class=headerlink href=#整合js-cookie（cookie管理） title=整合js-cookie（cookie管理）></a>整合js-cookie（cookie管理）</h3><h4 id=概述-4><a class=headerlink href=#概述-4 title=概述></a>概述</h4><p>相关文档及教程：<a href=https://www.npmjs.com/package/js-cookie rel=noopener target=_blank>点我直达</a>。<h4 id=使用步骤-4><a class=headerlink href=#使用步骤-4 title=使用步骤></a>使用步骤</h4><p>（1）安装js-cookie。安装命令<code>npm install js-cookie --save</code>。<p>（2）使用<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> cookie <span class=keyword>from</span> <span class=string>'js-cookie'</span></span><br><span class=line><span class=comment>// 存储cookie，对当前页面路径有效</span></span><br><span class=line>cookie.<span class="title function_">set</span>(<span class=string>'name'</span>, <span class=string>'value'</span>, { <span class=attr>expires</span>: <span class=number>7</span>, <span class=attr>path</span>: <span class=string>''</span> });</span><br><span class=line><span class=comment>// 获取cookie</span></span><br><span class=line>cookie.<span class="title function_">get</span>(<span class=string>'name'</span>);</span><br><span class=line><span class=comment>// 删除对当前页面路径有效的cookie</span></span><br><span class=line>cookie.<span class="title function_">remove</span>(<span class=string>'name'</span>, {<span class=attr>path</span>: <span class=string>''</span>});</span><br></pre></table></figure><blockquote><p><em>注意：删除不存在的 cookie 既不会引发任何异常，也不会返回任何值。</em></blockquote><h3 id=整合vue-qriously（二维码）><a class=headerlink href=#整合vue-qriously（二维码） title=整合vue-qriously（二维码）></a>整合vue-qriously（二维码）</h3><h4 id=概述-5><a class=headerlink href=#概述-5 title=概述></a>概述</h4><p>相关文档及教程：<a href=%5Bhttps://www.npmjs.com/package/@bitfirer/vue-qriously>点我直达</a>。<h4 id=使用步骤-5><a class=headerlink href=#使用步骤-5 title=使用步骤></a>使用步骤</h4><p>（1）安装vue-qriously。安装命令<code>npm install vue-qriously --save</code>。<p>（2）集成到Vue实例<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> <span class="title class_">Vue</span> <span class=keyword>from</span> <span class=string>'vue'</span></span><br><span class=line><span class=keyword>import</span> <span class="title class_">VueQriously</span> <span class=keyword>from</span> <span class=string>'vue-qriously'</span></span><br><span class=line><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueQriously</span>);</span><br></pre></table></figure><p>（3）使用<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line>&LTscript setup></span><br><span class=line>import { ref } from 'vue'</span><br><span class=line>const wxpay = ref({</span><br><span class=line>    codeUrl:""</span><br><span class=line>})</span><br><span class=line>const getPayCode = async()=>{</span><br><span class=line>    const { data } = generatePayCodeUrl();</span><br><span class=line>    wxpay.value.codeUrl = data;</span><br><span class=line>}</span><br><span class=line>&LT/script></span><br><span class=line>&LTtemplate></span><br><span class=line>    &LTdiv></span><br><span class=line>        &LTqriously :value="wxpay.codeUrl" :size="200" /></span><br><span class=line>    &LT/div></span><br><span class=line>&LT/template></span><br></pre></table></figure><h3 id=整合echarts（图表）><a class=headerlink href=#整合echarts（图表） title=整合echarts（图表）></a>整合echarts（图表）</h3><h4 id=概述-6><a class=headerlink href=#概述-6 title=概述></a>概述</h4><p><a href=https://echarts.apache.org/handbook/zh/get-started/ rel=noopener target=_blank>快速上手 - Apache ECharts</a><h4 id=使用步骤-6><a class=headerlink href=#使用步骤-6 title=使用步骤></a>使用步骤</h4><p>（1）安装echarts。安装命令<code>npm install echarts --save</code>。<p>（2）使用<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line>&LTscript></span><br><span class=line>import * as echarts from 'echarts';</span><br><span class=line></span><br><span class=line>// 基于准备好的dom，初始化echarts实例</span><br><span class=line>var myChart = echarts.init(document.getElementById('main'));</span><br><span class=line>// 绘制图表</span><br><span class=line>myChart.setOption({</span><br><span class=line>  title: {</span><br><span class=line>    text: 'ECharts 入门示例'</span><br><span class=line>  },</span><br><span class=line>  tooltip: {},</span><br><span class=line>  xAxis: {</span><br><span class=line>    data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子']</span><br><span class=line>  },</span><br><span class=line>  yAxis: {},</span><br><span class=line>  series: [</span><br><span class=line>    {</span><br><span class=line>      name: '销量',</span><br><span class=line>      type: 'bar',</span><br><span class=line>      data: [5, 20, 36, 10, 10, 20]</span><br><span class=line>    }</span><br><span class=line>  ]</span><br><span class=line>});</span><br><span class=line>&LT/script></span><br><span class=line>&LTtemplate>&LT/template></span><br></pre></table></figure><h1 id=常见问题><a class=headerlink href=#常见问题 title=常见问题></a>常见问题</h1><h2 id=跨域问题><a class=headerlink href=#跨域问题 title=跨域问题></a>跨域问题</h2><h3 id=定义><a class=headerlink href=#定义 title=定义></a>定义</h3><p>当一个请求url的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面url不同时即为跨域。<h3 id=解决方法><a class=headerlink href=#解决方法 title=解决方法></a>解决方法</h3><p>解决该问题的方法有多种，这里以vue通过代理解决跨域为例来说明。<p>在<code>vite.config.js</code>文件中配置如下代码可实现通过代理解决跨域：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> { fileURLToPath, <span class="variable constant_">URL</span> } <span class=keyword>from</span> <span class=string>'node:url'</span></span><br><span class=line><span class=keyword>import</span> {defineConfig} <span class=keyword>from</span> <span class=string>'vite'</span></span><br><span class=line><span class=keyword>import</span> vue <span class=keyword>from</span> <span class=string>'@/vitejs/plugin-vue'</span></span><br><span class=line></span><br><span class=line><span class=comment>// https://vitejs.dev/config/</span></span><br><span class=line><span class=keyword>export</span> <span class=keyword>default</span> <span class="title function_">defineConfig</span>({</span><br><span class=line>  <span class=attr>plugins</span>: {</span><br><span class=line>    <span class="title function_">vue</span>(),  </span><br><span class=line>  },</span><br><span class=line>  <span class=attr>resolve</span>: {</span><br><span class=line>    <span class=attr>alias</span>: {</span><br><span class=line>      <span class=string>'@'</span>: <span class="title function_">fileURLToPath</span>(<span class=keyword>new</span> <span class="title function_">URL</span>(<span class=string>'./src'</span>, <span class=keyword>import</span>.<span class=property>meta</span>.<span class=property>url</span>))</span><br><span class=line>    }</span><br><span class=line>  },</span><br><span class=line>  <span class=attr>server</span>:{</span><br><span class=line>      <span class=attr>proxy</span>:{</span><br><span class=line>          <span class=string>'/api'</span>: {</span><br><span class=line>              <span class=attr>target</span>: <span class=string>'http://localhost:8080'</span>,</span><br><span class=line>              <span class=attr>changeOrigin</span>: <span class=literal>true</span>,</span><br><span class=line>              <span class=attr>rewrite</span>: <span class=function>(<span class=params>path</span>) =></span> path.<span class="title function_">replace</span>(<span class=string>'/^\/api/'</span>,<span class=string>''</span>)</span><br><span class=line>          }</span><br><span class=line>      }</span><br><span class=line>  }</span><br><span class=line>})</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <nav class=pagination><a class="extend prev" aria-label=上一页 href=/ rel=prev title=上一页><i class="fa fa-angle-left"></i></a><a class=page-number href=/>1</a><span class="page-number current">2</span><a class=page-number href=/page/3/>3</a><span class=space>…</span><a class=page-number href=/page/11/>11</a><a class="extend next" aria-label=下一页 href=/page/3/ rel=next title=下一页><i class="fa fa-angle-right"></i></a></nav> <footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer> <div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div> <div class=sidebar-dimmer></div> <div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div> <noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript> <script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script> <script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script> <script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script> <script src=/js/third-party/search/local-search.js></script> 