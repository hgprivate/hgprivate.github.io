<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hshz21.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content=豪哥博客 name=description><meta content=website property=og:type><meta content=豪哥博客 property=og:title><meta content=https://hshz21.gitee.io/page/7/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content=豪哥博客 property=og:description><meta content=zh_CN property=og:locale><meta content=豪哥 property=article:author><meta content=HG property=article:tag><meta content=summary name=twitter:card><link href=https://hshz21.gitee.io/page/7/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/7/index.html","title":""}</script><script class=next-config data-name=calendar type=application/json>""</script><title>豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <h1 class=site-title>豪哥博客</h1> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>109</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>33</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>126</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Mybatis%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Mybatis%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/ itemprop=url>MyBatis系列-MyBatis基础应用</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-03 21:11:57" datetime=2023-10-03T21:11:57+08:00 itemprop=dateModified>2023-10-03</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/MyBatis/ itemprop=url rel=index><span itemprop=name>MyBatis</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、什么是MyBatis><a class=headerlink href=#1、什么是MyBatis title=1、什么是MyBatis></a>1、什么是MyBatis</h1><p>MyBatis 是一个持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。<h1 id=2、如何使用><a class=headerlink href=#2、如何使用 title=2、如何使用></a>2、如何使用</h1><h2 id=2-1、安装><a class=headerlink href=#2-1、安装 title=2.1、安装></a>2.1、安装</h2><p>要使用 MyBatis， 只需将 <a href=https://github.com/mybatis/mybatis-3/releases rel=noopener target=_blank>mybatis-x.x.x.jar</a> 文件置于类路径（classpath）中即可。<p>如果使用 Maven 来构建项目，则需将下面的依赖代码置于 pom.xml 文件中：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>  <span class=tag><<span class=name>groupId</span>></span>org.mybatis<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>  <span class=tag><<span class=name>artifactId</span>></span>mybatis<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>  <span class=tag><<span class=name>version</span>></span>x.x.x<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><h2 id=2-2、构建SqlSessionFactory><a class=headerlink href=#2-2、构建SqlSessionFactory title=2.2、构建SqlSessionFactory></a>2.2、构建SqlSessionFactory</h2><h3 id=2-2-1、基于XML构建><a class=headerlink href=#2-2-1、基于XML构建 title=2.2.1、基于XML构建></a>2.2.1、基于XML构建</h3><p>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。<p>XML 配置文件中包含了对 MyBatis 系统的核心设置，包括获取数据库连接实例的数据源（DataSource）以及决定事务作用域和控制方式的事务管理器（TransactionManager）。XML（mybatis-config.xml）配置示例如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span> ?></span></span><br><span class=line><span class=meta>&LT!DOCTYPE <span class=keyword>configuration</span></span></span><br><span class=line><span class=meta>  <span class=keyword>PUBLIC</span> <span class=string>"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class=line><span class=meta>  <span class=string>"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>></span></span><br><span class=line><span class=tag><<span class=name>configuration</span>></span></span><br><span class=line>  <span class=tag><<span class=name>environments</span> <span class=attr>default</span>=<span class=string>"development"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>environment</span> <span class=attr>id</span>=<span class=string>"development"</span>></span></span><br><span class=line>      <span class=tag><<span class=name>transactionManager</span> <span class=attr>type</span>=<span class=string>"JDBC"</span>/></span></span><br><span class=line>      <span class=tag><<span class=name>dataSource</span> <span class=attr>type</span>=<span class=string>"POOLED"</span>></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"driver"</span> <span class=attr>value</span>=<span class=string>"${driver}"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"url"</span> <span class=attr>value</span>=<span class=string>"${url}"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"username"</span> <span class=attr>value</span>=<span class=string>"${username}"</span>/></span></span><br><span class=line>        <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"password"</span> <span class=attr>value</span>=<span class=string>"${password}"</span>/></span></span><br><span class=line>      <span class=tag>&LT/<span class=name>dataSource</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>environment</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>environments</span>></span></span><br><span class=line>  <span class=tag><<span class=name>mappers</span>></span></span><br><span class=line>    <span class=tag><<span class=name>mapper</span> <span class=attr>resource</span>=<span class=string>"org/mybatis/example/BlogMapper.xml"</span>/></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>mappers</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>configuration</span>></span></span><br></pre></table></figure><p>从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 file:// URL 构造的输入流。MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>String</span> <span class=variable>resource</span> <span class=operator>=</span> <span class=string>"org/mybatis/example/mybatis-config.xml"</span>;</span><br><span class=line><span class=type>InputStream</span> <span class=variable>inputStream</span> <span class=operator>=</span> Resources.getResourceAsStream(resource);</span><br><span class=line><span class=type>SqlSessionFactory</span> <span class=variable>sqlSessionFactory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br></pre></table></figure><h3 id=2-2-2、基于Java代码构建><a class=headerlink href=#2-2-2、基于Java代码构建 title=2.2.2、基于Java代码构建></a>2.2.2、基于Java代码构建</h3><p>如果你更愿意直接从 Java 代码而不是 XML 文件中创建配置，或者想要创建你自己的配置建造器，MyBatis 也提供了完整的配置类，提供了所有与 XML 文件等价的配置项。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=type>DataSource</span> <span class=variable>dataSource</span> <span class=operator>=</span> BlogDataSourceFactory.getBlogDataSource();</span><br><span class=line><span class=type>TransactionFactory</span> <span class=variable>transactionFactory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">JdbcTransactionFactory</span>();</span><br><span class=line><span class=type>Environment</span> <span class=variable>environment</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Environment</span>(<span class=string>"development"</span>, transactionFactory, dataSource);</span><br><span class=line><span class=type>Configuration</span> <span class=variable>configuration</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Configuration</span>(environment);</span><br><span class=line>configuration.addMapper(BlogMapper.class);</span><br><span class=line><span class=type>SqlSessionFactory</span> <span class=variable>sqlSessionFactory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(configuration);</span><br></pre></table></figure><p>注意该例中，configuration 添加了一个映射器类（mapper class）。映射器类是 Java 类，它们包含 SQL 映射注解从而避免依赖 XML 文件。不过，由于 Java 注解的一些限制以及某些 MyBatis 映射的复杂性，要使用大多数高级映射（比如：嵌套联合映射），仍然需要使用 XML 配置。有鉴于此，如果存在一个同名 XML 配置文件，MyBatis 会自动查找并加载它（在这个例子中，基于类路径和 BlogMapper.class 的类名，会加载 BlogMapper.xml）。<h2 id=2-3、获取SqlSession><a class=headerlink href=#2-3、获取SqlSession title=2.3、获取SqlSession></a>2.3、获取SqlSession</h2><h3 id=2-3-1、基于XML并指定其中的唯一标识ID（不推荐）><a class=headerlink href=#2-3-1、基于XML并指定其中的唯一标识ID（不推荐） title=2.3.1、基于XML并指定其中的唯一标识ID（不推荐）></a>2.3.1、基于XML并指定其中的唯一标识ID（不推荐）</h3><p>既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。例如：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>try</span> (<span class=type>SqlSession</span> <span class=variable>session</span> <span class=operator>=</span> sqlSessionFactory.openSession()) {</span><br><span class=line>  <span class=type>Blog</span> <span class=variable>blog</span> <span class=operator>=</span> (Blog) session.selectOne(<span class=string>"org.mybatis.example.BlogMapper.selectBlog"</span>, <span class=number>101</span>);</span><br><span class=line>}</span><br></pre></table></figure><h3 id=2-3-2、基于接口（推荐使用）><a class=headerlink href=#2-3-2、基于接口（推荐使用） title=2.3.2、基于接口（推荐使用）></a>2.3.2、基于接口（推荐使用）</h3><p>基于XML的方式虽然能够正常工作（对使用旧版本 MyBatis 的用户来说也比较熟悉）。但现在有了一种更简洁的方式——使用指定语句的参数和返回值相匹配的接口（比如 BlogMapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换。例如：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>try</span> (<span class=type>SqlSession</span> <span class=variable>session</span> <span class=operator>=</span> sqlSessionFactory.openSession()) {</span><br><span class=line>  <span class=type>BlogMapper</span> <span class=variable>mapper</span> <span class=operator>=</span> session.getMapper(BlogMapper.class);</span><br><span class=line>  <span class=type>Blog</span> <span class=variable>blog</span> <span class=operator>=</span> mapper.selectBlog(<span class=number>101</span>);</span><br><span class=line>}</span><br></pre></table></figure><h2 id=2-4、SQL语句映射><a class=headerlink href=#2-4、SQL语句映射 title=2.4、SQL语句映射></a>2.4、SQL语句映射</h2><h3 id=2-4-1、基于XML映射SQL语句示例：><a class=headerlink href=#2-4-1、基于XML映射SQL语句示例： title=2.4.1、基于XML映射SQL语句示例：></a>2.4.1、基于XML映射SQL语句示例：</h3><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span> ?></span></span><br><span class=line><span class=meta>&LT!DOCTYPE <span class=keyword>mapper</span></span></span><br><span class=line><span class=meta>  <span class=keyword>PUBLIC</span> <span class=string>"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class=line><span class=meta>  <span class=string>"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>></span></span><br><span class=line><span class=tag><<span class=name>mapper</span> <span class=attr>namespace</span>=<span class=string>"org.mybatis.example.BlogMapper"</span>></span></span><br><span class=line>  <span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectBlog"</span> <span class=attr>resultType</span>=<span class=string>"Blog"</span>></span></span><br><span class=line>    select * from Blog where id = #{id}</span><br><span class=line>  <span class=tag>&LT/<span class=name>select</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>mapper</span>></span></span><br></pre></table></figure><h3 id=2-4-2、基于全限定名来调用映射SQL（不推荐，不安全）><a class=headerlink href=#2-4-2、基于全限定名来调用映射SQL（不推荐，不安全） title=2.4.2、基于全限定名来调用映射SQL（不推荐，不安全）></a>2.4.2、基于全限定名来调用映射SQL（不推荐，不安全）</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>Blog</span> <span class=variable>blog</span> <span class=operator>=</span> (Blog) session.selectOne(<span class=string>"org.mybatis.example.BlogMapper.selectBlog"</span>, <span class=number>101</span>);</span><br></pre></table></figure><h3 id=2-4-3、基于接口来调用映射SQL（推荐使用）><a class=headerlink href=#2-4-3、基于接口来调用映射SQL（推荐使用） title=2.4.3、基于接口来调用映射SQL（推荐使用）></a>2.4.3、基于接口来调用映射SQL（推荐使用）</h3><p>第二种方法有很多优势，首先它不依赖于字符串字面值，会更安全一点；其次，如果你的 IDE 有代码补全功能，那么代码补全可以帮你快速选择到映射好的 SQL 语句。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>BlogMapper</span> <span class=variable>mapper</span> <span class=operator>=</span> session.getMapper(BlogMapper.class);</span><br><span class=line><span class=type>Blog</span> <span class=variable>blog</span> <span class=operator>=</span> mapper.selectBlog(<span class=number>101</span>);</span><br></pre></table></figure><h1 id=3、作用域和生命周期><a class=headerlink href=#3、作用域和生命周期 title=3、作用域和生命周期></a>3、作用域和生命周期</h1><h2 id=3-1、SqlSessionFactoryBuilder><a class=headerlink href=#3-1、SqlSessionFactoryBuilder title=3.1、SqlSessionFactoryBuilder></a>3.1、SqlSessionFactoryBuilder</h2><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 <code>SqlSessionFactoryBuilder</code>实例的最佳作用域是<strong>方法作用域（也就是局部方法变量）</strong>。 你可以重用 <code>SqlSessionFactoryBuilder</code>来创建多个<code>SqlSessionFactory</code>实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。<h2 id=3-2、SqlSessionFactory><a class=headerlink href=#3-2、SqlSessionFactory title=3.2、SqlSessionFactory></a>3.2、SqlSessionFactory</h2><p><code>SqlSessionFactory</code>一旦被创建就应该在应用的运行期间一直存在，且应用运行期间不要重复创建多次。因此 <code>SqlSessionFactory</code>的最佳作用域是<strong>应用作用域</strong>。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。<h2 id=3-3、SqlSession><a class=headerlink href=#3-3、SqlSession title=3.3、SqlSession></a>3.3、SqlSession</h2><p>每个线程都应该有它自己的<code>SqlSession</code>实例。<code>SqlSession</code>实例不是线程安全的，因此不能被共享，所以它的最佳作用域是<strong>请求或方法作用域</strong>。<p>绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>try</span> (<span class=type>SqlSession</span> <span class=variable>session</span> <span class=operator>=</span> sqlSessionFactory.openSession()) {</span><br><span class=line>  <span class=comment>// 你的应用逻辑代码</span></span><br><span class=line>}</span><br></pre></table></figure><p>在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。<h2 id=3-4、映射器实例><a class=headerlink href=#3-4、映射器实例 title=3.4、映射器实例></a>3.4、映射器实例</h2><p>映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的SqlSession相同。但<strong>方法作用域才是映射器实例最合适的作用域</strong>。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>try</span> (<span class=type>SqlSession</span> <span class=variable>session</span> <span class=operator>=</span> sqlSessionFactory.openSession()) {</span><br><span class=line>  <span class=type>BlogMapper</span> <span class=variable>mapper</span> <span class=operator>=</span> session.getMapper(BlogMapper.class);</span><br><span class=line>  <span class=comment>// 你的应用逻辑代码</span></span><br><span class=line>}</span><br></pre></table></figure><h1 id=4、XML配置><a class=headerlink href=#4、XML配置 title=4、XML配置></a>4、XML配置</h1><h2 id=4-1、properties（属性）><a class=headerlink href=#4-1、properties（属性） title=4.1、properties（属性）></a>4.1、properties（属性）</h2><p>这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。例如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>properties</span> <span class=attr>resource</span>=<span class=string>"org/mybatis/example/config.properties"</span>></span></span><br><span class=line>  <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"username"</span> <span class=attr>value</span>=<span class=string>"dev_user"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"password"</span> <span class=attr>value</span>=<span class=string>"F2Fa3!33TYyg"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>properties</span>></span></span><br></pre></table></figure><p>设置好的属性可以在整个配置文件中用来替换需要动态配置的属性值。比如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dataSource</span> <span class=attr>type</span>=<span class=string>"POOLED"</span>></span></span><br><span class=line>  <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"driver"</span> <span class=attr>value</span>=<span class=string>"${driver}"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"url"</span> <span class=attr>value</span>=<span class=string>"${url}"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"username"</span> <span class=attr>value</span>=<span class=string>"${username}"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"password"</span> <span class=attr>value</span>=<span class=string>"${password}"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>dataSource</span>></span></span><br></pre></table></figure><p>这个例子中的 username 和 password 将会由 properties 元素中设置的相应值来替换。 driver 和 url 属性将会由 config.properties 文件中对应的值来替换。这样就为配置提供了诸多灵活选择。<p><strong>注意</strong>：如果一个属性在不只一个地方进行了配置，那么，MyBatis 将按照下面的顺序来加载：<ol><li>首先读取在 properties 元素体内指定的属性。(优先级1-最低)<li>然后根据 properties 元素中的 resource 属性读取类路径下属性文件，或根据 url 属性指定的路径读取属性文件，并覆盖之前读取过的同名属性。（优先级2）<li>最后读取作为方法参数传递的属性，并覆盖之前读取过的同名属性。（优先级3-最高）</ol><p>因此，通过方法参数传递的属性具有最高优先级，resource/url 属性中指定的配置文件次之，最低优先级的则是 properties 元素中指定的属性。<h2 id=4-2、settings（设置）><a class=headerlink href=#4-2、settings（设置） title=4.2、settings（设置）></a>4.2、settings（设置）</h2><p>这是<code>MyBatis</code>极为重要的设置，它们会改变<code>MyBatis</code>的运行时行为。 下表描述了各项设置的含义、默认值等。<table><thead><tr><th align=center>设置名<th>描述<th align=left>有效值<th align=left>默认值<tbody><tr><td align=center>cacheEnabled<td>全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。<td align=left>true | false<td align=left>true<tr><td align=center>lazyLoadingEnabled<td>延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 <code>fetchType</code> 属性来覆盖该项的开关状态。<td align=left>true | false<td align=left>false<tr><td align=center>aggressiveLazyLoading<td>开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载（参考 <code>lazyLoadTriggerMethods</code>)。<td align=left>true | false<td align=left>false （在 3.4.1 及之前的版本中默认为 true）<tr><td align=center>multipleResultSetsEnabled<td>是否允许单个语句返回多结果集（需要数据库驱动支持）。<td align=left>true | false<td align=left>true<tr><td align=center>useColumnLabel<td>使用列标签代替列名。实际表现依赖于数据库驱动，具体可参考数据库驱动的相关文档，或通过对比测试来观察。<td align=left>true | false<td align=left>true<tr><td align=center>useGeneratedKeys<td>允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby）。<td align=left>true | false<td align=left>False<tr><td align=center>autoMappingBehavior<td>指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。<td align=left>NONE, PARTIAL, FULL<td align=left>PARTIAL<tr><td align=center>autoMappingUnknownColumnBehavior<td>指定发现自动映射目标未知列（或未知属性类型）的行为。<code>NONE</code>: 不做任何反应<code>WARNING</code>: 输出警告日志（<code>'org.apache.ibatis.session.AutoMappingUnknownColumnBehavior'</code> 的日志等级必须设置为 <code>WARN</code>）<code>FAILING</code>: 映射失败 (抛出 <code>SqlSessionException</code>)<td align=left>NONE, WARNING, FAILING<td align=left>NONE<tr><td align=center>defaultExecutorType<td>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（PreparedStatement）； BATCH 执行器不仅重用语句还会执行批量更新。<td align=left>SIMPLE REUSE BATCH<td align=left>SIMPLE<tr><td align=center>defaultStatementTimeout<td>设置超时时间，它决定数据库驱动等待数据库响应的秒数。<td align=left>任意正整数<td align=left>未设置 (null)<tr><td align=center>defaultFetchSize<td>为驱动的结果集获取数量（fetchSize）设置一个建议值。此参数只可以在查询设置中被覆盖。<td align=left>任意正整数<td align=left>未设置 (null)<tr><td align=center>defaultResultSetType<td>指定语句默认的滚动策略。（新增于 3.5.2）<td align=left>FORWARD_ONLY | SCROLL_SENSITIVE | SCROLL_INSENSITIVE | DEFAULT（等同于未设置）<td align=left>未设置 (null)<tr><td align=center>safeRowBoundsEnabled<td>是否允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。<td align=left>true | false<td align=left>False<tr><td align=center>safeResultHandlerEnabled<td>是否允许在嵌套语句中使用结果处理器（ResultHandler）。如果允许使用则设置为 false。<td align=left>true | false<td align=left>True<tr><td align=center>mapUnderscoreToCamelCase<td>是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。<td align=left>true | false<td align=left>False<tr><td align=center>localCacheScope<td>MyBatis 利用本地缓存机制（Local Cache）防止循环引用和加速重复的嵌套查询。 默认值为 SESSION，会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地缓存将仅用于执行语句，对相同 SqlSession 的不同查询将不会进行缓存。<td align=left>SESSION | STATEMENT<td align=left>SESSION<tr><td align=center>jdbcTypeForNull<td>当没有为参数指定特定的 JDBC 类型时，空值的默认 JDBC 类型。 某些数据库驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。<td align=left>JdbcType 常量，常用值：NULL、VARCHAR 或 OTHER。<td align=left>OTHER<tr><td align=center>lazyLoadTriggerMethods<td>指定对象的哪些方法触发一次延迟加载。<td align=left>用逗号分隔的方法列表。<td align=left>equals,clone,hashCode,toString<tr><td align=center>defaultScriptingLanguage<td>指定动态 SQL 生成使用的默认脚本语言。<td align=left>一个类型别名或全限定类名。<td align=left>org.apache.ibatis.scripting.xmltags.XMLLanguageDriver<tr><td align=center>defaultEnumTypeHandler<td>指定 Enum 使用的默认 <code>TypeHandler</code> 。（新增于 3.4.5）<td align=left>一个类型别名或全限定类名。<td align=left>org.apache.ibatis.type.EnumTypeHandler<tr><td align=center>callSettersOnNulls<td>指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这在依赖于 Map.keySet() 或 null 值进行初始化时比较有用。注意基本类型（int、boolean 等）是不能设置成 null 的。<td align=left>true | false<td align=left>false<tr><td align=center>returnInstanceForEmptyRow<td>当返回行的所有列都是空时，MyBatis默认返回 <code>null</code>。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集（如集合或关联）。（新增于 3.4.2）<td align=left>true | false<td align=left>false<tr><td align=center>logPrefix<td>指定 MyBatis 增加到日志名称的前缀。<td align=left>任何字符串<td align=left>未设置<tr><td align=center>logImpl<td>指定 MyBatis 所用日志的具体实现，未指定时将自动查找。<td align=left>SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING<td align=left>未设置<tr><td align=center>proxyFactory<td>指定 Mybatis 创建可延迟加载对象所用到的代理工具。<td align=left>CGLIB | JAVASSIST<td align=left>JAVASSIST （MyBatis 3.3 以上）<tr><td align=center>vfsImpl<td>指定 VFS 的实现<td align=left>自定义 VFS 的实现的类全限定名，以逗号分隔。<td align=left>未设置<tr><td align=center>useActualParamName<td>允许使用方法签名中的名称作为语句参数名称。 为了使用该特性，你的项目必须采用 Java 8 编译，并且加上 <code>-parameters</code> 选项。（新增于 3.4.1）<td align=left>true | false<td align=left>true<tr><td align=center>configurationFactory<td>指定一个提供 <code>Configuration</code> 实例的类。 这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。 这个类必须包含一个签名为<code>static Configuration getConfiguration()</code> 的方法。（新增于 3.2.3）<td align=left>一个类型别名或完全限定类名。<td align=left>未设置<tr><td align=center>shrinkWhitespacesInSql<td>Removes extra whitespace characters from the SQL. Note that this also affects literal strings in SQL. (Since 3.5.5)<td align=left>true | false<td align=left>false</table><p>一个配置完整的<code>settings</code>元素的示例如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>settings</span>></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"cacheEnabled"</span> <span class=attr>value</span>=<span class=string>"true"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"lazyLoadingEnabled"</span> <span class=attr>value</span>=<span class=string>"true"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"multipleResultSetsEnabled"</span> <span class=attr>value</span>=<span class=string>"true"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"useColumnLabel"</span> <span class=attr>value</span>=<span class=string>"true"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"useGeneratedKeys"</span> <span class=attr>value</span>=<span class=string>"false"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"autoMappingBehavior"</span> <span class=attr>value</span>=<span class=string>"PARTIAL"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"autoMappingUnknownColumnBehavior"</span> <span class=attr>value</span>=<span class=string>"WARNING"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"defaultExecutorType"</span> <span class=attr>value</span>=<span class=string>"SIMPLE"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"defaultStatementTimeout"</span> <span class=attr>value</span>=<span class=string>"25"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"defaultFetchSize"</span> <span class=attr>value</span>=<span class=string>"100"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"safeRowBoundsEnabled"</span> <span class=attr>value</span>=<span class=string>"false"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"mapUnderscoreToCamelCase"</span> <span class=attr>value</span>=<span class=string>"false"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"localCacheScope"</span> <span class=attr>value</span>=<span class=string>"SESSION"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"jdbcTypeForNull"</span> <span class=attr>value</span>=<span class=string>"OTHER"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>setting</span> <span class=attr>name</span>=<span class=string>"lazyLoadTriggerMethods"</span> <span class=attr>value</span>=<span class=string>"equals,clone,hashCode,toString"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>settings</span>></span></span><br></pre></table></figure><h2 id=4-3、typeAliases（类型别名）><a class=headerlink href=#4-3、typeAliases（类型别名） title=4.3、typeAliases（类型别名）></a>4.3、typeAliases（类型别名）</h2><p>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>typeAliases</span>></span></span><br><span class=line>  <span class=tag><<span class=name>typeAlias</span> <span class=attr>alias</span>=<span class=string>"Author"</span> <span class=attr>type</span>=<span class=string>"domain.blog.Author"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>typeAlias</span> <span class=attr>alias</span>=<span class=string>"Blog"</span> <span class=attr>type</span>=<span class=string>"domain.blog.Blog"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>typeAlias</span> <span class=attr>alias</span>=<span class=string>"Comment"</span> <span class=attr>type</span>=<span class=string>"domain.blog.Comment"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>typeAlias</span> <span class=attr>alias</span>=<span class=string>"Post"</span> <span class=attr>type</span>=<span class=string>"domain.blog.Post"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>typeAlias</span> <span class=attr>alias</span>=<span class=string>"Section"</span> <span class=attr>type</span>=<span class=string>"domain.blog.Section"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>typeAlias</span> <span class=attr>alias</span>=<span class=string>"Tag"</span> <span class=attr>type</span>=<span class=string>"domain.blog.Tag"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>typeAliases</span>></span></span><br></pre></table></figure><p>当这样配置时，<code>Blog</code> 可以用在任何使用 <code>domain.blog.Blog</code> 的地方。<p>也可以指定一个包名，<code>MyBatis</code>会在包名下面搜索需要的<code>Java Bean</code>，比如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>typeAliases</span>></span></span><br><span class=line>  <span class=tag><<span class=name>package</span> <span class=attr>name</span>=<span class=string>"domain.blog"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>typeAliases</span>></span></span><br></pre></table></figure><p>每一个在包 <code>domain.blog</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>；若有注解，则别名为其注解值。见下面的例子：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Alias("author")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Author</span> {</span><br><span class=line>    <span class=comment>//...</span></span><br><span class=line>}</span><br></pre></table></figure><p>下面是一些为常见的 Java 类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。<table><thead><tr><th align=right>别名<th align=left>映射的类型<tbody><tr><td align=right>_byte<td align=left>byte<tr><td align=right>_long<td align=left>long<tr><td align=right>_short<td align=left>short<tr><td align=right>_int<td align=left>int<tr><td align=right>_integer<td align=left>int<tr><td align=right>_double<td align=left>double<tr><td align=right>_float<td align=left>float<tr><td align=right>_boolean<td align=left>boolean<tr><td align=right>string<td align=left>String<tr><td align=right>byte<td align=left>Byte<tr><td align=right>long<td align=left>Long<tr><td align=right>short<td align=left>Short<tr><td align=right>int<td align=left>Integer<tr><td align=right>integer<td align=left>Integer<tr><td align=right>double<td align=left>Double<tr><td align=right>float<td align=left>Float<tr><td align=right>boolean<td align=left>Boolean<tr><td align=right>date<td align=left>Date<tr><td align=right>decimal<td align=left>BigDecimal<tr><td align=right>bigdecimal<td align=left>BigDecimal<tr><td align=right>object<td align=left>Object<tr><td align=right>map<td align=left>Map<tr><td align=right>hashmap<td align=left>HashMap<tr><td align=right>list<td align=left>List<tr><td align=right>arraylist<td align=left>ArrayList<tr><td align=right>collection<td align=left>Collection<tr><td align=right>iterator<td align=left>Iterator</table><h2 id=4-4、typeHandlers（类型处理器）><a class=headerlink href=#4-4、typeHandlers（类型处理器） title=4.4、typeHandlers（类型处理器）></a>4.4、typeHandlers（类型处理器）</h2><p>MyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器。<p><strong>提示</strong>： 从 3.4.5 开始，MyBatis 默认支持 JSR-310（日期和时间 API） 。<table><thead><tr><th align=center>类型处理器<th align=left>Java 类型<th align=left>JDBC 类型<tbody><tr><td align=center><code>BooleanTypeHandler</code><td align=left><code>java.lang.Boolean</code>, <code>boolean</code><td align=left>数据库兼容的 <code>BOOLEAN</code><tr><td align=center><code>ByteTypeHandler</code><td align=left><code>java.lang.Byte</code>, <code>byte</code><td align=left>数据库兼容的 <code>NUMERIC</code> 或 <code>BYTE</code><tr><td align=center><code>ShortTypeHandler</code><td align=left><code>java.lang.Short</code>, <code>short</code><td align=left>数据库兼容的 <code>NUMERIC</code> 或 <code>SMALLINT</code><tr><td align=center><code>IntegerTypeHandler</code><td align=left><code>java.lang.Integer</code>, <code>int</code><td align=left>数据库兼容的 <code>NUMERIC</code> 或 <code>INTEGER</code><tr><td align=center><code>LongTypeHandler</code><td align=left><code>java.lang.Long</code>, <code>long</code><td align=left>数据库兼容的 <code>NUMERIC</code> 或 <code>BIGINT</code><tr><td align=center><code>FloatTypeHandler</code><td align=left><code>java.lang.Float</code>, <code>float</code><td align=left>数据库兼容的 <code>NUMERIC</code> 或 <code>FLOAT</code><tr><td align=center><code>DoubleTypeHandler</code><td align=left><code>java.lang.Double</code>, <code>double</code><td align=left>数据库兼容的 <code>NUMERIC</code> 或 <code>DOUBLE</code><tr><td align=center><code>BigDecimalTypeHandler</code><td align=left><code>java.math.BigDecimal</code><td align=left>数据库兼容的 <code>NUMERIC</code> 或 <code>DECIMAL</code><tr><td align=center><code>StringTypeHandler</code><td align=left><code>java.lang.String</code><td align=left><code>CHAR</code>, <code>VARCHAR</code><tr><td align=center><code>ClobReaderTypeHandler</code><td align=left><code>java.io.Reader</code><td align=left>-<tr><td align=center><code>ClobTypeHandler</code><td align=left><code>java.lang.String</code><td align=left><code>CLOB</code>, <code>LONGVARCHAR</code><tr><td align=center><code>NStringTypeHandler</code><td align=left><code>java.lang.String</code><td align=left><code>NVARCHAR</code>, <code>NCHAR</code><tr><td align=center><code>NClobTypeHandler</code><td align=left><code>java.lang.String</code><td align=left><code>NCLOB</code><tr><td align=center><code>BlobInputStreamTypeHandler</code><td align=left><code>java.io.InputStream</code><td align=left>-<tr><td align=center><code>ByteArrayTypeHandler</code><td align=left><code>byte[]</code><td align=left>数据库兼容的字节流类型<tr><td align=center><code>BlobTypeHandler</code><td align=left><code>byte[]</code><td align=left><code>BLOB</code>, <code>LONGVARBINARY</code><tr><td align=center><code>DateTypeHandler</code><td align=left><code>java.util.Date</code><td align=left><code>TIMESTAMP</code><tr><td align=center><code>DateOnlyTypeHandler</code><td align=left><code>java.util.Date</code><td align=left><code>DATE</code><tr><td align=center><code>TimeOnlyTypeHandler</code><td align=left><code>java.util.Date</code><td align=left><code>TIME</code><tr><td align=center><code>SqlTimestampTypeHandler</code><td align=left><code>java.sql.Timestamp</code><td align=left><code>TIMESTAMP</code><tr><td align=center><code>SqlDateTypeHandler</code><td align=left><code>java.sql.Date</code><td align=left><code>DATE</code><tr><td align=center><code>SqlTimeTypeHandler</code><td align=left><code>java.sql.Time</code><td align=left><code>TIME</code><tr><td align=center><code>ObjectTypeHandler</code><td align=left>Any<td align=left><code>OTHER</code> 或未指定类型<tr><td align=center><code>EnumTypeHandler</code><td align=left>Enumeration Type<td align=left>VARCHAR 或任何兼容的字符串类型，用来存储枚举的名称（而不是索引序数值）<tr><td align=center><code>EnumOrdinalTypeHandler</code><td align=left>Enumeration Type<td align=left>任何兼容的 <code>NUMERIC</code> 或 <code>DOUBLE</code> 类型，用来存储枚举的序数值（而不是名称）。<tr><td align=center><code>SqlxmlTypeHandler</code><td align=left><code>java.lang.String</code><td align=left><code>SQLXML</code><tr><td align=center><code>InstantTypeHandler</code><td align=left><code>java.time.Instant</code><td align=left><code>TIMESTAMP</code><tr><td align=center><code>LocalDateTimeTypeHandler</code><td align=left><code>java.time.LocalDateTime</code><td align=left><code>TIMESTAMP</code><tr><td align=center><code>LocalDateTypeHandler</code><td align=left><code>java.time.LocalDate</code><td align=left><code>DATE</code><tr><td align=center><code>LocalTimeTypeHandler</code><td align=left><code>java.time.LocalTime</code><td align=left><code>TIME</code><tr><td align=center><code>OffsetDateTimeTypeHandler</code><td align=left><code>java.time.OffsetDateTime</code><td align=left><code>TIMESTAMP</code><tr><td align=center><code>OffsetTimeTypeHandler</code><td align=left><code>java.time.OffsetTime</code><td align=left><code>TIME</code><tr><td align=center><code>ZonedDateTimeTypeHandler</code><td align=left><code>java.time.ZonedDateTime</code><td align=left><code>TIMESTAMP</code><tr><td align=center><code>YearTypeHandler</code><td align=left><code>java.time.Year</code><td align=left><code>INTEGER</code><tr><td align=center><code>MonthTypeHandler</code><td align=left><code>java.time.Month</code><td align=left><code>INTEGER</code><tr><td align=center><code>YearMonthTypeHandler</code><td align=left><code>java.time.YearMonth</code><td align=left><code>VARCHAR</code> 或 <code>LONGVARCHAR</code><tr><td align=center><code>JapaneseDateTypeHandler</code><td align=left><code>java.time.chrono.JapaneseDate</code><td align=left><code>DATE</code></table><p>你可以重写已有的类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。 具体做法为：实现 <code>org.apache.ibatis.type.TypeHandler</code> 接口， 或继承一个很便利的类 <code>org.apache.ibatis.type.BaseTypeHandler</code>， 并且可以（可选地）将它映射到一个 JDBC 类型。比如：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=meta>@MappedJdbcTypes(JdbcType.VARCHAR)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleTypeHandler</span> <span class=keyword>extends</span> <span class="title class_">BaseTypeHandler</span>&LTString> {</span><br><span class=line>  <span class=meta>@Override</span></span><br><span class=line>  <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setNonNullParameter</span><span class=params>(PreparedStatement ps, <span class=type>int</span> i, String parameter, JdbcType jdbcType)</span> <span class=keyword>throws</span> SQLException {</span><br><span class=line>    ps.setString(i, parameter);</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=meta>@Override</span></span><br><span class=line>  <span class=keyword>public</span> String <span class="title function_">getNullableResult</span><span class=params>(ResultSet rs, String columnName)</span> <span class=keyword>throws</span> SQLException {</span><br><span class=line>    <span class=keyword>return</span> rs.getString(columnName);</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=meta>@Override</span></span><br><span class=line>  <span class=keyword>public</span> String <span class="title function_">getNullableResult</span><span class=params>(ResultSet rs, <span class=type>int</span> columnIndex)</span> <span class=keyword>throws</span> SQLException {</span><br><span class=line>    <span class=keyword>return</span> rs.getString(columnIndex);</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  <span class=meta>@Override</span></span><br><span class=line>  <span class=keyword>public</span> String <span class="title function_">getNullableResult</span><span class=params>(CallableStatement cs, <span class=type>int</span> columnIndex)</span> <span class=keyword>throws</span> SQLException {</span><br><span class=line>    <span class=keyword>return</span> cs.getString(columnIndex);</span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><p>mybatis-config.xml<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>typeHandlers</span>></span></span><br><span class=line>  <span class=tag><<span class=name>typeHandler</span> <span class=attr>handler</span>=<span class=string>"org.mybatis.example.ExampleTypeHandler"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>typeHandlers</span>></span></span><br></pre></table></figure><h2 id=4-5、处理枚举类型><a class=headerlink href=#4-5、处理枚举类型 title=4.5、处理枚举类型></a>4.5、处理枚举类型</h2><p>若想映射枚举类型 <code>Enum</code>，则需要从 <code>EnumTypeHandler</code> 或者 <code>EnumOrdinalTypeHandler</code> 中选择一个来使用。<p>比如说我们想存储取近似值时用到的舍入模式。默认情况下，MyBatis 会利用 <code>EnumTypeHandler</code> 来把 <code>Enum</code> 值转换成对应的名字。<p><strong>注意</strong>： <code>EnumTypeHandler</code> 在某种意义上来说是比较特别的，其它的处理器只针对某个特定的类，而它不同，它会处理任意继承了 <code>Enum</code> 的类。<p>不过，我们可能不想存储名字，相反我们的 DBA 会坚持使用整形值代码。那也一样简单：在配置文件中把 <code>EnumOrdinalTypeHandler</code> 加到 <code>typeHandlers</code> 中即可， 这样每个 <code>RoundingMode</code> 将通过他们的序数值来映射成对应的整形数值。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- mybatis-config.xml --></span></span><br><span class=line><span class=tag><<span class=name>typeHandlers</span>></span></span><br><span class=line>  <span class=tag><<span class=name>typeHandler</span> <span class=attr>handler</span>=<span class=string>"org.apache.ibatis.type.EnumOrdinalTypeHandler"</span> <span class=attr>javaType</span>=<span class=string>"java.math.RoundingMode"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>typeHandlers</span>></span></span><br></pre></table></figure><p>但要是你想在一个地方将 <code>Enum</code> 映射成字符串，在另外一个地方映射成整形值呢？<p>自动映射器（auto-mapper）会自动地选用 <code>EnumOrdinalTypeHandler</code> 来处理枚举类型， 所以如果我们想用普通的 <code>EnumTypeHandler</code>，就必须要显式地为那些 SQL 语句设置要使用的类型处理器。<h2 id=4-6、objectFactory（对象工厂）><a class=headerlink href=#4-6、objectFactory（对象工厂） title=4.6、objectFactory（对象工厂）></a>4.6、objectFactory（对象工厂）</h2><p>每次 MyBatis 创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成实例化工作。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认无参构造方法，要么通过存在的参数映射来调用带有参数的构造方法。 如果想覆盖对象工厂的默认行为，可以通过创建自己的对象工厂来实现。比如：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=comment>// ExampleObjectFactory.java</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExampleObjectFactory</span> <span class=keyword>extends</span> <span class="title class_">DefaultObjectFactory</span> {</span><br><span class=line>  <span class=keyword>public</span> Object <span class="title function_">create</span><span class=params>(Class type)</span> {</span><br><span class=line>    <span class=keyword>return</span> <span class=built_in>super</span>.create(type);</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>public</span> Object <span class="title function_">create</span><span class=params>(Class type, List&LTClass> constructorArgTypes, List&LTObject> constructorArgs)</span> {</span><br><span class=line>    <span class=keyword>return</span> <span class=built_in>super</span>.create(type, constructorArgTypes, constructorArgs);</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setProperties</span><span class=params>(Properties properties)</span> {</span><br><span class=line>    <span class=built_in>super</span>.setProperties(properties);</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>public</span> &LTT> <span class=type>boolean</span> <span class="title function_">isCollection</span><span class=params>(Class&LTT> type)</span> {</span><br><span class=line>    <span class=keyword>return</span> Collection.class.isAssignableFrom(type);</span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- mybatis-config.xml --></span></span><br><span class=line><span class=tag><<span class=name>objectFactory</span> <span class=attr>type</span>=<span class=string>"org.mybatis.example.ExampleObjectFactory"</span>></span></span><br><span class=line>  <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"someProperty"</span> <span class=attr>value</span>=<span class=string>"100"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>objectFactory</span>></span></span><br></pre></table></figure><p>ObjectFactory 接口很简单，它包含两个创建实例用的方法，一个是处理默认无参构造方法的，另外一个是处理带参数的构造方法的。 另外，setProperties 方法可以被用来配置 ObjectFactory，在初始化你的 ObjectFactory 实例后， objectFactory 元素体中定义的属性会被传递给 setProperties 方法。<h2 id=4-7、plugins（插件）><a class=headerlink href=#4-7、plugins（插件） title=4.7、plugins（插件）></a>4.7、plugins（插件）</h2><p>MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：<ul><li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)<li>ParameterHandler (getParameterObject, setParameters)<li>ResultSetHandler (handleResultSets, handleOutputParameters)<li>StatementHandler (prepare, parameterize, batch, update, query)</ul><p>这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码。 如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。 因为在试图修改或重写已有方法的行为时，很可能会破坏 MyBatis 的核心模块。 这些都是更底层的类和方法，所以使用插件的时候要特别当心。<p>通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=comment>// ExamplePlugin.java</span></span><br><span class=line><span class=meta>@Intercepts({@Signature(</span></span><br><span class=line><span class=meta>  type= Executor.class,</span></span><br><span class=line><span class=meta>  method = "update",</span></span><br><span class=line><span class=meta>  args = {MappedStatement.class,Object.class})})</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ExamplePlugin</span> <span class=keyword>implements</span> <span class="title class_">Interceptor</span> {</span><br><span class=line>  <span class=keyword>private</span> <span class=type>Properties</span> <span class=variable>properties</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Properties</span>();</span><br><span class=line>  <span class=keyword>public</span> Object <span class="title function_">intercept</span><span class=params>(Invocation invocation)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>    <span class=comment>// implement pre processing if need</span></span><br><span class=line>    <span class=type>Object</span> <span class=variable>returnObject</span> <span class=operator>=</span> invocation.proceed();</span><br><span class=line>    <span class=comment>// implement post processing if need</span></span><br><span class=line>    <span class=keyword>return</span> returnObject;</span><br><span class=line>  }</span><br><span class=line>  <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setProperties</span><span class=params>(Properties properties)</span> {</span><br><span class=line>    <span class=built_in>this</span>.properties = properties;</span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- mybatis-config.xml --></span></span><br><span class=line><span class=tag><<span class=name>plugins</span>></span></span><br><span class=line>  <span class=tag><<span class=name>plugin</span> <span class=attr>interceptor</span>=<span class=string>"org.mybatis.example.ExamplePlugin"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"someProperty"</span> <span class=attr>value</span>=<span class=string>"100"</span>/></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>plugin</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>plugins</span>></span></span><br></pre></table></figure><p>上面的插件将会拦截在 Executor 实例中所有的 “update” 方法调用， 这里的 Executor 是负责执行底层映射语句的内部对象。<p><strong>覆盖配置类</strong>：除了用插件来修改 MyBatis 核心行为以外，还可以通过完全覆盖配置类来达到目的。只需继承配置类后覆盖其中的某个方法，再把它传递到 SqlSessionFactoryBuilder.build(myConfig) 方法即可。再次重申，这可能会极大影响 MyBatis 的行为，务请慎之又慎。<h2 id=4-8、environments（环境配置><a class=headerlink href=#4-8、environments（环境配置 title=4.8、environments（环境配置)></a>4.8、environments（环境配置)</h2><p>MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema 的多个生产数据库中使用相同的 SQL 映射。还有许多类似的使用场景。<p>为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。可以接受环境配置的两个方法签名是：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>SqlSessionFactory</span> <span class=variable>factory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader, environment);</span><br><span class=line><span class=type>SqlSessionFactory</span> <span class=variable>factory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader, environment, properties);</span><br></pre></table></figure><p>如果忽略了环境参数，那么将会加载默认环境，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>SqlSessionFactory</span> <span class=variable>factory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader);</span><br><span class=line><span class=type>SqlSessionFactory</span> <span class=variable>factory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader, properties);</span><br></pre></table></figure><p>environments 元素定义了如何配置环境。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line>&LTenvironments <span class=keyword>default</span>=<span class=string>"development"</span>></span><br><span class=line>  &LTenvironment id=<span class=string>"development"</span>></span><br><span class=line>    &LTtransactionManager type=<span class=string>"JDBC"</span>></span><br><span class=line>      &LTproperty name=<span class=string>"..."</span> value=<span class=string>"..."</span>/></span><br><span class=line>    &LT/transactionManager></span><br><span class=line>    &LTdataSource type=<span class=string>"POOLED"</span>></span><br><span class=line>      &LTproperty name=<span class=string>"driver"</span> value=<span class=string>"${driver}"</span>/></span><br><span class=line>      &LTproperty name=<span class=string>"url"</span> value=<span class=string>"${url}"</span>/></span><br><span class=line>      &LTproperty name=<span class=string>"username"</span> value=<span class=string>"${username}"</span>/></span><br><span class=line>      &LTproperty name=<span class=string>"password"</span> value=<span class=string>"${password}"</span>/></span><br><span class=line>    &LT/dataSource></span><br><span class=line>  &LT/environment></span><br><span class=line>&LT/environments></span><br></pre></table></figure><p>注意事项：<ol><li>每个 SqlSessionFactory 实例只能选择一种环境。<li>每个数据库对应一个 SqlSessionFactory 实例。<li>默认使用的环境 ID（比如：default=”development”）。<li>每个 environment 元素定义的环境 ID（比如：id=”development”）。<li>事务管理器的配置（比如：type=”JDBC”）。<li>数据源的配置（比如：type=”POOLED”）。</ol><ul><li><p>事务管理器（transactionManager）</p> <p>在 MyBatis 中有两种类型的事务管理器（也就是 type=”[JDBC|MANAGED]”）：</p> <ul><li><p>JDBC – 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。</p><li><p>MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为。例如:</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>transactionManager</span> <span class=attr>type</span>=<span class=string>"MANAGED"</span>></span></span><br><span class=line>  <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"closeConnection"</span> <span class=attr>value</span>=<span class=string>"false"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>transactionManager</span>></span></span><br></pre></table></figure></ul> <p><strong>注意</strong>：如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器，因为 Spring 模块会使用自带的管理器来覆盖前面的配置。</p><li><p>数据源（dataSource）</p> <p>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。大多数 MyBatis 应用程序会按示例中的例子来配置数据源。虽然数据源配置是可选的，但如果要启用延迟加载特性，就必须配置数据源。</p> <p>有三种内建的数据源类型（也就是 type=”[UNPOOLED|POOLED|JNDI]”）：</p> <ol><li><p><strong>UNPOOLED</strong>——这个数据源的实现会每次请求时打开和关闭连接。虽然有点慢，但对那些数据库连接可用性要求不高的简单应用程序来说，是一个很好的选择。 性能表现则依赖于使用的数据库，对某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形。</p><li><p><strong>POOLED</strong>——这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这种处理方式很流行，能使并发 Web 应用快速响应请求。</p><li><p><strong>JNDI</strong>——这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。这种数据源配置只需要两个属性：</p> <ul><li><code>initial_context</code> – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么将会直接从 InitialContext中寻找 data_source属性。<li><code>data_source</code> – 这是引用数据源实例位置的上下文路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在InitialContext中查找。</ul> <p>和其他数据源配置类似，可以通过添加前缀“env.”直接把属性传递给 InitialContext。比如：</p> <ul><li><code>env.encoding=UTF8</code></ul><li><p>你可以通过实现接口 <code>org.apache.ibatis.datasource.DataSourceFactory</code> 来使用第三方数据源实现：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">DataSourceFactory</span> {</span><br><span class=line>  <span class=keyword>void</span> <span class="title function_">setProperties</span><span class=params>(Properties props)</span>;</span><br><span class=line>  DataSource <span class="title function_">getDataSource</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure> <ul><li><p>C3P0数据源实现：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory;</span><br><span class=line><span class=keyword>import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">C3P0DataSourceFactory</span> <span class=keyword>extends</span> <span class="title class_">UnpooledDataSourceFactory</span> {</span><br><span class=line>  <span class=keyword>public</span> <span class="title function_">C3P0DataSourceFactory</span><span class=params>()</span> {</span><br><span class=line>    <span class=built_in>this</span>.dataSource = <span class=keyword>new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure></ul></ol></ul><p>为了令其工作，记得在配置文件中为每个希望 MyBatis 调用的 setter 方法增加对应的属性。 下面是一个可以连接至 PostgreSQL 数据库的例子：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dataSource</span> <span class=attr>type</span>=<span class=string>"org.myproject.C3P0DataSourceFactory"</span>></span></span><br><span class=line>  <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"driver"</span> <span class=attr>value</span>=<span class=string>"org.postgresql.Driver"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"url"</span> <span class=attr>value</span>=<span class=string>"jdbc:postgresql:mydb"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"username"</span> <span class=attr>value</span>=<span class=string>"postgres"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"password"</span> <span class=attr>value</span>=<span class=string>"root"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>dataSource</span>></span></span><br></pre></table></figure><h2 id=4-9、mapper（映射器）><a class=headerlink href=#4-9、mapper（映射器） title=4.9、mapper（映射器）></a>4.9、mapper（映射器）</h2><p>我们现在就要来定义 SQL 映射语句了。 但首先，我们需要告诉 MyBatis 到哪里去找到这些语句。 在自动查找资源方面，Java 并没有提供一个很好的解决方案，所以最好的办法是直接告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 <code>file:///</code> 形式的 URL），或类名和包名等。例如：<h3 id=4-9-1、相对于类路径><a class=headerlink href=#4-9-1、相对于类路径 title=4.9.1、相对于类路径></a>4.9.1、相对于类路径</h3><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- 使用相对于类路径的资源引用 --></span></span><br><span class=line><span class=tag><<span class=name>mappers</span>></span></span><br><span class=line>  <span class=tag><<span class=name>mapper</span> <span class=attr>resource</span>=<span class=string>"org/mybatis/builder/AuthorMapper.xml"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>mapper</span> <span class=attr>resource</span>=<span class=string>"org/mybatis/builder/BlogMapper.xml"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>mapper</span> <span class=attr>resource</span>=<span class=string>"org/mybatis/builder/PostMapper.xml"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>mappers</span>></span></span><br></pre></table></figure><h3 id=4-9-2、完全限定资源定位符><a class=headerlink href=#4-9-2、完全限定资源定位符 title=4.9.2、完全限定资源定位符></a>4.9.2、完全限定资源定位符</h3><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- 使用完全限定资源定位符（URL） --></span></span><br><span class=line><span class=tag><<span class=name>mappers</span>></span></span><br><span class=line>  <span class=tag><<span class=name>mapper</span> <span class=attr>url</span>=<span class=string>"file:///var/mappers/AuthorMapper.xml"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>mapper</span> <span class=attr>url</span>=<span class=string>"file:///var/mappers/BlogMapper.xml"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>mapper</span> <span class=attr>url</span>=<span class=string>"file:///var/mappers/PostMapper.xml"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>mappers</span>></span></span><br></pre></table></figure><h3 id=4-9-3、映射器接口实现类的完全限定类名><a class=headerlink href=#4-9-3、映射器接口实现类的完全限定类名 title=4.9.3、映射器接口实现类的完全限定类名></a>4.9.3、映射器接口实现类的完全限定类名</h3><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- 使用映射器接口实现类的完全限定类名 --></span></span><br><span class=line><span class=tag><<span class=name>mappers</span>></span></span><br><span class=line>  <span class=tag><<span class=name>mapper</span> <span class=attr>class</span>=<span class=string>"org.mybatis.builder.AuthorMapper"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>mapper</span> <span class=attr>class</span>=<span class=string>"org.mybatis.builder.BlogMapper"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>mapper</span> <span class=attr>class</span>=<span class=string>"org.mybatis.builder.PostMapper"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>mappers</span>></span></span><br></pre></table></figure><h3 id=4-9-4、映射器接口实现-注册为映射器><a title="4.9.4、映射器接口实现 注册为映射器" class=headerlink href=#4-9-4、映射器接口实现-注册为映射器></a>4.9.4、映射器接口实现 注册为映射器</h3><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- 将包内的映射器接口实现全部注册为映射器 --></span></span><br><span class=line><span class=tag><<span class=name>mappers</span>></span></span><br><span class=line>  <span class=tag><<span class=name>package</span> <span class=attr>name</span>=<span class=string>"org.mybatis.builder"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>mappers</span>></span></span><br></pre></table></figure><h1 id=5、XML映射文件><a class=headerlink href=#5、XML映射文件 title=5、XML映射文件></a>5、XML映射文件</h1><h2 id=5-1、前言><a class=headerlink href=#5-1、前言 title=5.1、前言></a>5.1、前言</h2><p>MyBatis 的真正强大在于它的语句映射，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 致力于减少使用成本，让用户能更专注于 SQL 代码。<p>SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：<ul><li><code>cache</code> – 该命名空间的缓存配置。<li><code>cache-ref</code> – 引用其它命名空间的缓存配置。<li><code>resultMap</code> – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。<li><code>parameterMap</code> – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。（已废弃，不做讨论）<li><code>sql</code> – 可被其它语句引用的可重用语句块。<li><code>insert</code> – 映射插入语句。<li><code>update</code> – 映射更新语句。<li><code>delete</code> – 映射删除语句。<li><code>select</code> – 映射查询语句。</ul><h2 id=5-2、Cache（缓存）><a class=headerlink href=#5-2、Cache（缓存） title=5.2、Cache（缓存）></a>5.2、Cache（缓存）</h2><p>MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。 默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存。 要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>cache</span>/></span></span><br></pre></table></figure><p>基本上就是这样。这个简单语句的效果如下:<ul><li>映射语句文件中的所有 select 语句的结果将会被缓存。<li>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。<li>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。<li>缓存不会定时进行刷新（也就是说，没有刷新间隔）。<li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。<li>缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</ul><p><strong>注意：</strong> 缓存只作用于 cache 标签所在的映射文件中的语句。如果你混合使用 Java API 和 XML 映射文件，在共用接口中的语句将不会被默认缓存。你需要使用 @CacheNamespaceRef 注解指定缓存作用域。<p>这些属性可以通过 cache 元素的属性来修改。比如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>cache</span></span></span><br><span class=line><span class=tag>  <span class=attr>eviction</span>=<span class=string>"FIFO"</span></span></span><br><span class=line><span class=tag>  <span class=attr>flushInterval</span>=<span class=string>"60000"</span></span></span><br><span class=line><span class=tag>  <span class=attr>size</span>=<span class=string>"512"</span></span></span><br><span class=line><span class=tag>  <span class=attr>readOnly</span>=<span class=string>"true"</span>/></span></span><br></pre></table></figure><p>这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。<p>可用的清除策略有：<ul><li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象。<li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们。<li><code>SOFT</code> – 软引用：基于垃圾回收器状态和软引用规则移除对象。<li><code>WEAK</code> – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</ul><p>默认的清除策略是 LRU。<h2 id=5-3、Cache-ref><a class=headerlink href=#5-3、Cache-ref title=5.3、Cache-ref></a>5.3、Cache-ref</h2><p>回想一下上一节的内容，对某一命名空间的语句，只会使用该命名空间的缓存进行缓存或刷新。 但你可能会想要在多个命名空间中共享相同的缓存配置和实例。要实现这种需求，你可以使用 cache-ref 元素来引用另一个缓存。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>cache-ref</span> <span class=attr>namespace</span>=<span class=string>"com.someone.application.data.SomeMapper"</span>/></span></span><br></pre></table></figure><h2 id=5-4、ResultMap（结果映射）><a class=headerlink href=#5-4、ResultMap（结果映射） title=5.4、ResultMap（结果映射）></a>5.4、ResultMap（结果映射）</h2><p><code>resultMap</code> 元素是 MyBatis 中最重要最强大的元素。它可以让你从 90% 的 JDBC <code>ResultSets</code> 数据提取代码中解放出来，并在一些情形下允许你进行一些 JDBC 不支持的操作。实际上，在为一些比如连接的复杂语句编写映射代码的时候，一份 <code>resultMap</code> 能够代替实现同等功能的数千行代码。ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。<p>之前你已经见过简单映射语句的示例，它们没有显式指定 <code>resultMap</code>。比如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectUsers"</span> <span class=attr>resultType</span>=<span class=string>"map"</span>></span></span><br><span class=line>  select id, username, hashedPassword</span><br><span class=line>  from some_table</span><br><span class=line>  where id = #{id}</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><p>上述语句只是简单地将所有的列映射到 <code>HashMap</code> 的键上，这由 <code>resultType</code> 属性指定。虽然在大部分情况下都够用，但是 HashMap 并不是一个很好的领域模型。你的程序更可能会使用 JavaBean 或 POJO（Plain Old Java Objects，普通老式 Java 对象）作为领域模型。MyBatis 对两者都提供了支持。看看下面这个 JavaBean：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">User</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> id;</span><br><span class=line>    <span class=keyword>private</span> String username;</span><br><span class=line>    <span class=keyword>private</span> String hashedPassword;</span><br><span class=line>    </span><br><span class=line>	<span class=comment>//get and set method...</span></span><br><span class=line>}</span><br></pre></table></figure><p>这样的一个 JavaBean 可以被映射到 <code>ResultSet</code>，就像映射到 <code>HashMap</code> 一样简单。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectUsers"</span> <span class=attr>resultType</span>=<span class=string>"com.someapp.model.User"</span>></span></span><br><span class=line>  select id, username, hashedPassword</span><br><span class=line>  from some_table</span><br><span class=line>  where id = #{id}</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><p>类型别名是你的好帮手。使用它们，你就可以不用输入类的全限定名了。比如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- mybatis-config.xml 中 --></span></span><br><span class=line><span class=tag><<span class=name>typeAlias</span> <span class=attr>type</span>=<span class=string>"com.someapp.model.User"</span> <span class=attr>alias</span>=<span class=string>"User"</span>/></span></span><br><span class=line></span><br><span class=line><span class=comment>&LT!-- SQL 映射 XML 中 --></span></span><br><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectUsers"</span> <span class=attr>resultType</span>=<span class=string>"User"</span>></span></span><br><span class=line>  select id, username, hashedPassword</span><br><span class=line>  from some_table</span><br><span class=line>  where id = #{id}</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><p>你会发现上面的例子没有一个需要显式配置 <code>ResultMap</code>，这就是 <code>ResultMap</code> 的优秀之处——你完全可以不用显式地配置它们。我们来看看如果在刚刚的示例中，显式使用外部的 <code>resultMap</code> 会怎样，这也是解决列名不匹配的另外一种方式。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>resultMap</span> <span class=attr>id</span>=<span class=string>"userResultMap"</span> <span class=attr>type</span>=<span class=string>"User"</span>></span></span><br><span class=line>  <span class=tag><<span class=name>id</span> <span class=attr>property</span>=<span class=string>"id"</span> <span class=attr>column</span>=<span class=string>"user_id"</span> /></span></span><br><span class=line>  <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"username"</span> <span class=attr>column</span>=<span class=string>"user_name"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"password"</span> <span class=attr>column</span>=<span class=string>"hashed_password"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>resultMap</span>></span></span><br></pre></table></figure><p>然后在引用它的语句中设置 <code>resultMap</code> 属性就行了（注意我们去掉了 <code>resultType</code> 属性）。比如:<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectUsers"</span> <span class=attr>resultMap</span>=<span class=string>"userResultMap"</span>></span></span><br><span class=line>  select user_id, user_name, hashed_password</span><br><span class=line>  from some_table</span><br><span class=line>  where id = #{id}</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><h3 id=5-4-1、高级结果映射><a class=headerlink href=#5-4-1、高级结果映射 title=5.4.1、高级结果映射></a>5.4.1、高级结果映射</h3><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- 非常复杂的语句 --></span></span><br><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectBlogDetails"</span> <span class=attr>resultMap</span>=<span class=string>"detailedBlogResultMap"</span>></span></span><br><span class=line>  select</span><br><span class=line>       B.id as blog_id,</span><br><span class=line>       B.title as blog_title,</span><br><span class=line>       B.author_id as blog_author_id,</span><br><span class=line>       A.id as author_id,</span><br><span class=line>       A.username as author_username,</span><br><span class=line>       A.password as author_password,</span><br><span class=line>       A.email as author_email,</span><br><span class=line>       A.bio as author_bio,</span><br><span class=line>       A.favourite_section as author_favourite_section,</span><br><span class=line>       P.id as post_id,</span><br><span class=line>       P.blog_id as post_blog_id,</span><br><span class=line>       P.author_id as post_author_id,</span><br><span class=line>       P.created_on as post_created_on,</span><br><span class=line>       P.section as post_section,</span><br><span class=line>       P.subject as post_subject,</span><br><span class=line>       P.draft as draft,</span><br><span class=line>       P.body as post_body,</span><br><span class=line>       C.id as comment_id,</span><br><span class=line>       C.post_id as comment_post_id,</span><br><span class=line>       C.name as comment_name,</span><br><span class=line>       C.comment as comment_text,</span><br><span class=line>       T.id as tag_id,</span><br><span class=line>       T.name as tag_name</span><br><span class=line>  from Blog B</span><br><span class=line>       left outer join Author A on B.author_id = A.id</span><br><span class=line>       left outer join Post P on B.id = P.blog_id</span><br><span class=line>       left outer join Comment C on P.id = C.post_id</span><br><span class=line>       left outer join Post_Tag PT on PT.post_id = P.id</span><br><span class=line>       left outer join Tag T on PT.tag_id = T.id</span><br><span class=line>  where B.id = #{id}</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- 非常复杂的结果映射 --></span></span><br><span class=line><span class=tag><<span class=name>resultMap</span> <span class=attr>id</span>=<span class=string>"detailedBlogResultMap"</span> <span class=attr>type</span>=<span class=string>"Blog"</span>></span></span><br><span class=line>  <span class=tag><<span class=name>constructor</span>></span></span><br><span class=line>    <span class=tag><<span class=name>idArg</span> <span class=attr>column</span>=<span class=string>"blog_id"</span> <span class=attr>javaType</span>=<span class=string>"int"</span>/></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>constructor</span>></span></span><br><span class=line>  <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"title"</span> <span class=attr>column</span>=<span class=string>"blog_title"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>association</span> <span class=attr>property</span>=<span class=string>"author"</span> <span class=attr>javaType</span>=<span class=string>"Author"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>id</span> <span class=attr>property</span>=<span class=string>"id"</span> <span class=attr>column</span>=<span class=string>"author_id"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"username"</span> <span class=attr>column</span>=<span class=string>"author_username"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"password"</span> <span class=attr>column</span>=<span class=string>"author_password"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"email"</span> <span class=attr>column</span>=<span class=string>"author_email"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"bio"</span> <span class=attr>column</span>=<span class=string>"author_bio"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"favouriteSection"</span> <span class=attr>column</span>=<span class=string>"author_favourite_section"</span>/></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>association</span>></span></span><br><span class=line>  <span class=tag><<span class=name>collection</span> <span class=attr>property</span>=<span class=string>"posts"</span> <span class=attr>ofType</span>=<span class=string>"Post"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>id</span> <span class=attr>property</span>=<span class=string>"id"</span> <span class=attr>column</span>=<span class=string>"post_id"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"subject"</span> <span class=attr>column</span>=<span class=string>"post_subject"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>association</span> <span class=attr>property</span>=<span class=string>"author"</span> <span class=attr>javaType</span>=<span class=string>"Author"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>collection</span> <span class=attr>property</span>=<span class=string>"comments"</span> <span class=attr>ofType</span>=<span class=string>"Comment"</span>></span></span><br><span class=line>      <span class=tag><<span class=name>id</span> <span class=attr>property</span>=<span class=string>"id"</span> <span class=attr>column</span>=<span class=string>"comment_id"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>collection</span>></span></span><br><span class=line>    <span class=tag><<span class=name>collection</span> <span class=attr>property</span>=<span class=string>"tags"</span> <span class=attr>ofType</span>=<span class=string>"Tag"</span> ></span></span><br><span class=line>      <span class=tag><<span class=name>id</span> <span class=attr>property</span>=<span class=string>"id"</span> <span class=attr>column</span>=<span class=string>"tag_id"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>collection</span>></span></span><br><span class=line>    <span class=tag><<span class=name>discriminator</span> <span class=attr>javaType</span>=<span class=string>"int"</span> <span class=attr>column</span>=<span class=string>"draft"</span>></span></span><br><span class=line>      <span class=tag><<span class=name>case</span> <span class=attr>value</span>=<span class=string>"1"</span> <span class=attr>resultType</span>=<span class=string>"DraftPost"</span>/></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>discriminator</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>collection</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>resultMap</span>></span></span><br></pre></table></figure><h3 id=5-4-2、鉴别器><a class=headerlink href=#5-4-2、鉴别器 title=5.4.2、鉴别器></a>5.4.2、鉴别器</h3><p>有时候，一个数据库查询可能会返回多个不同的结果集（但总体上还是有一定的联系的）。 鉴别器（discriminator）元素就是被设计来应对这种情况的，另外也能处理其它情况，例如类的继承层次结构。 鉴别器的概念很好理解——它很像 Java 语言中的 switch 语句。<p>一个鉴别器的定义需要指定 column 和 javaType 属性。column 指定了 MyBatis 查询被比较值的地方。 而 javaType 用来确保使用正确的相等测试（虽然很多情况下字符串的相等测试都可以工作）。例如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>resultMap</span> <span class=attr>id</span>=<span class=string>"vehicleResult"</span> <span class=attr>type</span>=<span class=string>"Vehicle"</span>></span></span><br><span class=line>  <span class=tag><<span class=name>id</span> <span class=attr>property</span>=<span class=string>"id"</span> <span class=attr>column</span>=<span class=string>"id"</span> /></span></span><br><span class=line>  <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"vin"</span> <span class=attr>column</span>=<span class=string>"vin"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"year"</span> <span class=attr>column</span>=<span class=string>"year"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"make"</span> <span class=attr>column</span>=<span class=string>"make"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"model"</span> <span class=attr>column</span>=<span class=string>"model"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"color"</span> <span class=attr>column</span>=<span class=string>"color"</span>/></span></span><br><span class=line>  <span class=tag><<span class=name>discriminator</span> <span class=attr>javaType</span>=<span class=string>"int"</span> <span class=attr>column</span>=<span class=string>"vehicle_type"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>case</span> <span class=attr>value</span>=<span class=string>"1"</span> <span class=attr>resultMap</span>=<span class=string>"carResult"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>case</span> <span class=attr>value</span>=<span class=string>"2"</span> <span class=attr>resultMap</span>=<span class=string>"truckResult"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>case</span> <span class=attr>value</span>=<span class=string>"3"</span> <span class=attr>resultMap</span>=<span class=string>"vanResult"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>case</span> <span class=attr>value</span>=<span class=string>"4"</span> <span class=attr>resultMap</span>=<span class=string>"suvResult"</span>/></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>discriminator</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>resultMap</span>></span></span><br></pre></table></figure><p>在这个示例中，MyBatis 会从结果集中得到每条记录，然后比较它的 vehicle type 值。 如果它匹配任意一个鉴别器的 case，就会使用这个 case 指定的结果映射。 这个过程是互斥的，也就是说，剩余的结果映射将被忽略（除非它是扩展的，我们将在稍后讨论它）。 如果不能匹配任何一个 case，MyBatis 就只会使用鉴别器块外定义的结果映射。<h3 id=5-4-3、自动映射><a class=headerlink href=#5-4-3、自动映射 title=5.4.3、自动映射></a>5.4.3、自动映射</h3><p>在下面的例子中，<em>id</em> 和 <em>userName</em> 列将被自动映射，<em>hashed_password</em> 列将根据配置进行映射。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectUsers"</span> <span class=attr>resultMap</span>=<span class=string>"userResultMap"</span>></span></span><br><span class=line>  select</span><br><span class=line>    user_id as "id",</span><br><span class=line>    user_name as "userName",</span><br><span class=line>    hashed_password</span><br><span class=line>  from some_table</span><br><span class=line>  where id = #{id}</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>resultMap</span> <span class=attr>id</span>=<span class=string>"userResultMap"</span> <span class=attr>type</span>=<span class=string>"User"</span>></span></span><br><span class=line>  <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"password"</span> <span class=attr>column</span>=<span class=string>"hashed_password"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>resultMap</span>></span></span><br></pre></table></figure><p>有三种自动映射等级：<ul><li><code>NONE</code> - 禁用自动映射。仅对手动映射的属性进行映射。<li><code>PARTIAL</code> - 对除在内部定义了嵌套结果映射（也就是连接的属性）以外的属性进行映射<li><code>FULL</code> - 自动映射所有属性。</ul><p>默认值是 <code>PARTIAL</code>，这是有原因的。当对连接查询的结果使用 <code>FULL</code> 时，连接查询会在同一行中获取多个不同实体的数据，因此可能导致非预期的映射。 下面的例子将展示这种风险：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectBlog"</span> <span class=attr>resultMap</span>=<span class=string>"blogResult"</span>></span></span><br><span class=line>  select</span><br><span class=line>    B.id,</span><br><span class=line>    B.title,</span><br><span class=line>    A.username,</span><br><span class=line>  from Blog B left outer join Author A on B.author_id = A.id</span><br><span class=line>  where B.id = #{id}</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>resultMap</span> <span class=attr>id</span>=<span class=string>"blogResult"</span> <span class=attr>type</span>=<span class=string>"Blog"</span>></span></span><br><span class=line>  <span class=tag><<span class=name>association</span> <span class=attr>property</span>=<span class=string>"author"</span> <span class=attr>resultMap</span>=<span class=string>"authorResult"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>resultMap</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>resultMap</span> <span class=attr>id</span>=<span class=string>"authorResult"</span> <span class=attr>type</span>=<span class=string>"Author"</span>></span></span><br><span class=line>  <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"username"</span> <span class=attr>column</span>=<span class=string>"author_username"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>resultMap</span>></span></span><br></pre></table></figure><p>在该结果映射中，Blog 和 Author 均将被自动映射。但是注意 Author 有一个 id 属性，在 ResultSet 中也有一个名为 id 的列，所以 Author 的 id 将填入 Blog 的 id，这可不是你期望的行为。 所以，要谨慎使用 <code>FULL</code>。<p>无论设置的自动映射等级是哪种，你都可以通过在结果映射上设置 <code>autoMapping</code> 属性来为指定的结果映射设置启用/禁用自动映射。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>resultMap</span> <span class=attr>id</span>=<span class=string>"userResultMap"</span> <span class=attr>type</span>=<span class=string>"User"</span> <span class=attr>autoMapping</span>=<span class=string>"false"</span>></span></span><br><span class=line>  <span class=tag><<span class=name>result</span> <span class=attr>property</span>=<span class=string>"password"</span> <span class=attr>column</span>=<span class=string>"hashed_password"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>resultMap</span>></span></span><br></pre></table></figure><h2 id=5-5、ParameterMap（参数）><a class=headerlink href=#5-5、ParameterMap（参数） title=5.5、ParameterMap（参数）></a>5.5、ParameterMap（参数）</h2><p>之前见到的所有语句都使用了简单的参数形式。但实际上，参数是 MyBatis 非常强大的元素。对于大多数简单的使用场景，你都不需要使用复杂的参数，比如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectUsers"</span> <span class=attr>resultType</span>=<span class=string>"User"</span>></span></span><br><span class=line>  select id, username, password</span><br><span class=line>  from users</span><br><span class=line>  where id = #{id}</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><p>上面的这个示例说明了一个非常简单的命名参数映射。鉴于参数类型（parameterType）会被自动设置为 <code>int</code>，这个参数可以随意命名。原始类型或简单数据类型（比如 <code>Integer</code> 和 <code>String</code>）因为没有其它属性，会用它们的值来作为参数。 然而，如果传入一个复杂的对象，行为就会有点不一样了。比如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>insert</span> <span class=attr>id</span>=<span class=string>"insertUser"</span> <span class=attr>parameterType</span>=<span class=string>"User"</span>></span></span><br><span class=line>  insert into users (id, username, password)</span><br><span class=line>  values (#{id}, #{username}, #{password})</span><br><span class=line><span class=tag>&LT/<span class=name>insert</span>></span></span><br></pre></table></figure><p>如果 User 类型的参数对象传递到了语句中，会查找 id、username 和 password 属性，然后将它们的值传入预处理语句的参数中。<p>MyBatis 也支持很多高级的数据类型，比如结构体（structs），但是当使用 out 参数时，你必须显式设置类型的名称。比如（再次提示，在实际中要像这样不能换行）：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>#{middleInitial, mode=OUT, jdbcType=STRUCT, jdbcTypeName=MY_TYPE, resultMap=departmentResultMap}</span><br></pre></table></figure><p>尽管上面这些选项很强大，但大多时候，你只须简单指定属性名，顶多要为可能为空的列指定 <code>jdbcType</code>，其他的事情交给 MyBatis 自己去推断就行了。<ul><li><p>字符串替换</p> <p>默认情况下，使用 <code>#{}</code> 参数语法时，MyBatis 会创建 <code>PreparedStatement</code> 参数占位符，并通过占位符安全地设置参数（就像使用 ? 一样）。 这样做更安全，更迅速，通常也是首选做法，不过有时你就是想直接在 SQL 语句中直接插入一个不转义的字符串。 比如 ORDER BY 子句，这时候你可以：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>ORDER BY ${columnName}</span><br></pre></table></figure> <p>这样，MyBatis 就不会修改或转义该字符串了。</p> <p>当 SQL 语句中的元数据（如表名或列名）是动态生成的时候，字符串替换将会非常有用。 举个例子，如果你想 <code>select</code> 一个表任意一列的数据时，不需要这样写：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=meta>@Select("select * from user where id = #{id}")</span></span><br><span class=line>User <span class="title function_">findById</span><span class=params>(<span class=meta>@Param("id")</span> <span class=type>long</span> id)</span>;</span><br><span class=line></span><br><span class=line><span class=meta>@Select("select * from user where name = #{name}")</span></span><br><span class=line>User <span class="title function_">findByName</span><span class=params>(<span class=meta>@Param("name")</span> String name)</span>;</span><br><span class=line></span><br><span class=line><span class=meta>@Select("select * from user where email = #{email}")</span></span><br><span class=line>User <span class="title function_">findByEmail</span><span class=params>(<span class=meta>@Param("email")</span> String email)</span>;</span><br><span class=line></span><br><span class=line><span class=comment>// 其它的 "findByXxx" 方法</span></span><br></pre></table></figure> <p>而是可以只写这样一个方法：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta>@Select("select * from user where ${column} = #{value}")</span></span><br><span class=line>User <span class="title function_">findByColumn</span><span class=params>(<span class=meta>@Param("column")</span> String column, <span class=meta>@Param("value")</span> String value)</span>;</span><br></pre></table></figure> <p>其中 <code>${column}</code> 会被直接替换，而 <code>#{value}</code> 会使用 <code>?</code> 预处理。 这样，就能完成同样的任务：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>User</span> <span class=variable>userOfId1</span> <span class=operator>=</span> userMapper.findByColumn(<span class=string>"id"</span>, <span class=number>1L</span>);</span><br><span class=line><span class=type>User</span> <span class=variable>userOfNameKid</span> <span class=operator>=</span> userMapper.findByColumn(<span class=string>"name"</span>, <span class=string>"kid"</span>);</span><br><span class=line><span class=type>User</span> <span class=variable>userOfEmail</span> <span class=operator>=</span> userMapper.findByColumn(<span class=string>"email"</span>, <span class=string>"noone@nowhere.com"</span>);</span><br></pre></table></figure> <p>这种方式也同样适用于替换表名的情况。</p> <p><strong>注意：</strong>用这种方式接受用户的输入，并用作语句参数是不安全的，会导致潜在的 SQL 注入攻击。因此，要么不允许用户输入这些字段，要么自行转义并检验这些参数。</p></ul><h2 id=5-6、SQL><a class=headerlink href=#5-6、SQL title=5.6、SQL></a>5.6、SQL</h2><p>这个元素可以用来定义可重用的 SQL 代码片段，以便在其它语句中使用。 参数可以静态地（在加载的时候）确定下来，并且可以在不同的 include 元素中定义不同的参数值。比如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>sql</span> <span class=attr>id</span>=<span class=string>"userColumns"</span>></span> ${alias}.id,${alias}.username,${alias}.password <span class=tag>&LT/<span class=name>sql</span>></span></span><br></pre></table></figure><p>这个 SQL 片段可以在其它语句中使用，例如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectUsers"</span> <span class=attr>resultType</span>=<span class=string>"map"</span>></span></span><br><span class=line>  select</span><br><span class=line>    <span class=tag><<span class=name>include</span> <span class=attr>refid</span>=<span class=string>"userColumns"</span>></span><span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"alias"</span> <span class=attr>value</span>=<span class=string>"t1"</span>/></span><span class=tag>&LT/<span class=name>include</span>></span>,</span><br><span class=line>    <span class=tag><<span class=name>include</span> <span class=attr>refid</span>=<span class=string>"userColumns"</span>></span><span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"alias"</span> <span class=attr>value</span>=<span class=string>"t2"</span>/></span><span class=tag>&LT/<span class=name>include</span>></span></span><br><span class=line>  from some_table t1</span><br><span class=line>    cross join some_table t2</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><p>也可以在 include 元素的 refid 属性或内部语句中使用属性值，例如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>sql</span> <span class=attr>id</span>=<span class=string>"sometable"</span>></span></span><br><span class=line>  ${prefix}Table</span><br><span class=line><span class=tag>&LT/<span class=name>sql</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>sql</span> <span class=attr>id</span>=<span class=string>"someinclude"</span>></span></span><br><span class=line>  from <span class=tag><<span class=name>include</span> <span class=attr>refid</span>=<span class=string>"${include_target}"</span>/></span></span><br><span class=line><span class=tag>&LT/<span class=name>sql</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"select"</span> <span class=attr>resultType</span>=<span class=string>"map"</span>></span></span><br><span class=line>  select field1, field2, field3</span><br><span class=line>  <span class=tag><<span class=name>include</span> <span class=attr>refid</span>=<span class=string>"someinclude"</span>></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"prefix"</span> <span class=attr>value</span>=<span class=string>"Some"</span>/></span></span><br><span class=line>    <span class=tag><<span class=name>property</span> <span class=attr>name</span>=<span class=string>"include_target"</span> <span class=attr>value</span>=<span class=string>"sometable"</span>/></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>include</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><h2 id=5-7、Insert、Update-和-Delete><a title="5.7、Insert、Update 和 Delete" class=headerlink href=#5-7、Insert、Update-和-Delete></a>5.7、Insert、Update 和 Delete</h2><p>insert，update 和 delete 的实现非常接近：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>insert</span></span></span><br><span class=line><span class=tag>  <span class=attr>id</span>=<span class=string>"insertAuthor"</span></span></span><br><span class=line><span class=tag>  <span class=attr>parameterType</span>=<span class=string>"domain.blog.Author"</span></span></span><br><span class=line><span class=tag>  <span class=attr>flushCache</span>=<span class=string>"true"</span></span></span><br><span class=line><span class=tag>  <span class=attr>statementType</span>=<span class=string>"PREPARED"</span></span></span><br><span class=line><span class=tag>  <span class=attr>keyProperty</span>=<span class=string>""</span></span></span><br><span class=line><span class=tag>  <span class=attr>keyColumn</span>=<span class=string>""</span></span></span><br><span class=line><span class=tag>  <span class=attr>useGeneratedKeys</span>=<span class=string>""</span></span></span><br><span class=line><span class=tag>  <span class=attr>timeout</span>=<span class=string>"20"</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>update</span></span></span><br><span class=line><span class=tag>  <span class=attr>id</span>=<span class=string>"updateAuthor"</span></span></span><br><span class=line><span class=tag>  <span class=attr>parameterType</span>=<span class=string>"domain.blog.Author"</span></span></span><br><span class=line><span class=tag>  <span class=attr>flushCache</span>=<span class=string>"true"</span></span></span><br><span class=line><span class=tag>  <span class=attr>statementType</span>=<span class=string>"PREPARED"</span></span></span><br><span class=line><span class=tag>  <span class=attr>timeout</span>=<span class=string>"20"</span>></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>delete</span></span></span><br><span class=line><span class=tag>  <span class=attr>id</span>=<span class=string>"deleteAuthor"</span></span></span><br><span class=line><span class=tag>  <span class=attr>parameterType</span>=<span class=string>"domain.blog.Author"</span></span></span><br><span class=line><span class=tag>  <span class=attr>flushCache</span>=<span class=string>"true"</span></span></span><br><span class=line><span class=tag>  <span class=attr>statementType</span>=<span class=string>"PREPARED"</span></span></span><br><span class=line><span class=tag>  <span class=attr>timeout</span>=<span class=string>"20"</span>></span></span><br></pre></table></figure><p>各个参数详解如下：<table><thead><tr><th align=left>属性<th align=left>描述<tbody><tr><td align=left><code>id</code><td align=left>在命名空间中唯一的标识符，可以被用来引用这条语句。<tr><td align=left><code>parameterType</code><td align=left>将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。<tr><td align=left><code>parameterMap</code><td align=left>用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。<tr><td align=left><code>flushCache</code><td align=left>将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对 insert、update 和 delete 语句）true。<tr><td align=left><code>timeout</code><td align=left>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。<tr><td align=left><code>statementType</code><td align=left>可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。<tr><td align=left><code>useGeneratedKeys</code><td align=left>（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。<tr><td align=left><code>keyProperty</code><td align=left>（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（<code>unset</code>）。如果生成列不止一个，可以用逗号分隔多个属性名称。<tr><td align=left><code>keyColumn</code><td align=left>（仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。<tr><td align=left><code>databaseId</code><td align=left>如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。</table><p>对于不支持自动生成主键列的数据库和可能不支持自动生成主键的 JDBC 驱动，MyBatis 有另外一种方法来生成主键。<p>这里有一个简单（也很傻）的示例，它可以生成一个随机 ID（不建议实际使用，这里只是为了展示 MyBatis 处理问题的灵活性和宽容度）：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>insert</span> <span class=attr>id</span>=<span class=string>"insertAuthor"</span>></span></span><br><span class=line>  <span class=tag><<span class=name>selectKey</span> <span class=attr>keyProperty</span>=<span class=string>"id"</span> <span class=attr>resultType</span>=<span class=string>"int"</span> <span class=attr>order</span>=<span class=string>"BEFORE"</span>></span></span><br><span class=line>    select CAST(RANDOM()*1000000 as INTEGER) a from SYSIBM.SYSDUMMY1</span><br><span class=line>  <span class=tag>&LT/<span class=name>selectKey</span>></span></span><br><span class=line>  insert into Author</span><br><span class=line>    (id, username, password, email,bio, favourite_section)</span><br><span class=line>  values</span><br><span class=line>    (#{id}, #{username}, #{password}, #{email}, #{bio}, #{favouriteSection,jdbcType=VARCHAR})</span><br><span class=line><span class=tag>&LT/<span class=name>insert</span>></span></span><br></pre></table></figure><p>selectKey元素描述如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>selectKey</span></span></span><br><span class=line><span class=tag>  <span class=attr>keyProperty</span>=<span class=string>"id"</span></span></span><br><span class=line><span class=tag>  <span class=attr>resultType</span>=<span class=string>"int"</span></span></span><br><span class=line><span class=tag>  <span class=attr>order</span>=<span class=string>"BEFORE"</span></span></span><br><span class=line><span class=tag>  <span class=attr>statementType</span>=<span class=string>"PREPARED"</span>></span></span><br></pre></table></figure><p>各个参数详解如下：<table><thead><tr><th align=left>属性<th align=left>描述<tbody><tr><td align=left><code>keyProperty</code><td align=left><code>selectKey</code> 语句结果应该被设置到的目标属性。如果生成列不止一个，可以用逗号分隔多个属性名称。<tr><td align=left><code>keyColumn</code><td align=left>返回结果集中生成列属性的列名。如果生成列不止一个，可以用逗号分隔多个属性名称。<tr><td align=left><code>resultType</code><td align=left>结果的类型。通常 MyBatis 可以推断出来，但是为了更加准确，写上也不会有什么问题。MyBatis 允许将任何简单类型用作主键的类型，包括字符串。如果生成列不止一个，则可以使用包含期望属性的 Object 或 Map。<tr><td align=left><code>order</code><td align=left>可以设置为 <code>BEFORE</code> 或 <code>AFTER</code>。如果设置为 <code>BEFORE</code>，那么它首先会生成主键，设置 <code>keyProperty</code> 再执行插入语句。如果设置为 <code>AFTER</code>，那么先执行插入语句，然后是 <code>selectKey</code> 中的语句 - 这和 Oracle 数据库的行为相似，在插入语句内部可能有嵌入索引调用。<tr><td align=left><code>statementType</code><td align=left>和前面一样，MyBatis 支持 <code>STATEMENT</code>，<code>PREPARED</code> 和 <code>CALLABLE</code> 类型的映射语句，分别代表 <code>Statement</code>, <code>PreparedStatement</code> 和 <code>CallableStatement</code> 类型。</table><h2 id=5-8、Select><a class=headerlink href=#5-8、Select title=5.8、Select></a>5.8、Select</h2><p>一个简单查询的 select 元素是非常简单的。比如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectPerson"</span> <span class=attr>parameterType</span>=<span class=string>"int"</span> <span class=attr>resultType</span>=<span class=string>"hashmap"</span>></span></span><br><span class=line>  SELECT * FROM PERSON WHERE ID = #{id}</span><br><span class=line><span class=tag>&LT/<span class=name>select</span>></span></span><br></pre></table></figure><p>select 元素允许你配置很多属性来配置每条语句的行为细节。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>select</span></span></span><br><span class=line><span class=tag>  <span class=attr>id</span>=<span class=string>"selectPerson"</span></span></span><br><span class=line><span class=tag>  <span class=attr>parameterType</span>=<span class=string>"int"</span></span></span><br><span class=line><span class=tag>  <span class=attr>parameterMap</span>=<span class=string>"deprecated"</span></span></span><br><span class=line><span class=tag>  <span class=attr>resultType</span>=<span class=string>"hashmap"</span></span></span><br><span class=line><span class=tag>  <span class=attr>resultMap</span>=<span class=string>"personResultMap"</span></span></span><br><span class=line><span class=tag>  <span class=attr>flushCache</span>=<span class=string>"false"</span></span></span><br><span class=line><span class=tag>  <span class=attr>useCache</span>=<span class=string>"true"</span></span></span><br><span class=line><span class=tag>  <span class=attr>timeout</span>=<span class=string>"10"</span></span></span><br><span class=line><span class=tag>  <span class=attr>fetchSize</span>=<span class=string>"256"</span></span></span><br><span class=line><span class=tag>  <span class=attr>statementType</span>=<span class=string>"PREPARED"</span></span></span><br><span class=line><span class=tag>  <span class=attr>resultSetType</span>=<span class=string>"FORWARD_ONLY"</span>></span></span><br></pre></table></figure><p>各个参数详解如下：<table><thead><tr><th align=left>属性<th align=left>描述<tbody><tr><td align=left><code>id</code><td align=left>在命名空间中唯一的标识符，可以被用来引用这条语句。<tr><td align=left><code>parameterType</code><td align=left>将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。<tr><td align=left>parameterMap<td align=left>用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。<tr><td align=left><code>resultType</code><td align=left>期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。<tr><td align=left><code>resultMap</code><td align=left>对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。<tr><td align=left><code>flushCache</code><td align=left>将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。<tr><td align=left><code>useCache</code><td align=left>将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。<tr><td align=left><code>timeout</code><td align=left>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。<tr><td align=left><code>fetchSize</code><td align=left>这是一个给驱动的建议值，尝试让驱动程序每次批量返回的结果行数等于这个设置值。 默认值为未设置（unset）（依赖驱动）。<tr><td align=left><code>statementType</code><td align=left>可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。<tr><td align=left><code>resultSetType</code><td align=left>FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖数据库驱动）。<tr><td align=left><code>databaseId</code><td align=left>如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。<tr><td align=left><code>resultOrdered</code><td align=left>这个设置仅针对嵌套结果 select 语句：如果为 true，将会假设包含了嵌套结果集或是分组，当返回一个主结果行时，就不会产生对前面结果集的引用。 这就使得在获取嵌套结果集的时候不至于内存不够用。默认值：<code>false</code>。<tr><td align=left><code>resultSets</code><td align=left>这个设置仅适用于多结果集的情况。它将列出语句执行后返回的结果集并赋予每个结果集一个名称，多个名称之间以逗号分隔。</table><h1 id=6、日志><a class=headerlink href=#6、日志 title=6、日志></a>6、日志</h1><h2 id=6-1、前言><a class=headerlink href=#6-1、前言 title=6.1、前言></a>6.1、前言</h2><p>Mybatis 通过使用内置的日志工厂提供日志功能。内置日志工厂将会把日志工作委托给下面的实现之一：<ul><li>SLF4J<li>Apache Commons Logging<li>Log4j2<li>Log4j<li>JDK logging</ul><p>MyBatis 内置日志工厂会基于运行时检测信息选择日志委托实现。它会（按上面罗列的顺序）使用第一个查找到的实现。当没有找到这些实现时，将会禁用日志功能。<h2 id=6-2、日志配置><a class=headerlink href=#6-2、日志配置 title=6.2、日志配置></a>6.2、日志配置</h2><h4 id=步骤-1：添加-Log4J-的-jar-包><a title="步骤 1：添加 Log4J 的 jar 包" class=headerlink href=#步骤-1：添加-Log4J-的-jar-包></a>步骤 1：添加 Log4J 的 jar 包</h4><p>由于我们使用的是 Log4J，我们要确保它的 jar 包可以被应用使用。为此，需要将 jar 包添加到应用的类路径中。<p>对于 web 应用或企业级应用，你可以将 <code>log4j.jar</code> 添加到 <code>WEB-INF/lib</code> 目录下；对于独立应用，可以将它添加到 JVM 的 <code>-classpath</code> 启动参数中。<h4 id=步骤-2：配置-Log4J><a title="步骤 2：配置 Log4J" class=headerlink href=#步骤-2：配置-Log4J></a>步骤 2：配置 Log4J</h4><p>配置 Log4J 比较简单。假设你需要记录这个映射器的日志：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> org.mybatis.example;</span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">BlogMapper</span> {</span><br><span class=line>  <span class=meta>@Select("SELECT * FROM blog WHERE id = #{id}")</span></span><br><span class=line>  Blog <span class="title function_">selectBlog</span><span class=params>(<span class=type>int</span> id)</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>在应用的类路径中创建一个名为 <code>log4j.properties</code> 的文件，文件的具体内容如下：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment># 全局日志配置</span></span><br><span class=line><span class=attr>log4j.rootLogger</span>=<span class=string>ERROR, stdout</span></span><br><span class=line><span class=comment># MyBatis 日志配置</span></span><br><span class=line><span class=attr>log4j.logger.org.mybatis.example.BlogMapper</span>=<span class=string>TRACE</span></span><br><span class=line><span class=comment># 控制台输出</span></span><br><span class=line><span class=attr>log4j.appender.stdout</span>=<span class=string>org.apache.log4j.ConsoleAppender</span></span><br><span class=line><span class=attr>log4j.appender.stdout.layout</span>=<span class=string>org.apache.log4j.PatternLayout</span></span><br><span class=line><span class=attr>log4j.appender.stdout.layout.ConversionPattern</span>=<span class=string>%5p [%t] - %m%n</span></span><br></pre></table></figure><p>上述配置将使 Log4J 详细打印 <code>org.mybatis.example.BlogMapper</code> 的日志，对于应用的其它部分，只打印错误信息。<p>为了实现更细粒度的日志输出，你也可以只打印特定语句的日志。以下配置将只打印语句 <code>selectBlog</code> 的日志：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>log4j.logger.org.mybatis.example.BlogMapper.selectBlog</span>=<span class=string>TRACE</span></span><br></pre></table></figure><p>或者，你也可以打印一组映射器的日志，只需要打开映射器所在的包的日志功能即可：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>log4j.logger.org.mybatis.example</span>=<span class=string>TRACE</span></span><br></pre></table></figure><p>某些查询可能会返回庞大的结果集。这时，你可能只想查看 SQL 语句，而忽略返回的结果集。为此，SQL 语句将会在 DEBUG 日志级别下记录（JDK 日志则为 FINE）。返回的结果集则会在 TRACE 日志级别下记录（JDK 日志则为 FINER)。因此，只要将日志级别调整为 DEBUG 即可：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>log4j.logger.org.mybatis.example</span>=<span class=string>DEBUG</span></span><br></pre></table></figure><p>但如果你要为下面的映射器 XML 文件打印日志，又该怎么办呢？<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span> ?></span></span><br><span class=line><span class=meta>&LT!DOCTYPE <span class=keyword>mapper</span></span></span><br><span class=line><span class=meta>  <span class=keyword>PUBLIC</span> <span class=string>"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class=line><span class=meta>  <span class=string>"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>></span></span><br><span class=line><span class=tag><<span class=name>mapper</span> <span class=attr>namespace</span>=<span class=string>"org.mybatis.example.BlogMapper"</span>></span></span><br><span class=line>  <span class=tag><<span class=name>select</span> <span class=attr>id</span>=<span class=string>"selectBlog"</span> <span class=attr>resultType</span>=<span class=string>"Blog"</span>></span></span><br><span class=line>    select * from Blog where id = #{id}</span><br><span class=line>  <span class=tag>&LT/<span class=name>select</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>mapper</span>></span></span><br></pre></table></figure><p>这时，你可以通过打开命名空间的日志功能来对整个 XML 记录日志：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>log4j.logger.org.mybatis.example.BlogMapper</span>=<span class=string>TRACE</span></span><br></pre></table></figure><p>而要记录具体语句的日志，可以这样做：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>log4j.logger.org.mybatis.example.BlogMapper.selectBlog</span>=<span class=string>TRACE</span></span><br></pre></table></figure><p>你应该会发现，为映射器和 XML 文件打开日志功能的语句毫无差别。<p><strong>注意：</strong> 如果你使用的是 SLF4J 或 Log4j 2，MyBatis 会设置 tag 为 MYBATIS。<p>配置文件 <code>log4j.properties</code> 的余下内容用来配置输出器（appender）。<h1 id=7、分页插件><a class=headerlink href=#7、分页插件 title=7、分页插件></a>7、分页插件</h1><h2 id=7-1、添加依赖><a class=headerlink href=#7-1、添加依赖 title=7.1、添加依赖></a>7.1、添加依赖</h2><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --></span></span><br><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>	<span class=tag><<span class=name>groupId</span>></span>com.github.pagehelper<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>artifactId</span>></span>pagehelper<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>	<span class=tag><<span class=name>version</span>></span>5.2.0<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><h2 id=7-2、配置分页插件><a class=headerlink href=#7-2、配置分页插件 title=7.2、配置分页插件></a>7.2、配置分页插件</h2><p>在MyBatis的核心配置文件（mybatis-config.xml）中配置插件：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>plugins</span>></span></span><br><span class=line>	<span class=comment>&LT!--设置分页插件--></span></span><br><span class=line>	<span class=tag><<span class=name>plugin</span> <span class=attr>interceptor</span>=<span class=string>"com.github.pagehelper.PageInterceptor"</span>></span><span class=tag>&LT/<span class=name>plugin</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>plugins</span>></span></span><br></pre></table></figure><h2 id=7-3、使用分页插件><a class=headerlink href=#7-3、使用分页插件 title=7.3、使用分页插件></a>7.3、使用分页插件</h2><h3 id=7-3-1、开启分页功能><a class=headerlink href=#7-3-1、开启分页功能 title=7.3.1、开启分页功能></a>7.3.1、开启分页功能</h3><p>在执行查询方法前调用<code>PageHelper.startPage(int pageNum, int pageSize)</code>方法来开启分页功能。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testPageHelper</span><span class=params>()</span> <span class=keyword>throws</span> IOException {</span><br><span class=line>	<span class=type>InputStream</span> <span class=variable>is</span> <span class=operator>=</span> Resources.getResourceAsStream(<span class=string>"mybatis-config.xml"</span>);</span><br><span class=line>	<span class=type>SqlSessionFactoryBuilder</span> <span class=variable>sqlSessionFactoryBuilder</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class=line>	<span class=type>SqlSessionFactory</span> <span class=variable>sqlSessionFactory</span> <span class=operator>=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class=line>	<span class=type>SqlSession</span> <span class=variable>sqlSession</span> <span class=operator>=</span> sqlSessionFactory.openSession(<span class=literal>true</span>);</span><br><span class=line>	<span class=type>EmpMapper</span> <span class=variable>mapper</span> <span class=operator>=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class=line>	<span class=comment>//访问第一页，每页四条数据</span></span><br><span class=line>	PageHelper.startPage(<span class=number>1</span>,<span class=number>4</span>);</span><br><span class=line>	List&LTEmp> emps = mapper.selectByExample(<span class=literal>null</span>);</span><br><span class=line>	emps.forEach(System.out::println);</span><br><span class=line>}</span><br></pre></table></figure><h3 id=7-3-2、常用操作><a class=headerlink href=#7-3-2、常用操作 title=7.3.2、常用操作></a>7.3.2、常用操作</h3><h4 id=7-3-2-1、直接输出><a class=headerlink href=#7-3-2-1、直接输出 title=7.3.2.1、直接输出></a>7.3.2.1、直接输出</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testPageHelper</span><span class=params>()</span> <span class=keyword>throws</span> IOException {</span><br><span class=line>	<span class=type>InputStream</span> <span class=variable>is</span> <span class=operator>=</span> Resources.getResourceAsStream(<span class=string>"mybatis-config.xml"</span>);</span><br><span class=line>	<span class=type>SqlSessionFactoryBuilder</span> <span class=variable>sqlSessionFactoryBuilder</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class=line>	<span class=type>SqlSessionFactory</span> <span class=variable>sqlSessionFactory</span> <span class=operator>=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class=line>	<span class=type>SqlSession</span> <span class=variable>sqlSession</span> <span class=operator>=</span> sqlSessionFactory.openSession(<span class=literal>true</span>);</span><br><span class=line>	<span class=type>EmpMapper</span> <span class=variable>mapper</span> <span class=operator>=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class=line>	<span class=comment>//访问第一页，每页四条数据</span></span><br><span class=line>	Page&LTObject> page = PageHelper.startPage(<span class=number>1</span>, <span class=number>4</span>);</span><br><span class=line>	List&LTEmp> emps = mapper.selectByExample(<span class=literal>null</span>);</span><br><span class=line>	<span class=comment>//在查询到List集合后，打印分页数据</span></span><br><span class=line>	System.out.println(page);</span><br><span class=line>}</span><br></pre></table></figure><h4 id=7-3-2-2、使用PageInfo><a class=headerlink href=#7-3-2-2、使用PageInfo title=7.3.2.2、使用PageInfo></a>7.3.2.2、使用PageInfo</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=meta>@Test</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testPageHelper</span><span class=params>()</span> <span class=keyword>throws</span> IOException {</span><br><span class=line>	<span class=type>InputStream</span> <span class=variable>is</span> <span class=operator>=</span> Resources.getResourceAsStream(<span class=string>"mybatis-config.xml"</span>);</span><br><span class=line>	<span class=type>SqlSessionFactoryBuilder</span> <span class=variable>sqlSessionFactoryBuilder</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class=line>	<span class=type>SqlSessionFactory</span> <span class=variable>sqlSessionFactory</span> <span class=operator>=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class=line>	<span class=type>SqlSession</span> <span class=variable>sqlSession</span> <span class=operator>=</span> sqlSessionFactory.openSession(<span class=literal>true</span>);</span><br><span class=line>	<span class=type>EmpMapper</span> <span class=variable>mapper</span> <span class=operator>=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class=line>	PageHelper.startPage(<span class=number>1</span>, <span class=number>4</span>);</span><br><span class=line>	List&LTEmp> emps = mapper.selectByExample(<span class=literal>null</span>);</span><br><span class=line>	PageInfo&LTEmp> page = <span class=keyword>new</span> <span class="title class_">PageInfo</span><>(emps,<span class=number>5</span>);</span><br><span class=line>	System.out.println(page);</span><br><span class=line>}</span><br></pre></table></figure><h2 id=7-4、常见字段><a class=headerlink href=#7-4、常见字段 title=7.4、常见字段></a>7.4、常见字段</h2><ul><li>pageNum：当前页的页码 。<li>pageSize：每页显示的条数 。<li>size：当前页显示的真实条数。<li>total：总记录数。<li>pages：总页数。<li>prePage：上一页的页码。<li>nextPage：下一页的页码。<li>isFirstPage/isLastPage：是否为第一页/最后一页。<li>hasPreviousPage/hasNextPage：是否存在上一页/下一页。<li>navigatePages：导航分页的页码数。<li>navigatepageNums：导航分页的页码，[1,2,3,4,5]。</ul></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/MyBatis%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/MyBatis%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ itemprop=url>MyBatis系列-MyBatis原理解析</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-03 20:31:32" datetime=2023-10-03T20:31:32+08:00 itemprop=dateModified>2023-10-03</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/MyBatis/ itemprop=url rel=index><span itemprop=name>MyBatis</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=SqlSessionFactory><a class=headerlink href=#SqlSessionFactory title=SqlSessionFactory></a>SqlSessionFactory</h1><p>获取一个SqlSessionFactory对象：<ol><li><p>创建SqlSessionFactoryBuilder对象，并调用build()方法。</p> <ol><li><p><strong>创建 配置构建器对象</strong>：parser = new XMLConfigBuilder(inputStream, environment, properties);</p><li><p><strong>创建 配置 对象</strong>：解析核心配置文件（各个标签信息）并封装成Configuration对象：config = parser.parse();</p> <p>配置文件中的增删改查标签会被封装成一个MapperStatement。</p><li><p>通过上一步解析拿到的配置来<strong>创建DefaultSqlSessionFactory对象</strong>：new DefaultSqlSessionFactory(config);</p></ol><li><p><strong>最终返回DefaultSqlSessionFactory</strong>。</p></ol><h1 id=SqlSession><a class=headerlink href=#SqlSession title=SqlSession></a>SqlSession</h1><p>获取一个SqlSession对象：<ol><li><p>调用DefaultSqlSessionFactory.openSession()方法 <strong>获取SqlSession</strong>。</p> <ol><li><p><strong>获取执行器类型</strong>：configuration.getDefaultExecutorType()，若显式指定则以指定为准。</p> <p>执行器类型<em><strong>共有三种：SIMPLE（简单） / REUSE（可复用） / BATCH（批量操作），默认为SIMPLE</strong></em>。</p><li><p>调用openSessionFromDataSource(executorType…)方法</p> <ol><li><strong>获取环境信息</strong>：environment = configuration.getEnvironment();<li><strong>获取事务工厂</strong>：getTransactionFactoryFromEnvironment(environment);<li><strong>获取事务对象</strong>：transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);<li><strong>创建执行器对象</strong>： executor = configuration.newExecutor(tx, execType);<ol><li>根据execType创建不同的执行器。<li>如果开启二级缓存，那么使用CachingExecutor进行包装并返回CachingExecutor对象。<li>拦截器链封装executor对象（代理）：interceptorChain.pluginAll(executor);</ol><li><strong>创建DefaultSqlSession对象</strong>：new DefaultSqlSession(configuration, executor, autoCommit);<li><strong>最终重置错误上下文</strong>：ErrorContext.instance().reset();</ol></ol><li><p>返回一个DefaultSqlSession对象。</p></ol><h1 id=Mapper代理><a class=headerlink href=#Mapper代理 title=Mapper代理></a>Mapper代理</h1><p>获取Mapper代理对象：<ol><li>获取Mapper：<code>DefaultSqlSession.getMapper(Class&LTT> type)</code>。<ol><li>获取Mapper：<code>MapperRegistry.getMapper(type, sqlSession);</code>。<ol><li><strong>获取MapperProxy工厂</strong>：<code>mapperProxyFactory = (MapperProxyFactory&LTT>) knownMappers.get(type);</code>若MapperProxyFactory 为空就抛异常，否则继续执行。<li><strong>创建MapperProxy实例</strong>：<code>mapperProxyFactory.newInstance(sqlSession);</code><ol><li><strong>创建MapperProxy对象</strong>：mapperProxy = new MapperProxy<>(sqlSession, mapperInterface, methodCache);<li><strong>创建mapper接口代理对象</strong>：<code>Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);</code></ol></ol></ol><li>返回一个接口代理对象（Mapper接口实现）。</ol><h1 id=执行目标方法><a class=headerlink href=#执行目标方法 title=执行目标方法></a>执行目标方法</h1><p><em><strong>执行目标方法前会先执行代理对象的<code>invoke()</code>方法</strong></em>。<ol><li>执行MapperProxy.invoke()方法：invoke(Object proxy, Method method, Object[] args)<ol><li>若 method 是Object的方法，则执行Object的invoke方法，否则继续执行。<li><strong>创建Mapper方法执行器并执行方法</strong>：cachedInvoker(method).invoke(proxy, method, args, sqlSession);<ol><li>调用MapperMethod.execute(SqlSession sqlSession, Object[] args)方法。<ol><li>判断方法的目的类型：INSERT / UPDATE / DELETE / SELECT / FLUSH / 默认抛出异常。<li>根据方法目的类型 来通过SqlSession执行对应操作（增删改查）逻辑。<li>返回执行结果。</ol></ol></ol><li>返回操作结果。</ol><h2 id=Select><a class=headerlink href=#Select title=Select></a>Select</h2><h3 id=查询单条数据><a class=headerlink href=#查询单条数据 title=查询单条数据></a>查询单条数据</h3><ol><li><p><code>DefaultSqlSession.selectOne(command.getName(), param)</code></p><li><p><code>DefaultSqlSession.selectList(statement, parameter, rowBounds);</code></p> <ol><li><p><strong>获取MapperStatement对象</strong>：configuration.getMappedStatement(statement)，根据mapper接口方法唯一标识ID来获取。</p><li><p><strong>通过执行器执行查询方法</strong>：<code>executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);</code>先封装参数，然后执行query方法，最后返回结果。</p> <ol><li>获取绑定SQL的BoundSQL对象：<code>ms.getBoundSql(parameterObject);</code><li>创建缓存键：<code>createCacheKey(ms, parameterObject, rowBounds, boundSql);</code><li>执行查询：<code>query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</code><ol><li><strong>查询二级缓存</strong>，如果有结果则返回，如果没有，则执行下面逻辑。<li>二级缓存中没有结果，则执行<code>BaseExecutor.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</code>方法。<ol><li><strong>查询一级缓存</strong>，如果有结果，则执行<code>handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</code><li>如果一级缓存中没有，则执行 <code>BaseExecutor.queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);</code><ol><li><strong>执行查询方法</strong>：doQuery(ms, parameter, rowBounds, resultHandler, boundSql);<ol><li><strong>获取配置信息</strong>：ms.getConfiguration();<li><strong>创建StatementHandler对象</strong>：configuration.newStatementHandler(…)。<ol><li>根据<code>statementType</code>来创建StatementHandler（BaseStatementHandler）对象。且同时会**创建ParemeterHandler 和 ResultHandler，其也在创建后会被拦截器链包装（创建代理）：interceptorChain.pluginAll(parameterHandler / resultSetHandler);**。（statementType有三种类型：STATEMENT:SimpleStatementHandler / PREPARED:PreparedStatementHandler / CALLABLE:CallableStatementHandler / 其它抛异常），<li>拦截器链会封装创建好的StatementHandler对象，然后返回：<code>return interceptorChain.pluginAll(statementHandler);</code></ol><li><strong>初始化Statement</strong>：<code>prepareStatement(handler, ms.getStatementLog());</code><ol><li>实例化Statement。<li>为ParameterHandler 设置参数：<code>setParameters(statement);</code></ol><li><strong>执行查询方法</strong>：StatementHandler.query(stmt, resultHandler);<ol><li>执行PreparedStatement.execute()方法来查询数据。<li>使用ResultSetHandler处理结果数据集，通过<strong>TypeHandler</strong>进行类型转换。<li>返回 处理后的结果集。</ol></ol><li><strong>本地缓存执行结果</strong>：PerpetualCache-localCache.putObject(key, list);<li>如果方法有回调，则将key和parameter保存到输出缓存中：localOutputParameterCache.putObject(key, parameter);</ol></ol></ol></ol><li><p><em><strong>如果查询结果只有1条数据就返回，否则直接抛异常TooManyResultsException</strong></em>。</p></ol><li><p>返回 结果集。</p></ol><h3 id=查询多条数据><a class=headerlink href=#查询多条数据 title=查询多条数据></a>查询多条数据</h3><p>原理与查询单条数据类似。</div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Linux%E5%AE%9E%E6%93%8D%E7%AF%87/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Linux%E5%AE%9E%E6%93%8D%E7%AF%87/ itemprop=url>Linux系列-Linux实操篇</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-09-30 20:43:58" datetime=2023-09-30T20:43:58+08:00 itemprop=dateModified>2023-09-30</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Linux/ itemprop=url rel=index><span itemprop=name>Linux</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、开始使用><a class=headerlink href=#1、开始使用 title=1、开始使用></a>1、开始使用</h1><h2 id=1-1、登录和注销><a class=headerlink href=#1-1、登录和注销 title=1.1、登录和注销></a>1.1、登录和注销</h2><ul><li><strong>登录</strong>：一般使用普通用户登录，然后通过<code>su - 用户名</code>命令来切换到系统管理员身份。<li><strong>注销</strong>：使用命令<code>logout</code>，即可注销。</ul><blockquote><p>logout命令在图形运行级别下无效，只在运行级别3下才有效。<p>无论是关机还是重启，建议先运行<code>sync</code>命令将内存中的数据写到磁盘。</blockquote><h2 id=1-2、重启><a class=headerlink href=#1-2、重启 title=1.2、重启></a>1.2、重启</h2><ul><li><strong>shutdown -r now</strong>：立刻重启计算机。<li><strong>reboot</strong>：现在重启计算机。</ul><h2 id=1-3、关机><a class=headerlink href=#1-3、关机 title=1.3、关机></a>1.3、关机</h2><ul><li><strong>shutdown -h now</strong>：立刻执行关机。<li><strong>shutdown -h 1</strong>：1分钟后关机。<li><strong>halt</strong>：关机。<li><strong>sync</strong>：内存数据同步到磁盘。</ul><h2 id=1-4、远程登录><a class=headerlink href=#1-4、远程登录 title=1.4、远程登录></a>1.4、远程登录</h2><p>Linux 一般作为服务器使用，而服务器一般放在机房，需要远程登录到Linux服务器来管理维护系统。<p>Linux 系统中是<strong>通过SSH服务实现远程登录功能，默认ssh服务端口号为 22</strong>。<p>Window中可以远程登录 Linux 的客户端有XShell、SecureCRT、Putty、SSH Secure Shell 等。<blockquote><p>远程登录Lunux服务器需要SSH协议和22端口。若Linux服务器没有满足该条件，请进行相关设置，以满足条件。</blockquote><h2 id=1-5、文件传输><a class=headerlink href=#1-5、文件传输 title=1.5、文件传输></a>1.5、文件传输</h2><p>远程文件传输需要 Linux服务器开启<strong>SSHD服务</strong>。如需使用文件传输，请先开启该服务。<h1 id=2、vi-vim编辑器><a class=headerlink href=#2、vi-vim编辑器 title=2、vi/vim编辑器></a>2、vi/vim编辑器</h1><h2 id=2-1、概述><a class=headerlink href=#2-1、概述 title=2.1、概述></a>2.1、概述</h2><p>Unix Like 系统都会内建 vi 编辑器，目前使用较多的是 vim 编辑器。<p><strong>vim 从 vi 发展而来</strong>。具备代码补全、编译、错误跳转等编程功能。<p><img alt=image-20210918194511730 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210918194511730.png><h2 id=2-3、三种模式><a class=headerlink href=#2-3、三种模式 title=2.3、三种模式></a>2.3、三种模式</h2><p>vi / vim 分三种模式，分别是<strong>命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）</strong>。<h3 id=2-3-1、命令模式><a class=headerlink href=#2-3-1、命令模式 title=2.3.1、命令模式></a>2.3.1、命令模式</h3><p><strong>用户启动 vi/vim 时会直接进入 命令模式。</strong><p>常用命令如下：<ul><li>输入英文字母<code>i</code>会 切换到 输入模式。<li>输入英文字母<code>x</code>会 删除 当前光标所在处字符。<li>输入英文标点符号字符<code>:</code>会切换到底线命令模式，然后可在最下面一行输入命令。</ul><blockquote><p>命令模式下的命令数量有限，但可通过 <strong>底线命令模式</strong> 输入更多命令。</blockquote><h3 id=2-3-2、输入模式><a class=headerlink href=#2-3-2、输入模式 title=2.3.2、输入模式></a>2.3.2、输入模式</h3><p><strong>输入英文字母<code>i</code>会切换到输入模式。</strong><p>输入模式下可使用以下命令：<ul><li><strong>字符按键以及Shift组合</strong>，输入字符。<li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符。<li><strong>DEL</strong>，删除键，删除光标后一个字符。<li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾。<li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页。<li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线。<li><strong>ESC</strong>，退出输入模式，切换到命令模式。</ul><h3 id=2-3-3、底线命令模式><a class=headerlink href=#2-3-3、底线命令模式 title=2.3.3、底线命令模式></a>2.3.3、底线命令模式</h3><p><strong>命令模式下输入英文标点符号<code>:</code>会切换到底线命令模式</strong>。<p>底线命令模式可输入单个或多个字符命令，命令数量较多。底线命令模式下常用命令有（省略了冒号）：<ul><li>q：退出程序。<li>w：保存文件。</ul><p><strong>按ESC键可退出底线命令模式。</strong><h1 id=3、用户管理><a class=headerlink href=#3、用户管理 title=3、用户管理></a>3、用户管理</h1><h2 id=3-1、概述><a class=headerlink href=#3-1、概述 title=3.1、概述></a>3.1、概述</h2><p><strong>Linux系统是一个多用户多任务分时操作系统</strong>，要使用系统资源，就必须申请一个账号，然后通过该账户进行访问。<p>用户账号机制 可以帮助系统管理员 跟踪系统用户的操作，并控制他们对系统资源的访问；同时可帮助用户 组织文件 并提供 安全性保护。<p>每个用户账号都拥有唯一 用户名 和 口令。输入正确的用户名和口令 就能进入系统和自己的主目录。<h2 id=3-2、用户组><a class=headerlink href=#3-2、用户组 title=3.2、用户组></a>3.2、用户组</h2><h3 id=3-2-1、添加组><a class=headerlink href=#3-2-1、添加组 title=3.2.1、添加组></a>3.2.1、添加组</h3><p>语法：groupadd 组名<p>常用命令：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：创建用户组wudang</span></span><br><span class=line>groupadd wudang</span><br></pre></table></figure><blockquote><p>创建好的用户组信息可以在用户组文件 <code>/etc/group</code>中看到。</blockquote><h3 id=3-2-2、修改组><a class=headerlink href=#3-2-2、修改组 title=3.2.2、修改组></a>3.2.2、修改组</h3><p>语法：groupmod -n new_name old_name<p>常用命令：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：将用户组meifa修改为haircut</span></span><br><span class=line>groupmod -n haircut meifa</span><br></pre></table></figure><h3 id=3-2-3、删除组><a class=headerlink href=#3-2-3、删除组 title=3.2.3、删除组></a>3.2.3、删除组</h3><p>语法：groupdel 组名<p>常用命令：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：删除用户组wudang</span></span><br><span class=line>groupdel wudang</span><br></pre></table></figure><h2 id=3-3、用户><a class=headerlink href=#3-3、用户 title=3.3、用户></a>3.3、用户</h2><h3 id=3-3-1、创建用户><a class=headerlink href=#3-3-1、创建用户 title=3.3.1、创建用户></a>3.3.1、创建用户</h3><p>语法：useradd [参数] 用户名<p>参数说明：<ul><li>-c<备注> 　加上备注文字。备注文字会保存在passwd的备注栏位中。<li>-d<登入目录> 　指定用户登入时的起始目录。<li>-D 　变更预设值。<li>-e<有效期限> 　指定帐号的有效期限。<li>-f<缓冲天数> 　指定在密码过期后多少天即关闭该帐号。<li>-g<群组> 　指定用户所属的群组。<li>-G<群组> 　指定用户所属的附加群组。<li>-m 　自动建立用户的登入目录。<li>-M 　不要自动建立用户的登入目录。<li>-n 　取消建立以用户名称为名的群组。<li>-r 　建立系统帐号。<li>-s<shell>　 　指定用户登入后所使用的shell。 <li>-u<uid> 　指定用户ID。 <p>常用命令：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：创建用户xm，并将其放到用户组xm中。</span></span><br><span class=line>useradd xm</span><br><span class=line></span><br><span class=line><span class=comment># 命令2：创建用户xm，并指定该用户的家目录为test</span></span><br><span class=line>useradd -d <span class=built_in>test</span> xm</span><br><span class=line></span><br><span class=line><span class=comment># 命令2：添加用户zwj，且指定用户组为wudang</span></span><br><span class=line>useradd -g wudang zwj</span><br></pre></table></figure> <blockquote><p>创建好的用户信息可以在<code>/etc/passwd</code>中看到。</blockquote> <h3 id=3-3-2、设置密码><a class=headerlink href=#3-3-2、设置密码 title=3.3.2、设置密码></a>3.3.2、设置密码</h3><p>（1）为用户xm设置密码</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：为用户xm设置密码123456</span></span><br><span class=line>passwd xm  <span class=comment># 回车后系统提示输入密码，该密码就是用户密码</span></span><br></pre></table></figure> <h3 id=3-3-3、查询用户><a class=headerlink href=#3-3-3、查询用户 title=3.3.3、查询用户></a>3.3.3、查询用户</h3><p>（1）查询名为xm的用户信息</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：查询用户xm</span></span><br><span class=line><span class=built_in>id</span> xm</span><br></pre></table></figure> <h3 id=3-3-4、修改用户><a class=headerlink href=#3-3-4、修改用户 title=3.3.4、修改用户></a>3.3.4、修改用户</h3><p>（1）修改密码</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 回车后，输入需要设置的密码</span></span><br><span class=line>passwd user_name</span><br></pre></table></figure> <p>（2）修改用户所属的组</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：将zwj的组修改为shaolin</span></span><br><span class=line>usermod -g shaolin zwj</span><br></pre></table></figure> <h3 id=3-3-5、切换用户><a class=headerlink href=#3-3-5、切换用户 title=3.3.5、切换用户></a>3.3.5、切换用户</h3><p>语法：su - 要切换的用户名</p> <p>常用命令：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：切换到用户zf</span></span><br><span class=line>su - zf</span><br><span class=line></span><br><span class=line><span class=comment># 命令2：返回到原来用户</span></span><br><span class=line><span class=built_in>exit</span></span><br></pre></table></figure> <h3 id=3-3-6、删除用户><a class=headerlink href=#3-3-6、删除用户 title=3.3.6、删除用户></a>3.3.6、删除用户</h3><p>语法：userdel 用户名</p> <p>常用命令：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：删除用户xm，但保留家目录</span></span><br><span class=line>userdel xm</span><br><span class=line></span><br><span class=line><span class=comment># 命令2：删除用户xm，并删除家目录</span></span><br><span class=line>userdel -r xm</span><br></pre></table></figure> <p><font color=red>注意：删除用户时一般保留家目录。</font></p> <h1 id=4、基础指令><a class=headerlink href=#4、基础指令 title=4、基础指令></a>4、基础指令</h1><h2 id=4-1、帮助指令><a class=headerlink href=#4-1、帮助指令 title=4.1、帮助指令></a>4.1、帮助指令</h2><h3 id=4-1-1、man指令><a class=headerlink href=#4-1-1、man指令 title=4.1.1、man指令></a>4.1.1、man指令</h3><p>语法：man [命令/配置文件]</p> <h3 id=4-1-2、help指令><a class=headerlink href=#4-1-2、help指令 title=4.1.2、help指令></a>4.1.2、help指令</h3><p>语法：help 命令</p> <h2 id=4-2、磁盘管理><a class=headerlink href=#4-2、磁盘管理 title=4.2、磁盘管理></a>4.2、磁盘管理</h2><h3 id=4-2-1、系統分区-挂载><a class=headerlink href=#4-2-1、系統分区-挂载 title=4.2.1、系統分区/挂载></a>4.2.1、系統分区/挂载</h3><h4 id=4-2-1-1、分区方式><a class=headerlink href=#4-2-1-1、分区方式 title=4.2.1.1、分区方式></a>4.2.1.1、分区方式</h4><ul><li><strong>MBR分区</strong><ol><li>最多支持4个分区。<li>系统只能安装在主分区。<li>扩展分区要占一个主分区。<li>MBR最大支持2TB，但拥有良好的兼容性。</ol><li><strong>GTP分区</strong><ol><li>支持无限个主分区。（操作系统可能有限制，windows下最多128个分区）。<li>最大支持18EB。（1EB = 1024PB，1PB = 1024TB）<li>windows7 64位以后支持gtp分区。</ol></ul> <h4 id=4-2-1-2、硬盘类型><a class=headerlink href=#4-2-1-2、硬盘类型 title=4.2.1.2、硬盘类型></a>4.2.1.2、硬盘类型</h4><p><strong>（1）IDE硬盘</strong></p> <p>驱动器标识符为 <code>hdx~</code>。</p> <ul><li><p><code>hd</code>：表明分区所在设备的类型，是指IDE硬盘。</p><li><p><code>x</code>：为盘号。</p> <ul><li>a为基本盘。<li>b为基本盘从盘。<li>c为辅助主盘。<li>d为辅助从盘。</ul><li><p><code>~</code>：代表分区。</p> <p>前四个分区用1-4的4个数字标识，它们是主分区或扩展分区。从5开始就是逻辑分区。</p></ul> <p><strong>（2）SCSI硬盘</strong></p> <p>SCSI硬盘标识符为 <code>sdx~</code>。其它与IDE硬盘中的相关描述类似。</p> <h4 id=4-2-1-3、查看分区挂载><a class=headerlink href=#4-2-1-3、查看分区挂载 title=4.2.1.3、查看分区挂载></a>4.2.1.3、查看分区挂载</h4><p><strong>（1）命令lsblk</strong></p> <p>语法如下：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>lsblk </span><br></pre></table></figure> <p>参数解析：</p> <ul><li>-f：查看详细的设备挂载情况，显示文件系统信息。</ul> <h4 id=4-2-1-4、分区挂载><a class=headerlink href=#4-2-1-4、分区挂载 title=4.2.1.4、分区挂载></a>4.2.1.4、分区挂载</h4><p><strong>（1）添加硬盘</strong></p> <p>为虚拟机添加硬盘。</p> <p><strong>（2）硬盘分区</strong></p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>fdisk /dev/sdb</span><br><span class=line><span class=comment># 后续依次输入：m / n / e / 1 / w</span></span><br></pre></table></figure> <p><strong>（3）格式化分区</strong></p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>mkfs -t xfs /dev/sdb1</span><br></pre></table></figure> <p><strong>（4）挂载</strong></p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment># 第一步：创建需要挂载的目录，比如该目录是 /home/newdisk</span></span><br><span class=line><span class=built_in>mkdir</span> -p /home/newdisk</span><br><span class=line></span><br><span class=line><span class=comment># 第二步：执行挂载操作</span></span><br><span class=line>mount /dev/sdb1 /home/newdisk</span><br></pre></table></figure> <p>注意：磁盘卸载命令为<code>umount /home/newdisk</code></p> <h4 id=4-2-1-5、自动挂载><a class=headerlink href=#4-2-1-5、自动挂载 title=4.2.1.5、自动挂载></a>4.2.1.5、自动挂载</h4><p><strong>默认情况下，系统重启会导致之前的挂载丢失，为解决此问题需要设置自动挂载。</strong></p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment># 第一步：编辑 /etc/fstab 文件，将挂载关系添加至该文件中。</span></span><br><span class=line>vim /etc/fstab </span><br><span class=line></span><br><span class=line><span class=comment># 添加如下内容（根据自己本机情况来添加）</span></span><br><span class=line>/dev/sdb1         /home/newdisk       ext4         defaults         0 0</span><br><span class=line></span><br><span class=line><span class=comment># 第二步：执行mount命令，开启自动挂载。</span></span><br><span class=line>mount -a</span><br></pre></table></figure> <h3 id=4-2-2、查看磁盘使用><a class=headerlink href=#4-2-2、查看磁盘使用 title=4.2.2、查看磁盘使用></a>4.2.2、查看磁盘使用</h3><h4 id=4-2-2-1、df命令><a class=headerlink href=#4-2-2-1、df命令 title=4.2.2.1、df命令></a>4.2.2.1、df命令</h4><p>作用：<strong>用于显示目前在 Linux 系统上的文件系统磁盘使用情况统计。</strong></p> <p>语法：<code>df [选项]... [FILE]...</code></p> <ul><li>文件-a, –all 包含所有的具有 0 Blocks 的文件系统<li>文件–block-size={SIZE} 使用 {SIZE} 大小的 Blocks<li>文件-h, –human-readable 使用人类可读的格式(预设值是不加这个选项的…)<li>文件-H, –si 很像 -h, 但是用 1000 为单位而不是用 1024<li>文件-i, –inodes 列出 inode 资讯，不列出已使用 block<li>文件-k, –kilobytes 就像是 –block-size=1024<li>文件-l, –local 限制列出的文件结构<li>文件-m, –megabytes 就像 –block-size=1048576<li>文件–no-sync 取得资讯前不 sync (预设值)<li>文件-P, –portability 使用 POSIX 输出格式<li>文件–sync 在取得资讯前 sync<li>文件-t, –type=TYPE 限制列出文件系统的 TYPE<li>文件-T, –print-type 显示文件系统的形式<li>文件-x, –exclude-type=TYPE 限制列出文件系统不要显示 TYPE<li>文件-v (忽略)<li>文件–help 显示这个帮手并且离开<li>文件–version 输出版本资讯并且离开</ul> <h4 id=4-2-2-2、du命令><a class=headerlink href=#4-2-2-2、du命令 title=4.2.2.2、du命令></a>4.2.2.2、du命令</h4><p>作用：<strong>显示目录或文件大小。</strong></p> <p>语法：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>du</span> [-abcDhHklmsSx][-L <符号连接>][-X <文件>][--block-size][--exclude=<目录或文件>][--max-depth=<目录层数>][--<span class=built_in>help</span>][--version][目录或文件]</span><br></pre></table></figure> <p>参数说明：</p> <ul><li>-a或-all 显示目录中个别文件的大小。<li>-b或-bytes 显示目录或文件大小时，以byte为单位。<li>-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。<li>-D或–dereference-args 显示指定符号连接的源文件大小。<li>-h或–human-readable 以K，M，G为单位，提高信息的可读性。<li>-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。<li>-k或–kilobytes 以1024 bytes为单位。<li>-l或–count-links 重复计算硬件连接的文件。<li>-L<符号连接>或–dereference<符号连接> 显示选项中所指定符号连接的源文件大小。<li>-m或–megabytes 以1MB为单位。<li>-s或–summarize 仅显示总计。<li>-S或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。<li>-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。<li>-X<文件>或–exclude-from=<文件> 在<文件>指定目录或文件。<li>–exclude=<目录或文件> 略过指定的目录或文件。<li>–max-depth=<目录层数> 超过指定层数的目录后，予以忽略。<li>–help 显示帮助。<li>–version 显示版本信息。</ul> <h3 id=4-2-3、创建-删除目录><a class=headerlink href=#4-2-3、创建-删除目录 title=4.2.3、创建/删除目录></a>4.2.3、创建/删除目录</h3><h4 id=4-2-3-1、mkdir命令><a class=headerlink href=#4-2-3-1、mkdir命令 title=4.2.3.1、mkdir命令></a>4.2.3.1、mkdir命令</h4><p>作用：<strong>用于创建目录。</strong></p> <p>语法：<code>mkdir [-p] dirName</code></p> <p>参数说明：</p> <ul><li>-p 确保目录名称存在，不存在时则创建。</ul> <h4 id=4-2-3-2、rmdir命令><a class=headerlink href=#4-2-3-2、rmdir命令 title=4.2.3.2、rmdir命令></a>4.2.3.2、rmdir命令</h4><p>作用：<strong>删除空目录。</strong></p> <p>语法：<code>rmdir [-p] dirName</code></p> <p>参数：</p> <ul><li>-p 当子目录被删除 后 也是空目录的话，则顺便一并删除。</ul> <h3 id=4-2-4、查看目录子项><a class=headerlink href=#4-2-4、查看目录子项 title=4.2.4、查看目录子项></a>4.2.4、查看目录子项</h3><h4 id=4-2-4-1、ls命令><a class=headerlink href=#4-2-4-1、ls命令 title=4.2.4.1、ls命令></a>4.2.4.1、ls命令</h4><p>作用：<strong>列出当前目录下所有文件和目录。</strong></p> <p>语法： ls [-alrtAFR] [name…]</p> <p>参数：</p> <ul><li>-a 显示所有文件及目录 (<strong>.</strong> 开头的隐藏文件也会列出)<li>-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出<li>-r 将文件以相反次序显示(原定依英文字母次序)<li>-t 将文件依建立时间之先后次序列出<li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)<li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”，目录则加 “/“。<li>-R 若目录下有文件，则以下之文件亦皆依序列出。</ul> <h4 id=4-2-4-2、tree命令><a class=headerlink href=#4-2-4-2、tree命令 title=4.2.4.2、tree命令></a>4.2.4.2、tree命令</h4><p>作用：以树状图形式展示目录内容。</p> <p>语法：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>tree [-aACdDfFgilnNpqstux][-I <范本样式>][-P <范本样式>][目录...]</span><br></pre></table></figure> <p>参数说明：</p> <ul><li>-a 显示所有文件和目录。<li>-A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。<li>-C 在文件和目录清单加上色彩，便于区分各种类型。<li>-d 显示目录名称而非内容。<li>-D 列出文件或目录的更改时间。<li>-f 在每个文件或目录之前，显示完整的相对路径名称。<li>-F 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上”*”,”/“,”=”,”@”,”|”号。<li>-g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。<li>-i 不以阶梯状列出文件或目录名称。<li>-L level 限制目录显示层级。<li>-l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。<li>-n 不在文件和目录清单加上色彩。<li>-N 直接列出文件和目录名称，包括控制字符。<li>-p 列出权限标示。<li>-P<范本样式> 只显示符合范本样式的文件或目录名称。<li>-q 用”?”号取代控制字符，列出文件和目录名称。<li>-s 列出文件或目录大小。<li>-t 用文件和目录的更改时间排序。<li>-u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。<li>-x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。</ul> <h3 id=4-2-5、统计目录子项><a class=headerlink href=#4-2-5、统计目录子项 title=4.2.5、统计目录子项></a>4.2.5、统计目录子项</h3><h4 id=4-2-5-1、统计home目录下文件个数><a class=headerlink href=#4-2-5-1、统计home目录下文件个数 title=4.2.5.1、统计home目录下文件个数></a>4.2.5.1、统计home目录下文件个数</h4><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment># 仅统计 /home 当前第一级的文件个数</span></span><br><span class=line><span class=built_in>ls</span> -l /home | grep <span class=string>"^-"</span> | <span class=built_in>wc</span> -l</span><br><span class=line></span><br><span class=line><span class=comment># 统计 /home 下及子目录下的所有文件个数</span></span><br><span class=line><span class=built_in>ls</span> -lR /home | grep <span class=string>"^-"</span> | <span class=built_in>wc</span> -l</span><br></pre></table></figure> <h4 id=4-2-5-2、统计home目录下目录个数><a class=headerlink href=#4-2-5-2、统计home目录下目录个数 title=4.2.5.2、统计home目录下目录个数></a>4.2.5.2、统计home目录下目录个数</h4><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment># 仅统计 /home 当前第一级的目录个数</span></span><br><span class=line><span class=built_in>ls</span> -l /home | grep <span class=string>"^d"</span> | <span class=built_in>wc</span> -l</span><br><span class=line></span><br><span class=line><span class=comment># 统计 /home 下及子目录下的所有目录个数</span></span><br><span class=line><span class=built_in>ls</span> -lR /home | grep <span class=string>"^d"</span> | <span class=built_in>wc</span> -l</span><br></pre></table></figure> <h2 id=4-3、文件属性管理><a class=headerlink href=#4-3、文件属性管理 title=4.3、文件属性管理></a>4.3、文件属性管理</h2><h3 id=4-3-1、概述><a class=headerlink href=#4-3-1、概述 title=4.3.1、概述></a>4.3.1、概述</h3><p>在 Linux 中我们可以使用 <strong>ll</strong> 或者 <strong>ls –l</strong> 命令来显示一个文件的属性以及文件所属的用户和组，如：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>[root@www /]# <span class=built_in>ls</span> -l</span><br><span class=line>total 64</span><br><span class=line>dr-xr-xr-x   2 root root 4096 Dec 14  2012 bin</span><br><span class=line>dr-xr-xr-x   4 root root 4096 Apr 19  2012 boot</span><br></pre></table></figure> <p>从左到右每一部分的解析如下图所示：</p> <p><img alt=img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%90%AB%E4%B9%89%E5%9B%BE%E7%A4%BA.jpg></p> <p>将上面列出的每一个文件的信息从左到右可分为7个部分，下面将分别解析。</p> <p><strong>（1）第一部分</strong></p> <p><img alt=img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%B1%9E%E6%80%A7%E5%90%AB%E4%B9%89%E5%9B%BE%E7%A4%BA.jpg></p> <p><strong>第一部分的第一个字符表示当前文件的类型</strong>，文件类型有如下几种：</p> <ul><li><code>d</code>：表示目录<li><code>-</code>：表示文件；<li><code>l</code>：表示 链接文档(link file)；<li><code>b</code>：表示 装置文件中 可供储存的<strong>接口设备</strong>(可随机存取装置)；<li><code>c</code>：表示 装置文件中 的<strong>串行端口设备</strong>，例如键盘、鼠标(一次性读取装置)。</ul> <p>第一个字符后面的Owner表示<strong>当前文件的所有者（用户）有什么权限</strong>。</p> <p>第一个字符后面的Group表示<strong>当前文件的所属组（用户组）有什么权限</strong>。</p> <p>第一个字符后面的OtherUsers表示<strong>其它用户对当前文件有什么权限</strong>。</p> <blockquote><p>权限由 <code>r、w、x</code>三个参数组合。<code>r</code>表示 可读(read)、 <code>w</code>表示 可写(write)、 <code>x</code>表示 可执行(execute)。 三个权限的位置不会改变，如果没有权限则由字符<code>-</code>表示。</blockquote> <p><strong>（2）第二部分表示当前文件的链接数量。</strong></p> <p>如果当前文件的类型是文件，那么这里的数字表示硬链接数量。如果当前文件的类型是目录，那么这里的的数字表示当前目录下子项目的数量。</p> <p><strong>（3）第三部分表示当前文件的所有者是哪个用户。</strong></p> <p>常用命令：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：查看当前目录中文件的所有者</span></span><br><span class=line><span class=built_in>ls</span> -ahl</span><br><span class=line></span><br><span class=line><span class=comment># 命令2：修改文件ok.txt的所有者为zf</span></span><br><span class=line><span class=built_in>chown</span> zf ok.txt</span><br></pre></table></figure> <p><strong>（4）第四部分表示当前文件所属的用户组是哪一组</strong></p> <p>常用命令：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：修改文件ok.txt的所有组为police</span></span><br><span class=line><span class=built_in>chgrp</span> police ok.txt</span><br></pre></table></figure> <p><strong>（5）第五部分表示当前文件的大小。</strong></p> <p><strong>（6）第六部分表示当前文件最后的修改时间。</strong></p> <p><strong>（7）第七部分表示当前文件的文件名。</strong></p> <h3 id=4-3-2、修改文件属性><a class=headerlink href=#4-3-2、修改文件属性 title=4.3.2、修改文件属性></a>4.3.2、修改文件属性</h3><h4 id=4-3-2-1、chattr命令><a class=headerlink href=#4-3-2-1、chattr命令 title=4.3.2.1、chattr命令></a>4.3.2.1、chattr命令</h4><p>作用：<strong>改变文件属性。</strong></p> <p>该指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式：</p> <ol><li>a：让文件或目录仅供附加用途。<li>b：不更新文件或目录的最后存取时间。<li>c：将文件或目录压缩后存放。<li>d：将文件或目录排除在倾倒操作之外。<li>i：不得任意更动文件或目录。<li>s：保密性删除文件或目录。<li>S：即时更新文件或目录。<li>u：预防意外删除。</ol> <p>语法：chattr -RV -v<版本编号> +/-/=<属性> 文件或目录…</p> <p>参数：</p> <ul><li>-R 递归处理，将指定目录下的所有文件及子目录一并处理。<li>-v<版本编号> 设置文件或目录版本。<li>-V 显示指令执行过程。<li>+<属性> 开启文件或目录的该项属性。<li>-<属性> 关闭文件或目录的该项属性。<li>=<属性> 指定文件或目录的该项属性。</ul> <h4 id=4-3-2-2、chmod命令><a class=headerlink href=#4-3-2-2、chmod命令 title=4.3.2.2、chmod命令></a>4.3.2.2、chmod命令</h4><p>作用：<strong>控制文件所属用户权限。</strong></p> <p>简介：<strong>Linux/Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）。只有文件所有者和超级用户可以修改文件或目录的权限。</strong></p> <p><img alt=img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F%E5%9B%BE%E7%A4%BA.jpg></p> <p>语法：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>chmod</span> [-cfvR] [--<span class=built_in>help</span>] [--version] mode file...</span><br></pre></table></figure> <p>参数说明：</p> <ul><li>mode : 权限设定字串，格式如下：</ul> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>[ugoa...][[+-=][rwxX]...][,...]</span><br></pre></table></figure> <p>其中：</p> <ul><li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o表示其他以外的人，a 表示这三者皆是。<li>+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。<li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</ul> <p>参数说明：</p> <ul><li>-c : 若该文件权限确实已经更改，才显示其更改动作。<li>-f : 若该文件权限无法被更改也不要显示错误讯息。<li>-v : 显示权限变更的详细资料。<li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更)。<li>–help : 显示辅助说明。<li>–version : 显示版本。</ul> <p>常用命令：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment># 数字命令方式：将 .bashrc 这个文件所有的权限都设定启用</span></span><br><span class=line><span class=comment># 如果要将权限变成 -rwxr-xr-- 呢？那么权限的分数就成为 [4+2+1][4+0+1][4+0+0]=754</span></span><br><span class=line><span class=built_in>chmod</span> 777 .bashrc </span><br><span class=line></span><br><span class=line><span class=comment># 符号命令方式：将 .bashrc 这个文件权限设置为-rwxr-xr--</span></span><br><span class=line><span class=built_in>chmod</span> u=rwx,g=rx,o=r .bashrc</span><br></pre></table></figure> <h4 id=4-3-2-3、chown-命令><a title="4.3.2.3、chown 命令" class=headerlink href=#4-3-2-3、chown-命令></a>4.3.2.3、chown 命令</h4><p>作用：<strong>管理文件所有者和文件关联组。</strong></p> <p>语法：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>chown [-cfhvR] [--help] [--version] user[:group] file...</span><br></pre></table></figure> <p>参数 :</p> <ul><li>user : 新的文件拥有者的使用者 ID。<li>group : 新的文件拥有者的使用者组(group)。<li>-c : 显示更改的部分的信息。<li>-f : 忽略错误信息。<li>-h :修复符号链接。<li>-v : 显示详细的处理信息。<li>-R : 处理指定目录以及其子目录下的所有文件。<li>–help : 显示辅助说明。<li>–version : 显示版本。</ul> <h4 id=4-3-2-4、chgrp-命令><a title="4.3.2.4、chgrp 命令" class=headerlink href=#4-3-2-4、chgrp-命令></a>4.3.2.4、chgrp 命令</h4><p>作用：<strong>修改文件或目录所属群组。</strong></p> <p>语法：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>chgrp</span> [-cfhRv][--<span class=built_in>help</span>][--version][所属群组][文件或目录...] 或 <span class=built_in>chgrp</span> [-cfhRv][--<span class=built_in>help</span>][--reference=<参考文件或目录>][--version][文件或目录...]</span><br></pre></table></figure> <p>参数说明：</p> <ul><li>-c或–changes 效果类似”-v”参数，但仅回报更改的部分。<li>-f或–quiet或–silent 　不显示错误信息。<li>-h或–no-dereference 　只对符号连接的文件作修改，而不更动其他任何相关文件。<li>-R或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。<li>-v或–verbose 　显示指令执行过程。<li>–help 　在线帮助。<li>–reference=<参考文件或目录> 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。<li>–version 　显示版本信息。</ul> <h2 id=4-4、文件管理><a class=headerlink href=#4-4、文件管理 title=4.4、文件管理></a>4.4、文件管理</h2><h3 id=4-4-1、查找文件><a class=headerlink href=#4-4-1、查找文件 title=4.4.1、查找文件></a>4.4.1、查找文件</h3><h4 id=4-4-1-1、find命令><a class=headerlink href=#4-4-1-1、find命令 title=4.4.1.1、find命令></a>4.4.1.1、find命令</h4><p>作用：<strong>find 命令用来在指定目录下查找文件。</strong>任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p> <p>语法：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>find path -option [-<span class=built_in>print</span>] [-<span class=built_in>exec</span> -ok <span class=built_in>command</span>] {} \;</span><br></pre></table></figure> <p>参数说明：</p> <p>find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</p> <ul><li>expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。<li>-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件。<li>-amin n : 在过去 n 分钟内被读取过。<li>-anewer file : 比文件 file 更晚被读取过的文件。<li>-atime n : 在过去n天内被读取过的文件。<li>-cmin n : 在过去 n 分钟内被修改过。<li>-cnewer file :比文件 file 更新的文件。<li>-ctime n : 在过去n天内被修改过的文件。<li>-empty：空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name。<li>-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写。<li>-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写。<li>-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。<li>-pid n : process id 是 n 的文件。<li>-type<ul><li>c : 文件类型是 c 的文件。<li>d: 目录<li>c: 字型装置文件<li>b: 区块装置文件<li>p: 具名贮列<li>f: 一般文件<li>l: 符号连结<li>s: socket</ul></ul> <h4 id=4-4-1-2、locate命令><a class=headerlink href=#4-4-1-2、locate命令 title=4.4.1.2、locate命令></a>4.4.1.2、locate命令</h4><p>作用：<strong>用于查找符合条件的文档</strong>，他会去保存文档和目录名称的数据库中查找合乎范本样式条件的文档或目录。一般情况只需输入 <code>locate your_file_name</code> 即可查找指定文件。</p> <p>语法：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>locate [-d ][--<span class=built_in>help</span>][--version][范本样式...]</span><br></pre></table></figure> <p>参数：</p> <ul><li>-b, –basename – 仅匹配路径名的基本名称<li>-c, –count – 只输出找到的数量<li>-d, –database DBPATH – 使用 DBPATH 指定的数据库，而不是默认数据库 /var/lib/mlocate/mlocate.db<li>-e, –existing – 仅打印当前现有文件的条目<li>-1 – 如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到 的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的 权限资料。<li>-0, –null – 在输出上带有NUL的单独条目<li>-S, –statistics – 不搜索条目，打印有关每个数据库的统计信息<li>-q – 安静模式，不会显示任何错误讯息。<li>-P, –nofollow, -H – 检查文件存在时不要遵循尾随的符号链接<li>-l, –limit, -n LIMIT – 将输出（或计数）限制为LIMIT个条目<li>-n – 至多显示 n个输出。<li>-m, –mmap – 被忽略，为了向后兼容<li>-r, –regexp REGEXP – 使用基本正则表达式<li>–regex – 使用扩展正则表达式<li>-q, –quiet – 安静模式，不会显示任何错误讯息<li>-s, –stdio – 被忽略，为了向后兼容<li>-o – 指定资料库存的名称。<li>-h, –help – 显示帮助<li>-i, –ignore-case – 忽略大小写<li>-V, –version – 显示版本信息</ul> <h3 id=4-4-2、查看文件内容><a class=headerlink href=#4-4-2、查看文件内容 title=4.4.2、查看文件内容></a>4.4.2、查看文件内容</h3><h4 id=4-4-2-1、cat命令><a class=headerlink href=#4-4-2-1、cat命令 title=4.4.2.1、cat命令></a>4.4.2.1、cat命令</h4><p>作用：<strong>将文件的全部内容输出到控制台上以供查看</strong>。需要注意的是该命令会一次性将所有内容输出到控制台，所以该命令适用于文件内容少的场景。</p> <p>语法：<code>cat [-AbeEnstTuv] [--help] [--version] fileName</code></p> <p>参数说明：</p> <ul><li><strong>-n 或 –number</strong>：由 1 开始对所有输出的行数编号。<li><strong>-b 或 –number-nonblank</strong>：和 -n 相似，只不过对于空白行不编号。<li><strong>-s 或 –squeeze-blank</strong>：当遇到有连续两行以上的空白行，就代换为一行的空白行。<li><strong>-v 或 –show-nonprinting</strong>：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。<li><strong>-E 或 –show-ends</strong> : 在每行结束处显示 $。<li><strong>-T 或 –show-tabs</strong>: 将 TAB 字符显示为 ^I。<li><strong>-A, –show-all</strong>：等价于 -vET。<li><strong>-e：</strong>等价于”-vE”选项；<li><strong>-t：</strong>等价于”-vT”选项；</ul> <h4 id=4-4-2-2、more命令><a class=headerlink href=#4-4-2-2、more命令 title=4.4.2.2、more命令></a>4.4.2.2、more命令</h4><p><strong>该命令是一个基于VI编辑器的文本过滤器，可以全屏幕按页显示文件的内容。</strong></p> <p>该命令中内置了多个快捷键供使用，详情如下：</p> <ul><li>空白键：向下翻一页。<li>enter：向下翻一行。<li>q：退出不在显示文件内容。<li>ctrl+f：向下滚动一屏。<li>ctrl+b：返回上一屏。<li>=：输出当前行的行号。<li>:f：输出文件名和当前行的行号。</ul> <p>语法：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]</span><br></pre></table></figure> <p>参数：</p> <ul><li>-num：一次显示的行数。<li>-d：提示使用者，在画面下方显示 [Press space to continue, ‘q’ to quit.] ，如果使用者按错键，则会显示 [Press ‘h’ for instructions.] 而不是 ‘哔’ 声。<li>-l：取消遇见特殊字元 ^L（送纸字元）时会暂停的功能。<li>-f：计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）。<li>-p：不以卷动的方式显示每一页，而是先清除萤幕后再显示内容。<li>-c：跟 -p 相似，不同的是先显示内容再清除其他旧资料。<li>-s：当遇到有连续两行以上的空白行，就代换为一行的空白行。<li>-u：不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）。<li>+/pattern：在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示。<li>+num：从第 num 行开始显示。<li>fileNames：欲显示内容的文档，可为复数个数。</ul> <h4 id=4-4-2-3、less命令><a class=headerlink href=#4-4-2-3、less命令 title=4.4.2.3、less命令></a>4.4.2.3、less命令</h4><p><strong>less命令用于分屏查看文件内容，与more命令类似，但比more要更强大，less支持各种终端。less在显示文件内容时并非一次将整个文件加载显示，而是根据显示内容需要进行加载，对于查看大型文件内容有较高的效率。</strong></p> <p>该命令同样支持快捷键，详情如下：</p> <ul><li>空白键：向下翻动一页。<li>pagedown：向下翻动一页。<li>pageup：向上翻动一页。<li>/字串：向下搜索字串的功能，n向下查找，N向上查找。<li>?字串：向上搜索字串的功能，n向上查找，N向下查找。<li>q：退出less程序。</ul> <p>语法：<code>less [参数] 文件 </code></p> <p>参数说明：</p> <ul><li>-b <缓冲区大小> 设置缓冲区的大小<li>-e 当文件显示结束后，自动离开<li>-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件<li>-g 只标志最后搜索的关键词<li>-i 忽略搜索时的大小写<li>-m 显示类似more命令的百分比<li>-N 显示每行的行号<li>-o <文件名> 将less 输出的内容在指定文件中保存起来<li>-Q 不使用警告音<li>-s 显示连续空行为一行<li>-S 行过长时间将超出部分舍弃<li>-x <数字> 将”tab”键显示为规定的数字空格<li>/字符串：向下搜索”字符串”的功能<li>?字符串：向上搜索”字符串”的功能<li>n：重复前一个搜索（与 / 或 ? 有关）<li>N：反向重复前一个搜索（与 / 或 ? 有关）<li>b 向上翻一页<li>d 向后翻半页<li>h 显示帮助界面<li>Q 退出less 命令<li>u 向前滚动半页<li>y 向前滚动一行<li>空格键 滚动一页<li>回车键 滚动一行<li>[pagedown]： 向下翻动一页<li>[pageup]： 向上翻动一页</ul> <h4 id=4-4-2-4、head命令><a class=headerlink href=#4-4-2-4、head命令 title=4.4.2.4、head命令></a>4.4.2.4、head命令</h4><p><strong>head命令用于显示文件开头部分内容，默认只显示文件开头前10行内容。</strong></p> <p>语法如下：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=built_in>head</span> 文件</span><br><span class=line><span class=built_in>head</span> -n 5 文件</span><br></pre></table></figure> <p>参数解析：</p> <ul><li>-n：设置显示头部内容的行数。</ul> <p>使用示例：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：查看文件info.txt内容的前3行</span></span><br><span class=line><span class=built_in>head</span> -n 3 info.txt</span><br></pre></table></figure> <h4 id=4-4-2-5、tail命令><a class=headerlink href=#4-4-2-5、tail命令 title=4.4.2.5、tail命令></a>4.4.2.5、tail命令</h4><p><strong>tail命令用于输出文件尾部内容，默认只显示文件尾部后10行内容。</strong></p> <p>语法如下：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=built_in>tail</span> 文件</span><br><span class=line><span class=built_in>tail</span> -n 5 文件</span><br><span class=line><span class=built_in>tail</span> -f 文件</span><br></pre></table></figure> <p>参数解析：</p> <ul><li>-n：设置要查看文件尾部多少行的内容。<li>-f：实时追踪文档的所有更新。</ul> <p>使用示例：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：查看文件info.txt内容的后5行</span></span><br><span class=line><span class=built_in>tail</span> -n 5 info.txt</span><br></pre></table></figure> <h3 id=4-4-3、追加文件内容><a class=headerlink href=#4-4-3、追加文件内容 title=4.4.3、追加文件内容></a>4.4.3、追加文件内容</h3><h4 id=4-4-3-1、echo命令><a class=headerlink href=#4-4-3-1、echo命令 title=4.4.3.1、echo命令></a>4.4.3.1、echo命令</h4><p><strong>echo命令会输出内容到控制台。</strong></p> <p>语法如下：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>echo</span> [选项] [要输出的内容]</span><br></pre></table></figure> <p>参数解析：</p> <ul><li>-e：支持反斜线控制的字符转换。比如：<code>\\  \n  \t</code></ul> <p>使用示例如下：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：控制台分行输出hello和world</span></span><br><span class=line><span class=built_in>echo</span> -e <span class=string>"hello\nworld"</span></span><br></pre></table></figure> <h4 id=4-4-3-2、追加操作-和><a title="4.4.3.2、追加操作>和>>" class=headerlink href=#4-4-3-2、追加操作-和></a>4.4.3.2、追加操作>和>></h4><p>语法如下：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>echo</span> 要输出的内容 [>/>>] info.txt</span><br></pre></table></figure> <p>参数解析：</p> <ul><li><code>></code>：<strong>向文件中添加内容，并覆盖已存在内容。</strong><li><code>>></code>：<strong>向文件中追加内容，不会覆盖已存在内容。</strong></ul> <p>使用示例：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：将字符串hello输出保存到文件info.txt</span></span><br><span class=line><span class=built_in>echo</span> <span class=string>"hello"</span> >> info.txt</span><br></pre></table></figure> <h3 id=4-4-4、软连接文件><a class=headerlink href=#4-4-4、软连接文件 title=4.4.4、软连接文件></a>4.4.4、软连接文件</h3><p><strong>软连接也称为符号链接，有着自己的数据块，主要存储链接到其它文件的路径。</strong></p> <p>语法如下：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>ln</span> -s [原文件或目录] [软连接名字]</span><br></pre></table></figure> <p>注意事项：</p> <ul><li>使用删除命令<code>rm -rf 软连接名/</code>后，软连接对应的真实目录中的文件也会被删除。<li>若仅仅想要删除软连接而不影响原始文件或目录，可以执行命令<code>rm -rf 软连接名</code>，与第一条描述的命令类似，只是缺少了一个<code>/</code>。</ul> <p>使用示例：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：为目录/tmp创建一个软连接tmpdir</span></span><br><span class=line><span class=built_in>ln</span> -s /tmp tmpdir</span><br></pre></table></figure> <h2 id=4-5、压缩和解压缩><a class=headerlink href=#4-5、压缩和解压缩 title=4.5、压缩和解压缩></a>4.5、压缩和解压缩</h2><h3 id=4-5-1、gzip-gunzip><a class=headerlink href=#4-5-1、gzip-gunzip title=4.5.1、gzip/gunzip></a>4.5.1、gzip/gunzip</h3><p>语法如下：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>gzip 文件</span><br><span class=line>gunzip 文件.gz</span><br></pre></table></figure> <p>注意事项：</p> <ul><li><strong>只能压缩文件，不能压缩目录</strong>。<li><strong>不保留原来的文件</strong>。<li><strong>同时多个文件会产生多个压缩包</strong>。</ul> <p>使用示例：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：压缩文件hello.txt</span></span><br><span class=line>gzip hello.txt</span><br><span class=line></span><br><span class=line><span class=comment># 命令2：解压缩文件hello.txt.gz</span></span><br><span class=line>gunzip hello.txt.gz</span><br></pre></table></figure> <h3 id=4-5-2、zip-unzip><a class=headerlink href=#4-5-2、zip-unzip title=4.5.2、zip/unzip></a>4.5.2、zip/unzip</h3><p>语法如下：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># 压缩命令语法</span></span><br><span class=line>zip [选项] [自定义名字.zip] [要压缩的内容]</span><br><span class=line><span class=comment># 解压缩命令语法</span></span><br><span class=line>unzip [选项] [自定义名字.zip]</span><br></pre></table></figure> <p>参数解析：</p> <ul><li>zip命令参数<ul><li>-r：压缩目录。</ul><li>unzip命令参数：<ul><li>-d<目录>：指定解压后文件要存放的目录。</ul></ul> <p>注意事项：</p> <ul><li><strong>zip命令在 win/linux 上都通用，可以压缩目录且保留源文件</strong>。</ul> <p>使用示例：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：压缩目录/root，然后再解压缩到/tmp目录下</span></span><br><span class=line>zip -r rootdir.zip /root</span><br><span class=line>unzip -d /tmp rootdir.zip</span><br><span class=line></span><br><span class=line><span class=comment># 命令2：一次将多个文件压缩成一个文件，然后再解压缩到/tmp目录下</span></span><br><span class=line>zip morefile.zip houge.txt bailongma.txt</span><br><span class=line>unzip -d /tmp morefile.zip</span><br></pre></table></figure> <h3 id=4-5-3、tar打包><a class=headerlink href=#4-5-3、tar打包 title=4.5.3、tar打包></a>4.5.3、tar打包</h3><p>语法如下：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>tar [选项] [自定义名字.tar.gz] [需要打包的内容]</span><br></pre></table></figure> <p>参数解析：</p> <ul><li>-z：打包的同时进行压缩（使用了gzip）。<li>-c：生成.tar打包文件。<li>-v：显示详细信息。<li>-f：指定压缩后的文件名。<li>-x：解包.tar文件。<li>-C：解压缩到指定目录。</ul> <p>使用示例：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：将多个文件打包并压缩，然后再解包到/tmp目录下</span></span><br><span class=line>tar -zcvf houma.tar.gz houge.txt bailongma.txt</span><br><span class=line>tar -zxvf houma.tar.gz -C /tmp</span><br></pre></table></figure> <h2 id=4-6、时间日期><a class=headerlink href=#4-6、时间日期 title=4.6、时间日期></a>4.6、时间日期</h2><h3 id=4-6-1、date命令><a class=headerlink href=#4-6-1、date命令 title=4.6.1、date命令></a>4.6.1、date命令</h3><p>语法如下：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>date</span> [选项] ... [+format]</span><br></pre></table></figure> <p>参数解析：</p> <ul><li>-d<时间字符串>：显示指定的时间字符串表示的日期，非当前时间。<li>-s<日期时间>：设置系统日期时间。<li>date +%Y：显示当前年份。<li>date +%m：显示当前月份。<li>date +%d：显示当前哪一天。<li>date “+%Y-%m-%d %H:%M:%S”：显示年月日时分秒。</ul> <h3 id=4-6-2、cal命令><a class=headerlink href=#4-6-2、cal命令 title=4.6.2、cal命令></a>4.6.2、cal命令</h3><h1 id=5、网络管理><a class=headerlink href=#5、网络管理 title=5、网络管理></a>5、网络管理</h1><h2 id=5-1、查看网络IP和网关><a class=headerlink href=#5-1、查看网络IP和网关 title=5.1、查看网络IP和网关></a>5.1、查看网络IP和网关</h2><p><img alt=image-20210919111446177 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210919111446177.png></p> <p><img alt=image-20210919111853400 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210919111853400.png></p> <h2 id=5-2、网络环境配置><a class=headerlink href=#5-2、网络环境配置 title=5.2、网络环境配置></a>5.2、网络环境配置</h2><h3 id=5-2-1、配置静态IP><a class=headerlink href=#5-2-1、配置静态IP title=5.2.1、配置静态IP></a>5.2.1、配置静态IP</h3><p>编辑<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code>文件，添加如下配置：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line>NAME=ens33</span><br><span class=line>TYPE=Ethernet</span><br><span class=line>UUID=647650b9-b648-4848-b2b5-469f6840a621</span><br><span class=line>DEVICE=ens33</span><br><span class=line>ONBOOT=<span class=built_in>yes</span></span><br><span class=line>PROXY_METHOD=none</span><br><span class=line>BOOTPROTO=static</span><br><span class=line>DEFROUTE=<span class=built_in>yes</span></span><br><span class=line>IPV4_FAILURE_FATAL=<span class=built_in>yes</span></span><br><span class=line>IPV6INIT=no</span><br><span class=line>IPADDR=192.168.93.129</span><br><span class=line>GATEWAY=192.168.93.2</span><br><span class=line>DNS1=192.168.93.2</span><br><span class=line>PREFIX=24</span><br></pre></table></figure> <p>注意：配置完毕后需要重启系统。</p> <h3 id=5-2-2、配置动态IP><a class=headerlink href=#5-2-2、配置动态IP title=5.2.2、配置动态IP></a>5.2.2、配置动态IP</h3><p>编辑<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code>文件，添加如下配置：</p> <figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=attr>NAME</span>=<span class=string>ens33</span></span><br><span class=line><span class=attr>DEVICE</span>=<span class=string>ens33</span></span><br><span class=line><span class=attr>TYPE</span>=<span class=string>Ethernet</span></span><br><span class=line><span class=attr>UUID</span>=<span class=string>647650b9-b648-4848-b2b5-469f6840a621</span></span><br><span class=line><span class=attr>ONBOOT</span>=<span class=string>yes</span></span><br><span class=line><span class=attr>PROXY_METHOD</span>=<span class=string>none</span></span><br><span class=line><span class=attr>BROWSER_ONLY</span>=<span class=string>no</span></span><br><span class=line><span class=attr>BOOTPROTO</span>=<span class=string>dhcp</span></span><br><span class=line><span class=attr>DEFROUTE</span>=<span class=string>yes</span></span><br><span class=line><span class=attr>IPV4_FAILURE_FATAL</span>=<span class=string>no</span></span><br><span class=line><span class=attr>IPV6INIT</span>=<span class=string>yes</span></span><br><span class=line><span class=attr>IPV6_AUTOCONF</span>=<span class=string>yes</span></span><br><span class=line><span class=attr>IPV6_DEFROUTE</span>=<span class=string>yes</span></span><br><span class=line><span class=attr>IPV6_FAILURE_FATAL</span>=<span class=string>no</span></span><br><span class=line><span class=attr>IPV6_ADDR_GEN_MODE</span>=<span class=string>stable-privacy</span></span><br></pre></table></figure> <p>注意：配置完毕后需要重启系统。</p> <h2 id=5-3、netstat指令><a class=headerlink href=#5-3、netstat指令 title=5.3、netstat指令></a>5.3、netstat指令</h2><p>简介：<strong>netstat 命令用于显示网络状态。利用 netstat 指令可查看系统网络情况。</strong></p> <p>语法：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>netstat [-acCeFghilMnNoprstuvVwx][-A<网络类型>][--ip]</span><br></pre></table></figure> <p>参数说明：</p> <ul><li>-a或–all 显示所有连线中的Socket。<li>-A<网络类型>或–<网络类型> 列出该网络类型连线中的相关地址。<li>-c或–continuous 持续列出网络状态。<li>-C或–cache 显示路由器配置的快取信息。<li>-e或–extend 显示网络其他相关信息。<li>-F或–fib 显示路由缓存。<li>-g或–groups 显示多重广播功能群组组员名单。<li>-h或–help 在线帮助。<li>-i或–interfaces 显示网络界面信息表单。<li>-l或–listening 显示监控中的服务器的Socket。<li>-M或–masquerade 显示伪装的网络连线。<li>-n或–numeric 直接使用IP地址，而不通过域名服务器。<li>-N或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称。<li>-o或–timers 显示计时器。<li>-p或–programs 显示正在使用Socket的程序识别码和程序名称。<li>-r或–route 显示Routing Table。<li>-s或–statistics 显示网络工作信息统计表。<li>-t或–tcp 显示TCP传输协议的连线状况。<li>-u或–udp 显示UDP传输协议的连线状况。<li>-v或–verbose 显示指令执行过程。<li>-V或–version 显示版本信息。<li>-w或–raw 显示RAW传输协议的连线状况。<li>-x或–unix 此参数的效果和指定”-A unix”参数相同。<li>–ip或–inet 此参数的效果和指定”-A inet”参数相同。</ul> <h1 id=6、进程管理><a class=headerlink href=#6、进程管理 title=6、进程管理></a>6、进程管理</h1><h2 id=6-1、简介><a class=headerlink href=#6-1、简介 title=6.1、简介></a>6.1、简介</h2><p><strong>Linux中的每个执行程序都是 一个进程，每个进程都有一个ID号。系统服务通常以 后台进程 方式存在，直到系统关机。</strong></p> <h2 id=6-2、查看系统进程><a class=headerlink href=#6-2、查看系统进程 title=6.2、查看系统进程></a>6.2、查看系统进程</h2><h3 id=6-2-1、ps命令><a class=headerlink href=#6-2-1、ps命令 title=6.2.1、ps命令></a>6.2.1、ps命令</h3><p>语法：<code>ps [options] [--help]</code></p> <p>参数：</p> <ul><li>-A 列出所有的进程<li>-w 显示加宽可以显示较多的资讯<li>-au 显示较详细的资讯<li>-aux 显示所有包含其他使用者的行程<li>au(x) 输出格式 :</ul> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</span><br></pre></table></figure> <ul><li>USER: 行程拥有者<li>PID：p’ppid<li>%CPU: 占用的 CPU 使用率<li>%MEM: 占用的记忆体使用率<li>VSZ: 占用的虚拟记忆体大小<li>RSS: 占用的记忆体大小<li>TTY: 终端的次要装置号码 (minor device number of tty)<li>STAT: 该行程的状态:<ul><li>D: 无法中断的休眠状态 (通常 IO 的进程)<li>R: 正在执行中<li>S: 静止状态<li>T: 暂停执行<li>Z: 不存在但暂时无法消除<li>W: 没有足够的记忆体分页可分配<li>&LT: 高优先序的行程<li>N: 低优先序的行程<li>L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)</ul><li>START: 行程开始时间<li>TIME: 执行时间<li>COMMAND：执行指令</ul> <h3 id=6-2-2、pstree命令><a class=headerlink href=#6-2-2、pstree命令 title=6.2.2、pstree命令></a>6.2.2、pstree命令</h3><p>简介：<strong>pstree命令将所有行程以树状图显示，树状图将会以 pid (如果有指定) 或是以 init 这个基本行程为根 (root)，如果有指定使用者 id，则树状图会只显示该使用者所拥有的行程。</strong></p> <p>语法：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>pstree [-a] [-c] [-h|-Hpid] [-l] [-n] [-p] [-u] [-G|-U] [pid|user]</span><br><span class=line><span class=comment># or</span></span><br><span class=line>pstree -V</span><br></pre></table></figure> <p>参数说明：</p> <ul><li>-a 显示该行程的完整指令及参数, 如果是被记忆体置换出去的行程则会加上括号。<li>-c 如果有重覆的行程名, 则分开列出（预设值是会在前面加上 *）。</ul> <h2 id=6-3、终止进程><a class=headerlink href=#6-3、终止进程 title=6.3、终止进程></a>6.3、终止进程</h2><h3 id=6-3-1、简介><a class=headerlink href=#6-3-1、简介 title=6.3.1、简介></a>6.3.1、简介</h3><p>**终止进程可以采用命令 <code>kill、killall、pkill</code>**。</p> <h3 id=6-3-2、kill命令><a class=headerlink href=#6-3-2、kill命令 title=6.3.2、kill命令></a>6.3.2、kill命令</h3><p>简介：<strong>kill 命令可以通过指定进程PID来杀死或删除程序。</strong></p> <p>语法：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>kill</span> [-s <信息名称或编号>][程序]　或　<span class=built_in>kill</span> [-l <信息编号>]</span><br></pre></table></figure> <p>参数说明：</p> <ul><li>-l <信息编号>：若不加<信息编号>选项，则 -l 参数会列出全部的信息名称。<li>-s <信息名称或编号>：指定要送出的信息。<li>[程序]：可以是程序的PID或是PGID，也可以是工作编号。</ul> <p>使用 kill -l 命令列出所有可用信号。最常用信号：</p> <ul><li>1 (HUP)：重新加载进程。<li>9 (KILL)：杀死一个进程。<li>15 (TERM)：正常停止一个进程。</ul> <h3 id=6-3-3、killall命令><a class=headerlink href=#6-3-3、killall命令 title=6.3.3、killall命令></a>6.3.3、killall命令</h3><p>简介：<strong>killall 可以通过指定进程名字来杀死进程，与 kill 不同的是会杀死指定名字的所有进程。</strong></p> <p>语法：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>killall [选项]  name</span><br></pre></table></figure> <p>参数说明：</p> <ul><li>name ： 进程名</ul> <p>选项包含如下几个参数：</p> <ul><li>-e | –exact ： 进程需要和名字完全相符。<li>-I | –ignore-case ：忽略大小写。<li>-g | –process-group ：结束进程组。<li>-i | –interactive ：结束之前询问。<li>-l | –list ：列出所有的信号名称。<li>-q | –quite ：进程没有结束时，不输出任何信息。<li>-r | –regexp ：将进程名模式解释为扩展的正则表达式。<li>-s | –signal ：发送指定信号。<li>-u | –user ：结束指定用户的进程。<li>-v | –verbose ：显示详细执行过程。<li>-w | –wait ：等待所有的进程都结束。<li>-V |–version ：显示版本信息。<li>–help ：显示帮助信息。</ul> <h3 id=6-3-4、pkill命令><a class=headerlink href=#6-3-4、pkill命令 title=6.3.4、pkill命令></a>6.3.4、pkill命令</h3><p>简介：<strong>pkill 用于杀死一个进程，与 kill 不同的是它会杀死指定名字的所有进程，类似于 killall命令。</strong></p> <p>语法：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>pkill [选项]  name</span><br></pre></table></figure> <p>参数说明：</p> <ul><li>name ： 进程名</ul> <p>选项包含如下几个参数：</p> <ul><li>-o 仅向找到的最小（起始）进程号发送信号 -n 仅向找到的最大（结束）进程号发送信号<li>-P 指定父进程号发送信号<li>-g 指定进程组<li>-t 指定开启进程的终端</ul> <h2 id=6-4、监控进程><a class=headerlink href=#6-4、监控进程 title=6.4、监控进程></a>6.4、监控进程</h2><p>简介：<strong>top命令用于实时显示 process 动态。</strong></p> <p>语法：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]</span><br></pre></table></figure> <p>参数说明：</p> <ul><li>d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s<li>q : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行<li>c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称<li>S : 累积模式，会将己完成或消失的子进程 ( dead child process ) 的 CPU time 累积起来<li>s : 安全模式，将交谈式指令取消, 避免潜在的危机<li>i : 不显示任何闲置 (idle) 或无用 (zombie) 的进程<li>n : 更新的次数，完成后将会退出 top<li>b : 批次档模式，搭配 “n” 参数一起使用，可以用来将 top 的结果输出到档案内</ul> <h1 id=7、服务管理><a class=headerlink href=#7、服务管理 title=7、服务管理></a>7、服务管理</h1><h2 id=7-1、简介><a class=headerlink href=#7-1、简介 title=7.1、简介></a>7.1、简介</h2><p><strong>服务本质就是进程，且运行在后台，通常会监听某个端口，等待其它程序请求，故称之为守护进程</strong>。</p> <h2 id=7-2、查看服务开启情况><a class=headerlink href=#7-2、查看服务开启情况 title=7.2、查看服务开启情况></a>7.2、查看服务开启情况</h2><p>查看方式如下：</p> <ol><li>指令<code>setup</code><li>指令<code>ls -l /etc/init.d/</code></ol> <h2 id=7-3、查看服务运行级别><a class=headerlink href=#7-3、查看服务运行级别 title=7.3、查看服务运行级别></a>7.3、查看服务运行级别</h2><p>查看或修改默认级别方式如下：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment># 第一步：编辑/etc/inittab文件</span></span><br><span class=line>vim /etc/inittab</span><br><span class=line></span><br><span class=line><span class=comment># 第二步：设置需要的运行级别，比如设置运行级别为5</span></span><br><span class=line><span class=built_in>id</span>: 5: initdefault: </span><br></pre></table></figure> <h2 id=7-4、服务操作指令><a class=headerlink href=#7-4、服务操作指令 title=7.4、服务操作指令></a>7.4、服务操作指令</h2><h3 id=7-4-1、service（CentOS6）><a class=headerlink href=#7-4-1、service（CentOS6） title=7.4.1、service（CentOS6）></a>7.4.1、service（CentOS6）</h3><p>简介：<strong>service命令是 Redhat Linux 兼容发行版中用来控制系统服务的实用工具，它可以启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。</strong></p> <p>语法：service 服务名 [start / stop / restart / reload / status]</p> <blockquote><p>以上语法方式仅仅是临时生效，系统重启后会变为最初状态。如果设置永久生效，需要使用<code>chkconfig</code>指令。</blockquote> <h3 id=7-4-2、systemctl（CentOS7）><a class=headerlink href=#7-4-2、systemctl（CentOS7） title=7.4.2、systemctl（CentOS7）></a>7.4.2、systemctl（CentOS7）</h3><p>简介：<strong>centOS7.0之后不再使用<code>service</code>指令，改用<code>systemctl</code>指令。</strong></p> <p>语法如下：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>systemctl start/stop/restart/status 服务名字</span><br></pre></table></figure> <blockquote><p>除了使用命令查看服务外，可以通过访问<code>/usr/lib/systemd/system</code>来查看服务。</blockquote> <p>使用示例：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 示例1：开启服务</span></span><br><span class=line>systemctl start network</span><br></pre></table></figure> <h3 id=7-4-3、chkconfig><a class=headerlink href=#7-4-3、chkconfig title=7.4.3、chkconfig></a>7.4.3、chkconfig</h3><p>简介：<strong>chkconfig命令用于检查、设置系统服务</strong>，是Red Hat公司遵循GPL规则所开发的程序，可查询操作系统在每一个执行等级中会执行哪些系统服务，其包括各类常驻服务。谨记 chkconfig 不是立即自动禁止或激活一个服务，它只是简单的改变了符号连接。</p> <p>语法：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>chkconfig [--add][--del][--list][系统服务] </span><br><span class=line><span class=comment># or</span></span><br><span class=line>chkconfig [--level <等级代号>][系统服务][on/off/reset]</span><br></pre></table></figure> <p>参数：</p> <ul><li>–add：增加所指定的系统服务，让 chkconfig 指令得以管理它，并同时在系统启动的叙述文件内增加相关数据。<li>–del：删除所指定的系统服务，不再由 chkconfig 指令管理，并同时在系统启动的叙述文件内删除相关数据。<li>–level<等级代号>：指定读系统服务要在哪一个执行等级中开启或关闭。</ul> <p><strong>常用命令</strong>：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：查看 所有服务 开启情况</span></span><br><span class=line>chkconfig --list</span><br><span class=line><span class=comment># 命令2：查看 sshd服务 开启情况</span></span><br><span class=line>chkconfig --list | grep sshd</span><br><span class=line><span class=comment># 命令3：设置将 sshd服务 在运行级别5下关闭</span></span><br><span class=line>chkconfig --level 5 sshd off</span><br></pre></table></figure> <h1 id=8、定时任务><a class=headerlink href=#8、定时任务 title=8、定时任务></a>8、定时任务</h1><h2 id=8-1、crontab命令><a class=headerlink href=#8-1、crontab命令 title=8.1、crontab命令></a>8.1、crontab命令</h2><h3 id=8-1-1、简介><a class=headerlink href=#8-1-1、简介 title=8.1.1、简介></a>8.1.1、简介</h3><p><strong>Linux crontab是用来定期执行程序的命令</strong>。</p> <p>当安装完成操作系统之后，默认便会启动此任务调度命令。crond 命令每分钟会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</p> <p>注意：<strong>新建 cron 任务不会马上执行，至少要过 2 分钟后才可以，当然你可以重启 cron 来马上执行</strong>。</p> <p>linux 任务调度的工作主要分为以下两类：</p> <ul><li><strong>系统执行工作</strong>：系统周期性所要执行的工作，如备份系统数据、清理缓存。<li><strong>个人执行工作</strong>：某个用户定期要做的工作。</ul> <p>每个用户都有自己的cron配置文件，通过命令<code>crontab -e</code>就可以编辑。</p> <p>一般情况下我们编辑好用户的cron配置文件保存退出后会自动存放于/var/spool/cron/目录中，文件以用户名命名，linux的cron服务是每隔一分钟去读取一次/var/spool/cron、/etc/crontab、/etc/cron.d下面所有的内容。</p> <h3 id=8-1-2、语法参数介绍><a class=headerlink href=#8-1-2、语法参数介绍 title=8.1.2、语法参数介绍></a>8.1.2、语法参数介绍</h3><p>语法：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>crontab [ -u user ] file</span><br><span class=line><span class=comment># or</span></span><br><span class=line>crontab [ -u user ] { -l | -r | -e }</span><br></pre></table></figure> <p>说明：</p> <p><strong>crontab 可实现在固定时间或固定间隔执行程序</strong>。</p> <p><strong><code>-u user</code>表示指定user时程表，其前提是必须有权限才能指定他人时程表。如果不使用<code>-u user</code>则表示设定自己时程表。</strong></p> <p>参数说明：</p> <ul><li>-l : 查询crontab任务。<li>-e : 编辑crontab定时任务。<li>-r : 删除当前用户所有的crontab任务。</ul> <p>时间格式：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>f1 f2 f3 f4 f5 program</span><br></pre></table></figure> <ul><li>f1 表示<strong>分钟</strong>，f2 表示<strong>小时</strong>，f3 表示一个月份中的第几<strong>日</strong>，f4 表示<strong>月</strong>份，f5 表示一个星期中的第几<strong>天</strong>。program 表示要执行的程序。<li>当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其馀类推<li>当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其馀类推<li>当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次，f2 为 */n 表示每 n 小时个时间间隔执行一次，其馀类推<li>当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行，其馀类推</ul> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>*    *    *    *    *</span><br><span class=line>-    -    -    -    -</span><br><span class=line>|    |    |    |    |</span><br><span class=line>|    |    |    |    +----- 星期中星期几 (0 - 6) (星期天 为0)</span><br><span class=line>|    |    |    +---------- 月份 (1 - 12) </span><br><span class=line>|    |    +--------------- 一个月中的第几天 (1 - 31)</span><br><span class=line>|    +-------------------- 小时 (0 - 23)</span><br><span class=line>+------------------------- 分钟 (0 - 59)</span><br></pre></table></figure> <p>使用者也可以将所有的设定先存放在文件中，用crontab file的方式来设定执行时间。</p> <h3 id=8-1-3、常用命令><a class=headerlink href=#8-1-3、常用命令 title=8.1.3、常用命令></a>8.1.3、常用命令</h3><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment># 每一分钟执行一次 /bin/ls：</span></span><br><span class=line>* * * * * /bin/ls</span><br><span class=line><span class=comment># 在12月内, 每天的早上 6 点到 12 点，每隔 3 个小时 0 分钟执行一次 /usr/bin/backup：</span></span><br><span class=line>0 6-12/3 * 12 * /usr/bin/backup</span><br><span class=line><span class=comment># 周一到周五每天下午 5:00 寄一封信给 alex@domain.name：</span></span><br><span class=line>0 17 * * 1-5 mail -s <span class=string>"hi"</span> alex@domain.name < /tmp/maildata</span><br><span class=line><span class=comment># 每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分....执行 echo "haha"：</span></span><br><span class=line>20 0-23/2 * * * <span class=built_in>echo</span> <span class=string>"haha"</span></span><br></pre></table></figure> <p><font color=red>注意：当程序在你所指定的时间执行后，系统会发一封邮件给当前的用户，显示该程序执行的内容，若不希望收到这样的邮件，请在每一行空一格之后加上<code>> /dev/null 2>&1</code>即可，</font>如：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>20 03 * * * . /etc/profile;/bin/sh /var/www/runoob/test.sh > /dev/null 2>&1 </span><br></pre></table></figure> <h3 id=8-1-4、常见问题><a class=headerlink href=#8-1-4、常见问题 title=8.1.4、常见问题></a>8.1.4、常见问题</h3><h4 id=8-1-4-1、脚本无法执行问题><a class=headerlink href=#8-1-4-1、脚本无法执行问题 title=8.1.4.1、脚本无法执行问题></a>8.1.4.1、脚本无法执行问题</h4><p>如果我们使用 crontab 来定时执行脚本，无法执行，但是如果直接通过命令（如：./test.sh)又可以正常执行，这主要是因为无法读取环境变量的原因。</p> <p>解决方法：</p> <ol><li><p><em><strong>所有命令需要写成绝对路径形式</strong></em>，如：<code>/usr/local/bin/docker</code>。</p><li><p><strong>在 shell 脚本开头使用以下代码</strong>：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>#!/bin/sh</span></span><br><span class=line></span><br><span class=line>. /etc/profile</span><br><span class=line>. ~/.bash_profile</span><br></pre></table></figure><li><p>在 <strong>/etc/crontab</strong> 中添加环境变量，在可执行命令之前添加命令 <strong>. /etc/profile;/bin/sh</strong>，使得环境变量生效，例如：</p> <figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>20 03 * * * . /etc/profile;/bin/sh /var/www/runoob/test.sh</span><br></pre></table></figure></ol> <h1 id=9、RPM和YUM><a class=headerlink href=#9、RPM和YUM title=9、RPM和YUM></a>9、RPM和YUM</h1><h2 id=9-1、RPM><a class=headerlink href=#9-1、RPM title=9.1、RPM></a>9.1、RPM</h2><h3 id=9-1-1、简介><a class=headerlink href=#9-1-1、简介 title=9.1.1、简介></a>9.1.1、简介</h3><p>rpm（英文全拼：redhat package manager） 原本是 Red Hat Linux 发行版专门用来<strong>管理 Linux 各项套件的程序</strong>，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版采用。<strong>RPM 让 Linux 易于安装，升级，间接提升了 Linux 适用度</strong>。</p> <h3 id=9-1-2、语法><a class=headerlink href=#9-1-2、语法 title=9.1.2、语法></a>9.1.2、语法</h3><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>rpm [-acdhilqRsv][-b<完成阶段><套间档>+][-e<套件挡>][-f<文件>+][-i<套件档>][-p<套件档>＋][-U<套件档>][-vv][--addsign<套件档>+][--allfiles][--allmatches][--badreloc][--buildroot<根目录>][--changelog][--checksig<套件档>+][--clean][--dbpath<数据库目录>][--dump][--excludedocs][--excludepath<排除目录>][--force][--ftpproxy<主机名称或IP地址>][--ftpport<通信端口>][--<span class=built_in>help</span>][--httpproxy<主机名称或IP地址>][--httpport<通信端口>][--ignorearch][--ignoreos][--ignoresize][--includedocs][--initdb][justdb][--nobulid][--nodeps][--nofiles][--nogpg][--nomd5][--nopgp][--noorder][--noscripts][--notriggers][--oldpackage][--percent][--pipe<执行指令>][--prefix<目的目录>][--provides][--queryformat<档头格式>][--querytags][--rcfile<配置档>][--rebulid<套件档>][--rebuliddb][--recompile<套件档>][--relocate<原目录>=<新目录>][--replacefiles][--replacepkgs][--requires][--resign<套件档>+][--rmsource][--rmsource<文件>][--root<根目录>][--scripts][--setperms][--setugids][--short-circuit][--sign][--target=<安装平台>+][--<span class=built_in>test</span>][--timecheck<检查秒数>][--triggeredby<套件档>][--triggers][--verify][--version][--whatprovides<功能特性>][--whatrequires<功能特性>]</span><br></pre></table></figure> <p><strong>参数说明</strong>：</p> <ul><li>-a 　查询所有套件。<li>-b<完成阶段><套件档>+或-t <完成阶段><套件档>+ 　设置包装套件的完成阶段，并指定套件档的文件名称。<li>-c 　只列出组态配置文件，本参数需配合”-l”参数使用。<li>-d 　只列出文本文件，本参数需配合”-l”参数使用。<li>-e<套件档>或–erase<套件档> 　删除指定的套件。<li>-f<文件>+ 　查询拥有指定文件的套件。<li>-h或–hash 　套件安装时列出标记。<li>-i 　显示套件的相关信息。<li>-i<套件档>或–install<套件档> 　安装指定的套件档。<li>-l 　显示套件的文件列表。<li>-p<套件档>+ 　查询指定的RPM套件档。<li>-q 　使用询问模式，当遇到任何问题时，rpm指令会先询问用户。<li>-R 　显示套件的关联性信息。<li>-s 　显示文件状态，本参数需配合”-l”参数使用。<li>-U<套件档>或–upgrade<套件档> 升级指定的套件档。<li>-v 　显示指令执行过程。<li>-vv 　详细显示指令执行过程，便于排错。<li>-addsign<套件档>+ 　在指定的套件里加上新的签名认证。<li>–allfiles 　安装所有文件。<li>–allmatches 　删除符合指定的套件所包含的文件。<li>–badreloc 　发生错误时，重新配置文件。<li>–buildroot<根目录> 　设置产生套件时，欲当作根目录的目录。<li>–changelog 　显示套件的更改记录。<li>–checksig<套件档>+ 　检验该套件的签名认证。<li>–clean 　完成套件的包装后，删除包装过程中所建立的目录。<li>–dbpath<数据库目录> 　设置欲存放RPM数据库的目录。<li>–dump 　显示每个文件的验证信息。本参数需配合”-l”参数使用。<li>–excludedocs 　安装套件时，不要安装文件。<li>–excludepath<排除目录> 　忽略在指定目录里的所有文件。<li>–force 　强行置换套件或文件。<li>–ftpproxy<主机名称或IP地址> 　指定FTP代理服务器。<li>–ftpport<通信端口> 　设置FTP服务器或代理服务器使用的通信端口。<li>–help 　在线帮助。<li>–httpproxy<主机名称或IP地址> 　指定HTTP代理服务器。<li>–httpport<通信端口> 　设置HTTP服务器或代理服务器使用的通信端口。<li>–ignorearch 　不验证套件档的结构正确性。<li>–ignoreos 　不验证套件档的结构正确性。<li>–ignoresize 　安装前不检查磁盘空间是否足够。<li>–includedocs 　安装套件时，一并安装文件。<li>–initdb 　确认有正确的数据库可以使用。<li>–justdb 　更新数据库，当不变动任何文件。<li>–nobulid 　不执行任何完成阶段。<li>–nodeps 　不验证套件档的相互关联性。<li>–nofiles 　不验证文件的属性。<li>–nogpg 　略过所有GPG的签名认证。<li>–nomd5 　不使用MD5编码演算确认文件的大小与正确性。<li>–nopgp 　略过所有PGP的签名认证。<li>–noorder 　不重新编排套件的安装顺序，以便满足其彼此间的关联性。<li>–noscripts 　不执行任何安装Script文件。<li>–notriggers 　不执行该套件包装内的任何Script文件。<li>–oldpackage 　升级成旧版本的套件。<li>–percent 　安装套件时显示完成度百分比。<li>–pipe<执行指令> 　建立管道，把输出结果转为该执行指令的输入数据。<li>–prefix<目的目录> 　若重新配置文件，就把文件放到指定的目录下。<li>–provides 　查询该套件所提供的兼容度。<li>–queryformat<档头格式> 　设置档头的表示方式。<li>–querytags 　列出可用于档头格式的标签。<li>–rcfile<配置文件> 　使用指定的配置文件。<li>–rebulid<套件档> 　安装原始代码套件，重新产生二进制文件的套件。<li>–rebuliddb 　以现有的数据库为主，重建一份数据库。<li>–recompile<套件档> 　此参数的效果和指定”–rebulid”参数类似，当不产生套件档。<li>–relocate<原目录>=<新目录> 　把本来会放到原目录下的文件改放到新目录。<li>–replacefiles 　强行置换文件。<li>–replacepkgs 　强行置换套件。<li>–requires 　查询该套件所需要的兼容度。<li>–resing<套件档>+ 　删除现有认证，重新产生签名认证。<li>–rmsource 　完成套件的包装后，删除原始代码。<li>–rmsource<文件> 　删除原始代码和指定的文件。<li>–root<根目录> 　设置欲当作根目录的目录。<li>–scripts 　列出安装套件的Script的变量。<li>–setperms 　设置文件的权限。<li>–setugids 　设置文件的拥有者和所属群组。<li>–short-circuit 　直接略过指定完成阶段的步骤。<li>–sign 　产生PGP或GPG的签名认证。<li>–target=<安装平台>+ 　设置产生的套件的安装平台。<li>–test 　仅作测试，并不真的安装套件。<li>–timecheck<检查秒数> 　设置检查时间的计时秒数。<li>–triggeredby<套件档> 　查询该套件的包装者。<li>–triggers 　展示套件档内的包装Script。<li>–verify 　此参数的效果和指定”-q”参数相同。<li>–version 　显示版本信息。<li>–whatprovides<功能特性> 　查询该套件对指定的功能特性所提供的兼容度。<li>–whatrequires<功能特性> 　查询该套件对指定的功能特性所需要的兼容度。</ul> <h3 id=9-1-3、常用命令><a class=headerlink href=#9-1-3、常用命令 title=9.1.3、常用命令></a>9.1.3、常用命令</h3><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：安装dejagnu</span></span><br><span class=line>rpm -ivh dejagnu-1.4.2-10.noarch.rpm</span><br><span class=line></span><br><span class=line><span class=comment># 命令2：忽略报错，强制安装</span></span><br><span class=line>rpm --force -ivh package.rpm</span><br><span class=line></span><br><span class=line><span class=comment># 命令3：列出所有已安装包</span></span><br><span class=line>rpm -qa</span><br><span class=line></span><br><span class=line><span class=comment># 命令4：查看rpm包中文件安装位置</span></span><br><span class=line>rpm -ql <span class=built_in>ls</span></span><br><span class=line></span><br><span class=line><span class=comment># 命令5：卸载rpm包</span></span><br><span class=line>rpm -e package.rpm </span><br><span class=line></span><br><span class=line><span class=comment># 命令6：升级rpm包</span></span><br><span class=line>rpm -U file.rpm</span><br></pre></table></figure> <h2 id=9-2、YUM><a class=headerlink href=#9-2、YUM title=9.2、YUM></a>9.2、YUM</h2><h3 id=9-2-1、简介><a class=headerlink href=#9-2-1、简介 title=9.2.1、简介></a>9.2.1、简介</h3><p>yum（ Yellow dog Updater, Modified）是一个在 Fedora 和 RedHat 以及 SUSE 中的<strong>Shell前端软件包管理器</strong>。基于 RPM 包管理，能从指定服务器自动下载 RPM 包并安装，<strong>可自动处理依赖关系</strong>。</p> <p><strong>yum 提供了查找、安装、删除某一个、一组甚至全部软件包的命令，且命令简洁又好记。</strong></p> <h3 id=9-2-2、语法><a class=headerlink href=#9-2-2、语法 title=9.2.2、语法></a>9.2.2、语法</h3><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>yum [options] [<span class=built_in>command</span>] [package ...]</span><br></pre></table></figure> <ul><li><strong>options：</strong>可选，选项包括-h（帮助），-y（当安装过程提示选择全部为 “yes”），-q（不显示安装的过程）等等。<li><strong>command：</strong>要进行的操作。<li><strong>package：</strong>安装的包名。</ul> <h3 id=9-2-3、常用命令><a class=headerlink href=#9-2-3、常用命令 title=9.2.3、常用命令></a>9.2.3、常用命令</h3><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=comment># 1.列出所有可更新的软件清单命令：</span></span><br><span class=line>yum check-update</span><br><span class=line><span class=comment># 2.更新所有软件命令：</span></span><br><span class=line>yum update</span><br><span class=line><span class=comment># 3.仅安装指定的软件命令：</span></span><br><span class=line>yum install &LTpackage_name></span><br><span class=line><span class=comment># 4.仅更新指定的软件命令：</span></span><br><span class=line>yum update &LTpackage_name></span><br><span class=line><span class=comment># 5.列出所有可安裝的软件清单命令：</span></span><br><span class=line>yum list</span><br><span class=line><span class=comment># 6.删除软件包命令：</span></span><br><span class=line>yum remove &LTpackage_name></span><br><span class=line><span class=comment># 7.查找软件包命令：</span></span><br><span class=line>yum search &LTkeyword></span><br><span class=line><span class=comment># 8.清除缓存命令:</span></span><br><span class=line>    <span class=comment># 8.1、清除缓存目录下的软件包</span></span><br><span class=line>    yum clean packages:</span><br><span class=line>    <span class=comment># 8.2、清除缓存目录下的 headers</span></span><br><span class=line>    yum clean headers:</span><br><span class=line>    <span class=comment># 8.3、清除缓存目录下旧的 headers</span></span><br><span class=line>    yum clean oldheaders:</span><br><span class=line>    <span class=comment># 8.4、清除缓存目录下的软件包及旧的 headers</span></span><br><span class=line>    yum clean, yum clean all (= yum clean packages; yum clean oldheaders) </span><br></pre></table></figure> <h1 id=10、强势工具><a class=headerlink href=#10、强势工具 title=10、强势工具></a>10、强势工具</h1><h2 id=10-1、文本处理工具><a class=headerlink href=#10-1、文本处理工具 title=10.1、文本处理工具></a>10.1、文本处理工具</h2><h3 id=10-1-1、cut命令><a class=headerlink href=#10-1-1、cut命令 title=10.1.1、cut命令></a>10.1.1、cut命令</h3><p><strong>cut命令可以从文件的每一行剪切字节、字符和字段，并将这些内容输出。</strong></p> <p>语法如下：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>cut</span> 参数 filename</span><br></pre></table></figure> <p>参数解析：</p> <ul><li>-d：分隔符，按照指定分隔符来分割列，默认是制表符”\t”。<li>-f：列号，提取第几列。<li>-c：按字符进行切割，后加n表示取第几列。</ul> <h3 id=10-1-2、awk命令><a class=headerlink href=#10-1-2、awk命令 title=10.1.2、awk命令></a>10.1.2、awk命令</h3><p><strong>awk是一个强大的文本分析工具，把文件逐行读入，以空格为默认分隔符将行进行切割。</strong></p> <p>语法如下：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>awk [参数] <span class=string>'/pattern1/{action1} /pattern2/{action2}'</span> filename</span><br></pre></table></figure> <p>参数解析：</p> <ul><li>-f：指定输入文件分割符。<li>-v：赋值一个用户定义变量。<li>pattern：表示awk在数据中查找的内容，就是匹配模式。<li>action：找到匹配内容时所执行的一系列命令。</ul> <p>内置变量：</p> <ul><li>FILENAME：文件名。<li>NR：已读的记录数，行号。<li>NF：游览记录的域的个数（切割后，列的数量）</ul> <p>使用示例：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令1：</span></span><br><span class=line>awk -F : <span class=string>'{print $1","$7}'</span> passwd</span><br><span class=line></span><br><span class=line><span class=comment># 命令2：</span></span><br><span class=line>awk -F : <span class=string>'BEGIN{print "start..."} {print $1","$7} END{print "end..."}'</span> passwd</span><br><span class=line></span><br><span class=line><span class=comment># 命令3：将passwd文件中的用户id增加1并输出</span></span><br><span class=line>awk -v i=1 -F : <span class=string>'{print $3+i}'</span> passwd</span><br></pre></table></figure> <footer class=post-footer><div class=post-eof></div></footer> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Linux%E5%9F%BA%E7%A1%80%E7%AF%87/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Linux%E5%9F%BA%E7%A1%80%E7%AF%87/ itemprop=url>Linux系列-Linux基础篇</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-09-30 20:04:52" datetime=2023-09-30T20:04:52+08:00 itemprop=dateModified>2023-09-30</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Linux/ itemprop=url rel=index><span itemprop=name>Linux</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、文件目录结构><a class=headerlink href=#1、文件目录结构 title=1、文件目录结构></a>1、文件目录结构</h1><h2 id=1-1、目录结构图><a class=headerlink href=#1-1、目录结构图 title=1.1、目录结构图></a>1.1、目录结构图</h2><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%8401.jpg><h2 id=1-2、详细解析><a class=headerlink href=#1-2、详细解析 title=1.2、详细解析></a>1.2、详细解析</h2><p>目录详细解析：<ul><li><p><strong>/bin</strong>：bin 是 Binaries (二进制文件) 的缩写，该目录存放<em><strong>常用命令</strong></em>。</p><li><p><strong>/boot</strong>：存放启动 Linux 时使用的<em><strong>核心文件</strong></em>，包括一些连接文件以及镜像文件。</p><li><p><strong>/dev</strong>：dev 是 Device(设备) 的缩写，该目录存放 Linux <em><strong>外部设备</strong></em>，Linux 中访问设备的方式 与 访问文件的方式相同。</p><li><p><strong>/etc：</strong>etc 是 Etcetera(等等) 的缩写，该目录存放<strong>系统管理所需要的配置文件和子目录</strong>。</p><li><p><strong>/home</strong>：<em><strong>用户主目录</strong></em>，每个用户都有一个个人目录，目录名 通常以 用户账号命名。</p><li><p><strong>/lib</strong>：lib 是 Library(库) 的缩写，该目录存放<em><strong>动态连接共享库</strong></em>，几乎所有程序都要用到这些共享库。</p><li><p><strong>/lost+found</strong>：该目录一般情况下为空，系统非法关机后，该目录会存放一些文件。</p><li><p><strong>/media</strong>：<strong>Linux 识别到外部设备时会挂载到该目录下</strong>。</p><li><p><strong>/mnt</strong>：该目录 用于 临时挂载其它文件系统，可以将光驱挂载至<code>/mnt/</code>目录，进入该目录就可查看光驱中的内容。</p><li><p><strong>/opt</strong>：opt 是 optional(可选) 的缩写，该目录是安装其它软件的可选目录，默认为空。</p><li><p><strong>/proc</strong>：proc 是 Processes(进程) 的缩写，<code>/proc</code>是一种<strong>伪文件系统（也即虚拟文件系统）</strong>，存储内核运行时的 一系列特殊文件，该目录是系统内存映射，可通过访问该目录获取系统信息。该目录中的内容不在硬盘而在内存中，也可以直接修改其中的某些文件，比如可通过如下命令来屏蔽主机ping命令，使别人无法ping你的机器：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br></pre></table></figure><li><p><strong>/root</strong>：该目录是<strong>超级系统管理员目录</strong>。</p><li><p><strong>/sbin</strong>：是 Superuser Binaries (超级用户的二进制文件) 的缩写，该目录存放系统管理员使用的<strong>系统管理程序</strong>。</p><li><p><strong>/selinux</strong>：该目录是<strong>Redhat/CentOS所特有的目录</strong>，用于存放selinux相关文件（Selinux是一个安全机制，类似于windows防火墙，但该机制比较复杂）。</p><li><p><strong>/srv</strong>：该目录存放一些服务启动之后需要提取的数据。</p><li><p><strong>/sys</strong>：该目录下安装了 2.6 内核中新出现的<em><strong>文件系统 sysfs</strong></em>。sysfs 文件系统集成了3种文件系统信息：<strong>针对进程信息的 proc 文件系统</strong>、<strong>针对设备的 devfs 文件系统</strong>、<strong>针对伪终端的 devpts 文件系统</strong>。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建时，对应的文件和目录也在内核对象子系统中被创建。</p><li><p><strong>/tmp</strong>：tmp 是 temporary(临时) 的缩写，该目录存放一些<em><strong>临时文件</strong></em>。</p><li><p><strong>/usr</strong>：usr 是 unix shared resources(共享资源) 的缩写，该目录存放<em><strong>应用程序和文件</strong></em>。</p><li><p><strong>/usr/bin</strong>：<strong>系统用户使用的应用程序</strong>。</p><li><p><strong>/usr/sbin</strong>：超级用户使用的比较<strong>高级的管理程序和系统守护程序</strong>。</p><li><p><strong>/usr/src</strong>：该目录默认存放<strong>内核源代码</strong>。</p><li><p><strong>/var</strong>：var 是 variable(变量) 的缩写，该目录通常会<em><strong>存储扩充文件</strong></em>，比如日志文件。</p><li><p><strong>/run</strong>：<strong>系统重启时会删除该目录中的文件</strong>。如果系统上有 /var/run 目录，则应让它指向 run。</p></ul><h2 id=1-3、小结><a class=headerlink href=#1-3、小结 title=1.3、小结></a>1.3、小结</h2><p>Linux中有几个重要目录，一定要慎重操作。<ul><li><p><strong>/etc</strong>： 系统配置文件。</p><li><p><strong>/bin、/sbin、/usr/bin、/usr/sbin</strong>: <strong>系统预设执行文件目录</strong>。其中/bin、/usr/bin 是给系统用户使用的指令（除root用户外），/sbin、 /usr/sbin 是 root 使用的指令。</p><li><p><strong>/var</strong>： 该目录用于存放应用程序的一些日志等信息。mail 预设也放在其中。</p></ul><blockquote><p><strong>Linux中，一切皆文件。</strong></blockquote><h1 id=2、系统运行级别><a class=headerlink href=#2、系统运行级别 title=2、系统运行级别></a>2、系统运行级别</h1><h2 id=2-1、运行级别><a class=headerlink href=#2-1、运行级别 title=2.1、运行级别></a>2.1、运行级别</h2><p>所有运行级别如下：<ul><li>0：关机<li>1：单用户模式<li>2：多用户无网络服务<li>3：<strong>多用户有网络服务</strong><li>4：保留<li>5：<strong>图形界面</strong><li>6：系统重启</ul><blockquote><p><strong>常用运行级别是 3 和 5</strong>。如需修改运行级别，需要修改<code>/etc/inittab</code>文件，做如下修改：<p><code>id:5:initdefault</code>（修改其中的数字即可）</blockquote></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/ itemprop=url>Kafka系列-KafKa基础应用</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 21:16:15" datetime=2023-10-02T21:16:15+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/KafKa/ itemprop=url rel=index><span itemprop=name>KafKa</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=KafKa概述><a class=headerlink href=#KafKa概述 title=KafKa概述></a>KafKa概述</h1><h2 id=何为KafKa><a class=headerlink href=#何为KafKa title=何为KafKa></a>何为KafKa</h2><p><strong>Kafka是由Apache软件基金会开发的一个开源流处理平台，基于Scala和Java编写。</strong><p>Apache Kafka是一个分布式发布 - 订阅消息系统和一个强大队列，可以处理大量数据，并使您能够将消息从一个端点传递到另一个端点。Kafka适合离线和在线消息消费。 Kafka消息保留在磁盘上，并在群集内复制以防止数据丢失。 Kafka构建在ZooKeeper同步服务之上。 它与Apache Storm和Spark可以很好地集成，可用于实时流式数据分析。<p>Kafka 是一个分布式消息队列，具有高性能、持久化、多副本备份、横向扩展等能力。生产者往队列里写消息，消费者从队列里取消息进行业务逻辑。一般在架构设计中起到解耦、削峰、异步处理的作用。<h2 id=使用场景><a class=headerlink href=#使用场景 title=使用场景></a>使用场景</h2><ul><li><font color=orange>指标</font>：Kafka通常用于操作监控数据。 这涉及聚合来自分布式应用程序的统计信息，以产生操作数据的集中馈送。<li><font color=orange>日志聚合解决方案</font>：Kafka可用于跨组织从多个服务收集日志，并使它们以标准格式提供给多个服务器。<li><font color=orange>流处理</font>：流行的框架(如Storm和Spark Streaming)从主题中读取数据，对其进行处理，并将处理后的数据写入新主题，供用户和应用程序使用。 Kafka的强耐久性在流处理的上下文中也非常有用。</ul><h2 id=重要概念><a class=headerlink href=#重要概念 title=重要概念></a>重要概念</h2><h3 id=Broker（实例）><a class=headerlink href=#Broker（实例） title=Broker（实例）></a>Broker（实例）</h3><p><strong>Kafka 集群有多个Server，每一个Server都可以存储消息，且每一个Server称为一个 kafka 实例，也叫做broker。</strong><p><strong>Producer和Consumer通过 TCP协议 与Kafka集群通信，Producer和Consumer可以看作是Kafka集群的客户端。</strong>Producer通过TCP协议发送消息到KafKa集群，KafKa集群再将这些消息提供给Consumer。如下图所示：<p><img alt=image-20230807101619914 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20230807101619914.png><h3 id=Topic（主题）><a class=headerlink href=#Topic（主题） title=Topic（主题）></a>Topic（主题）</h3><p>每个 topic 中保存同一类消息。每个 producer 发送消息至 kafka 时都需要指明要将消息存到哪个 topic 中，也就是将这个消息进行分类。<h3 id=Partition（分区）><a class=headerlink href=#Partition（分区） title=Partition（分区）></a>Partition（分区）</h3><p>每个 topic 都可以分多个 partition，每个 partition 在存储层面是【append log 文件】。任何发布到此 partition 的消息都会被直接追加到 log 文件尾部。<p><img alt=image-20210324153055048 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-image-20210324153055048.png><p>为何需要分区？根本原因就是：kafka基于文件进行存储，当文件内容大到一定程度时，很容易达到单个磁盘的上限，因此，采用分区法，一个分区对应一个文件，这样就可以将数据分别存储到不同的server上去，另外这样做也可以负载均衡，容纳更多的消费者。<p>Kafka将topic划分为多个partition进行存储 有两个好处：<ul><li><p><font color=orange>消息存储扩容</font></p> <p>一个文件其存储容量有限，但集群中的多个文件存储就可以大大增加一个topic能够保存的消息数量。</p><li><p><font color=orange>并行读写</font></p> <p>通过多个partition文件存储消息，意味着 producer 和 consumer 可以并行读写一个topic。</p></ul><h3 id=Offset（偏移量）><a class=headerlink href=#Offset（偏移量） title=Offset（偏移量）></a>Offset（偏移量）</h3><p><strong>一个分区对应一个磁盘上的文件，而消息在文件中的位置就称为 offset（偏移量），offset 是一个 long 型数字，它可以唯一标记一条消息。</strong>由于kafka 并没有提供其他额外的索引机制来存储 offset，文件只能顺序的读写，所以在kafka中几乎不允许对消息进行“随机读写”。<h3 id=Producer（生产者）><a class=headerlink href=#Producer（生产者） title=Producer（生产者）></a>Producer（生产者）</h3><p>消息发送者。<strong>将消息发送到topic的进程叫做Producer。</strong><p>Producer负责将消息发送到Kafka集群的某一个topic中。Producer发送消息时可以指定partition号，故可以将消息持久化到特定partition中。<p>如果没有指定partition号，那么Kafka Producer可以通过 特定算法 计算出partition号。具体算法如下：<ul><li>如果 待发送的消息 指定了key，则 <font color=orange>【hash key】来映射到对应partition号。</font><li>如果 待发送的消息 没有指定key，则 <font color=orange>通过【Round Robin轮询算法】确定partition号。</font>这样可保证数据在所有的partition上平均分配。<li>Kafka Producer也 <font color=orange>支持自定义partition分配方式。</font>客户端提供一个<code>org.apache.kafka.clients.producer.Partitioner</code>实现类，然后 将此实现类 配置到Producer中即可。</ul><h3 id=Consumer（消费者）><a class=headerlink href=#Consumer（消费者） title=Consumer（消费者）></a>Consumer（消费者）</h3><p>消息消费者。<font color=orange>将订阅topic，获取消息的进程叫做Consumer。Kafka中的Consumer采用【poll模型】。</font><p><font color=orange>Consumer通过移动 offset 顺序来读取消息。offset由Consumer维护。</font>Kafka集群只负责根据Consumer传入的offset来返回对应消息。<p>Kafka 0.9前，offset信息保存在zookeeper <code>[consumers/{group}/offsets/{topic}/{partition}]</code> 目录中。而0.9之后，所有offset信息都保存在Broker上的一个名为<code>__consumer_offsets</code> 的 topic 中。<p>如下图所示：<p><img alt=image-20210324153535778 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-image-20210324153535778.png><p><strong>Kafka不会立刻删除已经被消费的消息，而会根据broker中的配置来决定多久清理一次。</strong>当broker中配置的时间到达时，不论消息是否被消费，Kafka都会清理磁盘空间。<p>传统的消息队列提供两种消息消费模式：<ul><li>队列模式：一条消息只能被多个消费者中的一个消费。<li>发布订阅模式：一条消息能够被多个消费者同时消费。</ul><p><strong>Kafka为了支持这两种消费模型，提出了 消费者组（consumer group）概念。</strong>如下图所示：<p><img alt=image-20210324153902808 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-image-20210324153902808.png><p>如图，每一个消费者不再是一个简单的订阅了某个topic的个体，多个消费者被放在了一个消费者组中。每一个消费者必须属于一个消费者组，同时一个消费者组能够拥有多个消费者。对于一个消费者组，Kafka拥有以下约束：<ul><li>一条消息只能被一个消费者组中的一个消费者消费。<li>同一个partition中的消息只能被某个消费者组中的某个固定消费者消费。</ul><p>如上图所示，在一个消费者组中，一旦某个partition被分配给了某个消费者，那么该partition就不会再分配给任何其它的同组消费者。因此如果一个consumer group中消费者数量超过了partition数量，那么一定会有多余的消费者永远收不到消息。<p>最后，KafKa只能够保证消费一个分区内的消费是有序的。无法保证一个topic下（拥有多个分区）所有消息的消费都是有序的。<h3 id=Replication（复制）><a class=headerlink href=#Replication（复制） title=Replication（复制）></a>Replication（复制）</h3><p><strong>一个topic的多个partition被分在Kafka集群的多个broker上。</strong>每个broker负责partition中消息的读写操作。此外，Kafka还支持为每个partition设置需要备份（replicas）的个数，所有的备份partition分布在Kafka集群中，以提高可用性。<p>既然Kafka支持replication，那么就意味着需要对多个备份进行调度。每个partition 都有一个机器被称为”leader”，同时零个或多个机器作为follower。leader 负责所有读写操作，follower执行leader指令。如果 leader 失效，那么将会有其他follower 来接管进而晋升为新leader。follower只是单调的和leader 跟进同步消息即可。因此，所有发送到Kafka集群的读写请求本质上均是针对leader的操作，leader操作完成后，发送指令给follower进行数据同步，从而实现了高可用性。<h3 id=小结><a class=headerlink href=#小结 title=小结></a>小结</h3><ul><li>kafka 是一个基于发布-订阅的分布式消息系统（消息队列）<li>Kafka 面向大数据，消息保存在主题中，而每个 topic 有分为多个分区<li>kafak 的消息数据保存在磁盘，每个 partition 对应磁盘上的一个文件，消息写入就是简单的文件追加，文件可以在集群内复制备份以防丢失<li>即使消息被消费，kafka 也不会立即删除该消息，可以通过配置使得过一段时间后自动删除以释放磁盘空间<li>kafka依赖分布式协调服务Zookeeper，适合离线/在线信息的消费，与 storm 和 spark 等实时流式数据分析常常结合使用</ul><h2 id=KafKa特点><a class=headerlink href=#KafKa特点 title=KafKa特点></a>KafKa特点</h2><ul><li><font color=orange>可靠</font>：Kafka是分布式，分区，复制和容错的。<li><font color=orange>可扩展</font>：Kafka消息传递系统轻松缩放，无需停机。<li><font color=orange>耐用</font>：Kafka使用分布式提交日志，这意味着消息会尽可能快地保留在磁盘上，因此它是持久的。<li><font color=orange>高性能</font>：Kafka对于发布和订阅消息都具有高吞吐量。 即使存储了许多TB的消息，它也保持稳定的性能。</ul><p>Kafka非常快，并可保证零停机和零数据丢失。<h2 id=小结-1><a class=headerlink href=#小结-1 title=小结></a>小结</h2><p>Kafka是一个统一平台，用于处理所有的实时数据Feed。 Kafka支持低延迟消息传递，并在出现机器故障时提供容错保证。 Kafka非常快，执行2百万写/秒。 Kafka将所有数据保存到磁盘，这实质上意味着所有写入都会进入操作系统(RAM)的页面缓存。 这使得将数据从页面缓存传输到网络套接字非常有效。<h1 id=Kafka基本原理><a class=headerlink href=#Kafka基本原理 title=Kafka基本原理></a>Kafka基本原理</h1><h2 id=分布式和分区><a class=headerlink href=#分布式和分区 title=分布式和分区></a>分布式和分区</h2><p>kafka 是一个分布式消息系统。消息保存在 Topic 中，可实现大量数据存储，一个 topic 有多个分区，每个分区对应一个文件，分别存储到不同机器上，实现分布式集群存储。每个 partition 可以有副本，备份到多台机器上可提高可用性。<p>总结就是：一个 topic 对应的多个 partition 分散存储到集群中的多个 broker 上，存储方式是一个 partition 对应一个文件，每个 broker 负责存储在自己机器上的 partition 中的消息读写。<h2 id=副本><a class=headerlink href=#副本 title=副本></a>副本</h2><p><strong>每个 partition 将会被备份到多台机器上以提高可用性，备份的数量可以通过配置文件指定。</strong><p>冗余备份方式 在分布式系统中 很常见，对于 同一文件的多个备份进行管理和调度，其kafka做法是：每个 partition 选举一个 server 作为“leader”，由 leader 负责所有对该分区的读写，其他 server 作为 follower 只需要简单与 leader 同步，保持跟进即可。如果 原 leader 失效，会重新 从其它follower中 挑选一个晋升为新leader。<p>Kafka 通过 ZK 来在 Broker 中选出一个 Controller，用于 Partition分配 和 Leader选举。<p><strong>leader级别的server 承担了 该分区所有读写请求，压力较大，从整体考虑，有多少个 partition 就意味着会有多少个leader，kafka 会将 leader 分散到不同 broker 上，确保整体负载均衡。</strong><h2 id=整体数据流程><a class=headerlink href=#整体数据流程 title=整体数据流程></a>整体数据流程</h2><p>Kafka 的总体数据流满足下图，该图可以说是概括了整个 kafka 的基本原理。<p><img alt=image-20210324172846378 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-image-20210324172846378.png><h3 id=数据生产过程><a class=headerlink href=#数据生产过程 title=数据生产过程></a>数据生产过程</h3><p><strong>对于 生产者 要写入一条记录，可以指定四个参数：topic、partition、key 和 value，其中 topic 和 value 是必须的，而 key 和 partition 是可选的。</strong><p><strong>对于一条记录，会先对其进行序列化，然后按照 Topic 和 Partition放进对应的发送队列中。</strong>如果 Partition 没填，那么会是如下情况：<ol><li>Key 有填，通过对 Key 进行哈希，相同 Key 去一个 Partition。<li>Key 没填，通过 Round-Robin 来选 Partition。</ol><p><img alt=image-20210324173345094 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-image-20210324173345094.png><p>producer 将会和Topic下所有 partition leader 保持 socket 连接，消息由 producer 直接通过 socket 发送到 broker。其中 partition leader 的位置( host : port )注册在 zookeeper 中，producer 作为 zookeeper client，已经注册了 watch 用来监听 partition leader 的变更事件，因此，可以准确的知道谁是当前的 leader。<p>producer 端采用异步发送：将多条消息暂且在客户端 buffer 起来，并将他们批量的发送到 broker，小数据 IO 太多，会拖慢整体的网络延迟，批量延迟发送事实上提升了网络效率。<h3 id=数据消费过程><a class=headerlink href=#数据消费过程 title=数据消费过程></a>数据消费过程</h3><p>对于消费者，不是以单独的形式存在的，每一个消费者属于一个 consumer group，一个 group 包含多个 consumer。特别需要注意的是：订阅 Topic 是以一个消费组来订阅的，发送到 Topic 的消息，只会被订阅此 Topic 的每个 group 中的一个 consumer 消费。<p>如果所有的 Consumer 都具有相同的 group，那么就像是一个点对点的消息系统；如果每个 consumer 都具有不同的 group，那么消息会广播给所有的消费者。<p>具体说来，这实际上是根据 partition 来分的，一个 Partition，只能被消费组里的一个消费者消费，但是可以同时被多个消费组消费，消费组里的每个消费者是关联到一个 partition 的，因此有这样的说法：对于一个 topic，同一个 group 中不能有多于 partitions 个数的 consumer 同时消费，否则将意味着某些 consumer 将无法得到消息。<p>同一个消费组的两个消费者不会同时消费一个 partition。<p><img alt=image-20210324173658271 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-image-20210324173658271.png><p>在 kafka 中，采用了 pull 方式，即 consumer 在和 broker 建立连接之后，主动去 pull(或者说 fetch )消息，首先 consumer 端可以根据自己的消费能力适时的去 fetch 消息并处理，且可以控制消息消费的进度(offset)。<p>partition 中的消息只有一个 consumer 在消费，且不存在消息状态的控制，也没有复杂的消息确认机制，可见 kafka broker 端是相当轻量级的。当消息被 consumer 接收之后，需要保存 Offset 记录消费到哪，以前保存在 ZK 中，由于 ZK 的写性能不好，以前的解决方法都是 Consumer 每隔一分钟上报一次，在 0.10 版本后，Kafka 把这个 Offset 的保存，从 ZK 中剥离，保存在一个名叫 consumeroffsets topic 的 Topic 中，由此可见，consumer 客户端也很轻量级。<h2 id=消息传送机制><a class=headerlink href=#消息传送机制 title=消息传送机制></a>消息传送机制</h2><p><font color=orange>Kafka 支持 3 种 消息投递语义，通常会使用 At least once 模型：</font><ul><li>At most once：最多一次，消息可能会丢失，但不会重复。<li>At least once：最少一次，消息不会丢失，可能会重复。<li>Exactly once：只有一次，消息不丢失不重复，且只消费一次。</ul><h1 id=Kafka工作流程><a class=headerlink href=#Kafka工作流程 title=Kafka工作流程></a>Kafka工作流程</h1><h2 id=前言><a class=headerlink href=#前言 title=前言></a>前言</h2><p><strong>Kafka 以快速，可靠，持久，容错和零停机 的优点 提供 基于pub-sub 和队列的消息系统。 在这两种情况下，生产者只需将消息发送到主题，消费者可以根据自己的需要选择任何一种类型的消息传递系统。</strong><h2 id=发布订阅消息流程><a class=headerlink href=#发布订阅消息流程 title=发布订阅消息流程></a>发布订阅消息流程</h2><p>以下是 Pub-Sub 消息工作流程：<ul><li>生产者定期向主题发送消息。<li>如果生产者发送两个消息并且有两个分区，Kafka 将在第一分区中存储一个消息，在第二分区中存储第二消息。（Kafka 代理存储特定主题分区中的所有消息，它确保消息在分区之间平等共享。）<li>消费者订阅特定主题，然后Kafka会返回主题当前偏移给消费者，且将偏移保存在 Zookeeper 中。<li>消费者 定期请求 Kafka (如100 Ms)新消息。Kafka 收到 生产者消息 时 会 立即转发消息给消费者。<li>消费者消费消息 后 将向 Kafka 代理发送确认。Kafka 收到确认后 会将 偏移 更改为新值。因 Zookeeper 中维护着偏移，故 消费者可以 正确读取 下一封邮件。<li>以上流程将重复，直到消费者停止请求。<li>消费者可以随时回退/跳到所需的主题偏移量，并阅读所有后续消息。</ul><h2 id=队列消息-用户组的工作流><a class=headerlink href=#队列消息-用户组的工作流 title=队列消息/用户组的工作流></a>队列消息/用户组的工作流</h2><p>在队列消息传递系统而不是单个消费者中，具有相同组 ID 的一组消费者将订阅主题。 简单来说，订阅具有相同 Group ID 的主题的消费者被认为是单个组，并且消息在它们之间共享。 让我们检查这个系统的实际工作流程。<ul><li>生产者以固定间隔向某个主题发送消息。<li>Kafka存储在为该特定主题配置的分区中的所有消息，类似于前面的方案。<li>单个消费者订阅特定主题，假设 Topic-01 为 Group ID 为 Group-1 。<li>Kafka 以与发布 - 订阅消息相同的方式与消费者交互，直到新消费者以相同的组 ID 订阅相同主题Topic-01 1 。<li>一旦新消费者到达，Kafka 将其操作切换到共享模式，并在两个消费者之间共享数据。 此共享将继续，直到用户数达到为该特定主题配置的分区数。<li>一旦消费者的数量超过分区的数量，新消费者将不会接收任何进一步的消息，直到现有消费者取消订阅任何一个消费者。 出现这种情况是因为 Kafka 中的每个消费者将被分配至少一个分区，并且一旦所有分区被分配给现有消费者，新消费者将必须等待。<li>此功能也称为使用者组。 同样，Kafka 将以非常简单和高效的方式提供两个系统中最好的。</ul><h2 id=Zookeeper作用><a class=headerlink href=#Zookeeper作用 title=Zookeeper作用></a>Zookeeper作用</h2><p>Apache Kafka 的一个关键依赖是 Apache Zookeeper，它是一个分布式配置和同步服务。Zookeeper 是 Kafka 代理和消费者之间的协调接口。Kafka 服务器通过 Zookeeper 集群共享信息。Kafka 在 Zookeeper 中存储基本元数据，例如关于主题，代理，消费者偏移(队列读取器)等的信息。<p>由于所有关键信息存储在 Zookeeper 中，并且它通常在其整体上复制此数据，因此Kafka代理/ Zookeeper 的故障不会影响 Kafka 集群的状态。Kafka 将恢复状态，一旦 Zookeeper 重新启动。 这为Kafka带来了零停机时间。Kafka 代理之间的领导者选举也通过使用 Zookeeper 在领导者失败的情况下完成。<h1 id=Kafka基本操作><a class=headerlink href=#Kafka基本操作 title=Kafka基本操作></a>Kafka基本操作</h1><h2 id=启动ZooKeeper><a class=headerlink href=#启动ZooKeeper title=启动ZooKeeper></a>启动ZooKeeper</h2><p>打开一个新终端并键入以下命令<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>bin/zookeeper-server-start.sh config/zookeeper.properties</span><br></pre></table></figure><p>要启动 <code>Kafka Broker</code>，请键入以下命令<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>bin/kafka-server-start.sh config/server.properties</span><br></pre></table></figure><p>启动 <code>Kafka Broker</code>后，在 ZooKeeper 终端上键入命令 <code>jps</code> ，您将看到以下响应 -<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>821 QuorumPeerMain</span><br><span class=line>928 Kafka</span><br><span class=line>931 Jps</span><br></pre></table></figure><p>其中，<code>QuorumPeerMain</code> 是 ZooKeeper 守护进程，另一个是 Kafka 守护进程。<h2 id=单节点单代理配置><a class=headerlink href=#单节点单代理配置 title=单节点单代理配置></a>单节点单代理配置</h2><p>在此配置中，您有一个 ZooKeeper 和代理 id 实例。 以下是配置它的步骤 ：<h3 id=创建-Kafka-主题><a title="创建 Kafka 主题" class=headerlink href=#创建-Kafka-主题></a>创建 Kafka 主题</h3><p><code>Kafka</code> 提供了一个名为 <code>kafka-topics.sh</code> 的命令行实用程序，用于在服务器上创建主题。 打开新终端并键入以下示例。<p><strong>语法</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 </span><br><span class=line>--partitions 1 --topic topic-name</span><br></pre></table></figure><p><strong>示例</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1   </span><br><span class=line>--partitions 1 --topic Hello-Kafka</span><br></pre></table></figure><p>以上命令创建了一个名为 <code>Hello-Kafka</code> 的主题，其中包含一个分区和一个副本因子。<p>创建主题后可以在 <code>Kafka</code> 代理终端窗口中获取通知，并在 <code>config / server.properties</code> 文件中的<code>“/tmp/kafka-logs/"</code>中指定 创建的主题日志。<h3 id=主题列表><a class=headerlink href=#主题列表 title=主题列表></a>主题列表</h3><p>要获取<code>Kafka</code>服务器中的主题列表，可以使用以下命令<p><strong>语法</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>bin/kafka-topics.sh --list --zookeeper localhost:2181</span><br></pre></table></figure><p><strong>输出</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>Hello-Kafka</span><br></pre></table></figure><p>由于我们已经创建了一个主题，它将仅列出 <code>Hello-Kafka</code> 。<h3 id=启动生产者并发送消息><a class=headerlink href=#启动生产者并发送消息 title=启动生产者并发送消息></a>启动生产者并发送消息</h3><p><strong>语法</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic topic-name</span><br></pre></table></figure><p>从上面的语法，生产者命令行客户端需要两个主要参数 -<ul><li><font color=orange>代理列表</font>：我们要发送邮件的代理列表。 在这种情况下，我们只有一个代理。 <code>Config / server.properties</code> 文件包含代理端口 ID，因为我们知道我们的代理正在侦听端口 9092，因此您可以直接指定它。<li><font color=orange>主题名称</font>：以下是主题名称的示例。</ul><p><strong>示例</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic Hello-Kafka</span><br></pre></table></figure><p>生产者将等待来自 <code>stdin</code> 的输入并发布到 <code>Kafka</code> 集群。 默认情况下，每个新行都作为新消息发布，然后在<code> config / producer.properties</code> 文件中指定默认生产者属性。 现在，您可以在终端中键入几行消息，如下所示。<p><strong>输出</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>$ bin/kafka-console-producer.sh --broker-list localhost:9092 --topic Hello-Kafka</span><br><span class=line>[2016-01-16 13:50:45,931] </span><br><span class=line>WARN property topic is not valid (kafka.utils.Verifia-bleProperties)</span><br><span class=line>Hello</span><br><span class=line>My first message</span><br><span class=line>My second message</span><br></pre></table></figure><h3 id=启动消费者并接收消息><a class=headerlink href=#启动消费者并接收消息 title=启动消费者并接收消息></a>启动消费者并接收消息</h3><p>与生产者类似，在<code>config / consumer.proper-ties</code> 文件中指定了缺省使用者属性。 打开一个新终端并键入以下消息消息语法。<p><strong>语法</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>bin/kafka-console-consumer.sh --zookeeper localhost:2181 —topic topic-name </span><br><span class=line>--from-beginning</span><br></pre></table></figure><p><strong>示例</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>bin/kafka-console-consumer.sh --zookeeper localhost:2181 —topic Hello-Kafka </span><br><span class=line>--from-beginning</span><br></pre></table></figure><p><strong>输出</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>Hello</span><br><span class=line>My first message</span><br><span class=line>My second message</span><br></pre></table></figure><p>最后，可以在生产者终端中输入消息，这些消息会出现在消费者的终端。<h2 id=单节点多代理配置><a class=headerlink href=#单节点多代理配置 title=单节点多代理配置></a>单节点多代理配置</h2><p>在进入多个代理集群设置之前，首先启动 ZooKeeper 服务器。<h3 id=创建多个Kafka-Brokers><a title="创建多个Kafka Brokers" class=headerlink href=#创建多个Kafka-Brokers></a>创建多个Kafka Brokers</h3><p>我们在配置<code>/ server.properties</code> 中已有一个 <code>Kafka</code> 代理实例。 现在我们需要多个代理实例，因此将现有的 <code>server.properties</code> 文件复制到两个新的配置文件中，并将其重命名为 <code>server-one.properties</code> 和 <code>server-two.properties</code>。并编辑文件填充如下内容：<p>config / server-one.properties<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment># The id of the broker. This must be set to a unique integer for each broker.</span></span><br><span class=line><span class=attr>broker.id</span>=<span class=string>1</span></span><br><span class=line><span class=comment># The port the socket server listens on</span></span><br><span class=line><span class=attr>port</span>=<span class=string>9093</span></span><br><span class=line><span class=comment># A comma seperated list of directories under which to store log files</span></span><br><span class=line><span class=attr>log.dirs</span>=<span class=string>/tmp/kafka-logs-1</span></span><br></pre></table></figure><p>config / server-two.properties<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment># The id of the broker. This must be set to a unique integer for each broker.</span></span><br><span class=line><span class=attr>broker.id</span>=<span class=string>2</span></span><br><span class=line><span class=comment># The port the socket server listens on</span></span><br><span class=line><span class=attr>port</span>=<span class=string>9094</span></span><br><span class=line><span class=comment># A comma seperated list of directories under which to store log files</span></span><br><span class=line><span class=attr>log.dirs</span>=<span class=string>/tmp/kafka-logs-2</span></span><br></pre></table></figure><h3 id=启动多个代理><a class=headerlink href=#启动多个代理 title=启动多个代理></a>启动多个代理</h3><p>在三台服务器上进行所有更改后，打开三个新终端，逐个启动每个代理。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>Broker1：</span><br><span class=line>bin/kafka-server-start.sh config/server.properties</span><br><span class=line>Broker2：</span><br><span class=line>bin/kafka-server-start.sh config/server-one.properties</span><br><span class=line>Broker3：</span><br><span class=line>bin/kafka-server-start.sh config/server-two.properties</span><br></pre></table></figure><p>通过在 ZooKeeper 终端上键入 <strong><code>jps</code></strong> 检查所有守护程序，然后您将看到响应。<h3 id=创建主题><a class=headerlink href=#创建主题 title=创建主题></a>创建主题</h3><p>让我们为此主题将复制因子值指定为三个，因为我们有三个不同的代理运行。 如果您有两个代理，那么分配的副本值将是两个。<p>示例如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>bin/kafka-topics.sh </span><br><span class=line>--create </span><br><span class=line>--zookeeper localhost:2181 </span><br><span class=line>--replication-factor 3 </span><br><span class=line>-partitions 1 </span><br><span class=line>--topic Multibrokerapplication</span><br></pre></table></figure><p>Describe 命令用于检查哪个代理正在侦听当前创建的主题，示例如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>bin/kafka-topics.sh </span><br><span class=line>--describe </span><br><span class=line>--zookeeper localhost:2181 </span><br><span class=line>--topic Multibrokerappli-cation</span><br></pre></table></figure><p><strong>输出</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line>bin/kafka-topics.sh </span><br><span class=line>--describe </span><br><span class=line>--zookeeper localhost:2181 </span><br><span class=line>--topic Multibrokerappli-cation</span><br><span class=line></span><br><span class=line>Topic:Multibrokerapplication    PartitionCount:1 </span><br><span class=line>ReplicationFactor:3 Configs:</span><br><span class=line>   </span><br><span class=line>Topic:Multibrokerapplication Partition:0 Leader:0 </span><br><span class=line>Replicas:0,2,1 Isr:0,2,1</span><br></pre></table></figure><p>从上面的输出，我们可以得出结论，第一行给出所有分区的摘要，显示主题名称，分区数量和我们已经选择的复制因子。 在第二行中，每个节点将是分区的随机选择部分的领导者。<p>在我们的例子中，我们看到我们的第一个 <code>broker(with broker.id 0)</code>是领导者。 然后 <code>Replicas:0,2,1</code> 意味着所有代理复制主题最后 <code>Isr</code> 是 <code>in-sync</code> 副本的集合。 那么，这是副本的子集，当前活着并被领导者赶上。<h3 id=启动生产者以发送消息><a class=headerlink href=#启动生产者以发送消息 title=启动生产者以发送消息></a>启动生产者以发送消息</h3><p>此过程保持与单代理设置中相同。<p>示例：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>bin/kafka-console-producer.sh --broker-list localhost:9092 </span><br><span class=line>--topic Multibrokerapplication</span><br></pre></table></figure><p>输出：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic Multibrokerapplication</span><br><span class=line>[2016-01-20 19:27:21,045] WARN Property topic is not valid (kafka.utils.Verifia-bleProperties)</span><br><span class=line>This is single node-multi broker demo</span><br><span class=line>This is the second message</span><br></pre></table></figure><h3 id=启动消费者以接收消息><a class=headerlink href=#启动消费者以接收消息 title=启动消费者以接收消息></a>启动消费者以接收消息</h3><p>此过程保持与单代理设置中所示的相同。<p>示例：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>bin/kafka-console-consumer.sh </span><br><span class=line>--zookeeper localhost:2181 </span><br><span class=line>—topic Multibrokerapplica-tion </span><br><span class=line>--from-beginning</span><br></pre></table></figure><p>输出：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>bin/kafka-console-consumer.sh </span><br><span class=line>--zookeeper localhost:2181 </span><br><span class=line>—topic Multibrokerapplica-tion —from-beginning</span><br><span class=line>This is single node-multi broker demo</span><br><span class=line>This is the second message</span><br></pre></table></figure><h2 id=主题操作><a class=headerlink href=#主题操作 title=主题操作></a>主题操作</h2><h3 id=修改主题><a class=headerlink href=#修改主题 title=修改主题></a>修改主题</h3><p>语法：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>bin/kafka-topics.sh </span><br><span class=line>—zookeeper localhost:2181 </span><br><span class=line>--alter </span><br><span class=line>--topic topic_name </span><br><span class=line>--parti-tions count</span><br></pre></table></figure><p>示例：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>We have already created a topic “Hello-Kafka<span class=string>" with single partition count and one replica factor. </span></span><br><span class=line><span class=string>Now using “alter"</span> <span class=built_in>command</span> we have changed the partition count.</span><br><span class=line>bin/kafka-topics.sh </span><br><span class=line>--zookeeper localhost:2181 </span><br><span class=line>--alter </span><br><span class=line>--topic Hello-kafka </span><br><span class=line>--parti-tions 2</span><br></pre></table></figure><p>输出：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>WARNING: If partitions are increased <span class=keyword>for</span> a topic that has a key, </span><br><span class=line>the partition logic or ordering of the messages will be affected</span><br><span class=line>Adding partitions succeeded!</span><br></pre></table></figure><h3 id=删除主题><a class=headerlink href=#删除主题 title=删除主题></a>删除主题</h3><p>语法：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>bin/kafka-topics.sh </span><br><span class=line>--zookeeper localhost:2181 </span><br><span class=line>--delete </span><br><span class=line>--topic topic_name</span><br></pre></table></figure><p>示例：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>bin/kafka-topics.sh </span><br><span class=line>--zookeeper localhost:2181</span><br><span class=line>--delete </span><br><span class=line>--topic Hello-kafka</span><br></pre></table></figure><p>输出：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>> Topic Hello-kafka marked <span class=keyword>for</span> deletion</span><br></pre></table></figure><p>**注意 **：如果 <code>delete.topic.enable</code>未设置为 <code>true</code>，则此操作不会产生任何影响。</div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/KafKa%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/KafKa%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ itemprop=url>Kafka系列-KafKa原理解析</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-09-23 17:13:31" datetime=2023-09-23T17:13:31+08:00 itemprop=dateModified>2023-09-23</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/KafKa/ itemprop=url rel=index><span itemprop=name>KafKa</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、生产者><a class=headerlink href=#1、生产者 title=1、生产者></a>1、生产者</h1><h2 id=1-1、生产者客户端流程><a class=headerlink href=#1-1、生产者客户端流程 title=1.1、生产者客户端流程></a>1.1、生产者客户端流程</h2><ol><li><strong>配置信息</strong><ul><li>服务器<li>key/val序列化</ul><li><strong>生产者实例</strong><ul><li>KafkaProducer</ul><li><strong>构造消息</strong><ul><li>消息 ProducerRecord<li>消息元数据 RecordMetadata</ul><li><strong>发送消息</strong><ul><li>三种方式：发后即忘、同步、异步</ul><li><strong>关闭生产者</strong></ol><h2 id=1-2、发送消息流程分析><a class=headerlink href=#1-2、发送消息流程分析 title=1.2、发送消息流程分析></a>1.2、发送消息流程分析</h2><ul><li>主线程：拦截器 -> 序列化器 -> 分区器 -> 消息累加器：分区 - 双端队列-ProducerBatch。<li>send线程：Request -> node - Request -> selector -> kafka cluster。</ul><h2 id=1-3、消息发送相关参数><a class=headerlink href=#1-3、消息发送相关参数 title=1.3、消息发送相关参数></a>1.3、消息发送相关参数</h2><ol><li><code>compression.type</code>：消息压缩方式 gzip / snappy / lz4<li><code>linger.ms</code>：发送ProducerBatch前等待消息加入的时间，默认0<li><code>max.request.size</code>：能发送消息的最大值，默认1048576<li><code>retries</code>：发生消息异常时的重试次数，默认2147483647<li><code>retry.backoff.ms</code>：发生异常时的重试间隔时间，默认100<li><code>send.buffer.bytes</code>：socket发送消息缓冲区大小，默认131072，128KB<li><code>receive.buffer.bytes</code>：socket接收消息缓冲区大小，默认65536，64KB<li><code>request.timeout.ms</code>：等待请求响应的最长时间，默认30秒<li><code>acks</code>：有多少分区收到消息，才会响应成功。<ul><li>1：leader副本写入成功就响应。<li>0：无需等待响应（异步）。<li>-1/all：ISR集合中的副本都写入成功后再响应。</ul><li><code>connections.max.idle.ms</code>：多久后关闭限制的连接，默认9分钟</ol><h2 id=1-4、生产者发送消息流程><a class=headerlink href=#1-4、生产者发送消息流程 title=1.4、生产者发送消息流程></a>1.4、生产者发送消息流程</h2><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-%E7%94%9F%E4%BA%A7%E8%80%85%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png><h1 id=2、Broker><a class=headerlink href=#2、Broker title=2、Broker></a>2、Broker</h1><h2 id=2-1、Topic结构划分><a class=headerlink href=#2-1、Topic结构划分 title=2.1、Topic结构划分></a>2.1、Topic结构划分</h2><p>topic -> partition -> 副本 -> log -> segment(.log / .index / .timeindex / 其它)<blockquote><p><code>.index</code>索引文件 基于 稀疏索引实现，默认<code>.log</code>文件每记录4Kb数据 就会在<code>.index</code>文件中记录一条索引。</blockquote><h2 id=2-2、副本><a class=headerlink href=#2-2、副本 title=2.2、副本></a>2.2、副本</h2><ol><li>leader : follower === 1 : N。<li>AR = ISR + OSR。<li>leader副本与follower副本间若超30秒没有交流，否则从ISR中删除。<li>controller 第一次 随机 轮询。<li>leader / follower 挂了。<li>副本分配 默认。<li>手动分配。<li>leader partition 负载均衡 10%。</ol><h2 id=2-3、删除数据><a class=headerlink href=#2-3、删除数据 title=2.3、删除数据></a>2.3、删除数据</h2><p><strong>数据默认保存7天，超过就会被删除</strong>。<p>删除策略有两种：<ul><li><strong>删除</strong>：所有都过期再删除。<li><strong>压缩</strong>：以最新val的key为准保存。</ul><h2 id=2-4、高效读写><a class=headerlink href=#2-4、高效读写 title=2.4、高效读写></a>2.4、高效读写</h2><ol><li><strong>集群分区</strong><li><strong>稀疏索引</strong><li><strong>顺序读写</strong><li><strong>零拷贝 / 页缓存（内核）</strong></ol><h2 id=2-5、手动调整分区副本><a class=headerlink href=#2-5、手动调整分区副本 title=2.5、手动调整分区副本></a>2.5、手动调整分区副本</h2><ol><li><p>编写一个json文件(文件名为increase-replication-factor.json)，内容格式如下：</p> <figure class="highlight json"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=attr>"version"</span><span class=punctuation>:</span><span class=number>1</span></span><br><span class=line><span class=attr>"partitions"</span><span class=punctuation>:</span><span class=punctuation>[</span><span class=punctuation>{</span><span class=attr>"topic"</span><span class=punctuation>:</span><span class=string>"first"</span><span class=punctuation>,</span><span class=attr>"partition"</span><span class=punctuation>:</span><span class=number>0</span><span class=punctuation>,</span><span class=attr>"replicas"</span><span class=punctuation>:</span><span class=punctuation>[</span><span class=number>0</span><span class=punctuation>,</span><span class=number>1</span><span class=punctuation>]</span><span class=punctuation>}</span><span class=punctuation>,</span></span><br><span class=line>			 <span class=punctuation>{</span><span class=attr>"topic"</span><span class=punctuation>:</span><span class=string>"first"</span><span class=punctuation>,</span><span class=attr>"partition"</span><span class=punctuation>:</span><span class=number>1</span><span class=punctuation>,</span><span class=attr>"replicas"</span><span class=punctuation>:</span><span class=punctuation>[</span><span class=number>0</span><span class=punctuation>,</span><span class=number>1</span><span class=punctuation>]</span><span class=punctuation>}</span><span class=punctuation>,</span></span><br><span class=line>			 <span class=punctuation>{</span><span class=attr>"topic"</span><span class=punctuation>:</span><span class=string>"first"</span><span class=punctuation>,</span><span class=attr>"partition"</span><span class=punctuation>:</span><span class=number>2</span><span class=punctuation>,</span><span class=attr>"replicas"</span><span class=punctuation>:</span><span class=punctuation>[</span><span class=number>1</span><span class=punctuation>,</span><span class=number>0</span><span class=punctuation>]</span><span class=punctuation>}</span><span class=punctuation>,</span></span><br><span class=line>			 <span class=punctuation>{</span><span class=attr>"topic"</span><span class=punctuation>:</span><span class=string>"first"</span><span class=punctuation>,</span><span class=attr>"partition"</span><span class=punctuation>:</span><span class=number>4</span><span class=punctuation>,</span><span class=attr>"replicas"</span><span class=punctuation>:</span><span class=punctuation>[</span><span class=number>1</span><span class=punctuation>,</span><span class=number>0</span><span class=punctuation>]</span><span class=punctuation>}</span><span class=punctuation>]</span></span><br></pre></table></figure><li><p>执行如下命令</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>bin/kafka-reassign-partitions.sh --bootstrap-server node2:9092 --reassignment-json-file increase-replication-factor.json --execute</span><br></pre></table></figure></ol><h2 id=2-6、服役新节点，退役旧节点><a class=headerlink href=#2-6、服役新节点，退役旧节点 title=2.6、服役新节点，退役旧节点></a>2.6、服役新节点，退役旧节点</h2><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=comment># 第一步</span></span><br><span class=line>bin/kafka-reassign-partitions.sh --bootstrap-server node1:9092 --topics-to-move-json-file topics-to-move.json --broker-list <span class=string>"0,1,2,3"</span> --generate</span><br><span class=line></span><br><span class=line><span class=comment># 第二步</span></span><br><span class=line>vim increase-replication-factor.json</span><br><span class=line></span><br><span class=line><span class=comment># 第三步</span></span><br><span class=line>bin/kafka-reassign-partitions --bootstrap-server node1:9092 --reassignment-json-file increase-replication-factor.json --execute</span><br><span class=line></span><br><span class=line><span class=comment># 第四步</span></span><br><span class=line>bin/kafka-reassign-partitions.sh --bootstrap-server node1:9092 --reassignment-json-file increase-replication-factor.json --verify</span><br></pre></table></figure><h2 id=2-7、Broker工作流程><a class=headerlink href=#2-7、Broker工作流程 title=2.7、Broker工作流程></a>2.7、Broker工作流程</h2><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-Broker%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png><h1 id=3、消费者><a class=headerlink href=#3、消费者 title=3、消费者></a>3、消费者</h1><h2 id=3-1、消费者客户端流程><a class=headerlink href=#3-1、消费者客户端流程 title=3.1、消费者客户端流程></a>3.1、消费者客户端流程</h2><ol><li><strong>消费者配置</strong><ul><li>连接服务器<li>key/val序列化<li>消费组ID</ul><li><strong>消费者实例</strong><li><strong>订阅主题</strong><li><strong>拉取消息并消费</strong><li><strong>提交消费位移</strong><li><strong>关系消费者</strong></ol><h2 id=3-2、分区分配策略><a class=headerlink href=#3-2、分区分配策略 title=3.2、分区分配策略></a>3.2、分区分配策略</h2><ul><li><p><strong>Range：按主题来分配。</strong></p> <p>消费者数量 不是 分区数量的 整数倍时，第一个消费者多消费一个分区。</p> <p>例如：分区为【0、1、2、3、4、5、6】，消费者为【c1、c2、c3】，那么消费者消费规则为：c1：【0、1、2】，c2：【3、4】，c3：【5、6】。该种策略会造成 数据倾斜 问题。</p><li><p><strong>RoundRobin：轮询分区策略。</strong></p> <p>例如：分区为【0、1、2、3、4、5、6】，消费者为【c1、c2、c3】，那么消费者消费规则为：c1：【0、3、6】，c2：【1、4】，c3：【2、5】。</p><li><p><strong>Sticky：粘性分区策略，也即随机分配。</strong></p> <p>例如：分区为【0、1、2、3、4、5、6】，消费者为【c1、c2、c3】，那么消费者消费规则为：c1：【0、5、6】，c2：【1、3】，c3：【2、4】。注意：第一个消费者会多消费一个，但消费者所消费的分区是随机。</p><li><p><strong>CooperativeSticky：遵循相同的 Sticky逻辑，但允许再平衡。</strong></p></ul><blockquote><p>默认策略为 Range + CooperativeSticky，kafka允许设置多个分配策略。</blockquote><h2 id=3-3、偏移量Offset><a class=headerlink href=#3-3、偏移量Offset title=3.3、偏移量Offset></a>3.3、偏移量Offset</h2><ol><li>默认存储在系统主题。<li>默认自动提交，提交周期5s。<li>手动提交、同步/异步。<li>指定offset位置起消费，通过方法seek()实现。<li>按照时间消费、把时间转成offset再消费。<li>漏消费、重复消费。</ol><h2 id=3-4、事务><a class=headerlink href=#3-4、事务 title=3.4、事务></a>3.4、事务</h2><p>生产端 -> 集群 -> 消费者 -> 框架<h2 id=3-5、数据积压><a class=headerlink href=#3-5、数据积压 title=3.5、数据积压></a>3.5、数据积压</h2><ol><li>增加分区 消费者。<li>生产 -> 集群，4个参数。<li>消费端 两个参数 50m 500条。</ol><h2 id=3-6、消费者消费消息流程><a class=headerlink href=#3-6、消费者消费消息流程 title=3.6、消费者消费消息流程></a>3.6、消费者消费消息流程</h2><p>消费者组 初始化 流程图：<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E5%9B%BE.png><p>消费者组 消费消息 流程图：<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/KafKa%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png><h1 id=4、Kafka监控><a class=headerlink href=#4、Kafka监控 title=4、Kafka监控></a>4、Kafka监控</h1><h2 id=4-1、安装MySQL><a class=headerlink href=#4-1、安装MySQL title=4.1、安装MySQL></a>4.1、安装MySQL</h2><p>参考博客。<h2 id=4-2、配置Kafka><a class=headerlink href=#4-2、配置Kafka title=4.2、配置Kafka></a>4.2、配置Kafka</h2><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment># 1、修改kafka启动脚本(kafka-server-start.sh)，修改KAFKA_HEAP_OPTS参数项：</span></span><br><span class=line><span class=built_in>export</span> KAFKA_HEAP_OPTS=“-server -Xms2G -Xmx2G -XX:PermSize=128m </span><br><span class=line>-XX:+UserG1GC -XX:MaxGCPauseMillis=200 -XX:ParallelGCThreads=8 </span><br><span class=line>-XX:ConcGCThreads=5 -XX:InitiatingHeapOccupancyPercent=70”</span><br><span class=line><span class=built_in>export</span> JMX_PORT=9999</span><br></pre></table></figure><h1 id=5、Kafka硬件需求><a class=headerlink href=#5、Kafka硬件需求 title=5、Kafka硬件需求></a>5、Kafka硬件需求</h1><h2 id=5-1、日流量><a class=headerlink href=#5-1、日流量 title=5.1、日流量></a>5.1、日流量</h2><ul><li>100G万日活 * 每人每天100条 = 1亿条（中型公司）<li>处理速度：1亿条 / (24 * 3600s) = 1150条/秒<li>1150条日志 * 1K/s = 1m/s<li>高峰：1m/s * 20倍 = 20m/s - 40m/s</ul><h2 id=5-2、服务器数量><a class=headerlink href=#5-2、服务器数量 title=5.2、服务器数量></a>5.2、服务器数量</h2><p>参考公式：2 * (生产者峰值速率 * 副本数 / 100) + 1<p>服务器数量 = 2 * （20m/s * 2 / 100） + 1 = 3台服务器。<h2 id=5-3、硬盘选择><a class=headerlink href=#5-3、硬盘选择 title=5.3、硬盘选择></a>5.3、硬盘选择</h2><ul><li>1亿条数据 * 1K = 100G。<li>100G * 2副本 * 3天 / 0.7 = 1T硬盘容量。<li><strong>三台服务器，磁盘总大小要大于1T</strong>。</ul><h2 id=5-4、内存选择><a class=headerlink href=#5-4、内存选择 title=5.4、内存选择></a>5.4、内存选择</h2><p>kafka内存 = 堆内存 + 页缓存（服务器内存）<ol><li><p>堆内存10 - 15G。</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>jstat -gc kafka进程ID号 ls 10</span><br><span class=line>jmap -heap kafka进程号</span><br></pre></table></figure><li><p>页缓存segment（1G） (分区数 * 1G * 25%) / 3 = 1G。</p><li><p>一台服务器为 10G + 1G = 11G，<strong>大于11G即可</strong>。</p></ol><h2 id=5-5、CPU><a class=headerlink href=#5-5、CPU title=5.5、CPU></a>5.5、CPU</h2><p><strong>32核 最优</strong>。<ul><li>num.io.threads：写磁盘线程数，占总核数的50%，即12个<li>num.replica.fetchers：副本拉取线程数，占总核数50%的三分之一，即4个<li>num.network.threads：数据传输线程数，占总核数50%的三分之二，即8个<li>执行其它任务线程 8个</ul><h2 id=5-6、网络><a class=headerlink href=#5-6、网络 title=5.6、网络></a>5.6、网络</h2><p>网络带宽 = 峰值吞吐量 = 20M/S<p><strong>选择 千兆网卡（125M/s）即可</strong>。<h1 id=6、调优><a class=headerlink href=#6、调优 title=6、调优></a>6、调优</h1><h2 id=6-1、生产者优化><a class=headerlink href=#6-1、生产者优化 title=6.1、生产者优化></a>6.1、生产者优化</h2><h3 id=6-1-1、提升生产者吞吐量><a class=headerlink href=#6-1-1、提升生产者吞吐量 title=6.1.1、提升生产者吞吐量></a>6.1.1、提升生产者吞吐量</h3><ol><li>buffer.memory：发送缓冲区大小，默认32M，可提升到64M。<li>batch.size：默认16KB。<li>linger.ms：默认0，一般设置5-100。<li>compression.type：压缩方式。</ol><h3 id=6-1-2、数据可靠性><a class=headerlink href=#6-1-2、数据可靠性 title=6.1.2、数据可靠性></a>6.1.2、数据可靠性</h3><ol><li>acks：0 / 1 / -1，默认为-1。<li>ack设为-1。<li>分区副本数量大于等于2。<li>ISR中应答的副本数量大于等于2。</ol><h3 id=6-1-3、数据去重><a class=headerlink href=#6-1-3、数据去重 title=6.1.3、数据去重></a>6.1.3、数据去重</h3><ol><li>enable.idempotence：是否开启幂等性，默认为true，表示开启。<li>开启事务。</ol><h3 id=6-1-4、数据有序><a class=headerlink href=#6-1-4、数据有序 title=6.1.4、数据有序></a>6.1.4、数据有序</h3><ol><li>采用单分区，单分区内数据有序，可实现有序消费。<li>多分区，分区间是无序的。</ol><h3 id=6-1-5、数据乱序><a class=headerlink href=#6-1-5、数据乱序 title=6.1.5、数据乱序></a>6.1.5、数据乱序</h3><ol><li>enable.idempotence=true，开启幂等处理。<li>允许没有返回的ack次数为1-5。</ol><h2 id=6-2、Broker优化><a class=headerlink href=#6-2、Broker优化 title=6.2、Broker优化></a>6.2、Broker优化</h2><h3 id=6-2-1、服役退役节点><a class=headerlink href=#6-2-1、服役退役节点 title=6.2.1、服役退役节点></a>6.2.1、服役退役节点</h3><h3 id=6-2-2、增加分区><a class=headerlink href=#6-2-2、增加分区 title=6.2.2、增加分区></a>6.2.2、增加分区</h3><h3 id=6-2-3、增加副本因子><a class=headerlink href=#6-2-3、增加副本因子 title=6.2.3、增加副本因子></a>6.2.3、增加副本因子</h3><ol><li>创建副本存储计划<li>执行副本存储计划</ol><h3 id=6-2-4、Leader分区负载平衡><a class=headerlink href=#6-2-4、Leader分区负载平衡 title=6.2.4、Leader分区负载平衡></a>6.2.4、Leader分区负载平衡</h3><ol><li>auto.leader-rebalance.enable：默认为true，建议关闭。</ol><h3 id=6-2-5、自动创建主题><a class=headerlink href=#6-2-5、自动创建主题 title=6.2.5、自动创建主题></a>6.2.5、自动创建主题</h3><ol><li>关闭 自动创建主题功能。</ol><h2 id=6-3、消费者优化><a class=headerlink href=#6-3、消费者优化 title=6.3、消费者优化></a>6.3、消费者优化</h2><h3 id=6-3-1、消费者再平衡><a class=headerlink href=#6-3-1、消费者再平衡 title=6.3.1、消费者再平衡></a>6.3.1、消费者再平衡</h3><ol><li>消费者与coordinator心跳时间3S。<li>消费者与coordinator连接超时45S。<li>消费者 消息处理超时 5分钟。<li>消费者分区分配策略，默认Range+CooperativeSticky，可同时配置多个策略。可选策略有：Range、RoundRobin、Sticky、CooperativeSticky。</ol><h3 id=6-3-2、指定Offset消费><a class=headerlink href=#6-3-2、指定Offset消费 title=6.3.2、指定Offset消费></a>6.3.2、指定Offset消费</h3><h3 id=6-3-3、指定时间消费><a class=headerlink href=#6-3-3、指定时间消费 title=6.3.3、指定时间消费></a>6.3.3、指定时间消费</h3><h3 id=6-3-4、消费者事务><a class=headerlink href=#6-3-4、消费者事务 title=6.3.4、消费者事务></a>6.3.4、消费者事务</h3><h3 id=6-3-5、消费者提升吞吐量><a class=headerlink href=#6-3-5、消费者提升吞吐量 title=6.3.5、消费者提升吞吐量></a>6.3.5、消费者提升吞吐量</h3><ol><li>fetch.max.bytes：默认50M。<li>max.poll.records：默认500条。</ol><h3 id=6-3-6、增加下游消费者处理能力><a class=headerlink href=#6-3-6、增加下游消费者处理能力 title=6.3.6、增加下游消费者处理能力></a>6.3.6、增加下游消费者处理能力</h3><h2 id=6-4、整体调优><a class=headerlink href=#6-4、整体调优 title=6.4、整体调优></a>6.4、整体调优</h2><h3 id=6-4-1、提升吞吐量><a class=headerlink href=#6-4-1、提升吞吐量 title=6.4.1、提升吞吐量></a>6.4.1、提升吞吐量</h3><ul><li>生产者<ol><li>buffer.memory：发送缓冲区大小，默认32M，可提升到64M。<li>batch.size：默认16KB。<li>linger.ms：默认0，一般设置5-100。<li>compression.type：压缩方式。</ol><li>Broker<ol><li>增加分区</ol><li>消费者<ol><li>fetch.max.bytes：默认50M。<li>max.poll.records：默认500条。</ol><li>增加下游消费者处理能力</ul><h3 id=6-4-2、数据精准一次><a class=headerlink href=#6-4-2、数据精准一次 title=6.4.2、数据精准一次></a>6.4.2、数据精准一次</h3><ul><li>生产者<ol><li>acks设置为-1。<li>幂等性+事务。</ol><li>Broker<ol><li>分区副本大于等于2。<li>ISR中应答的最小副本数量大于等于2</ol><li>消费者<ol><li>事务+手动提交。<li>消费者输出目的地必须支持事务。</ol></ul><h3 id=6-4-3、合理设置分区数><a class=headerlink href=#6-4-3、合理设置分区数 title=6.4.3、合理设置分区数></a>6.4.3、合理设置分区数</h3><p>producer吞吐量=20M/S，consumer吞吐量=50M/S，期望吞吐量=100M/S，则：<p>分区数量=100/20=5个分区，分区数量一般设置为3-10个。<h3 id=6-4-4、单条日志大小><a class=headerlink href=#6-4-4、单条日志大小 title=6.4.4、单条日志大小></a>6.4.4、单条日志大小</h3><ol><li>message.max.bytes：默认1M，broker接收每批次消息最大值。<li>max.request.size：默认1M，broker发送每个请求的最大值，针对topic来说。<li>replica.fetch.max.bytes：默认1M，副本同步数据每批次的最大值。<li>fetch.max.bytes：默认50M。</ol><h3 id=6-4-5、服务器宕机><a class=headerlink href=#6-4-5、服务器宕机 title=6.4.5、服务器宕机></a>6.4.5、服务器宕机</h3><p>处理方法流程<ol><li>尝试启动，若可以启动，直接解决。<li>重启不行，增加内存，增加CPU、网络带宽。<li>若节点被删除，但副本数量大于等于2个，可以参考服役新节点的方式重新服役一个新节点，并执行负载均衡。</ol><h3 id=6-4-6、集群压力测试><a class=headerlink href=#6-4-6、集群压力测试 title=6.4.6、集群压力测试></a>6.4.6、集群压力测试</h3><ol><li>使用kafka官方脚本来压测<ul><li>生产者：kafka-producer-perf-test.sh<li>消费者：kafka-consumer-perf-test.sh</ul><li>其他方式压测</ol><h1 id=7、查看日志分段><a class=headerlink href=#7、查看日志分段 title=7、查看日志分段></a>7、查看日志分段</h1><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>kafka-run-class.sh kafka.tools.DumpLogSegments --files 000000000000000.index/.log</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/JVM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=url>Java系列-JVM</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-05 22:27:43" datetime=2023-10-05T22:27:43+08:00 itemprop=dateModified>2023-10-05</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/JVM/ itemprop=url rel=index><span itemprop=name>JVM</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=0、必知必会><a class=headerlink href=#0、必知必会 title=0、必知必会></a>0、必知必会</h1><h2 id=0-1、Java类加载><a class=headerlink href=#0-1、Java类加载 title=0.1、Java类加载></a>0.1、Java类加载</h2><h3 id=0-1-1、Class文件><a class=headerlink href=#0-1-1、Class文件 title=0.1.1、Class文件></a>0.1.1、Class文件</h3><h4 id=0-1-1-1、简介><a class=headerlink href=#0-1-1-1、简介 title=0.1.1.1、简介></a>0.1.1.1、简介</h4><p><strong>Class文件是一组以8位为基础单位的 二进制流，超过8位以上的会被按照 高位在前 分割成多个8位进行存储。</strong><p>Class文件格式采用一种类似C语言结构体的伪结构进行数据存储，其中包含两种数据类型，即 无符号数和表 。<ul><li><p><strong>无符号数</strong>：无符号数属于基本数据类型，以u1、u2、u4、u8分别代表1字节、2字节、4字节、8字节的无符号数。它可以描述数字、索引引用、数量值、utf8编码后的字符串值。</p><li><p><strong>表</strong>：表是由 多个无符号数和其它表组成的 复合数据类型。所有表都以<code>_info</code>结尾，用来描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。</p></ul><h4 id=0-1-1-2、class文件结构><a class=headerlink href=#0-1-1-2、class文件结构 title=0.1.1.2、class文件结构></a>0.1.1.2、class文件结构</h4><p><img alt=image-20210428110838690 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210428110838690.png><p>classFile结构中，各项含义如下：<ol><li><font color=orange>magic</font>：魔数<li><font color=orange>minor_version/major_version</font>：class文件次版本号/主版本号<li><font color=orange>constant_pool_count</font>：常量池计数器<li><font color=orange>constant_pool[constant_pool_count-1]</font>：常量池<li><font color=orange>access_flags</font>：访问标志<li><font color=orange>this_class</font>：类索引<li><font color=orange>super_class</font>：父类索引<li><font color=orange>interfaces_count</font>：接口计数器<li><font color=orange>interfaces[interfaces_count]</font>：接口表<li><font color=orange>fields_count</font>：字段计数器<li><font color=orange>fields[fields_count]</font>：字段表<li><font color=orange>methods_count</font>：方法计数器<li><font color=orange>methods[methods_count]</font>：方法表<li><font color=orange>attributes_count</font>：属性计数器<li><font color=orange>attributes[attributes_count]</font>：属性表</ol><h3 id=0-1-2、类加载过程><a class=headerlink href=#0-1-2、类加载过程 title=0.1.2、类加载过程></a>0.1.2、类加载过程</h3><h4 id=0-1-2-1、概述><a class=headerlink href=#0-1-2-1、概述 title=0.1.2.1、概述></a>0.1.2.1、概述</h4><p>虚拟机 把 描述类的数据 从Class文件加载到内存，并对数据进行校验、转化解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<p>整个生命周期包括：<strong>加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中验证、准备、解析3个部分统称为连接（Linking）</strong>。<p>加载分为两类：<ul><li><strong>显式加载</strong>：通过类加载器加载一个类。<li><strong>隐式加载</strong>：不直接使用类加载器加载类，而是虚拟机自动加载完成。</ul><blockquote><p>加载后，类的一些信息可通过工具HSDB来查看。<p>HSDB启动命令：<code>java -cp ./lib/sa-jdi.jar sun.jvm.hotspot.HSDB</code></blockquote><h4 id=0-1-2-2、加载阶段><a class=headerlink href=#0-1-2-2、加载阶段 title=0.1.2.2、加载阶段></a>0.1.2.2、加载阶段</h4><p>此阶段虚拟机会做三件事：<ol><li>通过一个<strong>类的全限定名</strong>来<strong>获取</strong>定义此<strong>类的二进制字节流</strong>；<li>将这个字节流所代表的<strong>静态存储结构转</strong>为方法区的<strong>运行时数据结构</strong>；<li>在内存中<strong>生成</strong>一个代表该类的 <strong>java.lang.Class对象</strong>，<strong>作为</strong>方法区中<strong>该类各种数据的访问入口</strong>；</ol><p>获取二进制字节流可以通过Class文件、ZIP包、网络、运行时（动态代理）、JSP生成、数据库等途径获取。<p>那些二进制字节流加载完后，按指定格式存放于方法区内（Java7及以前方法区位于永久代，Java8位于Metaspace（元空间））。然后在方法区生成一个比较特殊的<code>java.lang.Class</code>对象，用来作为 访问方法区中这些类型数据的 外部接口。<p><font color=red>注意：数组类不通过类加载器加载，而是由Java虚拟机直接创建，但数组类的元素还是要依靠类加载器进行加载。</font><h4 id=0-1-2-3、链接阶段><a class=headerlink href=#0-1-2-3、链接阶段 title=0.1.2.3、链接阶段></a>0.1.2.3、链接阶段</h4><h5 id=验证阶段><a class=headerlink href=#验证阶段 title=验证阶段></a>验证阶段</h5><p>验证的目的是确保Class文件字节流中包含的<strong>信息符合当前虚拟机的要求</strong>，且<strong>不会危害虚拟机</strong>自身的安全。<p>验证内容如下：<ol><li>文件格式验证<li>元数据验证<li>字节码验证<li>符号引用验证</ol><h5 id=准备阶段><a class=headerlink href=#准备阶段 title=准备阶段></a>准备阶段</h5><p>准备阶段主要工作：在方法区中<strong>为类变量分配内存、设置默认值</strong>。<p>类变量指的是被static修饰的变量，不包含实例变量，实例变量在对象实例化阶段分配在堆中。并且，变量的初始化值并非类中定义的值，而是该变量所属类型的默认值。<p><font color=red>注意：变量被final修饰时，该字段属性为ConstantValue，它会在 准备阶段 初始化为指定的值。</font><h5 id=解析阶段><a class=headerlink href=#解析阶段 title=解析阶段></a>解析阶段</h5><p>解析阶段主要工作：虚拟机将常量池内的 <strong>符号引用替换为直接引用</strong>。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用 进行解析。<h4 id=0-1-2-4、初始化阶段><a class=headerlink href=#0-1-2-4、初始化阶段 title=0.1.2.4、初始化阶段></a>0.1.2.4、初始化阶段</h4><p>初始化阶段主要工作：<strong>执行类构造器的<code>clinit()</code>方法</strong>。<p><code>&LTclinit>()</code>方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并而成。编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问其之前的变量，之后的变量只能赋值但不能访问。<p><font color=red>注意：<code>&LTclinit>()</code>方法 与 实例构造器() 不同，其不需要 显式调用 父类构造器，虚拟机会保证在子类的clinit()方法执行之前，父类的clinit()方法已经执行完毕。虚拟机会保证一个类的clinit()方法在多线程下被同步加锁。</font><h3 id=0-1-3、类加载器><a class=headerlink href=#0-1-3、类加载器 title=0.1.3、类加载器></a>0.1.3、类加载器</h3><h4 id=0-1-3-1、简介><a class=headerlink href=#0-1-3-1、简介 title=0.1.3.1、简介></a>0.1.3.1、简介</h4><p><strong>通过 类的全限定名 获取该类二进制字节流的代码块叫 类加载器</strong>。<h4 id=0-1-3-2、类加载器分类><a class=headerlink href=#0-1-3-2、类加载器分类 title=0.1.3.2、类加载器分类></a>0.1.3.2、类加载器分类</h4><p>JVM规范中规定，将派生于抽象类<code>ClassLoader</code>的类加载器都称为 自定义类加载器。<p>实际开发中，通常会将类加载器分为如下几种：<ol><li><p><strong>启动类加载器（Bootstrap ClassLoader）</strong></p> <p>使用C/C++语言实现，并不继承java.lang.ClassLoader。为安全起见，主要负责加载Java核心类库，比如：<code>%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar</code>和class等。</p><li><p><strong>扩展类加载器（Extensions ClassLoader）</strong></p> <p>使用Java语言实现，派生于抽象类ClassLoader，父类是启动类加载器。</p> <p>主要负责加载<code>%JRE_HOME%\lib\ext</code>目录下的jar包和class文件。</p><li><p><strong>应用程序/系统类加载器（App ClassLoader）</strong></p> <p>使用Java语言实现，派生于抽象类ClassLoader，父类是扩展类加载器。</p> <p>加载 CLASSPATH 或 java.class.path 指定路径下的类库。</p><li><p><strong>自定义类加载器（Custom ClassLoader）</strong></p> <p>自定义类加载器可以扩展加载源、修改类加载方式，隔离加载类、防止源码泄露。JDK1.2之前，实现自定义类加载需要继承抽象类ClassLoader并重写loadClass方法，而JDK1.2之后建议重写findClass方法来代替重写loadClass方法。</p> <p>若无特别需求，则建议直接继承URLClassLoader类，可避免编写findClass方法及获取字节流的方式。</p></ol><p><font color=red>注意：这些类加载器之间是包含（复合）关系，而并非是继承关系。</font><h4 id=0-1-3-3、常用命令><a class=headerlink href=#0-1-3-3、常用命令 title=0.1.3.3、常用命令></a>0.1.3.3、常用命令</h4><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -Xbootclasspath/a:. cn.shh.xxx.Test bootstrap F init</span><br></pre></table></figure><ul><li><code>Xbootclasspath</code>：表示设置bootclasspath。<li><code>/a</code>：表示将当前目录追加至bootclass之后。</ul><p>常用命令：<ul><li><code>java -Xbootclasspath:&LTnew bootclasspath></code><li><code>java -Xbootclasspath/a:<追加路径></code><li><code>java -Xbootclasspath/p:<追加路径></code></ul><h3 id=0-1-4、双亲委派模型><a class=headerlink href=#0-1-4、双亲委派模型 title=0.1.4、双亲委派模型></a>0.1.4、双亲委派模型</h3><h4 id=0-1-4-1、简介><a class=headerlink href=#0-1-4-1、简介 title=0.1.4.1、简介></a>0.1.4.1、简介</h4><p><img alt=image-20201224173439957 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20201224173439957.png><p>上图所示，<strong>类加载器间的关系就称为 类加载器的双亲委派模型（Parents Delegation Mode）。</strong><p><strong>类加载器的 双亲委派模型 在 JDK 1.2 期间被引入。</strong>它并不是一个强制性约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。<h4 id=0-1-4-2、工作机制><a class=headerlink href=#0-1-4-2、工作机制 title=0.1.4.2、工作机制></a>0.1.4.2、工作机制</h4><p><strong>双亲委派机制是指：一个类加载器收到了类加载请求时会先请求自己的父加载器去加载，如果父加载器无法加载该类，那么才会交给当前类加载器来加载。</strong><h4 id=0-1-4-3、特点><a class=headerlink href=#0-1-4-3、特点 title=0.1.4.3、特点></a>0.1.4.3、特点</h4><ol><li><p>Java类随它的类加载器一起具备了一种带有优先级的层次关系。</p><li><p>保证Java程序的稳定运行。</p><li><p>避免类被重复加载。</p><li><p>保证了安全。</p></ol><h4 id=0-1-4-4、实现原理><a class=headerlink href=#0-1-4-4、实现原理 title=0.1.4.4、实现原理></a>0.1.4.4、实现原理</h4><p><strong>双亲委派模型的实现代码体现在抽象类<code>java.lang.ClassLoader</code>的<code>loadClass()</code>方法中。</strong>逻辑如下：<ol><li>先检查一个类是否被加载过，若没有被加载，则调用父加载器的 loadClass() 方法进行加载。<li>若父加载器为空，则默认使用启动类加载器作为父加载器。<li>如果父加载器加载失败，抛出 ClassNotFoundException 异常后，再调用自己的 findClass() 方法进行加载。</ol><h4 id=0-1-4-5、破坏双亲模型><a class=headerlink href=#0-1-4-5、破坏双亲模型 title=0.1.4.5、破坏双亲模型></a>0.1.4.5、破坏双亲模型</h4><p>到目前为止，双亲委派模型主要出现过3次 较大规模的 破坏情况：<ol><li>由于 JDK 1.2 才发布双亲委派模型，类加载器和抽象类 ClassLoader 则在 JDK 1.0 时代就已经存在，为了兼容已经存在的自定义类加载器实现，JDK 1.2之后添加了一个新的 protected方法 findClass() 。JDK 1.2之后已不在提倡覆盖 loadClass() 方法，而应当把自己的类加载逻辑写入 findClass() 方法中，在 loadClass() 中如果父类加载失败，则会调用自己的 findClass() 方法来完成加载。<li><strong>基础类之所以称为“基础类”，是因为它们会作为API来被用户代码调用，但是，如果基础类反过来需要调用用户代码时，该怎么办？于是线程上下文类加载器就出现了。</strong>有了线程上下文类加载器，JNDI服务可以去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为打破了双亲委派模型的层次结构来逆向使用类加载器，这实际上违背了双亲委派模型的一般性原则。<li>第三次破坏是由于 <strong>用户对程序动态性的追求而导致，动态性是指：代码热替换、模块热部署等</strong>。比如 OSGI 中的类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更复杂的网状结构。<li>Tomcat等web容器的出现。<li>OSGI、Jigsaw等模块化技术的应用。</ol><h4 id=0-1-4-6、重要方法><a class=headerlink href=#0-1-4-6、重要方法 title=0.1.4.6、重要方法></a>0.1.4.6、重要方法</h4><ul><li>loadClass()：类加载的主要方法。双亲委派机制的体现就是该方法。<li>findClass()：根据名称或位置加载.class字节码。<li>definclass()：把字节码转化为Class。</ul><p><font color=red>注意：自定义类加载器需要破坏双亲委派原则时就重写loadClass方法。如果只想自定义类加载器不想破坏双亲委派模型，那就继承ClassLoader并重写findClass方法。</font><p><code>findClass()</code>方法是JDK1.2之后 ClassLoader 新添加的一个方法。<blockquote><p>JDK1.2 后不提倡覆盖loadClass()方法，而建议把自己的逻辑写到<code>findClass()</code>方法中。因为<code>loadClass()</code>方法无法完成类加载逻辑时最终还是会调用<code>findClass()</code>方法来完成加载。</blockquote><h4 id=0-1-4-7、JNDI-JDBC破坏双亲委派><a class=headerlink href=#0-1-4-7、JNDI-JDBC破坏双亲委派 title=0.1.4.7、JNDI/JDBC破坏双亲委派></a>0.1.4.7、JNDI/JDBC破坏双亲委派</h4><p><strong>Java的基础类会被Bootstrap加载，且会通过API方式调用这些基础类。但是，除了API方式调用，还有一种SPI方式调用，如JDBC服务。</strong><p>创建数据库连接的方式如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>Connection</span> <span class=variable>conn</span> <span class=operator>=</span> DriverManager.getConnection(<span class=string>"jdbc:mysql://localhost:3306/mysql"</span>, <span class=string>"root"</span>, <span class=string>"1234"</span>);</span><br></pre></table></figure><p><code>java.sql.DriverManager</code>类位于rt.jar中 ，故会被根加载器加载。类加载时，会执行该类的静态方法。其中有一段关键代码是：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>ServiceLoader&LTDriver> loadedDrivers = ServiceLoader.load(Driver.class);</span><br></pre></table></figure><p>这段代码，会尝试加载classpath下实现了Driver接口的所有实现类。<p>那么，问题就来了。<p><strong>DriverManager会被根加载器加载，但在加载时遇到以上代码，会尝试加载Driver的所有实现类，但这些实现类基本都是第三方提供，根据双亲委派原则，第三方的类不能被根加载器加载。</strong><p>那么，怎么解决这个问题呢？<p><strong>在JDBC中引入ThreadContextClassLoader（线程上下文加载器，默认情况下是AppClassLoader）来破坏双亲委派原则。</strong><p>我们深入到<code>ServiceLoader.load</code>方法就可以看到：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> &LTS> ServiceLoader&LTS> <span class="title function_">load</span><span class=params>(Class&LTS> service)</span> {</span><br><span class=line>    <span class=type>ClassLoader</span> <span class=variable>cl</span> <span class=operator>=</span> Thread.currentThread().getContextClassLoader();</span><br><span class=line>    <span class=keyword>return</span> ServiceLoader.load(service, cl);</span><br><span class=line>}</span><br></pre></table></figure><p>第一行，获取当前线程的线程上下⽂类加载器 AppClassLoader，⽤于加载 classpath 下的具体实现类。<h4 id=0-1-4-8、Tomcat破坏双亲委派><a class=headerlink href=#0-1-4-8、Tomcat破坏双亲委派 title=0.1.4.8、Tomcat破坏双亲委派></a>0.1.4.8、Tomcat破坏双亲委派</h4><p>Tomcat中可能会部署多个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，如果采用默认的双亲委派类加载机制，那么无法加载多个相同类。所以，Tomcat破坏双亲委派原则，提供隔离的机制，为web容器中每一个应用单独提供一个WebAppClassLoader加载器。<p><strong>Tomcat类加载机制：为了实现隔离性，优先加载 Web 应用自己定义的类，所以没有遵照双亲委派约定，每一个WebAppClassLoader负责加载自己目录下的class文件，加载不到时再交给CommonClassLoader加载，这和双亲委派刚好相反。</strong><h4 id=0-1-4-9、总结><a class=headerlink href=#0-1-4-9、总结 title=0.1.4.9、总结></a>0.1.4.9、总结</h4><h5 id=父子加载器之间是继承关系吗？><a class=headerlink href=#父子加载器之间是继承关系吗？ title=父子加载器之间是继承关系吗？></a>父子加载器之间是继承关系吗？</h5><p><strong>双亲委派模型中，类加载器之间的关系一般不会以继承（Inheritance）的关系来实现，而是使用组合（Composition）关系来复用父加载器代码。</strong><p>如下为ClassLoader中父加载器的定义：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">ClassLoader</span> {</span><br><span class=line>    <span class=comment>// The parent class loader for delegation</span></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>final</span> ClassLoader parent;</span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>Java中继承和组合的区别是什么？<ol><li>组合(has-a)关系可以<strong>显式获得被包含类（继承中称为父类）对象</strong>，而继承(is-a)则是<strong>隐式获得父类对象</strong>，被包含类和父类对应，而组合外部类和子类对应。<li>组合关系在<strong>运行期决定</strong>，而继承关系在<strong>编译期决定</strong>。<li>组合是组合类和被包含类之间的一种<strong>松耦合关系</strong>，而继承则是父类和子类之间的一种<strong>紧耦合关系</strong>。<li>组合类中包含了外部类的对象，组合类<strong>可以选择性调用外部类方法</strong>；而使用继承关系时，父类的所有方法和变量都被子类<strong>无条件继承，子类不能选择</strong>。<li>继承可以实现类型回溯，即用父类变量引用子类对象，这样便可以实现多态，而组合没有这个特性。<li>如果你确定复用另外一个类的方法永远不需要改变时，应该使用组合，因为组合只是<strong>简单复用被包含类的接口</strong>，而继承除了复用父类接口外，它还可以<strong>覆盖这些接口</strong>，修改父类接口的默认实现，这个特性是组合没有的。<li>组合体现的是整体和部分的思想，例如电脑类是由内存类，CPU类，硬盘类等组成，而继承则体现的是一种可回溯的父子关系，子类也是父类的一个对象。<li><strong>两者区别主要体现在类的抽象阶段</strong>，在分析类之间的关系时就应该确定是采用组合还是采用继承。</ol></blockquote><h2 id=0-2、JVM运行时数据区><a class=headerlink href=#0-2、JVM运行时数据区 title=0.2、JVM运行时数据区></a>0.2、JVM运行时数据区</h2><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/2.1.1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E5%89%8D%E8%A8%80-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%BB%93%E6%9E%84%E5%88%92%E5%88%86.png><h3 id=0-1-1、程序计数器（私有）><a class=headerlink href=#0-1-1、程序计数器（私有） title=0.1.1、程序计数器（私有）></a>0.1.1、程序计数器（私有）</h3><h4 id=0-1-1-1、简介-1><a class=headerlink href=#0-1-1-1、简介-1 title=0.1.1.1、简介></a>0.1.1.1、简介</h4><p>JVM的程序计数寄存器，是物理PC寄存器的一种抽象模拟。<p>程序计数器主要<strong>存储要执行的程序指令的地址信息</strong>，确保程序正确执行。<h4 id=0-1-1-2、作用><a class=headerlink href=#0-1-1-2、作用 title=0.1.1.2、作用></a>0.1.1.2、作用</h4><p>PC寄存器用来<strong>存储指向下一条指令的地址</strong>，也即将要执行的指令代码的地址。由执行引擎读取下一条指令。<h3 id=0-1-2、方法区（公有）><a class=headerlink href=#0-1-2、方法区（公有） title=0.1.2、方法区（公有）></a>0.1.2、方法区（公有）</h3><h4 id=0-1-2-1、简介><a class=headerlink href=#0-1-2-1、简介 title=0.1.2.1、简介></a>0.1.2.1、简介</h4><p>方法区存储类的结构信息：<strong>运行时常量池、字段和方法数据、构造函数和普通方法的字节码内容</strong>，还包含一些<strong>类、实例、接口初始化时用到的特殊方法</strong>。<p><font color=red>注意事项：方法区内存不足时会导致内存溢出错误。</font><p>方法区内存溢出的场景：Spring、MyBatis。<h4 id=0-1-2-2、实现><a class=headerlink href=#0-1-2-2、实现 title=0.1.2.2、实现></a>0.1.2.2、实现</h4><ul><li><strong>PermSpace（JDK7）</strong><ol><li>JDK7中方法区实现是永久代。<li><strong>字符串常量池位于永久代中</strong>。<li>FGC不会清理。<li>-XX:PermSize默认值为20.75M，<code>-XX:MaxPermSize</code>默认值在32位下是64M，64位下是82M。</ol><li><strong>MetaSpace（JDK8）</strong><ol><li>JDK8中方法区实现是元空间，使用物理内存。<li><strong>字符串常量池位于堆中</strong>。<li>会触发FGC清理。<li>windows下，<code>-XX:MetaspaceSize</code>是21M，<code>-XX:MaxMetaspaceSize</code>的值是-1，表示没有限制。</ol></ul><h4 id=0-1-2-3、方法区演变><a class=headerlink href=#0-1-2-3、方法区演变 title=0.1.2.3、方法区演变></a>0.1.2.3、方法区演变</h4><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/2.5.10-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E6%96%B9%E6%B3%95%E5%8C%BA-%E6%96%B9%E6%B3%95%E5%8C%BA%E6%BC%94%E8%BF%9B.png><h4 id=0-1-2-4、运行时常量池><a class=headerlink href=#0-1-2-4、运行时常量池 title=0.1.2.4、运行时常量池></a>0.1.2.4、运行时常量池</h4><h5 id=常量池><a class=headerlink href=#常量池 title=常量池></a>常量池</h5><p>常量池是Class文件的一部分，用于存放编译期生成的各种字面量和符号引用，这部分内容将会在类被加载后放到方法区的运行时常量池中。<h5 id=运行时常量池><a class=headerlink href=#运行时常量池 title=运行时常量池></a>运行时常量池</h5><p><strong>加载 类或接口 到虚拟机后就会创建对应的运行时常量池</strong>。<p>运行时常量池是方法区的一部分。运行时常量池 是 常量池表的【运行时表示形式】，它包含多种常量，从编译期可知的 数字字面量 到必须运行且解析后才能获得的 方法或字段引用。（类似于符号表，但比符号表要更广泛。）<h3 id=0-1-3、虚拟机栈（私有）><a class=headerlink href=#0-1-3、虚拟机栈（私有） title=0.1.3、虚拟机栈（私有）></a>0.1.3、虚拟机栈（私有）</h3><h4 id=0-1-3-1、简介-1><a class=headerlink href=#0-1-3-1、简介-1 title=0.1.3.1、简介></a>0.1.3.1、简介</h4><p><strong>每个线程都有自己的栈，栈中的数据都是以 栈帧 的格式存在。</strong>每个线程在执行一个方法时会在栈中对应一个栈帧。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种信息。<p><font color=red>注意事项：虚拟机栈内存不足时会导致内存溢出错误。</font><h4 id=0-1-3-2、内部结构><a class=headerlink href=#0-1-3-2、内部结构 title=0.1.3.2、内部结构></a>0.1.3.2、内部结构</h4><p>Java虚拟机中主要存储的是栈帧，而栈帧由以下几部分组成：<ul><li><strong>局部变量表</strong><li><strong>操作数栈</strong><li><strong>动态链接</strong><li><strong>方法出口</strong><li><strong>一些附加信息</strong></ul><h4 id=0-1-3-3、其它><a class=headerlink href=#0-1-3-3、其它 title=0.1.3.3、其它></a>0.1.3.3、其它</h4><p>问题分析：<ul><li>栈内存越大越好吗？<li>垃圾回收是否设计栈内存？<li>方法中的局部变量是否是线程安全的？</ul><h3 id=0-1-4、本地方法栈（私有）><a class=headerlink href=#0-1-4、本地方法栈（私有） title=0.1.4、本地方法栈（私有）></a>0.1.4、本地方法栈（私有）</h3><h4 id=0-1-4-1、简介-1><a class=headerlink href=#0-1-4-1、简介-1 title=0.1.4.1、简介></a>0.1.4.1、简介</h4><p><strong>本地方法栈使用C语言实现，线程私有，主要服务于本地方法的调用。</strong><p>本地方法栈中存储本地方法，执行引擎工作时会加载本地方法库。<p><font color=red>注意事项：本地方法栈内存不足时会导致内存溢出错误。</font><h4 id=0-1-4-2、注意事项><a class=headerlink href=#0-1-4-2、注意事项 title=0.1.4.2、注意事项></a>0.1.4.2、注意事项</h4><ul><li>可以通过本地方法接口来访问虚拟机内部的运行时数据区。<li>直接使用本地处理器中的寄存器。<li>直接从本地内存的堆中分配任意内存。<li>并非所有JVM都支持本地方法，JVM规范并没有要求本地方法栈使用的语言、具体实现方式、数据结构等，也可以选择不实现本地方法栈。<li>Hotspot中直接将本地方法栈和虚拟机栈合二为一。</ul><h3 id=0-1-5、堆（公有）><a class=headerlink href=#0-1-5、堆（公有） title=0.1.5、堆（公有）></a>0.1.5、堆（公有）</h3><h4 id=0-1-5-1、简介><a class=headerlink href=#0-1-5-1、简介 title=0.1.5.1、简介></a>0.1.5.1、简介</h4><p><strong>堆是各个线程共有的区域，该区域主要存储加载创建对象过程中生成的对象数据。</strong><p><font color=red>注意事项：堆空间不足时会导致内存溢出错误。</font><h4 id=0-1-5-2、分代模型><a class=headerlink href=#0-1-5-2、分代模型 title=0.1.5.2、分代模型></a>0.1.5.2、分代模型</h4><p>逻辑上将堆分为以下几个部分：<ul><li>年轻代<ul><li>Eden区<li>Surivor from区<li>Surivor to区</ul><li>老年代<li>永久代/元空间（JDK7及之前是永久代，之后是元空间）</ul><h4 id=0-1-5-3、空间大小><a class=headerlink href=#0-1-5-3、空间大小 title=0.1.5.3、空间大小></a>0.1.5.3、空间大小</h4><h5 id=堆大小><a class=headerlink href=#堆大小 title=堆大小></a>堆大小</h5><p>可以通过Xms、Xmx来设置堆内存初始内存和最大内存，堆大小在JVM启动时已经设定好了。<p>默认情况下：初始内存大小为物理内存/64，最大内存为物理内存的1/4。<p><font color=red>注意事项：堆内存大小超过最大内存限制时会抛出OOM异常。</font><h5 id=新生代老年代><a class=headerlink href=#新生代老年代 title=新生代老年代></a>新生代老年代</h5><p>默认参数<code>-XX:NewRatio=2</code>表示新生代占比1，老年代占比2，新生代占整个堆内存的1/3。同理<code>-XX:NewRatio=4</code>表示新生代占比1，老年代占比4，新生代占整个堆内存的1/5。<p><font color=red>注意事项：参数<code>-XX:NewRatio=2</code>的实际效果会受参数<code>-XX:UseAdaptiveSizePolicy</code>的影响，后者参数表示 开启关闭自适应内存分配策略。</font>如果想要达到指定的具体效果，需要使用参数<code>-XX:SurvivorRatio</code>来设置，该参数表示新生代中Eden区与Survivor区的比例。<p>使用参数<code>-Xmn</code>设置新生代的空间大小。<h3 id=0-1-6、直接内存><a class=headerlink href=#0-1-6、直接内存 title=0.1.6、直接内存></a>0.1.6、直接内存</h3><p><strong>直接内存在堆外，不会受限于-Xmx设置的最大堆大小。</strong>但系统内存也是有限的，Java堆和直接内存的总和依然受限于操作系统能提供的最大内存。<p>直接内存有如下缺点：<ul><li>分配回收成本较高。<li>不受JVM内存回收管理。</ul><p><strong>直接内存大小可以通过参数MaxDirectMemorySize来设置，如果不指定，则默认与堆的最大值-Xmx参数值一致。</strong><h3 id=0-1-7、字符串常量池><a class=headerlink href=#0-1-7、字符串常量池 title=0.1.7、字符串常量池></a>0.1.7、字符串常量池</h3><h4 id=0-1-7-1、简介><a class=headerlink href=#0-1-7-1、简介 title=0.1.7.1、简介></a>0.1.7.1、简介</h4><p><strong>String Pool是一个固定大小的Hashtable，默认大小为1009。</strong>如果String Pool中字符串太多，会造成链表过长，进而导致在调用String的intern方法时性能会大幅下降。<p><strong>JDK6及以前版本，字符串常量池在方法区中，JDK7及之后版本，字符串常量池转移到堆中。</strong><h4 id=0-1-7-2、参数设置><a class=headerlink href=#0-1-7-2、参数设置 title=0.1.7.2、参数设置></a>0.1.7.2、参数设置</h4><p>使用参数<code>-XX:StringTableSize</code>可设置StringTable的长度。<blockquote><p>JDK6中StringTable大小固定为1009。JDK7中StringTable大小默认为60013。JDK8中最小有效值为1009。</blockquote><h2 id=0-3、执行引擎><a class=headerlink href=#0-3、执行引擎 title=0.3、执行引擎></a>0.3、执行引擎</h2><h3 id=0-3-1、即时编译器><a class=headerlink href=#0-3-1、即时编译器 title=0.3.1、即时编译器></a>0.3.1、即时编译器</h3><h5 id=解释器与编译器><a class=headerlink href=#解释器与编译器 title=解释器与编译器></a>解释器与编译器</h5><p><strong>当程序需要迅速启动和执行时，解释器先运行，然后编译器逐渐发挥作用。如果编译器优化后类发生了变化，那么可以立即通过解释器来运行。所以说解释器和编译器是互相配合执行代码。</strong><p>HotSpot虚拟机内置了三个即时编译器：<strong>客户端编译器（C1编译器）、服务端编译器（C2编译器）、Graal编译器（JDK 10中正式引入）。Graal编译器的目标是替换C2编译器</strong>。<p>JVM执行代码时可采用多种模式，现分为三种：<ul><li><p><strong>混合模式（默认方式）</strong></p> <p>使用参数<code>-Xmixed</code>可以设置JVM运行于混合模式。</p><li><p><strong>解释器（Intepreter）模式</strong></p> <p>使用参数<code>-Xint</code>可以设置JVM运行于“解释模式”。</p><li><p><strong>JIT（Just In-Time，即时编译）模式</strong></p> <p>使用参数<code>-Xcomp</code>可以设置JVM运行于“编译模式”，但要注意，当编译器无法继续工作时解释器依然会介入执行。</p></ul><p><strong>分层编译在JDK 6中初步实现，在JDK 7服务端模式中作为默认编译策略被开启</strong>。分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其包括：<ul><li>第0层：程序纯解释执行，并且解释器不开启性能监控功能（Profiling）。<li>第1层：使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启 性能监控功能。<li>第2层：使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能。<li>第3层：使用客户端编译器执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。<li>第4层：使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启 用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。</ul><p>分层编译后，解释器、客户端编译器、服务端编译器可同时工作，在服务端编译器采用高复杂度优化算法时，客户端编译器可先采用简单优化来为之争取更多编译时间。<blockquote><p>疑问：既然编译到本地效率更高，为啥不全部编译到本地呢？<ol><li>现在的Java解释器执行效率已经很高，几乎可以和编译器相媲美。<li>类库或class很多时，编译到本地会导致启动过程非常慢。</ol></blockquote><h5 id=热点代码><a class=headerlink href=#热点代码 title=热点代码></a>热点代码</h5><p>被即时编译器编译的目标是“热点代码”，热点代码主要有两类：<ul><li><strong>被多次调用的方法</strong>。<li><strong>被多次执行的循环体</strong>。</ul><p>某段代码是不是热点代码，是否触发即时编译需要执行“热点探测”（Hot Spot Code Detection），热点探测并不一定要知道方法具体被调用多少次，目前主流的热点探测判定方式有两种，分别是：<ul><li><p><strong>基于采样的热点探测</strong></p> <p>采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。这种探测方式的好处是实现简单高效，可以很容易获取方法调用关系，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而 扰乱热点探测。</p><li><p><strong>基于计数器的热点探测</strong></p> <p>采用这种方法的虚拟机会为 每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为 它是“热点方法”。这种统计方法实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。</p></ul><h5 id=调用计数器><a class=headerlink href=#调用计数器 title=调用计数器></a>调用计数器</h5><p>方法被调用时会先查看是否存在该方法编译后的代码，存在则先执行编译后的代码，不存在则会将方法调用计时器值加1，然后判断方法调用计数器值与回边计数器值之和是否超过调用计数器的阈值，超过阈值会向即时编译器发送方法代码编译请求，在代码被即时编译器编译完成前会暂时先使用解释器来解释执行，当编译完成后，该方法的调用入口地址就会被自动修改为新值，后期调用该方法时就可以执行编译后的代码了。<blockquote><p>方法调用计数器的默认阈值在客户端模式下是1500次，在服务端模式下是10000次，这个阈值可以通过虚拟机参数<code>-XX:CompileThreshold</code>来人为设定。</blockquote><p>默认设置下，方法调用计数器统计的是一段时间内方法被调用的次数，该时间段内，如果方法的调用次数不足以触发即时编译器来编译，那方法调用计数器数值会减少一半，该过程被称为<em><strong>方法调用计数器热度衰减（Counter Decay）</strong></em>，而这段时间称为此方法统计的<em><strong>半衰周期（Counter Half Life Time）</strong></em>。<blockquote><p><font color=orange>热度衰减操作在垃圾收集时进行</font>，可使用参数<code>-XX:-UseCounterDecay</code>来关闭热度衰减，让方法调用计数器统计方法调用的绝对次数。可使用参数<code>-XX:CounterHalfLifeTime</code>设置半衰周期的时间，单位秒。</blockquote><h5 id=回边计数器><a class=headerlink href=#回边计数器 title=回边计数器></a>回边计数器</h5><p><strong>回边计数器会统计一个方法中循环体代码的执行次数，在字节码中遇到控制流向后跳转的指令就称为“回边（Back Edge）”，回边计数器统计的目的是为了触发栈上替换编译。</strong><p>回边计数器阈值计算分以下两种情况：<ul><li>客户端模式下回边计数器阈值计算公式为：方法调用计数器阈值（-XX:CompileThreshold）乘以OSR比率（-XX:OnStackReplacePercentage）除以100。其中<code>-XX:OnStackReplacePercentage</code>默认值为933，<strong>如果都取默认值，那客户端模式下的回边计数器的阈值为 13995</strong>。<li>服务端模式下回边计数器阈值的计算公式为：方法调用计数器阈值（-XX:CompileThreshold）乘以（OSR比率（-XX:OnStackReplacePercentage）减去解释器监控比率（-XX:InterpreterProfilePercentage）的差值）除以100。其中-XX：OnStack ReplacePercentage默认值为140，- XX:InterpreterProfilePercentage默认值为33，<strong>如果都取默认值，那服务端模式的回边计数器的阈值为10700</strong>。</ul><p>当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否有已经编译好的版本，如果有的话，它将会优先执行已编译的代码，否则就把回边计数器的值加一，然后判断方法调用计数器与回边计数器值之和是否超过回边计数器的阈值。超过阈值时会提交一个栈上替换编译请求， 并且把回边计数器的值稍微降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。<p>与方法计数器不同，回边计数器没有计算热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出时会把方法计数器的值也调整到溢出状态，这样下次再进入该方法时就会执行标准编译过程。<blockquote><p><font color=red>注意：回边次数 不等于 循环次数，因为并不是所有的循环都是回边，如空循环并不算控制流向后跳转，也不会被回边计数器统计。</font></blockquote><h3 id=0-3-2、提前编译器><a class=headerlink href=#0-3-2、提前编译器 title=0.3.2、提前编译器></a>0.3.2、提前编译器</h3><p><strong>JDK 9引入了Jaotc，可实现提前编译Class文件及模块</strong>，它可以减少程序的启动时间和到达全速性能的预热时间。该功能需要特定的物理机器和虚拟机参数，限制太多。<h3 id=0-3-3、编译器优化><a class=headerlink href=#0-3-3、编译器优化 title=0.3.3、编译器优化></a>0.3.3、编译器优化</h3><h5 id=方法内联><a class=headerlink href=#方法内联 title=方法内联></a>方法内联</h5><p><strong>内联被称为优化之母，消除方法调用成本外，也为其它优化手段提供了良好基础。</strong><p><strong>方法内联就是把目标方法代码“复制”到发起调用的方法之中，避免发生真实方法调用。</strong>该功能得益于即时编译器的付出。<blockquote><p>Java中默认的实例方法是虚方法。只有使用 invokespecial指令调用的私有方法、实例构造器、父类方法和使用invokestatic指令调用的静态方法才会在编译期进行解析。被final修饰的方法使用invokevirtual指令调用，它是非虚方法，《Java语言规范》中明确说明了这点。</blockquote><p>内联与虚方法之间会产生“矛盾”，C和C++是通过使用final关键字来修饰方法解决的，但Java在虚拟机中解决这个问题。<p>Java虚拟机首先引入了一种名为类型<em><strong>继承关系分析（Class Hierarchy Analysis，CHA）</strong></em>技术，用于确定目前已加载的类中，某个接口是否有多于一种的实现、某个类是否存在子类、某个子类是否覆盖了父类的某个虚方法 等信息。<p>编译器进行内联时会根据不同情况采取不同处理：非虚方法直接进行内联就可以；对于虚方法，会向CHA查询此方法下是否有多个目标版本可供选择，如果只有一个版本，那可以内联，这种内联称为<em><strong>守护内联（Guarded Inlining）</strong></em>。由于Java程序是动态连接的，说不准什么时候就会加载到新的类型从而改变CHA结论，因此这种内联属于<em><strong>激进预测性优化</strong></em>。假如在程序的后续执行过程中，虚拟机一直没有加载到会导致方法接收者继承关系发生变化的类，那这个内联优化的代码就可以一直使用。如果加载了导致继承关系发生变化的新类，那么就必须抛弃已编译的代码，退回到解释状态执行，或重新进行编译。<p>如果被调用的方法确实有多个版本可供选择，那即时编译器还将进行最后一次努力，使用内联缓存（Inline Cache）的方式来缩减方法调用的开销。这种状态下方法调用真正发生，比起直接查虚方法表还要快一些。<h5 id=逃逸分析><a class=headerlink href=#逃逸分析 title=逃逸分析></a>逃逸分析</h5><h6 id=简介><a class=headerlink href=#简介 title=简介></a>简介</h6><p>逃逸分析（Escape Analysis）与类型继承关系分析一 样，并不是直接优化代码的手段，而是<strong>为其他优化措施提供依据的分析技术</strong>。<p>逃逸分析基本原理：分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，这种称为方法逃逸；甚至还有可能被外部线程访问，这种称为线程逃逸；不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。<p><font color=red>注意：JDK 6u23版本之后，Hotspot默认开启了逃逸分析。</font><h6 id=优化><a class=headerlink href=#优化 title=优化></a>优化</h6><p>如果能证明一个对象不会逃逸到方法或线程之外（换句话说是别的方法或线程无法通过任何途径 访问到这个对象），或者逃逸程度比较低（只逃逸出方法而不会逃逸出线程），则可能为这个对象实例采取不同程度的优化。比如：<ul><li><p><font color=orange>栈上分配</font></p> <p>如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁。栈上分配支持方法逃逸，但不支持线程逃逸。</p><li><p><font color=orange>标量替换</font></p> <p>若一个数据已经无法再分解成更小的数据来表示了，Java虚拟机中的原始数据类型（int、long等数值类型及reference类型等）都不能再进一步分解了，那么这些数据就可以被称为标量。相对的，如果一个数据可以继续分解，那它就被称为聚合量（Aggregate），Java 中的对象就是典型的聚合量。如果把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量 恢复为原始类型来访问，这个过程就称为标量替换。</p> <p>标量替换可以视作栈上分配的一种特例，实现更简单（不用考虑整个对象完整结构的分配），但对逃逸程度的要求更高，它不允许对象逃逸出方法范围内。</p><li><p><font color=orange>同步消除</font></p> <p>线程同步本身是一个相对耗时的过程，如果逃逸分析 能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争， 对这个变量实施的同步措施也就可以安全地消除掉。</p></ul><h6 id=功能开启><a class=headerlink href=#功能开启 title=功能开启></a>功能开启</h6><ul><li>-XX:+DoEscapeAnalysis：开启逃逸分析。<li>-XX:+PrintEscapeAnalysis：查看逃逸分析筛选结果。</ul><h5 id=公共子表达式消除><a class=headerlink href=#公共子表达式消除 title=公共子表达式消除></a>公共子表达式消除</h5><p>公共子表达式消除的含义是：<strong>如果一 个表达式E之前已经被计算过了，并且从先前的计算到现在E中所有变量的值都没有发生变化，那么E 的这次出现就称为公共子表达式。对于这种表达式，没有必要花时间再对它重新进行计算，可直接使用计算过的表达式结果代替E。</strong>如果这种优化仅限于程序基本块内，便可称为局部公共子表达式消除（Local Common Subexpression Elimination），如果这种优化的范围涵盖了多个基本块，那就称为全局公共子表达式消除（Global Common Subexpression Elimination）。<h5 id=数组边界检查消除><a class=headerlink href=#数组边界检查消除 title=数组边界检查消除></a>数组边界检查消除</h5><p>数组边界检查消除（Array Bounds Checking Elimination）是即时编译器中的一项语言相关的经典优化技术。如果有一个数组foo[]，在Java语言中访问数组元素foo[i]的时候系统将会自动进行上下界 的范围检查，即i必须满足“i>=0&&i<=foo.length”的访问条件，否则将抛出一个运行时异常： java.lang.ArrayIndexOutOfBoundsException。对于虚拟机执行子系统来说，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这必定是一种性能负担。<p>无论如何，为了安全，数组边界检查肯定是要做的，但数组边界检查是不是必须在运行期间一次 不漏地进行则是可以“商量”的事情。<strong>如果对于数组的访问在编译期根据数据流分析就能确定没有越界，执行时就无须判断了。</strong>更常见的是数组访问发生在循环中，且使用循环变量来访问数组。那么在循环中就可以把整个数组的上下界检查消除掉，这可以减少很多次的条件判断操作。<h3 id=0-3-4、Graal编译器><a class=headerlink href=#0-3-4、Graal编译器 title=0.3.4、Graal编译器></a>0.3.4、Graal编译器</h3><p><strong>从JDK 10起，Graal 编译器可以替换服务端编译器成为HotSpot分层编译中最顶层的即时编译器。</strong><p>Java虚拟机编译器接口（Java-Level JVM Compiler Interface，JVMCI）（JDK 9时发布的JEP 243）使得Graal可以从HotSpot的代码中分离出来。<p>通过Java虚拟机编译器接口就可以把一个在HotSpot虚拟机外部的、用Java语言实现的即时编译器（不局限于Graal）集成到HotSpot中，响应HotSpot发出的最顶层的编译请求，并将编译后的二进制代码 部署到 HotSpot代码缓存中。此外，又可以绕开HotSpot的即时编译系统，让该编译器直接为应用的类库编译出二进制机器码，将该编译器当作一个提前编译器去使用 （如Jaotc）。<h3 id=0-3-5、总结><a class=headerlink href=#0-3-5、总结 title=0.3.5、总结></a>0.3.5、总结</h3><p><strong>HotSpot VM采用解释器与即时编译器并存的架构。</strong>Java虚拟机运行时会采用解释器和即时编译器协调工作的方式来达到相对较好的工作状态。<h2 id=0-4、本地方法接口><a class=headerlink href=#0-4、本地方法接口 title=0.4、本地方法接口></a>0.4、本地方法接口</h2><h3 id=0-4-1、本地方法><a class=headerlink href=#0-4-1、本地方法 title=0.4.1、本地方法></a>0.4.1、本地方法</h3><h4 id=0-4-1-1、定义><a class=headerlink href=#0-4-1-1、定义 title=0.4.1.1、定义></a>0.4.1.1、定义</h4><p><strong>被关键字native修饰的没有方法体的方法就是一个本地方法，本地方法是java调用非java代码的接口。</strong><h2 id=0-5、对象管理><a class=headerlink href=#0-5、对象管理 title=0.5、对象管理></a>0.5、对象管理</h2><h3 id=0-5-1、对象创建><a class=headerlink href=#0-5-1、对象创建 title=0.5.1、对象创建></a>0.5.1、对象创建</h3><p>创建对象一般遵循以下6大步骤：<ol><li>判断对象对应的类是否已经被加载、连接、初始化。<li>为对象分配内存。<ul><li>如果内存规整，通过 指针碰撞 方式来分配内存。<li>如果内存不规整，通过 空闲列表 方式来分配内存。</ul><li>处理并发安全问题。<ul><li>采用CAS失败重试，区域加锁保证更新原子性。<li>每个线程预先分配一个TLAB。</ul><li>初始化分配到的空间。<li>设置对象的对象头。<li>执行init方法进行初始化。</ol><h3 id=0-5-2、对象定位><a class=headerlink href=#0-5-2、对象定位 title=0.5.2、对象定位></a>0.5.2、对象定位</h3><h4 id=0-5-2-1、简介><a class=headerlink href=#0-5-2-1、简介 title=0.5.2.1、简介></a>0.5.2.1、简介</h4><p>对象访问有两种方式：句柄访问和直接指针。<strong>Java中使用的是直接指针</strong>。<h4 id=0-5-2-2、句柄访问><a class=headerlink href=#0-5-2-2、句柄访问 title=0.5.2.2、句柄访问></a>0.5.2.2、句柄访问</h4><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86-1.1-%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%BD%8D-%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%9B%BE%E7%A4%BA.png><h4 id=0-5-2-3、直接指针><a class=headerlink href=#0-5-2-3、直接指针 title=0.5.2.3、直接指针></a>0.5.2.3、直接指针</h4><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86-1.2-%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%BD%8D-%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E5%9B%BE%E7%A4%BA.png><h1 id=1、JVM基础><a class=headerlink href=#1、JVM基础 title=1、JVM基础></a>1、JVM基础</h1><h2 id=1-1、概述><a class=headerlink href=#1-1、概述 title=1.1、概述></a>1.1、概述</h2><h3 id=1-1-1、简介><a class=headerlink href=#1-1-1、简介 title=1.1.1、简介></a>1.1.1、简介</h3><p><strong>JVM全称为Java Virtual Machine，意为Java虚拟机。</strong><p><strong>JVM、JRE、JDK、JAVASE、JAVAEE等的关系：JVM < JRE < JDK < JAVASE < JAVAEE。它们之间是包含与被包含的关系。</strong>详情介绍如下：<ul><li><strong>JVM</strong>：Java Virtual Machine，表示Java虚拟机。<li><strong>JRE</strong>：Java Runtime Environment，表示Java运行时环境。<li><strong>JDK</strong>：Java Development Kit，表示Java开发工具集。<li><strong>JAVAME</strong>：Java Micro Edition，表示Micro版，之前称J2ME。是一个技术和规范的集合，它为移动设备（包括消费类产品、嵌入式设备、高级移动设备等）提供了基于Java环境的开发与应用平台。Java ME分为两类配置，一类是面向小型移动设备的<em>CLDC</em>（Connected Limited Device Profile），一类是面向功能更强大的移动设备如智能手机和机顶盒，称为<em>CDC</em>（Connected Device Profile CDC）。Java ME有自己的类库，其中<em>CLDC</em>使用的是专用的Java虚拟机叫做J<em>VM</em>。<li><strong>JAVASE</strong>：Java Standard Edition，表示Java标准版，之前称为J2SE。JAVASE是Java技术的核心和基础，是Java ME和Java EE编程的基础。<li><strong>JAVAEE</strong>：Java Enterprise Edition，表示Java企业版，之前也称为J2EE。Java EE 是在 Java SE 的基础上构建的，它提供Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web 3.0应用程序。</ul><p>JVM在垃圾回收层面与C++的区别：<ul><li>JAVA：系统自动处理，开发效率高，执行效率低。<li>C++：手工处理，开发效率低，执行效率高。容易出现忘记回收、内存泄漏、回收多次、非法访问等问题。</ul><h3 id=1-1-2、优点><a class=headerlink href=#1-1-2、优点 title=1.1.2、优点></a>1.1.2、优点</h3><p>JVM优点如下：<ul><li>一次编译，到处运行。<li>自动垃圾回收。<li>多态特性。<li>数组下标越界检查。</ul><h3 id=1-1-3、常见虚拟机><a class=headerlink href=#1-1-3、常见虚拟机 title=1.1.3、常见虚拟机></a>1.1.3、常见虚拟机</h3><ul><li><p>Hotspot</p><li><p>JRockit（BEA）：专注于服务端应用，据行业基准测试显示，其是世界上最快的JVM。2008年BEA被Oracle收购，Oracle计划将整合两大优秀的虚拟机，整合方式是在Hotspot基础上加入JRockit的新特性。</p><li><p>J9（IBM）：市场定位与HotSpot相似，适用于服务器端、桌面应用、嵌入式应用等场景。2017年左右，IBM开源了J9 VM，命名为OpenJ9，交给Eclipse基金会管理。</p><li><p>KVM</p><li><p>Azul VM</p><li><p>Liquid VM（BEA）</p><li><p>Graal VM：2018年Oracle公开Graal VM，号称“Run Programs Faster Anywhere”，其与1995年宣称的“Write Once, Run Anywhere”遥相呼应。Graal VM是在HotSpot VM基础上增强而成的跨语言全栈虚拟机，适用于多种语言。</p></ul><h3 id=1-1-4、虚拟机退出><a class=headerlink href=#1-1-4、虚拟机退出 title=1.1.4、虚拟机退出></a>1.1.4、虚拟机退出</h3><p>导致虚拟机退出的情况分以下几种：<ul><li>程序正常结束。<li>程序执行过程中遇到了异常或错误，进而导致虚拟机退出。<li>因操作系统出现错误导致虚拟机退出。<li>调用了Runtime类或System类的exit方法，或Runtime类的halt方法，且Java安全管理器也允许这种操作。</ul><h2 id=1-2、认识垃圾><a class=headerlink href=#1-2、认识垃圾 title=1.2、认识垃圾></a>1.2、认识垃圾</h2><h3 id=1-2-1、垃圾定义><a class=headerlink href=#1-2-1、垃圾定义 title=1.2.1、垃圾定义></a>1.2.1、垃圾定义</h3><p><strong>没有引用指向的任何对象都称为垃圾，且应该被回收。</strong><h2 id=1-3、识别垃圾><a class=headerlink href=#1-3、识别垃圾 title=1.3、识别垃圾></a>1.3、识别垃圾</h2><h3 id=1-3-1、引用计数算法><a class=headerlink href=#1-3-1、引用计数算法 title=1.3.1、引用计数算法></a>1.3.1、引用计数算法</h3><h4 id=1-3-1-1、简介><a class=headerlink href=#1-3-1-1、简介 title=1.3.1.1、简介></a>1.3.1.1、简介</h4><p><strong>当一个对象被引用时，该对象的引用计数器数值会加1，这被称为引用计数算法。</strong><h4 id=1-3-1-2、缺点><a class=headerlink href=#1-3-1-2、缺点 title=1.3.1.2、缺点></a>1.3.1.2、缺点</h4><ol><li><p><font color=red>需要一个单独字段来存储计数器，增加了存储开销。</font></p><li><p><font color=red>每次赋值都需要更新计数器，增加了时间开销。</font></p><li><p><font color=red>不能解决“循环引用”问题。</font></p> <p>循环引用问题指：有对象A和对象B，对象A中含有对象B的引用，对象B中含有对象A的引用。此时，对象A和对象B的引用计数器都不为0，但是在系统中却不存在任何第3个对象引用了A或B。也就是说A和B是应该被回收的垃圾对象，但由于垃圾对象间相互引用，从而使垃圾回收器无法识别，引起内存泄漏。</p></ol><h3 id=1-3-2、根可达性算法><a class=headerlink href=#1-3-2、根可达性算法 title=1.3.2、根可达性算法></a>1.3.2、根可达性算法</h3><h4 id=1-3-2-1、简介><a class=headerlink href=#1-3-2-1、简介 title=1.3.2.1、简介></a>1.3.2.1、简介</h4><p><strong>根搜索算法有实现简单、执行高效等特点，可有效解决循环引用问题，防止内存泄漏发生。</strong><p>根搜索算法是以 根对象集合 为起始点，按照从上至下的方式 搜索 被根对象集合所连接的目标对象是否可达，如果目标对象不可达就表明该对象己死亡，便可以在 instanceOopDesc Mark World 中将其标记为垃圾对象。在根搜索算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。<h4 id=1-3-2-2、根对象><a class=headerlink href=#1-3-2-2、根对象 title=1.3.2.2、根对象></a>1.3.2.2、根对象</h4><p><strong>一个程序刚启动时需要的那些对象就称为根对象。</strong>比如：<ol><li>main线程栈帧中的那些对象。<li>静态变量访问到的对象。<li>常量池：一个class用到其它class的那些类的对象。<li>JNI：调用C和C++那些方法所使用到的那些类或对象。</ol><p>在Hotspot中，根对象集合包含5个元素：<ol><li>Java 对象引用。<li>本地方法内的对象引用。<li>运行时常量池中的对象引用。<li>方法区中类静态属性的对象引用。<li>与一个类对应的唯一数据类型的 Class 对象。</ol><h4 id=1-3-2-3、总结><a class=headerlink href=#1-3-2-3、总结 title=1.3.2.3、总结></a>1.3.2.3、总结</h4><p><strong>根搜索算法中的不可达对象最初处于缓刑阶段，真正死亡要经历两次标记</strong>：<ol><li>如果一个对象没有与GCRoot相连，那么该对象会被第一次标记并判断是否执行该对象的finaliz()方法。如果该对象没有覆盖finalize()方法或finalize()方法已经执行过了，那么无需操作，否则会将该对象放入F-Queue中，然后通过一个低优先级的finalizer线程来执行该对象的finalize()方法。<li>稍后 GC 将对 F- Queue 中的对象进行第二次标记，第二次标记之前，如果该对象与其它对象建立了引用关系，那么第二次标记时会将该对象移出即将回收的集合。如果第二次标记之前，该对象没有发生引用变化，那么它将会被真正回收。</ol><h2 id=1-4、垃圾回收><a class=headerlink href=#1-4、垃圾回收 title=1.4、垃圾回收></a>1.4、垃圾回收</h2><h3 id=1-4-1、垃圾回收算法><a class=headerlink href=#1-4-1、垃圾回收算法 title=1.4.1、垃圾回收算法></a>1.4.1、垃圾回收算法</h3><h4 id=1-4-1-1、标记清除（Mark-Sweep）><a class=headerlink href=#1-4-1-1、标记清除（Mark-Sweep） title=1.4.1.1、标记清除（Mark-Sweep）></a>1.4.1.1、标记清除（Mark-Sweep）</h4><h5 id=定义><a class=headerlink href=#定义 title=定义></a>定义</h5><p><strong>标记存活对象然后清除未被标记的垃圾对象的算法称为标记清除算法。</strong>该算法将垃圾回收分两个阶段，标记阶段和清除阶段。<ol><li><p>标记阶段：Collector从引用根节点开始遍历，标记可以被根对象关联到的对象，这些对象都是可达对象。</p><li><p>清除阶段：Collector对堆内存从头到尾进行线性遍历，如果发现某个对象在其Header中没有被标记为可达对象，则将其回收。这里的清除并非是真的清除，而是将待清除对象的地址保存到空闲地址列表中，为新对象分配内存时可直接覆盖使用。</p></ol><p>标记-清除算法不需要运行环境监测每一次内存分配和指针操作，而只要在“标记”阶段中跟踪每个指针变量的指向，用类似思路实现的垃圾收集器常被称为 跟踪收集器。<h5 id=优缺点><a class=headerlink href=#优缺点 title=优缺点></a>优缺点</h5><ul><li>优点：效率较高、成本较低。<li>缺点：会产生内存碎片、执行效率低。</ul><h4 id=1-4-1-2、复制（Copying）><a class=headerlink href=#1-4-1-2、复制（Copying） title=1.4.1.2、复制（Copying）></a>1.4.1.2、复制（Copying）</h4><h5 id=定义-1><a class=headerlink href=#定义-1 title=定义></a>定义</h5><p><strong>将内存空间分为两块，每次只使用其中一块。垃圾回收时会将当前使用内存（假如为区域A）中的存活对象拷贝至另一空闲内存中（假如为区域B），然后清掉区域A中剩下的死亡对象并交换两个内存区域的角色，最后完成垃圾回收，这种算法称之为 复制算法。</strong><h5 id=优缺点-1><a class=headerlink href=#优缺点-1 title=优缺点></a>优缺点</h5><ul><li>优点：<font color=orang>只扫描一次，效率高且没有碎片；</font><li>缺点：<font color=red>每次只使用一半内存，造成空间浪费；移动复制对象需要调整对象引用；</font></ul><h5 id=适用场景><a class=headerlink href=#适用场景 title=适用场景></a>适用场景</h5><p>适用于存活对象较少的情况。<h4 id=1-4-1-3、标记压缩（Mark-Compact）><a class=headerlink href=#1-4-1-3、标记压缩（Mark-Compact） title=1.4.1.3、标记压缩（Mark-Compact）></a>1.4.1.3、标记压缩（Mark-Compact）</h4><h5 id=定义-2><a class=headerlink href=#定义-2 title=定义></a>定义</h5><p>标记压缩算法思想：<strong>从根节点开始标记所有被引用对象，然后将存活对象压缩到内存一端并按顺序排放，之后清理边界外所有的空间。</strong><p>空间压缩后，内存较为规整，此种情况下可以通过 指针碰撞 算法为新对象分配空间。<h5 id=优缺点-2><a class=headerlink href=#优缺点-2 title=优缺点></a>优缺点</h5><ul><li>优点：<font color=orang>不会产生碎片；</font><li>缺点：<font color=red>两遍扫描，第一遍先找出有用的，第二遍才进行移动，如果是多线程还需要进行同步，效率低。</font></ul><h4 id=1-4-1-4、增量算法-（Incremental-Collecting><a title="1.4.1.4、增量算法 （Incremental Collecting )" class=headerlink href=#1-4-1-4、增量算法-（Incremental-Collecting></a>1.4.1.4、增量算法 （Incremental Collecting )</h4><p>增量算法思想：<strong>垃圾收集线程和应用程序线程交替执行，每次垃圾收集线程只收集小片内存空间，然后切换到应用程序线程执行。依次反复，直到垃圾收集完成。</strong><p><strong>垃圾回收线程和应用程序线程同时执行可减少停顿时间，但因线程切换、上下文转换等会降低吞吐量。</strong><h4 id=1-4-1-5、Card-Table（卡表）><a title="1.4.1.5、Card Table（卡表）" class=headerlink href=#1-4-1-5、Card-Table（卡表）></a>1.4.1.5、Card Table（卡表）</h4><p>官方解释：A kind of remembered set that records where oops have changed in a generation.<p><strong>Card Table 是一种数组结构，底层由BitMap实现，每个位置代表一个Card，其大小为1byte。</strong>1byte有八位，通过约定每一位的含义就可区分不同的使用场景。<p>卡表作用：<strong>将老年代空间分成多个大小相同的块（一般为 <code>128~512bytes</code> ），叫做卡片（Card）。对象放在不同的card中，如果老年代的某个Card中的对象引用了年轻代中的对象，写屏障逻辑就会将之标记为Dirty，下次扫描时只需扫描Dirty Card即可。</strong><h3 id=1-4-2、垃圾回收触发机制><a class=headerlink href=#1-4-2、垃圾回收触发机制 title=1.4.2、垃圾回收触发机制></a>1.4.2、垃圾回收触发机制</h3><h4 id=1-4-2-1、年轻代GC><a class=headerlink href=#1-4-2-1、年轻代GC title=1.4.2.1、年轻代GC></a>1.4.2.1、年轻代GC</h4><ul><li>年轻代空间不足时会触发Minor GC，Survivor区满并不会触发GC。<li>Minor GC会引发STW，暂停其它用户线程，当垃圾线程执行完毕后用户线程才会恢复。</ul><h4 id=1-4-2-2、老年代GC><a class=headerlink href=#1-4-2-2、老年代GC title=1.4.2.2、老年代GC></a>1.4.2.2、老年代GC</h4><ul><li>出现了Major GC前通常会先执行一次Minor GC（非绝对，Parallel Scavenge收集器可以直接执行Major GC。）。<li>Major GC 速度一般比Minor GC慢10倍以上。<li>Major GC后内存依然不足，那么就报OOM。</ul><h4 id=1-4-2-3、FUll-GC><a title="1.4.2.3、FUll GC" class=headerlink href=#1-4-2-3、FUll-GC></a>1.4.2.3、FUll GC</h4><p>触发FGC的情况有如下几种：<ul><li>老年代空间不足。<li>方法区空间不足。<li>通过Minor GC后进入老年代对象的平均大小大于老年代可用空间。<li>由Eden区、Survivor from区向Survivor to区复制对象时，对象大小大于to区可用内存，则把该对象放进老年代，且老年代可用内存小于该对象大小。<li>调用System.gc()方法时，通知系统执行Full GC，但不保证一定执行。</ul><h2 id=1-5、堆内存逻辑分区模型><a class=headerlink href=#1-5、堆内存逻辑分区模型 title=1.5、堆内存逻辑分区模型></a>1.5、堆内存逻辑分区模型</h2><ul><li>除了Epsilon、ZGC、Shenandoah之外，其它GC都使用逻辑分代模型。<li>G1是逻辑分代，物理不分代。<li>除此之外，不仅逻辑分代，物理也分代。</ul><h2 id=1-6、新老年代划分><a class=headerlink href=#1-6、新老年代划分 title=1.6、新老年代划分></a>1.6、新老年代划分</h2><h3 id=1-6-1、新生代><a class=headerlink href=#1-6-1、新生代 title=1.6.1、新生代></a>1.6.1、新生代</h3><ul><li>eden（伊甸）：默认比例为8，存放刚new出来的对象。<li>survivor from：默认比例为1，回收一次后要存储对象的区域。<li>survivor to：默认比例为1，回收一次后要存储对象的区域。</ul><h3 id=1-6-2、老年代><a class=headerlink href=#1-6-2、老年代 title=1.6.2、老年代></a>1.6.2、老年代</h3><ul><li>tenured（终身）：默认与新生代的比例为2:1，存放大对象和生命力较强的对象。</ul><h2 id=1-7、对象生命周期><a class=headerlink href=#1-7、对象生命周期 title=1.7、对象生命周期></a>1.7、对象生命周期</h2><h3 id=1-7-1、生命周期><a class=headerlink href=#1-7-1、生命周期 title=1.7.1、生命周期></a>1.7.1、生命周期</h3><p><strong>对象产生后会优先栈上分配；如果不能分配，就判断其大小，如果太大直接放进老年代，如果不大，就在TLAB中分配；如果还是分配不下，就直接在eden区分配。</strong><p>eden区经过一次垃圾回收之后，未被回收的对象会进入surivor from区，eden区和surivor from区再经过一次回收后，未被回收的对象会被移动到survivor to区（注意：移动完成后from区和to区交换角色，即 from变to，to变from，为的是下次再回收后来存储alive对象），以此反复执行，直到年龄达到阈值时就进入老年代。<p><font color=red>注意：from <—> to区中对象间的移动超过阈值就会进入老年代，这个阈值可通过如下参数进行设置：</font><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-XX:MaxTenuringThreshold</span><br></pre></table></figure><p>栈上分配前提条件：<ul><li>线程私有小对象。<li>无逃逸：在某一段代码中使用，代码外无法使用。<li>支持标量替换：用普通的类型代替对象（若仅仅使用一个对象中的1至2个属性，那么就无需先拿到对象再获取对应属性，而是直接使用这两个属性代替这个对象）。<li>无需调整。</ul><h3 id=1-7-2、TLAB><a class=headerlink href=#1-7-2、TLAB title=1.7.2、TLAB></a>1.7.2、TLAB</h3><h4 id=1-7-2-1、简介><a class=headerlink href=#1-7-2-1、简介 title=1.7.2.1、简介></a>1.7.2.1、简介</h4><p><strong>TLAB意为 线程本地分配缓冲区，TLAB是堆内存eden区中划分出的一块线程专用空间。</strong>线程初始化时，虚拟机会为每一个线程分配一块TLAB空间，该空间线程独有。如果要分配内存，优先在该空间上分配，这样就避免了竞争，大大提高内存分配效率和线程安全。<p><font color=red>注意：TLAB的独占只限于“内存分配”这个动作，而对于TLAB的读取、内存回收等操作依然属于线程共享。</font><h4 id=1-7-2-2、TLAB问题><a class=headerlink href=#1-7-2-2、TLAB问题 title=1.7.2.2、TLAB问题></a>1.7.2.2、TLAB问题</h4><p>假如一个线程的TLAB空间大小为100KB，已经使用80KB，当再分配一个30KB的对象时，就无法在TLAB中分配，遇到此种情况，有两种处理方案：<ol><li>直接在堆内存中分配对象。<li>废弃当前TLAB，重新申请TLAB并在其中为对象分配内存。</ol><p>为解决这两个问题，虚拟机设定了一个参数<code>refill_waste</code>，称为最大浪费空间。当请求分配的内存大于该参数值，则在堆内存中分配对象，当小于该值时则废弃当前TLAB并重新申请TLAB，然后在其中进行对象分配。<h4 id=1-7-2-3、TLAB相关参数><a class=headerlink href=#1-7-2-3、TLAB相关参数 title=1.7.2.3、TLAB相关参数></a>1.7.2.3、TLAB相关参数</h4><ul><li>手动指定tlab大小：-XX：TLABSize<li>tlab功能开启/关闭：XX:+/-UseTLAB<li>tlab占eden空间百分比：-XX:TLABWasteTargetPercent<li>禁用tlab运行时动态自动调整大小功能：-XX:-ResizeTLAB<li>tlab的refill_waste值：-XX：TLABRefillWasteFraction（默认大小64，表示使用约为1/64空间大小作为refill_waste）<li>观察tlab使用情况：-XX+PringTLAB</ul><h3 id=1-7-3、何时进入老年代><a class=headerlink href=#1-7-3、何时进入老年代 title=1.7.3、何时进入老年代></a>1.7.3、何时进入老年代</h3><h4 id=1-7-3-1、参数指定><a class=headerlink href=#1-7-3-1、参数指定 title=1.7.3.1、参数指定></a>1.7.3.1、参数指定</h4><p><strong>年龄达到参数<code>-XX:MaxTenuringThreshold</code> 设置的值</strong>，如果不指定，默认参考如下：<ul><li>Parallel Scavenge：15<li>CMS：6<li>G1：15</ul><h4 id=1-7-3-2、动态年龄><a class=headerlink href=#1-7-3-2、动态年龄 title=1.7.3.2、动态年龄></a>1.7.3.2、动态年龄</h4><ul><li>from -> to后超过to内存总量50%。form + eden区的存活对象全部移到to区后，若此时to区中相同年龄对象的内存大小总和占用to区内存总量的一半时，则将这些年龄相同的对象和超过该年龄的对象直接放入老年代。所以说也不一定非得到了15岁/6岁才行。<li>把年龄最大的直接放入老年代。</ul><h2 id=1-8、垃圾收集器><a class=headerlink href=#1-8、垃圾收集器 title=1.8、垃圾收集器></a>1.8、垃圾收集器</h2><h3 id=1-8-1、Serial（JDK1-3）><a class=headerlink href=#1-8-1、Serial（JDK1-3） title=1.8.1、Serial（JDK1.3）></a>1.8.1、Serial（JDK1.3）</h3><h4 id=简介-1><a class=headerlink href=#简介-1 title=简介></a>简介</h4><p><strong>JDK1.3.1引入Serial GC，适用于 存储器小，CPU少的环境。</strong><p>Serial 收集器工作于<strong>年轻代</strong>，采用<strong>复制算法</strong>、串行回收和“ Stop-the-World ”机制的方式执行内存回收。<h4 id=参数><a class=headerlink href=#参数 title=参数></a>参数</h4><ul><li>-XX:+UseSerialGC：年轻代、老年代分别使用Serial、Serial Old收集器。</ul><h3 id=1-8-2、Serial-Old><a title="1.8.2、Serial Old" class=headerlink href=#1-8-2、Serial-Old></a>1.8.2、Serial Old</h3><h4 id=简介-2><a class=headerlink href=#简介-2 title=简介></a>简介</h4><p>Serial Old收集器工作于<strong>老年代</strong>，采用单线程<strong>标记压缩算法</strong>。<blockquote><p>Serial Old是运行在Client模式下默认的老年代垃圾回收器。Serial Old在Server模式下主要有两个用途：与新生代的Parallel Scavenge配合使用；作为老年代CMS收集器的后备方案。</blockquote><h4 id=参数-1><a class=headerlink href=#参数-1 title=参数></a>参数</h4><ul><li>-XX:+UseSerialGC：年轻代、老年代分别使用Serial、Serial Old收集器。</ul><h3 id=1-8-3、Parallel-Scavenge（JDK1-4）><a title="1.8.3、Parallel Scavenge（JDK1.4）" class=headerlink href=#1-8-3、Parallel-Scavenge（JDK1-4）></a>1.8.3、Parallel Scavenge（JDK1.4）</h3><h4 id=简介-3><a class=headerlink href=#简介-3 title=简介></a>简介</h4><p><strong>JDK1.4.2引入Parallel GC，JDK6中成为默认垃圾回收器。</strong><p>Parallel Scavenge收集器工作在<strong>年轻代</strong>，采用<strong>复制算法</strong>，关注吞吐量。与并行收集器一样都是多线程、独占式的收集器。<p>自适应调节策略是Parallel Scavenge与ParNew的一个重要区别。<blockquote><p>如果没有优化，JDK1.8默认使用Parallel Scavenge和Parallel Old，简称PS+PO。</blockquote><h4 id=参数-2><a class=headerlink href=#参数-2 title=参数></a>参数</h4><ul><li>-XX:+UseParallelGC：年轻代使用并行回收收集器，老年代使用串行收集器。<li>-XX:+UseParallelOldGC：年轻代和老年代都使用井行垃圾回收器。<li>-XX:ParallelGCThreads：年轻代并行收集器的线程数量。默认当CPU数量小于8时线程数量等于CPU数量。当CPU数量大于8时线程数量值为<code>3 + [5 * cpu数量 / 8]</code>。<li>-XX MaxGCPauseMills：最大垃圾收集停顿时间（单位毫秒），它的值是一个大于0的整数。<li>-XX:+GCTimeRatio：垃圾收集时间占总时间的比例。取值范围为0~100，默认值为99，也就是垃圾回收时间占用不超过1%。与参数<code>-XX MaxGCPauseMills</code>有一定矛盾性。<li>-XX:+UseAdaptiveSizePolicy：开启自适应调节策略。在这种模式下，年轻代的大小、 Eden的比例、晋升老年代的对象年龄等参数会被自动调整，己达到在堆大小、吞吐量和停顿时间之间的平衡点。仅指定虚拟机的最大堆、目标的吞吐量（ GCTimeRatio ）和停顿时间（ MaxGCPauseMills) , 让虚拟机自己完成调优工作。</ul><h3 id=1-8-4、Parallel-Old><a title="1.8.4、Parallel Old" class=headerlink href=#1-8-4、Parallel-Old></a>1.8.4、Parallel Old</h3><h4 id=简介-4><a class=headerlink href=#简介-4 title=简介></a>简介</h4><p><strong>Parallel Old垃圾回收器在JDK6中开始启用，工作与老年代。它是采用标记压缩算法且基于并行回收和“Stop-the-World”机制的关注吞吐量的多线程并发收集器，。</strong><h4 id=如何开启？><a class=headerlink href=#如何开启？ title=如何开启？></a>如何开启？</h4><ul><li>-XX:+UseParallelOldGC：年轻代和老年代中都使用并行回收收集器；<li>-XX :ParallelGCThreads：垃圾回收时的线程数量；</ul><h3 id=1-8-5、ParNew><a class=headerlink href=#1-8-5、ParNew title=1.8.5、ParNew></a>1.8.5、ParNew</h3><h4 id=简介-5><a class=headerlink href=#简介-5 title=简介></a>简介</h4><p><strong>ParNew收集器是Serial收集器的多线程版本。</strong><p>ParNew收集器工作于<strong>年轻代</strong>，采用<strong>复制算法</strong>和<strong>Stop-the-World机制</strong>，并采用井行回收的方式执行内存回收。<blockquote><p>ParNew是大多数JVM运行在Server模式下新生代的默认垃圾回收器。<p>目前来说，ParNew只能与CMS配合工作。</blockquote><h4 id=优缺点-3><a class=headerlink href=#优缺点-3 title=优缺点></a>优缺点</h4><ul><li>优点<ol><li>单CPU环境下， ParNew 收集器不见得比 Serial 收集器更高效；<li>ParNew收集器可充分利用多核心CPU的优势，可更快速地完成垃圾收集，提升程序吞吐量；</ol><li>缺点</ul><h4 id=参数-3><a class=headerlink href=#参数-3 title=参数></a>参数</h4><ul><li>-XX:+UseParNewGC：使用 ParNew 收集器；<li>-XX:ParallelGCThreads：并发线程数量，默认与CPU数量相同。</ul><h4 id=ParNew-vs-Paraller-Scavenge><a title="ParNew vs Paraller Scavenge" class=headerlink href=#ParNew-vs-Paraller-Scavenge></a>ParNew vs Paraller Scavenge</h4><ol><li>PN响应时间优先，可配合CMS。<li>PS吞吐量优先。</ol><p>ParNew是Parallel Scavenge的变种。<h3 id=1-8-6、CMS（JDK1-4）><a class=headerlink href=#1-8-6、CMS（JDK1-4） title=1.8.6、CMS（JDK1.4）></a>1.8.6、CMS（JDK1.4）</h3><h4 id=1-8-6-1、简介><a class=headerlink href=#1-8-6-1、简介 title=1.8.6.1、简介></a>1.8.6.1、简介</h4><p>CMS（Concurrent Mark Sweep）采用<strong>标记清除算法和STW机制</strong>，它可以确保工作线程和垃圾回收线程同时工作，拥有低延迟等特点。<p><font color=red>注意：HotSpot 中， 除了 CMS收集器外的任何老年代垃圾收集器都会执行Full GC，只有G1收集器较为特殊。</font><blockquote><p>JDK 1.4.2引入CMS，JDK 14中删除了CMS。</blockquote><h4 id=1-8-6-2、回收过程><a class=headerlink href=#1-8-6-2、回收过程 title=1.8.6.2、回收过程></a>1.8.6.2、回收过程</h4><ol><li><p><strong>初始标记</strong>：有STW；单线程；</p><li><p><strong>并发标记</strong>：工作线程和回收线程同时工作；多线程；会产生漏标问题。</p> <p>最耗时的阶段，且并发执行、不产生STW、响应较好，如何做到？它会从根对象往下找，寻找过程中可能出现 垃圾被引用后又变成不是垃圾的情况。如果该情况发生在并发标记阶段，此时就会进入重新标记阶段，标记上一阶段标记后又发生变化的那些对象，因为变化不多，故重新标记也有STW，不过时间不长，故它可以控制暂停时间。</p><li><p><strong>重新标记</strong>：使用多线程对起死回生对象、漏标对象 进行重新标记。存在STW。</p><li><p><strong>并发清理</strong>：清理已存在的垃圾对象。因与应用线程一起执行，故该阶段会产生浮动垃圾。</p></ol><h4 id=1-8-6-3、优缺点><a class=headerlink href=#1-8-6-3、优缺点 title=1.8.6.3、优缺点></a>1.8.6.3、优缺点</h4><h5 id=优点><a class=headerlink href=#优点 title=优点></a>优点</h5><p>CMS优点：<strong>并发收集、低延迟</strong>。<h5 id=缺点><a class=headerlink href=#缺点 title=缺点></a>缺点</h5><p>CMS存在如下缺点：<ul><li><p><strong>会产生内存碎片</strong>：并发清理后存在内存碎片，可用空间不足导致不得不提前触发FULL GC。</p><li><p><strong>对CPU资源较敏感</strong>：并发执行占用了一部分的资源导致程序一定程度上变慢，总吞吐量会降低。</p><li><p><strong>无法处理浮动垃圾</strong>：应用线程与垃圾回收线程同时运行，并发标记阶段可能出现一些新的垃圾对象，而这些新的垃圾对象无法在这一时刻被及时处理，只能留给下一次GC来处理。</p></ul><p><font color=red>CMS无法处理时会采用 单线程Serial Old收集器 进行标记压缩，速度会非常慢，应避免该情况发生。</font><h4 id=1-8-6-4、参数><a class=headerlink href=#1-8-6-4、参数 title=1.8.6.4、参数></a>1.8.6.4、参数</h4><ul><li><strong>-XX:+UseConcMarkSweepGC</strong>：使用 CMS 收集器。开启该参数时会自动开启参数-XX:+UserParNewGC，最终的组合就是年轻代使用ParNew，老年代使用CMS和Serial Old。<li><strong>-XX:CMSInitiatingOccupanyFraction</strong>：堆内存使用率达到该阈值会触发垃圾回收。JDK5及之前版本默认值为68，即堆内存使用率达到68%时触发一次垃圾回收。JDK6及之后版本默认值为92。<li><strong>-XX:+UseCMSInitiatingOccupancyOnly</strong>： 只使用设定的回收阈值(-XX:CMSInitiatingOccupanyFraction值)。如果不开启该功能，则JVM仅在第一次使用设定值，后续会自动调整；<li><strong>-XX:+UseCMSCompactAtFullCollection</strong>：执行完Full GC后是否对内存进行压缩，压缩可避免内存碎片但停顿时间会更长。<li><strong>-XX:CMSFullGCsBeforeCompaction</strong>：执行多少次Full GC后对内存进行压缩。<li><strong>-XX:ParallelCMSThreads</strong>：CMS线程数量。默认线程数量为**(ParallelGCThreads + 3) / 4**，</ul><h4 id=1-8-6-6、扩展><a class=headerlink href=#1-8-6-6、扩展 title=1.8.6.6、扩展></a>1.8.6.6、扩展</h4><h5 id=Card-Table><a title="Card Table" class=headerlink href=#Card-Table></a>Card Table</h5><p><strong>Card Table是一种用于辅助处理跨代垃圾回收的数据结构。它的作用是跟踪对象引用在堆内存中的位置变化，以便准确的标记和回收垃圾对象。</strong><p>Java堆内存通常被划分为多个连续的内存块，称之为卡片（Card）。每个卡片的大小通常为512字节或更小。Java堆中的每个对象引用都被映射到一个或多个卡片上。<p>Card Table通过位图（Bitmap）来表示堆内存的卡片状态。这个位图的每个位对应一个卡片，用于标记卡片上的引用是否发生变化。位图通常被分为两个部分，一个称为“dirty card”位图，用于标记引用变为非空；另一个称为“clean card”位图，用于标记引用变为空。<p>对象引用发生变化时，对应的卡片状态会发生改变。GC进行垃圾回收时会先扫描“dirty card”位图，找到与该位图相关的对象并对之进行检查，确保其准确性。<p>Card Table提供了一种增量标记的方式，即只对发生变化的卡片进行标记和处理，减少垃圾回收停顿时间，提供吞吐量。<p>Card Table只是垃圾回收机制的一部分，它与其它组件合作来实现高效垃圾回收。Card Table的实现会因不同的垃圾回收器而有所差异。<h5 id=Rememvered-Set><a title="Rememvered Set" class=headerlink href=#Rememvered-Set></a>Rememvered Set</h5><p>Remembered Set是一种用于<strong>跟踪堆内存中对象应用的数据结构。与Card Table一起工作，帮助其准确地标记和回收垃圾对象</strong>。<p>Remembered Set的主要作用是<em><strong>记录老年代中对象对年轻代中对象的引用关系</strong></em>。<p>Remembered Set使用一种特殊的数据结构，通常是一个位图，或其它类似位图的结构。位图的每个位对应一个引用，用于标记引用是否存在。当对象引用发生变化时，对响应的位进行标记或清除。<p>Card Table会标记发生变化的卡片，而 Remembered Set会根据这些卡片信息来确定哪些引用需要被记录下来。<p>垃圾回收器执行垃圾回收时会先扫描Remembered Set中标记的引用，垃圾回收器会根据这些引用关系进行标记和处理，确保引用链的完整性和准确性。<h5 id=CMS中的使用><a class=headerlink href=#CMS中的使用 title=CMS中的使用></a>CMS中的使用</h5><p>Card Table 在 CMS GC 中也有使用，使用一块区域用来记录老年代中的每个 Card 指向新生代的引用（<code>points-out</code> 结构），YGC执行时会将该区域的对象作为 GC roots，而不需要扫描整个老年代。<p>并发标记时，如果某个对象的引用发生了变化，那么标记该对象所在的 Card 为 Dirty Card（通过 write-barrier）。在重新标记时，只需要重新扫描 Dirty Cards 即可，同时【清除 Dirty 标记】。<h3 id=1-8-7、G1（JDK7）><a class=headerlink href=#1-8-7、G1（JDK7） title=1.8.7、G1（JDK7）></a>1.8.7、G1（JDK7）</h3><h4 id=1-8-7-1、简介><a class=headerlink href=#1-8-7-1、简介 title=1.8.7.1、简介></a>1.8.7.1、简介</h4><p><strong>JDK 1.7u4中引入G1，JDK9中G1成为默认垃圾收集器，JDK12中增强了G1</strong>。<p><strong>G1是一款服务器式垃圾回收器，适用于大内存多处理器的服务器。可尽可能满足设定的垃圾回收暂定目标，同时提高吞吐量。</strong><p>如果你的应用程序符合以下几点，那么使用G1将变得非常合适：<ul><li>超过50%的堆内存被实时数据占用。<li>对象分配率和晋升率有很大差异。</ul><p>G1有如下特点：<ol><li><strong>并发收集；</strong><li><strong>压缩空闲空间不会延长GC暂停时间</strong>；<li><strong>更易预测的GC暂停时间</strong>；<li><strong>适用于 低吞吐量 场景</strong>；</ol><h4 id=1-8-7-2、Region><a class=headerlink href=#1-8-7-2、Region title=1.8.7.2、Region></a>1.8.7.2、Region</h4><p><strong>G1 会把整个 Java 堆划分为不超过2048个大小独立的Region，每个 Region 大小要满足2的N次幂，范围在1MB-32MB 之间</strong>。Region的大小在 JVM 生命周期内不会被改变。<p>每一个Region在逻辑上属于某一个分代，该分代分为四种：<ol><li><strong>Eden区存放新对象</strong>；<li><strong>Survivor区放存活对象</strong>；<li><strong>old区存放老对象</strong>；<li><strong>Humongoous区存放大对象</strong>；（G1中通常会将H区作为老年代的一部分来看待。）</ol><blockquote><p>G1内存区域不是固定的E或O。G1新老年代比例动态变化无需显式指定，因为G1有预测停顿时间的基准。G1会跟踪每一次STW，据此动态设置各个Regin的大小。<p>一个对象大小超过了1个Region的一半则称该对象为大对象。如果一个H区无法容纳一个大对象，那么会使用连续的H区来存储这个大对象。为了能找到连续的H区，有时不得不执行Full GC。G1不会复制巨型对象，巨型对象没有被引用时会在YGC阶段被回收。</blockquote><h4 id=1-8-7-3、重要概念><a class=headerlink href=#1-8-7-3、重要概念 title=1.8.7.3、重要概念></a>1.8.7.3、重要概念</h4><h5 id=RSet><a class=headerlink href=#RSet title=RSet></a>RSet</h5><p><strong>RSet是Remembered Set的缩写，意为记录集合。G1中的每个Region都有一个RSet，它是一个hash表（表中存储card table），记录了其它Region中的对象对本Region中对象的引用</strong>。<p>**RSet大小和Region数量有直接关系，一般来说 RSet 的大小占整个 Java 堆空间的1%~20%**。<blockquote><p>每次引用类型数据写操作时，会产生一个写屏障来中断当前操作。然后检查要写入的引用指向的对象与当前引用类型是否在不同的Regin中，如果确实在不同的Region，那么通过CardTable把相关引用信息记录到引用所指对象所在的Regin的RSet中。</blockquote><p><strong>G1中RSet使用的是point-in机制，而CMS使用的是point-out机制</strong>。<blockquote><p>point-in是指：哪些分区引用了当前分区中的对象，则仅仅将这些对象当做根来扫描就避免了无效的扫描。</blockquote><p>对于G1来说，当引用发生变化时赋值器会对引用做处理，引用较多时赋值器开销会很大，为解决开销大问题，G1 中又引入了卡表（Card Table）。<blockquote><p>当 Region 被引用较多时，RSet 占用空间会上升，因此为RSet 的存储划分了三种粒度：<ul><li>稀疏表（Sparse）：直接通过哈希表来存储，key 是 region index，value 是 card 数组（记录 card index）。<li>细粒度（Fine）：当一个 region 的 card 数量超过阈值时，退化为一个 bitmap，每一位对应一个card（index）。如果bit为0表示该bit对应的内存分段中没有引用，为1表示有引用。<li>粗粒度（Coarse）：当引用 region 数量超过阈值时，退化为只记录 regin 引用，由 bitmap 存储，每一位对应一个 region（index）。</ul><p>因为某些Region中的对象可能会被其它许多对象引用，为避免保存太多数据，故会以更大粒度保存引用，这种方式会减少RS数据，但会增加扫描和标记开销，因为需要扫描所有bit为1的内存分段中的对象以确定具体是来自哪个对象的引用。</blockquote><h5 id=Card-Table-1><a title="Card Table" class=headerlink href=#Card-Table-1></a>Card Table</h5><p>Card Table会将一个分区在逻辑上划分为多个固定大小的连续区域，每个区域称之为卡。卡通常较小，介于128到512字节之间，堆中每 512byte 映射 card table 1 byte。Card Table通常为字节数组，数组的索引（即数组下标）会用来标识每个卡的空间地址。当一个卡被引用时，该卡对应数组索引下的值会被标记为0，即标记为脏被引用，RSet会将该下标记录下来。<strong>RSet一般是一个Hash Table，Key是其它Region的起始地址，Value是一个集合，集合中存储的是Card Table的Index。</strong><blockquote><p>JVM会对程序中的每一个引用赋值语句进行记录和处理，把引用关系更新到RS中。RS更新并非实时性，RS处理需要线程同步，开销会很大，所以为了性能需要，G1维护了一个Dirty Card Queue。对于引用赋值语句，JVM会在之前和之后执行特殊操作以在dirty card queue中加入一个保存了对象引用信息的card。YGC时G1会对Dirty Card Queue中所有的card进行处理并更新RS，以保证RS实时准确的反映引用关系。</blockquote><h5 id=CSet><a class=headerlink href=#CSet title=CSet></a>CSet</h5><p><strong>CSet意为回收集合，记录了需要回收的内存区域。</strong><p><strong>一个CSet 中包含多少 Region 取决于有多少空间可以被释放、G1停顿目标时间这两个因素。</strong>G1只关注是否有存活对象，如果没有，则无论你属于老年代，还是年轻代，你都会被回收井放入可用 Region 队列，下一次被分配到哪里是无法确定的。<p>CSet 包含了大量Region ，每个Region中有一个RSet。<h5 id=TLAB><a class=headerlink href=#TLAB title=TLAB></a>TLAB</h5><p><strong>TLAB是Thread Local Allocation Buffer的首字母，意为 线程本地分配缓冲。</strong><p>堆内存是线程共享的，多个线程分配内存时需要加锁同步。为了避免加锁，提高性能，每一个线程会被分配一个私有TLAB。TLAB中的内存来自于G1年轻代中的内存分段。当对象是Humongous对象，TLAB也能装下的时候，对象会被优先分配在线程的TLAB中。因为TLAB属于线程，不需要加锁，效率高。<h5 id=PLAB><a class=headerlink href=#PLAB title=PLAB></a>PLAB</h5><p><strong>PLAB是Promotion Local Allocation Buffer的首字母，意为晋升本地分配缓冲。</strong><p>G1是多线程并发回收，为避免多线程将对象向同一个内存分段拷贝，那么复制过程也需加锁。为避免加锁，G1的每个线程都关联一个PLAB，这样就不需要进行加锁了。<p>多线程环境下最好使用<code>-XX:-ResizePLAB</code>来关闭PLAB大小的自动调整功能，避免大量线程通信导致的性能下降。<h5 id=SATB><a class=headerlink href=#SATB title=SATB></a>SATB</h5><p><strong>SATB是Snapshot At The Beginning的首字母，意为开始时快照。</strong><h4 id=1-8-7-4、GC回收过程><a class=headerlink href=#1-8-7-4、GC回收过程 title=1.8.7.4、GC回收过程></a>1.8.7.4、GC回收过程</h4><p>G1垃圾回收过程图示如下：<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-1.1-G1-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B.png><h5 id=YGC阶段（标记复制-STW）><a title="YGC阶段（标记复制 / STW）" class=headerlink href=#YGC阶段（标记复制-STW）></a>YGC阶段（标记复制 / STW）</h5><p>对象被创建后首先放到Eden区，<strong>当所有Eden区都满了，G1会启动一次年轻代垃圾回收</strong>：首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），将要被回收的内存放到回收集中，然后执行回收操作。<p><font color=red>注意</font>：YGC只会回收Eden区和Survivor区。回收集是指需要被回收的内存分段的集合，年轻代回收集 包含年轻代Eden区和Survivor区所有的内存分段。<p>年轻代回收过程如下：<ol><li>根扫描：根指的是静态变量指向的对象，正在执行的方法链条上的局部变量等。根引用和RSet记录的外部引用将作为扫描存活对象的入口。<li>更新RS：处理Dirty Card队列，更新RS。（RS可以反映老年代中的对象对年轻代对象的引用）<li>处理RS：识别老年代对象对Eden区中对象的引用，被指向的Eden区对象都被认为是存活对象。<li>对象拷贝：将Eden中的存活对象复制到survivor中，Survivor中存活对象年龄未达阈值则将年龄加1，达到阈值则复制到老年代中。如果Survivor空间不足，Eden中部分数据会直接晋升至老年代。<li>处理引用：处理软引用，弱引用，虚引用、Final等引用。最终Eden中空间为空，GC停止，目标内存中对象连续，没有内存碎片，所以复制过程可以达到整理内存的效果。</ol><h5 id=并发标记><a class=headerlink href=#并发标记 title=并发标记></a>并发标记</h5><p><strong>年轻代回收后或 houmongous对象 分配后会检测当前堆内存使用情况，当堆内存（包括老年代和新生代）使用率达到参数<code>-XX:InitiatingHeapOccupancyPercent</code>（默认是45%）设置的百分比时会触发老年代回收。</strong><p><strong>老年代回收包含标记老年代内对象是否存活的过程，标记过程和应用程序并发运行（不需要Stop-The-World）</strong>，所以应用程序会改变指针指向，进而导致对象丢失。<strong>G1处理对象丢失的方法是使用 开始时快照技术（SATB，Snapshot At The Begging）</strong>，这种技术会造成某些垃圾对象也被当做是存活对象，所以G1会使得占用的内存比实际需要的内存大。<p>并发标记过程如下：<ol><li><p>初始标记（STW）：标记从根节点直接可达的对象。该阶段存在STW，且会触发一次YGC。</p><li><p>根区域扫描：扫描Survivor区直接可达的老年代对象，并标记被引用的对象。该过程必须在YGC之前完成。</p><li><p>并发标记：在整个堆中进行并发标记（可与应用程序并发执行），该过程可能被YGC中断。并发标记阶段，若区域中的对象都是垃圾，那么这个区域会被立即回收。同时，会计算每个区域对象的活性（区域中存活对象的比例）。</p><li><p>再次标记（STW）：由于并发标记阶段是GC和应用程序同时执行，可能存在漏标情况，所以需要执行STW式的再次标记。G1中采用了SATB（开始时快照技术）算法。</p><li><p>独占清除（STW）：计算各个区域存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。该阶段不会做垃圾收集。</p><li><p>并发清理：识别并清理完全空闲的区域。</p></ol><h5 id=混合回收（Mixed-GC）><a title="混合回收（Mixed GC）" class=headerlink href=#混合回收（Mixed-GC）></a>混合回收（Mixed GC）</h5><p><strong>越来越多的对象晋升到老年代Regin后，为避免堆内存被耗尽，会触发一次混合回收（Mixed GC）。</strong>该算法并非是Old GC，除了回收整个年轻代Regin，还会回收一部分老年代Regin。选择收集不同的老年代Regin（并发标记阶段中的独占清理阶段已经排序过了），可以一定程度上控制垃圾回收的消耗时间。<p><strong>并发标记结束以后，老年代中百分百为垃圾的内存被回收了，部分为垃圾的内存也计算了出来。</strong><ul><li>-XX:G1MixedGCCountTarget：该参数表示 老年代内存分段会分多少次来回收，默认8次。<li>-XX:G1MixedGCLiveThresholdPercent：表示垃圾占内存分段比例要达到该参数值设定的百分比时才会被回收，默认为65%。垃圾占内存分段比例越高的，越优先被回收。老年代、Eden、Survivor from区中要被回收的内存分段合起来称为Collection Set，也即 回收集合。混合回收回收集（Collection Set）包括八分之一的老年代内存分段、Eden区内存分段、Survivor区内存分段，下次mixed GC 的evacuation阶段会把他们都一并清理。混合回收的算法和年轻代完全一样，只是回收集多了老年代的内存分段。混合回收并不一定要进行8次。具体执行逻辑与参数-XX:G1HeapWastePercent有关，详情如下。<li>-XX:G1HeapWastePercent：默认为10%，表示允许浪费整个堆内存10%的空间。也就是说 若垃圾占堆内存的比例低于10%，就不再执行混合回收，因为性价比很低。</ul><p><font color=red>注意：Mixed GC 并不是 Full GC。G1 GC回收足够数量的老年代区域 (通过多次混合回收) 后，G1将恢复到年轻代回收、全局并发标记、混合回收，以此逻辑循环执行。</font><h5 id=FGC><a class=headerlink href=#FGC title=FGC></a>FGC</h5><p>G1初衷是避免Full GC出现，但如果上述方式不能正常工作时会停止应用程序，使用单线程Serial收集器来完成垃圾清理工作，性能会非常差。<p>导致Full GC的原因有两个：<ul><li><em><strong>Evacuation时没有足够的to-space来存放晋升对象</strong></em>。<li><em><strong>并发处理过程完成之前空间耗尽</strong></em>。</ul><h4 id=1-8-7-5、三色标记算法><a class=headerlink href=#1-8-7-5、三色标记算法 title=1.8.7.5、三色标记算法></a>1.8.7.5、三色标记算法</h4><p>并发标记使用的是三色标记算法。它是描述追踪式回收器的一种有效方法，利用它可以推演回收器的正确性。 三色标记会将对象分成三种类型：<ul><li><strong>黑色</strong>：根对象，或者该对象与它的子对象都被扫描过。<li><strong>灰色</strong>：对象本身已被扫描过，但该对象的子对象还没有扫描。<li><strong>白色</strong>：未扫描过的对象，扫描完所有对象之后，最终为白色的就是不可达对象，即为垃圾对象。</ul><h4 id=1-8-7-8、G1优化><a class=headerlink href=#1-8-7-8、G1优化 title=1.8.7.8、G1优化></a>1.8.7.8、G1优化</h4><p>优化和注意事项分析如下：<ul><li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小。固定年轻代大小会覆盖暂停时间目标。<li>评估G1 GC吞吐量时，暂停时间目标不需要太严格，否则会直接影响吞吐量。</ul><h4 id=1-8-7-9、参数><a class=headerlink href=#1-8-7-9、参数 title=1.8.7.9、参数></a>1.8.7.9、参数</h4><ul><li>-XX:+UseG1GC：使用G1垃圾回收器。<li>-XX:G1HeapRegionSize：每个Region的大小。值是2的幂，范围1m~32m之间。目标是根据最小Java堆大小划分处约2048个区域，默认是堆内存的1/2000。<li>-XX:MaxGCPauseMillis：最大GC停顿时间指标。默认200ms。<li>-XX:ParallelGCThread：STW工作线程的数量，最多8个。<li>-XX:ConcGCThreads：并发标记的线程数量。建议该值为并行垃圾回收线程数量(ParallelGCThreads)的1/4左右。<li>-XX:InitiatingHeapOccupancyPercent：触发并发GC周期的堆占用率阈值。默认是45。</ul><h3 id=1-8-8、ZGC-（JDK11）><a title="1.8.8、ZGC （JDK11）" class=headerlink href=#1-8-8、ZGC-（JDK11）></a>1.8.8、ZGC （JDK11）</h3><h4 id=1-8-8-1、简介><a class=headerlink href=#1-8-8-1、简介 title=1.8.8.1、简介></a>1.8.8.1、简介</h4><p><strong>ZGC是JDK11中 新加入的 具有实验性质的低延迟垃圾收集器，目前仅支持Linux/x86-64。ZGC收集器是一款基于Region内存布局，（暂时）不设分代，使用读屏障、染色指针和内存多重映射等技术来实现可并发的标记整理算法，首要目标是实现低延迟。</strong><blockquote><p>JDK11中引入ZGC，JDK13中增强ZGC。</blockquote><h4 id=1-8-8-2、内存布局><a class=headerlink href=#1-8-8-2、内存布局 title=1.8.8.2、内存布局></a>1.8.8.2、内存布局</h4><p>与Shenandoah和G1一样，ZGC也采取基于Region的堆内存布局，但是ZGC的Region具有动态性（动态的创建和销毁，以及动态的区域容量大小）。<p>ZGC的Region可以分为三类：<ul><li><font color=orange>小型Region</font>：容量固定为2MB，用于放置小于256KB的小对象。<li><font color=orange>中型Region</font>：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。<li><font color=orange>大型Region</font>：容量不固定，可以动态变化，但必须为2MB的整数倍，用于存放4MB或以上的大对象。并且每个大型Region只会存放一个对象。</ul><h4 id=1-8-8-3、染色指针><a class=headerlink href=#1-8-8-3、染色指针 title=1.8.8.3、染色指针></a>1.8.8.3、染色指针</h4><h5 id=简介-6><a class=headerlink href=#简介-6 title=简介></a>简介</h5><p>HotSpot的垃圾收集器，有几种不同的标记实现方案。<ul><li>把标记直接记录在对象头上（Serial 收集器）。<li>把标记记录在于对象相互独立的数据结构上（G1、Shenandoah使用了一种相当于堆内存的1/64大小的BitMap结构来记录标记信息）。<li>ZGC染色指针直接把标记信息记录到引用对象的指针上。</ul><p>染色指针是一种直接<strong>将少量额外信息存储在指针上的技术</strong>。目前Linux下64位指针的高18位不能用来寻址，但剩余的46位指针所能支持的4TB内存仍然可以满足需要。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/ZGC%E9%A2%9C%E8%89%B2%E6%8C%87%E9%92%8801.png><p>ZGC将使用剩下46位的高4位来存储四个标志信息：<ol><li>Finalizable：是否只能通过finalize()方法才能被访问到。<li>Remapped：是否进入了重分配集。<li>Marked0：通过这些标志虚拟机就可以直接从指针中看到引用对象的三色标记状态。<li>Marked1：同3。</ol><p><font color=red>注意：由于这些标志位占用4位，故剩余42位空间（4TB），所以ZGC能够管理的内存不能超过4TB。</font><h5 id=特点><a class=headerlink href=#特点 title=特点></a>特点</h5><ul><li>染色指针可以使得一旦某个Region的存活对象被移走之后，该Region会立即被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。<li>染色指针可以减少在垃圾收集过程中内存屏障的使用数量。因为读、写内存屏障的主要目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。<li>染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</ul><h4 id=1-8-8-4、读屏障><a class=headerlink href=#1-8-8-4、读屏障 title=1.8.8.4、读屏障></a>1.8.8.4、读屏障</h4><p><strong>当从堆中加载对象时，就会使用读屏障（Load Barrier）</strong>。读屏障的主要作用就是<strong>检查指针上的三色标记位，根据标记位判断出对象是否被移动过，如果没有则可以直接访问，如果移动过就需要进行“自愈”</strong>。自愈会使对象访问变慢，但“自愈”完成后访问就不会变慢了。<blockquote><p>当读取处于重分配集的对象时，会被读屏障拦截，通过 转发表记录 将访问转发到新复制对象上，并同时修正更新该引用的值，使其直接指向新对象。ZGC将这种行为叫做指针的“自愈能力”。</blockquote><h4 id=1-8-8-5、内存多重映射><a class=headerlink href=#1-8-8-5、内存多重映射 title=1.8.8.5、内存多重映射></a>1.8.8.5、内存多重映射</h4><h5 id=简介-7><a class=headerlink href=#简介-7 title=简介></a>简介</h5><p>Linux/x86-64平台上ZGC使用了多重映射（Multi-Mapping）将多个不同的虚拟内存地址映射到同一物理内存地址上，这是一种多对一映射，意味着ZGC在虚拟内存中看到的地址空间要比实际的堆内存容量更大。把染色指针中的标志位看作是地址的分段符，那只要将这些不同的地址段都映射到同一物理内存空间，经过多重映射转换后，就可以使用染色指针进行正常寻址。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/ZGC%E5%86%85%E5%AD%98%E5%A4%9A%E9%87%8D%E6%98%A0%E5%B0%8401.png><h4 id=1-8-8-6、ZGC工作过程><a class=headerlink href=#1-8-8-6、ZGC工作过程 title=1.8.8.6、ZGC工作过程></a>1.8.8.6、ZGC工作过程</h4><p>ZGC工作过程大致可划分为以下四个阶段。四个阶段都可以并发执行，仅是两个阶段中间会存在短暂的小阶段停顿。<p><img alt=ZGC运行过程 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/ZGC%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B01><ol><li><font color=orange>并发标记（Concurrent Mark）</font>：与G1、Shenandoah一样，并发标记是遍历对象图做可达性分析的阶段，前后也要经过类似于G1、Shenandoah的初始标记、最终标记的短暂停顿，而且这些停顿阶段所做的事情在目标上也是类似的。<li><font color=orange>并发预备重分配（ Concurrent Prepare for Relocate）</font>：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，将这些Region组成重分配集（Relocation Set）。<li><font color=orange>并发重分配（Concurrent Relocate）</font>：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table）,记录从旧对象到新对象的转向关系。<li><font color=orange>并发重映射（Concurrent Remap）</font>：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用，ZGC的并发映射并不是以一个必须要“迫切”去完成的任务。ZGC很巧妙地把并发重映射阶段要做的工作，合并到下一次垃圾收集循环中的并发标记阶段里去完成，反正他们都是要遍历所有对象的，这样合并节省了一次遍历的开销。</ol><h4 id=1-8-8-7、ZGC优缺点><a class=headerlink href=#1-8-8-7、ZGC优缺点 title=1.8.8.7、ZGC优缺点></a>1.8.8.7、ZGC优缺点</h4><h5 id=优点（高吞吐量、低延迟）><a class=headerlink href=#优点（高吞吐量、低延迟） title=优点（高吞吐量、低延迟）></a>优点（高吞吐量、低延迟）</h5><p>ZGC是支持<code>NUMA-Aware</code>的内存分配。MUMA（Non-Uniform Memory Access，非统一内存访问架构）是一种多处理器或多核处理器计算机所设计的内存架构。<p>现在多CPU插槽的服务器都是Numa架构，比如两颗CPU插槽(24核)，64G内存的服务器，那一颗CPU 12个核，访问从属于它的32G本地内存，要比访问另外32G远端内存要快得多。<p>ZGC默认支持NUMA架构，在创建对象时，根据当前线程在哪个CPU执行，优先在靠近这个CPU的内存进行分配，这样可以显著的提高性能，在SPEC JBB 2005 基准测试里获得40%的提升。<h5 id=缺点（浮动垃圾）><a class=headerlink href=#缺点（浮动垃圾） title=缺点（浮动垃圾）></a>缺点（浮动垃圾）</h5><p>当ZGC准备要对一个很大的堆做一次完整的并发收集，则全过程要持续十分钟以上，由于应用的对象分配速率很高，将创造大量的新对象，这些新对象很难进入当次收集的标记范围，通常就只能全部作为存活对象来看待（尽管其中绝大部分对象都是朝生夕灭），这就产生了大量的浮动垃圾。<p>目前唯一的办法就是尽可能地去增加堆容量大小，获取更多喘息的时间。但若要从根本上解决，还是需要引入分代收集，让新生对象都在一个专门的区域中创建，然后针对这个区域进行更频繁、更快的收集。<h3 id=1-8-9、Epsilon（JDK11）><a class=headerlink href=#1-8-9、Epsilon（JDK11） title=1.8.9、Epsilon（JDK11）></a>1.8.9、Epsilon（JDK11）</h3><h4 id=1-8-9-1、简介><a class=headerlink href=#1-8-9-1、简介 title=1.8.9.1、简介></a>1.8.9.1、简介</h4><p>JDK 11中的JEP 318添加了一个名为Epsilon的垃圾回收器。Epsilon（A No-Op Garbage Collector）只负责分配内存不做任何垃圾回收操作。当堆内存空闲空间不足时会自动触发与<code>OutOfMemoryError</code>相关的处理。<h4 id=1-8-9-2、目标><a class=headerlink href=#1-8-9-2、目标 title=1.8.9.2、目标></a>1.8.9.2、目标</h4><p>Epsilon回收器设计目的或初衷：<ol><li>性能测试：测试应用在没有GC干预情况下的性能。<li>短生命周期应用：对于生命周期较短的应用，没有垃圾回收也是可以接收的。<li>内存管理：自己来管理内存。</ol><h4 id=1-8-9-3、使用场景><a class=headerlink href=#1-8-9-3、使用场景 title=1.8.9.3、使用场景></a>1.8.9.3、使用场景</h4><ul><li>Performance testing：什么都不执行的GC非常适合用于差异性分析。no-op GC可以用于过滤掉GC诱发的新能损耗，比如GC线程的调度，GC屏障的消耗，GC周期的不合适触发，内存位置变化等。此外有些延迟者不是由于GC引起的，比如scheduling hiccups, compiler transition hiccups，所以去除GC引发的延迟有助于统计这些延迟。<li>Memory pressure testing：在测试java代码时，确定分配内存的阈值有助于设置内存压力常量值。这时no-op就很有用，它可以简单地接受一个分配的内存分配上限，当内存超限时就失败。例如：测试需要分配小于1G的内存，就使用-Xmx1g参数来配置no-op GC，然后当内存耗尽的时候就直接crash。<li>VM interface testing：以VM开发视角，有一个简单的GC实现，有助于理解VM-GC的最小接口实现。它也用于证明VM-GC接口的健全性。<li>Extremely short lived jobs： 一个短声明周期的工作可能会依赖快速退出来释放资源，这个时候接收GC周期来清理heap其实是在浪费时间，因为heap会在退出时清理。并且GC周期可能会占用一会时间，因为它依赖heap上的数据量。<li>Last-drop latency improvements：对那些极端延迟敏感的应用，开发者十分清楚内存占用，或者是几乎没有垃圾回收的应用，此时耗时较长的GC周期将会是一件坏事。<li>Last-drop throughput improvements：即便对那些无需内存分配的工作，选择一个GC意味着选择了一系列的GC屏障，所有的OpenJDK GC都是分代的，所以他们至少会有一个写屏障。避免这些屏障可以带来一点点的吞吐量提升。</ul><h4 id=1-8-9-4、相关描述><a class=headerlink href=#1-8-9-4、相关描述 title=1.8.9.4、相关描述></a>1.8.9.4、相关描述</h4><p>通过参数<code>-XX:+UseEpsilonGC</code>可以开启Epsilon GC。<p>Epsilon GC通过在分配内存的单个连续块中实现线性分配来工作。这样就可以在GC中轻松实现无锁TLAB（线程本地分配缓冲区）发行代码，然后可以重用现有VM代码处理的无锁TLAB内部分配。发出TLAB还有助于使驻留内存占用的进程受实际分配的内存限制。大量/超出TLAB的分配由同一代码处理，因为在此方案中分配TLAB与分配大对象之间几乎没有区别。<p>Epsilon使用的障碍集完全为空/无操作，因为GC不执行任何GC循环，因此不关心对象图，对象标记，对象复制等。引入一种新的障碍集实现是可能是此实现中最具破坏性的JVM更改。<p>由于Epsilon的运行时接口的唯一重要部分是发布TLAB的时间，因此其延迟很大程度上取决于所发布的TLAB的大小。对于任意大的TLAB和任意大的堆，延迟开销可以由任意低的正值（因此称为名称）来描述。（替代起源故事：“ epsilon”通常表示“空符号”，与该GC的禁止操作性保持一致）。<p>Java堆耗尽就不可能进行分配，也不能进行内存回收。此时有几种选择：<ul><li>抛出一条带有描述性信息的<code>OutOfMemoryError</code>异常消息。<li>执行堆转储（启用<code>-XX:+HeapDumpOnOutOfMemoryError</code>）<li>关闭JVM，并有选择地执行外部操作（通常操作<code>-XX:OnOutOfMemoryError=...</code>），例如，启动调试器或向外部监视系统通知该失败。</ul><h3 id=1-8-10、Shenandoah><a class=headerlink href=#1-8-10、Shenandoah title=1.8.10、Shenandoah></a>1.8.10、Shenandoah</h3><p>待补充。<h3 id=1-8-11、总结><a class=headerlink href=#1-8-11、总结 title=1.8.11、总结></a>1.8.11、总结</h3><h4 id=1-8-11-1、垃圾收集器对比><a class=headerlink href=#1-8-11-1、垃圾收集器对比 title=1.8.11.1、垃圾收集器对比></a>1.8.11.1、垃圾收集器对比</h4><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-1.2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93.png><p><img alt=image-20210315120311771 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210315120311771.png><h4 id=1-8-11-2、ZGC-vs-Shenandoah><a title="1.8.11.2、ZGC vs Shenandoah" class=headerlink href=#1-8-11-2、ZGC-vs-Shenandoah></a>1.8.11.2、ZGC vs Shenandoah</h4><p>前者用的是三色标记，后者用的是染色指针。<h4 id=1-8-11-3、三色标记-颜色指针><a title="1.8.11.3、三色标记 / 颜色指针" class=headerlink href=#1-8-11-3、三色标记-颜色指针></a>1.8.11.3、三色标记 / 颜色指针</h4><ul><li><p><strong>三色标记</strong>：把对象分为三个颜色，不同的颜色代表是否被标记过，还是标记了一半，还是没有标记。</p><li><p><strong>染色指针</strong>：染色指针是一种直接将少量额外信息存储到指针上的技术。目前Linux下64位指针的高18位不能用来寻址，但剩余的46位指针所能支持的4TB内存仍然可以满足需要。故，拿出剩下的46位中高4位来记录不同的状态信息。</p></ul><h4 id=1-8-11-4、Remark阶段的算法><a class=headerlink href=#1-8-11-4、Remark阶段的算法 title=1.8.11.4、Remark阶段的算法></a>1.8.11.4、Remark阶段的算法</h4><p>CMS和G1中用的是同一个算法，该算法叫三色标记：<ol><li><strong>黑</strong>：自己和所引用的对象都标记完了。<li><strong>灰</strong>：自己标记完了，但所引用的其它对象还没有标记。<li><strong>白</strong>：自己和引用的对象都还没有标记。</ol><h2 id=1-9、漏标问题><a class=headerlink href=#1-9、漏标问题 title=1.9、漏标问题></a>1.9、漏标问题</h2><h3 id=1-9-1、认识漏标><a class=headerlink href=#1-9-1、认识漏标 title=1.9.1、认识漏标></a>1.9.1、认识漏标</h3><p>CMS和G1的核心就是并发标记的线程和工作线程同时进行，而该阶段会产生“漏标”问题。<p>问题：<strong>GC标记阶段中如果删除了所有灰色到白色的引用，且黑色指向了白色，则此时若不对黑色对象的子对象进行重新扫描，就会出现漏标现象，会把白色对象当作垃圾被回收</strong>。<h3 id=1-9-2、解决漏标><a class=headerlink href=#1-9-2、解决漏标 title=1.9.2、解决漏标></a>1.9.2、解决漏标</h3><p><strong>（1）增量更新（Increment Update）</strong><p><img alt=image-20210314213906184 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210314213906184.png><p>如上图所示，若A指向D时，跟踪这个引用，并把A标记为灰色，下次扫描时就会重新扫描A的子对象D，这就叫做增量更新。<p>特点：<strong>当产生新标记后，关注引用的增加，CMS采用 增量更新+写屏障 解决了漏标问题</strong>。<p><strong>（2）SATB（snapshot at the beginning）</strong><p><img alt=image-20210314214048813 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210314214048813.png><p>如上图所示，刚开始做一个快照，当B和D之间的引用消失时要把这个引用推到GC的堆栈，保证D能够被扫描到。如果某一个引用消失了，我会把白色对象放到GC堆栈中，下次扫描时直接扫描白色对象即可，这样白色就不会漏标了。<p>SATB有三个工作步骤：<ol><li>在开始标记时生成一个快照图，用来标记存活对象。<li>在并发标记时所有被改变的对象将会被加入到队列（在write barrier里把所有旧的引用所指向的对象都变成非白的）。<li>可能存在游离垃圾，将在下次被收集。</ol><p>特点：<strong>当引用被删除后，关注引用的删除，G1用 SATB+写屏障 解决了漏标问题</strong>。<blockquote><p>SATB 算法通过创建一个对象图的方式完成堆内存逻辑上的快照，即将堆内存里所有需要回收的对象全部呈现在它的这张对象图上，这个标记过程在并行标记阶段完成 。<p>SATB 算法维护的标记内容在数据结构上也分为两块， 一块是已经完成的标记，另一块是即将进行的标记。</blockquote><h3 id=1-9-3、总结><a class=headerlink href=#1-9-3、总结 title=1.9.3、总结></a>1.9.3、总结</h3><p>灰色指向白色的引用消失时，如果没有黑色指向白色，则该引用会直接被push到堆栈，下次扫描时拿到这个引用，由于RSet的存在，不需要扫描整个堆去查找指向白色的引用，效率比较高。SATB配合RSet浑然天成。<blockquote><p>G1为什么使用SATB，而不使用incremental update？因为变成灰色后还要重新扫描，效率太低了。</blockquote><h1 id=2、JVM参数><a class=headerlink href=#2、JVM参数 title=2、JVM参数></a>2、JVM参数</h1><h2 id=2-1、简介><a class=headerlink href=#2-1、简介 title=2.1、简介></a>2.1、简介</h2><h3 id=2-1-1、参数分类><a class=headerlink href=#2-1-1、参数分类 title=2.1.1、参数分类></a>2.1.1、参数分类</h3><ul><li><p><strong>-开头</strong>：标准类型，所有HotSpot都支持。</p><li><p><strong>-X开头</strong>：非标准类型，特定版本才支持。</p><li><p><strong>-XX开头</strong>：不稳定，下个版本可能取消。</p> <ol><li><p><strong>Boolean类型参数</strong></p> <p>-XX:+/- 某个属性值（+表示开启，-表示关闭）。</p><li><p><strong>K-V类型参数</strong></p> <p>-XX: key（属性）= value（属性值）</p><li><p><strong>jinfo查看当前运行时配置项</strong></p> <p>jinfo -flag 配置项 进程号</p></ol></ul><blockquote><p>如何解释-Xms和-Xmx参数属于-XX参数？<p>-Xms = -XX:InitialHeapSize / -Xmx = -XX:MaxHeapSize</blockquote><h3 id=2-1-2、查看参数值><a class=headerlink href=#2-1-2、查看参数值 title=2.1.2、查看参数值></a>2.1.2、查看参数值</h3><h4 id=查看方式><a class=headerlink href=#查看方式 title=查看方式></a>查看方式</h4><ol><li><p>查看java进程相关参数</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>jinfo -flag 参数项 进程号</span><br><span class=line>jinfo -flags 进程号</span><br></pre></table></figure><li><p>查看默认值和最终值</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>java -XX:+PrintFlagsInitial   <span class=comment># 查看jvm未更改的默认参数</span></span><br><span class=line>java -XX:+PrintFlagsFinal     <span class=comment># 查看jvm已经更改过的参数</span></span><br></pre></table></figure> <p>也可以在运行java命令的同时加入打印jvm参数，如：<code>java -XX:+PrintFlagsFinal UpdateJVMParamDemo</code></p> <p><font color=red>注意：<code>:=</code>表示jvm启动时修改过的参数。<code>=</code>表示jvm没有更改过的默认参数。</font></p><li><p>打印命令行参数</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -XX:+PrintCommandLineFlags</span><br></pre></table></figure><li><p>查看可以被修改的参数</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -XX:+PrintFlagsFinal -version | grep manageable</span><br></pre></table></figure></ol><h2 id=2-2、系统优化参数><a class=headerlink href=#2-2、系统优化参数 title=2.2、系统优化参数></a>2.2、系统优化参数</h2><ul><li><strong>-XX:-UseCompressedOops</strong>：禁用压缩指针。默认启用，当 Java 堆内存小于 32 GB 时将使用压缩指针。启用此选项后，对象引用表示为 32 位偏移量而不是 64 位指针。此选项仅适用于 64 位 JVM。当 Java 堆内存大于 32GB 时，也可以使用压缩指针。查看<code>-XX:ObjectAlignmentInBytes</code>选项。<li><strong>-XX:+Inline</strong>：启用方法内联。默认开启。要禁用方法内联，请指定<code>-XX:-Inline</code>。<li><strong>-XX:InlineSmallCode=大小</strong>：设置触发内联功能的已编译方法的代码大小（以字节为单位）。只有已编译代码小于指定大小时才会被内联。默认最大代码大小设置为 1000 字节：-XX:InlineSmallCode=1000。<li><strong>-XX:MaxInlineSize=大小</strong>：设置要内联的方法的最大字节码大小（以字节为单位）。默认最大字节码大小为 35 个字节：<code>-XX:MaxInlineSize=35</code>。<li><strong>-XX:MaxTrivialSize=大小</strong>：设置要内联的普通方法的最大字节码大小（以字节为单位）。默认普通方法的最大字节码大小为 6 个字节：<code>-XX:MaxTrivialSize=6</code>。<li><strong>-XX:+PrintInlining</strong>：启用内联决策打印，可以查看哪些方法正在被内联。默认禁用且不打印内联信息。参数<code>-XX:+PrintInlining</code>必须与参数<code>-XX:+UnlockDiagnosticVMOptions</code>一起使用。<li><strong>-XX:+OptimizeStringConcat</strong>：启用<code>String</code>连接优化。默认启用。要禁用<code>String</code>串联优化，请指定<code>-XX:-OptimizeStringConcat</code>。只有 Java HotSpot Server VM 支持此选项。<li><strong>-XX:+UseStringDeduplication</strong>：启用字符串重复数据删除。默认禁用。要想启用该功能就必须启用G1 垃圾收集器。</ul><h2 id=2-3、类加载参数><a class=headerlink href=#2-3、类加载参数 title=2.3、类加载参数></a>2.3、类加载参数</h2><ul><li><p><strong>-XX:+TraceClassLoading</strong>：启用类加载跟踪。</p><li><p><strong>-XX:+TraceClassLoadingPreorder</strong>：启用按引用顺序跟踪所有加载类。默认禁用且不跟踪。</p><li><p><strong>-XX:+TraceClassUnloading</strong>：启用类卸载跟踪。默认禁用且不跟踪。</p><li><p><strong>-XX:CICompilerCount=线程</strong>：设置用于编译的编译器线程数。默认线程数为 2，客户端线程数为 1，如果使用分层编译，它会扩展到内核数。</p><li><p><strong>-XX:CodeCacheMinimumFreeSpace=大小</strong>：编译所需最小空间（以字节为单位）。当剩余空间小于最小可用空间时将停止编译。默认空间大小为 500 KB。</p><li><p><strong>-XX:CompileOnly=方法</strong>：设置限制编译的方法列表（以逗号分隔）。</p> <figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-XX:CompileOnly=java/lang/String.length,java/util/List.size</span><br></pre></table></figure><li><p><strong>-XX:CompileThreshold=调用</strong>：设置 编译前解释方法次数。默认情况下，在服务器 JVM 中，JIT 编译器执行 10,000 次解释方法调用来收集信息以进行高效编译。对于客户端 JVM，默认为 1,500 次调用。启用分层编译时将忽略此选项；见选项<code>-XX:+TieredCompilation</code>。</p><li><p><strong>-XX:+BackgroundCompilation</strong>：启用后台编译。默认启用。要禁用后台编译，请指定<code>-XX:-BackgroundCompilation</code>（这等效于指定<code>-Xbatch</code>）。</p><li><p><strong>-XX:MaxNodeLimit=节点</strong>：设置单个方法编译期间要使用的最大节点数。默认情况下，最大节点数设置为 65,000：<code>-XX:MaxNodeLimit=65000</code>。</p><li><p><strong>-XX:+PrintCompilation</strong>：通过在每次编译方法时将消息打印到控制台来启用来自 JVM 的详细诊断输出。这可以查看实际编译了哪些方法。默认禁用该功能且不打印诊断输出。同时可以通过指定参数<code>-XX:+LogCompilation</code>将编译活动记录到文件中。</p><li><p><strong>-XX:ReservedCodeCacheSize=大小</strong>：设置 JIT 编译代码的最大代码缓存大小（以字节为单位）。默认最大代码缓存为 240 MB；如果指定参数<code>-XX:-TieredCompilation</code>禁用了分层编译，则默认大小为 48 MB。该参数最大限制为 2 GB，否则报错。最大代码缓存不应小于初始代码缓存；见选项<code>-XX:InitialCodeCacheSize</code>。此选项等效于<code>-Xmaxjitcodesize</code>。</p><li><p><strong>-XX:-TieredCompilation</strong>：禁用分层编译。默认启用。只有 Java HotSpot Server VM 支持此选项。</p></ul><h2 id=2-4、运行时数据区参数><a class=headerlink href=#2-4、运行时数据区参数 title=2.4、运行时数据区参数></a>2.4、运行时数据区参数</h2><h3 id=2-4-1、堆（Heap）><a class=headerlink href=#2-4-1、堆（Heap） title=2.4.1、堆（Heap）></a>2.4.1、堆（Heap）</h3><h4 id=基本参数><a class=headerlink href=#基本参数 title=基本参数></a>基本参数</h4><ul><li><strong>-Xms / -XX:InitialHeapSize=大小</strong>：堆内存最小值和初始大小。此值必须是 1024 的倍数且大于 1 MB。<li><strong>-Xmx / -XX:MaxHeapSize=大小</strong>：堆内存最大值（以字节为单位）。此值必须是 1024 的倍数且大于 2 MB。通常将<code>-Xms</code>并<code>-Xmx</code>设为相同值。<li><strong>-XX:+AggressiveHeap</strong>：启用 Java 堆优化。根据计算机配置（RAM 和 CPU）自动设置合适的参数值。默认禁用。<li><strong>-XX:NewRatio=比率</strong>：设置年轻代和年老代大小比例。默认为 2。<li><strong>-XX:+UseAdaptiveSizePolicy</strong>：启用自适应大小调整。默认启用。要禁用请指定参数<code>-XX:-UseAdaptiveSizePolicy</code>和 设置内存分配池的大小（请参阅<code>-XX:SurvivorRatio</code>选项）。<li><strong>-XX:InitialRAMPercentage=percent</strong>：将 JVM 用于 Java 堆的初始内存量设置为 -XX:MaxRAM 选项中所述确定的最大内存量的百分比。默认值为 1.5625%。<li><strong>-XX:MaxRAMPercentage=百分比</strong>：Java 堆的最大内存量，设置为 -XX:MaxRAM 选项中所述确定的最大内存量的百分比。默认值为 25%。</ul><h4 id=年轻代><a class=headerlink href=#年轻代 title=年轻代></a>年轻代</h4><ul><li><strong>-XX:NewSize</strong>：年轻代初始大小。<li><strong>-XX:MaxNewSize</strong>：年轻代最大内存大小。<li><strong>-Xmn</strong>：年轻代 初始大小 和 最大大小。官方建议 年轻代大小 应在 整堆大小的一半 到 四分之一之间。<li><strong>-XX:SurvivorRatio</strong>：新生代中 Eden区 与 Survivor区 的占用比例，默认为8，意为eden区大小占年轻代的8/10，而survivor from区和to区各占1/10；<li><strong>-XX:+UseTLAB</strong>：在年轻代中使用TLAB。默认启用。要禁用 TLAB，请指定<code>-XX:-UseTLAB</code>。<li><strong>-XX:TLABSize=大小</strong>：TLAB 初始大小（以字节为单位）。参数值为 0 时表示自动选择初始大小。<li><strong>-XX:TargetSurvivorRatio=百分比</strong>：设置YGC后，幸存区使用占比。默认为 50%。</ul><h4 id=老年代><a class=headerlink href=#老年代 title=老年代></a>老年代</h4><h3 id=2-4-2、方法区（MethodArea）><a class=headerlink href=#2-4-2、方法区（MethodArea） title=2.4.2、方法区（MethodArea）></a>2.4.2、方法区（MethodArea）</h3><h4 id=永久代><a class=headerlink href=#永久代 title=永久代></a>永久代</h4><ul><li><code>-XX:PermSize=256m</code>：设置永久代初始大小。<li><code>-XX:MaxPermSize=256m</code>：设置永久代最大容量。</ul><h4 id=元空间><a class=headerlink href=#元空间 title=元空间></a>元空间</h4><ul><li><strong>-XX:MaxMetaspaceSize=大小</strong>：设置 类元数据 最大本机内存量。默认大小不受限制。应用程序的元数据量取决于应用程序本身、其他正在运行的应用程序以及系统上可用的内存量。<li><strong>-XX:MetaspaceSize=size</strong>：设置 类元数据空间大小，该空间将在第一次超出时触发垃圾回收。根据使用的元数据量增加或减少垃圾收集的阈值。默认大小取决于平台。<li><code>-XX:+UseCompressedOops</code>：压缩对象指针。<li><code>-XX:+UseCompressedClassPointers</code>：压缩类型指针。<li><code>-XX:CompressedClassSpaceSize</code>：设置Klass Metaspace的大小，默认1G。</ul><h3 id=2-4-3、操作数栈（OperandStack）><a class=headerlink href=#2-4-3、操作数栈（OperandStack） title=2.4.3、操作数栈（OperandStack）></a>2.4.3、操作数栈（OperandStack）</h3><ul><li><strong>-Xss</strong>：设置 线程堆栈大小（以字节为单位）等价于<code>-XX:ThreadStackSize=大小</code>。默认值取决于平台。<li><strong>-XX:+DoEscapeAnalysis</strong>：启用逃逸分析。默认启用。要禁用请指定<code>-XX:-DoEscapeAnalysis</code>。只有 Java HotSpot Server VM 支持此选项。</ul><h3 id=2-4-4、本地方法栈（LocalMethodStack）><a class=headerlink href=#2-4-4、本地方法栈（LocalMethodStack） title=2.4.4、本地方法栈（LocalMethodStack）></a>2.4.4、本地方法栈（LocalMethodStack）</h3><h3 id=2-4-5、程序计数器（ProgramRegister）><a class=headerlink href=#2-4-5、程序计数器（ProgramRegister） title=2.4.5、程序计数器（ProgramRegister）></a>2.4.5、程序计数器（ProgramRegister）</h3><h3 id=2-4-6、直接内存（DirectMemory）><a class=headerlink href=#2-4-6、直接内存（DirectMemory） title=2.4.6、直接内存（DirectMemory）></a>2.4.6、直接内存（DirectMemory）</h3><ul><li><strong>-XX:MaxDirectMemorySize=大小</strong>：设置新 I/O（<code>java.nio</code>包）直接缓冲区分配的最大值（以字节为单位）。默认大小为 0，表示 JVM 会自动选择 NIO 直接缓冲区大小。</ul><h3 id=2-4-7、其它><a class=headerlink href=#2-4-7、其它 title=2.4.7、其它></a>2.4.7、其它</h3><ul><li><strong>-XX:ObjectAlignmentInBytes=对齐</strong>：设置 Java 对象的内存对齐（以字节为单位）。默认为 8 个字节。指定的值应该是 2 的幂，并且必须在 8 到 256（含）范围内。<li><strong>-XX:+PrintCommandLineFlags</strong>：允许 打印出现在命令行上的符合人体工程学的选定 JVM 标志。<li><strong>-XX:InitialCodeCacheSize=大小</strong>：设置 初始代码缓存大小（以字节为单位）。默认为 500 KB。初始代码缓存大小应不小于系统的最小内存页大小。</ul><h2 id=2-5、垃圾回收参数><a class=headerlink href=#2-5、垃圾回收参数 title=2.5、垃圾回收参数></a>2.5、垃圾回收参数</h2><h3 id=2-5-1、基本参数><a class=headerlink href=#2-5-1、基本参数 title=2.5.1、基本参数></a>2.5.1、基本参数</h3><ul><li><p><strong>-Xnoclassgc</strong>：禁用垃圾回收 (GC)。</p><li><p><strong>-XX:ErrorFile=文件名</strong>：发生错误时 将 错误数据 写入指定文件。文件默认在当前目录且并命名为 hs_err_pid pid.log，其中 pid 是导致错误的进程标识符。</p><li><p><strong>-XX:+HeapDumpOnOutOfMemoryError</strong>：OOM引发异常时将错误信息导出到指定文件。可使用参数<code>-XX:HeapDumpPath</code>设置文件路径和名称。默认禁用。</p><li><p><strong>-XX:HeapDumpPath=路径</strong>：设置该<code>-XX:+HeapDumpOnOutOfMemoryError</code>选项时，设置用于写入堆分析器 (HPROF) 提供的堆转储的路径和文件名。默认情况下，该文件在当前工作目录中创建，并命名为<code>java_pid</code><em>pid</em><code>.hprof</code>，其中 pid 是导致错误的进程标识符。以下示例设置默认文件（<code>%p</code>代表当前进程标识符）：</p> <figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>-XX:HeapDumpPath=./java_pid%p.hprof</span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>以下示例显示如何将堆转储文件设置为/var/log/java/java_heapdump.hprof：</span></span><br><span class=line>-XX:HeapDumpPath=/var/log/java/java_heapdump.hprof</span><br></pre></table></figure><li><p><strong>-XX:ActiveProcessorCount= x</strong>：覆盖 VM 用于计算其用于各种操作（例如垃圾收集和 ForkJoinPool）的线程池大小的 CPU 数量。</p><li><p><strong>-XX:MaxHeapFreeRatio=百分比</strong>：设置 GC后堆最大空闲空间占比（0 到 100）。如果GC后空闲空间占比大于该参数值，则将堆缩小。默认为 70%。</p><li><p><strong>-XX:MinHeapFreeRatio=百分比</strong>：设置 GC后堆最小空闲空间占比（0 到 100）。如果GC后空闲空间占比小于该参数值，则将堆扩大。默认为 40%。</p><li><p><strong>-XX:MaxTenuringThreshold=阈值</strong>：对象晋升至老年代的最大年龄阈值为 15。并行（吞吐量）收集器默认为 15，CMS 收集器默认为 6。</p><li><p><strong>-XX:MinRAMPercentage=百分比</strong>：将 JVM 可用于 Java 堆的最大内存量设置为如<code>-XX:MaxRAM</code>小堆选项中所述确定的最大内存量的百分比。小堆大约 125 MB。默认值为 50%。</p><li><p><strong>-XX:+ScavengeBeforeFullGC</strong>：FGC前先执行一次YGC，默认启用。Oracle 建议您不要禁用它。</p><li><p><strong>-XX:StringDeduplicationAgeThreshold=阈值</strong>：<code>String</code>达到指定年龄的对象被视为重复数据删除的候选对象。一个对象的年龄是衡量它在垃圾收集中幸存下来的次数。这有时被称为任期；</p><li><p><strong>-XX:+UseGCOverheadLimit</strong>：允许使用限制 JVM 在<code>OutOfMemoryError</code>抛出异常之前花费在 GC 上的时间比例的策略。默认情况下启用此选项，<code>OutOfMemoryError</code>如果总时间的 98% 以上用于垃圾收集并且堆的回收少于 2%，则并行 GC 将抛出异常。当堆很小时，此功能可用于防止应用程序长时间运行而几乎没有或没有进展。要禁用此选项请指定<code>-XX:-UseGCOverheadLimit</code>。</p><li><p><strong>-XX:+UseNUMA</strong>：通过增加应用程序对低延迟内存的使用，在具有非统一内存架构 (NUMA) 的机器上实现应用程序的性能优化。默认情况下，此选项处于禁用状态，并且不会对 NUMA 进行优化。该选项仅在使用并行垃圾收集器 ( <code>-XX:+UseParallelGC</code>)时可用。</p><li><p>-XX:PreTenureSizeThreshold：设置大对象大小；</p><li><p>-XX:MaxTenuringThreshold：表示对象晋升到老年代的年龄阈值；（默认值15，CMS为6，G1为15。）</p> <p><font color=red>注意，年龄小于该阈值时也可能会晋升，但晋升时对象的年龄永远不会超过该阈值。因为还有对象动态晋升机制的存在，动态晋升是指：当survivor区中所有相同大小对象的大小总和超过survivor区一半时，就需要将这些相同大小的对象和大于该大小的对象全部晋升到老年代中，使得survivor区中有空闲空间来供程序正常运行来用，否则没有空闲空间，程序将会出现问题。</font></p></ul><h3 id=2-5-2、垃圾收集器参数><a class=headerlink href=#2-5-2、垃圾收集器参数 title=2.5.2、垃圾收集器参数></a>2.5.2、垃圾收集器参数</h3><h4 id=基本参数-1><a class=headerlink href=#基本参数-1 title=基本参数></a>基本参数</h4><ul><li><strong>-XX:ConcGCThreads=线程</strong>：设置并发GC 线程数。默认值取决于 JVM 可用的 CPU 数量。<li><strong>-XX:+DisableExplicitGC</strong>：禁用代码块 System.gc()。<li><strong>-XX:InitiatingHeapOccupancyPercent=百分比</strong>：设置启动并发 GC 周期的堆占用百分比（0 到 100）。它被垃圾收集器使用，它们根据整个堆的占用率触发并发 GC 周期，而不仅仅是其中一代（例如，G1 垃圾收集器）。默认初始值为 45%。值 0 表示不间断 GC 循环。<li><strong>-XX:MaxGCPauseMillis=时间</strong>：设置 GC 最大暂停时间（以毫秒为单位）。默认 没有最大暂停时间值。</ul><h4 id=Serial-Old常用参数><a title="Serial Old常用参数" class=headerlink href=#Serial-Old常用参数></a>Serial Old常用参数</h4><ul><li><strong>-XX:+UseSerialGC</strong>：启用串行垃圾收集器。适用于小型的简单的应用程序。默认禁用，并根据机器配置和 JVM 类型自动选择收集器。</ul><h4 id=Parallel常用参数><a class=headerlink href=#Parallel常用参数 title=Parallel常用参数></a>Parallel常用参数</h4><ul><li><p><strong>-XX:+UseParallelGC</strong>：使用并行清理垃圾收集器（也称为吞吐量收集器）。默认禁用，并根据机器配置和 JVM 类型自动选择收集器。如果启用该选项，则默认同时启用<code>-XX:+UseParallelOldGC</code>，除非明确禁用它。</p><li><p><strong>-XX:+UseParallelOldGC</strong>：启用并行垃圾收集器。默认禁用。启用它会自动启用参数<code>-XX:+UseParallelGC</code>。</p><li><p><strong>-XX:+ParallelGCThreads=n</strong>：设置用于年轻代和年老代并行垃圾回收的线程数。默认值取决于 JVM 可用的 CPU 数量。同样适用于CMS。*</p> <p>按照逻辑处理器的数量来设置n值。n 的值应该与逻辑处理器的数量相同，最多为 8。如果逻辑处理器不止八个，则将 n 的值设置为逻辑处理器数量的 5/8 左右。这适用于大多数情况，除非是较大的 SPARC 系统，其中 n 值可以是逻辑处理器数的 5/16 左右。</p><li><p><strong>-XX:+UseAdaptiveSizePolicy</strong>：表示自动选择各区大小比例。</p><li><p><strong>-XX:InitialSurvivorRatio=比率</strong>：设置吞吐量垃圾收集器使用的初始幸存者空间比率（由<code>-XX:+UseParallelGC</code>和/或 -<code>XX:+UseParallelOldGC</code>选项启用）。默认吞吐量垃圾收集器使用<code>-XX:+UseParallelGC</code>和<code>-XX:+UseParallelOldGC</code>选项启用自适应大小调整，并根据应用程序行为调整幸存者空间大小，从初始值开始。如果禁用了自适应大小调整（使用该<code>-XX:-UseAdaptiveSizePolicy</code>选项），<code>-XX:SurvivorRatio</code>则应使用该选项为整个应用程序执行设置幸存者空间的大小。</p> <p>根据年轻代的大小（Y）和初始幸存者空间比率（R），可以使用以下公式计算幸存者空间的初始大小（S）：</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>S=Y/(R+2)</span><br></pre></table></figure><li><p><strong>-XX:+ParallelRefProcEnabled</strong>：启用并行引用处理。默认禁用状态。</p><li><p><code>-XX:MaxGCPauseMillis</code>：设置垃圾收集器最大停顿时间。</p><li><p><code>-XX:GCTimeRatio</code>：垃圾收集时间占总时间的比例。</p></ul><h4 id=ParNew参数><a class=headerlink href=#ParNew参数 title=ParNew参数></a>ParNew参数</h4><ul><li><strong>-XX:+UseParNewGC</strong>：年轻代中使用 并行线程 进行收集。默认禁用。设置参数<code>-XX:+UseConcMarkSweepGC</code>会自动启用。使用<code>-XX:+UseParNewGC</code>不带选项<code>-XX:+UseConcMarkSweepGC</code>的选择是在JDK 8弃用。</ul><h4 id=CMS常用参数><a class=headerlink href=#CMS常用参数 title=CMS常用参数></a>CMS常用参数</h4><ul><li><p><font color=orange>-XX:+UseConcMarkSweepGC</font>：为老年代启用 CMS 垃圾收集器。Oracle 建议您在吞吐量 ( <code>-XX:+UseParallelGC</code>) 垃圾收集器无法满足应用程序延迟要求时使用 CMS 垃圾收集器。G1 垃圾收集器 ( <code>-XX:+UseG1GC</code>) 是另一种选择。</p> <p>默认情况下，此选项处于禁用状态，并根据机器的配置和 JVM 的类型自动选择收集器。当启用该选项时，<code>-XX:+UseParNewGC</code>选项将自动设置，你不应该禁用它，因为下面的选项组合已经在JDK 8被弃用：<code>-XX:+UseConcMarkSweepGC -XX:-UseParNewGC</code>。</p><li><p><font color=orange>-XX:ParallelCMSThreads</font>：CMS线程数量。</p><li><p><font color=orange>-XX:CMSInitiatingOccupancyFraction</font>：老年代内存使用率达到多少时执行CMS收集（低版本的 JDK 默认值为 68%, JDK6 及以上版本默认值为 92%），这里的内存回收范围仅限于老年代，而非整个堆空间，因此通过该选项便可以有效降低 Full GC 执行次数。如果频繁发生SerialOld卡顿，应该调小，（频繁CMS回收）。默认值设置为 -1。任何负值（包括默认值）都意味着<code>-XX:CMSTriggerRatio</code>用于定义初始占用率的值。</p><li><p><font color=orange>-XX:+UseCMSCompactAtFullCollection</font>：执行FGC后是否进行压缩整理。</p><li><p><font color=orange>-XX:CMSFullGCsBeforeCompaction</font>：执行FGC多少次后进行压缩整理。</p><li><p><font color=orange>-XX:+CMSClassUnloadingEnabled</font>：表示对永久代进行垃圾回收；</p> <p>CMS收集器默认不会对永久代进行垃圾回收，如需回收设置该参数即可。在早期JVM版本中，要求设置额外的标志-XX:+CMSPermGenSweepingEnabled。注意，即使没有设置这个标志，一旦永久代耗尽空间也会尝试进行垃圾回收，但是收集不会是并行的，而再一次进行Full GC。</p><li><p><font color=orange>-XX:CMSInitiatingPermOccupancyFraction</font>：达到什么比例时进行Perm回收。</p><li><p><font color=orange>GCTimeRatio</font>：设置GC时间占用程序运行时间的百分比。</p><li><p><font color=orange>-XX:MaxGCPauseMillis</font>：停顿时间，是一个建议时间，GC会尝试用各种手段达到这个时间，比如减小年轻代。</p><li><p><strong>-XX:+CMSClassUnloadingEnabled</strong>：在使用并发标记清除 (CMS) 垃圾收集器时启用类卸载。默认启用。要禁用 CMS 垃圾收集器的类卸载，请指定<code>-XX:-CMSClassUnloadingEnabled</code>。</p><li><p><strong>-XX:+CMSScavengeBeforeRemark</strong>：在 CMS 注释步骤之前启用清理尝试。默认禁用。</p><li><p><strong>-XX:CMSTriggerRatio=百分比</strong>：设置在<code>-XX:MinHeapFreeRatio</code>CMS 收集周期开始之前分配的指定值的百分比（0 到 100）。默认值设置为 80%。</p><li><p><strong>-XX:+ExplicitGCInvokesConcurrent</strong>：通过使用<code>System.gc()</code>请求启用并发 GC 的调用。默认禁用，只能与<code>-XX:+UseConcMarkSweepGC</code>选项一起启用。</p><li><p><strong>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</strong>：通过在并发 GC 周期中使用 System.gc() 请求和卸载类来启用并发 GC 的调用。默认禁用，只能与 -XX:+UseConcMarkSweepGC 选项一起启用。</p><li><p><strong>-XX:+UseCMSInitiatingOccupancyOnly</strong>：允许使用占用值作为启动 CMS 收集器的唯一标准。默认禁用，可以使用其他条件。</p></ul><h4 id=G1常用参数><a class=headerlink href=#G1常用参数 title=G1常用参数></a>G1常用参数</h4><ul><li><p><font color=orange>-XX:+UseG1GC</font>：表示 使用G1收集器；</p><li><p><font color=orange>-XX:MaxGCPauseMillis</font>：每次GC的停顿目标时间，默认值 200ms。G1会尝试调整Young区的个数来达到该值；</p><li><p>-<font color=orange>XX:GCPauseIntervalMillis</font>：GC间隔时间；</p><li><p><font color=orange>-XX:G1HeapRegionSize=n</font>：分区大小，建议逐渐增大该值1、2、4、8、16、32。随着size增加，垃圾存活时间会更长，GC间隔会更长，但每次GC时间也会更长，ZGC做了改进（动态区块大小）；</p><li><p><font color=orange>-XX:G1HeapWastePercent</font>：默认值5%，表示在全局并发标记结束后能够统计出所有可被回收的垃圾占Heap的比例值，如果超过5%，就会触发之后的多轮Mixed GC，mixed gc会同时回收年轻代+老年代，而这个参数可以指定mixed gc触发的时机；</p> <p>注意：该参数与 <code>InitiatingHeapOccupancyPercent</code> 结合使用可以实现提前回收老年代，让老年代提前释放空间。</p><li><p><font color=orange>-XX:InitiatingHeapOccupancyPercent=45</font>：默认45%，表示在堆使用率达到该参数设定值时，就会触发 混合回收；</p><li><p><font color=orange>-XX:G1NewSizePercent</font>：新生代最小比例，默认为5%。</p><li><p><font color=orange>-XX:G1MaxNewSizePercent</font>：新生代最大比例，默认为60%；</p><li><p><font color=orange>-XX:G1MixedGCCountTarget</font>：默认值8，表示最后的混合回收阶段会执行8次，一次只回收掉一部分Region，然后系统继续运行，过了一小段时间后，会再次进行混合回收，就这样重复8次；</p><li><p><font color=orange>-XX:G1MixedGCLiveThresholdPercent</font>：默认值85%，表示 一个Region中的存活对象若大于Region大小的85%，那就无需回收这个Region，否则得不偿失；</p><li><p><font color=orange>-XX:GCTimeRatio</font>：圾回收时间占程序运行时间的百分比；</p><li><p><font color=orange>-XX:ConcGCThreads=n</font>：设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1/4 左右；</p><li><p><strong>-XX:G1HeapRegionSize=大小</strong>：使用G1收集器时 Java 堆细分的区域大小。该值介于 1 MB 和 32 MB 之间。默认区域大小是根据堆大小来定。</p><li><p><strong>-XX:+G1PrintHeapRegions</strong>：启用打印有关哪些区域已分配以及哪些由 G1 收集器回收的信息。默认情况下，此选项处于禁用状态。</p><li><p><strong>-XX:G1ReservePercent=百分比</strong>：设置保留为虚假上限的堆的百分比（0 到 50），以减少 G1 收集器升级失败的可能性。默认情况下，此选项设置为 10%。</p><li><p><strong>-XX:+UseStringDeduplication</strong>：启用字符串重复数据删除。默认禁用。要使用此选项，您必须启用G1垃圾收集器。</p></ul><h4 id=常见垃圾回收器参数><a class=headerlink href=#常见垃圾回收器参数 title=常见垃圾回收器参数></a>常见垃圾回收器参数</h4><ul><li><p>设置串行收集器</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-XX:+UseSerialGC = Serial New(DefNew) + Serial Old</span><br></pre></table></figure><li><p>设置并行收集器</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-XX:+UseParallelGC</span><br></pre></table></figure> <p>同时还需要设置以下参数：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>-XX:ParallelGCThreads=n     <span class=comment># 设置并行收集器工作时使用的CPU数量。</span></span><br><span class=line>-XX:MaxGCPauseMillis=n      <span class=comment># 设置并行收集器最大停顿时间。</span></span><br><span class=line>-XX:GCTimeRatio=n           <span class=comment># 设置垃圾回收时间占程序运行时间的百分比。</span></span><br></pre></table></figure><li><p>设置老年代并行收集器</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-XX:+UseParallelOldGC</span><br></pre></table></figure><li><p>设置并发收集器</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-XX:+UseConcMarkSweeqGC</span><br></pre></table></figure> <p>同时还需要设置以下参数：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>-XX:+CMSIncrementalMode     <span class=comment># 设置为增量模式，适用于单CPU情况。</span></span><br><span class=line>-XX:ParallelGCThreads=n     <span class=comment># 设置年轻代收集为并行收集时，并行GC线程的数量，一般最好和CPU核心数量一样。</span></span><br></pre></table></figure></ul><p>其它参数如下：<ul><li><p><font color=orange>-XX:+UseParNewGC = ParNew + SerialOld</font></p><li><p><font color=orange>-XX:+UseConc(current)MarkSweepGC = ParNew + CMS + SerialOld</font></p><li><p><font color=orange>-XX:+UseParallelGC = Parallel Scavenge + Parallel Old</font></p><li><p><font color=orange>-XX:+UseG1GC = G1</font></p><li><p>查看Linux下默认GC的方法，而Windows中会打印UseParallelGC</p> <ol><li><font color=orange>java -XX:+PrintCommandLineFlags - version</font><li>通过GC日志分辨。</ol><li><p>Linux下1.8版本默认垃圾收集器是啥？</p> <ol><li>1.8.0_181 默认看不出，Copy MarkCompact<li>1.8.0_222 默认PS + PO</ol></ul><h3 id=2-5-3、GC日志参数><a class=headerlink href=#2-5-3、GC日志参数 title=2.5.3、GC日志参数></a>2.5.3、GC日志参数</h3><h4 id=基本参数-2><a class=headerlink href=#基本参数-2 title=基本参数></a>基本参数</h4><ul><li><strong>-XX:LogFile=路径</strong>：设置写入日志数据的路径和文件名。默认该文件创建在当前工作目录中，并命名为<code>hotspot.log</code>.</ul><h4 id=日志打印参数><a class=headerlink href=#日志打印参数 title=日志打印参数></a>日志打印参数</h4><ul><li><strong>-XX:+PrintGC</strong>：每次 GC 时打印消息。默认禁用。<li><strong>-XX:+PrintGCDetails</strong>：每次 GC 时打印详细消息。默认禁用。<li><strong>-XX:+PrintGCTimeStamps</strong>：每次 GC 时打印时间戳。默认禁用。<li><strong>-XX:+PrintGCTaskTimeStamps</strong>：为每个单独的 GC 工作线程任务启用时间戳打印。默认禁用。<li><strong>-XX:+PrintGCCauses</strong><li><strong>-XX:+PrintGCApplicationConcurrentTime</strong>：启用打印自上次暂停（例如，GC 暂停）以来经过的时间。默认禁用。<li><strong>-XX:+PrintGCApplicationStoppedTime</strong>：启用打印暂停（例如，GC 暂停）持续的时间。默认禁用。<li><strong>-XX:+PrintGCDateStamps</strong>：每次 GC 时打印日期戳。默认禁用。<li><strong>-XX:+PrintStringDeduplicationStatistics</strong>：打印详细重复数据，删除统计信息。默认禁用。查看<code>-XX:+UseStringDeduplication</code>选项。<li><strong>-XX:+PrintTenuringDistribution</strong>：启用任期年龄信息的打印。<li><strong>-XX:SoftRefLRUPolicyMSPerMB=时间</strong>：软引用对象在上次被引用后在堆上保持活动的时间量（以毫秒为单位）。默认值是堆中每空闲兆字节的生命周期一秒。<li><strong>-XX:PrintHeapAtGC</strong>：GC执行前后打印出堆的信息；<li><strong>-Xloggc:filename</strong>：日志文件保存路径；</ul><p><font color=red>注意：total = eden区 + 1个survivor区。</font><h4 id=日志配置><a class=headerlink href=#日志配置 title=日志配置></a>日志配置</h4><ol><li><p>方式一</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>-Xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M -XX:+PrintGCDetails -XX:+PrintGCGateStamps -XX:+PrintGCCause</span><br></pre></table></figure><li><p>方式二</p> <p>或者每天产生一个。</p></ol><h2 id=2-6、Java锁参数><a class=headerlink href=#2-6、Java锁参数 title=2.6、Java锁参数></a>2.6、Java锁参数</h2><ul><li><strong>-XX:-UseBiasedLocking</strong>：禁用偏向锁。</ul><h2 id=2-7、JVM参数总结><a class=headerlink href=#2-7、JVM参数总结 title=2.7、JVM参数总结></a>2.7、JVM参数总结</h2><h3 id=2-7-1、GC常用参数><a class=headerlink href=#2-7-1、GC常用参数 title=2.7.1、GC常用参数></a>2.7.1、GC常用参数</h3><ul><li><font color=orange>-Xms / -Xmx / -Xmn / -Xss</font>：最小堆 / 最大堆 / 年轻代 / 栈空间。<li><font color=orange>-XX:NewSize</font>：JVM启动时分配的新生代内存大小。<li><font color=orange>-XX:OldSize</font>：JVM启动时分配的老年代内存大小。<li><font color=orange>-XX:PermSize 和 -XX:MaxPermSize</font>：JVM 永久代（方法区，JDK7之前）大小。<li><font color=orange>-XX SurvivorRatio</font>：Eden空间和另外两个Survivor空间的比例，默认比例是<code>8:1</code>。<li><font color=orange>-XX:+UseTLAB</font>：使用TLAB，默认打开。<li><font color=orange>-XX:+PrintTLAB</font>：打印TLAB使用情况。<li><font color=orange>-XX:TLABSize</font>：设置TLAB大小。<li><font color=orange>-XX:+DisableExplictGC</font>：System.gc()不管用 ，FGC。<li><font color=orange>-XX:+PrintGC</font>：<li><font color=orange>-XX:+PrintGCDetails</font>：<li><font color=orange>-XX:+PrintHeapAtGC</font>：<li><font color=orange>-XX:+PrintGCTimeStamps</font>：<li><font color=orange>-XX:+PrintGCApplicationConcurrentTime (低)</font>：打印应用程序时间。<li><font color=orange>-XX:+PrintGCApplicationStoppedTime（低）</font>：打印暂停时长。<li><font color=orange>-XX:+PrintReferenceGC（重要性低）</font>：记录回收了多少种不同引用类型的引用。<li><font color=orange>-verbose:class</font>：类加载详细过程。<li><font color=orange>-XX:+PrintVMOptions</font>：<li><font color=orange>-XX:+PrintFlagsFinal -XX:+PrintFlagsInitial</font>：必须会用。<li><font color=orange>-Xloggc:opt/log/gc.log</font>：将生成的gc日志保存于指定的文件中。<li><font color=orange>-XX:MaxTenuringThreshold</font>：升代年龄，最大值15。<li><font color=orange>-XX:PreBlockSpin</font>：锁自旋次数参数（默认即可，不建议设置）。<li><font color=orange>-XX:CompileThreshold</font>：热点代码检测参数、逃逸分析、标量替换（默认即可，不建议设置）。</ul><h3 id=2-7-2、堆内存常用配置><a class=headerlink href=#2-7-2、堆内存常用配置 title=2.7.2、堆内存常用配置></a>2.7.2、堆内存常用配置</h3><h4 id=类型1><a class=headerlink href=#类型1 title=类型1></a>类型1</h4><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k</span><br></pre></table></figure><ul><li><p><font color=orange>-Xmx3550m</font>：设置JVM最大可用内存为3550M。</p><li><p><font color=orange>-Xms3550m</font>：设置JVM内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</p><li><p><font color=orange>-Xmn2g</font>：设置年轻代大小为2G。整个JVM内存大小=年轻代大小+老年代大小+持久代大小。持久代大小一般固定为64m，所以增大年轻代后，将会减小老年代大小。</p> <p><font color=red>注意：此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</font></p><li><p><font color=orange>-Xss128k</font>：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p></ul><h4 id=类型2><a class=headerlink href=#类型2 title=类型2></a>类型2</h4><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0</span><br></pre></table></figure><ul><li><font color=orange>-XX:NewRatio=4</font>：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4表示年轻代与年老代所占比值为<code>1:4</code>，年轻代占整个堆栈的1/5。<li><font color=orange>-XX:SurvivorRatio=4</font>：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为<code>2:4</code>，一个Survivor区占整个年轻代的1/6。<li><font color=orange>-XX:MaxPermSize=16m</font>：设置持久代大小为16m。<li><font color=orange>-XX:MaxTenuringThreshold=0</font>：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代即被回收的机会。</ul><h3 id=2-8-3、回收器常用配置><a class=headerlink href=#2-8-3、回收器常用配置 title=2.8.3、回收器常用配置></a>2.8.3、回收器常用配置</h3><h4 id=吞吐量优先><a class=headerlink href=#吞吐量优先 title=吞吐量优先></a>吞吐量优先</h4><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment># 方案1</span></span><br><span class=line>java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20</span><br><span class=line><span class=comment># 方案2</span></span><br><span class=line>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC</span><br><span class=line><span class=comment># 方案3</span></span><br><span class=line>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100</span><br><span class=line><span class=comment># 方案4</span></span><br><span class=line>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy</span><br></pre></table></figure><h4 id=响应时间优先><a class=headerlink href=#响应时间优先 title=响应时间优先></a>响应时间优先</h4><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># 方案1</span></span><br><span class=line>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</span><br><span class=line><span class=comment># 方案2</span></span><br><span class=line>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</span><br></pre></table></figure><h1 id=3、JVM调优><a class=headerlink href=#3、JVM调优 title=3、JVM调优></a>3、JVM调优</h1><h2 id=3-1、前言><a class=headerlink href=#3-1、前言 title=3.1、前言></a>3.1、前言</h2><h3 id=3-1-1、内存泄漏和内存溢出><a class=headerlink href=#3-1-1、内存泄漏和内存溢出 title=3.1.1、内存泄漏和内存溢出></a>3.1.1、内存泄漏和内存溢出</h3><ul><li><strong>内存泄漏（Memory Leak）：程序申请内存后无法释放已申请的内存空间，一次内存泄露可以忽略，但内存泄露堆积后果很严重。</strong><li><strong>内存溢出（Out Of Memory）：程序申请内存时没有足够的内存空间供其使用会出现Out Of Memory。</strong></ul><h3 id=3-1-2、QPS和TPS><a class=headerlink href=#3-1-2、QPS和TPS title=3.1.2、QPS和TPS></a>3.1.2、QPS和TPS</h3><ul><li><p><strong>QPS</strong>：全称——Queries Per Second，意思是<em><strong>每秒查询率</strong></em>，是一台服务器每秒能够响应的查询次数（数据库中的每秒执行查询sql的次数），显然，这个不够全面，不能描述增删改，所以，不建议用qps来作为系统性能指标。</p><li><p><strong>TPS</strong>：全称——Transactions Per Second，意思是<em><strong>每秒事务数</strong></em>，具体事务的定义，都是人为的，可以一个接口、多个接口、一个业务流程等等。一个事务是指事务内第一个请求发送到接收到最后一个请求的响应的过程，以此来计算使用的时间和完成的事务个数。</p> <p>以单接口定义的事务为例，每个事务包括了如下3个过程：</p> <ol><li>向服务器发请求。<li>服务器自己的内部处理（包含应用服务器、数据库服务器等）。<li>服务器返回结果给客户端。</ol> <p>如果每秒能够完成N次这三个过程，那么TPS就是N；</p> <p>如果多个接口定义为一个事务，且1、2、3过程执行一轮为一次，那么1秒能执行多少次，TPS就是多少。</p></ul><h3 id=3-1-3、吞吐量和响应时间><a class=headerlink href=#3-1-3、吞吐量和响应时间 title=3.1.3、吞吐量和响应时间></a>3.1.3、吞吐量和响应时间</h3><ul><li><strong>吞吐量</strong>：用户代码时间 / (用户代码执行时间 + 垃圾回收时间)。<li><strong>响应时间</strong>：服务器接收到请求到返回结果给客户端这么一个过程所耗费的时间。STW时间越短，响应时间越好。</ul><h2 id=3-2、如何调优><a class=headerlink href=#3-2、如何调优 title=3.2、如何调优></a>3.2、如何调优</h2><p>想要调优，首先要有一个目标，你的目标是追求<em><strong>响应时间 or 吞吐量？</strong></em><ul><li>追求吞吐量，对于 科学计算、数据挖掘等场景，选择垃圾回收器组合：PS+PO。<li>追求响应时间，比如：网站、带界面的程序、对外提供API等，选择ParNew、CMS、G1。</ul><h2 id=3-3、调优分类><a class=headerlink href=#3-3、调优分类 title=3.3、调优分类></a>3.3、调优分类</h2><p>GC调优分为三类：<ol><li>根据需求进行JVM规划和预调优。<li>优化JVM运行环境（慢、卡顿）。<li>解决JVM运行过程中出现的各种问题，比如说OOM。</ol><h2 id=3-4、调优思路><a class=headerlink href=#3-4、调优思路 title=3.4、调优思路></a>3.4、调优思路</h2><h3 id=3-4-1、思路><a class=headerlink href=#3-4-1、思路 title=3.4.1、思路></a>3.4.1、思路</h3><p>调优，从业务场景开始，没有业务场景的调优就是耍流氓。同时还要遵循无监控，不调优的规则<p>常见的调优思路如下：<ol><li><p>熟悉业务场景（选择垃圾收集器，垃圾收集器只有合适的，没有最好的）。</p> <ul><li>响应时间：停顿时间，（推荐：CMS / G1 / ZGC）<li>吞吐量：代码时间 / (代码时间 + GC时间)，（推荐：PS）</ul><li><p>选择回收器组合。</p><li><p>计算内存需求。</p><li><p>选定CPU（越高越好，按预算来）。</p><li><p>设定年代大小，升级年龄。</p><li><p>设定日志参数。</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>-xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log </span><br><span class=line>-XX:+UseGCLogFileRotation </span><br><span class=line>-XX:NumberOfGCLogFiles=5 </span><br><span class=line>-XX:GCLogFilesSize=20m </span><br><span class=line>-XX:+PrintGcDetails </span><br><span class=line>-XX:+PrintGCDateStamps </span><br><span class=line>-XX:PrintGCCause</span><br></pre></table></figure> <p>注意：一般记录日志时，会形成日志文件。如果只有一个日志文件，肯定不行，需要根据实际情况来定。</p></ol><h3 id=3-4-2、常用命令><a class=headerlink href=#3-4-2、常用命令 title=3.4.2、常用命令></a>3.4.2、常用命令</h3><ol><li>java -XX:+PrintFlagsInitial：打印默认参数值；<li>java -XX:+PrintFlagsFinal：打印最终参数值；<li>java -XX:+PrintFlagsFinal | grep xxx：找到对应的参数；<li>java -XX:+PrintFlagsFinal -version | grep GC；</ol><h2 id=3-5、调优工具><a class=headerlink href=#3-5、调优工具 title=3.5、调优工具></a>3.5、调优工具</h2><h3 id=3-5-1、Arthas><a class=headerlink href=#3-5-1、Arthas title=3.5.1、Arthas></a>3.5.1、Arthas</h3><h4 id=常用命令><a class=headerlink href=#常用命令 title=常用命令></a>常用命令</h4><p>1、dump到指定文件（使用jhat进行分析）<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>heapdump</span> <span class=string>/tmp/dump.hprof</span></span><br></pre></table></figure><p>2、仅dump live对象<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>heapdump</span> <span class=string>--live /tmp/dump.hprof</span></span><br></pre></table></figure><p>3、展示当前进程信息<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>dashboard</span></span><br></pre></table></figure><p>4、打印线程ID的栈信息<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>thread</span> <span class=string>id </span></span><br></pre></table></figure><p>5、可以方便查看死锁<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>thread</span> <span class=string>-b id</span></span><br></pre></table></figure><p>6、反编译<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>jad</span> <span class=string>*.class    如：jad HelloGC</span></span><br></pre></table></figure><p>反编译需要注意以下问题：<ol><li><font color=red>动态代理生成类问题；</font><li><font color=red>第三方类；（观察代码）</font><li><font color=red>版本问题；（确定自己最新提交的版本是不是被使用）</font></ol><p><font color=red>注意：配合热替换使用，但要注意热替换的限制问题。</font><p>7、热替换<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>redefine /opt/XXX.class</span><br></pre></table></figure><p>实现步骤：<ol><li>运行测试类A；（A中有方法m，m中打印数字1。）<li>现需要修改类A中方法m的逻辑，让其打印数字2；<li>在不停掉1步骤中类A情的况下，直接修改类A中方法m的逻辑（打印2），然后重新编译（javac A.java）；<li>执行arthas命令：<code>redefine /opt/A.class</code>，即可实现热替换；（命令中的A.class是修改后的最新版本）</ol><p>限制条件有：<ol><li>只能修改方法实现；（方法已经运行）<li>不能改方法名；<li>不能改属性；</ol><h3 id=3-5-2、VisualVM><a class=headerlink href=#3-5-2、VisualVM title=3.5.2、VisualVM></a>3.5.2、VisualVM</h3><h3 id=3-5-3、Profiler><a class=headerlink href=#3-5-3、Profiler title=3.5.3、Profiler></a>3.5.3、Profiler</h3><h3 id=3-5-4、GCEasy><a class=headerlink href=#3-5-4、GCEasy title=3.5.4、GCEasy></a>3.5.4、GCEasy</h3><h3 id=3-5-5、GCViewer><a class=headerlink href=#3-5-5、GCViewer title=3.5.5、GCViewer></a>3.5.5、GCViewer</h3><h2 id=3-6、调优案例><a class=headerlink href=#3-6、调优案例 title=3.6、调优案例></a>3.6、调优案例</h2><h3 id=3-6-1、案例一><a class=headerlink href=#3-6-1、案例一 title=3.6.1、案例一></a>3.6.1、案例一</h3><h4 id=案例代码><a class=headerlink href=#案例代码 title=案例代码></a>案例代码</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.math.BigDecimal;</span><br><span class=line><span class=keyword>import</span> java.util.ArrayList;</span><br><span class=line><span class=keyword>import</span> java.util.Date;</span><br><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.TimeUnit;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">FullGC_Problem01</span> {</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">CardInfo</span>{</span><br><span class=line>        <span class=type>BigDecimal</span> <span class=variable>bigDecimal</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">BigDecimal</span>(<span class=number>0.0</span>);</span><br><span class=line>        <span class=type>String</span> <span class=variable>name</span> <span class=operator>=</span> <span class=string>"ZhangSan"</span>;</span><br><span class=line>        <span class=type>int</span> <span class=variable>age</span> <span class=operator>=</span> <span class=number>18</span>;</span><br><span class=line>        <span class=type>Date</span> <span class=variable>birthdate</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Date</span>();</span><br><span class=line></span><br><span class=line>        <span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">m</span><span class=params>()</span>{}</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>ScheduledThreadPoolExecutor</span> <span class=variable>executor</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class=number>50</span>, <span class=keyword>new</span> <span class="title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy());</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> Exception{</span><br><span class=line>        executor.setMaximumPoolSize(<span class=number>50</span>);</span><br><span class=line>        <span class=keyword>for</span> (;;){</span><br><span class=line>            modelFit();</span><br><span class=line>            Thread.sleep(<span class=number>100</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">modelFit</span><span class=params>()</span>{</span><br><span class=line>        List&LTCardInfo> taskList = getAllCardInfo();</span><br><span class=line>        taskList.forEach(info -> {</span><br><span class=line>            executor.scheduleWithFixedDelay(() -> {</span><br><span class=line>                info.m();</span><br><span class=line>            }, <span class=number>2</span>, <span class=number>3</span>, TimeUnit.SECONDS);</span><br><span class=line>        });</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> List&LTCardInfo> <span class="title function_">getAllCardInfo</span><span class=params>()</span>{</span><br><span class=line>        List&LTCardInfo> taskList = <span class=keyword>new</span> <span class="title class_">ArrayList</span><>();</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < <span class=number>100</span>; i++){</span><br><span class=line>            <span class=type>CardInfo</span> <span class=variable>ci</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">CardInfo</span>();</span><br><span class=line>            taskList.add(ci);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> taskList;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h4 id=排查过程><a class=headerlink href=#排查过程 title=排查过程></a>排查过程</h4><p><strong>1）运行测试程序</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>java -Xms200m -Xmx200m -XX:+PrintGC -XX:+HeapDumpOnOutOfMemoryError FullGC_Problem01</span><br></pre></table></figure><p><strong>2）查看CPU占用，拿到占比较高的进程ID。</strong><p>通过命令 top 查找耗费CPU最高的进程PID，比如3568。<p><strong>3）找到CPU占用最高的线程ID，查看线程运行情况。</strong><ol><li>通过命令<code>top -Hp 3568</code>查找当前进程中耗费CPU最高的线程PID，比如1374；<li>通过命令<code>printf "%x\n" 1374</code>可以把线程PID转为16进制，比如转换后得到 55e；<li>通过命令<code>jstack 3568 | grep -20 55e</code>查找当前线程阻塞的位置；</ol><p><strong>4）查看线程运行情况</strong>：执行<code>jinfo pid</code>命令。<p><strong>5）观察GC执行情况。</strong><p>通过命令<code>jstat -gc PID</code> 观察gc动态情况，阅读GC日志发现频繁GC，arthas观察，jconsole，jvisualVM，Jprofiler（最好用）。<p>通过命令<code>jstat -gc 4655 500</code>实现每500毫秒打印一次GC情况。<blockquote><p>注意：图形界面监控一般适用于测试阶段，线上系统监控一般使用命令行调式工具——cmdline、Arthas。</blockquote><p><strong>6）查看对象创建的数量。</strong><p>通过命令<code>jmap -histo pid | head -20</code>查看对象创建数量排名前20的对象信息。<p><strong>7）导出dump信息文件。</strong><p>通过命令<code>jmap -dump:format=b,file=D:\test\heap.hprof 6956</code>将当前堆栈信息导出到一个文件中。<blockquote><p>线上系统，内存特别大，jmap执行期间会对进程产生很大影响，甚至卡顿（电商不适合）<ol><li>设定参数HeapDump，OOM的时会自动产生堆转储文件（不是很专业，因为多有监控，内存增长就会报警。<li>多服务器备份（高可用），停掉这台服务器对其他服务器不影响。<li>在线定位(一般小点儿公司用不到)。<li>在测试环境中压测（产生类似内存增长问题，在堆还不是很大的时候进行转储）。</ol></blockquote><p><strong>8）重新运行测试程序。</strong><p><code>java -Xms20M -Xmx20M -XX:+UseParallelGC -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/opt/test_jvm/gc_out/ FullGC_Problem01</code><p><strong>9）分析dump文件。</strong><p>使用<code>MAT、jhat、jvisualvm</code>工具来分析dump文件。<p>执行命令<code>jhat -J-Xmx512M xxx.hprof</code>后会在7000端口开启一个服务，通过浏览器可以访问该服务并对其执行相关操作，比如可以使用OQL查找特定问题对象。<p><strong>10）找出代码问题。</strong><h2 id=3-7、GC日志详解><a class=headerlink href=#3-7、GC日志详解 title=3.7、GC日志详解></a>3.7、GC日志详解</h2><h3 id=3-7-1、准备><a class=headerlink href=#3-7-1、准备 title=3.7.1、准备></a>3.7.1、准备</h3><p>测试代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.LinkedList;</span><br><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">HelloGC</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        System.out.println(<span class=string>"HellGC."</span>);</span><br><span class=line>        <span class=type>List</span> <span class=variable>list</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">LinkedList</span>();</span><br><span class=line>        <span class=keyword>for</span> (;;){</span><br><span class=line>            <span class=type>byte</span>[] b = <span class=keyword>new</span> <span class="title class_">byte</span>[<span class=number>1024</span> * <span class=number>1024</span>];</span><br><span class=line>            list.add(b);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>测试一：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令</span></span><br><span class=line>java -XX:+PrintCommandLineFlags HelloGC</span><br><span class=line></span><br><span class=line><span class=comment># 输出</span></span><br><span class=line>-XX:InitialHeapSize=29592512 -XX:MaxHeapSize=473480192 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops </span><br><span class=line>HelloGC</span><br><span class=line>Exception <span class=keyword>in</span> thread <span class=string>"main"</span> java.lang.OutOfMemoryError: Java heap space at HelloGC.main(HelloGC.java:9)</span><br></pre></table></figure><p>测试二：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令</span></span><br><span class=line>java -Xmn10M -Xms40M -Xmx60M -XX:+PrintCommandLineFlags -XX:+PrintGC HelloGC PrintGCDetails PrintGCTimeStamps PrintGCCauses</span><br><span class=line></span><br><span class=line><span class=comment># 输出</span></span><br><span class=line>-XX:InitialHeapSize=41943040 -XX:MaxHeapSize=62914560 -XX:MaxNewSize=10485760 -XX:NewSize=10485760 -XX:+PrintCommandLineFlags -XX:+PrintGC -XX:+UseCompressedClassPointers -XX:+UseCompressedOops </span><br><span class=line>HelloGC</span><br><span class=line>[GC (Allocation Failure)  7675K->7426K(39936K), 0.0065081 secs]</span><br><span class=line>[GC (Allocation Failure)  14756K->14594K(39936K), 0.0066781 secs]</span><br><span class=line>[GC (Allocation Failure)  21916K->21762K(39936K), 0.0082077 secs]</span><br><span class=line>[GC (Allocation Failure)  29086K->28931K(39936K), 0.0062089 secs]</span><br><span class=line>[GC (Allocation Failure)  36256K->36099K(45076K), 0.0077737 secs]</span><br><span class=line>[Full GC (Allocation Failure)  36099K->36098K(45076K), 0.0023287 secs]</span><br><span class=line>[GC (Allocation Failure)  43424K->43266K(60416K), 0.0068826 secs]</span><br><span class=line>[GC (Allocation Failure)  50592K->50434K(60416K), 0.0075865 secs]</span><br><span class=line>[Full GC (Allocation Failure)  57761K->57603K(60416K), 0.0027358 secs]</span><br><span class=line>[Full GC (Allocation Failure)  57603K->57591K(60416K), 0.0022941 secs]</span><br><span class=line>Exception <span class=keyword>in</span> thread <span class=string>"main"</span> java.lang.OutOfMemoryError: Java heap space at HelloGC.main(HelloGC.java:9)</span><br></pre></table></figure><p>测试三：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令</span></span><br><span class=line>java -XX:+UseConcMarkSweepGC -XX:+PrintCommandLineFlags HelloGC</span><br><span class=line></span><br><span class=line> <span class=comment># 输出</span></span><br><span class=line>-XX:InitialHeapSize=29592512 -XX:MaxHeapSize=473480192 -XX:MaxNewSize=87244800 -XX:MaxTenuringThreshold=6 -XX:OldPLABSize=16 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC </span><br><span class=line>HelloGC</span><br><span class=line>Exception <span class=keyword>in</span> thread <span class=string>"main"</span> java.lang.OutOfMemoryError: Java heap space at HelloGC.main(HelloGC.java:9)</span><br></pre></table></figure><h3 id=3-7-2、示例日志1><a class=headerlink href=#3-7-2、示例日志1 title=3.7.2、示例日志1></a>3.7.2、示例日志1</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>[GC (Allocation Failure) [DefNew (promotion failed) : 123228K->138592K(138816K), <span class=number>0.0698705</span> secs][Tenured: 308488K->308488K(308608K), <span class=number>0.0097199</span> secs] 360036K->359693K(447424K), </span><br><span class=line>[Metaspace: 2500K->2500K(1056768K)], <span class=number>0.0796660</span> secs] </span><br><span class=line>[Times: user=<span class=number>0.02</span> sys=<span class=number>0.06</span>, real=<span class=number>0.07</span> secs]</span><br></pre></table></figure><ul><li>GC：指YGC。<li>(Allocation Failure)：GC原因。<li>DefNew：产生的年代，这里是年轻代；后面的：123228K->138592K(138816K), 0.0698705 secs，其从左到右分别代表：回收前年轻代大小->回收后年轻代大小(整个年轻代的大小)，回收所消耗的时间；<li>[Tenured: 308488K->308488K(308608K), 0.0097199 secs]：从左到右分别代表：回收前堆大小->回收后堆大小(整个堆的大小)，回收消耗的时间。<li>[Metaspace: 2500K->2500K(1056768K)], 0.0796660 secs]：从左到右分别代表：回收前元空间大小->回收后大小(整个元空间的大小)，回收消耗的时间。<li>[Times: user=0.02 sys=0.06, real=0.07 secs]：从左到右分别代表：用户态消耗的时间、内核态消耗的时间，整个过程实际消耗多长时间。</ul><h3 id=3-7-3、示例日志2><a class=headerlink href=#3-7-3、示例日志2 title=3.7.3、示例日志2></a>3.7.3、示例日志2</h3><p>一旦内存溢出，就会把整个堆 heap dump出来：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>Heap</span><br><span class=line> def <span class=keyword>new</span> <span class="title class_">generation</span>   total 138816K, used 138753K [<span class=number>0x00000000e3c00000</span>, <span class=number>0x00000000ed2a0000</span>, <span class=number>0x00000000ed2a0000</span>)</span><br><span class=line>  eden space 123392K, <span class=number>100</span>% used [<span class=number>0x00000000e3c00000</span>, <span class=number>0x00000000eb480000</span>, <span class=number>0x00000000eb480000</span>)</span><br><span class=line>  from space 15424K,  <span class=number>99</span>% used [<span class=number>0x00000000ec390000</span>, <span class=number>0x00000000ed290478</span>, <span class=number>0x00000000ed2a0000</span>)</span><br><span class=line>  to   space 15424K,   <span class=number>0</span>% used [<span class=number>0x00000000eb480000</span>, <span class=number>0x00000000eb480000</span>, <span class=number>0x00000000ec390000</span>)</span><br><span class=line> tenured generation   total 308608K, used 308477K [<span class=number>0x00000000ed2a0000</span>, <span class=number>0x0000000100000000</span>, <span class=number>0x0000000100000000</span>)</span><br><span class=line>   the space 308608K,  <span class=number>99</span>% used [<span class=number>0x00000000ed2a0000</span>, <span class=number>0x00000000fffdf618</span>, <span class=number>0x00000000fffdf800</span>, <span class=number>0x0000000100000000</span>)</span><br><span class=line> Metaspace       used 2531K, capacity 4486K, committed 4864K, reserved 1056768K</span><br><span class=line>  <span class=keyword>class</span> <span class="title class_">space</span>    used 272K, capacity 386K, committed 512K, reserved 1048576K</span><br></pre></table></figure><ul><li><p>Metaspace used 2531K, capacity 4486K, committed 4864K, reserved 1056768K：2531K表示已使用；4486K表示总容量；4864K表示虚拟内存占用；1056768K表示虚拟内存保留容量。</p><li><p>total = eden + 一个survivor</p><li><p>年轻代大小加起来不相等？因为除了new的对象和年轻代外还有其他信息。观察日志主要看的是变化。</p></ul><h2 id=3-8、OOM问题案例><a class=headerlink href=#3-8、OOM问题案例 title=3.8、OOM问题案例></a>3.8、OOM问题案例</h2><h3 id=3-8-1、堆内存溢出><a class=headerlink href=#3-8-1、堆内存溢出 title=3.8.1、堆内存溢出></a>3.8.1、堆内存溢出</h3><p><strong>（1）创建了大且多的对象</strong><h3 id=3-8-2、方法区内存溢出><a class=headerlink href=#3-8-2、方法区内存溢出 title=3.8.2、方法区内存溢出></a>3.8.2、方法区内存溢出</h3><p><strong>（1）动态生成类</strong><h3 id=3-8-3、栈溢出><a class=headerlink href=#3-8-3、栈溢出 title=3.8.3、栈溢出></a>3.8.3、栈溢出</h3><p><strong>（1）递归深度多大</strong><h3 id=3-8-4、直接内存溢出><a class=headerlink href=#3-8-4、直接内存溢出 title=3.8.4、直接内存溢出></a>3.8.4、直接内存溢出</h3><p><strong>（1）NIO操作</strong><h3 id=3-8-5、其它><a class=headerlink href=#3-8-5、其它 title=3.8.5、其它></a>3.8.5、其它</h3><p><strong>（1）创建大量线程</strong><p><strong>（2）连接池多且大，且连接没有关闭</strong><p><strong>（3）第三方库问题，或使用不当造成</strong><h2 id=3-9、垃圾回收器调优><a class=headerlink href=#3-9、垃圾回收器调优 title=3.9、垃圾回收器调优></a>3.9、垃圾回收器调优</h2><h3 id=3-9-1、G1调优><a class=headerlink href=#3-9-1、G1调优 title=3.9.1、G1调优></a>3.9.1、G1调优</h3><p>触发FGC的情况如下：<p><strong>（1）并发模式失败</strong><p>G1启动标记周期，但在Mix GC之前，老年代就被填满，此时G1会放弃标记周期。这种情形下，需要增加堆大小，或者调整周期（例如增加线程数-XX:ConcGCThreads等）。<p><strong>（2）晋升失败或疏散失败</strong><p><strong>G1 GC时如果没有足够的内存供存活对象或晋升对象使用时会触发Full GC。可以在日志中看到（to-space exhausted）或者（to-space overflow）。</strong>解决该问题的方式如下：<ol><li>增加参数<code>-XX:G1ReservePercent</code>的值（并相应增加总的堆大小），为“目标空间”增加预留内存。<li>减少参数<code>-XX:InitiatingHeapOccupancyPercent</code>的值，提前启动标记周期。<li>增加参数<code>-XX:ConcGCThreads</code>的值，增加并行标记线程的数目。</ol><p><strong>（3）巨型对象分配失败</strong><p>当巨型对象找不到空闲空间分配时会触发Full GC来释放空间。这种情况下，应该避免分配大量的巨型对象，增加内存或者增大<code>-XX:G1HeapRegionSize</code>，使巨型对象不再是巨型对象。<h2 id=3-10、场景分析优化><a class=headerlink href=#3-10、场景分析优化 title=3.10、场景分析优化></a>3.10、场景分析优化</h2><h3 id=3-10-1、卡慢场景><a class=headerlink href=#3-10-1、卡慢场景 title=3.10.1、卡慢场景></a>3.10.1、卡慢场景</h3><p><strong>场景1</strong>：原服务器32位、1.5G内存堆，用户反馈慢。优化升级为64位、16G内存堆后，反馈更慢，反而不如从前。<p><strong>1）原网站为啥慢？</strong><p>多用户访问数据，故大量数据加载至内存，从而造成内存不足、频繁GC、STW长、响应时间慢等问题。<p><strong>2）为什么会卡顿？</strong><p>内存越大，FGC时间就会越长。<p><strong>3）如何应对？</strong><p>PS 更改为 PN + CMS 或者 G1。<h3 id=3-10-2、CPU消耗高问题><a class=headerlink href=#3-10-2、CPU消耗高问题 title=3.10.2、CPU消耗高问题></a>3.10.2、CPU消耗高问题</h3><p>场景1：系统CPU经常100%，如何调优？<p>解决方案参考如下：<ol><li>找出消耗CPU较高的进程；可使用 top 命令查看。<li>该进程中哪个线程消耗CPU较高；可使用 top -Hp 命令查看。<li>导出该线程的堆栈；可使用 jstack 命令实现。<li>查找哪个方法（栈帧）的导致的问题。<li>工作线程占比高 | 垃圾回收线程占比高。</ol><h3 id=3-10-3、内存消耗高问题><a class=headerlink href=#3-10-3、内存消耗高问题 title=3.10.3、内存消耗高问题></a>3.10.3、内存消耗高问题</h3><p>场景1：系统内存飙高，如何定位及应对？<p>参考解决方案如下：<ol><li>堆栈比较多，导出堆信息；可使用 jmap 命令实现。<li>通过工具分析，分析工具有：jhat、jvisualvm、mat、jprofiler等。</ol><h3 id=3-10-4、如何监控JVM><a class=headerlink href=#3-10-4、如何监控JVM title=3.10.4、如何监控JVM></a>3.10.4、如何监控JVM</h3><p>工具：jstat、jvisualvm、jprofiler、arthas、top。</div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/IP%E5%9B%BE%E8%A1%A8%E8%A7%A3%E6%9E%90/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/IP%E5%9B%BE%E8%A1%A8%E8%A7%A3%E6%9E%90/ itemprop=url>计算机系列-IP图表分析</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-06 22:13:51" datetime=2023-10-06T22:13:51+08:00 itemprop=dateModified>2023-10-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/ itemprop=url rel=index><span itemprop=name>计算机</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=IP基本认识><a class=headerlink href=#IP基本认识 title=IP基本认识></a>IP基本认识</h1><h2 id=IP作用><a class=headerlink href=#IP作用 title=IP作用></a>IP作用</h2><p><strong>IP 在 TCP/IP 参考模型中处于第三层，即⽹络层。⽹络层主要作⽤：实现主机之间的通信，也叫点对点（end to end）通信</strong>。<p><img alt=image-20210415201526742 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415201526742.png?token=AIGEF3IBSDVTZBJISBUOCC3EZZQHC><h2 id=IP与MAC关系><a class=headerlink href=#IP与MAC关系 title=IP与MAC关系></a>IP与MAC关系</h2><p><strong>MAC可以实现两个直连设备间的通信；IP可以实现两个无直连⽹络间的通信</strong>。<p>举个⽣活的栗⼦，⼩林要去⼀个很远的地⽅旅⾏，制定了⼀个⾏程表，其间需先后乘坐⻜机、地铁、公 交⻋才能抵达⽬的地，为此⼩林需要买⻜机票，地铁票等。⻜机票和地铁票都是去往特定的地点的，每张票只能够在某⼀限定区间内移动。<p><img alt=image-20210415202504342 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415202504342.png?token=AIGEF3IBSRHYSGRCHUUDKGTEZZQIU><p>同时要注意，如果⼩林只有⾏程表⽽没有⻋票，就⽆法搭乘交通⼯具到达⽬的地。相反，如果除了⻋票⽽没有⾏程表，恐怕也很难到达⽬的地。因为⼩林不知道该坐什么⻋，也不知道该在哪⾥换乘。<p>针对以上描述，可总结如下：<ul><li>此处的「区间内移动」就如同数据链路层。<li>区间内的出发点好⽐源 MAC 地址，⽬标地点好⽐⽬的 MAC 地址。<li>整个旅游⾏程表就相当于⽹络层。<li>⾏程的开始好⽐源 IP，⾏程的终点好⽐⽬的 IP 地址。<li>计算机⽹络中同时需要「数据链路层」和「⽹络层」两个分层才能实现与最终⽬标地址的通信。<li>在⽹络数据包传输中，源IP地址和⽬标IP地址不会变化，只有源 MAC 地址和⽬标 MAC ⼀直在变化。</ul><h1 id=IP地址基础知识><a class=headerlink href=#IP地址基础知识 title=IP地址基础知识></a>IP地址基础知识</h1><h2 id=IP地址定义><a class=headerlink href=#IP地址定义 title=IP地址定义></a>IP地址定义</h2><p>TCP/IP ⽹络通信时，为了保证正常通信，每个设备都需要配置正确的 IP 地址，否则⽆法实现正常通信。<p><strong>IP 地址（IPv4 地址）由 32 位正整数表示，IP 在计算机中是以⼆进制⽅式处理</strong>。 为了⽅便记忆采⽤了点分⼗进制的标记⽅式，也就是将 32 位 IP 地址以每 8 位为1组，共分为 4 组，每组以点隔开，再将每组转换成⼗进制。<p><img alt=image-20210415203544505 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415203544505.png?token=AIGEF3NLJYYBD5VDNBBQTHTEZZQKW><p>那么，IP 地址最⼤值为<code>2^32 = 4294967296</code>，也就是说最大允许43亿台计算机连接到网络。<p>实际上， IP 地址并非根据主机台数来配置，⽽是根据⽹卡来配置。<strong>IP 地址是由⽹络标识和主机标识两个部分组成</strong>，能够连接到⽹络的计算机个数很少。<blockquote><p>电脑配了 IP， ⼿机、IPad 等电⼦设备都配了 IP， 照理来说肯定会超过 43 亿啦，那是怎么能够⽀持这么多 IP 的呢？因为会根据⼀种可以更换 IP 地址的技术 NAT ，使得可连接计算机数超过 43 亿台。</blockquote><h2 id=IP地址分类><a class=headerlink href=#IP地址分类 title=IP地址分类></a>IP地址分类</h2><h3 id=IP地址类型><a class=headerlink href=#IP地址类型 title=IP地址类型></a>IP地址类型</h3><p><strong>IP 地址分为 5 种类型：A类、B类、C类、D类、E类</strong>。<p><img alt=image-20210415204302389 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415204302389.png?token=AIGEF3MRG4SAOL4EIUZ7TALEZZQMK><p>上图中⻩⾊部分为分类号，⽤以区分 IP 地址类别。<h3 id=A、B、C类型地址><a class=headerlink href=#A、B、C类型地址 title=A、B、C类型地址></a>A、B、C类型地址</h3><p><strong>A、B、C 类IP地址主要分两个部分：⽹络号和主机号</strong>。<p>A、B、C 分类地址的范围、最⼤主机个数如下：<p><img alt=image-20210415204603352 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415204603352.png?token=AIGEF3LROQ3FWAKUIANXEN3EZZQN2><p>最⼤主机数，就是看主机号的位数，如 C 类地址的主机号占 8 位，那么 C 类地址的最⼤主机个数为<code>2^8 - 2 = 254个</code><p>为什么要减 2 呢？ 因为IP 地址中有两 IP是特殊的，分别是主机号全为 1 和 全为 0 地址。<ul><li><strong>主机号全为1指的是某个⽹络下的所有主机，⽤于⼴播</strong>。<li><strong>主机号全为 0 指的是某个⽹络</strong>。</ul><h3 id=D、E类型地址><a class=headerlink href=#D、E类型地址 title=D、E类型地址></a>D、E类型地址</h3><p><strong>D 类和 E 类地址没有主机号，所以不可⽤于主机 IP，D 类常被⽤于多播，E 类是预留分类， 暂未使⽤</strong>。<p><img alt=image-20210415205817207 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415205817207.png?token=AIGEF3KWRVXXTJFBF2M32T3EZZQPC><p><strong>多播地址的作用是将包发送给特定组内的所有主机</strong>。<p>多播使⽤ D 类地址，其前四位是 1110 的就表示是多播地址，⽽剩下的 28 位是多播的组编号。<p>从 224.0.0.0 ~ 239.255.255.255 都是多播的可⽤范围，其划分为以下三类：<ul><li>224.0.0.0 ~ 224.0.0.255 为预留的组播地址，只能在局域⽹中，路由器是不会进⾏转发的。<li>224.0.1.0 ~ 238.255.255.255 为⽤户可⽤的组播地址，可以⽤于 Internet 上。<li>239.0.0.0 ~ 239.255.255.255 为本地管理组播地址，可供内部⽹使⽤，仅在特定的本地范围有效。</ul><h3 id=广播地址><a class=headerlink href=#广播地址 title=广播地址></a>广播地址</h3><p><strong>⼴播地址⽤于在同⼀个链路中相互连接的主机之间发送数据包</strong>。<p>当主机号全为 1 时，就表示该⽹络的⼴播地址。<p>⼴播地址可以分为本地⼴播和直接⼴播两种：<ul><li><strong>本⽹络内进行⼴播称为本地⼴播</strong></ul><p>例如⽹络地址为 192.168.0.0/24 的情况下，⼴播地址是 192.168.0.255 。因为这个⼴播地址的 IP 包会被路由器屏蔽，所以不会到达 192.168.0.0/24 以外的 其他链路上。<ul><li><strong>不同⽹络之间进行⼴播称为直接⼴播</strong></ul><p>例如⽹络地址为 192.168.0.0/24 的主机向 192.168.1.255/24 的⽬标地址发送 IP 包。收到这个包的路由器，将数据转发给 192.168.1.0/24，从⽽使得所有 192.168.1.1~192.168.1.254 的主机都能收到这个包（由于直接⼴播有⼀定的安全问题，多数情况 下会在路由器上设置为不转发。） 。<h3 id=IP地址分类优劣><a class=headerlink href=#IP地址分类优劣 title=IP地址分类优劣></a>IP地址分类优劣</h3><h4 id=优点><a class=headerlink href=#优点 title=优点></a>优点</h4><p>简单明了、选路（基于⽹络地址）简单，通过判断首位是0还是1就能 快速找出 ⽹络地址和主机地址。<p>其余分类判断⽅式参考如下：<p>第一位为：<ul><li>0：A类地址<li>1：第二位为：<ul><li>0：B类地址<li>1：第三位为：<ul><li>0：C类地址<li>1：第四位：<ul><li>0：D类地址<li>1：E类地址</ul></ul></ul></ul><h4 id=缺点><a class=headerlink href=#缺点 title=缺点></a>缺点</h4><ol><li>同一网络下没有地址层次。<li>A、B、C类不能很好与现实网络匹配。</ol><p>以上两个缺点都可以通过使用CIDR无分类地址来解决。<h2 id=CIDR（无分类IP地址）><a class=headerlink href=#CIDR（无分类IP地址） title=CIDR（无分类IP地址）></a>CIDR（无分类IP地址）</h2><h3 id=CIDR简介><a class=headerlink href=#CIDR简介 title=CIDR简介></a>CIDR简介</h3><p><strong>因IP分类存在许多缺点，所以提出⽆分类地址⽅案，即CIDR</strong>。<p><strong>CIDR不再分类地址，32 ⽐特的 IP 被划分为两部分：前⾯是⽹络号，后⾯是主机号</strong>。<h3 id=网络号和主机号划分><a class=headerlink href=#网络号和主机号划分 title=网络号和主机号划分></a>网络号和主机号划分</h3><p><strong>无分类地址格式为：a.b.c.d/x ，其中 /x 表示前 x 位属于⽹络号， x 的范围是 0 ~ 32 ，这使得 IP 地址更加灵活</strong>。<p>⽐如 10.100.122.2/24，就是无分类地址，/24 表示前 24 位是⽹络号，剩余的 8 位是主机号。<p><img alt=image-20210415211145547 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415211145547.png?token=AIGEF3MW3M2R7E7OPP4GDDLEZZQRA><p><strong>另⼀种划分⽹络号与主机号的方式是⼦⽹掩码，掩码就是掩盖掉主机号，剩下的是⽹络号</strong>。<p><strong>⼦⽹掩码和IP地址进行与运算可得到⽹络号</strong>。<p><img alt=image-20210415211234778 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415211234778.png?token=AIGEF3LH7MQRN5FCSP6MA5TEZZQSO><p><strong>为何划分网络号和主机号</strong><p>因为 两台计算机想通讯就得先判断是否处于同⼀个⼴播域内，即⽹络地址是否相同。如果⽹络地址相同，表明接受⽅在本⽹络上且可以把数据包直接发送到⽬标主机。<p>路由器寻址就是采用该方式来找到对应⽹络号，进⽽把数据包转发给对应⽹络。<p><img alt=image-20210415211525393 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415211525393.png?token=AIGEF3OOIFHUZG5TUUCS7C3EZZQT6><h3 id=子网划分><a class=headerlink href=#子网划分 title=子网划分></a>子网划分</h3><h4 id=何为子网划分><a class=headerlink href=#何为子网划分 title=何为子网划分></a>何为子网划分</h4><p><strong>⼦⽹掩码可以划分出⽹络号和主机号，还可划分⼦⽹</strong>。<p>⼦⽹划分实际上是将主机地址分为两个部分：⼦⽹⽹络地址 和 ⼦⽹主机地址。形式如下：<p><img alt=image-20210415211605113 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415211605113.png?token=AIGEF3OF4XRSSKC4YOE264TEZZQVG><ul><li>未做⼦⽹划分的 ip 地址：⽹络地址＋主机地址。<li>做⼦⽹划分后的 ip 地址：⽹络地址＋（⼦⽹⽹络地址＋⼦⽹主机地址）。</ul><h4 id=子网划分原理><a class=headerlink href=#子网划分原理 title=子网划分原理></a>子网划分原理</h4><p>假设对 C 类地址进⾏⼦⽹划分，⽹络地址 192.168.1.0，使⽤⼦⽹掩码 255.255.255.192 对其进⾏⼦⽹划分。<p>C 类地址中前 24 位是⽹络号，最后 8 位是主机号，根据⼦⽹掩码可知从 8 位主机号中借⽤ 2 位作为⼦⽹号。<p><img alt=image-20210415211738776 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415211738776.png?token=AIGEF3OS6ZLP5TWZTLUPFGTEZZQW6><p>由于⼦⽹⽹络地址被划分成 2 位，那么⼦⽹地址就有 4 个，分别是 00、01、10、11，具体划分如下图：<p><strong>子网0</strong><p><img alt=image-20210415211918539 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415211918539.png?token=AIGEF3IMMEMW2YLE2D7BTKTEZZQYI><p><strong>子网1</strong><p><img alt=image-20210415211943850 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415211943850.png?token=AIGEF3NSSLF5SWJLFMRDNCDEZZQZO><p><strong>子网2</strong><p><img alt=image-20210415212003104 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415212003104.png?token=AIGEF3L3DMCNVCSMHFSNBULEZZQ2Y><p><strong>子网3</strong><p><img alt=image-20210415212019344 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415212019344.png?token=AIGEF3LMLOBOWT7Z44SCGFLEZZQ4U><p>划分后的 4 个⼦⽹如下表格：<p><img alt=image-20210415212042823 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415212042823.png?token=AIGEF3OGGMZ55NXLKN4PIOLEZZQ56><h2 id=公有IP地址与私有IP地址><a class=headerlink href=#公有IP地址与私有IP地址 title=公有IP地址与私有IP地址></a>公有IP地址与私有IP地址</h2><h3 id=公私IP地址简介><a class=headerlink href=#公私IP地址简介 title=公私IP地址简介></a>公私IP地址简介</h3><p><strong>A、B、C 类地址中可分为公有 IP 地址和私有 IP 地址</strong>。<p><img alt=image-20210415212322287 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415212322287.png?token=AIGEF3LLTM5WE655PPH2TBDEZZQ7E><p>每个⼩区都有⾃⼰的楼编号和⻔牌号，你⼩区家可以叫 1 栋 101 号，我⼩区家也可以叫 1 栋 101，没有任何问题。但⼀旦出了⼩区，就需要带上中⼭路 666 号（公⽹ IP 地址），是国家统⼀分配 的，不能两个⼩区都叫中⼭路 666。<p>所以，公有 IP 地址是有个组织统⼀分配的，假设你要开⼀个博客⽹站，那么你就需要去申请购买⼀个 公有 IP，这样全世界的⼈才能访问。并且公有 IP 地址基本上要在整个互联⽹范围内保持唯⼀。<h3 id=公私IP地址管理机构><a class=headerlink href=#公私IP地址管理机构 title=公私IP地址管理机构></a>公私IP地址管理机构</h3><p><strong>私有 IP 地址通常由内部IT⼈员管理，公有IP由ICANN组织管理，中文叫互联⽹名称与数字地址分配机构</strong>。<p>IANA 是 ICANN中的⼀个机构，它负责分配互联⽹ IP 地址，是按州的⽅式层层分配。<p><img alt=image-20210415212554129 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415212554129.png?token=AIGEF3INVAPZ7KYF2BGKFUDEZZRAM><ul><li>ARIN 北美地区<li>LACNIC 拉丁美洲和⼀些加勒⽐群岛<li>RIPE NCC 欧洲、中东和中亚<li>AfriNIC ⾮洲地区<li>APNIC 亚太地区</ul><p><strong>国内IP由CNNIC机构管理，它是国内唯⼀指定的全局IP地址管理组织</strong>。<h2 id=IP地址与路由控制><a class=headerlink href=#IP地址与路由控制 title=IP地址与路由控制></a>IP地址与路由控制</h2><p><strong>IP地址的⽹络地址部分⽤于进⾏路由控制</strong>。<p>路由控制表中记录着⽹络地址与下⼀步应该发送⾄路由器的地址。在主机和路由器上都会有各⾃的路由器控制表。<p>发送 IP 包时 要先 确定 IP 包⾸部中的⽬标地址，再从路由控制表中找到与该地址具有相同⽹络地址的记录，根据该记录将 IP 包转发给相应的下⼀个路由器。如果路由控制表中存在多条相同⽹络地址 的记录，就选择相同位数最多的⽹络地址，也就是最⻓匹配。<p><img alt=image-20210415212845042 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415212845042.png?token=AIGEF3JRGQDXS5ZBBAVNZHDEZZRCI><ol><li>主机 A 要发送⼀个 IP 包，其源地址是 10.1.1.30 和⽬标地址是 10.1.2.10 ，由于没有在主机 A 的路由表找到与⽬标地址 10.1.2.10 的⽹络地址，于是包被转发到默认路由（路由器 1 ）。<li>路由器 1 收到 IP 包后，也在路由器 1 的路由表匹配与⽬标地址相同的⽹络地址记录，发现匹配 到了，于是就把 IP 数据包转发到了 10.1.0.2 这台路由器 2。<li>路由器 2 收到后，同样对⽐⾃身的路由表，发现匹配到了，于是把 IP 包从路由器 2 的 10.1.2.1 这个接⼝出去，最终经过交换机把 IP 数据包转发到了⽬标主机。</ol><h3 id=环回地址><a class=headerlink href=#环回地址 title=环回地址></a>环回地址</h3><p>环回地址 是在同⼀台计算机上的程序之间进⾏⽹络通信时所使⽤的默认地址。<p>计算机使⽤ 127.0.0.1 作为环回地址，与之相同的是主机名 localhost 。使⽤这个 IP 或主机名时，数据包不会流向⽹络。<h2 id=IP分片与重组><a class=headerlink href=#IP分片与重组 title=IP分片与重组></a>IP分片与重组</h2><p>每种数据链路的最⼤传输单元 MTU 都不相同，如 FDDI 数据链路 MTU 为 4352、以太⽹ MTU 为 1500 字节等。<p>每种数据链路的 MTU 之所以不同，是因为不同类型的数据链路 其 使⽤⽬的不同，故可承载的 MTU 也就不同。<p><strong>最常⻅的数据链路是以太⽹，它的 MTU 是 1500 字节</strong>。<p>当 IP 数据包⼤⼩⼤于 MTU 时， IP 数据包会被分⽚，分⽚后的 IP 数据包在被重组时，只能由⽬标主机进⾏，路由器不会进⾏重组。<p>假设发送⽅发送⼀个 4000 字节的⼤数据报，若要传输在以太⽹链路，则需要把数据报分⽚成 3 个⼩数 据报进⾏传输，再交由接收⽅重组成⼤数据报。<p><img alt=image-20210415213617493 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415213617493.png?token=AIGEF3PKCDQC4T4KGH7OOV3EZZRDQ><p>分⽚传输中，⼀旦某个分⽚丢失，会导致整个 IP 数据包作废，所以 TCP 引⼊了 MSS 也就是在 TCP 层进⾏分⽚而不在 IP 层分⽚，那么对于 UDP 我们尽量不要发送⼀个⼤于 MTU 的数据报⽂。<h2 id=IPV6基本认识><a class=headerlink href=#IPV6基本认识 title=IPV6基本认识></a>IPV6基本认识</h2><h3 id=IPV6简介><a class=headerlink href=#IPV6简介 title=IPV6简介></a>IPV6简介</h3><p>IPv4 地址是 32 位，⼤约有 43 亿个地址，但早在 2011 年 IPv4 地址就已经被分配完了。<p><strong>IPv6 地址是 128 位，可分配地址数量非常多，且还有更好的安全性和扩展性</strong>。<p>因IPv4 和 IPv6 不兼容，且IPV6要求电脑、手机要适配，也需要网络运营商的支持，所以ipv6普及较慢。<h3 id=IPV6亮点><a class=headerlink href=#IPV6亮点 title=IPV6亮点></a>IPV6亮点</h3><p>IPv6 除了地址多，还有很多其它亮点：<ol><li>IPv6可⾃动配置，即使<strong>没有DHCP服务器也可实现IP地址⾃动分配</strong>。<li>IPv6 包头包⾸部⻓度固定为40 字节，去掉了包头校验，简化了⾸部结构，减轻了路由器负荷，⼤⼤提⾼了传输性能。<li>IPv6 有<strong>防⽌线路窃听</strong>等功能，提升了安全性。</ol><h3 id=IPV6地址表示法><a class=headerlink href=#IPV6地址表示法 title=IPV6地址表示法></a>IPV6地址表示法</h3><p>IPv4 地址⻓度共 32 位，每 8 位作为⼀组，并⽤点分⼗进制的表示⽅式。<p><strong>IPv6 ⻓度 128 位，每 16 位为⼀组，每组⽤冒号隔开</strong>。<p><img alt=image-20210415213924099 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415213924099.png?token=AIGEF3NGU6KHIWBVZYN3B4TEZZREW><p>如果出现连续的0时还可以将这些 0 省略，并⽤两个冒号 「::」隔开。但是，⼀个 IP 地址中只允许出现⼀次两个连续的冒号。<p><img alt=image-20210415213947044 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415213947044.png?token=AIGEF3NLTJC54KGPO75DZITEZZRF2><h3 id=IPV6地址结构><a class=headerlink href=#IPV6地址结构 title=IPV6地址结构></a>IPV6地址结构</h3><p><strong>IPv6 类似 IPv4，同样采取IP地址前⼏位来标识 IP 地址的种类</strong>。<p>IPv6 地址主要有以下类型地址：<ul><li>单播地址，⽤于⼀对⼀的通信。<li>组播地址，⽤于⼀对多的通信。<li>任播地址，⽤于通信最近的节点，最近的节点是由路由协议决定。<li>没有⼴播地址。</ul><p><img alt=image-20210415214100341 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415214100341.png?token=AIGEF3IO2DLR7L53D6QTLSLEZZRHO><h3 id=IPV6单播地址类型><a class=headerlink href=#IPV6单播地址类型 title=IPV6单播地址类型></a>IPV6单播地址类型</h3><p>IPv6 地址主要分三类单播地址，每类地址有效范围都不同：<ul><li>同⼀链路单播通信，不经过路由器，可以使⽤链路本地单播地址，IPv4 没有此类型。<li>在内⽹⾥单播通信，可以使⽤唯⼀本地地址，相当于 IPv4 的私有 IP。<li>在互联⽹通信，可以使⽤全局单播地址，相当于 IPv4 的公有 IP。</ul><p><img alt=image-20210415214210802 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415214210802.png?token=AIGEF3NZH6JIPHBJQBXNYZLEZZRI6><h2 id=IPV4首部与IPV6首部><a class=headerlink href=#IPV4首部与IPV6首部 title=IPV4首部与IPV6首部></a>IPV4首部与IPV6首部</h2><p>IPv4 与 IPv6 ⾸部差异如下：<p><img alt=image-20210415214300627 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415214300627.png?token=AIGEF3JL3ZQSBAJ4BXGH7F3EZZRKE><p>IPv6 与 IPv4相比，其⾸部改进如下：<ol><li><strong>取消了⾸部校验和字段</strong>。因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。<li><strong>取消了分⽚/重新组装相关字段</strong>。分⽚与重组是耗时的过程，IPv6不允许在中间路由器进⾏分⽚与重组，这种操作只能在源与⽬标主机，这将⼤⼤提⾼路由器转发速度。<li><strong>取消选项字段</strong>。选项字段不再是标准 IP ⾸部的⼀部分，但它并没有消失，⽽是可能出现在 IPv6 ⾸部中的「下⼀个⾸部」指出的位置上。删除该选项字段使的 IPv6 的⾸部成为固定⻓度的 40 字 节。</ol><h1 id=IP协议相关技术><a class=headerlink href=#IP协议相关技术 title=IP协议相关技术></a>IP协议相关技术</h1><h2 id=DNS域名解析><a class=headerlink href=#DNS域名解析 title=DNS域名解析></a>DNS域名解析</h2><p>我们访问网站时，其网址通常是域名，而并非是IP地址，因为域名更便于理解和接受。<p>实现这⼀技术的就是 DNS 域名解析， DNS可将域名⽹址⾃动转换为 IP地址。<p>DNS 中的域名都是⽤点来分隔，⽐如<code>www.server.com</code> ，这⾥的点代表了不同层次之间的界限。<p><strong>域名中，越靠右的位置表示其层级越⾼，所以域名的层级关系类似⼀个树状结构</strong>：<ul><li>根 DNS 服务器<li>顶级域 DNS 服务器（com）<li>权威 DNS 服务器（server.com）</ul><p><img alt=image-20210415214715046 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415214715046.png?token=AIGEF3PW6RHL2TMR6FN4UQDEZZRLC><p>根域 DNS 服务器信息保存在互联⽹中的所有 DNS 服务器中。这样⼀来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器。<p>因此，客户端只要能够找到任意⼀台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再⼀路顺藤摸⽠找到位于下层的某台⽬标 DNS 服务器。<h3 id=域名解析流程><a class=headerlink href=#域名解析流程 title=域名解析流程></a>域名解析流程</h3><p>浏览器会先查自己的缓存，再查系统缓存，还没有就检查本机域名解析⽂件hosts ，如果还没有就会通过 DNS 服务器来查询。<p>DNS服务器查询过程如下：<ol><li>客户端⾸先会发出⼀个 DNS 请求，问 <a href=http://www.server.com/ rel=noopener target=_blank>www.server.com</a> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。<li>本地域名服务器收到客户端的请求后，如果缓存⾥的表格能找到 <a href=http://www.server.com,则它直接返回/ rel=noopener target=_blank>www.server.com，则它直接返回</a> IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“⽼⼤， 能告诉我 <a href=http://www.server.com/ rel=noopener target=_blank>www.server.com</a> 的 IP 地址吗？” 根域名服务器是最⾼层次的，它不直接⽤于域名解析，但能指明⼀条道路。<li>根 DNS 收到来⾃本地 DNS 的请求后，发现后置是 .com，说：“<a href=http://www.server.com/ rel=noopener target=_blank>www.server.com</a> 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址，你去问它吧。”<li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“⽼⼆， 你能告诉我 <a href=http://www.server.com/ rel=noopener target=_blank>www.server.com</a> 的 IP 地址吗？”<li>顶级域名服务器说：“我给你负责 <a href=http://www.server.com/ rel=noopener target=_blank>www.server.com</a> 区域的权威 DNS 服务器的地址，你去问它应该 能问到”。<li>本地 DNS 于是转向问权威 DNS 服务器：“⽼三，<a href=http://www.server.com对应的IP是啥呀？”>www.server.com对应的IP是啥呀？”</a> server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。<li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。<li>本地 DNS 再将 IP 地址返回客户端，客户端和⽬标建⽴连接。</ol><p>⾄此，我们完成了 DNS 解析过程。现在总结⼀下，整个过程我画成了⼀个图。<p><img alt=image-20210415214931845 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415214931845.png?token=AIGEF3NVX3DKRC64RYSAHELEZZRMM><h2 id=ARP与RARP协议（网络接口层）><a class=headerlink href=#ARP与RARP协议（网络接口层） title=ARP与RARP协议（网络接口层）></a>ARP与RARP协议（网络接口层）</h2><h3 id=ARP协议><a class=headerlink href=#ARP协议 title=ARP协议></a>ARP协议</h3><p>在传输⼀个 IP 数据报时，确定了源 IP 地址和⽬标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下⼀跳。然⽽，⽹络层的下⼀层是数据链路层，所以我们还要知道「下⼀跳」的 MAC 地址。<p><strong>通过主机路由表可找到下⼀跳 IP 地址，根据 IP地址 和 ARP 协议，可得知下⼀跳 MAC 地址</strong>。<p>ARP 如何知道对⽅MAC地址呢？<p><strong>ARP借助ARP请求与ARP响应两种类型的包来确定MAC地址</strong>。<p><img alt=image-20230805101102458 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805101102458.png?token=AIGEF3JXOV3NUCG7MPNDC33EZZRNY><ul><li><strong>主机会通过⼴播发送 ARP 请求，这个包中包含了想要知道 MAC 地址的主机 IP 地址</strong>。<li>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包⾥的内容，如果 ARP 请求包中的⽬标 IP 地址与⾃⼰的 IP 地址⼀致，那么这个设备就将⾃⼰的 MAC 地址塞⼊ ARP 响应包返回给主机。</ul><p><strong>操作系统通常会把第⼀次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中拿</strong>。<p><font color=red>注意：MAC 地址缓存有时间限制，超过限定时间将清除已缓存内容。</font><h3 id=RARP协议><a class=headerlink href=#RARP协议 title=RARP协议></a>RARP协议</h3><p><strong>ARP 协议是已知 IP 地址求 MAC 地址， RARP 则是已知 MAC 地址求 IP 地址</strong>。例如 将打印机服务器等⼩型嵌⼊式设备接⼊到⽹络时就经常会⽤得到。<p>通常需要架设⼀台 RARP 服务器，在这个服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接⼊到⽹络，接着：<ul><li>该设备会发送⼀条「我的 MAC 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。<li>RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个设备。</ul><p>最后，设备会从 RARP 服务器所收到的应答信息中找到IP地址并进行设置。<p><img alt=image-20210415215304596 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415215304596.png?token=AIGEF3PFAKEMEZ6GJ2PNKLTEZZRPE><h2 id=DHCP动态获取IP地址><a class=headerlink href=#DHCP动态获取IP地址 title=DHCP动态获取IP地址></a>DHCP动态获取IP地址</h2><p>我们的电脑通常都是通过 DHCP 动态获取 IP 地址，⼤⼤省去了配 IP 信息繁琐的过程。<p>接下来，我们来看看电脑是如何通过 4 个步骤获取到 IP。<p><font color=red>注意：DHCP 客户端进程监听的是 68 端⼝号，DHCP 服务端进程监听的是 67 端⼝号。</font><p>4 个步骤如下：<ol><li>客户端⾸先发起 DHCP 发现报⽂（DHCP DISCOVER） 的 IP 数据报，由于客户端没有 IP 地址， 也不知道 DHCP 服务器的地址，所以使⽤的是 UDP ⼴播通信，其使⽤的⼴播⽬的地址是 255.255.255.255（端⼝ 67） 并且使⽤ 0.0.0.0（端⼝ 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，然后链路层将帧⼴播到⽹络中的所有设备。<li>DHCP 服务器收到 DHCP 发现报⽂时，⽤ DHCP 提供报⽂（DHCP OFFER） 向客户端做出响应。该报⽂仍然使⽤ IP ⼴播地址 255.255.255.255，该报⽂信息携带服务器提供可租约的 IP 地址、⼦⽹掩码、默认⽹关、DNS 服务器以及 IP 地址租⽤期。<li>客户端收到⼀个或多个服务器的 DHCP 提供报⽂后，从中选择⼀个服务器，并向选中的服务器发送 DHCP 请求报⽂（DHCP REQUEST进⾏响应，回显配置的参数。<li>最后，服务端⽤ DHCP ACK 报⽂对 DHCP 请求报⽂进⾏响应，应答所要求的参数。</ol><p>⼀旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租⽤期内使⽤ DHCP 服务器分配的 IP 地址。<p>如果租约的 DHCP IP 地址快过期了，客户端会向服务器发送 DHCP 请求报⽂：<ul><li>服务器如果同意继续租⽤，则⽤ DHCP ACK 报⽂进⾏应答，客户端就会延⻓租期。<li>服务器如果不同意继续租⽤，则⽤ DHCP NACK 报⽂，客户端就要停⽌使⽤租约的 IP 地址。</ul><p>可以发现，<strong>DHCP 交互中，全程都是使⽤ UDP ⼴播通信</strong>。<p>如果 DHCP 服务器和客户端不是在同⼀个局域⽹内，路由器⼜不会转发⼴播包，那不是每个⽹络都要配⼀个 DHCP 服务器？ 为解决该问题，出现了<strong>DHCP 中继代理</strong>。 有了 DHCP 中继代理以后，对不同⽹段的 IP 地址分配可以由⼀个 DHCP 服务器统⼀进⾏管理。<p><img alt=image-20210415220738058 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415220738058.png?token=AIGEF3M4XEWKNO7CH3ICLN3EZZRQC><ul><li>DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，⽽ DHCP 中继代理在收到这个⼴播包以后，再以单播的形式发给 DHCP 服务器。<li>服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包⼴播给 DHCP 客户端 。</ul><p>因此，DHCP 服务器即使不在同⼀个链路上也可以实现统⼀分配和管理IP地址。<h2 id=NAT（网络地址转换）><a class=headerlink href=#NAT（网络地址转换） title=NAT（网络地址转换）></a>NAT（网络地址转换）</h2><h3 id=NAT作用><a class=headerlink href=#NAT作用 title=NAT作用></a>NAT作用</h3><p>IPv4 地址紧缺，故提出了 ⽹络地址转换方案 NAT，作用就是： <strong>将私有IP地址转换成公有IP地址</strong>。<p><img alt=image-20210415220931123 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415220931123.png?token=AIGEF3K22S7HJNVL27DCCADEZZRRC><p>思考：若这样，那不是 N 个私有 IP 地址，就需要 N 个公有 IP 地址？这怎么就缓解 IPv4 地址耗尽问题？<p>确实是， 普通 NAT转换没什么意义。<strong>由于绝⼤多数⽹络应⽤都使⽤传输层协议 TCP 或 UDP 来传输数据。 因此可以把 IP 地址 + 端⼝号⼀起进⾏转换，这种转换技术叫 ⽹络地址与端⼝转换 NAPT</strong>。<p>很抽象？来，看下⾯的图解就能瞬间明⽩了。<p><img alt=image-20210415221031683 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415221031683.png?token=AIGEF3IKC3ZSXCNDBMPTHTDEZZRSG><p>图中有两个客户端 192.168.1.10 和 192.168.1.11 同时与服务器 183.232.231.172 进⾏通信，且两个客户端本地端⼝都是 1025。此时，两个私有 IP 地址将转换为公有地址 120.229.175.121，但是以不同的端⼝号作为区分。<p>于是，⽣成⼀个 NAPT 路由器转换表，就可以正确转换 地址与端⼝组合，令客户端 A、B 能同时与服务器之间进⾏通信。<p>这种转换表在 NAT 路由器上⾃动⽣成。例如，建⽴ TCP 连接⾸次握⼿时的 SYN 包 ⼀经发出，就会⽣成这个表。⽽后⼜随着收到关闭连接时发出 FIN 包的确认应答而从表中删除。<h3 id=NAT缺陷><a class=headerlink href=#NAT缺陷 title=NAT缺陷></a>NAT缺陷</h3><p>因为 NAT/NAPT 依赖⾃⼰的转换表，因此会有以下问题：<ol><li>外部⽆法主动与 NAT 内部服务器建⽴连接，因为 NAPT 转换表没有转换记录。<li>转换表的⽣成与转换操作都会产⽣性能开销。<li>通信过程中，如果 NAT 路由器重启了，所有TCP 连接都将被重置。</ol><h3 id=如何解决缺陷><a class=headerlink href=#如何解决缺陷 title=如何解决缺陷></a>如何解决缺陷</h3><ol><li><p>改用IPV6：IPv6 可⽤范围⾮常⼤，每台设备都可配置⼀个公有 IP 地址，但 IPv6 普及还需要时间。</p><li><p>NAT穿透技术</p> <p><font color=orange>NAT 穿透技术能够让⽹络应⽤程序主动发现⾃⼰位于 NAT 设备之后，并会主动获得 NAT 设备的公有 IP，并为⾃⼰建⽴端⼝映射条⽬，注意这些都由 NAT设备后的应⽤程序⾃动完成。</font></p></ol><p>也就是说，在 NAT 穿透技术中，NAT设备后的应⽤程序处于主动地位，它已经明确地知道 NAT 设备要修改它外发的数据包，于是它主动配合 NAT 设备的操作，主动地建⽴好映射，这样就减少了NAT设备的工作。<p>说⼈话，就是客户端主动从 NAT 设备获取公网 IP 地址，然后⾃⼰建⽴端⼝映射条⽬，然后⽤这个条⽬ 对外通信，就不需要 NAT 设备来进⾏转换了。<h2 id=ICMP（互联网控制报文协议-网络层）><a title="ICMP（互联网控制报文协议 / 网络层）" class=headerlink href=#ICMP（互联网控制报文协议-网络层）></a>ICMP（互联网控制报文协议 / 网络层）</h2><h3 id=ICMP简介><a class=headerlink href=#ICMP简介 title=ICMP简介></a>ICMP简介</h3><p><strong>ICMP全称是Internet Control Message Protocol，也叫互联⽹控制报⽂协议</strong>。<p>⾥⾯有个关键词 —— 控制，如何控制呢？<p>⽹络包 在 复杂⽹络传输中 会遇到各种问题。 当遇到问题时 需要 传出消息 并 报告异常问题，这样可以 调整传输策略 来控制 整个局⾯。<h3 id=ICMP功能><a class=headerlink href=#ICMP功能 title=ICMP功能></a>ICMP功能</h3><p><strong>ICMP 主要功能包括：确认IP包是否成功送达⽬标地址、报告发送过程中IP包被废弃的原因和改善⽹络设置等</strong>。<p>在 IP 通信中如果某个 IP 包因为某种原因未能达到⽬标地址，那么这个具体的原因将由 ICMP 负责通知。<p><img alt=image-20210415221514890 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415221514890.png?token=AIGEF3PYUGAL34ICWISTU5LEZZRTM><p>如上图，主机 A发送数据包 给 主机B，但因为某些原因 导致 路由器 2 不能找到主机B，此时路由器 2 通过 IP 向主机 A 发送⼀个 ICMP ⽬标不可达数据包。<p><strong>ICMP通知消息会使⽤ IP 进⾏发送</strong>。<p>因此，从路由器 2 返回的 ICMP 包会按照往常的路由控制先经过路由器 1 再转发给主机 A 。收到该 ICMP 包的主机 A 则分解 ICMP 的⾸部和数据域以后得知具体发⽣问题的原因。<h3 id=ICMP类型><a class=headerlink href=#ICMP类型 title=ICMP类型></a>ICMP类型</h3><p>ICMP ⼤致可以分为两⼤类：<ul><li><strong>⽤于诊断的查询消息，也就是「查询报⽂类型」</strong>。<li><strong>通知出错原因的错误消息，也就是「差错报⽂类型」</strong>。</ul><p><img alt=image-20210415221644966 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415221644966.png?token=AIGEF3J4SSES4SWPSTY7A6LEZZRUQ><h2 id=IGMP（因特网组管理协议-网络层）><a title="IGMP（因特网组管理协议 / 网络层）" class=headerlink href=#IGMP（因特网组管理协议-网络层）></a>IGMP（因特网组管理协议 / 网络层）</h2><h3 id=IGMP简介><a class=headerlink href=#IGMP简介 title=IGMP简介></a>IGMP简介</h3><p>ICMP 与 IGMP ⼀点关系都没有，就好比 周杰 与 周杰伦 的区别。<p><strong>组播地址说的是只有在⼀组的主机才能收到数据包，那么如何确定是否在⼀个组呢？这需要 IGMP协议 来协助</strong>。<p><img alt=image-20210415221723705 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415221723705.png?token=AIGEF3MF22JJES33IHDA7EDEZZRVS><p><strong>IGMP 是因特⽹组管理协议，⼯作在主机（组播成员）和最后⼀跳路由之间</strong>，如上图中蓝⾊部分。<ul><li>IGMP 报⽂向路由器申请加⼊和退出组播组，默认情况下路由器不会转发组播包到连接中的主机，除⾮主机通过 IGMP 加⼊到组播组，主机申请加⼊到组播组时，路由器就会记录 IGMP 路由器表，路由器后续就会转发组播包到对应的主机了。<li>IGMP 报⽂采⽤ IP 封装，IP 头部的协议号为 2，⽽且 TTL 字段值通常为 1，因为 IGMP 是⼯作在主机与连接的路由器之间。</ul><h3 id=IGMP工作机制><a class=headerlink href=#IGMP工作机制 title=IGMP工作机制></a>IGMP工作机制</h3><p><strong>IGMP 分为三个版本，分别是：IGMPv1、IGMPv2、IGMPv3</strong>。<p>以 IGMPv2 为例，说说 常规查询与响应 和 离开组播组 这两个⼯作机制。<p><strong>常规查询与响应⼯作机制</strong><p><img alt=image-20210415221848921 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415221848921.png?token=AIGEF3J4AISZEC7SBUT4H5LEZZRWY><ol><li>路由器会周期性发送⽬的地址为 224.0.0.1 （表示同⼀⽹段内所有主机和路由器） IGMP 常规查询报⽂。<li>主机1 和 主机 3 收到这个查询，随后会启动「报告延迟计时器」，计时器的时间是随机的，通常是 0~10 秒，计时器超时后主机就会发送 IGMP 成员关系报告报⽂（源 IP 地址为⾃⼰主机的 IP 地 址，⽬的 IP 地址为组播地址）。如果在定时器超时之前，收到同⼀个组内的其他主机发送的成员关系报告报⽂，则⾃⼰不再发送，这样可以减少⽹络中多余的 IGMP 报⽂数量。<li>路由器收到主机的成员关系报⽂后，就会在 IGMP 路由表中加⼊该组播组，后续⽹络中⼀旦该组播 地址的数据到达路由器，它会把数据包转发出去。</ol><p><strong>离开组播组⼯作机制</strong><p><strong>离开组播组的情况一，⽹段中仍有该组播组</strong>：<p><img alt=image-20210415222033735 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415222033735.png?token=AIGEF3JE5ZCEGB2HNLAWDI3EZZRXY><ol><li>主机 1 要离开组 224.1.1.1，发送 IGMPv2 离组报⽂，报⽂的⽬的地址是 224.0.0.2（表示发向⽹段内的所有路由器）。<li>路由器 收到该报⽂后，以 1 秒为间隔连续发送 IGMP 特定组查询报⽂（共计发送 2 个），以便确认该⽹络是否还有 224.1.1.1 组的其他成员。<li>主机 3 仍然是组 224.1.1.1 的成员，因此它⽴即响应这个特定组查询。路由器知道该⽹络中仍然存在该组播组的成员，于是继续向该⽹络转发 224.1.1.1 的组播数据包。</ol><p><strong>离开组播组的情况⼆，⽹段中没有该组播组</strong>：<p><img alt=image-20210415222133007 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415222133007.png?token=AIGEF3LA2MJ4DXOOQZ7TRL3EZZRYU><ol><li>主机 1 要离开组播组 224.1.1.1，发送 IGMP 离组报⽂。<li>路由器收到该报⽂后，以 1 秒为间隔连续发送 IGMP 特定组查询报⽂（共计发送 2 个）。此时在该⽹段内，组 224.1.1.1 已经没有其他成员了，因此没有主机响应这个查询。<li>⼀定时间后，路由器认为该⽹段中已经没有 224.1.1.1 组播组成员了，将不会再向这个⽹段转发该组播地址的数据包。</ol></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/IO%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/IO%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ itemprop=url>计算机系列-IO</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-06 16:06:36" datetime=2023-10-06T16:06:36+08:00 itemprop=dateModified>2023-10-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/ itemprop=url rel=index><span itemprop=name>计算机</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、IO简介><a class=headerlink href=#1、IO简介 title=1、IO简介></a>1、IO简介</h1><h2 id=1-1、前言><a class=headerlink href=#1-1、前言 title=1.1、前言></a>1.1、前言</h2><p><strong>Linux 2.6以后，Java中NIO和AIO都通过epoll来实现，而Windows上的AIO是通过IOCP来实现</strong>。<p>Epoll 与 IOCP 区别如下：<ol><li>Epoll 适用于 Linux；而 IOCP 适用于 Windows；<li>Epoll 会在事件资源满足时发出可处理的通知消息；而 IOCP 会在事件完成时发出完成通知消息；<li>从应用程序角度来看， Epoll本质上是同步非阻塞，IOCP本质上则是异步操作；</ol><p>Java中的BIO、NIO和AIO就是对操作系统中各种IO模型的封装。程序员在使用相关API时，无需关心系统底层知识，无需编写不同的代码，可直接使用Java提供的API。<p><strong>Linux(UNIX)操作系统共有五种IO模型：阻塞IO模型、非阻塞IO模型、IO复用模型、信号驱动IO模型、异步IO模型</strong>。<h2 id=1-2、到底什么是IO><a class=headerlink href=#1-2、到底什么是IO title=1.2、到底什么是IO></a>1.2、到底什么是IO</h2><p>拿一次磁盘文件读取为例，<strong>IO就是把数据从硬件（硬盘）中读取到用户空间中的一个过程</strong>。<p>其实真正的文件读取还涉及到缓存等细节，这里不再展开。关于用户空间、内核空间以及硬件等的关系如果不理解的话，可以通过钓鱼的例子来帮助理解。<p>钓鱼过程：我们通过鱼竿将鱼从鱼塘中钓上来并放入鱼篓中。<p>其中的鱼塘就可以看成是磁盘，鱼钩可以映射成内核空间，鱼篓可以映射成用户空间。一次完整的钓鱼（IO）操作，是鱼（文件）从鱼塘（硬盘）中转移（拷贝）到鱼篓（用户空间）的过程。<p>对于一个network IO (以read举例)，它会涉及到两个系统对象：一个是调用IO的进程，另一个就是系统内核(kernel)。<p>对于一次IO访问（以read举例），数据先拷贝至系统内核的缓冲区中，然后再拷贝到应用程序的地址空间。所以，一个read操作会经历两个阶段：<ul><li>**阶段1：等待数据准备 (Waiting for the data to be ready)**。<li>**阶段2： 将数据 从内核 拷贝到 进程中 (Copying the data from the kernel to the process)**。</ul><p>因为这两个阶段，linux系统生成了五种网络模式：<ul><li>阻塞 I/O（blocking IO）<li>非阻塞 I/O（nonblocking IO）<li>信号驱动 I/O（ signal driven IO）<li>I/O 多路复用（ IO multiplexing）<li>异步 I/O（asynchronous IO）</ul><h2 id=1-3、阻塞IO模型（同步）><a class=headerlink href=#1-3、阻塞IO模型（同步） title=1.3、阻塞IO模型（同步）></a>1.3、阻塞IO模型（同步）</h2><p>钓鱼的时候，有一种方式比较惬意，比较轻松，那就是我们坐在鱼竿面前，这个过程中我们什么也不做，双手一直把着鱼竿，就静静的等着鱼儿咬钩。一旦手上感受到鱼的力道，就把鱼钓起来放入鱼篓中。然后再钓下一条鱼。<p>映射到Linux操作系统中，这就是一种最简单的IO模型，即阻塞IO。 阻塞 I/O 是最简单的 I/O 模型，一般表现为进程或线程等待某个条件，如果条件不满足，则一直等下去。直到条件满足再进行下一步操作。<p>这种钓鱼方式相对来说比较简单，对于钓鱼的人来说，不需要什么特制的鱼竿，拿一根够长的木棍就可以悠闲的开始钓鱼了（实现简单）。缺点就是比较耗费时间，比较适合那种对鱼的需求量小的情况（并发低，时效性要求低）。<p><img alt=image-20200927130712324 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200927130712324.png?token=AIGEF3OVLUK27RBL6SLEFTLEZZV3U><p>如上图，当用户进程执行了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整 个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除 block的状态，重新运行起来。<h2 id=1-4、非阻塞IO模型（同步）><a class=headerlink href=#1-4、非阻塞IO模型（同步） title=1.4、非阻塞IO模型（同步）></a>1.4、非阻塞IO模型（同步）</h2><p>我们钓鱼的时候，在等待鱼儿咬钩的过程中，我们可以做点别的事情，比如玩一把王者荣耀、看一集《延禧攻略》等等。但是，我们要时不时的去看一下鱼竿，一旦发现有鱼儿上钩了，就把鱼钓上来。<p>映射到Linux操作系统中，这就是非阻塞的IO模型。应用进程与内核交互，目的未达到之前，不再一味的等着，而是直接返回。然后通过轮询的方式，不停的去问内核数据有没有准备好。如果某一次轮询发现数据已经准备好了，那就把数据拷贝到用户空间中。<p>这种方式钓鱼，和阻塞IO比，所使用的工具没有什么变化，但是钓鱼的时候可以做些其他事情，增加时间的利用率。<p><img alt=image-20200927131236060 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200927131236060.png?token=AIGEF3JJN3JOM6PIKPPGUA3EZZV4U><p>从上图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。 从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次 发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。<p>所以，用户进程第一个阶段不是阻塞的，需要不断的主动询问kernel数据好了没有；第二个阶段依然是阻塞的。<h2 id=1-5、信号驱动模型（同步）><a class=headerlink href=#1-5、信号驱动模型（同步） title=1.5、信号驱动模型（同步）></a>1.5、信号驱动模型（同步）</h2><p>我们钓鱼的时候，为了避免自己一遍一遍的去查看鱼竿，我们可以给鱼竿安装一个报警器。当有鱼儿咬钩的时候立刻报警。然后我们再收到报警后，去把鱼钓起来。<p>映射到Linux操作系统中，这就是信号驱动IO。应用进程在读取文件时通知内核，如果某个 socket 的某个事件发生时，请向我发一个信号。在收到信号后，信号对应的处理函数会进行后续处理。<p>这种方式钓鱼，和前几种相比，所使用的工具有了一些变化，需要有一些定制（实现复杂）。但是钓鱼的人就可以在鱼儿咬钩之前彻底做别的事儿去了。等着报警器响就行了。<p><img alt=image-20200927132311222 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200927132311222.png?token=AIGEF3NL6VRYEYFRUKUQF6TEZZV5Y><p>据上图所示，用户进程预先向内核注册一个信号处理函数，然后用户进程返回，并且不阻塞，当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝的用户空间中。<h2 id=1-6、IO多路复用模型（同步）><a class=headerlink href=#1-6、IO多路复用模型（同步） title=1.6、IO多路复用模型（同步）></a>1.6、IO多路复用模型（同步）</h2><p>我们钓鱼的时候，为了保证可以最短的时间钓到最多的鱼，我们同一时间摆放多个鱼竿，同时钓鱼。然后哪个鱼竿有鱼儿咬钩了，我们就把哪个鱼竿上面的鱼钓起来。映射到Linux操作系统中，这就是IO复用模型。多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。<p><strong>IO multiplexing（IO多路复用）就是常说的select，poll，epoll，有时也称为event driven IO</strong>。IO复用同非阻塞IO本质一样，不过利用了新的select系统调用，由内核来负责本来是请求进程该做的轮询操作。看似比非阻塞IO还多了一个系统调用开销，不过因为可以支持多路IO，才算提高了效率。<p>这种通过 增加鱼竿 的方式，可有效提升效率。<p><img alt=image-20200927131649129 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200927131649129.png?token=AIGEF3OTZ73LT4QN6AP7KWLEZZV62><p>据上图可知，当用户进程调用了<code>select</code>，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个 socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。<p>select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。在IO multiplexing Model中，实际对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被 block的。只不过process是被select这个函数block，而不是被socket IO给block。<h2 id=1-7、异步IO模型（异步）><a class=headerlink href=#1-7、异步IO模型（异步） title=1.7、异步IO模型（异步）></a>1.7、异步IO模型（异步）</h2><p>钓鱼时采用一种高科技钓鱼竿，即全自动钓鱼竿。可以自动感应鱼上钩，自动收竿，更厉害的可以自动把鱼放进鱼篓里。然后，通知我们鱼已经钓到了，他就继续去钓下一条鱼去了。<p>映射到Linux操作系统中，这就是异步IO模型。应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。<p><img alt=image-20200927132414881 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200927132414881.png?token=AIGEF3LT4XPCFNCIGXH63A3EZZV7Y><p>如上图所示，用户进程发起<code>aio_read</code>操作之后，给内核传递描述符、缓冲区指针、缓冲区大小等，告诉内核当整个操作完成时，如何通知进程，然后就立刻去做其他事情了。当内核收到<code>aio_read</code>后，会立刻返回，然后内核开始等待数据准备，数据准备好以后，直接把数据拷贝到用户空间，然后再通知进程本次IO已经完成。<p>这种钓鱼方式，最省事，只需要交给鱼竿就可以了。<h2 id=1-8、总结><a class=headerlink href=#1-8、总结 title=1.8、总结></a>1.8、总结</h2><h3 id=1-8-1、前四种都是同步IO模型><a class=headerlink href=#1-8-1、前四种都是同步IO模型 title=1.8.1、前四种都是同步IO模型></a>1.8.1、前四种都是同步IO模型</h3><p>我们说阻塞IO模型、非阻塞IO模型、IO复用模型和信号驱动IO模型都是同步的IO模型。原因是因为，无论以上那种模型，真正的数据拷贝过程，都是同步进行。<p>信号驱动逻辑是：<strong>数据准备好之后内核会通知进程，然后进程通过<code>recvfrom</code>操作进行数据拷贝</strong>。可以认为数据准备阶段是异步的，数据拷贝操作是同步的。所以，整个IO过程不能认为是异步。<h3 id=1-8-2、五种-IO-模型对比><a title="1.8.2、五种 IO 模型对比" class=headerlink href=#1-8-2、五种-IO-模型对比></a>1.8.2、五种 IO 模型对比</h3><p><img alt=5种IO模型对比01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/5%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%9401.png?token=AIGEF3K7SADXDY2FIQ5EAUTEZZWBY><h1 id=2、IO多路复用><a class=headerlink href=#2、IO多路复用 title=2、IO多路复用></a>2、IO多路复用</h1><h2 id=2-1、必知知识><a class=headerlink href=#2-1、必知知识 title=2.1、必知知识></a>2.1、必知知识</h2><h3 id=2-1-1、用户空间和内核空间><a class=headerlink href=#2-1-1、用户空间和内核空间 title=2.1.1、用户空间和内核空间></a>2.1.1、用户空间和内核空间</h3><p><strong>32位操作系统的寻址空间（虚拟存储空间）为4G（2的32次方）</strong>。<p>操作系统核心是内核，可访问受保护的内存空间，也有访问底层硬件设备的所有权限。<p>为了限制进程直接操作内核（kernel），保证内核安全，操作系统将虚拟空间划分为两部分：<ul><li><p><strong>内核空间</strong>：linux系统中，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF）供内核使用，称为内核空间。</p><li><p><strong>用户空间</strong>：将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF）供进程使用，称为用户空间。</p></ul><h3 id=2-1-2、进程切换><a class=headerlink href=#2-1-2、进程切换 title=2.1.2、进程切换></a>2.1.2、进程切换</h3><p><strong>内核可以挂起正在CPU上运行的进程，也可以恢复被挂起的某个进程，这种行为被称为进程切换</strong>。任何进程的运行都依赖于操作系统内核的支持。<p>从一个进程的运行转到另一个进程上运行，其过程变化如下：<ol><li>保存处理机上下文，包括程序计数器和其他寄存器。<li>更新PCB信息。<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。<li>选择另一个进程执行，并更新其PCB。<li>更新内存管理的数据结构。<li>恢复处理机上下文。</ol><p>详情可参考这篇文章：<a href=http://guojing.me/linux-kernel-architecture/posts/process-switch/ rel=noopener target=_blank>进程切换</a><h3 id=2-1-3、进程阻塞><a class=headerlink href=#2-1-3、进程阻塞 title=2.1.3、进程阻塞></a>2.1.3、进程阻塞</h3><p>正在执行的进程，若期待的某些事件未发生，则系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。<p>进程的阻塞是进程自身的一种主动行为，只有运行态的进程才能转为阻塞状态。阻塞状态下的进程不消耗CPU资源。<h3 id=2-1-4、文件描述符FD><a class=headerlink href=#2-1-4、文件描述符FD title=2.1.4、文件描述符FD></a>2.1.4、文件描述符FD</h3><h4 id=简介><a class=headerlink href=#简介 title=简介></a>简介</h4><p><strong>文件描述符（File descriptor）是计算机科学中的一个术语，是一个表述文件引用的抽象化概念</strong>。<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核会向进程返回一个文件描述符。<p><font color=red>注意：偏底层应用程序的设计通常会与文件描述符打交道，但要注意的是，文件描述符仅与Unix、Linux系统有关。</font><h4 id=文件描述符原理><a class=headerlink href=#文件描述符原理 title=文件描述符原理></a>文件描述符原理</h4><p>系统为了维护文件描述符建立了3张表：<ul><li><p><strong>进程级文件描述符表</strong></p> <p>主要记录了以下两项内容：</p> <ol><li>文件描述符标志。<li>文件指针（open file handle）。</ol><li><p><strong>系统级文件描述符表</strong></p> <p>记录内容如下：</p> <ol><li>当前文件偏移量。<li>状态标识。<li>文件访问模式（读、写、读和写）。<li>对该文件i-nod对象的引用。<li>文件类型（常规文件、套接字、FIFO….）。<li>访问权限。<li>一个指向该文件所持有的索引表的指针。<li>文件的各种属性。<li>与信号驱动相关设置。</ol><li><p><strong>文件系统i-node表</strong></p> <p>记录内容如下：</p> <ol><li>文件类型。<li>文件锁。</ol></ul><h4 id=文件描述符限制><a class=headerlink href=#文件描述符限制 title=文件描述符限制></a>文件描述符限制</h4><p><strong>理论上可以打开多少个文件描述符取决于系统内存的大小，但内核会有系统级限制，以及用户级限制</strong>（限制某个应用消耗掉所有文件资源，可使用ulimit -n 查看）。<p><strong>用户级限制</strong><ul><li><p>查看</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>ulimit</span> -n</span><br></pre></table></figure><li><p>修改</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># 重启后失效</span></span><br><span class=line><span class=built_in>ulimit</span> -SHn 65535</span><br><span class=line><span class=comment># 永久生效</span></span><br><span class=line>修改配置文件/etc/security/limits.conf，在最后一行加入：* - nofile 65535</span><br></pre></table></figure></ul><p><strong>系统级限制</strong><ul><li><p>查看</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>sysctl -a | grep -i file-max --color;</span><br><span class=line>---</span><br><span class=line><span class=built_in>cat</span> /proc/sys/fs/file-max</span><br></pre></table></figure><li><p>修改</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment># 重启后失效</span></span><br><span class=line>sysctl -w fs.file-max=65535;</span><br><span class=line>---</span><br><span class=line><span class=built_in>echo</span> 65535 > /proc/sys/fs/file-max</span><br><span class=line></span><br><span class=line><span class=comment>#永久生效</span></span><br><span class=line>修改配置文件/etc/sysctl.conf，在最后一行加入fs.file-max=65535。</span><br><span class=line>执行访问，触发生效。</span><br><span class=line>sysctl -p</span><br></pre></table></figure></ul><h3 id=2-1-5、缓存I-O><a class=headerlink href=#2-1-5、缓存I-O title=2.1.5、缓存I/O></a>2.1.5、缓存I/O</h3><p><strong>缓存 I/O 又被称作 标准 I/O，大多数文件系统的默认 I/O 都是缓存 I/O</strong>。<p>Linux 缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据先被拷贝至系统内核的缓冲区中，然后再拷贝到应用程序的地址空间。<h3 id=2-1-6、IO多路复用简介><a class=headerlink href=#2-1-6、IO多路复用简介 title=2.1.6、IO多路复用简介></a>2.1.6、IO多路复用简介</h3><p>IO多路复用是指：<strong>内核一旦发现进程指定的一个或者多个IO条件符合要求时就会通知该进程</strong>。<p>与多进程和多线程技术相比，I/O多路复用的最大优势就是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。<p>目前支持I/O多路复用的系统调用有 <code>select、pselect、poll、epoll</code>，I/O多路复用就是通过一种机制来实现一个进程监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作<code>。</code><p><code>select、pselect、poll、epoll</code>本质上都是同步I/O，需要在读写事件就绪后自己负责进行读写，这个读写过程是阻塞的，而异步I/O无需自己读写，其实现会自动把数据从内核拷贝到用户空间。<p><code>epoll</code>跟<code>select</code>都能提供I/O多路复用的解决方案。现在的Linux内核都能支持，其中<code>epoll</code>是Linux所特有，而<code>select</code>则是<code>POSIX</code>所规定，一般操作系统均有实现。<p><strong>select，poll，epoll都是I/O多路复用的具体实现，他们的出现有先后顺序</strong>。<h2 id=2-2、select（1983）><a class=headerlink href=#2-2、select（1983） title=2.2、select（1983）></a>2.2、select（1983）</h2><p>**I/O多路复用被提出来后，select是第一个实现 (1983 左右在BSD里实现)**。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>int</span> <span class="title function_">select</span> <span class=params>(<span class=type>int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span>;</span><br></pre></table></figure><h3 id=2-2-1、原理><a class=headerlink href=#2-2-1、原理 title=2.2.1、原理></a>2.2.1、原理</h3><p><code>select</code>函数监视的文件描述符分3类，分别是<code>writefds、readfds、exceptfds</code>。调用select函数后会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（<code>timeout</code>指定等待时间，如果立即返回设为<code>null</code>即可）后函数才返回。当select函数返回后，只能通过遍历<code>fdset</code>，来找到就绪的描述符。<h3 id=2-2-2、优缺点><a class=headerlink href=#2-2-2、优缺点 title=2.2.2、优缺点></a>2.2.2、优缺点</h3><h4 id=优点><a class=headerlink href=#优点 title=优点></a>优点</h4><p><strong><code>select</code>目前几乎在所有的平台上都支持，良好的跨平台特性也是它的一个优点</strong>。<h4 id=缺点><a class=headerlink href=#缺点 title=缺点></a>缺点</h4><ol><li><strong>select 会修改传入的参数数组</strong>。这个对于一个需要调用很多次的函数，是非常不友好的。<li>select 中的任何一个sock(I/O stream)出现了数据，<strong>select 仅仅会返回，但并不告诉你哪个sock上有数据</strong>，于是只能遍历一遍才能找到，这开销可想而知。<li><strong>select 只能监视1024个链接</strong>。这个和草榴没啥关系，linux 定义在头文件中的，参见<em>FD_SETSIZE。</em><li><strong>select 线程不安全</strong>。如果你把一个sock加入到select，然后突然另外一个线程发现，尼玛，这个sock不用，要收回。对不起，这个select不支持的，如果你丧心病狂的竟然关掉这个sock，select的标准行为是。呃。不可预测的，这个可是写在文档中的哦。</ol><h2 id=2-3、poll（1997）><a class=headerlink href=#2-3、poll（1997） title=2.3、poll（1997）></a>2.3、poll（1997）</h2><p><strong>1997年实现了poll</strong>。<p>与select使用三个位图来表示三个<code>fdset</code>的方式不同，poll使用一个<code>pollfd</code>指针实现。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>struct pollfd {</span><br><span class=line>    <span class=type>int</span> fd; <span class=comment>/* file descriptor */</span></span><br><span class=line>    <span class=type>short</span> events; <span class=comment>/* requested events to watch */</span></span><br><span class=line>    <span class=type>short</span> revents; <span class=comment>/* returned events witnessed */</span></span><br><span class=line>};</span><br></pre></table></figure><p>pollfd结构包含了要监视的 event 和发生的 event，不再使用 select的 “参数-值”传递方式。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>int</span> <span class="title function_">poll</span> <span class=params>(struct pollfd *fds, unsigned <span class=type>int</span> nfds, <span class=type>int</span> timeout)</span>;</span><br></pre></table></figure><h3 id=2-3-1、原理><a class=headerlink href=#2-3-1、原理 title=2.3.1、原理></a>2.3.1、原理</h3><p><code>poll</code>本质上和<code>select</code>没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历。如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时。挂起的线程被唤醒后会再次遍历fd。这个过程经历了多次无意义的遍历。<h3 id=2-3-2、优缺点><a class=headerlink href=#2-3-2、优缺点 title=2.3.2、优缺点></a>2.3.2、优缺点</h3><h4 id=优点-1><a class=headerlink href=#优点-1 title=优点></a>优点</h4><ol><li><strong>没有最大连接数的限制</strong>，因为是基于链表来存储。<li><strong>不再修改传入数组，不过这个要看平台了</strong>，所以小心为妙。</ol><h4 id=缺点-1><a class=headerlink href=#缺点-1 title=缺点></a>缺点</h4><ol><li>大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。<li><strong><code>poll</code>有一个特点是“水平触发</strong>。如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。<li>线程非安全。</ol><h4 id=注意事项><a class=headerlink href=#注意事项 title=注意事项></a>注意事项</h4><p>从上面看，<code>select</code>和<code>poll</code>都需要在返回后通过遍历文件描述符来获取已经就绪的<code>socket</code>。事实上，同时连接的大量客户端可能只有很少数处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。<h2 id=2-4、epoll（2002）><a class=headerlink href=#2-4、epoll（2002） title=2.4、epoll（2002）></a>2.4、epoll（2002）</h2><h3 id=2-4-1、简介><a class=headerlink href=#2-4-1、简介 title=2.4.1、简介></a>2.4.1、简介</h3><p><strong>2002，大神 Davide Libenzi 实现了epoll，在内核2.6中提出</strong>。<p>epoll 是 select 和 poll 的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。<strong>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次</strong>。<h3 id=2-4-2、原理><a class=headerlink href=#2-4-2、原理 title=2.4.2、原理></a>2.4.2、原理</h3><p><strong><code>epoll</code>支持水平触发和边缘触发</strong>。最大特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是<code>epoll</code>使用“事件”就绪通知的方式，通过<code>epoll_ctl</code>注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。<h3 id=2-4-3、工作过程><a class=headerlink href=#2-4-3、工作过程 title=2.4.3、工作过程></a>2.4.3、工作过程</h3><p>epoll操作过程需要三个接口，分别如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>int</span> <span class="title function_">epoll_create</span><span class=params>(<span class=type>int</span> size)</span>；<span class=comment>// 创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span></span><br><span class=line><span class=type>int</span> <span class="title function_">epoll_ctl</span><span class=params>(<span class=type>int</span> epfd, <span class=type>int</span> op, <span class=type>int</span> fd, struct epoll_event *event)</span>；</span><br><span class=line><span class=type>int</span> <span class="title function_">epoll_wait</span><span class=params>(<span class=type>int</span> epfd, struct epoll_event * events, <span class=type>int</span> maxevents, <span class=type>int</span> timeout)</span>;</span><br></pre></table></figure><p><strong>（1）epoll_create(int size)</strong><p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。 当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。<p>*<em>（2）epoll_ctl(int epfd, int op, int fd, struct epoll_event <em>event)</em></em><ul><li><p>epfd：是epoll_create()的返回值。</p><li><p>op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</p><li><p>fd：是需要监听的fd（文件描述符）</p><li><p>epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>struct epoll_event {</span><br><span class=line>    __uint32_t events; </span><br><span class=line>    <span class=comment>/* Epoll events / epoll_data_t data; / User data variable */</span> </span><br><span class=line>};</span><br></pre></table></figure> <p>events可以是以下几个宏的集合：</p> <ol><li><font color=orange>EPOLLIN </font>：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；<li><font color=orange>EPOLLOUT</font>：表示对应的文件描述符可以写；<li><font color=orange>EPOLLPRI</font>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<li><font color=orange>EPOLLERR</font>：表示对应的文件描述符发生错误；<li><font color=orange>EPOLLHUP</font>：表示对应的文件描述符被挂断；<li><font color=orange>EPOLLET</font>： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。<li><font color=orange>EPOLLONESHOT</font>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。</ol></ul><p><strong>（3）epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)</strong><p>等待epfd上的io事件，最多返回maxevents个事件。 参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。<h3 id=2-4-4、优缺点><a class=headerlink href=#2-4-4、优缺点 title=2.4.4、优缺点></a>2.4.4、优缺点</h3><p><strong>优点</strong><ol><li>没有最大并发连接的限制，能打开的FD上限远大于1024（1G的内存上能监听约10万个端口）。<li>线程安全。<li>效率提升，它并不采用轮询的方式，不会随着FD数目的增加而效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。<li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。</ol><p><strong>缺点</strong>：只有linux支持epoll。比如BSD上面的实现是kqueue。<h3 id=2-4-5、工作模式><a class=headerlink href=#2-4-5、工作模式 title=2.4.5、工作模式></a>2.4.5、工作模式</h3><p><strong>epoll对文件描述符的操作有两种模式：LT（level trigger，水平触发，默认）和 ET（edge trigger，边缘触发）</strong>。两者的区别如下：<ul><li><p><strong>LT模式（事件发生就通知你，你不管，那就一直通知你）</strong></p> <p>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</p> <p><code>LT(level triggered)</code>是默认的工作方式，并且同时支持<code>block和no-block socket</code>。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的`。</p><li><p><strong>ET模式（事件发生就通知你，你不管，那不好意思，只会通知一次）</strong></p> <p>当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</p> <p><code>ET(edge-triggered)</code>是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)。</p> <p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式下时必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p></ul><p>如果存在大量活跃连接，select/poll效率会较高一点，但如果活跃连接数量较少，那么epoll的效率会高于select/poll。<h2 id=2-5、kqueue><a class=headerlink href=#2-5、kqueue title=2.5、kqueue></a>2.5、kqueue</h2><h3 id=2-5-1、简介><a class=headerlink href=#2-5-1、简介 title=2.5.1、简介></a>2.5.1、简介</h3><p>与 epoll 类似，仅存于 FreeBSD（一种类UNIX操作系统）。<h2 id=2-6、总结><a class=headerlink href=#2-6、总结 title=2.6、总结></a>2.6、总结</h2><h3 id=2-6-1、select、poll、epoll区别><a class=headerlink href=#2-6-1、select、poll、epoll区别 title=2.6.1、select、poll、epoll区别></a>2.6.1、select、poll、epoll区别</h3><ol><li><p>一个进程所能打开的最大连接数</p> <p><img alt=select-poll-epoll区别_一个进程支持的最大连接数01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/select-poll-epoll%E5%8C%BA%E5%88%AB_%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%94%AF%E6%8C%81%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B001.png?token=AIGEF3L5JFBKQGWZRDVHKEDEZZWE2></p><li><p>FD剧增后带来的IO效率问题</p> <p><img alt=select-poll-epoll区别_FD剧增后带来的效率问题01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/select-poll-epoll%E5%8C%BA%E5%88%AB_FD%E5%89%A7%E5%A2%9E%E5%90%8E%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%95%88%E7%8E%87%E9%97%AE%E9%A2%9801.png?token=AIGEF3IBWIKHFGDH77RBSP3EZZWGO></p><li><p>消息传递方式</p> <p><img alt=select-poll-epoll区别_消息传递方式01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/select-poll-epoll%E5%8C%BA%E5%88%AB_%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F01.png?token=AIGEF3P4I6JR72ZXBU2H6Z3EZZWIK></p></ol><h3 id=2-6-2、场景助记><a class=headerlink href=#2-6-2、场景助记 title=2.6.2、场景助记></a>2.6.2、场景助记</h3><p>一个epoll场景：一个酒吧服务员（一个线程），前面趴了一群醉汉，突然一个吼一声“倒酒”（事件），你小跑过去给他倒一杯，然后随他去吧，突然又一个要倒酒，你又过去倒上，就这样一个服务员服务好多人，有时没人喝酒，服务员处于空闲状态，可以玩玩手机。<p>至于epoll与select，poll的区别在于后两者的场景中醉汉不说话，你要挨个问要不要酒，没时间玩手机了。I/O多路复用大概就是指这几个醉汉共用一个服务员。<h3 id=2-6-3、三者如何选择><a class=headerlink href=#2-6-3、三者如何选择 title=2.6.3、三者如何选择></a>2.6.3、三者如何选择</h3><ol><li>通常<code>epoll</code>性能最好，但在连接数少且连接都十分活跃的情况下，<code>select</code>和<code>poll</code>的性能可能要比<code>epoll</code>要好，毕竟<code>epoll</code>的通知机制需要很多函数回调。<li><code>select</code>低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计进行改善。</ol><h1 id=3、BIO（Blocking-Input-Output）><a title="3、BIO（Blocking Input/Output）" class=headerlink href=#3、BIO（Blocking-Input-Output）></a>3、BIO（Blocking Input/Output）</h1><h2 id=3-1、简介><a class=headerlink href=#3-1、简介 title=3.1、简介></a>3.1、简介</h2><p>BIO是一个同步阻塞IO。同步阻塞I/O模式下，数据的读取写入必须阻塞并等待其完成。<p>通过经典的烧开水例子来帮助理解，这里假设一个烧开水的场景，有一排水壶在烧开水，BIO的工作模式就是， 叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。但是实际上线程在等待水壶烧开的时间段什么都没有做。<h2 id=3-2、特点><a class=headerlink href=#3-2、特点 title=3.2、特点></a>3.2、特点</h2><ol><li><strong>一个线程对应一个请求。</strong></ol><h2 id=3-3、阻塞方法><a class=headerlink href=#3-3、阻塞方法 title=3.3、阻塞方法></a>3.3、阻塞方法</h2><ol><li>InputStream.read()<li>OutputStream.write()<li>ServerSocket.accept()</ol><h2 id=3-4、优缺点><a class=headerlink href=#3-4、优缺点 title=3.4、优缺点></a>3.4、优缺点</h2><ul><li><p>优点：（同步、使用复杂。）</p> <p>BIO模型程序开发起来较为简单，易于把握。（因为这是最基本与简单的I/O操作方式，其根本特性是做完一件事再去做另一件事，一件事一定要等前一件事做完，这很符合程序员传统的顺序开发思想。）</p><li><p>缺点：（阻塞、同步，三次握手耗时。）</p> <p>BIO模型下的线程阻塞会导致线程的频繁切换，进而影响整个系统性能。因为BIO模型下，一个线程同时只能做一个工作，如果线程在执行过程中依赖于需要等待的资源，那么该线程会长期处于阻塞状态，我们知道在整个操作系统中，线程是系统执行的基本单位。</p></ul><h2 id=3-5、使用场景><a class=headerlink href=#3-5、使用场景 title=3.5、使用场景></a>3.5、使用场景</h2><p>BIO方式适用于连接数量少且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。<h2 id=3-6、注意事项><a class=headerlink href=#3-6、注意事项 title=3.6、注意事项></a>3.6、注意事项</h2><p>系统开发中，线程的生命周期一定要准确控制，对于大并发的场景，尽量使用线程池来确保线程的创建数量在一个合理范围之内，切勿编写代码来限制线程创建上限。<h1 id=4、NIO（New-Input-Output）><a title="4、NIO（New Input/Output）" class=headerlink href=#4、NIO（New-Input-Output）></a>4、NIO（New Input/Output）</h1><h2 id=4-1、简介><a class=headerlink href=#4-1、简介 title=4.1、简介></a>4.1、简介</h2><p><strong>NIO是同步非阻塞I/O模型，Java 1.4 中引入 NIO 框架，对应 java.nio 包，提供了Channel , Selector，Buffer等抽象类</strong>。<p><strong>NIO中的N可以理解为Non-blocking，而不单纯是New</strong>。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种套接字通道实现，两种通道都支持阻塞和非阻塞两种模式。<p>阻塞模式比较简单，但性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 非阻塞模式来应对。<p><strong>NIO编程中，需要理解3个对象：Channel、Buffer和Selector</strong>。<h2 id=4-2、Channel><a class=headerlink href=#4-2、Channel title=4.2、Channel></a>4.2、Channel</h2><p>Channel和IO中的Stream(流)差不多。只不过Stream是单向的，譬如：InputStream, OutputStream。而Channel是双向的，既可以用来进行读操作，又可以用来进行写操作，NIO中的Channel实现有：<ol><li>FileChannel——文件IO<li>DatagramChannel——UDP<li>SocketChannel——TCP Client<li>ServerSocketChannel——TCP Server</ol><h2 id=4-3、Buffer><a class=headerlink href=#4-3、Buffer title=4.3、Buffer></a>4.3、Buffer</h2><p>NIO中的Buffer实现有：ByteBuffer、CharBuffer、DoubleBuffer、 FloatBuffer、IntBuffer、 LongBuffer、ShortBuffer，分别对应基本数据类型: byte、char、double、 float、int、 long、 short。当然NIO中还有MappedByteBuffer、HeapByteBuffer、DirectByteBuffer等。<h3 id=4-3-1、DirectByteBuffer-VS-HeapByteBuffer><a title="4.3.1、DirectByteBuffer VS HeapByteBuffer" class=headerlink href=#4-3-1、DirectByteBuffer-VS-HeapByteBuffer></a>4.3.1、DirectByteBuffer VS HeapByteBuffer</h3><p>它们是ByteBuffer分配内存的两种方式。<ol><li>HeapByteBuffer内存空间在JVM堆上分配，可以看做是jdk对于byte[]数组的封装；而DirectByteBuffer则直接利用了系统接口进行内存申请，其内存分配在C的heap中，这样就减少了内存之间的拷贝操作，如此一来，在使用 DirectByteBuffer 时，系统就可以直接从内存将数据写入到Channel中，而无需进行Java堆的内存申请，复制等操作，提高了性能。<li>DirectByteBuffer使用起来相对于完全托管于Java内存管理的HeapByteBuffer来说更复杂一些，如果用不好可能会引起OOM。因为DirectByteBuffer通过FGC来回收内存，且会自己检测情况是否调用system.gc()。如果参数中使用了DisableExplicitGC那么就无法回收该快内存了，-XX:+DisableExplicitGC标志会让System.gc()方法失效，失效后如果还想回收就需要我们手动来回收内存了。<li>DirectByteBuffer的内存大小受 -XX:MaxDirectMemorySize JVM参数控制（默认大小64M），在 DirectByteBuffer申请内存空间达到该设置大小后，会触发FGC。</ol><h2 id=4-4、Selector><a class=headerlink href=#4-4、Selector title=4.4、Selector></a>4.4、Selector</h2><h3 id=4-4-1、简介><a class=headerlink href=#4-4-1、简介 title=4.4.1、简介></a>4.4.1、简介</h3><p><strong>Selector通过单线程处理多个Channel，适用于多连接流量低的场景</strong>。<h3 id=4-4-2、优缺点><a class=headerlink href=#4-4-2、优缺点 title=4.4.2、优缺点></a>4.4.2、优缺点</h3><h3 id=4-4-3、使用场景><a class=headerlink href=#4-4-3、使用场景 title=4.4.3、使用场景></a>4.4.3、使用场景</h3><p>NIO适用于连接数多且连接较短的场景，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。<h2 id=4-5、总结><a class=headerlink href=#4-5、总结 title=4.5、总结></a>4.5、总结</h2><h3 id=4-5-1、NIO特性-NIO与IO的区别><a class=headerlink href=#4-5-1、NIO特性-NIO与IO的区别 title=4.5.1、NIO特性/NIO与IO的区别></a>4.5.1、NIO特性/NIO与IO的区别</h3><ul><li><p>Non-Blocking IO：IO流是阻塞的，NIO流不阻塞。</p><li><p>Buffer（缓冲区）：IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。</p> <p>Buffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。</p><li><p>Channel（通道）：NIO 基于通道进行读写。通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互，故可以异步地读写。</p><li><p>Selector（选择器）：NIO有选择器，而IO没有。</p></ul><h3 id=4-5-2、NIO-VS-BIO><a title="4.5.2、NIO VS BIO" class=headerlink href=#4-5-2、NIO-VS-BIO></a>4.5.2、NIO VS BIO</h3><ol><li>BIO以流的方式处理数据，而NIO以块的方式处理数据。块IO的效率要比流IO高。<li>BIO是阻塞的，而NIO非阻塞。<li>BIO基于字节流和字符流进行操作，而NIO基于Channel和Buffer进行操作，数据既可以从Channel读到Buffer中，也可以从Buffer写入Channel中。Selector可用单个线程监听多个客户端。</ol><h1 id=5、AIO（Asynchronous-Input-Output）><a title="5、AIO（Asynchronous Input/Output）" class=headerlink href=#5、AIO（Asynchronous-Input-Output）></a>5、AIO（Asynchronous Input/Output）</h1><h2 id=5-1、简介><a class=headerlink href=#5-1、简介 title=5.1、简介></a>5.1、简介</h2><p>AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2，它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。<p>AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。（除了 AIO 其他的 IO 类型都是同步的，这一点可以从底层IO线程模型解释。<h2 id=5-2、特点><a class=headerlink href=#5-2、特点 title=5.2、特点></a>5.2、特点</h2><p>在进行IO操作时，不需要阻塞等待操作完成，期间可以执行其它操作，一旦操作完成会直接返回结果给你。<h2 id=5-3、优缺点><a class=headerlink href=#5-3、优缺点 title=5.3、优缺点></a>5.3、优缺点</h2><p>优点：提升IO操作的效率和系统的并发性能。<p>缺点：系统对其的支持不够完善，且实现较为复杂，只适用于大数据量的IO操作场景。<h2 id=5-4、使用场景><a class=headerlink href=#5-4、使用场景 title=5.4、使用场景></a>5.4、使用场景</h2><p>AIO方式适用于连接数目多且连接较长的场景，比如相册服务器。JDK7开始支持。<h1 id=6、IO多路复用模式><a class=headerlink href=#6、IO多路复用模式 title=6、IO多路复用模式></a>6、IO多路复用模式</h1><p>一般地，I/O多路复用机制都依赖于一个事件多路分离器(Event Demultiplexer)。分离器对象可将 来自事件源的I/O事件分离出来，然后分发到对应的read/write事件处理器(Event Handler)。开发人员预先注册需要处理的事件及其事件处理器（或回调函数）；事件分离器负责将请求事件传递给事件处理器。<p>两个与事件分离器有关的模式是Reactor和Proactor。Reactor模式采用同步IO，而Proactor采用异步IO。<p>在Reactor中，事件分离器负责 等待 文件描述符或socket为读写操作 准备就绪，然后将就绪事件传递给对应的处理器，最后由处理器负责完成实际的读写工作。<p>在Proactor中，处理器或兼任处理器的事件分离器，只负责发起异步读写操作。IO操作本身由操作系统来完成。传递给操作系统的参数需要包含用户定义的数据缓冲区地址和数据大小，操作系统才能从中得到写出操作所需数据，或写入从socket读到的数据。事件分离器捕获IO操作完成事件，然后将事件传递给对应事件处理器。比如，在windows上，处理器发起一个异步IO操作，再由事件分离器等待IOCompletion事件。典型的异步模式实现，都建立在操作系统支持异步API的基础之上，我们将这种实现称为“系统级”异步或“真”异步，因为应用程序完全依赖操作系统执行真正的IO工作。<h2 id=6-1、Reactor模式><a class=headerlink href=#6-1、Reactor模式 title=6.1、Reactor模式></a>6.1、Reactor模式</h2><h3 id=6-x-1、读操作><a class=headerlink href=#6-x-1、读操作 title=6.x.1、读操作></a>6.x.1、读操作</h3><ol><li>注册读就绪事件和相关的事件处理器。<li>事件分离器等待事件发生。<li>当读就绪事件发生时，事件分离器调用第一步中的事件处理器。<li>事件处理器首先执行读取操作，处理读到的数据，注册新的事件，然后返还控制权。</ol><h3 id=6-x-2、写操作><a class=headerlink href=#6-x-2、写操作 title=6.x.2、写操作></a>6.x.2、写操作</h3><p>写入操作类似于读取操作，只不过第一步注册的是写就绪事件。<h3 id=6-x-3、class结构><a class=headerlink href=#6-x-3、class结构 title=6.x.3、class结构></a>6.x.3、class结构</h3><p><img alt=image-20210130120424783 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210130120424783.png?token=AIGEF3LVAGFSNH77T3MR2Z3EZZWKI><p>Reactor包含如下角色：<ul><li>Handle 句柄；用来标识socket连接或是打开文件；<li>Synchronous Event Demultiplexer：同步事件多路分解器：由操作系统内核实现的一个函数；用于阻塞等待发生在句柄集合上的一个或多个事件；（如select/epoll；）<li>Event Handler：事件处理接口<li>Concrete Event HandlerA：实现应用程序所提供的特定事件处理逻辑；<li>Reactor：反应器，定义一个接口，实现以下功能：<ol><li>供应用程序注册和删除关注的事件句柄；<li>运行事件循环；<li>有就绪事件到来时，分发事件到之前注册的回调函数上处理；</ol></ul><p>具体事件处理程序不调用反应器，而是由反应器分配一个具体事件处理程序，具体事件处理程序对某个指定的事件发生做出反应；这种控制逆转又称为“好莱坞法则”（不要调用我，让我来调用你）。<p>业务流程时序图：<p><img alt=image-20210130120745134 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210130120745134.png?token=AIGEF3NURLY36AQHY2JQLJDEZZWLK><ol><li>应用启动，将关注的事件handle注册到Reactor中；<li>调用Reactor，进入无限事件循环，等待注册的事件到来；<li>事件到来，select返回，Reactor将事件分发到之前注册的回调函数中处理；</ol><h2 id=6-2、Proactor模式><a class=headerlink href=#6-2、Proactor模式 title=6.2、Proactor模式></a>6.2、Proactor模式</h2><h3 id=6-x-1、读操作-1><a class=headerlink href=#6-x-1、读操作-1 title=6.x.1、读操作></a>6.x.1、读操作</h3><ol><li>应用程序初始化一个异步读取操作，然后注册事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。<li>事件分离器等待读取操作完成事件。<li>在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作（异步IO都是操作系统负责将数据读写到应用传递进来的缓冲区供应用程序操作，操作系统扮演了重要角色），并将读取的内容放入用户传递过来的缓存区中。Proactor中，应用程序需要传递缓存区，这也是区别于Reactor的一点。<li>事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。</ol><h3 id=6-x-2、写操作-1><a class=headerlink href=#6-x-2、写操作-1 title=6.x.2、写操作></a>6.x.2、写操作</h3><p>写操作与读操作类似。<h3 id=6-x-3、class结构-1><a class=headerlink href=#6-x-3、class结构-1 title=6.x.3、class结构></a>6.x.3、class结构</h3><p><img alt=image-20210130121111912 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210130121111912.png?token=AIGEF3P7PCE73Q4G6GRF7C3EZZWMM><p><strong>Proactor主动器模式包含如下角色</strong><ul><li>Handle 句柄；用来标识socket连接或是打开文件；<li>Asynchronous Operation Processor：异步操作处理器；负责执行异步操作，一般由操作系统内核实现；<li>Asynchronous Operation：异步操作;<li>Completion Event Queue：完成事件队列；异步操作完成的结果放到队列中等待后续使用;<li>Proactor：主动器；为应用程序进程提供事件循环；从完成事件队列中取出异步操作的结果，分发调用相应的后续处理逻辑；<li>Completion Handler：完成事件接口；一般是由回调函数组成的接口；<li>Concrete Completion Handler：完成事件处理逻辑；实现接口定义特定的应用处理逻辑；</ul><p>业务流程时序图：<p><img alt=image-20210130121212731 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210130121212731.png?token=AIGEF3J26FNDQI3N67MR2ZTEZZWNQ><ol><li>应用程序启动，调用异步操作处理器提供的异步操作接口函数，调用之后应用程序和异步操作处理就独立运行；应用程序可以调用新的异步操作，而其它操作可以并发进行；<li>应用程序启动Proactor主动器，进行无限的事件循环，等待完成事件到来；<li>异步操作处理器执行异步操作，完成后将结果放入到完成事件队列；<li>主动器从完成事件队列中取出结果，分发到相应的完成事件回调函数处理逻辑中；</ol><h2 id=6-3、总结><a class=headerlink href=#6-3、总结 title=6.3、总结></a>6.3、总结</h2><h3 id=6-3-1、主动与被动><a class=headerlink href=#6-3-1、主动与被动 title=6.3.1、主动与被动></a>6.3.1、主动与被动</h3><p>以主动写为例：<ul><li>Reactor将handle放到select()，等待可写就绪，然后调用write()写入数据；写完后 处理后续逻辑；<li>Proactor调用aoi_write后立刻返回，由内核负责写操作，写完后调用相应的回调函数处理后续逻辑；</ul><h3 id=6-3-2、实现><a class=headerlink href=#6-3-2、实现 title=6.3.2、实现></a>6.3.2、实现</h3><p>Reactor实现了一个被动的事件分离和分发模型，服务等待请求事件的到来，再通过不受间断的同步处理事件，从而做出反应。<p>Proactor实现了一个主动的事件分离和分发模型；这种设计允许多个任务并发执行，从而提高吞吐量；并可执行耗时长的任务（各个任务间互不影响）。<h3 id=6-3-3、优劣><a class=headerlink href=#6-3-3、优劣 title=6.3.3、优劣></a>6.3.3、优劣</h3><h4 id=优点-2><a class=headerlink href=#优点-2 title=优点></a>优点</h4><ul><li>Reactor<ol><li>Reactor实现相对简单，对于耗时短的处理场景处理高效；<li>操作系统可以在多个事件源上等待，并且避免了多线程编程相关的性能开销和编程复杂性；<li>事件的串行化对应用是透明的，可以顺序的同步执行而不需要加锁；<li>事务分离：将与应用无关的多路分解、分配机制 和 与应用相关的回调函数 分离开来。</ol><li>Proactor<ol><li>Proactor性能更高，能够处理耗时长的并发场景；</ol></ul><h4 id=缺点-2><a class=headerlink href=#缺点-2 title=缺点></a>缺点</h4><ul><li><p>Reactor：Reactor处理耗时长的操作会造成事件分发的阻塞，影响后续事件的处理；</p><li><p>Proactor</p> <ol><li>Proactor实现逻辑复杂；<li>依赖操作系统对异步的支持；（目前纯异步的操作系统较少，但有优秀实现如windows IOCP，但由于windows系统用于服务器的局限性，目前应用范围较小；）<li>Unix/Linux系统对纯异步支持有限，应用事件驱动的主流还是通过select/epoll来实现；</ol></ul><h3 id=6-3-4、适用场景><a class=headerlink href=#6-3-4、适用场景 title=6.3.4、适用场景></a>6.3.4、适用场景</h3><ul><li><p>Reactor：同时接收多个服务请求，且依次同步处理它们的事件驱动程序；</p><li><p>Proactor：异步接收和同时处理多个服务请求的事件驱动程序；</p></ul></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/HTTP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/ itemprop=url>计算机系列-HTTP基础知识</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-06 21:08:45" datetime=2023-10-06T21:08:45+08:00 itemprop=dateModified>2023-10-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/ itemprop=url rel=index><span itemprop=name>计算机</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、HTTP必知><a class=headerlink href=#1、HTTP必知 title=1、HTTP必知></a>1、HTTP必知</h1><h2 id=1-1、啥是HTTP><a class=headerlink href=#1-1、啥是HTTP title=1.1、啥是HTTP></a>1.1、啥是HTTP</h2><p><strong>HTTP 是 HyperText Transfer Protocol 的缩写，超⽂本传输协议</strong>。<p>超⽂本传输协议可拆分为三个部分：超⽂本、传输、协议。<h3 id=1-1-1、超文本><a class=headerlink href=#1-1-1、超文本 title=1.1.1、超文本></a>1.1.1、超文本</h3><p><strong>HTTP传输的内容是超⽂本</strong>。<ul><li><p>⽂本：在互联⽹早期时只是简单的字符⽂字，但现在的含义已经可以扩展为图⽚、视频、压缩包等，在 HTTP 眼⾥这些都算作⽂本。</p><li><p>超⽂本：超越了普通⽂本的⽂本，它是⽂字、图⽚、视频等的混合体，最关键有超链接，能从⼀个超⽂本跳转到另外⼀个超⽂本。</p> <p>HTML 就是最常⻅的超⽂本了，它本身只是纯⽂字⽂件，但内部⽤很多标签定义了图⽚、视频等的链接，再经过浏览器的解释，呈现给我们的就是⼀个有⽂字、有画⾯的⽹⻚。</p></ul><p><strong>HTTP是计算机间传输⽂字、图⽚、⾳频、视频等超⽂本数据的约定和规范</strong>。<h3 id=1-1-2、传输><a class=headerlink href=#1-1-2、传输 title=1.1.2、传输></a>1.1.2、传输</h3><p>传输包含两项信息：<ol><li>HTTP 协议是⼀个双向协议。<li>数据虽然是在 A 和 B 之间传输，但允许中间有中转或接⼒。</ol><p>HTTP 是计算机中两点之间传输数据的约定和规范。<h3 id=1-1-3、协议><a class=headerlink href=#1-1-3、协议 title=1.1.3、协议></a>1.1.3、协议</h3><p>HTTP是计算机世界中的协议。它确⽴了计算机之间交流通信的规范，以及相关的各种控制和错误处理⽅式（⾏为约定和规范）。<h2 id=1-2、HTTP状态码><a class=headerlink href=#1-2、HTTP状态码 title=1.2、HTTP状态码></a>1.2、HTTP状态码</h2><p><img alt=image-20230805094440407.png src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805094440407.png?token=AIGEF3MNNEBKKP2VOUZ45SDEZZNHW><h2 id=1-3、HTTP请求头字段><a class=headerlink href=#1-3、HTTP请求头字段 title=1.3、HTTP请求头字段></a>1.3、HTTP请求头字段</h2><h3 id=1-3-1、user-agent（请求发送方-谁发的）><a title="1.3.1、user-agent（请求发送方 - 谁发的）" class=headerlink href=#1-3-1、user-agent（请求发送方-谁发的）></a>1.3.1、user-agent（请求发送方 - 谁发的）</h3><h3 id=1-3-2、HOST（请求接收方-发给谁）><a title="1.3.2、HOST（请求接收方 - 发给谁）" class=headerlink href=#1-3-2、HOST（请求接收方-发给谁）></a>1.3.2、HOST（请求接收方 - 发给谁）</h3><p><strong>客户端发送请求时，⽤来指定服务器的域名</strong>。<p><img alt=image-20210415173330840 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415173330840.png?token=AIGEF3LWYPYIFXOCK23HHETEZZOHI><p>有了 Host 字段，就可以将请求发往同⼀台服务器上的不同⽹站。<h3 id=1-3-3、Connection（使用持久连接）><a class=headerlink href=#1-3-3、Connection（使用持久连接） title=1.3.3、Connection（使用持久连接）></a>1.3.3、Connection（使用持久连接）</h3><p><strong>Connection字段用于告知服务器使⽤ TCP 持久连接，以便其他请求复⽤</strong>。<p><img alt=image-20210415173628892 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415173628892.png?token=AIGEF3JEZCLCLR2WACWIMG3EZZPPM><p>HTTP/1.1 版本的默认连接都是持久连接，但为了兼容⽼版本的 HTTP，需要指定 Connection ⾸部字段的值为 Keep-Alive 。 ⼀个可以复⽤的 TCP 连接就建⽴了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。<h3 id=1-3-4、Content-Type（响应数据格式）><a class=headerlink href=#1-3-4、Content-Type（响应数据格式） title=1.3.4、Content-Type（响应数据格式）></a>1.3.4、Content-Type（响应数据格式）</h3><p><strong>Content-Type字段⽤于告诉客户端，本次数据是什么格式</strong>。<p><img alt=image-20210415173849046 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415173849046.png?token=AIGEF3N7PSIDEUUTQSL4Q3TEZZPQA><p>上⾯的类型表明，发送的是⽹⻚，⽽且编码是UTF-8。 客户端请求的时候，可以使⽤ Accept 字段声明⾃⼰可以接受哪些数据格式。<figure class="highlight http"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line># 客户端声明⾃⼰可以接受任何格式的数据</span><br><span class=line>Accept：*/*</span><br></pre></table></figure><h3 id=1-3-5、Content-Length（响应数据长度）><a class=headerlink href=#1-3-5、Content-Length（响应数据长度） title=1.3.5、Content-Length（响应数据长度）></a>1.3.5、Content-Length（响应数据长度）</h3><p><strong>Content-Length 字段用于表示服务端响应数据的⻓度</strong>。<p><img alt=image-20210415173517081 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415173517081.png?token=AIGEF3OXJ6KPF746WLYMBLDEZZPQS><p>比如，上⾯就是告诉浏览器，本次服务器回应的数据⻓度是 1000 个字节，后⾯的字节就属于下⼀个回应了。<h3 id=1-3-6、Content-Encoding（响应数据的压缩格式）><a class=headerlink href=#1-3-6、Content-Encoding（响应数据的压缩格式） title=1.3.6、Content-Encoding（响应数据的压缩格式）></a>1.3.6、Content-Encoding（响应数据的压缩格式）</h3><p><strong>Content-Encoding字段用于表示服务器返回的数据使⽤了什么压缩格式</strong>。<p><img alt=image-20210415174030419 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415174030419.png?token=AIGEF3NROJQIG5QLYSPNEXTEZZPRI><p>上⾯表示服务器返回的数据采⽤了 gzip ⽅式压缩，告知客户端需要⽤此⽅式解压。 客户端在请求时，⽤ Accept-Encoding 字段说明⾃⼰可以接受哪些压缩⽅法。<h2 id=1-4、HTTP请求和响应><a class=headerlink href=#1-4、HTTP请求和响应 title=1.4、HTTP请求和响应></a>1.4、HTTP请求和响应</h2><h3 id=1-4-1、HTTP请求><a class=headerlink href=#1-4-1、HTTP请求 title=1.4.1、HTTP请求></a>1.4.1、HTTP请求</h3><p><strong>一个HTTP请求报文由请求行（request line）、请求头部（header）、空行 和 请求数据 4个部分组成</strong>，请求报文的一般格式如下图：<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/http%E5%8D%8F%E8%AE%AE%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%8401.jpg?token=AIGEF3MVXDHXPPWAYO4262TEZZPR6><p>下面针对每一项进行分析：<p><strong>（1）请求行</strong><p><strong>请求行分为三个部分：请求方式、请求地址和协议版本</strong>。<ol><li><p><font color=orange>请求方式</font></p> <p>HTTP/1.1 定义的请求方式有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</p> <p>最常的两种GET和POST，如果是RestFul接口，则一般会用到GET、POST、DELETE、PUT。</p><li><p><font color=orange>请求地址</font></p> <p>组成：<协议>：//<主机>：<端口>/<路径></p> <p>端口和路径有时可以省略（HTTP默认端口号是80）：</p> <p><img alt=img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E8%AF%B7%E6%B1%82%E8%A1%8C-%E8%AF%B7%E6%B1%82%E5%9C%B0%E5%9D%80%E5%9B%BE%E7%A4%BA.jpg?token=AIGEF3LVUQOTQAUZJWSARH3EZZPTA></p><li><p><font color=orange>协议版本</font></p> <p>协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1。</p></ol><p>请求行示例如下：<figure class="highlight http"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>POST /index.php　HTTP/1.1</span><br></pre></table></figure><p><strong>（2）请求头</strong><p>请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。<p>常见请求头如下：<p><img alt=img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%9B%BE%E7%A4%BA.jpg?token=AIGEF3LUS5OXWSK7DEGAWVLEZZPTQ><p>请求头示例如下：<figure class="highlight http"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=attribute>Host</span><span class=punctuation>: </span>localhost</span><br><span class=line><span class=attribute>User-Agent</span><span class=punctuation>: </span>Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2</span><br><span class=line><span class=attribute>Accept</span><span class=punctuation>: </span>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class=line><span class=attribute>Accept-Language</span><span class=punctuation>: </span>zh-cn,zh;q=0.5</span><br><span class=line><span class=attribute>Accept-Encoding</span><span class=punctuation>: </span>gzip, deflate</span><br><span class=line><span class=attribute>Connection</span><span class=punctuation>: </span>keep-alive</span><br><span class=line><span class=attribute>Referer</span><span class=punctuation>: </span>[http://localhost/](https://link.jianshu.com?t=http://localhost/)</span><br><span class=line>Content-Length：25</span><br><span class=line>Content-Type：application/x-www-form-urlencoded</span><br></pre></table></figure><p><strong>（3）空行</strong><p>空行用于隔离请求头和请求体，否则服务器无法解析请求信息。<p><strong>（4）请求数据</strong><p>可选部分，比如GET请求就没有请求数据。<p>请求数据示例：<figure class="highlight http"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>username=aa&password=1234</span><br></pre></table></figure><h3 id=1-4-2、HTTP响应><a class=headerlink href=#1-4-2、HTTP响应 title=1.4.2、HTTP响应></a>1.4.2、HTTP响应</h3><p><strong>HTTP响应报文主要由 状态行、响应头、空行 和 响应数据 组成</strong>。结构如下图所示：<p><img alt=img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/HTTP%E5%93%8D%E5%BA%94%E6%95%B4%E4%BD%93%E5%9B%BE%E7%A4%BA.jpg?token=AIGEF3JLOBG3WTMHBSSYPBTEZZPUE><p>下面针对每一项进行分析：<p><strong>（1）状态行</strong><p><strong>状态行由协议版本，状态码，状态码描述3部分组成</strong>。<p>其中协议版本与请求报文一致，状态码描述是对状态码的简单描述。<p>状态码分类如下：<table><thead><tr><th align=left>分类<th align=left>分类描述<tbody><tr><td align=left>1**<td align=left>信息，服务器收到请求，需要请求者继续执行操作。<tr><td align=left>2**<td align=left>成功，操作被成功接收并处理。<tr><td align=left>3**<td align=left>重定向，需要进一步的操作以完成请求。<tr><td align=left>4**<td align=left>客户端错误，请求包含语法错误或无法完成请求。<tr><td align=left>5**<td align=left>服务器错误，服务器在处理请求的过程中发生了错误。</table><p>常见状态如下所示：<ul><li>200：响应成功。<li>302：跳转，其跳转地址通过响应头中的location属性来指定。<li>400：客户端请求有语法错误，不能被服务器识别。<li>403：服务器接收到请求，但拒绝提供服务（认证失败）。<li>404：请求资源不存在。<li>500：服务器内部错误。</ul><p>状态行示例如下：<figure class="highlight http"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=meta>HTTP/1.1</span> <span class=number>200</span> OK</span><br></pre></table></figure><p><strong>（2）响应头</strong><p>与请求头部类似，为响应报文添加了一些附加信息。<p>常见响应头部如下：<p><img alt=img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E5%93%8D%E5%BA%94%E5%A4%B4%E5%9B%BE%E7%A4%BA.jpg?token=AIGEF3LTW4EZZIYMTCXXFJTEZZPWY><p>响应头示例如下：<figure class="highlight http"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=attribute>Date</span><span class=punctuation>: </span>Sun, 17 Mar 2013 08:12:54 GMT</span><br><span class=line><span class=attribute>Server</span><span class=punctuation>: </span>Apache/2.2.8 (Win32) PHP/5.2.5</span><br><span class=line><span class=attribute>X-Powered-By</span><span class=punctuation>: </span>PHP/5.2.5</span><br><span class=line><span class=attribute>Set-Cookie</span><span class=punctuation>: </span>PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/</span><br><span class=line><span class=attribute>Expires</span><span class=punctuation>: </span>Thu, 19 Nov 1981 08:52:00 GMT</span><br><span class=line><span class=attribute>Cache-Control</span><span class=punctuation>: </span>no-store, no-cache, must-revalidate, post-check=0, pre-check=0</span><br><span class=line><span class=attribute>Pragma</span><span class=punctuation>: </span>no-cache</span><br><span class=line><span class=attribute>Content-Length</span><span class=punctuation>: </span>4393</span><br><span class=line><span class=attribute>Keep-Alive</span><span class=punctuation>: </span>timeout=5, max=100</span><br><span class=line><span class=attribute>Connection</span><span class=punctuation>: </span>Keep-Alive</span><br><span class=line><span class=attribute>Content-Type</span><span class=punctuation>: </span>text/html; charset=utf-8</span><br></pre></table></figure><p><strong>（3）空行</strong><p>至关重要，不能缺少。与请求中空行作用类似。<p><strong>（4）响应数据</strong><p>用于存放需要返回给客户端的数据信息。<p>响应数据示例：<figure class="highlight http"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>&LThtml></span><br><span class=line>    &LThead></span><br><span class=line>    &LTtitle>HTTP响应示例&LTtitle></span><br><span class=line>    &LT/head></span><br><span class=line>    &LTbody></span><br><span class=line>    Hello HTTP!</span><br><span class=line>    &LT/body></span><br><span class=line>&LT/html></span><br></pre></table></figure><p>通过以上步骤，数据已经传递完毕。HTTP/1.1会维持持久连接一段时间后才会关闭。<h3 id=1-4-3、关闭连接><a class=headerlink href=#1-4-3、关闭连接 title=1.4.3、关闭连接></a>1.4.3、关闭连接</h3><p><strong>客户端或服务端都可以关闭连接。每个请求都使用一个单独的网络连接</strong>。<p><font color=red>注意：服务器不会记住之前的连接处理状态，这种不记忆过去请求状态的协议称为无状态(stateless)协议。</font><h1 id=2、GET与POST><a class=headerlink href=#2、GET与POST title=2、GET与POST></a>2、GET与POST</h1><h2 id=2-1、GET与POST区别><a class=headerlink href=#2-1、GET与POST区别 title=2.1、GET与POST区别></a>2.1、GET与POST区别</h2><ul><li>GET：GET ⽅法是请求从服务器获取资源，这个资源可以是静态的⽂本、⻚⾯、图⽚视频等。<li>POST：POST ⽅法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报⽂的 body ⾥。</ul><h2 id=2-2、GET与POST的安全和幂等><a class=headerlink href=#2-2、GET与POST的安全和幂等 title=2.2、GET与POST的安全和幂等></a>2.2、GET与POST的安全和幂等</h2><h3 id=2-2-1、安全和幂等概念><a class=headerlink href=#2-2-1、安全和幂等概念 title=2.2.1、安全和幂等概念></a>2.2.1、安全和幂等概念</h3><p>安全：<strong>请求⽅法不会「破坏」服务器上的资源</strong>。<p>幂等：<strong>多次执⾏相同的操作，其结果与执行一次的结果相同</strong>。<h3 id=2-2-2、GET安全与幂等><a class=headerlink href=#2-2-2、GET安全与幂等 title=2.2.2、GET安全与幂等></a>2.2.2、GET安全与幂等</h3><p>GET⽅法安全且幂等，因为它是只读操作，⽆论操作多少次，服务器上的数据都是安全的，且每次结果都相同。<h3 id=2-2-3、POST安全与幂等><a class=headerlink href=#2-2-3、POST安全与幂等 title=2.2.3、POST安全与幂等></a>2.2.3、POST安全与幂等</h3><p>POST方法非安全非幂等，因为是新增或提交数据的操作，会创建和修改服务器上的资源，所以非安全非幂等。<h1 id=3、HTTP特性><a class=headerlink href=#3、HTTP特性 title=3、HTTP特性></a>3、HTTP特性</h1><h2 id=3-1、HTTP1-1优点与缺点><a class=headerlink href=#3-1、HTTP1-1优点与缺点 title=3.1、HTTP1.1优点与缺点></a>3.1、HTTP1.1优点与缺点</h2><h3 id=3-1-1、优点><a class=headerlink href=#3-1-1、优点 title=3.1.1、优点></a>3.1.1、优点</h3><p><strong>HTTP 突出优点是简单、灵活、易扩展、跨平台、应用广泛</strong>。<ol><li><p>简单：HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式，易于理解， 降低了学习和使⽤的⻔槛。</p><li><p>灵活易扩展：HTTP协议⾥的各类请求⽅法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开 发⼈员⾃定义和扩充。 同时 HTTP 由于是⼯作在应⽤层（ OSI 第七层），则它下层可以随意变化。 HTTPS 也就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚⾄把 TCP 层换成了基 于 UDP 的 QUIC。</p><li><p>跨平台且应用广泛：互联⽹发展⾄今，HTTP 的应⽤范围⾮常的⼴泛，从台式机的浏览器到⼿机上的各种 APP，从看新闻、 刷贴吧到购物、理财、吃鸡，HTTP 的应⽤⽚地开花，同时天然具有跨平台的优越性。</p></ol><h3 id=3-1-2、缺点><a class=headerlink href=#3-1-2、缺点 title=3.1.2、缺点></a>3.1.2、缺点</h3><p><strong>HTTP 协议是⽆状态、明⽂传输，不安全</strong>。<ol><li><p><font color=orange>⽆状态双刃剑</font></p> <p>⽆状态的好处：因为服务器不会去记忆 HTTP 状态，这能减轻服务器的负担，减少资源占用。</p> <p>⽆状态的坏处：服务器没有记忆能⼒，在完成有关联性的操作时会⾮常麻烦。</p> <p>对于⽆状态的问题，解法⽅案有很多种，其中⽐较简单的⽅式⽤ Cookie 技术。 Cookie 通过在请求和响应报⽂中写⼊ Cookie 信息来控制客户端的状态。 相当于，在客户端第⼀次请求后，服务器会下发⼀个装有客户信息的「⼩贴纸」，后续客户端请求服务器的时候，带上「⼩贴纸」，服务器就能认得。</p><li><p><font color=orange>明⽂传输双刃剑</font></p> <p>好处：明⽂意味着可⽅便阅读，可以直接⾁眼查看（通过浏览器的 F12 控制台或 Wireshark 抓包都可），提高了调试⼯作的便利性。</p> <p>坏处：HTTP 的所有信息都暴露了。在漫⻓的传输过程中很容易被窃取。</p><li><p><font color=orange>不安全</font></p> <p>HTTP ⽐较严重的缺点就是不安全：</p> <ol><li>通信使⽤明⽂，内容可能会被窃听。⽐如，账号信息容易泄漏，那你号没了。<li>不验证通信⽅的身份，因此有可能遭遇伪装。⽐如，访问假的淘宝、拼多多，那你钱没了。<li>⽆法证明报⽂的完整性，所以有可能已遭篡改。⽐如，⽹⻚上植⼊垃圾⼴告，视觉污染，眼没了。</ol> <p>HTTP 的安全问题，可以⽤ HTTPS 的⽅式解决，也就是通过引⼊ SSL/TLS 层，使得在安全上达到了极 致。</p></ol><h2 id=3-2、HTTP1-1性能><a class=headerlink href=#3-2、HTTP1-1性能 title=3.2、HTTP1.1性能></a>3.2、HTTP1.1性能</h2><p><strong>HTTP 协议基于TCP/IP，且使⽤了请求应答通信模式，所以性能的关键就在这两点中</strong>。<ol><li>长连接<li>管道网络传输<li>队头阻塞</ol><h3 id=3-2-1、长连接><a class=headerlink href=#3-2-1、长连接 title=3.2.1、长连接></a>3.2.1、长连接</h3><p>HTTP/1.0中，每发起⼀个请求，都要建立⼀次 TCP 连接（三次握⼿），且是串⾏请求，增加了通信开销。<p>HTTP/1.1 提出了⻓连接通信⽅式，也叫持久连接。<p>持久连接的特点是：<strong>只要任意⼀端没有明确提出断开连接，则保持 TCP 连接状态</strong>。<p><img alt=image-20210415180426292 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415180426292.png?token=AIGEF3ORLSC3ZA2BLR5LH43EZZP3I><h3 id=3-2-2、管道网络传输><a class=headerlink href=#3-2-2、管道网络传输 title=3.2.2、管道网络传输></a>3.2.2、管道网络传输</h3><p><strong>HTTP/1.1 采⽤了⻓连接，这使得管道（pipeline）⽹络传输成为了可能</strong>。<p><strong>同⼀个 TCP 连接中，客户端可以连续发起多个请求，后一个请求不必等待前一个请求处理完毕就可以继续发送。但服务器还是按照顺序先回应 A 请求，再回应 B 请求。要是前⾯的回应特别慢，后⾯就会有许多请求排队等待</strong>。这称为队头堵塞。<h3 id=3-2-3、队头阻塞><a class=headerlink href=#3-2-3、队头阻塞 title=3.2.3、队头阻塞></a>3.2.3、队头阻塞</h3><p>当顺序发送的请求序列中有⼀个请求被阻塞时，后⾯排队的请求也会⼀同被阻塞，这会导致客户端⼀直请求不到数据，这就是队头阻塞。<p><img alt=image-20210415180822708 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415180822708.png?token=AIGEF3M37TWIAH6H5LR25WTEZZP34><h1 id=4、HTTP与HTTPS><a class=headerlink href=#4、HTTP与HTTPS title=4、HTTP与HTTPS></a>4、HTTP与HTTPS</h1><h2 id=4-1、HTTP与HTTPS区别><a class=headerlink href=#4-1、HTTP与HTTPS区别 title=4.1、HTTP与HTTPS区别></a>4.1、HTTP与HTTPS区别</h2><ol><li><p>安全性</p> <p>HTTP是超⽂本传输协议，明⽂传输存在安全⻛险。HTTPS在TCP和HTTP⽹络层之间加⼊了SSL/TLS安全协议，可实现报文加密传输。</p><li><p>建立连接</p> <p>HTTP连接建⽴相对简单， TCP三次握⼿之后便可进⾏ HTTP 的报⽂传输。HTTPS在TCP三次握⼿之后还需进⾏SSL/TLS的握⼿过程才可进行加密报⽂的传输。</p><li><p>端口号</p> <p>HTTP端⼝号是80，HTTPS端⼝号是443。</p><li><p>身份验证</p> <p>HTTP不验证通信方的身份是否可信；</p> <p>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</p></ol><h2 id=4-2、HTTPS解决了HTTP那些问题><a class=headerlink href=#4-2、HTTPS解决了HTTP那些问题 title=4.2、HTTPS解决了HTTP那些问题></a>4.2、HTTPS解决了HTTP那些问题</h2><p>由于HTTP 是明⽂传输，所以安全上存在以下三个⻛险：<ol><li>窃听⻛险：⽐如通信链路上可以获取通信内容，⽤户号容易没。<li>篡改⻛险：⽐如强制植⼊垃圾⼴告，视觉污染，⽤户眼容易瞎。<li>冒充⻛险：⽐如冒充淘宝⽹站，⽤户钱容易没。</ol><p><strong>HTTPS在HTTP与TCP层之间加⼊了SSL/TLS协议，该方式可解决和避免上述⻛险</strong>：<ol><li>信息加密：交互信息⽆法被窃取，但你的号会因为「⾃身忘记」账号⽽没。<li>校验机制：⽆法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾⼴告。<li>身份证书：证明淘宝是真的淘宝⽹，但你的钱还是会因为「剁⼿」⽽没。</ol><p>可⻅，只要⾃身不做「恶」，SSL/TLS 协议可以保证通信安全。<h2 id=4-3、HTTPS加密原理><a class=headerlink href=#4-3、HTTPS加密原理 title=4.3、HTTPS加密原理></a>4.3、HTTPS加密原理</h2><ol><li>混合加密：保证信息机密性，解决窃听⻛险。<li>摘要算法：实现完整性，能够生产校验数据完整性的指纹，解决了篡改⻛险。<li>数字证书：将服务器公钥放⼊到数字证书，解决了冒充⻛险。</ol><h3 id=4-3-1、混合加密><a class=headerlink href=#4-3-1、混合加密 title=4.3.1、混合加密></a>4.3.1、混合加密</h3><p><strong>混合加密可以保证信息机密性，解决窃听⻛险</strong>。<p><img alt=image-20210415182015246 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415182015246.png?token=AIGEF3IWSVAJ73UNNB4TXE3EZZP5Y><p><strong>HTTPS采⽤对称加密和⾮对称加密互相结合的「混合加密」⽅式</strong>：<ul><li>在通信建⽴前采⽤ ⾮对称加密 ⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。<li>在通信过程中全部使⽤ 对称加密 方式「会话秘钥」来加密明⽂数据。</ul><p>采⽤「混合加密」方式的原因：<ol><li><strong>对称加密只使⽤⼀个密钥</strong>，运算速度快，密钥必须保密，⽆法做到安全的密钥交换。<li><strong>⾮对称加密使⽤两个密钥</strong>：公钥和私钥，公钥可以任意分发⽽私钥必须保密，解决了密钥交换的安全问题，但速度会变慢。</ol><h3 id=3-3-2、摘要算法><a class=headerlink href=#3-3-2、摘要算法 title=3.3.2、摘要算法></a>3.3.2、摘要算法</h3><p><strong>摘要算法用于实现完整性，能生成校验数据完整性的指纹，解决了篡改⻛险</strong>。<p><img alt=image-20210415182326356 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415182326356.png?token=AIGEF3I4JU5HIWM3DDG72FLEZZP6Q><p>客户端通过摘要算法算出明⽂的指纹，后将指纹、明⽂⼀同加密后发送给服务器。服务器通过相同的摘要算法计算得出明⽂，通过对比客户端携带的指纹和当前计算得出的指纹，若指纹相同，说明数据完整。<h3 id=4-3-3、数字证书><a class=headerlink href=#4-3-3、数字证书 title=4.3.3、数字证书></a>4.3.3、数字证书</h3><p><strong>客户端先向服务端索要公钥，然后⽤公钥加密信息，服务器收到密⽂后，⽤⾃⼰的私钥解密</strong>。<p>这就存在些问题，如何保证公钥信任度及不被篡改呢？<p>这就需要借助第三⽅权威机构 CA （数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。<p><img alt=image-20210415182616713 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415182616713.png?token=AIGEF3OHAOIT7PDXSJUVURTEZZP7G><p><strong>通过数字证书的⽅式保证服务器公钥的身份，解决冒充的⻛险</strong>。<h2 id=4-4、HTTPS如何建立连接><a class=headerlink href=#4-4、HTTPS如何建立连接 title=4.4、HTTPS如何建立连接></a>4.4、HTTPS如何建立连接</h2><h3 id=4-4-1、SSL-TLS协议基本流程><a class=headerlink href=#4-4-1、SSL-TLS协议基本流程 title=4.4.1、SSL/TLS协议基本流程></a>4.4.1、SSL/TLS协议基本流程</h3><ol><li>客户端向服务器索要公钥并验证。<li>双⽅协商⽣成「会话秘钥」。<li>双⽅通过「会话秘钥」进⾏加密通信。</ol><p>前两步也就是 SSL/TLS 握⼿阶段。<p>SSL/TLS 的「握⼿阶段」涉及四次通信，可⻅下图：<p><img alt=image-20210415183012254 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415183012254.png?token=AIGEF3KKEW4DNJEU4UAEHYTEZZP74><p><img alt=image-20210415183132165 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415183132165.png?token=AIGEF3PK45S4GR7EE3YWP4LEZZQAQ><h3 id=4-4-2、SSL-TLS协议详细流程><a class=headerlink href=#4-4-2、SSL-TLS协议详细流程 title=4.4.2、SSL/TLS协议详细流程></a>4.4.2、SSL/TLS协议详细流程</h3><p>SSL/TLS 协议建⽴的详细流程：<ol><li><p>Client Hello</p> <p><strong>⾸先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求</strong>。</p> <p>在这⼀步，客户端主要向服务器发送以下信息：</p> <ol><li>客户端⽀持的 <strong>SSL/TLS 协议版本</strong>，如 TLS 1.2 版本。<li>客户端⽣成的<strong>随机数</strong>（ Client Random ），后⾯⽤于生成「会话秘钥」。<li>客户端⽀持的<strong>密码套件列表</strong>，如 RSA 加密算法。</ol><li><p>Sever Hello</p> <p><strong>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello</strong> 。</p> <p>服务器回应的内容有如下内容：</p> <ol><li>确认 SSL/ TLS 协议版本，如果浏览器不⽀持，则关闭加密通信。<li>服务器⽣成<strong>随机数</strong>（ Server Random ），后⾯⽤于⽣产「会话秘钥」。<li>确认<strong>密码套件列表</strong>，如 RSA 加密算法。<li><strong>服务器数字证书</strong>。</ol><li><p>客户端回应</p> <p>客户端收到服务器回应之后，<strong>先通过浏览器或者操作系统中的 CA 公钥来确认服务器数字证书的真实性。 如果证书没有问题，客户端会从数字证书中取出服务器公钥，然后使⽤它加密报⽂并向服务器发送如下信息</strong>：</p> <ol><li><p>⼀个<strong>随机数</strong>（ pre-master key ）。该随机数会被服务器公钥加密。</p><li><p><strong>加密通信算法改变通知</strong>，表示随后的信息都将⽤「会话秘钥」加密通信。</p><li><p><strong>客户端握⼿结束通知</strong>，表示客户端的握⼿阶段已经结束。这⼀项同时把之前所有内容发⽣的数据做个摘要，⽤来供服务端校验。</p></ol> <p>上⾯第1项中的随机数是整个握⼿阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就⽤双⽅协商的加密算法，各⾃⽣成本次通信的「会话秘钥」。</p><li><p>服务器最后回应</p> <p><strong>服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法计算出本次通信的「会话秘钥」。然后向客户端发送最后信息</strong>：</p> <ol><li>加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。<li>服务器握⼿结束通知，表示服务器的握⼿阶段已经结束。这⼀项同时把之前所有内容发⽣的数据做个摘要，⽤来供客户端校验。</ol> <p>⾄此，整个 SSL/TLS 的握⼿阶段全部结束。接下来，客户端与服务器进⼊加密通信，就完全是使⽤普通的 HTTP 协议，只不过⽤「会话秘钥」加密内容。</p></ol><h1 id=5、HTTP版本演变><a class=headerlink href=#5、HTTP版本演变 title=5、HTTP版本演变></a>5、HTTP版本演变</h1><h2 id=5-1、HTTP-1-0><a class=headerlink href=#5-1、HTTP-1-0 title=5.1、HTTP/1.0></a>5.1、HTTP/1.0</h2><p><strong>1996年5月，HTTP/1.0 发布</strong>，HTTP/1.0 规定浏览器与服务器只保持短暂连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。<p><strong>TCP连接建立需要三次握手，很耗费，HTTP/1.0的性能比较差</strong>。<h2 id=5-2、HTTP-1-1><a class=headerlink href=#5-2、HTTP-1-1 title=5.2、HTTP/1.1></a>5.2、HTTP/1.1</h2><p>HTTP/1.1 相⽐ HTTP/1.0 性能上的改进：<ol><li><strong>TCP长连接</strong>：使⽤ TCP⻓连接⽅式来降低开销性能开销；<li><strong>管道（pipeline）⽹络传输</strong>：只要第⼀个请求发出去了，不必等其回应就可以发第⼆个请求，减少了整体的响应时间。</ol><p>但是，HTTP/1.1 也有如下缺点：<ol><li>请求/响应头部未经压缩就发送，⾸部信息越多延迟越⼤，只能压缩Body部分；<li>发送冗⻓的⾸部。互相发送相同的⾸部造成了浪费；<li>服务器按请求顺序响应，如果响应中的某个请求阻塞了，那么后面请求会被全部阻塞，会导致客户端⼀直请求不到数据，这就是队头阻塞；<li><strong>没有请求优先级控制</strong>；<li><strong>请求只能从客户端开始，服务器只能被动响应</strong>。</ol><h2 id=5-3、HTTP-2><a class=headerlink href=#5-3、HTTP-2 title=5.3、HTTP/2></a>5.3、HTTP/2</h2><h3 id=5-3-1、HTTP-2概述><a class=headerlink href=#5-3-1、HTTP-2概述 title=5.3.1、HTTP/2概述></a>5.3.1、HTTP/2概述</h3><p><strong>HTTP/2 协议基于 HTTPS ，所以 HTTP/2 安全有保障</strong>。<p>HTTP/2 相⽐ HTTP/1.1，在性能上的改进如下：<ol><li>头部压缩（Hpack压缩算法、QPack算法）<li>二进制格式<li>数据流（Stream）<li>多路复用<li>服务器推送</ol><h4 id=5-3-1-1、头部压缩><a class=headerlink href=#5-3-1-1、头部压缩 title=5.3.1.1、头部压缩></a>5.3.1.1、头部压缩</h4><p><strong>HTTP/2 会压缩头部（Header），如果同时发出多个请求且它们的头相同或相似时，协议会帮你消除重复部分</strong>。<p>HPACK 算法：<strong>在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表并为每个字段⽣成⼀个索引号，后续只需发送索引号即可，进一步提升了性能</strong>。<h4 id=5-3-1-2、二进制格式><a class=headerlink href=#5-3-1-2、二进制格式 title=5.3.1.2、二进制格式></a>5.3.1.2、二进制格式</h4><p><strong>HTTP/2 中不再有 HTTP/1.1 中纯⽂本形式的报⽂了，⽽是全⾯采⽤⼆进制格式。头信息和数据体都是⼆进制，且统称为帧（frame）：头信息帧和数据帧</strong>。<p><img alt=image-20210415184254532 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415184254532.png?token=AIGEF3LQDA677F2OTIUQVNLEZZQBS><p>计算机只懂⼆进制，故收到报⽂后就可以直接解析，避免了转换的步骤，增加了数据传输的效率。<h4 id=5-3-1-3、数据流><a class=headerlink href=#5-3-1-3、数据流 title=5.3.1.3、数据流></a>5.3.1.3、数据流</h4><p>HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。<p><strong>每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编号，规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</strong>。<p><strong>客户端还可以指定数据流优先级</strong>。优先级⾼的请求，服务器会优先对该请求响应。<p><img alt=image-20210415184608092 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415184608092.png?token=AIGEF3OR5RKZEEJUHVEWHZDEZZQCE><h4 id=5-3-1-4、多路复用><a class=headerlink href=#5-3-1-4、多路复用 title=5.3.1.4、多路复用></a>5.3.1.4、多路复用</h4><p><strong>HTTP/2 可以在⼀个连接中并发执行多个请求或回应，且无需按照顺序⼀⼀对应</strong>。<p>移除 HTTP/1.1 串⾏请求，无需排队等待，故也就不会再出现「队头阻塞」问题，降低了延迟， ⼤幅度提⾼了连接利⽤率。<p>举例来说，在⼀个 TCP 连接⾥，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程⾮常耗时，那么就会先回应 A 请求已经处理好的部分，然后回应 B 请求，当B请求的响应完成后，再回来继续回应 A 请求剩下的部分。<h4 id=5-3-1-5、服务器推送><a class=headerlink href=#5-3-1-5、服务器推送 title=5.3.1.5、服务器推送></a>5.3.1.5、服务器推送</h4><p><strong>HTTP/2 ⼀定程度上改善了传统的「请求 - 应答」⼯作模式，服务端不再是被动响应，也可以主动 向客户端发送消息</strong>。<p>举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会⽤到的 JS、CSS ⽂件等静态资源主动发给 客户端，减少延时的等待，也就是服务器推送（Server Push，也叫 Cache Push）。<h3 id=5-3-2、HTTP-2缺陷><a class=headerlink href=#5-3-2、HTTP-2缺陷 title=5.3.2、HTTP/2缺陷></a>5.3.2、HTTP/2缺陷</h3><p>HTTP/2 主要问题：<strong>多个 HTTP 请求复⽤⼀个 TCP 连接时，下层的 TCP 协议不知道有多少 HTTP 请求。所以⼀旦发⽣了丢包现象就会触发 TCP 重传机制，⼀个 TCP 连接中的所有 HTTP 请求都必须等待这个丢了的包被重传回来时才能继续走下去</strong>。<p>HTTP/2丢包阻塞与HTTP/1.1管道阻塞的区别如下：<ul><li>HTTP/1.1 管道（ pipeline）传输中如果某个请求被阻塞了，那么该请求后的请求也会被统统阻塞住。<li>HTTP/2 多个请求复⽤⼀个TCP连接，⼀旦发⽣丢包，随后的所有数据帧都会延迟。</ul><h2 id=5-4、HTTP3><a class=headerlink href=#5-4、HTTP3 title=5.4、HTTP3></a>5.4、HTTP3</h2><p>HTTP/2的缺陷来源于 TCP 传输层，故，HTTP/3 把 HTTP 下层的 TCP 协议换成了 UDP。<p><img alt=image-20210415185214946 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210415185214946.png?token=AIGEF3LH2DFTTVDUAOCE3WTEZZQDA><p>UDP 不管顺序，也不管丢包，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的丢包全部重传问题。<p><strong>UDP 是不可靠传输，但基于UDP的QUIC协议可以帮助其达到类似TCP的可靠性传输效果</strong>。<ul><li><strong>QUIC 有⾃⼰的⼀套机制可以保证传输的可靠性。当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到影响</strong>。<li><strong>TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack</strong> 。<li>HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是TCP三次握⼿，然后 TLS/1.3 三次握⼿。 QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。</ul><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805095840581.png?token=AIGEF3IQMU723LDXPVNHQ3LEZZPLK><p>所以， QUIC 是⼀个在 UDP 之上的伪 TCP + TLS + HTTP/2 的多路复⽤协议。<p>很多⽹络设根本不知道什么是 QUIC，只会当做 UDP，这样会出现新问题。所以 HTTP/3 普及速度⾮常缓慢，未来 UDP 是否能够逆袭 TCP也很难说。<h2 id=5-5、小总结><a class=headerlink href=#5-5、小总结 title=5.5、小总结></a>5.5、小总结</h2><h3 id=5-5-1、Http1-0-VS-Htpp1-1><a title="5.5.1、Http1.0 VS Htpp1.1" class=headerlink href=#5-5-1、Http1-0-VS-Htpp1-1></a>5.5.1、Http1.0 VS Htpp1.1</h3><table><thead><tr><th align=center><th align=center>HTTP/1.0<th align=center>HTTP/1.1<tbody><tr><td align=center><strong>连接持久性</strong><td align=center>http1.0默认非持久连接，每次请求后会断开连接。<td align=center>http1.1支持持久连接，允许在单个连接上执行多个请求和响应。<tr><td align=center><strong>主机头部</strong><td align=center>http1.0不要求host头。<td align=center>http1.1中host头是必需的，允许基于名称的虚拟主机。<tr><td align=center><strong>管道</strong><td align=center>http1.0不支持管道化操作。<td align=center>http1.1支持请求管道化，允许在一个请求得到响应前继续发送其它请求，但响应仍然需要按请求顺序返回。<tr><td align=center><strong>缓存控制</strong><td align=center>http1.0中的缓存是通过<code>Pragmatic:no-cache</code>来控制。<td align=center>http1.1中引入了新的缓存控制头部，比如<code>Cache-Control</code>。<tr><td align=center><strong>错误通知</strong><td align=center>http1.0对于错误的通知不太明确。<td align=center>http1.1引入更多状态码来更精确的描述错误状态。<tr><td align=center><strong>方法和状态码</strong><td align=center>http1.0提供了有限的方法和状态码。<td align=center>http1.1引入了新的方法（OPTIONS、PUT、DELET等）和新的状态码。<tr><td align=center><strong>分块传输编码</strong><td align=center>http1.0不支持。<td align=center>http1.1允许服务器动态生成内容并在不知道整体大小的情况下发送给客户端。<tr><td align=center><strong>范围请求</strong><td align=center>http1.0不支持。<td align=center>http1.1允许客户端请求资源的一部分，这对于大文件和断点续传很有用。</table><h3 id=5-5-2、Http1-1-VS-Htpp2><a title="5.5.2、Http1.1 VS Htpp2" class=headerlink href=#5-5-2、Http1-1-VS-Htpp2></a>5.5.2、Http1.1 VS Htpp2</h3><table><thead><tr><th align=center><th align=center>HTTP/1.1<th align=center>HTTP/2<tbody><tr><td align=center><strong>多路复用</strong><td align=center>http1.1中的每个请求需要一个独立的TCP连接，或需要排队等待其它请求完成。<td align=center>http2中的单个连接可以进行多个并发请求和响应的交换，消除了对头阻塞问题。<tr><td align=center><strong>帧与流</strong><td align=center>http1.1中数据的发送方式较为简单，没有明确的结构。<td align=center>http2中的数据被分解为帧并在流中发送，每个流有一个唯一标识和优先级。<tr><td align=center><strong>头部压缩</strong><td align=center>http1.1的头部以文本形式发送，可能导致冗余。<td align=center>http2中使用HPack压缩格式，进一步减小了头部。<tr><td align=center><strong>服务器推送</strong><td align=center>http1.1中服务器只负责响应客户端的请求。<td align=center>http2中的服务器可以主动推送资源给客户端。<tr><td align=center><strong>二进制协议</strong><td align=center>http1.1中基于文本。<td align=center>http2中基于二进制，使得解析、实现、优化等变得更高效。<tr><td align=center><strong>流控制与优先级</strong><td align=center>http1.1缺少明确的流控制和请求优先级机制。<td align=center>http2中提供应用层的流控制和请求优先级。</table><h1 id=6、HTTP-TCP-Keep-Alive><a title="6、HTTP/TCP Keep-Alive" class=headerlink href=#6、HTTP-TCP-Keep-Alive></a>6、HTTP/TCP Keep-Alive</h1><h2 id=6-1、HTTP-Keep-Alive><a title="6.1、HTTP Keep-Alive" class=headerlink href=#6-1、HTTP-Keep-Alive></a>6.1、HTTP Keep-Alive</h2><h3 id=6-1-1、为什么HTTP是短连接><a class=headerlink href=#6-1-1、为什么HTTP是短连接 title=6.1.1、为什么HTTP是短连接></a>6.1.1、为什么HTTP是短连接</h3><p>众所周知，HTTP是短连接，client向server发送一个request，得到response后，连接就关闭。之所以这样设计使用，主要是考虑到实际情况。例如，用户通过浏览器访问一个web站点上的某个网页，当网页内容加载完毕之后，用户可能需要花费几分钟甚至更多的时间来浏览网页内容，此时完全没有必要继续维持底层连接。当用户需要访问其他网页时，再创建新的连接即可。<p>因此，HTTP连接的寿命通常都很短。这样做的好处是，可以极大的减轻服务端的压力。一般而言，一个站点能支撑的最大并发连接数也是有限的，面对这么多客户端浏览器，不可能长期维持所有连接。每个客户端取得自己所需的内容后，即关闭连接，更加合理。<h3 id=6-1-2、为什么要引入keep-alive><a class=headerlink href=#6-1-2、为什么要引入keep-alive title=6.1.2、为什么要引入keep-alive></a>6.1.2、为什么要引入keep-alive</h3><p>一个网页中，可能引入了几十个js、css文件，上百张图片，如果每请求一个资源就创建一个连接，代价会很大。<p>为解决该问题，只需保证一个连接能在<strong>短时间</strong>内得到复用即可，这就是HTTP协议中keep-alive属性的作用。<blockquote><ul><li>HTTP 1.0 默认关闭Keep-Alive，若要启用 则需要在http头中加入”Connection: Keep-Alive”；<li>HTTP 1.1 默认启用Keep-Alive，若要关闭 则需要在http头中加入”Connection: close “。</ul></blockquote><h3 id=6-1-3、Server端如何处理Keep-Alive><a class=headerlink href=#6-1-3、Server端如何处理Keep-Alive title=6.1.3、Server端如何处理Keep-Alive></a>6.1.3、Server端如何处理Keep-Alive</h3><p><strong>一个连接的复用时间长短，通常由web服务器控制</strong>。<p><strong>HTTP协议中，Keep-Alive属性保持连接的时间长短由服务端决定，通常都在几十秒左右</strong>。除此之外，一些异常情况会导致 keepalive失效。<h3 id=6-1-4、JDK对keep-alive的支持><a class=headerlink href=#6-1-4、JDK对keep-alive的支持 title=6.1.4、JDK对keep-alive的支持></a>6.1.4、JDK对keep-alive的支持</h3><p>当创建一个HttpUrlConnection对象时，底层实际上会创建一个对应的Socket对象。<strong>要复用的并非是HttpUrlConnection，而是底层的Socket</strong>。<p>JDK对keepalive的支持是默认开启，我们要做的是学会如何正确有效使用。<p>参见：<a href=https://link.zhihu.com/?target=https://docs.oracle.com/javase/8/docs/technotes/guides/net/http-keepalive.html>https://docs.oracle.com/javase/8/docs/technotes/guides/net/http-keepalive.html</a><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>When the application finishes reading the response body or when the application calls <span class="title function_">close</span><span class=params>()</span> </span><br><span class=line>on the InputStream returned by URLConnection.getInputStream(), </span><br><span class=line>the JDK<span class=string>'s HTTP protocol handler will try to clean up the connection and if successful, </span></span><br><span class=line><span class=string>put the connection into a connection cache for reuse by future HTTP requests.</span></span><br></pre></table></figure><p>这段话的含义是：当通过URLConnection.getInputStream()读取响应数据之后(这里是HttpUrlConnection)，应该调用InputStream的close方法关闭输入流，JDK http协议处理器会将这个连接放到一个连接缓存中，以便后续HTTP请求来复用。<h2 id=6-2、TCP-Keep-Alive><a title="6.2、TCP Keep-Alive" class=headerlink href=#6-2、TCP-Keep-Alive></a>6.2、TCP Keep-Alive</h2><h3 id=6-2-1、TCP-Keep-Alive探针><a title="6.2.1、TCP Keep-Alive探针" class=headerlink href=#6-2-1、TCP-Keep-Alive探针></a>6.2.1、TCP Keep-Alive探针</h3><p><strong>对于一方发起的keepalive探针，另一方必须响应</strong>。响应可能是以下三种形式之一：<ol><li><p>对方回应了ACK：说明一切OK。如果接下来2小时还没有数据传输，那么还会继续发送keepalive探针，以确保连接存活。</p><li><p>对方回复RST：表示这个连接已经不存在。例如一方服务宕机后重启，此时接收到探针，因为不存在对应的连接。</p><li><p>没有回复：说明socket已经被关闭了。</p> <ul><li><p>tcp_keepalive_intvl：keepalive探测包的发送间隔，默认为75秒。</p><li><p>tcp_keepalive_probes：如果对方不予应答，探测包的最大发送次数，默认为9次。即连续9次发送，都没有应答的话，则关闭连接。</p><li><p>tcp_keepalive_time：连接的最大空闲(idle)时间，默认为7200秒，即2个小时。需要注意的是，这2个小时，指的是只有keepalive探测包，如果期间存在其他数据传输，则重新计时。</p></ul></ol><p>这些默认值在 /proc/sys/net/ipv4 目录下可以找到，文件中的值就是默认值。<p><strong>TCP中的SO_KEEPALIVE是一个开关选项，默认关闭，需要在代码中显式开启。当开启后，通信双方没有数据传输时操作系统底层会定时发送keepalive探测包，以保证连接存活</strong>。<p>在Java 中可以通过Socket设置keepAlive为true：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>Socket socket=<span class=keyword>new</span> <span class="title class_">Socket</span>();</span><br><span class=line>socket.setKeepAlive(<span class=literal>true</span>);  <span class=comment>//开启keep alive</span></span><br><span class=line>socket.connect(<span class=keyword>new</span> <span class="title class_">InetSocketAddress</span>(<span class=string>"127.0.0.1"</span>, <span class=number>8080</span>));</span><br></pre></table></figure><h3 id=6-2-2、TCP-Keep-Alive缺点><a title="6.2.2、TCP Keep-Alive缺点" class=headerlink href=#6-2-2、TCP-Keep-Alive缺点></a>6.2.2、TCP Keep-Alive缺点</h3><ol><li><strong>keep alive只能检测连接是否存活，不能检测连接是否可用</strong>。例如，某一方发生了死锁，无法在连接上进行任何读写操作，但是操作系统仍然可以响应网络层keepalive包。<li><strong>TCP keepalive 机制依赖于操作系统实现，灵活性不够，默认关闭，且keepalive 心跳时间默认是两个小时，时间较长</strong>。<li><strong>代理(如socks proxy)、负载均衡器等工具会让tcp keep-alive失效</strong>。</ol></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <nav class=pagination><a class="extend prev" aria-label=上一页 href=/page/6/ rel=prev title=上一页><i class="fa fa-angle-left"></i></a><a class=page-number href=/>1</a><span class=space>…</span><a class=page-number href=/page/6/>6</a><span class="page-number current">7</span><a class=page-number href=/page/8/>8</a><span class=space>…</span><a class=page-number href=/page/11/>11</a><a class="extend next" aria-label=下一页 href=/page/8/ rel=next title=下一页><i class="fa fa-angle-right"></i></a></nav> <footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer> <div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div> <div class=sidebar-dimmer></div> <div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div> <noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript> <script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script> <script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script> <script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script> <script src=/js/third-party/search/local-search.js></script> 