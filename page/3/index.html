<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hshz21.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content=豪哥博客 name=description><meta content=website property=og:type><meta content=豪哥博客 property=og:title><meta content=https://hshz21.gitee.io/page/3/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content=豪哥博客 property=og:description><meta content=zh_CN property=og:locale><meta content=豪哥 property=article:author><meta content=HG property=article:tag><meta content=summary name=twitter:card><link href=https://hshz21.gitee.io/page/3/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script><script class=next-config data-name=calendar type=application/json>""</script><title>豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <h1 class=site-title>豪哥博客</h1> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>116</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>35</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>128</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=url>微服务系列-分布式事务</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 16:30:51" datetime=2023-10-02T16:30:51+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/ itemprop=url rel=index><span itemprop=name>分布式事务</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、事务概述><a class=headerlink href=#1、事务概述 title=1、事务概述></a>1、事务概述</h1><h2 id=1-1、何为事务><a class=headerlink href=#1-1、何为事务 title=1.1、何为事务></a>1.1、何为事务</h2><p><strong>数据库事务是指数据库执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成</strong>。<p>事务拥有以下四个特性，习惯上被称为ACID特性：<ul><li>**原子性(Atomicity)**：事务作为一个整体被执行，要么全部被执行，要么都不执行。<li>**一致性(Consistency)**：事务执行完毕后其数据的多个副本应保证最新且一致。<li>**隔离性(Isolation)**：一个事务的执行不能影响其它事务的执行。<li>**持久性(Durability)**：已提交事务对数据库的修改应准确同步至数据库。</ul><h2 id=1-2、本地事务><a class=headerlink href=#1-2、本地事务 title=1.2、本地事务></a>1.2、本地事务</h2><p>起初，事务 仅限于 单一数据库资源访问控制。架构服务化以后，事务的概念延伸到了服务中。若 将一个单一的服务操作作为一个事务，那么整个 服务操作 只能涉及 一个单一的数据库资源：<p><strong>基于单个服务、单一数据库资源访问的事务，被称为本地事务（Local Transaction）</strong>。<h2 id=1-3、分布式事务><a class=headerlink href=#1-3、分布式事务 title=1.3、分布式事务></a>1.3、分布式事务</h2><p>本地事务主要限制在单个会话内，不涉及多个数据库资源。但是在基于 SOA（Service-Oriented Architecture，面向服务架构）的分布式应用环境下，需要将多个数据库资源，多个服务访问都纳入到同一个事务当中，分布式事务应运而生。<h3 id=1-3-1、CAP理论><a class=headerlink href=#1-3-1、CAP理论 title=1.3.1、CAP理论></a>1.3.1、CAP理论</h3><p>CAP定理规定一个分布式系统不可能同时满足以下三点特性：<ul><li><p><strong>一致性（Consistercy）</strong></p> <p>一致性 是指 多个数据副本 保持最新且一致（多副本可能是单机上的多副本，也可能是多实例上的副本）。在一致性需求下，执行更新操作后，应该保证系统的数据仍然处于一致状态。</p><li><p><strong>可用性（Availability）</strong></p> <p>每次请求都能获取到正确的响应，但是不保证获取的数据为最新数据。</p><li><p><strong>分区容错性（Partition tolerance）</strong></p> <p>分布式系统在遇到任何网络分区故障时，仍然能够对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</p></ul><p>分布式系统最多只能同时满足 CAP理论中的两项。其中P必须，故只能在CP和AP中选择，zookeeper保证CP（一致性/分区容错），注册中心eruka保证AP（可用性/分区容错）。<h3 id=1-3-2、BASE理论><a class=headerlink href=#1-3-2、BASE理论 title=1.3.2、BASE理论></a>1.3.2、BASE理论</h3><p><strong>BASE是 Basically Available（基本可用）、Soft-state（软状态）和 Eventually Consistent（最终一致性）三个词语的缩写</strong>。<ul><li><p><strong>基本可用</strong></p> <p>分布式系统出现故障时，允许损失部分可用性（服务降级、页面降级）。</p><li><p><strong>软状态</strong></p> <p>允许分布式系统出现中间状态。中间状态 不影响 系统可用性。中间状态 是指 不同的data replication（数据备份节点）之间的数据更新可以出现延时的最终一致性。</p><li><p><strong>最终一致性</strong></p> <p>data replications经过一段时间后才达到一致性。</p></ul><p>BASE理论 是对 CAP中一致性和可用性 权衡的结果，核心思想：<strong>虽然无法达到强一致性，但可达到最终一致性</strong>。<h3 id=1-3-3、分布式事务分类><a class=headerlink href=#1-3-3、分布式事务分类 title=1.3.3、分布式事务分类></a>1.3.3、分布式事务分类</h3><p>分布式事务，本质上是对多个数据库的事务进行统一控制，按照控制力度可以分为：<ol><li>不控制：不控制就是不引入分布式事务；<li>部分控制：部分控制就是各种变种的两阶段提交，包括上面提到的 消息事务+最终一致性、TCC模式；<li>完全控制：完全实现两阶段提交；</ol><p>部分控制的好处是并发量和性能很好，缺点是数据一致性减弱了，完全控制则是牺牲了性能，保障了一致性，具体用哪种方式，最终还是取决于业务场景。<blockquote><p>技术为业务服务，根据不同业务选择合适的技术也是一种能力。</blockquote><h1 id=3、解决方案><a class=headerlink href=#3、解决方案 title=3、解决方案></a>3、解决方案</h1><h2 id=3-1、XA><a class=headerlink href=#3-1、XA title=3.1、XA></a>3.1、XA</h2><p>XA是一个分布式事务协议，由Tuxedo提出。<p>XA大致分为两部分：<ul><li><p><strong>事务管理器</strong></p> <p>事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。</p><li><p><strong>本地资源管理器</strong></p> <p>本地资源管理器往往由数据库实现，比如Oracle、DB2都实现了XA接口。</p></ul><h3 id=3-1-1、原理><a class=headerlink href=#3-1-1、原理 title=3.1.1、原理></a>3.1.1、原理</h3><p>XA实现分布式事务的原理如下：<p>第一阶段</p><img alt=image-20201008160639230 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20201008160639230.png><p>第二阶段</p><img alt=image-20201008160732023 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20201008160732023.png><h3 id=3-1-2、优缺点><a class=headerlink href=#3-1-2、优缺点 title=3.1.2、优缺点></a>3.1.2、优缺点</h3><p>XA协议 比较简单，商业数据库实现XA协议，使用分布式事务的成本也较低。但<strong>XA有致命缺点，即性能不理想</strong>，特别是交易场景下，XA无法满足高并发场景。<p>XA在商业数据库中的支持较理想，在MySQL中就不大支持，MySQL 的 XA 实现，没有记录prepare阶段日志，主备切换会导致 主备库数据不一致。许多nosql也没有支持XA，这让XA的应用场景变得很少。<h2 id=3-2、2PC><a class=headerlink href=#3-2、2PC title=3.2、2PC></a>3.2、2PC</h2><p><strong>2PC（Two-phase commit protocol），中文叫二阶段提交</strong>。 <strong>二阶段提交是一种强一致性设计</strong>，2PC 引入一个事务协调者来协调管理各参与者（可称为各本地资源）的提交和回滚。<p>二阶段包括 <strong>准备、提交</strong> 两个阶段：<ul><li><strong>准备阶段</strong>：协调者 发送准备命令 给 参与者，准备命令 可理解为 除了提交事务，全部工作都做完了。<li><strong>提交阶段</strong>：同步等待 所有资源响应之后 就进入第二阶段，即提交阶段（提交阶段 可以是 提交事务 或 回滚事务）。</ul><p>第二阶段提交失败咋办？有两种情况：<ol><li>第二阶段执行的是事务回滚操作：不断重试，直到 所有参与者 回滚成功，否则 第一阶段准备成功的参与者将一直阻塞。<li>第二阶段执行的是事务提交操作：不断重试，直到 所有参与者 提交成功，实在不行就人工介入处理。</ol><blockquote><p>注意：2PC 是一个同步阻塞协议。<p>第一阶段所有参与者都响应了，协调者才会执行下一阶段操作，第一阶段协调者有超时机制，如果协调者没有收到所有参与者的响应，或超时了，那么都将判定事务失败，会向所有参与者发送回滚命令。</blockquote><p><strong>协调者是一个单点，存在 单点故障 问题</strong>，如果协调者：<ol><li><strong>发送准备命令前</strong>挂了，则还行，等于事务还没开始。<li><strong>发送准备命令后</strong>挂了，就不太行，有些参与者等于都执行了处于事务资源锁定的状态。不仅事务执行不下去，还会因为锁定了一些公共资源而阻塞系统其它操作。<li><strong>发送回滚事务命令前</strong>挂了，那么事务也是执行不下去，且在第一阶段那些准备成功参与者都阻塞着。<li><strong>发送回滚事务命令后</strong>挂了，这个还行，至少命令发出去了，很大的概率都会回滚成功，资源都会释放。但是如果出现网络分区问题，某些参与者将因为收不到命令而阻塞。<li><strong>发送提交事务命令前</strong>挂了，这个不行，傻了！这下是所有资源都阻塞着。<li><strong>发送提交事务命令后</strong>挂了，这个还行，至少命令发出去了，很大概率都会提交成功，然后释放资源，但是如果出现网络分区问题某些参与者将因为收不到命令而阻塞着。</ol><p>协调者故障后，会通过选举得到新协调者，但 新协调者不知道当前事务进行到了哪一阶段？（准备阶段？提交阶段？）。<h2 id=3-3、3PC><a class=headerlink href=#3-3、3PC title=3.3、3PC></a>3.3、3PC</h2><h3 id=3-3-1、3PC简介><a class=headerlink href=#3-3-1、3PC简介 title=3.3.1、3PC简介></a>3.3.1、3PC简介</h3><p><strong>为解决 2PC 中的问题，3PC出现了。3PC在参与者中也引入了超时机制，新增一个阶段使得参与者可以利用这一个阶段统一各自状态。</strong><p><strong>3PC指<code>CanCommit、PreCommit 和 DoCommit</code> 三个阶段</strong>：<ul><li><strong>准备阶段</strong>：询问参与者自身状况，是否准备就绪。<li><strong>预提交阶段</strong>：和 2PC 的准备阶段一样，除了事务提交外，其它都做了。<li><strong>提交阶段</strong>：与 2PC 提交阶段一样。</ul><h3 id=3-3-2、3PC-阶段变更影响><a title="3.3.2、3PC 阶段变更影响" class=headerlink href=#3-3-2、3PC-阶段变更影响></a>3.3.2、3PC 阶段变更影响</h3><p>准备阶段会先询问所有参与者是否可以接收事务操作指令。避免一来就干活而可能导致的所有参与者都被阻塞。<p>预提交阶段 起到了统一状态的作用，在预提交阶段前所有参与者其实都未回应，在预处理阶段则表示所有参与者都已经回应了。<blockquote><p>注意：进入 预提交状态 的 参与者可以推断出来其他参与者也都进入了预提交状态。</blockquote><p><strong>多一个阶段多一个交互，且绝大情况下明知资源可用但还要走流程，故性能会相对差一点</strong>。<h3 id=3-3-3、参与者超时影响><a class=headerlink href=#3-3-3、参与者超时影响 title=3.3.3、参与者超时影响></a>3.3.3、参与者超时影响</h3><p><strong>如果等待提交命令 超时，那么 参与者会自动提交事务。如果等待预提交命令超时，那啥都不做</strong>。<p><font color=red>注意：超时机制也会带来数据不一致问题，参与者 等待提交命令超时后【默认执行提交操作】，但实际需要执行的可能是回滚操作。</font><blockquote><p>从维基百科上看，3PC 的引入是为了解决提交阶段 2PC 协调者和某参与者都挂了之后新选举的协调者不知道当前应该提交还是回滚的问题。<p>新协调者来的时候发现有一个参与者处于预提交或者提交阶段，那么表明所有参与者都已经确认了，所以此时执行的就是提交命令。所以说 3PC 就是通过引入预提交阶段来使得参与者之间的状态得到统一，也就是留了一个时间让大家同步一下。<p>但是这也只能让协调者知道该如果做，但不能保证这样做一定对，这其实和上面 2PC 分析一致，因为挂了的参与者到底有没有执行事务无法断定。所以说 3PC 通过预提交阶段可以减少故障恢复时候的复杂性，但是不能保证数据一致，除非挂了的那个参与者恢复。</blockquote><h3 id=3-3-4、3PC-VS-2PC><a title="3.3.4、3PC  VS  2PC" class=headerlink href=#3-3-4、3PC-VS-2PC></a>3.3.4、3PC VS 2PC</h3><p>3PC 引入参与者超时机制、预提交阶段，降低了故障恢复后协调者的决策复杂度。但整体交互过程变长，性能下降，且会存在数据不一致问题。所以 2PC 和 3PC 都不能保证数据100%一致，故通常都需要定时扫描补偿。<h2 id=3-4、TCC模型><a class=headerlink href=#3-4、TCC模型 title=3.4、TCC模型></a>3.4、TCC模型</h2><h3 id=3-4-1、TCC简介><a class=headerlink href=#3-4-1、TCC简介 title=3.4.1、TCC简介></a>3.4.1、TCC简介</h3><p><strong>TCC是Try、Confirm、Cancel三个词的首字母</strong>，分别对应如下三个阶段：<ol><li><strong>Try（初步操作）</strong>：完成所有业务检查，预留必须的业务资源。<li><strong>Confirm（确认操作）</strong>：真正去执行业务逻辑，不作任何业务检查，只使用 Try 阶段预留的业务资源。因此，只要 Try 操作成功，Confirm 必能成功。且Confirm 需满足 幂等性（一个分布式事务有且只能成功一次）。<li><strong>Cancel（取消操作）</strong>：释放 Try 阶段预留的业务资源。Cancel 操作也需要满足幂等性。</ol><p>TCC分布式事务模型不依赖资源管理器对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务。<p><strong>TCC 分布式事务模型包括三部分</strong>：<ol><li><strong>主业务服务</strong>：整个业务活动的发起方，服务的编排者，负责完成整个业务活动。<li><strong>从业务服务</strong>：整个业务活动的参与方，负责提供 TCC 业务操作，实现初步操作(Try)、确认操作(Confirm)、取消操作(Cancel)三个接口，供主业务服务调用。<li><strong>业务活动管理器</strong>：管理控制整个业务活动，包括记录维护 TCC 全局事务的事务状态和每个从业务服务的子事务状态，并在业务活动提交时调用所有从业务服务的 Confirm 操作，在业务活动取消时调用所有从业务服务的 Cancel 操作。</ol><h3 id=3-4-2、TCC流程><a class=headerlink href=#3-4-2、TCC流程 title=3.4.2、TCC流程></a>3.4.2、TCC流程</h3><p>一个完整的 TCC 分布式事务流程如下：<ol><li>主业务服务 首先开启 本地事务;<li>主业务服务 向业务活动管理器 申请启动 分布式事务主业务活动;<li>主业务活动 先向业务活动管理器 注册 从业务活动，然后调用从业务服务的 Try 接口;<li>当所有从业务服务的 Try 接口调用成功，主业务服务提交本地事务；若调用失败，主业务服务回滚本地事务;<li>若主业务服务提交本地事务，则 TCC 模型分别调用所有从业务服务的 Confirm 接口；若主业务服务回滚本地事务，则分别调用 Cancel 接口;<li>所有从业务服务的 Confirm 或 Cancel 操作完成后，全局事务结束。</ol><h3 id=3-4-3、TCC模型小结><a class=headerlink href=#3-4-3、TCC模型小结 title=3.4.3、TCC模型小结></a>3.4.3、TCC模型小结</h3><p>TCC编程模式也是两阶段提交的一个变种。TCC提供了一个编程框架，将整个业务逻辑分为三块：Try、Confirm和Cancel。以在线下单为例，Try阶段会去扣库存，Confirm阶段去更新订单状态，如果更新订单失败，则进入Cancel阶段，会去恢复库存。<p>TCC就是通过代码人为实现了两阶段提交，不同的业务场景所写的代码都不一样，复杂度也不一样，因此，这种模式并不能很好地被复用。<h2 id=3-5、本地消息表><a class=headerlink href=#3-5、本地消息表 title=3.5、本地消息表></a>3.5、本地消息表</h2><p>本地消息表其实是国外 ebay 搞出来的逻辑。<p>大概流程逻辑如下：<ol><li>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；<li>A 系统将这个消息发送到 MQ 中去；<li>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样<strong>保证不会重复处理消息</strong>；<li>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；<li>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；<li>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。</ol><p>该方案 最大问题 在于 <font color=red>严重依赖于数据库的消息表来管理事务</font>，如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。<h2 id=3-6、可靠消息最终一致性><a class=headerlink href=#3-6、可靠消息最终一致性 title=3.6、可靠消息最终一致性></a>3.6、可靠消息最终一致性</h2><p><strong>基于 MQ 实现分布式事务。RocketMQ 支持消息事务</strong>。<p>大概流程逻辑如下：<ol><li>A 系统先发送一个 prepared 消息到 mq，如果发送失败就取消操作，如果发送成功则执行本地事务，如果本地事务执行成功就让 mq 发送确认消息，如果失败让 mq 发送回滚消息；<li>如果A系统发送了确认消息，B系统也收到了确认消息，则B系统会执行自己的本地事务；<li>mq 会自动定时轮询，检测prepared消息是否发送成功，本地事务是否执行成功，确认消息或回滚消息是否发送成功。<li>如果 B系统 本地事务执行失败 则不断重试直到成功，如果实在是不行，且事务比较重要则发送警报由人工来处理。</ol><p>基于消息中间件的两阶段提交往往用在高并发场景下，将一个分布式事务拆成一个消息事务（A系统的本地操作+发消息）+ B系统的本地操作，其中B系统的操作由消息驱动，只要消息事务成功，那么A操作一定成功，消息也一定发出来了，这时候B会收到消息去执行本地操作，如果本地操作失败，消息会重投，直到B操作成功，这样就变相地实现了A与B的分布式事务。原理如下：<p><img alt=image-20201008161449305 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20201008161449305.png><p>上面方案能够完成A和B的操作，但A和B 并不 严格一致，而是 最终一致，牺牲一致性，换来 性能的大幅度提升。该方式 有风险，如果B一直执行不成功，那么一致性会被破坏，具体要不要玩，还是得看业务能够承担多少风险。<h2 id=3-7、最大努力通知><a class=headerlink href=#3-7、最大努力通知 title=3.7、最大努力通知></a>3.7、最大努力通知</h2><p>该方案大概流程逻辑如下：<ol><li>系统 A 本地事务执行完之后，发送消息到 MQ；<li>最大努力通知服务会一直检测MQ中是否有消息，若存在消息则进行持久化处理，并调用系统B的接口；<li>如果系统B 执行成功则完事，如果执行执行失败，那么“最大努力通知服务”就会定时重试调用系统B，反复 N 次，最后还是不行就放弃；</ol><h2 id=3-8、小结><a class=headerlink href=#3-8、小结 title=3.8、小结></a>3.8、小结</h2><ul><li>2PC/3PC：<strong>是一种强一致性事务</strong>，但依然可能存在数据不一致，阻塞等情况，且只能用在数据库层面。<li>TCC：<strong>是一种补偿性事务</strong>，适用范围更广，在业务层面实现，因此对业务的侵入性较大，每一个操作都需要实现对应的三个方法。<li>本地消息/事务消息/最大努力通知：<strong>是最终一致性事务</strong>，因此适用于一些对时间不敏感的业务。</ul></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ itemprop=url>Java系列-多线程与高并发</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-05 15:04:34" datetime=2023-10-05T15:04:34+08:00 itemprop=dateModified>2023-10-05</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E5%B9%B6%E5%8F%91/ itemprop=url rel=index><span itemprop=name>并发</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、并发编程基础><a class=headerlink href=#1、并发编程基础 title=1、并发编程基础></a>1、并发编程基础</h1><h2 id=1-1、线程简介><a class=headerlink href=#1-1、线程简介 title=1.1、线程简介></a>1.1、线程简介</h2><h3 id=1-1-1、重要概念><a class=headerlink href=#1-1-1、重要概念 title=1.1.1、重要概念></a>1.1.1、重要概念</h3><h4 id=1-1-1-1、进程><a class=headerlink href=#1-1-1-1、进程 title=1.1.1.1、进程></a>1.1.1.1、进程</h4><p><strong>系统资源分配的基本单位</strong>。<p>若要实现多程序并发执行，操作系统需要一个结构来抽象和表示程序的运行。<ul><li>进程 是 操作系统 对正在运行程序的一种抽象。<li>进程 是 由一组机器指令、数据和堆栈等组成的能独立运行的活动实体。<li>操作系统 可以 同时运行多个进程，多个进程可并发执行和交换信息。<li>进程 在运行时需要资源，如CPU、存储空间和I/O设备等。</ul><blockquote><p>并发：同一时刻 只有一个进程或线程 在运行，但因 切换较快 而带给人的感觉像同时在运行。<p>并行：同一时刻 有多个进程或线程 在运行。</blockquote><h4 id=1-1-1-2、线程><a class=headerlink href=#1-1-1-2、线程 title=1.1.1.2、线程></a>1.1.1.2、线程</h4><p><strong>CPU调度的基本单位</strong>。<p>进程调度成本较高（存储空间，CPU，I/O资源等，进程现场保护）并发切换效率较低。为提高调度效率，提出了比进程更轻量的线程。<ul><li>线程较进程更轻量。<li>线程能独立运行，独立调度，拥有资源（CPU资源，程序计数器等）。<li>线程调度成本较低（相对于进程来说），线程切换 不会导致 进程切换。<li>线程能并发执行，进一步提高系统并发性。<li>同一个进程的多个线程可以共享进程资源。</ul><h4 id=1-1-1-3、协程（coroutine）><a class=headerlink href=#1-1-1-3、协程（coroutine） title=1.1.1.3、协程（coroutine）></a>1.1.1.3、协程（coroutine）</h4><h5 id=简介><a class=headerlink href=#简介 title=简介></a>简介</h5><p><strong>最初多数用户线程被设计成协同式调度 （Cooperative Scheduling），故起名为协程（Coroutine）</strong>。由于协程会做调用栈保护、恢复工作，故又称为【有栈协程（Stackfull Coroutine）】，相反也有【无栈协程（Stackless Coroutine）】。<p>无栈协程的典型应用是各种语言中的await、async、yield等关键字。无栈协程本质上是一种有限状态机，状态保存在闭包里，比有栈协程恢复调用栈要轻量，但功能也相对有限。<p>协程主要优势是轻量，无论是有栈协程还是无栈协程，都要比传统内核线程要轻量得多。<blockquote><p>有栈协程有一种实现称为 纤程（Fiber）。</blockquote><h5 id=优缺点><a class=headerlink href=#优缺点 title=优缺点></a>优缺点</h5><p>协程特点如下：<ul><li>协程是【用户模式】下的【轻量级线程】，操作系统内核对协程一无所知。<li>协程调度 由 应用程序控制。<li>一个线程可以包含一个或多个协程。<li>协程有自己的寄存器上下文和栈，协程在调度切换时会将之保存，切换回来时可恢复至保存的状态。<li>协程可以保存上次的调用状态。<li>Windows下的实现叫【纤程】。<li>子程序调用总是一个入口对应一次返回，调用顺序明确。而协程的调用和子程序不同。</ul><p>协程主要一个线程执行，与多线程比，协程有如下优势：<ul><li>执行效率极高：子程序切换由程序控制，【没有线程切换】。<li>无需多线程锁机制：因为只有一个线程，也不存在同时写变量冲突。协程中操作共享资源无需加锁，只判断状态即可，故 执行效率 较 多线程 要高。</ul><h4 id=1-1-1-4、仟程（fiber）><a class=headerlink href=#1-1-1-4、仟程（fiber） title=1.1.1.4、仟程（fiber）></a>1.1.1.4、仟程（fiber）</h4><p>代码移植性一直是平台间交互考虑的重点，将应用程序从Unix移植到Windows的过程中会存在一系列问题，增加了移植难度和成本。<p><strong>为了更正确地将代码移植到Windows，Microsoft 在操作系统中增加了纤程（Fiber）</strong>。纤程与线程对比，有如下特性：<ul><li>线程在Windows内核中实现，操作系统会根据系统的调度算法对线程进行调度；纤程在用户模式下实现，内核对纤程一无所知。<li>纤程是【轻量级线程】，一个线程可包含一个或多个纤程。<li>内核会对线程进行抢占式调度，线程一次只能执行一个纤程代码（具体执行哪一个纤程由用户调度算法决定）。<li>纤程调度与线程调度没有直接关系，操作系统随时可能会夺取纤程所在线程的运行权。<li>正在运行的纤程显式切换到另一个纤程时这个纤程才可以运行。<li>Windows有一套API来实现线程转纤程或在一个线程里面创建多个纤程。</ul><h4 id=1-1-1-5、管程><a class=headerlink href=#1-1-1-5、管程 title=1.1.1.5、管程></a>1.1.1.5、管程</h4><p>临界资源 定义如下：<ul><li>一次只允许一个进程访问的资源；<li>多个进程只能互斥访问的资源；</ul><p>访问临界资源需要同步，比如 信号量 就是一种 进程同步机制。信号量要求每个访问临界资源的进程都具有wait和signal操作。这样使大量的同步操作分散在各个进程中，不仅给系统管理带来了麻烦，且会因同步操作使用不当而导致死锁。为了解决这些问题，管程出现了。<blockquote><p>操作系统中管理的各种软件和硬件资源，均可用 数据结构 抽象地描述其资源特性。利用共享数据结构抽象地表示系统中的共享资源。而把对共享数据结构实施的操作定义为一组过程，如资源的请求和释放过程request和release。进程对共享资源的申请、释放和其他操作，都是通过这组过程来实现，这组过程还可以根据资源情况来选择接受或阻塞进程的访问，确保每次仅有一个进程使用该共享资源，实现临界资源互斥访问。</blockquote><p>管程 就是 共享资源的数据结构 和 对该共享数据结构实施的操作 两者组成的 【资源管理程序】。管程 由 【请求和释放临界资源的进程】 所调用。<p><strong>管程定义了一个数据结构和管理该数据结构的一组操作</strong>。<h3 id=1-1-2、超线程><a class=headerlink href=#1-1-2、超线程 title=1.1.2、超线程></a>1.1.2、超线程</h3><p><strong>超线程（Hyper-Threading，简写HT）是Intel公司为CPU设计的一项技术，旨在提高每个处理器核心的性能</strong>。超线程技术允许单个物理核心模拟多个逻辑核心，从而能够并行处理多个线程。<p>背景：传统单核CPU中，当一个线程等待数据时核心会处于闲置状态。超线程的出现就是为了利用这种等待时间，使得CPU可以处理另一个线程，提高CPU的利用率。<p>工作原理：<ol><li>超线程技术允许CPU具有多于一个的线程执行单元，使得单个物理核心可以执行多个线程。<li>当一个线程因等待数据或其它原因被阻塞时，另一个线程可以使用该核心的资源，增加了核心利用率。<li>通过超线程技术进一步提升了处理器的工作效率和吞吐量。</ol><h3 id=1-1-3、线程优先级><a class=headerlink href=#1-1-3、线程优先级 title=1.1.3、线程优先级></a>1.1.3、线程优先级</h3><p>如今的操作系统基本<strong>采用时间片规则来调度运行线程</strong>，操作系统会分出一个个时间片，然后分配给每个线程，当线程的时间片用完了就会发生线程调度，并等待着下次分配。线程得到时间片的多少就决定了线程能使用处理器资源的多少，而线程优先级就可以一定程度上决定线程得到时间片的多少。<p><strong>Java线程可通过变量<code>priority</code>来控制优先级，优先级范围从1至10。创建线程时可通过方法<code>setPriority(int)</code>来设置优先级，默认优先级为5，优先级高的线程得到时间片的数量要多于优先级低的线程</strong>。<p>针对频繁阻塞（休眠或I/O操作）的线程需要设置较高的优先级，而偏重计算（需要较多CPU时间）的线程则可以设置较低的优先级，确保处理器不会被独占。<p><font color=red>注意：线程优先级的设定并非一定起作用，因为操作系统不一定会重视。</font><h3 id=1-1-4、线程状态><a class=headerlink href=#1-1-4、线程状态 title=1.1.4、线程状态></a>1.1.4、线程状态</h3><p><img alt=image-20210426211305027 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210426211305027.png?token=AIGEF3PT62JG3PZWEBS73BLEZZXC4><p>Java线程在整个生命周期中有6种不同的状态，某一个时间， 线程只能处于其中的一个状态。<ol><li><p><strong>NEW（初始状态）</strong>：线程被构建，但没有调用start方法。</p><li><p><strong>RUNNABLE（运行状态）</strong>：Java线程将就绪和运行两种状态统称为“运行中”。</p><li><p><strong>BLOCKED（阻塞状态）</strong>：表示线程阻塞于锁。</p><li><p><strong>WAITING（等待状态）</strong>：表示当前线程需要等待其它线程做出一些特定操作（通知或中断）。</p><li><p><strong>TIME_WAITING（超时等待状态）</strong>：该状态不同于WAITING，它可以在指定时间内自动返回。</p><li><p><strong>TERMINATED（终止状态）</strong>：表示当前线程已经执行完毕。</p></ol><h3 id=1-1-5、daemon线程><a class=headerlink href=#1-1-5、daemon线程 title=1.1.5、daemon线程></a>1.1.5、daemon线程</h3><p>Daemon（守护）线程是一种支持型线程，主要被用于程序后台调度及支持性工作。当Java虚拟机中不存在非Daemon线程时，Java虚拟机将会退出。可通过调用<code>Thread.setDaemon(true)</code>将线程设置为Daemon线程。<p><font color=red>注意：Daemon属性需要在线程启动之前设置。且Java虚拟机退出时Daemon线程中的finally块并不一定会执行。</font><h2 id=1-2、启动终止线程><a class=headerlink href=#1-2、启动终止线程 title=1.2、启动终止线程></a>1.2、启动终止线程</h2><h3 id=1-2-1、启动线程><a class=headerlink href=#1-2-1、启动线程 title=1.2.1、启动线程></a>1.2.1、启动线程</h3><h4 id=1-2-1-1、启动线程的方式><a class=headerlink href=#1-2-1-1、启动线程的方式 title=1.2.1.1、启动线程的方式></a>1.2.1.1、启动线程的方式</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.Callable;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.ExecutorService;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.Executors;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.FutureTask;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">T02_HowToCreateThread</span> {</span><br><span class=line>    <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">MyThread</span> <span class=keyword>extends</span> <span class="title class_">Thread</span> {</span><br><span class=line>        <span class=meta>@Override</span></span><br><span class=line>        <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">run</span><span class=params>()</span> {</span><br><span class=line>            System.out.println(<span class=string>"Hello MyThread!"</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">MyRun</span> <span class=keyword>implements</span> <span class="title class_">Runnable</span> {</span><br><span class=line>        <span class=meta>@Override</span></span><br><span class=line>        <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">run</span><span class=params>()</span> {</span><br><span class=line>            System.out.println(<span class=string>"Hello MyRun!"</span>);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">MyCall</span> <span class=keyword>implements</span> <span class="title class_">Callable</span>&LTString> {</span><br><span class=line>        <span class=meta>@Override</span></span><br><span class=line>        <span class=keyword>public</span> String <span class="title function_">call</span><span class=params>()</span> {</span><br><span class=line>            System.out.println(<span class=string>"Hello MyCall"</span>);</span><br><span class=line>            <span class=keyword>return</span> <span class=string>"success"</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>//启动线程的5种方式</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=keyword>new</span> <span class="title class_">MyThread</span>().start();</span><br><span class=line>        <span class=keyword>new</span> <span class="title class_">Thread</span>(<span class=keyword>new</span> <span class="title class_">MyRun</span>()).start();</span><br><span class=line>        <span class=keyword>new</span> <span class="title class_">Thread</span>(()->{</span><br><span class=line>            System.out.println(<span class=string>"Hello Lambda!"</span>);</span><br><span class=line>        }).start();</span><br><span class=line></span><br><span class=line>        <span class=type>Thread</span> <span class=variable>t</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Thread</span>(<span class=keyword>new</span> <span class="title class_">FutureTask</span>&LTString>(<span class=keyword>new</span> <span class="title class_">MyCall</span>()));</span><br><span class=line>        t.start();</span><br><span class=line></span><br><span class=line>        <span class=type>ExecutorService</span> <span class=variable>service</span> <span class=operator>=</span> Executors.newCachedThreadPool();</span><br><span class=line>        service.execute(()->{</span><br><span class=line>            System.out.println(<span class=string>"Hello ThreadPool"</span>);</span><br><span class=line>        });</span><br><span class=line>        service.shutdown();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h4 id=1-2-1-2、Callable的使用><a class=headerlink href=#1-2-1-2、Callable的使用 title=1.2.1.2、Callable的使用></a>1.2.1.2、Callable的使用</h4><h5 id=相关类结构图><a class=headerlink href=#相关类结构图 title=相关类结构图></a>相关类结构图</h5><p>接口Callable是一个单独的接口，与之相关的类内部结构图可参考如下：<p><img alt=image-20210706113047202 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210706113047202.png?token=AIGEF3IIKOSDUDGRO73RRQTEZZXEK><h5 id=Callable使用实例><a class=headerlink href=#Callable使用实例 title=Callable使用实例></a>Callable使用实例</h5><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">StartThreadByCallable</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>MyCallable</span> <span class=variable>callable</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">MyCallable</span>();</span><br><span class=line>        <span class=type>FutureTask</span> <span class=variable>futureTask</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">FutureTask</span><>(callable);</span><br><span class=line>        <span class=keyword>new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class=line></span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            <span class=type>Object</span> <span class=variable>result</span> <span class=operator>=</span> futureTask.get();</span><br><span class=line>            System.out.println(<span class=string>"result: "</span> + result);</span><br><span class=line>        }<span class=keyword>catch</span> (InterruptedException | ExecutionException e){</span><br><span class=line>            e.printStackTrace();</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>class</span> <span class="title class_">MyCallable</span> <span class=keyword>implements</span> <span class="title class_">Callable</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">call</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>int</span> <span class=variable>sum</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>1</span>; i <= <span class=number>100</span>; i++){</span><br><span class=line>            <span class=keyword>if</span> (i % <span class=number>2</span> == <span class=number>0</span>){</span><br><span class=line>                sum += i;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> sum;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1-2-2、理解中断><a class=headerlink href=#1-2-2、理解中断 title=1.2.2、理解中断></a>1.2.2、理解中断</h3><p>中断可理解为线程的标识位属性，它表示一个运行中的线程是否被其他线程执行了中断操作。通过调用线程的<code>interrupt()</code>方法可以实现中断线程的操作。<p>线程通过检查自身是否被中断来进行响应，方法<code>isInterrupted()</code>返回线程是否被中断，静态方法<code>Thread.interrupted()</code>返回当前中断状态，并将中断标识设为false。<p><font color=red>注意：终结状态下的线程，即使曾经被中断过，那么方法 isInterrupted() 依旧会返回false。</font><h3 id=1-2-3、过期方法><a class=headerlink href=#1-2-3、过期方法 title=1.2.3、过期方法></a>1.2.3、过期方法</h3><p>suspend()、resume() 和 stop()方法可以实现线程的暂停、恢复和终止。但这些API已经过期，不建议使用。<p>不推荐原因：<font color=red>调用方法suspend()后线程会占用资源进入睡眠状态，易引发死锁问题。stop()方法在终结线程时不能保证正常释放线程资源。</font><blockquote><p>暂停和恢复操作可以用 等待/通知 机制来替代。</blockquote><h3 id=1-2-4、安全终止线程><a class=headerlink href=#1-2-4、安全终止线程 title=1.2.4、安全终止线程></a>1.2.4、安全终止线程</h3><p><strong>通过 标识位或中断操作  可以实现线程终止时有机会清理资源，而非立即停止。这种方法更加安全和优雅</strong>。<h3 id=1-2-5、小结><a class=headerlink href=#1-2-5、小结 title=1.2.5、小结></a>1.2.5、小结</h3><p>可中断的场景如下：<ol><li>Lock<li>Object相关方法（wait）<li>Thread相关方法（join、sleep）</ol><p>不可中断场景如下：<ol><li>synchronized锁</ol><h2 id=1-3、线程间通信><a class=headerlink href=#1-3、线程间通信 title=1.3、线程间通信></a>1.3、线程间通信</h2><h3 id=1-3-1、volatile-synchronized><a title="1.3.1、volatile / synchronized" class=headerlink href=#1-3-1、volatile-synchronized></a>1.3.1、volatile / synchronized</h3><ul><li><p>volatile</p> <p>关键字volatile 可修饰字段，访问该变量时需要从共享内存中获取，对该变量的修改必须同步刷新至共享内存，它能保证所有线程对变量访问的可见性。</p><li><p>synchronized</p> <p>关键字synchronized可修饰方法 或 以同步块形式使用，可保证多个线程在同一时刻只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</p></ul><h3 id=1-3-2、等待-通知机制及范式><a class=headerlink href=#1-3-2、等待-通知机制及范式 title=1.3.2、等待/通知机制及范式></a>1.3.2、等待/通知机制及范式</h3><h4 id=1-3-2-1、等待通知机制><a class=headerlink href=#1-3-2-1、等待通知机制 title=1.3.2.1、等待通知机制></a>1.3.2.1、等待通知机制</h4><p>等待/通知机制是指：<strong>线程A调用对象O的wait()方法后会进入等待状态，线程B调用对象O的notify()或notifyAll()方法后会通知线程A结束等待继续执行</strong>。<p>调用wait()、notify()、notifyAll()时的注意事项如下：<ol><li>使用 wait()、notify() 和 notifyAll() 时需要先对调用对象加锁。<li>调用 wait() 方法后，会将当前线程放入对象的 等待队列，线程状态由RUNNING变为WAITING。<li>调用 notify()、notifyAll() 方法的线程释放锁之后，等待线程才会从wait()返回。<li>notify()方法会将等待队列中的一个等待线程移到同步队列中，而notifyAll() 方法会作用于全部线程，被移动线程的状态会由WAITING变为 BLOCKED。<li>获得调用对象的锁后才能从wait()方法返回。</ol><h4 id=1-3-2-2、等待通知范式><a class=headerlink href=#1-3-2-2、等待通知范式 title=1.3.2.2、等待通知范式></a>1.3.2.2、等待通知范式</h4><p><strong>范式分为两部分：等待方（消费者）、通知方（生产者）</strong>。<p>（1）等待方<ol><li>获取对象的锁；<li>如果条件不满足，那么调用对象的wait方法，被通知后仍要检查条件；<li>条件满足则执行对应的逻辑；</ol><p>（2）通知方<ol><li>获得对象的锁；<li>改变条件；<li>通知所有等待在对象上的线程；</ol><h3 id=1-3-3、管道输入-输出流><a class=headerlink href=#1-3-3、管道输入-输出流 title=1.3.3、管道输入/输出流></a>1.3.3、管道输入/输出流</h3><p><strong>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流的不同之处在于，基于内存实现线程间的数据传输</strong>。<p>管道输入/输出流主要包括了4种具体实现：<ul><li>面向字节：PipedInputStream、PipedOutputStream；<li>面向字符：PipedReader、PipedWriter；</ul><h3 id=1-3-4、Thread-join><a class=headerlink href=#1-3-4、Thread-join title=1.3.4、Thread.join></a>1.3.4、Thread.join</h3><p><strong>线程A执行thread.join()方法表示：线程A等待thread线程终止之后才从thread.join()返回</strong>。<p>除了<code>join()</code>方法外，还提供了<code>join(long millis)</code>和<code>join(long millis, int nanos)</code>两个超时方法。两个超时方法作用：如果线程在给定的超时时间内没有终止，那么会直接返回。<h3 id=1-3-5、ThreadLocal><a class=headerlink href=#1-3-5、ThreadLocal title=1.3.5、ThreadLocal></a>1.3.5、ThreadLocal</h3><p>ThreadLocal是一个以ThreadLocal对象为键、任意对象为值的存储结构。该结构存在于线程上，故一个线程可以根据一个ThreadLocal对象来查询绑定在该线程上的数据。<p>对于线程A，可以通过A.set(T)方法来设置一个值，然后通过A.get()方法获取到原先设置的值。<h1 id=2、CPU><a class=headerlink href=#2、CPU title=2、CPU></a>2、CPU</h1><h2 id=2-1、缓存行><a class=headerlink href=#2-1、缓存行 title=2.1、缓存行></a>2.1、缓存行</h2><h3 id=2-1-1、概述><a class=headerlink href=#2-1-1、概述 title=2.1.1、概述></a>2.1.1、概述</h3><p><strong>CPU缓存行是计算机体系架构中的一个概念，用于描述主存储器和CPU缓存之间的数据传输单位</strong>。缓存行是CPU缓存中最小的可寻址单位，也是一次从主存储器中读取数据块的大小。<p><strong>缓存行的大小是固定的，通常为32字节或64字节，具体取决于CPU设计。缓存行是按连续的内存地址来分割主存储器，且在CPU缓存中以相同方式进行组织。</strong><blockquote><p>为何CPU缓存行大小通常为64字节？原因分析有以下几点：<ul><li><strong>空间局部性</strong>。相邻数据被访问的可能性较大，一次加载连续的内存数据到缓存行中，可以利用这种局部性，减少对主存储器的访问次数，提高数据访问效率。<li><strong>数据传输效率</strong>。CPU与主存储器之间的数据传递是通过总线进行了，总线传输带宽是有限的，一次性加载较大的缓存行可以充分利用总线的宽度，减少数据传输的次数，提高数据传输效率。<li><strong>缓存行对齐</strong>。通常来说，数据的访问需要满足对齐要求。对齐要求是指数据存储在内存中的起始地址必需是某个值（缓存行大小）的倍数。如果不满足对齐要求，CPU需要做额外的工作来获取正确的数据，这增加了访问延迟。通过设定缓存行大小为64字节，可以确保大多数数据类型都能满足对齐要求。<li><strong>缓存容量与成本均衡</strong>。增加缓存行的大小可以提高缓存命中率，提高数据访问效率。但较大的缓存行也会占用更多的缓存容量。通过选择适当的缓存行大小，可以在缓存容量和性能之间取得平衡。</ul></blockquote><p>当CPU需要从主存储器中读取数据时，它会以缓存行为单位进行操作。如果要读取的数据位于缓存行中，CPU会一次性将整个缓存行加载到CPU缓存中，后期需要读取相邻数据时可直接从缓存中读取，提高了读取效率。<p>缓存行的引入是为了解决主存储器与CPU之间速度差异的问题。但缓存行的引入也带来了一些问题，第一个问题就是缓存行对内存的占用，加载到缓存的数据可能只使用了部分，而剩余的空间被浪费了，这也被称为缓存行浪费或缓存行膨胀。第二个问题就是缓存一致性问题，当多个CPU访问共享内存时，由于每个CPU都有自己的缓存，可能造成缓存的不一致，而这可以通过缓存一致性协议来解决。<h3 id=2-1-2、四个状态><a class=headerlink href=#2-1-2、四个状态 title=2.1.2、四个状态></a>2.1.2、四个状态</h3><p><strong>Modified（修改）、Exclusive（独占）、Shared（共享）、Invalid（无效）。</strong><h2 id=2-2、用户态与内核态><a class=headerlink href=#2-2、用户态与内核态 title=2.2、用户态与内核态></a>2.2、用户态与内核态</h2><h3 id=2-2-1、概述><a class=headerlink href=#2-2-1、概述 title=2.2.1、概述></a>2.2.1、概述</h3><p><strong>用户态与内核态是操作系统中的两种执行模式，用于区分运行在不同特权级别下的程序和系统内核。</strong><p><strong>用户态是为用户应用程序提供的一种执行缓存。</strong>用户态下的程序只能访问有限的资源和执行有限的操作。<p><strong>内核态是操作系统的特权执行模式，拥有对操作系统核心和硬件资源的完全控制权。</strong>内核态下的系统内核程序可以执行任何指令和访问任何资源。内核态程序可以执行特权指令、管理内存、调度任务等。<p>当用户程序需要执行特权操作时，会触发一次用户态到内核态的转变，系统内核会接管特权并执行相关操作，操作完成后，再交给用户程序，用户程序继续执行。<h3 id=2-2-2、ring-0-1-2-3><a title="2.2.2、ring 0  1  2  3" class=headerlink href=#2-2-2、ring-0-1-2-3></a>2.2.2、ring 0 1 2 3</h3><p><strong>CPU Ring 0、1、2、3是一种权限级别划分，这种划分通常用于X86体系结构中的操作系统和处理器。</strong><p>X86体系结构中，特权级别使用4个环（Ring）来表示，每个环对应一种特权级别，这些环被称为Ring0、1、2、3，也被称为内核态、系统态、用户态、应用态。<ul><li><p><strong>Ring 0（内核态）</strong>：是操作系统内核运行的特权级别，拥有最高的特权和访问权限。系统内核可以执行所有指令，访问系统的所有资源和硬件设备。</p><li><p><strong>Ring 1（系统态）</strong>：是保留给操作系统的第二特权级别，拥有较高的特权和访问权限。系统可以执行受限的指令集和访问部分授权的资源。</p><li><p><strong>Ring 2（用户态）</strong>：是保留给操作系统的第三特权级别，比Ring 3有更高的特权。系统可以执行受限的指令集和访问部分授权的资源。</p><li><p><strong>Ring 3（应用态）</strong>：是用户程序运行的特权级别，拥有最低的特权和访问权限。程序只能执行授权的指令集，访问有限的资源和执行授权动作。</p></ul><p><strong>CPU运行级别在 Ring3 和 Ring0 间的切换称为用户态和内核态的切换</strong>。<h3 id=2-2-3、上下文切换><a class=headerlink href=#2-2-3、上下文切换 title=2.2.3、上下文切换></a>2.2.3、上下文切换</h3><h4 id=2-2-3-1、简介><a class=headerlink href=#2-2-3-1、简介 title=2.2.3.1、简介></a>2.2.3.1、简介</h4><p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个 任务。在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以<strong>任务从保存到再加载的过程就是一次上下文切换。</strong><p>上下文切换 会影响 多线程执行速度。<h4 id=2-2-3-2、测试上下文切换><a class=headerlink href=#2-2-3-2、测试上下文切换 title=2.2.3.2、测试上下文切换></a>2.2.3.2、测试上下文切换</h4><p>使用<code>Lmbench3</code>可以测量上下文切换时长。使用<code>vmstat</code>可以测量上下文切换次数。<h4 id=2-2-3-3、减少上下文切换><a class=headerlink href=#2-2-3-3、减少上下文切换 title=2.2.3.3、减少上下文切换></a>2.2.3.3、减少上下文切换</h4><p><strong>减少上下文切换的方法：无锁并发编程、CAS算法、使用最少线程和使用协程。</strong><p>实战示例：<ol><li><p>用<code>jstack</code>命令 dump 线程信息，看看 pid 为 3117 的进程中的线程在做什么。</p> <figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>sudo</span> -u admin /opt/ifeve/java/bin/jstack 31177 > /home/tengfei.fangtf/dump17</span><br></pre></table></figure><li><p>统计所有线程分别处于什么状态，发现300多个线程处于 WAITING 状态。</p> <figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>grep java.lang.Thread.State dump17 | awk <span class=string>'{print $2$3$4$5}'</span> | <span class=built_in>sort</span> | <span class=built_in>uniq</span> -c</span><br></pre></table></figure><li><p>打开dump文件查看处于 WAITING 线程在做什么。发现线程池中的线程接收任务太少，大量线程都闲着。</p><li><p>减少线程池中的线程数量。</p><li><p>重新启动服务并测试查看效果。</p></ol><h2 id=2-3、缓存一致性协议><a class=headerlink href=#2-3、缓存一致性协议 title=2.3、缓存一致性协议></a>2.3、缓存一致性协议</h2><h3 id=2-3-1、种类><a class=headerlink href=#2-3-1、种类 title=2.3.1、种类></a>2.3.1、种类</h3><p>协议类型主要有：MSI、MESI、MOSI、Synapse Firefly Dragon。<strong>intel CPU 使用的是MESI协议</strong>。<h3 id=2-3-2、MESI><a class=headerlink href=#2-3-2、MESI title=2.3.2、MESI></a>2.3.2、MESI</h3><p>M、E、S、I 标记 高速缓存行 四种独占状态（使用两个附加位编码）：<ol><li><strong>修改（M）</strong>：高速缓存行仅存在于当前高速缓存中，并且是脏的 - 它已从主存储器中的值修改（M状态）。在允许对（不再有效）主存储器状态的任何其他读取之前，需要高速缓存在将来的某个时间将数据写回主存储器。回写将该行更改为共享状态（S）。<li><strong>独占（E）</strong>：缓存行仅存在于当前缓存中，但是干净 - 它与主内存匹配。它可以随时更改为共享状态，以响应读取请求。或者，可以在写入时将其改变为修改状态。<li><strong>共享（S）</strong>：表示此高速缓存行可能存储在计算机的其他高速缓存中并且是干净的 - 它与主存储器匹配。可以随时丢弃该行（更改为无效状态）。<li><strong>无效（I）</strong>：表示此缓存行无效（未使用）。</ol><p>对于任何给定的高速缓存对，给定高速缓存行的允许状态如图：<p><img alt=image-20201008205937219 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20201008205937219.png?token=AIGEF3IXUJ63WEXUW5FGKLDEZZXHC><p><strong>当块被标记为M（已修改）时，其他高速缓存中关于该块的副本将会被标记为I（无效）</strong>。<h3 id=2-3-3、优缺点><a class=headerlink href=#2-3-3、优缺点 title=2.3.3、优缺点></a>2.3.3、优缺点</h3><h4 id=优点><a class=headerlink href=#优点 title=优点></a>优点</h4><p>MESI多了一个E——“独占”状态。独占状态有许多优点。<p>加入独占状态的缘由：<ol><li>对于“某个处理器需要读取其他处理器没有的块然后写入它”这种情况，会导致 MSI 下发生的两个总线事务（首先是BusRd请求，然后是BusRdX请求）中的第二个请求事务失效。而 MESI 通过添加Exclusive状态解决了这个问题。<li>MSI不适用于顺序执行的应用程序，MESI适用于高度并行的应用程序。</ol><h4 id=缺点><a class=headerlink href=#缺点 title=缺点></a>缺点</h4><p><font color=red>如果由特定块上的各种高速缓存执行 连续读取和写入 操作，则必须每次都将数据刷新到总线上。MOESI协议克服了这一问题。</font><h2 id=2-4、内存屏障><a class=headerlink href=#2-4、内存屏障 title=2.4、内存屏障></a>2.4、内存屏障</h2><h3 id=2-4-1、硬件屏障><a class=headerlink href=#2-4-1、硬件屏障 title=2.4.1、硬件屏障></a>2.4.1、硬件屏障</h3><ul><li>sfence：sava，sfence指令前写 先于 sfence指令后写。<li>lfence：load，lfence指令前读 先于 lfence指令后读。<li>mfence：modify/mix，mfence指令前读写 先于 mfence指令后读写。</ul><h3 id=2-4-2、JVM内存屏障><a class=headerlink href=#2-4-2、JVM内存屏障 title=2.4.2、JVM内存屏障></a>2.4.2、JVM内存屏障</h3><p><img alt=image-20200902211143739 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200902211143739.png?token=AIGEF3JUF3VDP2K4ZX3FWR3EZZXII><h1 id=3、JAVA对象><a class=headerlink href=#3、JAVA对象 title=3、JAVA对象></a>3、JAVA对象</h1><h2 id=3-1、JAVA对象组成><a class=headerlink href=#3-1、JAVA对象组成 title=3.1、JAVA对象组成></a>3.1、JAVA对象组成</h2><h3 id=3-1-1、对象结构><a class=headerlink href=#3-1-1、对象结构 title=3.1.1、对象结构></a>3.1.1、对象结构</h3><p>Java对象保存在内存中时，由以下三部分组成：<p><strong>（1）对象头</strong><ul><li>普通对象头：无压缩16字节，压缩后12字节；<li>数组对象头：无压缩24字节，压缩后16字节；</ul><p><strong>（2）实例数据</strong><p>HotSpot中，对象的实例数据会在对象头后分配空间。<p>字段的分配顺序受源码声明顺序以及HotSpot分配策略的影响。无论哪种分配策略，宽度相同的字段总是相邻分配的；不同宽度间的字段可能存在对其填充；<p>笼统说，基类声明的实例字段会出现在派生类声明的实例字段之前。但开启指针压缩后，派生类的较窄字段可能会插入到基类实例字段之间的对其填充部分。<p>相关参数：FieldsAllocationStyle CompactFields。<p><strong>（3）对齐填充（使得最终对象大小是8的倍数）</strong><p>HotSpot中，GC堆上的对象要求在8字节边界上分配；也就是说对象的起始地址必须是8的倍数，对象占用的空间也必须是8的倍数。<p>若对象时机需要的大小不足8的倍数，则用0填充不足的部分，直到8字节边界为止。<p>对齐填充可能出现在不同宽度的字段之间，也可能出现在对象的末尾；或者当不存在未对齐的数据时则不会出现对齐填充。<p>Java对象头由三部分组成：<p><strong>（1）Mark Word（普通对象头无压缩为8字节，压缩后不变；数组对象头为8字节；）</strong><p>HotSpot中，GC堆上的对象需要维持一些状态信息，如：<ul><li>身份哈希码（identity hash code）<li>是否已被GC标记（GC过程中需要）<li>当前对象年龄<li>当前是否被当作锁同步<li>持有对象锁的线程ID（用于偏向锁）<li>…….</ul><p>该部分会根据对象当前状态有选择性的记录其中一部分。<p><strong>（2）Klass Point（普通对象头无压缩为8字节，压缩后4字节；数组对象头4字节）</strong><p>开启压缩功能参数：<code>-XX:+UseCompressedClassPointers</code>。<p>HotSpot中，堆中的对象从C++角度看都是oopDesc子类的实例。每个对象都有一个_klass字段，指向一个描述自身的元数据的对象。<p>Java对象与数组的Klass并不是Java语言级的java.lang.class。Klass用于运行，而java.lang.class用于Java的反射API；前者中有_java_mirror字段指向后者。<p><strong>（3）数组长度（数组对象才会存在该项）（数组对象长度占用4字节）</strong><h3 id=3-1-2、Mark-Word><a title="3.1.2、Mark Word" class=headerlink href=#3-1-2、Mark-Word></a>3.1.2、Mark Word</h3><p>64位如下：<p><img alt=image-20230805145739393 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805145739393.png?token=AIGEF3L3JWHMKR3UAOTMM33EZZXJU><p>32位如下：<p><img alt=32位Java对象内存布局图01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/32%E4%BD%8DJava%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%9B%BE01.png?token=AIGEF3PUMAZYIJ32BFWNLNDEZZXLO><p>对于hashcode值来说，存在两种情况：<p><strong>（1）没有重写hashcode方法</strong><p>没有重写过hashcode方法时调用System.identityHashCode(…)方法可以拿到由os:random生成的hashcode。<p>os::random生成hashcode的规则为：<code>next_rand = (16807seed) mod (2^31 - 1)</code>，因此可以在对象的markword中用31位空间存储它。<p><strong>（2）重写过hashcode方法</strong><p>重写过的hashcode方法其计算结果不会存储在这里。<h3 id=3-1-3、测试案例><a class=headerlink href=#3-1-3、测试案例 title=3.1.3、测试案例></a>3.1.3、测试案例</h3><p>工具：JOL（Java Object Layout）<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>    <span class=comment>&LT!-- https://mvnrepository.com/artifact/org.openjdk.jol/jol-core --></span></span><br><span class=line>    <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>        <span class=tag><<span class=name>groupId</span>></span>org.openjdk.jol<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>artifactId</span>></span>jol-core<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>        <span class=tag><<span class=name>version</span>></span>0.9<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencies</span>></span></span><br></pre></table></figure><p>jdk8u: markOop.hpp<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=comment>// Bit-format of an object header (most significant first, big endian layout below):</span></span><br><span class=line><span class=comment>//</span></span><br><span class=line><span class=comment>//  32 bits:</span></span><br><span class=line><span class=comment>//  --------</span></span><br><span class=line><span class=comment>//             hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class=line><span class=comment>//             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class=line><span class=comment>//             size:32 ------------------------------------------>| (CMS free block)</span></span><br><span class=line><span class=comment>//             PromotedObject*:29 ---------->| promo_bits:3 ----->| (CMS promoted object)</span></span><br><span class=line><span class=comment>//</span></span><br><span class=line><span class=comment>//  64 bits:</span></span><br><span class=line><span class=comment>//  --------</span></span><br><span class=line><span class=comment>//  unused:25 hash:31 -->| unused:1   age:4    biased_lock:1 lock:2 (normal object)</span></span><br><span class=line><span class=comment>//  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)</span></span><br><span class=line><span class=comment>//  PromotedObject*:61 --------------------->| promo_bits:3 ----->| (CMS promoted object)</span></span><br><span class=line><span class=comment>//  size:64 ----------------------------------------------------->| (CMS free block)</span></span><br><span class=line><span class=comment>//</span></span><br><span class=line><span class=comment>//  unused:25 hash:31 -->| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && normal object)</span></span><br><span class=line><span class=comment>//  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && biased object)</span></span><br><span class=line><span class=comment>//  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 ----->| (COOPs && CMS promoted object)</span></span><br><span class=line><span class=comment>//  unused:21 size:35 -->| cms_free:1 unused:7 ------------------>| (COOPs && CMS free block)</span></span><br></pre></table></figure><h2 id=3-2、Java数据类型><a class=headerlink href=#3-2、Java数据类型 title=3.2、Java数据类型></a>3.2、Java数据类型</h2><h3 id=3-2-1、类型占用字节><a class=headerlink href=#3-2-1、类型占用字节 title=3.2.1、类型占用字节></a>3.2.1、类型占用字节</h3><p><img alt=类型占用字节大小 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200915220817535.png?token=AIGEF3LFVBZGJEJXP4OIP4LEZZXNK><h4 id=3-2-1-1、扩展><a class=headerlink href=#3-2-1-1、扩展 title=3.2.1.1、扩展></a>3.2.1.1、扩展</h4><p>32位操作系统可以寻址到4G内存，因为 2^32 = 4 * 1024 * 1024 = 4G。64位近似无穷大（18EB）。<p>使用64位会有新问题：<strong>64位过长，给我们寻址带宽和对象内引用造成了负担。故引出了指针压缩技术。</strong><h3 id=3-2-2、指针压缩><a class=headerlink href=#3-2-2、指针压缩 title=3.2.2、指针压缩></a>3.2.2、指针压缩</h3><h4 id=3-2-2-1、底层实现><a class=headerlink href=#3-2-2-1、底层实现 title=3.2.2.1、底层实现></a>3.2.2.1、底层实现</h4><p><strong>JVM实现指针压缩的原理就是：不再保存所有引用，而是每隔8个字节保存一个引用。</strong>例如，原来保存每个引用0、1、2…，现在只保存0、8、16…。因此，指针压缩后，并不是所有引用都保存在堆中，而是以8个字节为间隔保存引用。<p>当引用被存入64位寄存器时，JVM会将其左移3位（相当于末尾添加3个0），例如0x0、0x1、0x2…分别被转换为0x0、0x8、0x10。当从寄存器中读出时，JVM又可以右移3位，丢弃末尾的0。（oop在堆中是32位，在寄存器中是35位，2的35次方=32G。也就是说，使用32位，来达到35位oop所能引用的堆内存空间）。<h4 id=3-2-2-2、指针压缩失效><a class=headerlink href=#3-2-2-2、指针压缩失效 title=3.2.2.2、指针压缩失效></a>3.2.2.2、指针压缩失效</h4><p>32G指针压缩失效问题：<strong>因为寄存器中2的35次方只能寻址到32G左右(不一定是32G，可能31G就会发生指压缩失效)，所以当内存超过32G时，JVM就默认停用压缩指针，进而改用64位寻址来寻址所有内存。改用64位寻址会导致对象变大，测试发现40G内存可以存储的对象个数要比30G内存少。</strong><h4 id=3-2-2-3、被压缩的数据><a class=headerlink href=#3-2-2-3、被压缩的数据 title=3.2.2.3、被压缩的数据></a>3.2.2.3、被压缩的数据</h4><ol><li>对象的全局静态变量(即类属性)。<li>对象头信息：64位平台下，原生对象头大小为16字节，压缩后为12字节。<li>对象引用：64位平台下，引用本身大小为8字节，压缩后为4字节。<li>对象数组：64位平台下，数组本身大小为24字节，压缩后16字节。</ol><h4 id=3-2-2-4、不会被压缩的数据><a class=headerlink href=#3-2-2-4、不会被压缩的数据 title=3.2.2.4、不会被压缩的数据></a>3.2.2.4、不会被压缩的数据</h4><ol><li>指向非Heap的对象指针。<li>局部变量、传参、返回值、NULL指针。</ol><h2 id=3-3、Java集合容器><a class=headerlink href=#3-3、Java集合容器 title=3.3、Java集合容器></a>3.3、Java集合容器</h2><h3 id=3-3-1、概述><a class=headerlink href=#3-3-1、概述 title=3.3.1、概述></a>3.3.1、概述</h3><p>Java集合容器整体结构如下图：<p>版本1：<p><img alt=Collection体系架构01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/Collection%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%8401.png?token=AIGEF3IOEOZ2Y5TSXSC4OSDEZZXP4><p>版本2：<p><img alt=集合结构图 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84%E5%9B%BE.jpg?token=AIGEF3POOXUNH77WTUNZZZTEZZXRS><h3 id=3-3-2、Collection><a class=headerlink href=#3-3-2、Collection title=3.3.2、Collection></a>3.3.2、Collection</h3><h4 id=3-3-2-1、List><a class=headerlink href=#3-3-2-1、List title=3.3.2.1、List></a>3.3.2.1、List</h4><h5 id=ArrayList><a class=headerlink href=#ArrayList title=ArrayList></a>ArrayList</h5><ol><li>数据结构：动态数组，需要连续内存。<li>元素特点：<ul><li>数组定义：<code>transient Object[] elementData;</code> 序列化时不考虑其存储元素；<li>允许为null值；</ul><li>增删改查：<ul><li>随机访问快；<li>首部插入速度较linkedlist要慢40%左右，尾部插入较linkedlist要快10%左右，中间插入较linkedlist要快65%左右，其它部分插入删除都会移动数据，性能较低；<li>可以利用CPU缓存，局部性原理。</ul><li>初始容量：<ul><li>JDK7：初始容量为10。<li>JDK8：初始为0，当第一次执行添加操作后才会扩容，扩容后容量为10；</ul><li>扩容：添加数据前已存在元素数量 等于 数组长度时，则扩大为原来的1.5倍，但底层并非是乘上1.5，而是根据公式：<code>原容量>>1+原容量</code>获得。<li>是否同步：非同步，线程不安全；但可以通过<code>Collections.synchronizedList(list)</code>返回一个线程安全的ArrayList，也可以使用concurrent包下的<code>CopyOnWriteArrayList</code>；<li>复杂度：添加n个元素需要O(n)时间；<li>使用场景：快速访问数据；单线程环境；</ol><h5 id=LinkedList><a class=headerlink href=#LinkedList title=LinkedList></a>LinkedList</h5><ol><li>数据结构：双向链表，不需要连续内存。<li>元素特点：<ul><li>链表节点底层实现就是内部类Node，变量Node first、Node last；<li>允许为null值；占用内存多；</ul><li>增删改查：<ul><li>随机访问慢，顺序访问性能还行；<li>首尾插入删除快，中间插入删除慢；</ul><li>初始容量：不需要指定容量；<li>扩容：随插入数据数量扩大；<li>是否同步：非同步，线程不安全；<li>复杂度：<li>使用场景：快速频繁增删数据场景；按顺序访问数据的场景；单线程环境；<li>扩展：可以实现栈、队列和双向队列；</ol><h5 id=Vector><a class=headerlink href=#Vector title=Vector></a>Vector</h5><ol><li>底层数据结构：动态数组；<li>元素特点：数组定义如：<code>Object[] elementData</code>；允许有空值；不支持序列化；<li>增删改查：插入删除效率低，查询效率高；<li>初始容量：默认10；<li>扩容：添加数据前先判断已存在元素数量 是否等于 数组长度，若等于则默认扩大为原来的2倍，如果显式设置了扩容量则按指定的扩容量来扩容，如果扩容后还是不够用，则直接根据要插入的元素数量长度来扩容；（默认容量为10，若首次发生扩容，则默认扩容后的容量为20。如果初始容量为10，然后直接一次性添加21个元素，那么扩容后的容量为21，而并非是40。容量21空闲为0的环境下，此时再添加1个元素，那么会再次扩容为原来的2倍，也即扩容为42）<li>是否同步：同步，线程安全，因其基于synchronized实现线程安全，故效率较差；可以使用concurrent包下的CopyOnWriteArrayList 来代替 Vector；<li>复杂度：<li>使用场景：多线程环境；</ol><h6 id=Stack><a class=headerlink href=#Stack title=Stack></a>Stack</h6><ol><li><p>底层数据结构：数组</p><li><p>元素特点：先进后出；</p><li><p>增删改查：</p> <ol><li>push方法：将元素推入栈底，即数组末尾；<li>pop方法：取出栈顶元素后并删除栈顶元素。<li>peek方法：取出栈顶元素，即数组首个元素。<li>empty方法：判断栈是否为空。<li>search方法：获取指定元素在栈中的位置。</ol> <p>注意：因其继承于Vector，所以其拥有Vector全部功能；</p><li><p>初始容量：空栈。</p><li><p>扩容：继承于vector，与之相同；</p><li><p>是否同步：线程安全；</p><li><p>复杂度：</p><li><p>使用场景：</p></ol><h5 id=CopyOnWriteArrayList><a class=headerlink href=#CopyOnWriteArrayList title=CopyOnWriteArrayList></a>CopyOnWriteArrayList</h5><ol><li>简介：写操作时（写操作加了锁，否则会拷贝多个副本），将原数组拷贝一份出来，然后在拷贝的新数组中执行写操作，操作完后再将原数组引用指向新数组；<li>底层数据结构：动态数组；<li>元素特点：<li>增删改查：<li>初始容量：<li>扩容：<li>是否同步：线程安全；<li>复杂度：<li>使用场景：读多写少，比如缓存；<li>注意事项：<ol><li>写操作需要拷贝数组，比较消耗内存，如果原数组容量比较大，则可能频繁发生YGC和FGC；<li>不能保证实时一致性，只能保证最终一致性；</ol></ol><h4 id=3-3-2-2、Set><a class=headerlink href=#3-3-2-2、Set title=3.3.2.2、Set></a>3.3.2.2、Set</h4><h5 id=HashSet><a class=headerlink href=#HashSet title=HashSet></a>HashSet</h5><ol><li>底层数据结构：基于HashMap和LinkedHashMap实现。具体实现方式：通过一个HashMap存储元素，元素存放在HashMap的key中，而value统一使用一个Object对象。<li>元素特点：<ol><li>无序不重复；<li>只允许1个null元素；</ol><li>增删改查：<li>初始容量：因基于HashMap实现，故规则参考HashMap实现规则；<li>扩容：因基于HashMap实现，故规则参考HashMap实现规则；<li>是否同步：线程不安全；<li>复杂度：<li>使用场景：去重，无需排序场景；</ol><h5 id=LinkedHashSet><a class=headerlink href=#LinkedHashSet title=LinkedHashSet></a>LinkedHashSet</h5><ol><li>底层数据结构：<ol><li>数组+双向链表；<li>基于LinkedHashMap和HashSet机制实现，所以可保证迭代顺序和元素的不重复；</ol><li>元素特点：<ol><li>Entry结构：before/hash/key/value/next/after；before和after用于维护整个双向链表；<li>元素不重复；<li>可以保证插入顺序和访问顺序；</ol><li>增删改查：<li>初始容量：因基于LinkedHashMap实现，参考其实现规则；<li>扩容：因基于LinkedHashMap实现，参考其实现规则；<li>是否同步：线程不安全；<li>复杂度：<li>使用场景：去重，需要保证插入或访问顺序；</ol><h5 id=SortedSet><a class=headerlink href=#SortedSet title=SortedSet></a>SortedSet</h5><ul><li>TreeSet<ol><li>底层实现：基于TreeMap实现。<li>元素特点：元素有序。支持两种排序方式：自然排序和定制排序，默认是自然排序。使用 无参构造时 默认自然排序；当需要使用定制排序时，需要使用 有参构造 来显式指定。<li>存储：通过compare和compareTo来判断是否相等。compare通过判断两个对象的id，相同id则认为是重复元素，不会加入到集合中。</ol></ul><h5 id=EnumSet><a class=headerlink href=#EnumSet title=EnumSet></a>EnumSet</h5><h5 id=CopyOnWriteSet><a class=headerlink href=#CopyOnWriteSet title=CopyOnWriteSet></a>CopyOnWriteSet</h5><ol><li>简介：写操作时（写操作加了锁，否则会拷贝多个副本），将原数组拷贝一份，然后在拷贝的那份数组中执行写操作，操作完后再将原数组引用指向新数组；<li>数组结构：动态数组；<li>原理：通过CopyOnWriteList机制实现；<li>是否同步：线程安全；<li>使用场景：读多写少，比如缓存；<li>注意事项：<ol><li>写操作需要拷贝数组，比较消耗内存，如果原数组容量比较大，则可能频繁发生YGC和FGC；<li>不能保证实时一致性（读取到的数据可能是旧的），只能保证最终一致性；</ol></ol><h5 id=CopyOnWriteArraySet><a class=headerlink href=#CopyOnWriteArraySet title=CopyOnWriteArraySet></a>CopyOnWriteArraySet</h5><ol><li>底层数据结构：动态数组；并非是散列表；<li>元素特点：不能存储重复元素；<li>增删改查>：<li>初始容量：<li>扩容：<li>是否同步：线程安全；<li>复杂度：<li>使用场景：读多写少，比如缓存；</ol><h5 id=ConcurrentSkipListSet><a class=headerlink href=#ConcurrentSkipListSet title=ConcurrentSkipListSet></a>ConcurrentSkipListSet</h5><h4 id=3-3-2-3、Queue><a class=headerlink href=#3-3-2-3、Queue title=3.3.2.3、Queue></a>3.3.2.3、Queue</h4><p>简介：offer()-添加数据后会返回一个布尔类型来表示是否添加成功；peek()-取数据；poll()-取数据后进行remove；<h5 id=Deque><a class=headerlink href=#Deque title=Deque></a>Deque</h5><ul><li>ArrayDeque<li>BlockingDeque<ul><li>LinkedBlockingDeque</ul></ul><h5 id=BlockingQueue（阻塞队列）><a class=headerlink href=#BlockingQueue（阻塞队列） title=BlockingQueue（阻塞队列）></a>BlockingQueue（阻塞队列）</h5><p>简介：在Queue的基础上添加<code>put()</code>和<code>take()</code>方法，这两个是阻塞方法。put装数据装满了会阻塞当前线程，take拿数据拿完了会阻塞当前线程。<ul><li><p>ArrayBlockingQueue</p> <p>简介：它是一个有界阻塞队列，且可以设置有界值，也就是容器的容量。注意本类实现的offer方法可以设置时间，在指定时间过后还是添加不进去再返回。</p><li><p>PriorityBlockingQueue</p><li><p>LinkedBlockingQueue</p> <p>简介：基于链表实现的无界阻塞队列，它可以一直装数据到你内存满为止。</p><li><p>TransferQueue</p> <p>简介：传递的意思，实际上是其它各种Queue的一个组合，它可以给线程传递任务且可以通过列表传递多个。该Queue新增了一个transfer()方法——其逻辑就是装完数据得等着，有线程把它拿走我才可以回去继续干我的事。</p> <p>应用场景：做了一件事，该事需要一个结果才能继续做下一件事。比如网购，我付钱成功后才能给发货，不成功不能发货。</p> <ul><li>LinkedTransferQueue</ul><li><p>SynchronousQueue</p> <p>简介：容量为0，它并非用来装数据，而是专门用来两个线程间传递数据和线程下达任务。该Queue用来进行阻塞式put调用，要求有线程从里面取数据时才能往里面装，相当于直接把数据递给取数据线程的手中。该Queue看似无用，其实不然，其在线程池中用处非常大，多线程取任务，互相间进行任务调度时用的就是这个Queue。</p></ul><h5 id=PriorityQueue><a class=headerlink href=#PriorityQueue title=PriorityQueue></a>PriorityQueue</h5><p>简介：内部结构是一个二叉树，该二叉树可以认为是堆排序里面的小顶堆（最小值为根节点）。PriorityQueue的特点是向里面装数据时不是按顺序装的，而是在内部进行了一个排序，按照优先级，最小的优先。<h5 id=ConcurrentLinkedQueue><a class=headerlink href=#ConcurrentLinkedQueue title=ConcurrentLinkedQueue></a>ConcurrentLinkedQueue</h5><h5 id=DelayQueue（双端队列）><a class=headerlink href=#DelayQueue（双端队列） title=DelayQueue（双端队列）></a>DelayQueue（双端队列）</h5><p>简介：DelayQueue可以基于时间排序。它是阻塞的队列的一种实现，这个阻塞队列在装数据时必须实现Delayed接口，也要实现Comparable接口并重写compareTo方法来实现任务排序的自定义逻辑；<h3 id=3-3-3、Map><a class=headerlink href=#3-3-3、Map title=3.3.3、Map></a>3.3.3、Map</h3><h4 id=3-3-3-1、HashMap><a class=headerlink href=#3-3-3-1、HashMap title=3.3.3.1、HashMap></a>3.3.3.1、HashMap</h4><ol><li><p>底层数据结构：JDK7是数组+单链表；JDK8是数组+单链表+红黑树；</p><li><p>元素特点：无序的key-value键值对；允许null key和null value；</p><li><p>增删改：插入、删除、查询效率较高；</p><li><p>初始容量：默认16（2的N次方）；</p><li><p>扩容：put后判断是否需要扩容；负载因子0.75，当容量 = (总容量*0.75)时触发扩容，扩大为原来的2倍；</p><li><p>是否同步：线程不安全；</p><li><p>复杂度：</p><li><p>使用场景：快速增删改查；随机读取；缓存；</p><li><p>哈希冲突对策：</p> <ul><li>开放定址法；<li>再散列函数法；<li>链地址法（拉链法，HashMap基于此实现）；</ul></ol><h5 id=3-3-3-1-1、LinkedHashMap><a class=headerlink href=#3-3-3-1-1、LinkedHashMap title=3.3.3.1.1、LinkedHashMap></a>3.3.3.1.1、LinkedHashMap</h5><ol><li>底层数据结构：数组+双向链表；<li>元素特点：<ol><li>entry结构：before/hash/key/value/next/after，before和after用于维护整个双向链表；<li>允许一个null key（多个覆盖），允许多个null value；</ol><li>增删改查：<ol><li>在HashMap基础上添加before和after两个属性保证迭代顺序；<li>迭代顺序可以是插入顺序，也可以是访问顺序；<li>使用LRU算法实现访问顺序排序；</ol><li>初始容量：<li>扩容：<li>是否同步：线程不安全；<li>复杂度：<li>使用场景：保证插入和访问顺序；</ol><h4 id=3-3-3-2、IdentityHashMap><a class=headerlink href=#3-3-3-2、IdentityHashMap title=3.3.3.2、IdentityHashMap></a>3.3.3.2、IdentityHashMap</h4><h4 id=3-3-3-3、TreeMap><a class=headerlink href=#3-3-3-3、TreeMap title=3.3.3.3、TreeMap></a>3.3.3.3、TreeMap</h4><ol><li><p><font color=orange>底层数据结构</font>：红黑树（高效检索二叉树）；</p><li><p><font color=orange>元素特点</font>：</p> <ol><li>有序的key-value集合，每一个元素都存储于红黑树的一个节点上；<li>Entry结构：key/value/left/right/parent/color；<li>不允许null key，但可允许多个null value；</ol><li><p><font color=orange>增删改查</font>：默认自然排序，也可定制排序；</p><li><p><font color=orange>初始容量</font>：</p><li><p><font color=orange>扩容</font>：</p><li><p><font color=orange>是否同步</font>：线程不安全；</p><li><p><font color=orange>复杂度</font>：</p><li><p><font color=orange>使用场景</font>：</p><li><p><font color=orange>存储</font>：TreeMap存储时会进行排序，会根据key来对key-value键值对进行排序，其排序方式分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法。</p> <p><font color=orange>自然排序</font>：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。</p> <p><font color=orange>定制排序</font>：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。</p><li><p><font color=orange>获取</font>：</p><li><p><font color=orange>检测元素异同</font>：TreeMap判断两个元素相等的标准：两个key执行equals返回true，且执行<code>compareTo()</code>方法返回0，则认为这两个key相等。</p><li><p><font color=orange>是否同步</font>：非同步。</p><li><p><font color=orange>注意事项</font>：如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的<code>equals()</code>方法，TreeMap中判断相等的标准是：两个key通过<code>equals()</code>方法返回为true，并且通过<code>compareTo()</code>方法比较应该返回为0。</p></ol><h4 id=3-3-3-4、WeakHashMap><a class=headerlink href=#3-3-3-4、WeakHashMap title=3.3.3.4、WeakHashMap></a>3.3.3.4、WeakHashMap</h4><h4 id=3-3-3-5、HashTable><a class=headerlink href=#3-3-3-5、HashTable title=3.3.3.5、HashTable></a>3.3.3.5、HashTable</h4><ol><li><font color=orange>底层数据结构</font>：数组 + 链表；<li><font color=orange>元素特点</font>：无序的key-value键值对，不允许null key 和 null value；<li><font color=orange>增删改查</font>：插入、删除、查询效率较低，因为被synchronized修饰；<li><font color=orange>初始容量</font>：默认11；<li><font color=orange>扩容</font>：put前判断是否需要扩容；负载因子0.75，当容量 >= (总容量*0.75)时触发扩容，扩大为2倍+1；<li><font color=orange>是否同步</font>：线程安全；基于重入锁synchronized实现线程安全；<li><font color=orange>复杂度</font>：<li><font color=orange>使用场景</font>：无序、不重复元素的存储。</ol><h4 id=3-3-3-6、IdentityHashMap><a class=headerlink href=#3-3-3-6、IdentityHashMap title=3.3.3.6、IdentityHashMap></a>3.3.3.6、IdentityHashMap</h4><h4 id=3-3-3-7、ConcurrentHashMap（JDK8）><a class=headerlink href=#3-3-3-7、ConcurrentHashMap（JDK8） title=3.3.3.7、ConcurrentHashMap（JDK8）></a>3.3.3.7、ConcurrentHashMap（JDK8）</h4><ol><li><font color=orange>底层数据结构</font>：数组+单链表+红黑树；<li><font color=orange>锁实现</font>：CAS+Synchronized；<li><font color=orange>元素特点</font>：Node改名为HashEntry；<li><font color=orange>增删改查</font>：<li><font color=orange>初始容量</font>：默认16；<li><font color=orange>扩容</font>：数据等于容量3/4时就扩容为原容量的2倍。<li><font color=orange>是否同步</font>：线程安全；基于 CAS+Synchronized 实现安全；<li><font color=orange>复杂度</font>：<li><font color=orange>使用场景</font>：多线程，高并发场景；</ol><h4 id=3-3-3-8、ConcurrentKipListMap><a class=headerlink href=#3-3-3-8、ConcurrentKipListMap title=3.3.3.8、ConcurrentKipListMap></a>3.3.3.8、ConcurrentKipListMap</h4><h3 id=3-3-4、Iterator><a class=headerlink href=#3-3-4、Iterator title=3.3.4、Iterator></a>3.3.4、Iterator</h3><ul><li><p>Iterator</p> <ol><li>简介：是接口，是集合迭代器。<li>API：<ol><li>boolean hashNext()：判断集合中是否存在下一个元素，若存在，则返回true。<li>Object next()：返回集合中下一个元素。<li>void remove()：删除集合上一次next方法返回的元素。</ol><li>注意事项：<ol><li>iterator()只能单向移动。<li>iterator.remove()可以唯一安全修改迭代过程中集合元素的方法；如果在迭代过程中以任何其它的方式修改了集合，那么将会产生未知行为。且每调用一次<code>next()</code>方法，<code>remove()</code>方法只能被调用一次，如果违反这个规则将抛出一个异常。</ol></ol> <ul><li>ListIterator<ol><li>简介：是一个 功能更强 的迭代器，继承于Iterator接口，只能适用于List。可以通过调用<code>listIterator()</code>方法产生一个指向List开始处的ListIterator，还可以调用<code>listIterator(n)</code>方法创建一个一开始就指向列表索引为n的元素的ListIterator。<li>特点：<ol><li>双向移动（向前向后遍历）<li>产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引。<li>可以使用set方法替换它访问过的最后一个元素。<li>可以使用add方法在next方法返回的元素之前或previous方法返回元素之后插入一个元素。</ol></ol></ul></ul><h3 id=3-3-5、Collection-Collections><a title="3.3.5、Collection / Collections" class=headerlink href=#3-3-5、Collection-Collections></a>3.3.5、Collection / Collections</h3><h4 id=3-3-5-1、Collection><a class=headerlink href=#3-3-5-1、Collection title=3.3.5.1、Collection></a>3.3.5.1、Collection</h4><p><strong>Collection是集合类顶级接口。提供操作集合的通用方法，其继承接口有List与Set</strong>。<h4 id=3-3-5-2、Collections><a class=headerlink href=#3-3-5-2、Collections title=3.3.5.2、Collections></a>3.3.5.2、Collections</h4><p>java.util.Collections 是<strong>集合工具类</strong>。拥有多种操作集合的静态方法，可对集合中的元素执行排序、搜索以及线程安全等操作，服务于Java的Collection框架。<h3 id=3-3-6、总结><a class=headerlink href=#3-3-6、总结 title=3.3.6、总结></a>3.3.6、总结</h3><h4 id=3-3-6-1、HashMap原理><a class=headerlink href=#3-3-6-1、HashMap原理 title=3.3.6.1、HashMap原理></a>3.3.6.1、HashMap原理</h4><h5 id=底层数据结构><a class=headerlink href=#底层数据结构 title=底层数据结构></a>底层数据结构</h5><p>（1）JDK7<p>JDK7底层基于数组 + 单链表实现。<p>JDK7中底层使用HashMap的静态内部类Entry来存储数据：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">Entry</span>&LTK,V> <span class=keyword>implements</span> <span class="title class_">Map</span>.Entry&LTK,V> {</span><br><span class=line>    <span class=keyword>final</span> K key;</span><br><span class=line>    V value;</span><br><span class=line>    Entry&LTK,V> next;</span><br><span class=line>    <span class=type>int</span> hash;</span><br><span class=line>    <span class=comment>// method...</span></span><br><span class=line>}</span><br></pre></table></figure><p>（2）JDK8<p>JDK8底层基于数组 + 单链表 + 红黑树实现。<p>JDK8中底层使用HashMap的静态内部类Node来存储数据：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">Node</span>&LTK,V> <span class=keyword>implements</span> <span class="title class_">Map</span>.Entry&LTK,V>{</span><br><span class=line>    <span class=keyword>final</span> <span class=type>int</span> hash;</span><br><span class=line>    <span class=keyword>final</span> K key;</span><br><span class=line>    V value;</span><br><span class=line>    Node&LTK,V> next;</span><br><span class=line>    <span class=comment>// method...</span></span><br><span class=line>}</span><br></pre></table></figure><blockquote><p>解决哈希冲突的常见方法：开放地址法、链地址法等。HashMap采用了链地址法。</blockquote><h5 id=元素特点><a class=headerlink href=#元素特点 title=元素特点></a>元素特点</h5><p><strong>HashMap支持一个null key 和多个 null value</strong>，原因如下：<ol><li><p>对于 null key 来说，在求hash值时会直接返回0，故只能有一个 null key。</p><li><p>对于 null value 来说，在执行put方法时不会对之进行校验，故可以有多个 null value。</p> <p>这里要注意，HashMap 的get方法执行逻辑是：如果没有查询到指定key的键值对时会返回 null 对象。故get(key)方法的返回结果为null有两种可能：</p> <ol><li>HashMap中不存在这个 key 对应的键值对；<li>HashMap中这个key对应的value为null；</ol> <p>故，在判断HashMap中是否存在某个key时，应该使用containsKey方法；</p></ol><h5 id=常见字段><a class=headerlink href=#常见字段 title=常见字段></a>常见字段</h5><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=comment>/** 保存Node&LTK,V>节点的数组，该表在首次使用时初始化，并根据需要调整大小。 分配时，长度始终是2的幂。 */</span></span><br><span class=line><span class=keyword>transient</span> Node&LTK,V>[] table;</span><br><span class=line><span class=comment>/** 存放具体元素的集合 */</span></span><br><span class=line><span class=keyword>transient</span> Set&LTMap.Entry&LTK,V>> entrySet;</span><br><span class=line></span><br><span class=line><span class=comment>/** 默认初始容量16 */</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=type>int</span> <span class=variable>DEFAULT_INITIAL_CAPACITY</span> <span class=operator>=</span> <span class=number>1</span> << <span class=number>4</span>;</span><br><span class=line><span class=comment>/** 最大容量 */</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=type>int</span> <span class=variable>MAXIMUM_CAPACITY</span> <span class=operator>=</span> <span class=number>1</span> << <span class=number>30</span>;</span><br><span class=line><span class=comment>/** 加载因子，用来计算threshold */</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=type>float</span> <span class=variable>DEFAULT_LOAD_FACTOR</span> <span class=operator>=</span> <span class=number>0.75f</span>;</span><br><span class=line><span class=comment>/** 触发扩容的阈值，实际大小（容量*加载因子）超过该阈值时会触发扩容  */</span></span><br><span class=line><span class=type>int</span> threshold;</span><br><span class=line><span class=comment>/** 负载因子：要调整大小的下一个大小值（容量*加载因子）。</span></span><br><span class=line><span class=comment>通过调节负载因子，可使 HashMap 在时间和空间复杂度上有不同表现。调低负载因子时，扩容效率增高，扩容过程中hash碰撞减少、链表长度变短，这是典型的拿空间换时间； 调高负载因子时，容纳键值对数量变多、空间利用率增高，但碰撞也增高了，最终效率下降。故一般使用默认值即可。*/</span></span><br><span class=line><span class=keyword>final</span> <span class=type>float</span> loadFactor;</span><br><span class=line></span><br><span class=line><span class=comment>/** 进行resize操作时，若桶中数量少于6则从树转成链表 */</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=type>int</span> <span class=variable>UNTREEIFY_THRESHOLD</span> <span class=operator>=</span> <span class=number>6</span>;</span><br><span class=line><span class=comment>/** 链表长度大于8时转化为红黑树 */</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=type>int</span> <span class=variable>TREEIFY_THRESHOLD</span> <span class=operator>=</span> <span class=number>8</span>;</span><br><span class=line><span class=comment>/** 链表转为红黑树时，需先判断当前数组容量是否小于64。若小于64且hash冲突太多，则不进行红黑树转化，而要通过resize函数继续扩容。 */</span></span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=type>int</span> <span class=variable>MIN_TREEIFY_CAPACITY</span> <span class=operator>=</span> <span class=number>64</span>;</span><br><span class=line></span><br><span class=line><span class=comment>/** 记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。 */</span></span><br><span class=line><span class=type>int</span> modCount;  </span><br><span class=line><span class=comment>/** HashMap当前存储的元素数量  */</span></span><br><span class=line><span class=type>int</span> size;</span><br></pre></table></figure><p><strong>HashMap中哈希桶数组table的长度length大小必须为2的n次方（合数）</strong>。<h5 id=hash方法><a class=headerlink href=#hash方法 title=hash方法></a>hash方法</h5><ul><li><p>key为空，则hashcode为0，这也是HashMap只允许存在一个key为null的原因。</p><li><p>key不为空，则计算公式如下：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>int</span> <span class=variable>hash</span> <span class=operator>=</span> (h = key.hashCode()) ^ (h >>> <span class=number>16</span>); 	<span class=comment>// 求hash值</span></span><br><span class=line><span class=type>int</span> <span class=variable>index</span> <span class=operator>=</span> (n - <span class=number>1</span>) & hash; 					<span class=comment>// 定位下标</span></span><br></pre></table></figure></ul><h5 id=put-操作><a class=headerlink href=#put-操作 title=put()操作></a>put()操作</h5><p><strong>JDK1.7采用头插法，JDK1.8采用尾插法</strong>。<p>JDK8执行流程如下：<ol><li>计算待新增数据key的hash值；<li>判断Node[]是否为空，若为空需要进行初始化；<li>通过运算(hash &(len-e))得出待插入元素要存储在数组中的下标位置idx，如果该位置idx没有数据，那么该元素数据添加成功。如果该位置idx有数据，则继续判断：<ol><li>如果该位置idx处Node节点的key与待插入数据的key相等，则直接覆盖已存在的值，然后返回旧值；<li>如果该结构是树形，则按照树的方式插入数据；<li>如果该结构是链表，则从上到下遍历该链表。如果当前节点的下一节点为null，则将待插入数据放在这个null位置，然后判断链表长度是否大于阈值8，如果 >= 8 且数组长度 >= 64 才转为红黑树，如果 >= 8 且数组长度 < 64 则仅仅进行链表的扩容；如果当前节点的下一个节点不为null，且该节点hash、key与待插入元素数据的hash和key都相同，则将待插入数据替换该节点，然后返回旧值。如果该节点hash、key与待插入数据的hash和key不一样，那就继续遍历该链表。</ol><li>判断数组长度是否大于阈值，如果是则进入扩容阶段；</ol><h5 id=resize-操作><a class=headerlink href=#resize-操作 title=resize()操作></a>resize()操作</h5><p><strong>当数组元素数量 = 数组长度*0.75时触发扩容，扩容后数组长度是旧的2倍。</strong><p>Java8与Java7的迁移算法不一样，Java8不需要每一个元素都重新计算hash值；JDK8只需根据原hash值新增的那个bit是1还是0来判断，是0的话索引没变，是1的话索引变成：(原索引+oldCap)。<p><font color=red>注意：JDK1.7中旧链表迁移至新链表时，如果与新表数组索引位置相同，则链表元素会倒置；而JDK1.8不会倒置。</font><h5 id=get-key-操作><a class=headerlink href=#get-key-操作 title=get(key)操作></a>get(key)操作</h5><ol><li>根据put()方法中计算hash的方式得到一个数组下标index；<li>遍历数组下标为index所对应的链表，若找到key和hash值同时相等的就返回该值，否则返回null；</ol><h5 id=remove-操作><a class=headerlink href=#remove-操作 title=remove()操作></a>remove()操作</h5><ol><li>根据get()方法中的方式计算出要删除的key对应的Node节点；<li>如果待删除节点是头节点，则将它的next节点作为头节点；<li>如果待删除节点是红黑树，则直接调用红黑树的删除算法进行删除；<li>如果待删除节点是链表中的一个节点，则将待删除节点的前一个节点的next属性指向待删除节点的下一个节点即可；<li>如果删除成功则返回被删除节点的value，否则返回null；</ol><p><font color=red>注意：删除单个key时，返回的是键值对中的value；</font><h5 id=iterator迭代器><a class=headerlink href=#iterator迭代器 title=iterator迭代器></a>iterator迭代器</h5><p><code>Hashtable</code> 和 <code>HashMap</code> 有相同的迭代器 Iterator，<code>HashMap</code>和<code>Hashtable</code> 的 Iterator 都是快速失败 fail-fast。但<code>Hashtable</code> 还有另外一个迭代器 Enumeration，该迭代器是 安全失败 fail-safe，<code>HashTable</code> 中有一个 keys 方法可以返回 Enumeration 迭代器。<blockquote><p><strong>fail-safe 和 fail-fast 是一种思想，一种机制，属于系统设计范畴，并非 Java 集合所特有</strong>。<p><strong>（1）快速失败 fail-fast</strong><p>一种快速发现系统故障的机制。一旦发生异常，立即停止当前操作，并上报给上层的系统来处理这些故障。<p>当 Iterator 这个迭代器被创建后，除了迭代器本身的方法 remove 可以改变集合的结构外，其他的因素若改变了集合的结构（改变只包含插入和删除），都将会抛出 <code>ConcurrentModificationException</code> 异常。<p><strong>java.util 包下的集合类都是 fail-fast 的</strong>。<p><strong>（2）安全失败 fail-safe</strong><p>在故障发生之后会维持系统继续运行。 fail-safe 不会抛出异常的原因如下：<ol><li>当集合的结构被改变时，fail-safe 机制会复制一份原集合数据，然后在复制的那份数据上进行遍历。</ol><p>虽然 fail-safe 不会抛出异常，但存在以下缺点：<ol><li>不能保证遍历的是最新内容。也就是说迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的；<li>复制时需要额外的空间和时间开销。</ol><p>顾名思义，和 fail-fast 恰恰相反，当我们对集合的结构做出改变的时候，fail-safe 机制不会抛出异常。<p><strong>java.util.concurrent 包下的容器都是 fail-safe 的。</strong></blockquote><h5 id=线程安全><a class=headerlink href=#线程安全 title=线程安全></a>线程安全</h5><p>HashMap非线程安全，而ConcurrentHashMap线程安全。<p>ConcurrentHashMap底层结构在JDK1.7和1.8中也不同：<ul><li>JDK1.7： 分段锁；<li>JDK1.8：CAS + Synchronized；</ul><h5 id=并发问题><a class=headerlink href=#并发问题 title=并发问题></a>并发问题</h5><p>常见问题如下：<ol><li>多线程扩容，引起死循环问题；<li>多线程put时可能导致元素丢失；<li>put非null元素后get出来的是null；</ol><p>应对措施：使用HashTable 或者 ConcurrentHashMap。<h5 id=Key取值问题><a class=headerlink href=#Key取值问题 title=Key取值问题></a>Key取值问题</h5><ol><li><p>key只允许有一个null，value允许有多个null；（key为null的hashcode总是0）</p><li><p>key取值范围有哪些？</p> <p>一般使用String、Integer，且String最常用。原因如下：</p> <ol><li>字符串是不可变的，它在被创建时其hashcode就缓存了，无需计算，且效率要比其它对象高。<li>获取对象时需要用到equals方法和hashCode方法，而String已经规范的重写过了。</ol><li><p>可变类可以作为key使用吗？</p> <p>不可以，因为hashcode可能会发生变化，导致put进去的值，无法get出来。</p><li><p>如何自定义一个类，其可以作为HashMap的key？</p> <p>该问题考察两个知识点：</p> <ol><li><p>如何重写equals方法和hashCode方法？</p> <p>根据如下4条规则来设计即可：</p> <ol><li>两个对象相等，hashcode⼀定相等；<li>两个对象不等，hashcode不⼀定不等；<li>hashcode相等，两个对象不⼀定相等；<li>hashcode不等，两个对象⼀定不等；</ol><li><p>如何设计一个不变类？</p> <ol><li>使用final修饰类，保证类不能被继承。<li>将所有成员变量访问权限设为私有，且加上final修饰，保证成员变量不可变；<li>不提供修改成员变量的方法；<li>通过构造器初始化所有成员，进行深拷贝；<li>getter方法中不要直接返回对象本身，而要返回克隆对象，防止逃逸。</ol></ol></ol><h5 id=位运算-VS-取模运算><a title="位运算 VS 取模运算" class=headerlink href=#位运算-VS-取模运算></a>位运算 VS 取模运算</h5><p>HashMap采用 位运算 的原因如下<ol><li><strong>效率高。</strong>位运算直接对内存数据进行操作，不需要转换为十进制，因此处理速度快；<li><strong>可以解决取模运算的负数问题。</strong>比如：-15 % 10 = -5；</ol><h5 id=JDK7和JDK8下HashMap的异同><a class=headerlink href=#JDK7和JDK8下HashMap的异同 title=JDK7和JDK8下HashMap的异同></a>JDK7和JDK8下HashMap的异同</h5><ol><li>存放数据的节点名称不同；JDK7使用 Entry 命名；JDK8使用 Node 命名；<li>定位数组下标位置方法不同；<ul><li>JDK7：计算key的hash，然后进行四次扰动，再与数组长度取模得出；<li>JDK8：计算key的hash，将hash值进行高低16位异或操作，再与数组长度取模得出；</ul><li>扩容时机不同：JDK7添加数据前先判断是否需要扩容；JDK8添加数据后再判断是否需要扩容；<li>扩容迁移定位方法不同；<ul><li>JDK7：扩容后需要重新计算hash；<li>JDK8：扩容后不需要重新计算hash；</ul><li>put方法插入链表位置不同：<ul><li>JDK7：头插法；<li>JDK8：尾插法；</ul><li>红黑树升级和退化<ul><li>链表升级为红黑树：<strong>JDK8引入红黑树，当链表长度 >= 8 且 数组长度 >= 64 时，链表转为红黑树；</strong><li>红黑树退化为链表：有两个地方会判断并退化成链表：<ol><li><strong>remove时退化；</strong><li><strong>扩容时会调用<code>split()</code>进行红黑树的扩容移动处理。</strong>split方法中，会将当前红黑树左右子树分别放入low，high两个w变量（treeNode类型）中。可理解为两条链表，当low链表中元素<=6时会将low转换为真正的链表（Node类型），当low链表中元素>6时会进行树化处理， 例如对链表中节点的left、right等进行赋值，high链表同理。</ol></ul></ol><h5 id=HashMap-VS-HashTable><a title="HashMap VS HashTable" class=headerlink href=#HashMap-VS-HashTable></a>HashMap VS HashTable</h5><ol><li>初始容：HashMap是16；HashTable是11；<li>定位数组下标位置：<ul><li>HashMap：key.hashcode()后 通过 位运算 定位下标；<li>HashTable：key.hashcode()后 通过 取模运算 定位下标；</ul><li>判断扩容时机：HashMap在put后判断；HashTable在put前判断；<li>扩容大小：HashMap扩大为原容量的2倍；HashTable扩大为原容量的2倍+1；<li>null key 和 null value<ul><li>HashMap：允许1个null key（多个覆盖）和 多个null value；<li>HashTable：不允许null key 和 null value；</ul><li>线程安全：HashMap线程不安全；HashTable线程安全；<li>接口实现：HashMap实现Map接口且继承AbstractMap类；HashTable实现Map接口且继承Dictionary类；</ol><h5 id=HashMap-VS-TreeMap><a title="HashMap VS TreeMap" class=headerlink href=#HashMap-VS-TreeMap></a>HashMap VS TreeMap</h5><ol><li>数据结构：HashMap是数组+链表+红黑树；TreeMap是红黑树；<li>存储方式：HashMap是随机存储；TreeMap是按key的字典升序排序存储；<li>null key 和 null value<ul><li>HashMap：允许1个null key（多个覆盖），允许多个null value；<li>TreeMap：不允许null key，但允许多个null value；</ul><li>效率高低：HashMap效率高；TreeMap效率低；</ol><h4 id=3-3-6-2、HashTable原理><a class=headerlink href=#3-3-6-2、HashTable原理 title=3.3.6.2、HashTable原理></a>3.3.6.2、HashTable原理</h4><h5 id=底层数据结构-1><a class=headerlink href=#底层数据结构-1 title=底层数据结构></a>底层数据结构</h5><p>使用哈希表来存储键值对，数据结构创建了一个继承<code>Map.Entry</code>的私有静态内部类<code>Entry</code>，每一个Entry对象表示存储在哈希表中的一个键值对。<h5 id=元素特点-1><a class=headerlink href=#元素特点-1 title=元素特点></a>元素特点</h5><p><strong>HashTable不支持 null key和null value</strong>，原因如下：<ol><li>对于 null value 来说，在执行put方法时会直接抛出异常NullPointerException。<li>对于 null key 来说，在定位元素时会执行key.hashCode方法，会抛出NullPointerException。<li>若允许 null key 和 null value，则多线程环境下会出现问题。（ConcurrentHashMap也不允许null key 和 null value。）</ol><h5 id=rehash方法（扩容）><a class=headerlink href=#rehash方法（扩容） title=rehash方法（扩容）></a>rehash方法（扩容）</h5><p><strong>当前容量 >=（总容量 * 负载因子）时，Hashtable 扩大为旧容量的2倍+1；</strong><h4 id=3-3-6-3、ArrayList原理><a class=headerlink href=#3-3-6-3、ArrayList原理 title=3.3.6.3、ArrayList原理></a>3.3.6.3、ArrayList原理</h4><h5 id=add-element-操作><a class=headerlink href=#add-element-操作 title=add(element)操作></a>add(element)操作</h5><ol><li><p>判断当前数组是否为空，若是则创建长度为10的数组，因为new ArrayList 时没有初始化；</p><li><p>判断是否需要扩容，即：当前数组中元素数+1后（size+1）判断其是否大于当前数组长度，是则进行扩容（执行grow()方法）;</p> <p>grow()方法流程如下：</p> <ol><li>创建新数组，其长度为原数组长度的1.5倍；<li>如果扩大1.5倍后依然不够，则根据实际长度来扩容，比如addAll()场景；<li>将原数组的数据通过<code>System.arraycopy</code>方法（native方法）复制到新数组中；</ol><li><p>在数组末尾添加数据，并将size+1；</p></ol><h5 id=add-index-element-操作><a title="add(index, element)操作" class=headerlink href=#add-index-element-操作></a>add(index, element)操作</h5><ol><li>检查index是否在数组范围内，假如数组长度是2，则index必须 >= 0 且 <= 2，否则抛出异常IndexOutOfBoundsException异常；<li>扩容检查；<li>通过拷贝方式，把数组位置为index至size-1的元素都往后移动一位，腾出位置后放入元素，并将size+1；</ol><h5 id=set-index-element-操作><a title="set(index, element)操作" class=headerlink href=#set-index-element-操作></a>set(index, element)操作</h5><ol><li>检查index是否在数组范围内，加入数组长度为2，则index必须 >= 0 且 < 2；<li>保存被覆盖的值，因为最终需要返回旧值；<li>新元素放至index位置，并返回该位置旧值；</ol><h5 id=remove-index-操作><a class=headerlink href=#remove-index-操作 title=remove(index)操作></a>remove(index)操作</h5><ol><li>检查index是否在数组范围内，假如数组长度是2，则index必须 >= 0 且 <= 2；<li>保留要删除的值，因为最终要返回该值（旧值）；<li>计算需要移动元素的个数，再通过拷贝使数组中位置为 index+1 到 size-1 的元素向前移动一位，然后把数组最后一位元素设为null，返回旧值；</ol><h5 id=注意事项><a class=headerlink href=#注意事项 title=注意事项></a>注意事项</h5><ol><li><strong>new ArrayList创建对象时，如果没有指定容量则初始化为0；如果有指定，则按照指定大小进行初始化；</strong><li><strong>扩容时，将容量扩大1.5倍，如果还是不够则根据实际元素数量来扩大，保证能存储所有数据，比如addAll场景；</strong><li><strong>若扩容后数组长度大于 (Integer.MAX_VALUE - 8)，则抛出异常OutOfMemoryError。</strong></ol><h5 id=ArrayList-VS-Vector><a title="ArrayList VS Vector" class=headerlink href=#ArrayList-VS-Vector></a>ArrayList VS Vector</h5><ol><li>线程安全：ArrayList不安全；Vector安全；<li>扩容倍数：ArrayList默认1.5倍；Vector默认扩大为原容量的2倍，创建时也可显式设置扩容量；<li>支持序列化：ArrayList支持序列化；Vector不支持；<li>indexOf()接口支持：ArrayList提供了indexOf(obj, start)接口；Vector没有提供；<li>指定扩容系数：ArrayList不可以指定；Vector可以指定；</ol><h5 id=ArrayList-VS-LinkedList><a title="ArrayList VS LinkedList" class=headerlink href=#ArrayList-VS-LinkedList></a>ArrayList VS LinkedList</h5><ol><li>底层数据结构：ArrayList是动态数组；LinkedList是双向链表；<li>增删改查特点：ArrayList查询快增删慢；LinkedList随机查询慢，顺序查询快，增删快；<li>空间浪费：ArrayList会在数组末尾保留一定空间；LinkedList会在每一个节点都要消耗空间来存储prev、next信息；</ol><h4 id=3-3-6-4、LinkedList原理><a class=headerlink href=#3-3-6-4、LinkedList原理 title=3.3.6.4、LinkedList原理></a>3.3.6.4、LinkedList原理</h4><h5 id=add-操作><a class=headerlink href=#add-操作 title=add()操作></a>add()操作</h5><ol><li>创建一个新节点，节点元素为传入的参数，前继节点是 当前节点的last节点，后继节点next为null；<li>判断当前链表last节点是否为null，如果是，则把新建的节点作为头节点，否则把新建的节点作为last节点；<li>最后返回true；</ol><h5 id=get-index-element-操作><a title="get(index, element)操作" class=headerlink href=#get-index-element-操作></a>get(index, element)操作</h5><ol><li>检擦index是否在数组长度范围内，假如数组长度为2，则index必须 >= 0 且 < 2；<li>如果 index 小于 (双向链表长度的1/2)，则从头开始遍历查找，否则从链表末尾向前遍历查找；</ol><h5 id=remove-操作-1><a class=headerlink href=#remove-操作-1 title=remove()操作></a>remove()操作</h5><ol><li>判断first节点是否为空，如果是则抛出异常NoSuchElementException；<li>如果不为空，则把待删除节点的next节点的prev属性值设为null，达到 删除头节点的效果；<li>返回删除值；</ol><h4 id=3-3-6-5、ConcurrentHashMap><a class=headerlink href=#3-3-6-5、ConcurrentHashMap title=3.3.6.5、ConcurrentHashMap></a>3.3.6.5、ConcurrentHashMap</h4><h5 id=put-操作-1><a class=headerlink href=#put-操作-1 title=put()操作></a>put()操作</h5><ol><li>判断待插入数据key和value是否为空，如果是则抛出空指针异常；<li>判断Node[] 数组是否为空，若是则需要初始化；<li>根据hash值通过位运算计算出Node数组的下标，判断该数组第一个Node节点是否有数据，如果没有数据则通过CAS将新值插入；<li>如果有数据则判断头节点的hashcode是否等于MOVED（即-1），即检查是否正在扩容，如果等于-1则帮助扩容；<li>若有数据，则对头节点进行加锁，如果头节点的hashcode >= 0，则说明是链表，遍历链表。如果找到key和hahs同时相等，则进行覆盖；若没有找到，则将新值插入到链表的最后面；如果hashCode < 0，说明红黑树，调用红黑树的 插值方法 插入新节点；<li>插值完成后，判断链表元素是否 >= 8，如果 >=8 且数组长度 > 64则转为红黑树。如果 >= 8 且数组长度 < 64 则仅仅进行扩容；</ol><h5 id=resize-操作-1><a class=headerlink href=#resize-操作-1 title=resize()操作></a>resize()操作</h5><p>创建新数组，其长度为原数组长度的2倍；多线程环境下旧数组迁移至新数组时会发生线程安全问题；<h5 id=get-操作><a class=headerlink href=#get-操作 title=get()操作></a>get()操作</h5><ol><li>计算获取数据key的hash值；<li>根据hashCode并通过位运算得到Node数组的下标，即得到头节点；<li>如果头节点为空，则返回null；<li>如果头节点的key与参数key可以相等，则返回头节点的值；<li>如果头节点的hashcode小于0，说明是红黑树，则调用find方法按照树的方式获取值；<li>如果不满足3、4、5条件，说明是链表，则按照链表的方式遍历获取值，整个过程不需要加锁；</ol><p>注意：整个过程无需加锁，因为读取的数据被volatile修饰，实现线程可见性；<h5 id=remove-操作-2><a class=headerlink href=#remove-操作-2 title=remove()操作></a>remove()操作</h5><ol><li>计算待插入数据key的hash值；<li>判断Node[]数组是否为空，如果是则返回null；如果不是，则根据hashCode通过位运算定位到数组下标，即得到头节点；<li>判断头节点hashCode是否等于MOVED（即-1），检查是否正在扩容，如果是则帮助扩容；<li>如果2、3条件都不满足，则加锁进行删除操作；<li>首先判断头节点有无发生变化，如果有改变则返回null；<li>如果头节点hashCode大于0，说明是链表，则按照链表方式遍历删除值；<li>如果头节点是TreeBin类型，说明是红黑树，则按照红黑树方式删除值；</ol><p><font color=red>注意：remove()底层是调用replaceNode()函数实现节点删除；</font><h5 id=JDK7、JDK8-下ConcurrentHashMap的区别><a title="JDK7、JDK8 下ConcurrentHashMap的区别" class=headerlink href=#JDK7、JDK8-下ConcurrentHashMap的区别></a>JDK7、JDK8 下ConcurrentHashMap的区别</h5><ol><li><font color=orange>底层结构</font><ul><li>JDK7：<strong>以 segment 作为每组数据的容器，对segment加锁只能锁住当前segment，segment数量等于并发度。 segment数组 + entry数组 + 链表。</strong><li>JDK8：<strong>没有segment数组。 直接 entry数组 + 链表，锁粒度为entry数组中每个索引节点。</strong></ul><li><font color=orange>初始化</font>：JDK7直接初始化。JDK8会在第一次put时初始化。<li><font color=orange>锁实现</font>：JDK7<strong>使用分段锁Segment；</strong>JDK8<strong>使用CAS+Synchronized；</strong><li><font color=orange>查询遍历</font>：JDK7基于链表实现，遍历效率低；JDK8基于红黑树实现，遍历效率高；<li><font color=orange>数据存放命名</font>：JDK7使用HashEntry容器来存储数据；JDK8改名为Node容器来存储数据；<li><font color=orange>数据插入</font><ul><li>JDK7：<strong>头插法</strong>；<ol><li>segment下标位置：并发度为16，因 2^4 = 16，故下标位置就是二次hash值的二进制位的 高4位 对应的 十进制数值。<li>数组索引位置：数组长度为8，因2^3 = 8，故索引位置就是二次hash值的二进制位的 低3位 对应的 十进制数值。</ol><li>JDK8：<strong>尾插法；</strong><ol><li>1.8 中的capacity不再表示全部容量，而是一定会放入的数据数量。如果capacity为16，那么第一次会初始化一个容量为32的数组，因为容量为16，加载因子为0.75，超过12（16*0.75）才扩容，而你直接放入16个元素，那更应该扩容了。</ol></ul><li><font color=orange>扩容</font><ul><li>JDK7：<strong>容量超过3/4时才扩容，先扩容再插入值；</strong>在其它segment中创建数组时会以segment[0]中的数组大小为原型来创建。segment[0]位置初始容量：总容量 / 并发度。<li>JDK8：<strong>容量等于3/4时就扩容，先插入值再扩容；</strong>迁移数据时，从旧数组中拿数据的顺序是从右到左。</ul><li><font color=orange>锁的粒度</font><ul><li>JDK7：<strong>最大并发数是Segment的个数，默认16，锁住整个段，不影响其它段；</strong><li>JDK8：<strong>去掉分段锁，更细粒度，只锁住一个Node节点，不影响其它Node节点；</strong></ul><li><font color=orange>读写限制及扩容</font><ul><li>JDK7：扩容时锁住一个段，当前段可读不可写，其它段可读写，只开启1个线程进行扩容；<li>JDK8：锁住一个Node节点，当前节点可读不可写，其它节点可读写，1个线程+可能多个put/remove线程帮助扩容；</ul></ol><h4 id=3-3-6-6、TreeMap><a class=headerlink href=#3-3-6-6、TreeMap title=3.3.6.6、TreeMap></a>3.3.6.6、TreeMap</h4><h5 id=put-操作-2><a class=headerlink href=#put-操作-2 title=put()操作></a>put()操作</h5><p>主要分为两个步骤：<ol><li><strong>构建排序二叉树</strong><ol><li>从根节点root开始查找；<li>如果root节点比待插入节点值小，则在root节点左子树查找，如果大于，则在右子树查找；<li>递归循步骤2，找到合适节点为止；<li>把待插入节点与步骤3中查找到的节点进行对比，如果待插入节点小于找到节点，则把待插入节点作为找到节点的左子树，否则作为右子树；</ol><li><strong>构建平衡二叉树</strong></ol><h5 id=remove-操作-3><a class=headerlink href=#remove-操作-3 title=remove()操作></a>remove()操作</h5><p>比put操作复杂，同样分为两个步骤：<ol><li><strong>删除节点</strong><ol><li>待删除节点，如果没有左和右子树时，则直接删除；<li>待删除节点，如果有一个字节点时，则把它的子节点指向它的上级节点（父节点）；<li>待删除节点，如果有两个非空的子节点时，流程复杂，暂不解释；</ol><li><strong>着色旋转</strong><ol><li>进行颜色对调和旋转，达到红黑树的特征；</ol></ol><h2 id=3-4、JAVA引用><a class=headerlink href=#3-4、JAVA引用 title=3.4、JAVA引用></a>3.4、JAVA引用</h2><h3 id=3-4-1、引用类型><a class=headerlink href=#3-4-1、引用类型 title=3.4.1、引用类型></a>3.4.1、引用类型</h3><h4 id=3-4-1-1、强引用><a class=headerlink href=#3-4-1-1、强引用 title=3.4.1.1、强引用></a>3.4.1.1、强引用</h4><ul><li><p>定义：new一个对象就是强引用。</p><li><p>回收时机：<strong>引用为null时就可以回收它。</strong></p><li><p>代码实现</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=type>Person</span> <span class=variable>p</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Person</span>();</span><br><span class=line>p = <span class=literal>null</span>;</span><br></pre></table></figure></ul><blockquote><p>new一个对象，这个引用就是强引用。代码中的<code>p</code>就是一个强引用。当p = null时，GC就可以回收它了。</blockquote><h4 id=3-4-1-2、软引用><a class=headerlink href=#3-4-1-2、软引用 title=3.4.1.2、软引用></a>3.4.1.2、软引用</h4><ul><li><p>定义：被SoftReference类对象指向的引用。</p><li><p>回收时机：<strong>内存不够时才会回收。</strong></p><li><p>代码实现</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>SoftReference<<span class=type>byte</span>[]> softReference = <span class=keyword>new</span> <span class="title class_">SoftReference</span>(<span class=keyword>new</span> <span class="title class_">byte</span>[<span class=number>1024</span>*<span class=number>1024</span>*<span class=number>10</span>]);</span><br></pre></table></figure> <p>只有在内存不够时，才会回收 byte字节数组。</p><li><p>应用场景：做缓存使用。</p></ul><h4 id=3-4-1-3、弱引用><a class=headerlink href=#3-4-1-3、弱引用 title=3.4.1.3、弱引用></a>3.4.1.3、弱引用</h4><ul><li><p>定义：被WeakReference类对象指向的引用。</p><li><p>回收时机：<strong>GC看到就回收（下次gc时回收）。</strong></p><li><p>代码实现</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>WeakReference&LTPerson> weakReference = <span class=keyword>new</span> <span class="title class_">WeakReference</span>(<span class=keyword>new</span> <span class="title class_">Person</span>());</span><br></pre></table></figure><li><p>应用场景：用在容器中。</p></ul><h4 id=3-4-1-4、虚引用><a class=headerlink href=#3-4-1-4、虚引用 title=3.4.1.4、虚引用></a>3.4.1.4、虚引用</h4><ul><li><p>定义：被PhantomReference类对象指向的应用。相当于不存在，get操作不能获取到值。</p><li><p>回收时机：<strong>GC看到就回收。（队列不为null，说明已经被回收了）。</strong></p><li><p>代码实现</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>ReferenceQueue&LTPerson> rq = <span class=keyword>new</span> <span class="title class_">ReferenceQueue</span><>();</span><br><span class=line>PhantomReference&LTPerson> phantomReference = <span class=keyword>new</span> <span class="title class_">PhantomReference</span>(<span class=keyword>new</span> <span class="title class_">Person</span>(), rq);</span><br></pre></table></figure> <p>PhantomReference的构造函数有两个参数，第二个参数必须是一个队列。虚引用就是给你一个通知，通知时放在队列中，你只需判断队列中是否为null，如果队列不为 null 说明虚引用已被回收。</p><li><p>应用场景：处理堆外内存。（参考NIO中的DirectByteBuffer，意为直接内存，直接内存不受JVM管理，而是被系统管理，故又叫堆外内存。堆外内存的回收可以使用虚引用来实现。）</p></ul><h1 id=4、Java内存模型><a class=headerlink href=#4、Java内存模型 title=4、Java内存模型></a>4、Java内存模型</h1><h2 id=4-1、简介><a class=headerlink href=#4-1、简介 title=4.1、简介></a>4.1、简介</h2><h3 id=4-1-1、前言><a class=headerlink href=#4-1-1、前言 title=4.1.1、前言></a>4.1.1、前言</h3><p>并发编程中，需要处理两个关键问题：<strong>线程之间如何通信及线程之间如何同步。</strong><ul><li><p>通信</p> <p>通信是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：</p> <ul><li><p>共享内存</p> <p>在共享内存的并发模型里，线程之间共享程序的公共状态，通过写-读内存中的公共状态 进行隐式通信。</p><li><p>消息传递。</p> <p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。</p></ul><li><p>同步</p> <p>同步是指程序中用于控制不同线程间操作发生相对顺序的机制。</p> <p>在共享内存并发模型 里，同步显式进行。在消息传递的并发模型里，由于消息发送必须在消息接收前，因此同步是隐式进行的。</p></ul><p><strong>Java并发采用的是共享内存模型，Java线程间的通信是隐式进行，整个通信过程对程序员完全透明。</strong><h3 id=4-1-2、认识JMM><a class=headerlink href=#4-1-2、认识JMM title=4.1.2、认识JMM></a>4.1.2、认识JMM</h3><p><strong>Java内存模型是根据英文Java Memory Model（JMM）翻译过来。其实JMM并不像JVM内存结构一样真实存在。他只是一个抽象概念。</strong><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了主内存变量的副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间无法直接访问对方工作内存中的变量，线程间的通信需要通过主内存来实现。<p><strong>JMM作用于工作内存和主存之间的数据同步过程。它规定了如何做数据同步以及什么时候做数据同步。</strong><p><img alt=image-20210424211138529 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210424211138529.png?token=AIGEF3JZVGM2SSRA5JMZNGDEZZXWK><p>Java内存模型的相关知识在<code>JSR-133: Java Memory Model and Thread Specification</code>中有描述。JMM是和多线程相关，它描述了一组规则或规范，这个规范规定了一个线程对共享变量的写入对另一个线程是可见的。<p><strong>Java内存模型（Java Memory Model，JMM）就是一种符合内存模型规范，屏蔽了各种硬件和操作系统访问差异，保证了Java程序在各种平台下对内存的访问都能得到一致效果的机制及规范。目的是解决多线程环境中基于共享内存进行通信时，存在的原子性、可见性（缓存一致性）以及有序性问题。</strong><h2 id=4-2、重要概念><a class=headerlink href=#4-2、重要概念 title=4.2、重要概念></a>4.2、重要概念</h2><h3 id=4-2-1、原子性问题><a class=headerlink href=#4-2-1、原子性问题 title=4.2.1、原子性问题></a>4.2.1、原子性问题</h3><p><strong>线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。</strong>所以在多线程场景下，就会发生原子性问题。<p>例如：线程要完成一个读、改、写操作，但在执行完读、改之后，时间片耗完了，此时就要放弃CPU，并等待重新调度。这种情况下，读改写就不是一个原子操作。即存在原子性问题。<h3 id=4-2-2、一致性问题><a class=headerlink href=#4-2-2、一致性问题 title=4.2.2、一致性问题></a>4.2.2、一致性问题</h3><p><strong>多核CPU 和 多线程场景中，每个核都至少有一个L1 缓存。</strong>多个线程访问进程中的某个共享内存，且多个线程分别在不同的核心上执行，则每个核心都会在各自的cache中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自缓存的情况，而各自cache之间的数据就有可能不同。<p>在CPU和主存之间增加缓存可能导致在多线程场景下出现缓存一致性问题，多核CPU的每个核的缓存中，对于同一数据可能有不同的副本。<h3 id=4-2-3、有序性问题><a class=headerlink href=#4-2-3、有序性问题 title=4.2.3、有序性问题></a>4.2.3、有序性问题</h3><p><strong>现代的处理器使用 写缓冲区 临时保存向内存写入的数据。</strong>写缓冲区可以保证指令流水线持续运行，可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。它可以通过 批处理 刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写来减少对内存总线的占用。<p>但要注意，<strong>每个处理器上的写缓冲区，仅仅对它所在的处理器可见。</strong>这个特性会对内存操作的执行顺序产生重要影响：<strong>处理器对内存读/写操作的执行顺序不一定与内存实际发生的读/写操作顺序一致。</strong><p>由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的 顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此 现代的处理器都会允许对写-读操作进行重排序。<p>为提高性能，编译器和处理器会对指令做重排序。重排序分3种类型：<ol><li>编译器优化重排序。（编译器重排序）<li>指令级并行重排序。（处理器重排序）<li>内存系统重排序。（处理器重排序）</ol><p>从Java源代码到最终执行的指令序列，会经历下面3种重排序：<p><img alt=Java内存模型-1.1-指令重排序-源码到执行指令间的重排序过程 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-1.1-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F-%E6%BA%90%E7%A0%81%E5%88%B0%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4%E9%97%B4%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B.png?token=AIGEF3PREC67A44L2UZB5ADEZZX4Q><p><strong>重排序可能会导致多线程程序出现内存可见性问题。</strong><h3 id=4-2-4、内存模型><a class=headerlink href=#4-2-4、内存模型 title=4.2.4、内存模型></a>4.2.4、内存模型</h3><p><strong>CPU多级缓存导致的一致性问题、CPU时间片机制导致的原子性问题、以及处理器优化和指令重排导致的有序性问题等，都是由硬件不断升级导致。</strong><p>为了保证并发编程中可以满足原子性、可见性及有序性，内存模型 就出现了。<p>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器、缓存、并发、编译器有关。它解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。<p><strong>Java语言为了屏蔽掉底层差异，定义了一套属于Java语言的内存模型规范，即Java内存模型。</strong><h2 id=4-3、底层实现><a class=headerlink href=#4-3、底层实现 title=4.3、底层实现></a>4.3、底层实现</h2><h3 id=4-3-1、happens-before><a class=headerlink href=#4-3-1、happens-before title=4.3.1、happens-before></a>4.3.1、happens-before</h3><p>happens-before的概念最初由<em><strong>Leslie Lamport</strong></em>在其一篇影响深远的论文（《Time，Clocks and the Ordering of Events in a Distributed System》）中提出。<p>从JDK 5开始，Java使用新的JSR-133内存模型。JSR-133使用happens-before的概念来指定两个操作之间的执行顺序。<p>在JMM中，<strong>如果一 个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。</strong>这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。<p><strong>happens-before规则有8个</strong>，详情如下：<ul><li><strong>程序次序规则</strong>：一个线程中的每个操作，happens-before于该线程中的任意后续操作。（线程中的代码顺序执行）<li><strong>管程锁定规则</strong>：一个unlock操作先行发生于后面对同一个锁的lock操作。（先解锁后加锁）<li><strong>volatile变量规则</strong>：对一个volatile域的写，happens-before于任意后续对这个volatile域的 读。（先volatile写后volatile读）<li><strong>传递性</strong>：如果A happens-before B，且B happens-before C，那么A happens-before C。<li><strong>对象终结规则</strong>：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize()方法的开始。<li><strong>线程启动规则</strong>：Thread对象的start()方法先行发生于此线程的每一个动作。<li><strong>线程中断规则</strong>：对线程interrupt()方法的调用先行发生于被中断线程 的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生。<li><strong>线程终止规则</strong>：线程中的所有操作都先行发生于对此线程的终止检 测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。</ul><p>JMM把happens-before 要求禁止的重排序分为下面两种：<ul><li><p><strong>会改变程序执行结果的重排序</strong>。</p> <p>对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。</p><li><p><strong>不会改变程序执行结果的重排序</strong>。</p> <p>对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM允许这种 重排序）。</p></ul><blockquote><p>两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个 操作之前执行！happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一 个操作按顺序排在第二个操作之前。<p>如果前一个操作的结果不需要对后一个操作可见，且前后两个操作按happens-before关系来执行 与 不按照happens-before关系来执行的结果如果完全一致，那么JMM允许这种重排序。</blockquote><h3 id=4-3-2、as-if-serial><a class=headerlink href=#4-3-2、as-if-serial title=4.3.2、as-if-serial></a>4.3.2、as-if-serial</h3><p>as-if-serial语义是：<strong>不管怎么重排序（编译器和处理器为了提高并行度），（单线程） 程序的执行结果不能被改变。</strong>编译器、runtime和处理器都必须遵守as-if-serial语义。<p>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。<p>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证了正确同步的多线程程序执行结果的正确性。<h3 id=4-3-3、volatile内存语义><a class=headerlink href=#4-3-3、volatile内存语义 title=4.3.3、volatile内存语义></a>4.3.3、volatile内存语义</h3><h4 id=volatile写内存语义><a class=headerlink href=#volatile写内存语义 title=volatile写内存语义></a>volatile写内存语义</h4><p><strong>当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</strong><h4 id=volatile读内存语义><a class=headerlink href=#volatile读内存语义 title=volatile读内存语义></a>volatile读内存语义</h4><p><strong>当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量。</strong><h4 id=底层实现><a class=headerlink href=#底层实现 title=底层实现></a>底层实现</h4><p><strong>为了实现volatile内存语义，JMM会限制 编译器重排序 和 处理器重排序。</strong><p>JMM禁止 编译器重排序 的规则如下：<p><img alt=image-20230805235157835 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805235157835.png?token=AIGEF3KZOENBUAHU2SOPZ2DEZZYFW><blockquote><p>在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量重排序。</blockquote><h3 id=4-3-4、锁内存语义><a class=headerlink href=#4-3-4、锁内存语义 title=4.3.4、锁内存语义></a>4.3.4、锁内存语义</h3><h4 id=锁获取内存语义><a class=headerlink href=#锁获取内存语义 title=锁获取内存语义></a>锁获取内存语义</h4><p><strong>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的 临界区代码必须从主内存中读取共享变量。</strong><h4 id=锁释放内存语义><a class=headerlink href=#锁释放内存语义 title=锁释放内存语义></a>锁释放内存语义</h4><p><strong>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。</strong><blockquote><p>对比锁释放-获取的内存语义与volatile写-读的内存语义可以看出：锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。</blockquote><h4 id=公平锁和非公平锁内存语义><a class=headerlink href=#公平锁和非公平锁内存语义 title=公平锁和非公平锁内存语义></a>公平锁和非公平锁内存语义</h4><ul><li>公平锁和非公平锁释放时，最后都要写一个volatile变量state。<li>公平锁获取时，首先会去读volatile变量。<li>非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile 写的内存语义。</ul><h3 id=4-3-4、final域内存语义><a class=headerlink href=#4-3-4、final域内存语义 title=4.3.4、final域内存语义></a>4.3.4、final域内存语义</h3><p>对于final域，编译器和处理器要遵守两个重排序规则：<ol><li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两者不能重排序。<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能 重排序。</ol><h3 id=4-4-1、原子性><a class=headerlink href=#4-4-1、原子性 title=4.4.1、原子性></a>4.4.1、原子性</h3><p><strong>Java为了保证原子性，提供了两个高级字节码指令<code>monitorenter</code>和<code>monitorexit</code>。在Java中对应的关键字就是synchronized。</strong><p>Java中可以使用synchronized来保证方法和代码块内操作的原子性。<h3 id=4-4-2、可见性><a class=headerlink href=#4-4-2、可见性 title=4.4.2、可见性></a>4.4.2、可见性</h3><p>Java中的关键字volatile有一个功能：<strong>被其修饰的变量在被修改后必须立即同步到主内存，被其修饰的变量在每次使用时都必须从主内存获取。</strong>因此，可以使用volatile来保证多线程操作时变量的可见性。<p>除了volatile，Java中的synchronized和final关键字也可以实现可见性。只不过实现方式不同。<h3 id=4-4-3、有序性><a class=headerlink href=#4-4-3、有序性 title=4.4.3、有序性></a>4.4.3、有序性</h3><p><strong>Java在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。</strong>JMM把内存屏障指令分为4类：<p><img alt=Java内存模型-1.2-可见性-内存屏障类型 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-1.2-%E5%8F%AF%E8%A7%81%E6%80%A7-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E7%B1%BB%E5%9E%8B.png?token=AIGEF3LKY332SGI2CDZSVN3EZZYI2><p><strong>StoreLoad Barriers是一个全能型屏障，它同时具有其他3个屏障的效果。</strong>目前 处理器大多支持该屏障（其他类型的屏障不一定被所有处理器支持）。执行该屏障开销会很昂贵，因为 处理器 要把 写缓冲区数据 全部刷新到内存中（Buffer Fully Flush）。<p>Java中的 synchronized 和 volatile 都可以保证多线程之间操作的有序性。区别：<ul><li>volatile关键字 能 禁止指令重排。<li>synchronized关键字 能 保证同一时刻只有一条线程运行。</ul><h1 id=5、JAVA并发><a class=headerlink href=#5、JAVA并发 title=5、JAVA并发></a>5、JAVA并发</h1><h2 id=5-1、Synchronized><a class=headerlink href=#5-1、Synchronized title=5.1、Synchronized></a>5.1、Synchronized</h2><h3 id=5-1-1、简介><a class=headerlink href=#5-1-1、简介 title=5.1.1、简介></a>5.1.1、简介</h3><p>synchronized一直被认为是重量级锁。随着Java SE 1.6对<code>synchronized</code>进行了各种优化之后，它就并不那么重了。<p><strong>Java SE 1.6中，锁共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，这几个状态会随着竞争情况逐渐升级。</strong>锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。<h3 id=5-1-2、底层实现><a class=headerlink href=#5-1-2、底层实现 title=5.1.2、底层实现></a>5.1.2、底层实现</h3><ul><li><p>Java源码层级：synchronized(o)。</p><li><p>字节码层级：</p> <ul><li>synchronized修饰方法（包括实例方法和静态方法）：添加访问标志<code>ACC_SYNCHRONIZED</code>。<li>synchronized修饰同步块：一般情况下都是添加 1个monitor enter 和 2个monitor exit，如果在同步方法中显式抛出异常，那么只会有1个monitor enter 和 1个monitor exit。</ul><li><p>JVM层级：基于操作系统提供的同步机制。</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">T01_Sync1</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>Object</span> <span class=variable>o</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Object</span>();</span><br><span class=line>        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>com.T01_Sync1$Lock object internals:</span><br><span class=line> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class=line>      <span class=number>0</span>     <span class=number>4</span>   (object header)  <span class=number>05</span> <span class=number>00</span> <span class=number>00</span> <span class=number>00</span> (<span class=number>00000101</span> <span class=number>00000000</span> <span class=number>00000000</span> <span class=number>00000000</span>) (<span class=number>5</span>)</span><br><span class=line>      <span class=number>4</span>     <span class=number>4</span>   (object header)  <span class=number>00</span> <span class=number>00</span> <span class=number>00</span> <span class=number>00</span> (<span class=number>00000000</span> <span class=number>00000000</span> <span class=number>00000000</span> <span class=number>00000000</span>) (<span class=number>0</span>)</span><br><span class=line>      <span class=number>8</span>     <span class=number>4</span>   (object header)  <span class=number>49</span> ce <span class=number>00</span> <span class=number>20</span> (<span class=number>01001001</span> <span class=number>11001110</span> <span class=number>00000000</span> <span class=number>00100000</span>) (<span class=number>536923721</span>)</span><br><span class=line>     <span class=number>12</span>     <span class=number>4</span>        (loss due to the next object alignment)</span><br><span class=line>Instance size: <span class=number>16</span> bytes</span><br><span class=line>Space losses: <span class=number>0</span> bytes internal + <span class=number>4</span> <span class=type>bytes</span> <span class=variable>external</span> <span class=operator>=</span> <span class=number>4</span> bytes total</span><br></pre></table></figure> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>com.T02_Sync2$Lock object internals:</span><br><span class=line> OFFSET  SIZE   TYPE DESCRIPTION                               VALUE</span><br><span class=line>      <span class=number>0</span>     <span class=number>4</span>   (object header)  <span class=number>05</span> <span class=number>90</span> 2e 1e (<span class=number>00000101</span> <span class=number>10010000</span> <span class=number>00101110</span> <span class=number>00011110</span>) (<span class=number>506368005</span>)</span><br><span class=line>      <span class=number>4</span>     <span class=number>4</span>   (object header)  1b <span class=number>02</span> <span class=number>00</span> <span class=number>00</span> (<span class=number>00011011</span> <span class=number>00000010</span> <span class=number>00000000</span> <span class=number>00000000</span>) (<span class=number>539</span>)</span><br><span class=line>      <span class=number>8</span>     <span class=number>4</span>   (object header)  <span class=number>49</span> ce <span class=number>00</span> <span class=number>20</span> (<span class=number>01001001</span> <span class=number>11001110</span> <span class=number>00000000</span> <span class=number>00100000</span>) (<span class=number>536923721</span>)</span><br><span class=line>     <span class=number>12</span>     <span class=number>4</span>        (loss due to the next object alignment)</span><br><span class=line>Instance size: <span class=number>16</span> bytes</span><br><span class=line>Space losses: <span class=number>0</span> bytes internal + <span class=number>4</span> <span class=type>bytes</span> <span class=variable>external</span> <span class=operator>=</span> <span class=number>4</span> bytes tota</span><br></pre></table></figure><li><p>OS/硬件层面</p> <ul><li>X86：使用指令 lock cmpxchg xxx 来实现。</ul></ul><h3 id=5-1-3、锁优化><a class=headerlink href=#5-1-3、锁优化 title=5.1.3、锁优化></a>5.1.3、锁优化</h3><h4 id=自旋锁与自适应自旋><a class=headerlink href=#自旋锁与自适应自旋 title=自旋锁与自适应自旋></a>自旋锁与自适应自旋</h4><p><strong>JDK 1.4.2引入了自旋锁，默认关闭，可使用参数<code>-XX:+UseSpinning</code>开启，JDK 6中改为默认开启。</strong><p>自旋等待不能代替阻塞，自旋等待虽然避免了线程切换的开销，但它要占用处理器时间，如果锁被占用的时间很短，自旋等待效果就会非常好，反之如果锁被占用时间很长，那么自旋线程只会白白消耗处理器资源，这会带来性能的浪费。因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍没有获得锁，就应当使用传统方式挂起线程。<strong>自旋次数默认是十次，也可以使用参数<code>-XX:PreBlockSpin</code>来修改。</strong><p><strong>JDK 6对自旋锁做了优化，引入了自适应自旋。</strong>自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待更长时间。另一方面，如果对于某个锁，自旋很少成功获得锁，那么后期再获取这个锁时可能直接省略自旋过程，以避免浪费处理器资源。<p><strong>JDK7之后就不能控制是否开启自旋功能了。</strong><h4 id=锁消除><a class=headerlink href=#锁消除 title=锁消除></a>锁消除</h4><p><strong>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但实际不会发生共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">add</span><span class=params>(String str1,String str2)</span>{</span><br><span class=line>    <span class=type>StringBuffer</span> <span class=variable>sb</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StringBuffer</span>();</span><br><span class=line>    sb.append(str1).append(str2);</span><br><span class=line>}</span><br></pre></table></figure><p>StringBuffer是线程安全的，因为它的关键方法被<code>synchronized</code>修饰。引用sb只会在<code>add</code>方法中使用，不会发生方法逃逸和线程逃逸，故JVM会自动消除掉StringBuffer对象内部的锁。<blockquote><p>在JDK 5之前，字符串加法会转化为StringBuffer 对象的连续append()操作，在JDK 5及以后的版本中，会转化为StringBuilder对象的连续append()操作。</blockquote><h4 id=锁粗化><a class=headerlink href=#锁粗化 title=锁粗化></a>锁粗化</h4><p>原则上，在编写代码时，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了尽可能减少需要同步的操作数量，即使存在锁竞争，等待锁的线程也能尽快地拿到锁。<p>大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作出现在循环体之中，那即使没有线程竞争，频繁进行互斥同步操作也会导致不必要的性能损耗。<p>比如以下代码，没有锁粗化时需要执行100次加锁/解锁操作，执行 锁粗化 优化后只需要加一次锁即可。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> String <span class="title function_">test</span><span class=params>(String str)</span>{</span><br><span class=line>    <span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=type>StringBuffer</span> <span class=variable>sb</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">StringBuffer</span>():</span><br><span class=line>    <span class=keyword>while</span>(i < <span class=number>100</span>){</span><br><span class=line>    	sb.append(str);</span><br><span class=line>    	i++;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> sb.toString():</span><br><span class=line>}</span><br></pre></table></figure><h4 id=偏向锁><a class=headerlink href=#偏向锁 title=偏向锁></a>偏向锁</h4><h5 id=简介-1><a class=headerlink href=#简介-1 title=简介></a>简介</h5><p><strong>JDK 6引入偏向锁，目的是消除数据在无竞争情况下的同步原语， 进一步提高程序运行性能。</strong>如果说轻量级锁是在无竞争情况下 使用CAS 来替换 使用互斥量，那偏向锁就是在无竞争情况下去掉同步和CAS。<p>偏向锁中的“偏”，就是偏心的“偏”、偏袒的“偏”。它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，没有其它线程来获取这个锁，则持有偏向锁的线程将永远不需要再进行同步。<h5 id=工作过程><a class=headerlink href=#工作过程 title=工作过程></a>工作过程</h5><p><strong>当锁对象第一次被线程获取时，虚拟机会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后再次进入同步块时，就不需要再进行任何同步操作（例如加锁、解锁及对Mark Word的更新操作 等）。</strong><p>若有其它线程尝试获取锁，偏向模式会马上结束。根据锁对象目前是否处于被锁定的状态来决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位 为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照轻量级锁工作流程来执行。<h5 id=总结><a class=headerlink href=#总结 title=总结></a>总结</h5><p>当对象进入偏向状态时，Mark Word大部分的空间（23个比特）都用于存储持有锁的线程ID了，这部分空间占用了原有存储对象哈希码的位置，那原来对象的哈希码怎么办呢？<p>一个对象如果计算过哈希码，就应该一直保持该值不变（推荐但不强制，因为用户可以重载hashCode()方法），否则很多依赖对象哈希码的API都可能存在出错风险。而作为绝大多数对象哈希码来源的Object::hashCode()方法，返回的是对象的一致性哈希码（Identity Hash Code），这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第一 次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变。因此，<strong>当一个对象已经计算过一 致性哈希码后，它就再也无法进入偏向锁状态了</strong>；而<strong>当一个对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁</strong>。在重量级锁实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”）下的Mark Word，其中自然可以存储原来的哈希码。<blockquote><p><font color=red>注意：如果请求获取的hashcode值来源于对Object::hashCode()或者System::identityHashCode(Object)方法的调用，那么才会撤销偏向锁并升级为重量级锁；反之，如果重写了对象的hashCode()方法，计算哈希码时并不会触发偏向锁的撤销和重量级锁的升级。</font></blockquote><p>偏向锁可以提高带有同步但无竞争的程序性能，但它同样是一个带有效益权衡（Trade Off）性质的优化，也就是说它并非总是对程序运行有利。如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数<code>-XX:-UseBiasedLocking</code>来禁止偏向锁优化反而可以提升性能。<h4 id=轻量级锁><a class=headerlink href=#轻量级锁 title=轻量级锁></a>轻量级锁</h4><h5 id=简介-2><a class=headerlink href=#简介-2 title=简介></a>简介</h5><p><strong>JDK 6引入了轻量级锁。</strong>“轻量级”是相对于使用操作系统互斥量来实现锁而言，因此传统锁机制被称为“重量级”锁。轻量级锁并不能代替重量级锁，它设计的初衷是在没有多线程竞争的前提下，减少重量级锁使用操作系统互斥量产生的性能消耗。<h5 id=工作过程-1><a class=headerlink href=#工作过程-1 title=工作过程></a>工作过程</h5><p><strong>在代码即将进入同步块时，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word）。</strong><p>然后，虚拟机将<strong>使用CAS操作尝试把锁对象的Mark Word更新为指向Lock Record的指针</strong>。<ul><li>如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且锁对象Mark Word的锁标志位（Mark Word的 最后两个比特）将转变为“00”，表示此对象处于轻量级锁定状态。<li>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志状态值变为“10”，此时锁对象Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也必须进入阻塞状态。</ul><p>上面描述的是轻量级锁的加锁过程，它的解锁过程也同样是通过CAS操作来进行，如果对象的 Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，那么就要在释放锁的同时，唤醒被挂起的线程。<h5 id=总结-1><a class=headerlink href=#总结-1 title=总结></a>总结</h5><p>轻量级锁能提升程序同步性能的依据是”对于绝大部分的锁，在整个同步周期内都是不存在竞争的”这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。因此在有竞争的情况下， 轻量级锁反而会比传统的重量级锁更慢。<p>偏向锁、轻量级锁的状态转化及对象Mark Word的关系如下图所示：<p><img alt=偏向锁、轻量级锁与MarkWord的关系 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E4%B8%8EMarkWord%E7%9A%84%E5%85%B3%E7%B3%BB.png?token=AIGEF3IKANGCKSJOPH3WQ2LEZZYK6><h3 id=5-1-4、锁升级><a class=headerlink href=#5-1-4、锁升级 title=5.1.4、锁升级></a>5.1.4、锁升级</h3><h4 id=5-1-4-1、无锁状态><a class=headerlink href=#5-1-4-1、无锁状态 title=5.1.4.1、无锁状态></a>5.1.4.1、无锁状态</h4><p><strong>new一个对象，默认就是无锁状态。</strong><h4 id=5-1-4-2、偏向锁><a class=headerlink href=#5-1-4-2、偏向锁 title=5.1.4.2、偏向锁></a>5.1.4.2、偏向锁</h4><h5 id=偏向锁来历><a class=headerlink href=#偏向锁来历 title=偏向锁来历></a>偏向锁来历</h5><p>HotSpot作者研究发现，通常不存在锁竞争，而是一个线程经常多次获得同一个锁。所以每次都要竞争锁会消耗很多资源，为了降低获取锁的代价就引入了偏向锁。<h5 id=偏向锁获取><a class=headerlink href=#偏向锁获取 title=偏向锁获取></a>偏向锁获取</h5><p><strong>首次访问锁的线程，偏向锁会偏向于该线程。有其它线程争夺锁时会撤销偏向锁，然后升级为轻量级锁。</strong><p>偏向锁 获取和撤销 过程描述如下：<p>当锁对象首次被线程获取时，会将获取到该锁的线程ID记录在锁对象的Mark Word中，以后该线程在进入和退出 同步块时不需要执行CAS操作来加锁和解锁：<ul><li>如果一致（依然是线程1获取锁对象），则无需通过CAS进行加锁、解锁；<li>如果不一致（其他线程（线程2）要竞争锁对象），则需要检查Java对象头中记录的线程1是否存活：<ul><li>如果没有存活，那么锁状态将被重置为无锁状态，其它线程（线程2）可以将其设为偏向锁；<li>如果存活，那么检查该线程（线程1）的栈帧信息，如果线程1依然需要这个锁，则暂停当前线程1并撤销偏向锁，然后升级为轻量级锁。如果线程1 不再使用该锁对象，那么锁状态将被设为无锁状态，然后重新偏向新的线程。</ul></ul><p>获取偏向锁详细步骤 参考如下：<ol><li>验证对象的bias位。如果是0，则表示该对象不可偏向，应该使用轻量级锁算法。<li>验证对象所属InstanceKlass的prototype的bias位是否被设置。如果没有设置，则该类所有对象全部不允许被偏向锁定，且所有对象的bias位都需要被重置，使用轻量级锁来替换。<li>校验epoch位。校验对象头中MarkWord的epoch位是否与该对象所属InstanceKlass的prototype的MarkWord的epoch匹配。如果不匹配，则表明偏向已过期，需要重新偏向。偏向线程可以通过CAS指令重新偏向于这个锁对象。<li>校验owner线程。比较偏向线程ID与当前线程ID。如果匹配，则表明当前线程已经获得了偏向，可以安全返回。如果不匹配，对象锁被假定为匿名偏向状态，当前线程应该尝试使用CAS指令获得偏向。如果失败的话，就尝试撤销(很可能引入安全点)，然后回退到轻量级锁；如果成功，当前线程成功获得偏向，可直接返回。</ol><h5 id=偏向锁关闭><a class=headerlink href=#偏向锁关闭 title=偏向锁关闭></a>偏向锁关闭</h5><p><strong>偏向锁在Java 6和Java 7中默认启用，但它仅在程序启动几秒后才激活，可通过JVM参数<code>-XX:BiasedLockingStartupDelay=0</code>来关闭该延迟。</strong><p><strong>如果程序线程通常处于竞争状态，可以通过JVM参数<code>-XX:-UseBiasedLocking</code>关闭偏向锁，那么程序默认会直接进入轻量级锁状态。</strong><p>HotSpot支持 存储/释放 偏向锁，以及偏向锁的批量重偏向和撤销。这个特性可以通过JVM参数进行切换，且默认支持。Unlock状态下MarkWord的一个比特位用于标识该对象偏向锁是否被使用或者是否被禁止。如果该bit位为0，则该对象未被锁定，并且禁止偏向；如果该bit位为1，则意味着该对象处于以下三种状态：<ol><li><font color=orange>匿名偏向(Anonymously Biased)</font><li><font color=orange>可重偏向(Rebiasable)</font><li><font color=orange>已偏向(Biased)</font></ol><h4 id=5-1-4-3、轻量级锁><a class=headerlink href=#5-1-4-3、轻量级锁 title=5.1.4.3、轻量级锁></a>5.1.4.3、轻量级锁</h4><h5 id=轻量级锁来历><a class=headerlink href=#轻量级锁来历 title=轻量级锁来历></a>轻量级锁来历</h5><p><strong>轻量级锁适用于 并发高但执行时间短的场景。</strong>线程阻塞将导致用户态与内核态的切换，若阻塞时间很短后锁就被释放了，那么代价会更大。为解决该问题，轻量级锁就出现了。<h5 id=轻量级锁加锁><a class=headerlink href=#轻量级锁加锁 title=轻量级锁加锁></a>轻量级锁加锁</h5><p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用 CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。<h5 id=轻量级锁解锁><a class=headerlink href=#轻量级锁解锁 title=轻量级锁解锁></a>轻量级锁解锁</h5><p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。<h5 id=轻量级锁升级><a class=headerlink href=#轻量级锁升级 title=轻量级锁升级></a>轻量级锁升级</h5><p>轻量级锁的升级过程描述如下：<ol><li>线程1获取轻量级锁时会先把锁对象对象头的MarkWord拷贝一份放到线程1栈帧中（称为DisplacedMarkWord），然后通过CAS方式把对象头中的内容替换为指向线程1中锁记录（DisplacedMarkWord）的指针。<li>线程1在修改替换对象头时，线程2进来也需要执行相关操作，但线程2在执行CAS时发现线程1已经把对象头换了，此时线程2的CAS会失败，然后线程2会尝试使用自旋锁来等待线程1释放锁。<li>线程2自旋次数达到上限时还没有获取锁，那么线程2就会将轻量级锁升级为重量级锁，然后线程2会进入到重量级锁的等待队列中进行等待，后续来的线程也会进入该队列进行等待，直到线程1执行完毕释放了锁，然后唤醒等待队列中的线程。</ol><blockquote><p>自旋达到上限时会升级到重量级锁，这里的上限分两种情况：<ul><li><p>Java6之前</p> <ol><li>默认启用，自旋次数的默认值是10次，也可以使用参数<code>-XX：PreBlockSpin</code>来修改。<li>或者，自旋线程数量超过CPU核数一半时升级为重量级锁。</ol><li><p>Java6之后，引入自适应自旋，自旋次数不再固定，而是根据：同一把锁上次的自旋时间 和 拥有锁的线程的状态来决定。</p> <ol><li>如果线程自旋成功，那么下次自旋的最大次数就会增加，因为JVM会认为上次都已经成功了，那么这次一定也会成功。<li>如果自旋很少成功，那么下次会减少自旋次数甚至是不再自旋，避免CPU空转，消费资源。</ol></ul></blockquote><p><font color=red>注意：</font><p>使用CAS自旋去争夺锁，会导致无意义的CPU占用。所以，<strong>轻量级锁适用于 线程少且执行时间短 的场景。</strong><h4 id=5-1-4-4、重量级锁><a class=headerlink href=#5-1-4-4、重量级锁 title=5.1.4.4、重量级锁></a>5.1.4.4、重量级锁</h4><p>重量级锁竞争时，可以使用自旋来优化。如果当前线程自旋成功（其它线程释放了锁，当前线程获取了锁），那么就可以避免当前线程被阻塞。如果自旋次数达到上限时还没有获取锁，那么就会将轻量级锁升级为重量级锁，然后当前线程会进入到重量级锁的等待队列中进行等待，后续来的线程也会进入该队列进行等待，直到拿到锁的线程执行完毕释放了锁，然后才会唤醒等待队列中的线程。<p><strong>重量级锁底层实现是一个Monitor对象，俗称Monitor锁，该对象有WaitSet、EntryList、Owner等重要成员。</strong><p><strong>获取轻量级锁失败的线程会将轻量级锁升级为重量级锁，此时会创建Monitor锁对象，然后会在synchronized修饰的锁对象头的markword中存入Monitor对象的地址并设置锁标识位为10，并设置Monitor锁对象的Owner指向获取锁的线程，获取锁失败的线程会进入到Monitor锁对象的EntryList中进行等待，直到获取锁的线程释放了锁，并将Owner设置为null，然后会唤醒EntryList中等待的线程来重新竞争锁。</strong><h4 id=小结><a class=headerlink href=#小结 title=小结></a>小结</h4><p>锁升级注意事项：<ol><li>为了避免无用自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁；<li>偏向锁升级为轻量级锁也不能再降级为偏向锁；<li>偏向锁状态可以被重置为无锁状态；</ol><p>锁优缺点对比：<p><img alt=Synachonized-1.1-锁的优缺点 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/Synachonized-1.1-%E9%94%81%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png?token=AIGEF3NTWUVMKCIFTZIAWITEZZYNA><h3 id=5-1-5、锁降级><a class=headerlink href=#5-1-5、锁降级 title=5.1.5、锁降级></a>5.1.5、锁降级</h3><p><a href=https://zhuanlan.zhihu.com/p/28505703 rel=noopener target=_blank>https://zhuanlan.zhihu.com/p/28505703</a><p><strong>只被<code>VM Thread</code>访问，降级也就没啥意义了。所以可以认为锁降级不存在！</strong><h4 id=降级目的和过程><a class=headerlink href=#降级目的和过程 title=降级目的和过程></a>降级目的和过程</h4><p>因为BasicLocking的实现优先于重量级锁的使用，JVM会尝试在STW的停顿中对处于“空闲(idle)”状态的重量级锁进行降级(deflate)。我们知道在STW时，所有的Java线程都会暂停在“安全点(SafePoint)”，此时VM Thread通过对所有Monitor进行遍历，或者通过对所有依赖于<code>MonitorInUseLists</code>值的当前正在“使用”中的<code>Monitor</code>子序列进行遍历，从而得到那些未被使用的“Monitor”并将之作为降级对象。<h4 id=降级对象><a class=headerlink href=#降级对象 title=降级对象></a>降级对象</h4><p><strong>重量级锁的降级发生于STW阶段，降级对象就是那些仅仅能被 VM Thread 访问而没有被其它 Java Thread 访问的Monitor对象。</strong><h4 id=HotSpot-VM实现><a title="HotSpot VM实现" class=headerlink href=#HotSpot-VM实现></a>HotSpot VM实现</h4><p>HotSpot VM锁降级底层实现，可以参考：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> ObjectSynchronizer::deflate_idle_monitors() {</span><br><span class=line>  <span class=keyword>assert</span>(SafepointSynchronize::is_at_safepoint(), <span class=string>"must be at safepoint"</span>);</span><br><span class=line>  <span class=type>int</span> <span class=variable>nInuse</span> <span class=operator>=</span> <span class=number>0</span> ;              <span class=comment>// currently associated with objects</span></span><br><span class=line>  <span class=type>int</span> <span class=variable>nInCirculation</span> <span class=operator>=</span> <span class=number>0</span> ;      <span class=comment>// extant</span></span><br><span class=line>  <span class=type>int</span> <span class=variable>nScavenged</span> <span class=operator>=</span> <span class=number>0</span> ;          <span class=comment>// reclaimed</span></span><br><span class=line>  <span class=type>bool</span> <span class=variable>deflated</span> <span class=operator>=</span> <span class=literal>false</span>;</span><br><span class=line></span><br><span class=line>  ObjectMonitor * FreeHead = NULL ;  <span class=comment>// Local SLL of scavenged monitors</span></span><br><span class=line>  ObjectMonitor * FreeTail = NULL ;</span><br><span class=line></span><br><span class=line>  TEVENT (deflate_idle_monitors) ;</span><br><span class=line><span class=comment>// Prevent omFlush from changing mids in Thread dtor's during deflation</span></span><br><span class=line><span class=comment>// And in case the vm thread is acquiring a lock during a safepoint</span></span><br><span class=line><span class=comment>// See e.g. 6320749</span></span><br><span class=line>  Thread::muxAcquire (&ListLock, <span class=string>"scavenge - return"</span>) ;</span><br><span class=line></span><br><span class=line>  <span class=keyword>if</span> (MonitorInUseLists) {</span><br><span class=line>    <span class=type>int</span> <span class=variable>inUse</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>for</span> (JavaThread* cur = Threads::first(); cur != NULL; cur = cur->next()) {</span><br><span class=line>      nInCirculation+= cur->omInUseCount;</span><br><span class=line>      <span class=type>int</span> <span class=variable>deflatedcount</span> <span class=operator>=</span> walk_monitor_list(cur->omInUseList_addr(), &FreeHead, &FreeTail);</span><br><span class=line>      cur->omInUseCount-= deflatedcount;</span><br><span class=line><span class=comment>// verifyInUse(cur);</span></span><br><span class=line>      nScavenged += deflatedcount;</span><br><span class=line>      nInuse += cur->omInUseCount;</span><br><span class=line>     }</span><br><span class=line></span><br><span class=line><span class=comment>// For moribund threads, scan gOmInUseList</span></span><br><span class=line>   <span class=keyword>if</span> (gOmInUseList) {</span><br><span class=line>     nInCirculation += gOmInUseCount;</span><br><span class=line>     <span class=type>int</span> <span class=variable>deflatedcount</span> <span class=operator>=</span> walk_monitor_list((ObjectMonitor **)&gOmInUseList, &FreeHead, &FreeTail);</span><br><span class=line>     gOmInUseCount-= deflatedcount;</span><br><span class=line>     nScavenged += deflatedcount;</span><br><span class=line>     nInuse += gOmInUseCount;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>  } <span class=keyword>else</span> <span class=keyword>for</span> (ObjectMonitor* block = gBlockList; block != NULL; block = next(block)) {</span><br><span class=line>	<span class=comment>// Iterate over all extant monitors - Scavenge all idle monitors.</span></span><br><span class=line>    <span class=keyword>assert</span>(block->object() == CHAINMARKER, <span class=string>"must be a block header"</span>);</span><br><span class=line>    nInCirculation += _BLOCKSIZE ;</span><br><span class=line>    <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>1</span> ; i < _BLOCKSIZE; i++) {</span><br><span class=line>      ObjectMonitor* mid = &block[i];</span><br><span class=line>      <span class=type>oop</span> <span class=variable>obj</span> <span class=operator>=</span> (oop) mid->object();</span><br><span class=line></span><br><span class=line>      <span class=keyword>if</span> (obj == NULL) {</span><br><span class=line>          <span class=comment>// The monitor is not associated with an object.</span></span><br><span class=line>          <span class=comment>// The monitor should either be a thread-specific private</span></span><br><span class=line>          <span class=comment>// free list or the global free list.</span></span><br><span class=line>          <span class=comment>// obj == NULL IMPLIES mid->is_busy() == 0</span></span><br><span class=line>        guarantee (!mid->is_busy(), <span class=string>"invariant"</span>) ;</span><br><span class=line>        <span class=keyword>continue</span> ;</span><br><span class=line>      }</span><br><span class=line>      deflated = deflate_monitor(mid, obj, &FreeHead, &FreeTail);</span><br><span class=line></span><br><span class=line>      <span class=keyword>if</span> (deflated) {</span><br><span class=line>        mid->FreeNext = NULL ;</span><br><span class=line>        nScavenged ++ ;</span><br><span class=line>      } <span class=keyword>else</span> {</span><br><span class=line>        nInuse ++;</span><br><span class=line>      }</span><br><span class=line>    }</span><br><span class=line>  }</span><br><span class=line>  MonitorFreeCount += nScavenged;</span><br><span class=line></span><br><span class=line>	<span class=comment>// Consider: audit gFreeList to ensure that MonitorFreeCount and list agree.</span></span><br><span class=line>  <span class=keyword>if</span> (ObjectMonitor::Knob_Verbose) {</span><br><span class=line>    ::printf (<span class=string>"Deflate: InCirc=%d InUse=%d Scavenged=%d ForceMonitorScavenge=%d : pop=%d free=%d\n"</span>,</span><br><span class=line>        nInCirculation, nInuse, nScavenged, ForceMonitorScavenge,</span><br><span class=line>        MonitorPopulation, MonitorFreeCount) ;</span><br><span class=line>    ::fflush(stdout) ;</span><br><span class=line>  }</span><br><span class=line></span><br><span class=line>  ForceMonitorScavenge = <span class=number>0</span>;    <span class=comment>// Reset</span></span><br><span class=line></span><br><span class=line><span class=comment>// Move the scavenged monitors back to the global free list.</span></span><br><span class=line>  <span class=keyword>if</span> (FreeHead != NULL) {</span><br><span class=line>     guarantee (FreeTail != NULL && nScavenged > <span class=number>0</span>, <span class=string>"invariant"</span>) ;</span><br><span class=line>     <span class=keyword>assert</span> (FreeTail->FreeNext == NULL, <span class=string>"invariant"</span>) ;</span><br><span class=line><span class=comment>// constant-time list splice - prepend scavenged segment to gFreeList</span></span><br><span class=line>     FreeTail->FreeNext = gFreeList ;</span><br><span class=line>     gFreeList = FreeHead ;</span><br><span class=line>  }</span><br><span class=line>  Thread::muxRelease (&ListLock) ;</span><br><span class=line></span><br><span class=line>  <span class=keyword>if</span> (ObjectMonitor::_sync_Deflations != NULL) ObjectMonitor::_sync_Deflations->inc(nScavenged) ;</span><br><span class=line>  <span class=keyword>if</span> (ObjectMonitor::_sync_MonExtant  != NULL) ObjectMonitor::_sync_MonExtant ->set_value(nInCirculation);</span><br><span class=line></span><br><span class=line><span class=comment>// <span class=doctag>TODO:</span> Add objectMonitor leak detection.</span></span><br><span class=line><span class=comment>// Audit/inventory the objectMonitors -- make sure they're all accounted for.</span></span><br><span class=line>  GVars.stwRandom = os::random() ;</span><br><span class=line>  GVars.stwCycle ++ ;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=5-1-6、注意事项><a class=headerlink href=#5-1-6、注意事项 title=5.1.6、注意事项></a>5.1.6、注意事项</h3><ol><li>synchronized(Object)模式下，不能用String常量、Integer、Long等类型来作为锁角色。<li>锁定方法与非锁定方法可同时执行。<li>多个线程必须锁定同一个锁（对象）。（需用final修饰锁对象，防止修改）<li>自旋锁在 JDK1.4.2 中引入，使用 -XX:+UseSpinning 来开启。JDK 6 中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。<li>自适应自旋锁意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。<li>偏向锁由于有锁撤销的过程，会消耗系统资源，所以，在锁争用特别激烈的时候，用偏向锁未必效率高。还不如直接使用轻量级锁。</ol><h2 id=5-2、CAS><a class=headerlink href=#5-2、CAS title=5.2、CAS></a>5.2、CAS</h2><h3 id=5-2-1、简介><a class=headerlink href=#5-2-1、简介 title=5.2.1、简介></a>5.2.1、简介</h3><p><strong>CAS是 Compare And Set/Swap/exchange 的简写，意为比较并交换。</strong><p>cas(V, Expected, NewValue)：V为原值，Expected为期望值。NewValue为新值。在修改原值为新值时，判断原值是否与期望值相同，相同则修改，否则拿到和期望值不同的原值再次进行相同逻辑的修改，一直到修改成功为止，这个过程就称为“自旋”。自旋会无意义消耗CPU，故是否选择使用CAS自旋技术，要根据实际场景来选择：<ul><li>线程数量多且执行时间长，就要避免使用CAS自旋，而要选用重量级锁来代替，因为重量级锁使用的是等待队列，不会消耗CPU。<li>线程数量少且执行时间短，选用CAS自旋会较好。</ul><h3 id=5-2-2、底层实现><a class=headerlink href=#5-2-2、底层实现 title=5.2.2、底层实现></a>5.2.2、底层实现</h3><ol><li>底层指令实现：<ul><li>IA64、X86下：通过<code>lock、cmpxchg</code>指令实现。单纯的<code>cmpxchg</code>不能保证原子性。<li>sparc-TSO下：通过<code>case</code>指令实现。<li>ARM和PowerPC下：通过一对<code>Idrex/strex</code>指令实现。</ul><li>硬件情况下：lock指令在执行后面指令的时候锁定一个北桥信号。<li>拓展知识：处理器 使用总线锁和缓存锁来实现原子操作。</ol><h3 id=5-2-3、CAS缺点><a class=headerlink href=#5-2-3、CAS缺点 title=5.2.3、CAS缺点></a>5.2.3、CAS缺点</h3><ol><li><p>ABA问题。解决方法：加版本号。</p><li><p>自旋时间长。解决方法：如果JVM支持处理器提供的pause指令，那么效率会有一点提升。</p> <ul><li><p>PAUSE指令作用：</p> <ol><li>提升<code>spin-wait loops(自旋锁循环等待)</code>的性能。在执行一个<code>spin-wait loop</code>时，Pentium4 处理器会遇到严重的性能损失，PAUSE 指令会向处理器发起提醒：告诉处理器所执行的代码序列是一个 spin-wait loop。处理器会根据这个提醒而避开内存序列冲突(memory order violation)，也就是说对 spin-wait loop 不做缓存，不做指令重新排序等动作。这样就可以大大的提高了处理器的性能。正是基于此，才建议在 spin-wait loops 中使用 pasuse 指令。<li>减少 Pentium4 处理器在执行 spin-wait loop 时的电源消耗。在等待资源而执行自旋锁等待时，Pentium4 处理器会极速执行从而导致消耗很多电能，而<code>pause</code>指令则可以极大的减少处理器的电能消耗。</ol><li><p>PAUSE指令拓展：</p> <p>PAUSE 指令在 Pentium4 处理器中引入，但它也是向前兼容的。在早先的 IA-32 处理器中，PAUSE 指令实际上就相当于 NOP 指令。</p> <p>Pentium4 处理器以一种 预延迟(pre-defined delay)的技术来实现 PAUSE 指令。这种延迟是有限度的，且在一些处理器上是零延迟。该指令不会改变处理器的处理器状态。</p></ul><li><p>只能保证一个共享变量的原子操作。解决方法：加锁；AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象中执行CAS操作。</p></ol><h3 id=5-2-4、自增操作><a class=headerlink href=#5-2-4、自增操作 title=5.2.4、自增操作></a>5.2.4、自增操作</h3><ul><li><p>Synchronized操作：执行时间长，因为需要用户态与内核态的切换，从而降低了执行效率。</p><li><p>AtomicXXX操作：执行时间较Synch要少，因为使用了CAS自旋/无锁操作。</p><li><p>LongAdder操作：执行时间长，因为使用了分段锁。 适用于并发量大的情况。</p></ul><h2 id=5-3、Volatile><a class=headerlink href=#5-3、Volatile title=5.3、Volatile></a>5.3、Volatile</h2><h3 id=5-3-1、简介><a class=headerlink href=#5-3-1、简介 title=5.3.1、简介></a>5.3.1、简介</h3><p>volatile是轻量级的 synchronized，它在多处理器开发中保证了共享变量的“可见性”。<strong>可见性指的是 当一个线程修改了一个共享变量后，另外一个线程能读到这个共享变量被修改后的值。</strong><p><strong>volatile比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</strong><p>几个重要的CPU术语如下：<p><img alt=CPU术语001 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/CPU%E6%9C%AF%E8%AF%AD001.png?token=AIGEF3NKAFXF6QJXCEDLJ63EZZYPO><p>volatile变量自身具有如下特性。<ul><li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</ul><h3 id=5-3-2、底层实现><a class=headerlink href=#5-3-2、底层实现 title=5.3.2、底层实现></a>5.3.2、底层实现</h3><h4 id=字节码层面><a class=headerlink href=#字节码层面 title=字节码层面></a>字节码层面</h4><p>在volatile修饰的元素前加了一个访问标志：ACC_VOLATILE。<h4 id=JVM层面（规范）><a class=headerlink href=#JVM层面（规范） title=JVM层面（规范）></a>JVM层面（规范）</h4><ol><li><p>StoreStore Barriers - volatile写 - StoreLoad Barriers。</p><li><p>volatile读 - LoadLoad Barriers - LoadStore Barriers。</p></ol><h4 id=hotspot><a class=headerlink href=#hotspot title=hotspot></a>hotspot</h4><p><strong>底层基于大多数CPU都支持的 lock addl 汇编代码指令来实现。</strong><p>Lock前缀的指令在多核处理器下的作用：<ul><li>将当前处理器缓存行的数据写回到系统内存。<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</ul><blockquote><p>对volatile修饰的变量执行写操作时会向处理器发送一条Lock前缀指令，将该变量所在缓存行的数据【写回到系统内存】。但要注意，虽然已经写回内存但其它处理器中关于该变量的缓存依然是旧的，对旧的数据执行操作就会有问题。所以，多处理器下，为了保证各个处理器缓存的一致性，就会实现【缓存一 致性协议】，每个处理器通过嗅探总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作时会重新从系统内存中把数据读到处理器缓存里。<p>volatile有两个实现原则：<ol><li>Lock前缀指令会引起处理器缓存回写到内存。<li>一个处理器的缓存回写到内存会导致其他处理器的缓存无效。</ol></blockquote><h4 id=CPU层面><a class=headerlink href=#CPU层面 title=CPU层面></a>CPU层面</h4><ul><li><p>X86 CPU内存屏障（有序性保证）</p> <ol><li><font color=orange>sfence指令</font>：sfence指令前写 优先于 sfence指令后写。<li><font color=orange>lfence指令</font>：lfence指令前读 优先于 lfence指令后读。<li><font color=orange>mfence指令</font>：mfence指令前读写 优先于 sfence指令后读写。</ol> <p>可惜大多数CPU并不支持这种指令，故hotspor并没有选择这种方案来实现有序性，而是采用大多数CPU都支持的其它指令：lock addl 来实现。</p></ul><h3 id=5-3-3、实现一致性-可见性><a class=headerlink href=#5-3-3、实现一致性-可见性 title=5.3.3、实现一致性/可见性></a>5.3.3、实现一致性/可见性</h3><ol><li>MESI能解决就用MESI。<li>锁总线。</ol><p>为了保证内存可见性，Java编译器会在生成指令序列的适当位置插入 内存屏障指令 来禁止特定类型的处理器重排序。<p><strong>JMM把内存屏障指令分为4类：LoadLoad屏障、StoreStore屏障、LoadStore屏障、StoreLoad屏障。</strong>（详情参考本教程2.4.2节）<h3 id=5-3-4、实现有序性><a class=headerlink href=#5-3-4、实现有序性 title=5.3.4、实现有序性></a>5.3.4、实现有序性</h3><ol><li>内存屏障、sfence mfence lfence等系统原语/指令。sfence mfence lfence为什么不用？因为可移植性差。<li>锁总线。</ol><h3 id=5-3-5、解决指令重排序><a class=headerlink href=#5-3-5、解决指令重排序 title=5.3.5、解决指令重排序></a>5.3.5、解决指令重排序</h3><ol><li><p>代码级别：volatile修饰变量。</p><li><p>字节码级别：加访问修饰符 ACC_VOLATILE。</p><li><p>JVM级别：JVM内存屏障。（屏障两边的指令禁止重排）</p><li><p>Hotspot实现：lock addl指令。</p> <p>为何lock指令可以解决重排序和可见性问题？因为：lock用于在多处理器中执行指令时会对共享内存进行独占使用，其能够将当前处理器对应的缓存的内容刷新到内存中，并使其它处理器相同缓存中的内容失效。此外还提供有序指令无法越过内存屏障的作用。</p><li><p>系统级别：load fence、store fence原语指令。</p></ol><blockquote><p>编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。<p>这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作， 不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。<p>处理器对读/写操作的放松，是以两个操作之间不存在数据依赖性为前提的（因为处理器要遵守as-if-serial语义，处理器不会对存在数据依赖性的两个内存操作做重排序）。<p>as-if-serial语义：不管怎么重排序（编译器和处理器为了提高并行度），（单线程） 程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。<p><font color=red>注意：在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但允许volatile变量与普通变量重排序。</font></blockquote><p>bytecodeinterpreter.cpp<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=type>int</span> field_offset = cache-><span class=built_in>f2_as_index</span>();</span><br><span class=line><span class=keyword>if</span> (cache-><span class=built_in>is_volatile</span>()) {</span><br><span class=line>    <span class=keyword>if</span> (support_IRIW_for_not_multiple_copy_atomic_cpu) {</span><br><span class=line>        OrderAccess::<span class=built_in>fence</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>orderaccess_linux_x86.inline.hpp<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>inline</span> <span class=type>void</span> <span class=title>OrderAccess::fence</span><span class=params>()</span> </span>{</span><br><span class=line>  <span class=keyword>if</span> (os::<span class=built_in>is_MP</span>()) {</span><br><span class=line>    <span class=comment>// always use locked addl since mfence is sometimes expensive</span></span><br><span class=line>	<span class=meta>#<span class=keyword>ifdef</span> AMD64</span></span><br><span class=line>    	<span class=function>__asm__ <span class=title>volatile</span> <span class=params>(<span class=string>"lock; addl $0,0(%%rsp)"</span> : : : <span class=string>"cc"</span>, <span class=string>"memory"</span>)</span></span>;</span><br><span class=line>	<span class=meta>#<span class=keyword>else</span></span></span><br><span class=line>    	<span class=function>__asm__ <span class=title>volatile</span> <span class=params>(<span class=string>"lock; addl $0,0(%%esp)"</span> : : : <span class=string>"cc"</span>, <span class=string>"memory"</span>)</span></span>;</span><br><span class=line>	<span class=meta>#<span class=keyword>endif</span></span></span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=5-3-6、volatile优化><a class=headerlink href=#5-3-6、volatile优化 title=5.3.6、volatile优化></a>5.3.6、volatile优化</h3><h4 id=追加到64字节><a class=headerlink href=#追加到64字节 title=追加到64字节></a>追加到64字节</h4><p><strong>著名的Java并发编程大师Doug lea在JDK 7的并发包里新增一个队列集合类LinkedTransferQueue，它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能。</strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=comment>/** 队列中的头部节点 */</span> </span><br><span class=line><span class=keyword>private</span> <span class=keyword>transient</span> <span class=keyword>final</span> PaddedAtomicReference&LTQNode> head; </span><br><span class=line><span class=comment>/** 队列中的尾部节点 */</span> </span><br><span class=line><span class=keyword>private</span> <span class=keyword>transient</span> <span class=keyword>final</span> PaddedAtomicReference&LTQNode> tail; </span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AtomicReference</span>&LTV> <span class=keyword>implements</span> <span class="title class_">java</span>.io.Serializable { </span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>volatile</span> V value; </span><br><span class=line>    <span class=comment>// 省略其他代码 </span></span><br><span class=line>｝</span><br><span class=line><span class=keyword>static</span> <span class=keyword>final</span> <span class=keyword>class</span> <span class="title class_">PaddedAtomicReference</span>&LTT> <span class=keyword>extends</span> <span class="title class_">AtomicReference</span>&LTT> { </span><br><span class=line>    <span class=comment>// 使用很多4个字节的引用追加到64个字节 </span></span><br><span class=line>    Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe; </span><br><span class=line>    PaddedAtomicReference(T r) {</span><br><span class=line>        <span class=built_in>super</span>(r); </span><br><span class=line>    } </span><br><span class=line>}</span><br></pre></table></figure><h4 id=为何追加到64字节？><a class=headerlink href=#为何追加到64字节？ title=为何追加到64字节？></a>为何追加到64字节？</h4><p>因为对于英特尔酷睿i7、酷睿、Atom和 NetBurst，以及Core Solo和Pentium M处理器的L1、L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行。这意味着，如果队列的头节点和尾节点都不足64字节，则处理器会将它们都读到同一个高速缓存行中，多处理器环境下的每个处理器都会缓存同样的头、尾节点，当一 个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致 其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作则需要不断修改头节点，这样一来效率就会大大降低。<p>为解决这种问题，就可以把不足64字节的数据后面追加到64字节，也就是说让队列的头节点和尾节点各占一个缓存行，这样就避免了阻塞节点操作，大大提高效率。<h4 id=注意事项-1><a class=headerlink href=#注意事项-1 title=注意事项></a>注意事项</h4><p>使用volatile变量时一定要追加至64字节的说法并非一定成立。在以下两种场景中不适合：<ol><li><strong>缓存行非64字节宽的处理器</strong>。如P6系列和奔腾处理器，它们的L1和L2高速缓存行是32个 字节宽。<li><strong>共享变量不会被频繁地写</strong>。因为使用追加字节的方式需要处理器读取更多的字节到高速缓冲区，这本身就会带来一定的性能消耗，如果共享变量不被频繁写的话，锁的几率也非常小，就没必要通过追加字节的方式来避免相互锁定。</ol><blockquote><p><font color=red>注意：追加字节的方式在Java 7下可能不生效，因为Java 7更加智慧，它会淘汰或重新排列无用字段，所以，需要使用其它追加字节的方式。除了volatile，Java并发编程中应用较多的是synchronized。</font></blockquote><h3 id=5-3-7、volatile使用指南><a class=headerlink href=#5-3-7、volatile使用指南 title=5.3.7、volatile使用指南></a>5.3.7、volatile使用指南</h3><p>使用volatile时可参考如下两条规则：<ul><li>写后加写屏障，阻止写屏障前代码跑到后面。（写屏障箭头朝上）<li>读前加读屏障，防止读屏障后面代码跑到前面。（读屏障箭头朝下）</ul><p>代码示例：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line> <span class=keyword>volatile</span> <span class=type>int</span> a;</span><br><span class=line><span class=type>int</span> b;</span><br><span class=line><span class=type>int</span> c;</span><br><span class=line></span><br><span class=line>a = <span class=number>1</span>;	</span><br><span class=line><span class=comment>// 屏障^^^^^^</span></span><br><span class=line>b = <span class=number>2</span>;</span><br><span class=line><span class=comment>// 屏障vvvvvv</span></span><br><span class=line>c = a;</span><br></pre></table></figure><h2 id=5-4、Lock（锁）><a class=headerlink href=#5-4、Lock（锁） title=5.4、Lock（锁）></a>5.4、Lock（锁）</h2><h3 id=5-4-1、简介><a class=headerlink href=#5-4-1、简介 title=5.4.1、简介></a>5.4.1、简介</h3><h4 id=锁类架构图><a class=headerlink href=#锁类架构图 title=锁类架构图></a>锁类架构图</h4><p><img alt=Java中的锁和AQS类结构图01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/Java%E4%B8%AD%E7%9A%84%E9%94%81%E5%92%8CAQS%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE01.png?token=AIGEF3KXLEK2VZACCYGNWBDEZZYRQ><h4 id=Lock接口特性><a class=headerlink href=#Lock接口特性 title=Lock接口特性></a>Lock接口特性</h4><p>Lock接口提供了synchronized不具备的特性，详情如下：<p><img alt=锁-1.1-Lock接口提供了synchronized不具备的特性 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E9%94%81-1.1-Lock%E6%8E%A5%E5%8F%A3%E6%8F%90%E4%BE%9B%E4%BA%86synchronized%E4%B8%8D%E5%85%B7%E5%A4%87%E7%9A%84%E7%89%B9%E6%80%A7.png?token=AIGEF3PVCAV2TJT2GI66CC3EZZYTA><h3 id=5-4-2、乐观锁><a class=headerlink href=#5-4-2、乐观锁 title=5.4.2、乐观锁></a>5.4.2、乐观锁</h3><h4 id=5-4-2-1、简介><a class=headerlink href=#5-4-2-1、简介 title=5.4.2.1、简介></a>5.4.2.1、简介</h4><p><strong>乐观锁代表是 AtomicInteger，使用 CAS 保证原子性。</strong><p>乐观锁 核心思想：无需加锁，每次只有一个线程能 成功修改 共享变量，其它线程会不断重试直到成功。<blockquote><p>乐观锁常见实现就是CAS算法，java java.util.concurrent包下原子类(例如<code>AtomicBoolean</code>，<code>AtomicInteger</code>，<code>AtomicLong</code>)中的递增操作就是通过CAS自旋来实现。</blockquote><h4 id=5-4-2-2、特点><a class=headerlink href=#5-4-2-2、特点 title=5.4.2.2、特点></a>5.4.2.2、特点</h4><ul><li>线程一直运行，不会阻塞，故不存在线程上下文切换。<li>需要多核CPU支持，线程数不应该超过 CPU核心数量。</ul><h4 id=5-4-2-3、适用场景><a class=headerlink href=#5-4-2-3、适用场景 title=5.4.2.3、适用场景></a>5.4.2.3、适用场景</h4><p><strong>乐观锁适用于多读场景，不加锁可以提高读操作性能。</strong><h3 id=5-4-3、悲观锁><a class=headerlink href=#5-4-3、悲观锁 title=5.4.3、悲观锁></a>5.4.3、悲观锁</h3><h4 id=5-4-3-1、简介><a class=headerlink href=#5-4-3-1、简介 title=5.4.3.1、简介></a>5.4.3.1、简介</h4><p><strong>悲观锁代表是 synchronized 和 Lock 锁。</strong><p>悲观锁核心思想：线程占有了锁，才能操作共享变量，每次只能有一个线程占有锁，其它获线程都要等待。<h4 id=5-4-3-2、特点><a class=headerlink href=#5-4-3-2、特点 title=5.4.3.2、特点></a>5.4.3.2、特点</h4><ul><li>线程从运行到阻塞，再从阻塞到唤醒，期间经历 线程上下文切换，若频繁发生，则会严重影响性能。<li>获取 synchronized 和 Lock 锁时，若锁已被占用，那么会默认重试几次，减少阻塞机会。</ul><h4 id=5-4-3-3、适用场景><a class=headerlink href=#5-4-3-3、适用场景 title=5.4.3.3、适用场景></a>5.4.3.3、适用场景</h4><p><strong>悲观锁适用于多写场景，先加锁可以保证写操作时数据的正确性。</strong><h3 id=5-4-4、重入锁><a class=headerlink href=#5-4-4、重入锁 title=5.4.4、重入锁></a>5.4.4、重入锁</h3><h4 id=简介-3><a class=headerlink href=#简介-3 title=简介></a>简介</h4><p>重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对 资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。<p>ReentrantLock虽然没能像synchronized关键字一样支持隐式的重进入，但是在调用lock()方 法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。<h4 id=重入锁特点><a class=headerlink href=#重入锁特点 title=重入锁特点></a>重入锁特点</h4><ol><li>线程A获取锁L后，可以在不释放锁L的同时再次获取锁L，且不会出现死锁现象；<li>线程A释放掉锁L后，其它线程才能获取锁L；</ol><p><strong>可重入锁的使命就是防止自己锁自己，进而提高程序执行性能。</strong><p>Java中可重入锁的常见实现如下：<ol><li>Synchronized<li>ReentrantLock</ol><h3 id=5-4-5、ReentrantLock><a class=headerlink href=#5-4-5、ReentrantLock title=5.4.5、ReentrantLock></a>5.4.5、ReentrantLock</h3><h4 id=5-4-5-1、简介><a class=headerlink href=#5-4-5-1、简介 title=5.4.5.1、简介></a>5.4.5.1、简介</h4><p><strong>ReentrantLock是一个可重入锁、独占式锁，与synchronized关键字相比，它更灵活、更强大，增加了轮询、超时、中断等高级功能。除此外，还提供了对公平锁与非公平锁的选择。</strong><p>ReentrantLock的内部类Sync继承了AQS，分为公平锁FairSync和非公平锁NonfairSync。ReentrantLock使用公平锁还是非公平锁，可以通过它的构造函数来决定。<blockquote><p>公平锁：按照请求的顺序来获取锁；非公平锁：不管请求顺序的先后，谁抢到锁，这把锁就是谁的。</blockquote><p>事实上，公平锁往往没有非公平锁的效率高，但是，并不是任何场景都是以TPS作为唯一指标，公平锁能够减少“饥饿”发生的概率，等待越久的请求越能够得到优先满足。<h4 id=5-4-5-2、原理><a class=headerlink href=#5-4-5-2、原理 title=5.4.5.2、原理></a>5.4.5.2、原理</h4><p><strong>ReentrantLock 主要通过unsafe的 CAS 和 park 两个功能实现锁机制。</strong><p>Sync类是ReentrantLock自定义同步组件，它是ReentrantLock的一个内部类，其继承自AQS，它有两个子类：公平锁FairSync和非公平锁NonfairSync。ReentrantLock的获取与释放锁操作都是委托给该同步组件来实现。<h3 id=5-4-6、读写锁><a class=headerlink href=#5-4-6、读写锁 title=5.4.6、读写锁></a>5.4.6、读写锁</h3><h4 id=5-4-6-1、简介><a class=headerlink href=#5-4-6-1、简介 title=5.4.6.1、简介></a>5.4.6.1、简介</h4><p><strong>读多写少情况下，读写锁能够提供比排它锁更好的并发性和吞吐量。读写锁的实现是 ReentrantReadWriteLock。</strong><p>ReadWriteLock仅定义了获取读锁和写锁的两个方法，其实现ReentrantReadWriteLock，除了接口方法之外，还提供了一些便于外界监控内部工作状态的方法。<h4 id=5-4-6-2、特点><a class=headerlink href=#5-4-6-2、特点 title=5.4.6.2、特点></a>5.4.6.2、特点</h4><p><img alt=锁-1.2-读写锁特性 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E9%94%81-1.2-%E8%AF%BB%E5%86%99%E9%94%81%E7%89%B9%E6%80%A7.png?token=AIGEF3MBYW4434TSKNMP7ULEZZYVI><h4 id=5-4-6-3、底层实现><a class=headerlink href=#5-4-6-3、底层实现 title=5.4.6.3、底层实现></a>5.4.6.3、底层实现</h4><h5 id=读写状态><a class=headerlink href=#读写状态 title=读写状态></a>读写状态</h5><p>读写锁 同样依赖 自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。ReentrantLock中自定义同步器的同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状 态，使得该状态的设计成为读写锁实现的关键。<p><strong>如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将 变量切分成了两个部分，高16位表示读，低16位表示写</strong>，划分方式如下图：<p><img alt=锁-1.3-读写锁状态划分设计图 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E9%94%81-1.3-%E8%AF%BB%E5%86%99%E9%94%81%E7%8A%B6%E6%80%81%E5%88%92%E5%88%86%E8%AE%BE%E8%AE%A1%E5%9B%BE.png?token=AIGEF3KMLEL744A7NPZTJKLEZZYXY><p>读写锁是如何迅速确定读和写各自的状态呢？答案是通过位运算。假设当前同步状态 值为S，写状态等于S&0x0000FFFF（将高16位全部抹去），读状态等于S>>>16（无符号补0右移 16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1<&LT16)，也就是 S+0x00010000。<h5 id=写锁获取与释放><a class=headerlink href=#写锁获取与释放 title=写锁获取与释放></a>写锁获取与释放</h5><p>写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程， 则当前线程进入等待状态。<blockquote><p>如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果 允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。</blockquote><p>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0 时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对 后续读写线程可见。<h5 id=读锁获取与释放><a class=headerlink href=#读锁获取与释放 title=读锁获取与释放></a>读锁获取与释放</h5><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问 （或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程 获取，则进入等待状态。<p>读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少值是（1<&LT16）。<h4 id=5-4-6-4、锁升级-降级><a class=headerlink href=#5-4-6-4、锁升级-降级 title=5.4.6.4、锁升级/降级></a>5.4.6.4、锁升级/降级</h4><h5 id=锁降级><a class=headerlink href=#锁降级 title=锁降级></a>锁降级</h5><p><strong>锁降级指的是写锁降级成为读锁。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。</strong><h5 id=锁升级（不存在）><a class=headerlink href=#锁升级（不存在） title=锁升级（不存在）></a>锁升级（不存在）</h5><p><font color=red>RentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。</font>目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。<h3 id=5-4-10、小总结><a class=headerlink href=#5-4-10、小总结 title=5.4.10、小总结></a>5.4.10、小总结</h3><h4 id=5-4-10-1、Synchronized和ReentrantLock区别><a class=headerlink href=#5-4-10-1、Synchronized和ReentrantLock区别 title=5.4.10.1、Synchronized和ReentrantLock区别></a>5.4.10.1、Synchronized和ReentrantLock区别</h4><h5 id=共同点><a class=headerlink href=#共同点 title=共同点></a>共同点</h5><ol><li>都是用来协调多线程对共享对象、变量的访问。<li>都是可重入锁，即同一线程可以多次获得同一个锁。<li>都保证了可见性和互斥性。</ol><h5 id=不同点><a class=headerlink href=#不同点 title=不同点></a>不同点</h5><ol><li><p>API方面</p> <ul><li>Synchronized：可修饰方法、代码块。隐式获取/释放锁。<li>ReentrantLock：显式获取/释放锁。（获取锁：ReentrantLock.lock；释放锁：ReentrantLock.unlock）</ul><li><p>等待可中断</p> <p>有两个线程：T1、T2，假设T1获取了对象object的锁，T2将等待T1释放object的锁。则：</p> <ul><li>Synchronized：T2会一直等待下去，不可被中断。<li>ReentrantLock：T2等待一定时间后，会中断操作，转而去做其它事。</ul><li><p>公平锁</p> <ul><li>Synchronized：是非公平锁。<li>ReenTrantLock：默认是非公平锁，可通过布尔值来控制使用公平锁。</ul><li><p>绑定多个条件</p> <ul><li>Synchronized：锁对象的wait和notify() 或notifyAll()方法可以实现一个隐含的条件。<li>ReenTrantLock：可以同时绑定多个Condition对象，只需多次调用newCondition方法即可。</ul><li><p>性能</p> <p>JDK1.5中的Synchronized有很大优化余地。JDK 1.6 中加入了很多针对锁的优化措施，故synchronized与ReentrantLock在性能方面基本持平。</p><li><p>其它</p> <ul><li>Synchronized是关键字，是内置语言的实现。Lock是一个接口。<li>Synchronized在发生异常时，会自动释放线程占有的锁，不会导致死锁发生。Lock必须通过unlock方法释放锁，否则会造成死锁。<li>Synchronized无法判断是否获取到锁；Lock可以。<li>Synchronized不管读写，都会阻塞线程，读效率低；Lock可以提供读写锁，可提高并发读的效率。</ul></ol><table><thead><tr><th align=center>比较方面<th align=center>synchronized<th align=center>ReenTrantLock<tbody><tr><td align=center>原始构成<td align=center>Java关键字，原生语法层面的互斥，需要JVM支持。<td align=center>JDK1.5之后提供的互斥锁<tr><td align=center>实现<td align=center>通过JVM自动加锁/解锁<td align=center>显式加锁/解锁<tr><td align=center>代码实现<td align=center>隐式自动获取锁/释放锁<td align=center>显式获取锁/释放锁<tr><td align=center>灵活性<td align=center>锁的范围可以随意控制<td align=center>Lock是方法调用，可跨方法，灵活性更大<tr><td align=center>等待可中断<td align=center>不可中断，除非抛出异常。<td align=center>可中断<tr><td align=center>公平<td align=center>非公平锁<td align=center>默认非公平锁，但可通过布尔值控制使用公平锁<tr><td align=center>条件Condition<td align=center><td align=center>通过多次newCondition可以获得多个Condition对象，可以简单的实现比较复杂的线程同步功能。<tr><td align=center>高级功能<td align=center><td align=center>getHoldCount()、getQueueLength()、isFair()、isHeldByCurrentThread()、isLocked()<tr><td align=center>便利性<td align=center>会自动释放获取锁，便利性好。<td align=center>需要手动获取释放锁，便利性差。<tr><td align=center>适用情况<td align=center>适用于并发度低的情况。<td align=center>适用于并发度高的情况。</table><h4 id=5-4-10-2、Lock-VS-Synchronized><a title="5.4.10.2、Lock VS Synchronized" class=headerlink href=#5-4-10-2、Lock-VS-Synchronized></a>5.4.10.2、Lock VS Synchronized</h4><p><strong>Lock可以非阻塞获取锁、被中断地获取锁、超时获取锁。</strong><h2 id=5-5、原子操作><a class=headerlink href=#5-5、原子操作 title=5.5、原子操作></a>5.5、原子操作</h2><h3 id=5-5-1、简介><a class=headerlink href=#5-5-1、简介 title=5.5.1、简介></a>5.5.1、简介</h3><p><strong>原子操作（atomic operation）意为“不可被中断的一个或一系列操作”。</strong><p>原子操作相关术语如下：<p><img alt=原子操作-1.1-相关术语 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C-1.1-%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD.png?token=AIGEF3KT2PLCG34WR36C2ZLEZZYZ2><h3 id=5-5-2、处理器原子操作><a class=headerlink href=#5-5-2、处理器原子操作 title=5.5.2、处理器原子操作></a>5.5.2、处理器原子操作</h3><p>首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。<p>为保证复杂内存操作的原子性，处理器提供了两种机制：<ul><li><p>总线锁</p> <p>所谓总线锁就是使用处理器提供的一个 LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该 处理器可以独占共享内存。</p><li><p>缓存锁</p> <p>总线锁定把CPU和内存之间的通信锁住了，开销较大，所以使用缓存锁定代替总线锁定来进行优化。</p> <p>有两种情况下处理器不会使用缓存锁定：</p> <ol><li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，处理器会调用总线锁定。<li>有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的 内存区域在处理器的缓存行中也会调用总线锁定。</ol></ul><h3 id=5-5-3、Java原子操作><a class=headerlink href=#5-5-3、Java原子操作 title=5.5.3、Java原子操作></a>5.5.3、Java原子操作</h3><p><strong>Java中可以通过 锁、循环CAS 方式来实现原子操作。</strong><h4 id=CAS实现原子操作><a class=headerlink href=#CAS实现原子操作 title=CAS实现原子操作></a>CAS实现原子操作</h4><p><strong>JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的</strong>。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。从Java 1.5开始，JDK的并发包里提供了一些原子操作类来支持原子操作。<p>CAS实现原子操作的三大问题：<ol><li>ABA问题。<li>循环时间长开销大。<li>只能保证一个共享变量的原子操作。</ol><h4 id=锁实现原子操作><a class=headerlink href=#锁实现原子操作 title=锁实现原子操作></a>锁实现原子操作</h4><p>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁 机制，有偏向锁、轻量级锁和互斥锁。除了偏向锁，JVM实现锁的方式都用了循环 CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时 候使用循环CAS释放锁。<h4 id=原子操作类><a class=headerlink href=#原子操作类 title=原子操作类></a>原子操作类</h4><p><strong>JDK 5开始提供了java.util.concurrent.atomic包，Atomic包里一共提供了13个类，属于4种类型的原子更新方式</strong>，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。Atomic包里的类基本都是使用Unsafe实现的包装类。<h5 id=基本类型><a class=headerlink href=#基本类型 title=基本类型></a>基本类型</h5><ul><li>AtomicBoolean：原子更新布尔类型。<li>AtomicInteger：原子更新整型。<li>AtomicLong：原子更新长整型。</ul><p>Java的基本类型里还有char、float和double等，对其这些基本类型，可以将它们转换成整型后，再使用compareAndSwapInt进行CAS更新。<h5 id=数组类型><a class=headerlink href=#数组类型 title=数组类型></a>数组类型</h5><ul><li>AtomicIntegerArray：原子更新整型数组里的元素。<li>AtomicLongArray：原子更新长整型数组里的元素。<li>AtomicReferenceArray：原子更新引用类型数组里的元素。</ul><h5 id=引用类型><a class=headerlink href=#引用类型 title=引用类型></a>引用类型</h5><ul><li>AtomicReference：原子更新引用类型。<li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。<li>AtomicMarkableReference：原子更新带有标记位的引用类型。</ul><h5 id=对象属性><a class=headerlink href=#对象属性 title=对象属性></a>对象属性</h5><ul><li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器。<li>AtomicStampedReference：原子更新带有版本号的引用类型。</ul><h2 id=5-6、并发工具类><a class=headerlink href=#5-6、并发工具类 title=5.6、并发工具类></a>5.6、并发工具类</h2><h3 id=5-6-1、CountDownLatch><a class=headerlink href=#5-6-1、CountDownLatch title=5.6.1、CountDownLatch></a>5.6.1、CountDownLatch</h3><p><strong>CountDownLatch允许一个或多个线程等待其他线程完成操作。</strong><p><strong>调用CountDownLatch的countDown方法时，N会减1，CountDownLatch的await方法会阻塞当前线程，直到N变成零。</strong>由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程中时，只需要把这个 CountDownLatch的引用传递到线程里即可。<p><font color=red>注意：计数器必须大于等于0，如果等于0，则调用await方法时不会阻塞当前线程。CountDownLatch不可能重新初始化或者修改CountDownLatch对象的内部计数器的值。一个线程调用countDown方法happen-before另外一个线程调用await方法。</font><h3 id=5-6-2、CyclicBarrier><a class=headerlink href=#5-6-2、CyclicBarrier title=5.6.2、CyclicBarrier></a>5.6.2、CyclicBarrier</h3><p><strong>CyclicBarrier是可循环使用的屏障。它的目的：让一 组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</strong><p>CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。<p>CyclicBarrier还提供一个更高级的构造函数CyclicBarrier（int parties，Runnable barrierAction），用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景。<ul><li>CyclicBarrier VS CountDownLatch</ul><p><strong>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。</strong><h3 id=5-6-3、Semaphore><a class=headerlink href=#5-6-3、Semaphore title=5.6.3、Semaphore></a>5.6.3、Semaphore</h3><p><strong>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</strong><p>Semaphore的构造方法Semaphore(int permits) 接受一个整型的数字，表示可用的许可证数量。Semaphore(10) 表示允许10个线程获取许可证，也就是最大并发数是10。Semaphore的用法也很简单，首先线程使用 Semaphore的acquire()方法获取一个许可证，使用完之后调用release()方法归还许可证。还可以用tryAcquire()方法尝试获取许可证。<h3 id=5-6-4、Exchanger><a class=headerlink href=#5-6-4、Exchanger title=5.6.4、Exchanger></a>5.6.4、Exchanger</h3><h4 id=简介-4><a class=headerlink href=#简介-4 title=简介></a>简介</h4><p><strong>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于线程间的数据交换。</strong>它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。<strong>两个线程通过 exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</strong><p><font color=red>注意：如果两个线程有一个没有执行exchange()方法则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用exchange(V x, longtimeout, TimeUnit unit)设置最大等待时长。</font><h4 id=应用场景><a class=headerlink href=#应用场景 title=应用场景></a>应用场景</h4><ol><li>Exchanger可以用于遗传算法，遗传算法中需要选出两个人作为交换对象，这时候会交换两人的数据，并使用交叉规则得出2个结果。<li>Exchanger也可以用于校对工作。</ol><h2 id=5-7、并发容器及框架><a class=headerlink href=#5-7、并发容器及框架 title=5.7、并发容器及框架></a>5.7、并发容器及框架</h2><h3 id=5-7-1、阻塞队列><a class=headerlink href=#5-7-1、阻塞队列 title=5.7.1、阻塞队列></a>5.7.1、阻塞队列</h3><h4 id=简介-5><a class=headerlink href=#简介-5 title=简介></a>简介</h4><p>JDK 7提供了7个阻塞队列，如下。<ul><li>ArrayBlockingQueue：一个由<strong>数组结构</strong>组成的<strong>有界阻塞</strong>队列。<li>LinkedBlockingQueue：一个由<strong>链表结构</strong>组成的<strong>有界阻塞</strong>队列。<li>PriorityBlockingQueue：一个<strong>支持优先级排序的无界阻塞</strong>队列。<li>DelayQueue：一个使用<strong>优先级队列</strong>实现的<strong>无界阻塞</strong>队列。<li>SynchronousQueue：一个<strong>不存储元素的阻塞队列</strong>。<li>LinkedTransferQueue：一个由<strong>链表结构</strong>组成的<strong>无界阻塞</strong>队列。<li>LinkedBlockingDeque：一个由<strong>链表结构</strong>组成的<strong>双向阻塞</strong>队列。</ul><h4 id=分析><a class=headerlink href=#分析 title=分析></a>分析</h4><h5 id=ArrayBlockingQueue><a class=headerlink href=#ArrayBlockingQueue title=ArrayBlockingQueue></a>ArrayBlockingQueue</h5><p><strong>此队列按照先进先出（FIFO）的原则对元素进行排序，默认情况下不保证线程访问队列的公平性。</strong><p>为了保证公平性，通常会降低吞吐量。可以使用以下代码创建一个公平的阻塞队列：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>ArrayBlockingQueue</span> <span class=variable>fairQueue</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class=number>1000</span>,<span class=literal>true</span>);</span><br></pre></table></figure><h5 id=LinkedBlockingQueue><a class=headerlink href=#LinkedBlockingQueue title=LinkedBlockingQueue></a>LinkedBlockingQueue</h5><p><strong>此队列的默认和最大长度为 Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。</strong><h5 id=PriorityBlockingQueue><a class=headerlink href=#PriorityBlockingQueue title=PriorityBlockingQueue></a>PriorityBlockingQueue</h5><p><strong>默认情况下元素采取自然顺序 升序排列。也可以自定义类实现compareTo()方法来指定元素排序规则</strong>，或者初始化 PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。<h5 id=DelayQueue><a class=headerlink href=#DelayQueue title=DelayQueue></a>DelayQueue</h5><p>DelayQueue是一个<strong>支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现</strong>。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。 只有在延迟期满时才能从队列中提取元素。<p>应用场景：<ul><li>缓存系统的设计<li>定时任务调度</ul><h5 id=SynchronousQueue><a class=headerlink href=#SynchronousQueue title=SynchronousQueue></a>SynchronousQueue</h5><p><strong>每一个put操作必须等待一个take操作， 否则不能继续添加元素。</strong><p>它支持公平访问队列，默认情况下线程采用非公平性策略访问队列。<p>SynchronousQueue的吞吐量高于 LinkedBlockingQueue和ArrayBlockingQueue。<h5 id=LinkedTransferQueue><a class=headerlink href=#LinkedTransferQueue title=LinkedTransferQueue></a>LinkedTransferQueue</h5><p>相对于其它 阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。<ul><li><p>transfer方法</p> <p>如果当前有消费者正在等待接收元素（消费者使用take()方法或带时间限制的poll()方法 时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等 待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。</p><li><p>tryTransfer方法</p> <p>tryTransfer方法是用来试探生产者传入的元素是否能直接传给消费者。如果没有消费者等 待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法 立即返回，而transfer方法是必须等到消费者消费了才返回。</p></ul><h5 id=LinkedBlockingDeque><a class=headerlink href=#LinkedBlockingDeque title=LinkedBlockingDeque></a>LinkedBlockingDeque</h5><p>是一个由链表结构组成的双向阻塞队列。所谓双向队列指的是可以 从队列的两端插入和移出元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。<p>初始化LinkedBlockingDeque时可以设置容量防止其过度膨胀。另外，双向阻塞队列可以运用在“工作窃取”模式中<h4 id=底层实现-1><a class=headerlink href=#底层实现-1 title=底层实现></a>底层实现</h4><p><strong>阻塞队列底层主要使用 通知模式 来实现生产者与消费者间的通信。</strong><p>ArrayBlockingQueue使用了Condition来实现，当往队列里插入一个元素时，如果队列不可用，那么阻塞生产者主要通过 LockSupport.park（this）来实现。<p>park这个方法会阻塞当前线程，但以下4种情况中的任何一种发生时，该方法就会返回：<ul><li>与park对应的unpark执行或已经执行过时。<li>线程被中断时。<li>等待完time参数指定的毫秒数时。<li>异常现象发生时，这个异常现象没有任何原因。</ul><h3 id=5-7-2、ForkJoin框架><a class=headerlink href=#5-7-2、ForkJoin框架 title=5.7.2、ForkJoin框架></a>5.7.2、ForkJoin框架</h3><h4 id=简介-6><a class=headerlink href=#简介-6 title=简介></a>简介</h4><p><strong>Fork/Join框架是Java 7提供的一个用于 并行执行任务 的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</strong><h4 id=工作窃取算法><a class=headerlink href=#工作窃取算法 title=工作窃取算法></a>工作窃取算法</h4><p><strong>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。</strong><p>工作窃取算法的优缺点如下：<ul><li><p>优点：充分利用线程进行并行计算，减少了线程间的竞争</p><li><p>缺点：某些情况下还是存在竞争，比如双端队列里只有一个任务时。并 且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</p></ul><h4 id=异常处理><a class=headerlink href=#异常处理 title=异常处理></a>异常处理</h4><p>ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消，且可以通过ForkJoinTask的getException方法获取异常。<p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或没有抛出异常则返回null。<h4 id=底层设计><a class=headerlink href=#底层设计 title=底层设计></a>底层设计</h4><ul><li>步骤1，分割任务。<li>步骤2，执行任务并合并结果。</ul><p>Fork/Join使用两个类来完成以上两件事情：<ul><li><p><strong>ForkJoinTask</strong>：使用ForkJoin框架，必须首先创建一个ForkJoin任务。</p> <p>通常情况下，我们不需要直接继承ForkJoinTask类，只需要继 承它的子类：</p> <ul><li>RecursiveAction：用于没有返回结果的任务。<li>RecursiveTask：用于有返回结果的任务。</ul><li><p><strong>ForkJoinPool</strong>：ForkJoinTask需要通过ForkJoinPool来执行。</p></ul><p>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，ForkJoinTask数组负责将存放程序提交给ForkJoinPool的任务，而ForkJoinWorkerThread数组负责执行这些任务。<ul><li><p>ForkJoinTask的fork方法</p> <p>调用ForkJoinTask的fork方法时，会异步调用ForkJoinWorkerThread的pushTask方法将任务放到ForkJoinTask数组中，然后调用ForkJoinPool的signalWork方法唤醒或创建一个线程去执行该任务。</p><li><p>ForkJoinTask的join方法</p> <p>调用Join方法会调用doJoin()方法，通过doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有4种：已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常 （EXCEPTIONAL）。</p></ul><h2 id=5-8、并发底层原理><a class=headerlink href=#5-8、并发底层原理 title=5.8、并发底层原理></a>5.8、并发底层原理</h2><h3 id=5-8-1、LockSupport工具><a class=headerlink href=#5-8-1、LockSupport工具 title=5.8.1、LockSupport工具></a>5.8.1、LockSupport工具</h3><p><strong>LockSupport是构建同步组件的基础工具。</strong>LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark(Thread thread) 方法来唤醒一个被阻塞的线程。<p>Java 6中，LockSupport增加了park(Object blocker)、parkNanos(Object blocker,long nanos) 和parkUntil(Object blocker,long deadline)3个方法，用于实现阻塞当前线程的功能，其中参数 blocker是用来标识当前线程在等待的对象（以下称为阻塞对象），该对象主要用于问题排查和 系统监控。<h3 id=5-8-2、Condition接口><a class=headerlink href=#5-8-2、Condition接口 title=5.8.2、Condition接口></a>5.8.2、Condition接口</h3><h4 id=简介-7><a class=headerlink href=#简介-7 title=简介></a>简介</h4><p><strong>Java对象（wait/notify）配合Synchronized可以实现等待/通知模式。Condition接口配合Lock同样可以实现等待/通知模式，但是两者的使用方式和功能特性是有差别的。</strong><p>Object监视器 VS Condition接口：<p><img alt=image-20200620151112096 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200620151112096.png?token=AIGEF3LU66ZLAJQGHYYX6EDEZZY4A><p>Condition对象由Lock对象（调用Lock对象的newCondition()方法）创建出来，即通过Lock的newCondition()方法可以获取一个Condition。<p>Condition使用方式比较简单。当前线程调用await()方法后会释放锁并在此等待，其它线程调用Condition对象的signal()方法会导致当前线程获取锁并从await()方法返回。<h4 id=实现分析><a class=headerlink href=#实现分析 title=实现分析></a>实现分析</h4><p>ConditionObject是同步器AbstractQueuedSynchronizer的内部类，每个Condition对象都包含一个等待队列，该队列是Condition对象实现等待/通知功能的关键。<p><strong>Condition的实现主要包括：等待队列、等待和通知，下面提到的Condition，如果不加说明均指的是ConditionObject。</strong><p><strong>（1）等待队列</strong><p>等待队列是一个FIFO单向队列，队列中的每个节点都包含一个线程引用，该线程就是 在Condition对象上等待的线程，<strong>一个线程调用Condition.await()方法后会释放锁并被构造成节点放入到等待队列，然后进入等待状态</strong>。事实上，节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中的节点类型都是同步器的静态内部类 AbstractQueuedSynchronizer.Node。<p><strong>一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点 （lastWaiter）。</strong><p><img alt=image-20210221163426067 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210221163426067.png?token=AIGEF3OTFQWKT5ZQHHM4UODEZZY6G><p><strong>Object监视器模型中，一个对象拥有一个同步队列和等待队列，而并发包中的 Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列。</strong><p>Condition是同步器的内部类，因此每个Condition实例都能够访问 同步器提供的方法，相当于每个Condition都拥有所属同步器的引用。<p><strong>（2）等待</strong><p>调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。<p>如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同 步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。<p><strong>（3）通知</strong><p>调用Condition的signal()方法会导致：将等待队列的首节点移至同步队列中，然后唤醒该节点中的线程，被唤醒的线程会通过调用同步器的acquireQueued()方法来尝试获取同步状态。成功获取同步状态（锁）后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功获取了锁。<blockquote><p><font color=red>注意事项：</font><ol><li>当从await()方法返回时，当前线程一定获取了Condition相关联的锁。<li>调用signal()方法的前提是当前线程必须获取了锁；<li>如果节点不是通过Condition.signal()方法被唤醒，而是通过中断被唤醒的话，会抛出异常 InterruptedException。</ol></blockquote><p>Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点中的线程。<h4 id=知识扩展><a class=headerlink href=#知识扩展 title=知识扩展></a>知识扩展</h4><p><strong>为什么wait()、notyfy()、notifyAll()要放在同步块中？</strong><ol><li>调用wait()就是释放锁，释放锁的前提必须要先获得锁，先获得锁才能释放锁。<li>notify()、notifyAll()是将锁交给调用wait()方法的线程，让其继续执行下去，如果自身没有锁，怎么叫把锁交给其他线程呢；（本质是让处于入口队列的线程竞争锁）。</ol><h3 id=5-8-3、AQS（CLH）><a class=headerlink href=#5-8-3、AQS（CLH） title=5.8.3、AQS（CLH）></a>5.8.3、AQS（CLH）</h3><h4 id=简介-8><a class=headerlink href=#简介-8 title=简介></a>简介</h4><p><strong>AQS（Abstract Queued Synchronizer）：简称抽象队列同步器。</strong><p>CLH（Craig Landin and Hagersten locks）：是一种基于链表的可扩展、高性能、公平的自旋锁，能确保无饥饿性、公平性。申请线程只在本地变量上自旋，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。<h4 id=底层实现-2><a class=headerlink href=#底层实现-2 title=底层实现></a>底层实现</h4><p><strong>基于volatile + CAS + 队列来实现。</strong><h5 id=同步队列><a class=headerlink href=#同步队列 title=同步队列></a>同步队列</h5><p><strong>同步器依赖内部的 同步队列（FIFO双向队列）来完成同步状态管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node），然后基于CAS的方式放入到同步队列尾部，同时会阻塞当前线程，当同步队列首节点释放同步状态时，会唤醒后继节点来获取同步状态，后继节点获取同步状态成功后会将自己设置为首节点。</strong><p>同步队列中的节点（Node）保存的内容：<strong>获取同步状态失败的线程引用、等待状态以及前驱和后继节点。</strong><p>同步队列的基本结构如下图所示：<p><img alt=image-20200721002028762 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200721002028762.png?token=AIGEF3K7UBTFCK3VU76IGCTEZZY7U><p>同步器拥有首节点（head） 和尾节点（tail）。 当一个线程无法获取到同步状态时，会被构造成节点并放入到同步队列末尾。放入队列末尾的操作将通过调用CAS方法：<code>compareAndSetTail(Node expect,Node update)</code>来实现，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。 插入过程如图所示：<p><img alt=image-20200721002419902 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20200721002419902.png?token=AIGEF3KHSKMLNT7SRLOKJKTEZZZA2><p>同步队列遵循FIFO规则，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点来获取同步状态，而后继节点在获取同步状态成功时会将自己设置为首节点。<p>注意：<strong>由于只有一个线程能够成功获取到同步状态，因此设置头节点的操作并不需要通过CAS来保证。</strong><h5 id=等待队列><a class=headerlink href=#等待队列 title=等待队列></a>等待队列</h5><p><strong>等待队列是一个FIFO单向队列。线程A调用Condition.await()方法将会导致线程A释放锁并被构造成节点放入到等待队列末尾，同时线程A进入等待状态。</strong><p>等待队列基本结构如下图所示：<p><img alt=image-20200721004540435 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200721004540435.png?token=AIGEF3NQLSRDPSWZXDGZACLEZZZEI><p><strong>Object监视器模型中，一个对象拥有一个同步队列和等待队列，而并发包中的 Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列，</strong>其对应关系如图所示：<p><img alt=image-20200721004716947 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200721004716947.png?token=AIGEF3IGGKYM4Z4T7SDOZYDEZZZFK><h5 id=独占式获取与释放><a class=headerlink href=#独占式获取与释放 title=独占式获取与释放></a>独占式获取与释放</h5><p><strong>调用同步器的acquire(int arg)方法可以获取同步状态，该方法对中断不敏感。</strong><p>当前线程调用<code>acquireQueued(final Node node,int arg)</code>方法会在“死循环”中尝试获取同步状态，而只有前驱节点是头节点才能够尝试获取同步状态，这是为什么？原因有两个：<ol><li>头节点是成功获取到同步状态的节点，头节点中的线程释放同步状态后会唤醒后继节点来获取同步状态，后继节点中的线程被唤醒后还需要检查自己的前驱节点是否是头节点。<li>维护同步队列的FIFO原则。</ol><p><strong>调用同步器的<code>release(int arg)</code>方法会释放同步状态，释放同步状态后会唤醒后继节点来尝试获取同步状态。</strong><h5 id=共享式获取与释放><a class=headerlink href=#共享式获取与释放 title=共享式获取与释放></a>共享式获取与释放</h5><p>共享式获取与独占式获取最主要的区别在于：<strong>同一时刻能否有多个线程同时获取到同步状态。</strong><p><strong>通过调用同步器的acquireShared(int arg)方法可以共享式获取同步状态。</strong>共享式成功获取到同步状态并退出自旋的条件是<code>tryAcquireShared(int arg)</code>方法返回值大于等于0。其具体过程：如果当前节点的前驱节点是头节点，则尝试获取同步状态，返回值大于等于0时标志着获取同步状态成功并从自旋过程中退出。<p>与独占式一样，共享式获取也需要释放同步状态，<strong>通过调用releaseShared(int arg)方法可以释放同步状态。</strong><h3 id=5-8-4、Unsafe><a class=headerlink href=#5-8-4、Unsafe title=5.8.4、Unsafe></a>5.8.4、Unsafe</h3><h4 id=简介-9><a class=headerlink href=#简介-9 title=简介></a>简介</h4><ol><li>主要用来操作JVM中的内存。<li>直接操作内存：allocateMemory、putXX、freeMemory、pageSize<li>直接生成实例：allocateInstance。<li>直接操作类或实例变量：objectFieldOffset、getInt、getObject。<li>CAS相关：weakCompareAndSetObject / int / Long。<li>Unsafe相当于C/C++中的指针。</ol><blockquote><p>注意：<strong>C分配/释放内存使用malloc/free，C++分配/释放内存使用new/delete。</strong></blockquote><h4 id=使用实例><a class=headerlink href=#使用实例 title=使用实例></a>使用实例</h4><p>Atomicinteger：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=type>int</span> <span class="title function_">incrementAndGet</span><span class=params>()</span> {</span><br><span class=line>    <span class=keyword>for</span> (;;) {</span><br><span class=line>    	<span class=type>int</span> <span class=variable>current</span> <span class=operator>=</span> get();</span><br><span class=line>    	<span class=type>int</span> <span class=variable>next</span> <span class=operator>=</span> current + <span class=number>1</span>;</span><br><span class=line>    	<span class=keyword>if</span> (compareAndSet(current, next))</span><br><span class=line>    	<span class=keyword>return</span> next;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=type>boolean</span> <span class="title function_">compareAndSet</span><span class=params>(<span class=type>int</span> expect, <span class=type>int</span> update)</span> {</span><br><span class=line>	<span class=keyword>return</span> unsafe.compareAndSwapInt(<span class=built_in>this</span>, valueOffset, expect, update);</span><br><span class=line>}</span><br></pre></table></figure><p>Unsafe:<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>native</span> <span class=type>boolean</span> <span class="title function_">compareAndSwapInt</span><span class=params>(Object var1, <span class=type>long</span> var2, <span class=type>int</span> var4, <span class=type>int</span> var5)</span>;</span><br></pre></table></figure><p>运用：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> sun.misc.Unsafe;</span><br><span class=line><span class=keyword>import</span> java.lang.reflect.Field;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">T02_TestUnsafe</span> {</span><br><span class=line>    <span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>T02_TestUnsafe</span> <span class=variable>t</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">T02_TestUnsafe</span>();</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=comment>//Unsafe unsafe = Unsafe.getUnsafe();</span></span><br><span class=line></span><br><span class=line>        <span class=type>Field</span> <span class=variable>unsafeField</span> <span class=operator>=</span> Unsafe.class.getDeclaredFields()[<span class=number>0</span>];</span><br><span class=line>        unsafeField.setAccessible(<span class=literal>true</span>);</span><br><span class=line>        <span class=type>Unsafe</span> <span class=variable>unsafe</span> <span class=operator>=</span> (Unsafe) unsafeField.get(<span class=literal>null</span>);</span><br><span class=line></span><br><span class=line>        <span class=type>Field</span> <span class=variable>f</span> <span class=operator>=</span> T02_TestUnsafe.class.getDeclaredField(<span class=string>"i"</span>);</span><br><span class=line>        <span class=type>long</span> <span class=variable>offset</span> <span class=operator>=</span> unsafe.objectFieldOffset(f);</span><br><span class=line>        System.out.println(offset);</span><br><span class=line></span><br><span class=line>        <span class=type>boolean</span> <span class=variable>success</span> <span class=operator>=</span> unsafe.compareAndSwapInt(t, offset, <span class=number>0</span>, <span class=number>1</span>);</span><br><span class=line>        System.out.println(success);</span><br><span class=line>        System.out.println(t.i);</span><br><span class=line>        <span class=comment>//unsafe.compareAndSwapInt()</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>jdk8u: unsafe.cpp:<p>cmpxchg = compare and exchange<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=built_in>UNSAFE_ENTRY</span>(jboolean, <span class=built_in>Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class=line>  <span class=built_in>UnsafeWrapper</span>(<span class=string>"Unsafe_CompareAndSwapInt"</span>);</span><br><span class=line>  oop p = JNIHandles::<span class=built_in>resolve</span>(obj);</span><br><span class=line>  jint* addr = (jint *) <span class=built_in>index_oop_from_field_offset_long</span>(p, offset);</span><br><span class=line>  <span class=keyword>return</span> (jint)(Atomic::<span class=built_in>cmpxchg</span>(x, addr, e)) == e;</span><br><span class=line>UNSAFE_END</span><br></pre></table></figure><p>jdk8u: atomic_linux_x86.inline.hpp<p>is_MP = Multi Processor<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=function><span class=keyword>inline</span> jint <span class=title>Atomic::cmpxchg</span><span class=params>(jint exchange_value, <span class=keyword>volatile</span> jint*dest, jint compare_value)</span> </span>{</span><br><span class=line>  <span class=type>int</span> mp = os::<span class=built_in>is_MP</span>();</span><br><span class=line>  <span class=function>__asm__ <span class=title>volatile</span> <span class=params>(LOCK_IF_MP(%<span class=number>4</span>) <span class=string>"cmpxchgl %1,(%3)"</span></span></span></span><br><span class=line><span class=params><span class=function>                    : <span class=string>"=a"</span> (exchange_value)</span></span></span><br><span class=line><span class=params><span class=function>                    : <span class=string>"r"</span> (exchange_value), <span class=string>"a"</span> (compare_value), <span class=string>"r"</span> (dest), <span class=string>"r"</span> (mp)</span></span></span><br><span class=line><span class=params><span class=function>                    : <span class=string>"cc"</span>, <span class=string>"memory"</span>)</span></span>;</span><br><span class=line>  <span class=keyword>return</span> exchange_value;</span><br><span class=line>}</span><br></pre></table></figure><p>jdk8u: os.hpp is_MP()<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=function><span class=type>static</span> <span class=keyword>inline</span> <span class=type>bool</span> <span class=title>is_MP</span><span class=params>()</span> </span>{</span><br><span class=line>  <span class=comment>// During bootstrap if _processor_count is not yet initialized</span></span><br><span class=line>  <span class=comment>// we claim to be MP as that is safest. If any platform has a</span></span><br><span class=line>  <span class=comment>// stub generator that might be triggered in this phase and for</span></span><br><span class=line>  <span class=comment>// which being declared MP when in fact not, is a problem - then</span></span><br><span class=line>  <span class=comment>// the bootstrap routine for the stub generator needs to check</span></span><br><span class=line>  <span class=comment>// the processor count directly and leave the bootstrap routine</span></span><br><span class=line>  <span class=comment>// in place until called after initialization has ocurred.</span></span><br><span class=line>  <span class=keyword>return</span> (_processor_count != <span class=number>1</span>) || AssumeMP;</span><br><span class=line>}</span><br></pre></table></figure><p>jdk8u: atomic_linux_x86.inline.hpp<figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=meta>#<span class=keyword>define</span> LOCK_IF_MP(mp) <span class=string>"cmp $0, "</span> #mp <span class=string>"; je 1f; lock; 1: "</span></span></span><br></pre></table></figure><p>最终实现：cmpxchg = cas修改变量值<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>lock cmpxchg 指令</span><br></pre></table></figure><p>硬件：lock指令在执行后面指令的时候锁定一个北桥信号（不采用锁总线的方式）。<h1 id=6、Java线程池><a class=headerlink href=#6、Java线程池 title=6、Java线程池></a>6、Java线程池</h1><h2 id=6-1、认识线程池><a class=headerlink href=#6-1、认识线程池 title=6.1、认识线程池></a>6.1、认识线程池</h2><h3 id=6-1-1、线程池优点><a class=headerlink href=#6-1-1、线程池优点 title=6.1.1、线程池优点></a>6.1.1、线程池优点</h3><p>合理地使用线程池能够带来3个好处：<ol><li>降低资源消耗。<li>提高响应速度。<li>提高线程的可管理性。</ol><h3 id=6-1-2、提交任务><a class=headerlink href=#6-1-2、提交任务 title=6.1.2、提交任务></a>6.1.2、提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。<p>两者区别如下：<ol><li>execute方法没有返回值，submit方法有返回值；<li>execute方法会抛出异常，submit方法不会抛出异常，但可通过Future.get方法打印异常；<li>execute方法入参为Runnable，submit方法入参可以是Runnable，也可以是Callable；</ol><h3 id=6-1-3、执行任务><a class=headerlink href=#6-1-3、执行任务 title=6.1.3、执行任务></a>6.1.3、执行任务</h3><p>当提交一个新任务到线程池时，线程池的处理流程如下。<ol><li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。<li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。<li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</ol><h3 id=6-1-4、关闭线程池><a class=headerlink href=#6-1-4、关闭线程池 title=6.1.4、关闭线程池></a>6.1.4、关闭线程池</h3><p>调用线程池的shutdown或shutdownNow方法可以关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务 可能 永远无法终止。<p>shutdown和shutdownNow两者有区别：<ul><li><p><strong>shutdown</strong>：将线程池状态设置成SHUTDOWN状态，然后中断所有空闲线程。</p><li><p><strong>shutdownNow</strong>：先将线程池状态设置成STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。</p></ul><p>只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后才表示线程池关闭成功，这时调用isTerminaed方法会返回true。<h2 id=6-2、线程池实现><a class=headerlink href=#6-2、线程池实现 title=6.2、线程池实现></a>6.2、线程池实现</h2><h3 id=6-2-1、WorkStealingPool><a class=headerlink href=#6-2-1、WorkStealingPool title=6.2.1、WorkStealingPool></a>6.2.1、WorkStealingPool</h3><h4 id=简介-10><a class=headerlink href=#简介-10 title=简介></a>简介</h4><p><strong>WorkStealingPool是一种特殊线程池，核心很简单，和其它线程池的区别是：每一个线程都有自己单独的队列，任务会不断的插入到每一个线程对应的队列中，某个线程执行完自己队列中的任务后，会尝试从其它线程的队列中取出任务来执行，这个就是WorkStealingPool。</strong><h4 id=实现><a class=headerlink href=#实现 title=实现></a>实现</h4><p>本质上是一个ForkJoinPool。<h4 id=优缺点-1><a class=headerlink href=#优缺点-1 title=优缺点></a>优缺点</h4><p>针对通常意义上的线程池来说，如果某一个线程任务量非常庞大，一直占据着CPU，与此同时其它线程就算是闲着也不能去帮忙——无能为力；而WorkStealingPool就灵活了许多，遇到任务量庞大的线程，其它线程如果执行完了自己的任务后，可以帮忙执行这个任务量庞大的线程，提高了执行效率。<h3 id=6-2-2、ForkJoinPool><a class=headerlink href=#6-2-2、ForkJoinPool title=6.2.2、ForkJoinPool></a>6.2.2、ForkJoinPool</h3><h4 id=简介-11><a class=headerlink href=#简介-11 title=简介></a>简介</h4><p><strong>ForkJoinPool适合把大任务切分成一个个小任务去执行，如果觉得小任务还是太大，那就再切，切到满意为止。每一个小任务执行完成后需要进行汇总——小任务汇总到父任务，父任务最终汇总到根任务，最后得到最终期望的结果，这个汇总合并的过程叫join，故该线程池称为ForkJoinPool。</strong><p>Fork/Join默认会创建与CPU核数数量相同的线程池。<h4 id=注意事项-2><a class=headerlink href=#注意事项-2 title=注意事项></a>注意事项</h4><p>一般实现ForkJoinPool的时候需要定义为特定的类型——能进行切分的任务，故出现了该种类型的任务——ForkJoinTask。但ForkJoinTask太过于原始，我们可以使用RecursiveAction，其有两种形式：<ol><li>RecursiveAction递归：大任务可以切分成小任务，小任务还可以再切分成更小的任务，其隐含了一个递归过程，因此叫RecursiveAction递归，不带返回值。<li>从RecursiveTask继承，有返回值。</ol><h2 id=6-3、默认线程池><a class=headerlink href=#6-3、默认线程池 title=6.3、默认线程池></a>6.3、默认线程池</h2><p>Class Executors中提供了默认线程池创建API，不过最终还是会通过ThreadPoolExecutor去实现。<p>Executors常用线程池实现有：<ol><li>SingleThreadExecutor<li>CachedThreadPool<li>FixedThreadPool<li>ScheduledThreadPool</ol><h3 id=6-3-1、SingleThreadExecutor><a class=headerlink href=#6-3-1、SingleThreadExecutor title=6.3.1、SingleThreadExecutor></a>6.3.1、SingleThreadExecutor</h3><ul><li><p>简介：线程池中只有一个线程，一个线程的线程池可以保证扔进去的任务是顺序执行的。</p><li><p>特点（默认）：核心1，最大1，空闲0L，单位毫秒，队列LinkedBlockingQueue，工厂DefaultThreadFactory，拒绝策略AbortPolicy；</p><li><p>实例</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>ExecutorService</span> <span class=variable>service</span> <span class=operator>=</span> Executors.newSingleThreadExecutor();</span><br><span class=line><span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span><span class=number>0</span>; i < <span class=number>5</span>; i++){</span><br><span class=line>    <span class=keyword>final</span> <span class=type>int</span> <span class=variable>j</span> <span class=operator>=</span> i;</span><br><span class=line>    service.execute(() -> {</span><br><span class=line>        System.out.println(j + <span class=string>" "</span> + Thread.currentThread().getName());</span><br><span class=line>    });</span><br><span class=line>}</span><br></pre></table></figure></ul><h3 id=6-3-2、CachedThreadPool><a class=headerlink href=#6-3-2、CachedThreadPool title=6.3.2、CachedThreadPool></a>6.3.2、CachedThreadPool</h3><ul><li><p>简介：提交一个任务时，若线程池中没有线程则创建一个线程来执行该任务，若有则不创建。</p><li><p>特点（默认）：核心0，最大Integer.MAX_VALUE，空闲60，单位秒，队列SynchronousQueue(默认false非公平；fair ? new TransferQueue<e>() : new TransferStack<e>();)，工厂DefaultThreadFactory，拒绝策略AbortPolicy； <li><p>实例</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=type>ExecutorService</span> <span class=variable>service</span> <span class=operator>=</span> Executors.newCachedThreadPool();</span><br><span class=line>System.out.println(<span class=string>"1 service: "</span> + service);</span><br><span class=line><span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < <span class=number>2</span>; i++){</span><br><span class=line>    service.execute(() -> {</span><br><span class=line>        shhSleep(<span class=number>1</span>);</span><br><span class=line>        System.out.println(Thread.currentThread().getName());</span><br><span class=line>    });</span><br><span class=line>}</span><br><span class=line>System.out.println(<span class=string>"2 service: "</span> + service);</span><br><span class=line>shhSleep(<span class=number>3</span>);</span><br><span class=line>System.out.println(<span class=string>"3 service: "</span> + service);</span><br><span class=line></span><br><span class=line>---</span><br><span class=line></span><br><span class=line><span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">shhSleep</span><span class=params>(<span class=type>long</span> t)</span>{</span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        TimeUnit.SECONDS.sleep(t);</span><br><span class=line>    }<span class=keyword>catch</span> (InterruptedException e){</span><br><span class=line>        e.printStackTrace();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure></li> <h3 id=6-3-3、FixedThreadPool><a class=headerlink href=#6-3-3、FixedThreadPool title=6.3.3、FixedThreadPool></a>6.3.3、FixedThreadPool</h3><ul><li><p>简介：固定的线程数，核心线程数和最大线程数都一样，因此没有回收之说，故就指定为0。</p><li><p>特点（默认）：核心、最大显式指定且一样，空闲0，单位毫秒，队列LinkedBlockingQueue，工厂DefaultThreadFactory，拒绝策略AbortPolicy；</p><li><p>实例</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br></pre><td class=code><pre><span class=line><span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">FixedThreadPoolTest</span><span class=params>()</span>{</span><br><span class=line>    <span class=type>long</span> start, end;</span><br><span class=line>    <span class=keyword>final</span> <span class=type>int</span> <span class=variable>cpuCoreNum</span> <span class=operator>=</span> <span class=number>4</span>;</span><br><span class=line>    <span class=type>ExecutorService</span> <span class=variable>service</span> <span class=operator>=</span> Executors.newFixedThreadPool(cpuCoreNum);</span><br><span class=line>    <span class=type>Task</span> <span class=variable>task1</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Task</span>(<span class=number>1</span>, <span class=number>80000</span>);</span><br><span class=line>    <span class=type>Task</span> <span class=variable>task2</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Task</span>(<span class=number>80001</span>, <span class=number>130000</span>);</span><br><span class=line>    <span class=type>Task</span> <span class=variable>task3</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Task</span>(<span class=number>130001</span>, <span class=number>170000</span>);</span><br><span class=line>    <span class=type>Task</span> <span class=variable>task4</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Task</span>(<span class=number>170001</span>, <span class=number>200000</span>);</span><br><span class=line>    Future&LTList&LTInteger>> f1 = service.submit(task1);</span><br><span class=line>    Future&LTList&LTInteger>> f2 = service.submit(task2);</span><br><span class=line>    Future&LTList&LTInteger>> f3 = service.submit(task3);</span><br><span class=line>    Future&LTList&LTInteger>> f4 = service.submit(task4);</span><br><span class=line>    <span class=keyword>try</span>{</span><br><span class=line>        start = System.currentTimeMillis();</span><br><span class=line>        f1.get();</span><br><span class=line>        f2.get();</span><br><span class=line>        f3.get();</span><br><span class=line>        f4.get();</span><br><span class=line>        end = System.currentTimeMillis();</span><br><span class=line>        System.out.println(end - start);</span><br><span class=line>    }<span class=keyword>catch</span> (InterruptedException e){</span><br><span class=line>        e.printStackTrace();</span><br><span class=line>    }<span class=keyword>catch</span> (ExecutionException e){</span><br><span class=line>        e.printStackTrace();</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line>---</span><br><span class=line></span><br><span class=line><span class=keyword>static</span> <span class=keyword>class</span> <span class="title class_">Task</span> <span class=keyword>implements</span> <span class="title class_">Callable</span>&LTList&LTInteger>>{</span><br><span class=line>    <span class=type>int</span> startPos, endPos;</span><br><span class=line>    Task(<span class=type>int</span> s, <span class=type>int</span> e){</span><br><span class=line>        <span class=built_in>this</span>.startPos = s;</span><br><span class=line>        <span class=built_in>this</span>.endPos = e;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> List&LTInteger> <span class="title function_">call</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        List&LTInteger> r = getPrime(startPos, endPos);</span><br><span class=line>        <span class=keyword>return</span> r;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>static</span> <span class=type>boolean</span> <span class="title function_">isPrime</span><span class=params>(<span class=type>int</span> num)</span>{</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>2</span>; i < num/<span class=number>2</span>; i++){</span><br><span class=line>            <span class=keyword>if</span> (num % i == <span class=number>0</span>)</span><br><span class=line>                <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>static</span> List&LTInteger> <span class="title function_">getPrime</span><span class=params>(<span class=type>int</span> start, <span class=type>int</span> end)</span>{</span><br><span class=line>        List&LTInteger> results = <span class=keyword>new</span> <span class="title class_">ArrayList</span><>();</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> start; i <= end; i++){</span><br><span class=line>            <span class=keyword>if</span> (isPrime(i))</span><br><span class=line>                results.add(i);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> results;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure></ul> <h3 id=6-3-4、ScheduledThreadPool><a class=headerlink href=#6-3-4、ScheduledThreadPool title=6.3.4、ScheduledThreadPool></a>6.3.4、ScheduledThreadPool</h3><ul><li><p>简介：定时任务池，本质上还是ThreadPoolExecutor。</p><li><p>特点（默认）：核心指定，最大Integer.MAX_VALUE，空闲0，单位纳秒，队列DelayedWorkQueue，工厂DefaultThreadFactory，拒绝策略AbortPolicy；</p><li><p>实例</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">ScheduledThreadPoolTest</span><span class=params>()</span>{</span><br><span class=line>    <span class=type>ScheduledExecutorService</span> <span class=variable>service</span> <span class=operator>=</span> Executors.newScheduledThreadPool(<span class=number>4</span>);</span><br><span class=line>    service.scheduleAtFixedRate(() -> {</span><br><span class=line>        <span class=keyword>try</span>{</span><br><span class=line>            TimeUnit.MILLISECONDS.sleep(<span class=keyword>new</span> <span class="title class_">Random</span>().nextInt(<span class=number>1000</span>));</span><br><span class=line>        }<span class=keyword>catch</span> (InterruptedException e){</span><br><span class=line>            e.printStackTrace();</span><br><span class=line>        }</span><br><span class=line>        System.out.println(Thread.currentThread().getName());</span><br><span class=line>    }, <span class=number>0</span>, <span class=number>500</span>, TimeUnit.MILLISECONDS);</span><br><span class=line>}</span><br></pre></table></figure></ul> <h2 id=6-4、自定义线程池><a class=headerlink href=#6-4、自定义线程池 title=6.4、自定义线程池></a>6.4、自定义线程池</h2><h3 id=6-4-1、简介><a class=headerlink href=#6-4-1、简介 title=6.4.1、简介></a>6.4.1、简介</h3><p>自定义线程池可通过ThreadPoolExecutor来实现，其相关参数如下：</p> <ol><li><p>corePoolSize（核心线程数）</p><li><p>maximumPoolSize（最大线程数）</p><li><p>keepAliveTime（空闲时间）</p><li><p>TimeUnit unit（空闲时间单位）</p><li><p>BlockingQueue workQueue（阻塞队列）</p><li><p>ThreadFactory threadFactory（线程工厂）</p><li><p>RejectedExecutionHandler handler（拒绝策略）：拒绝策略有四种</p> <ol><li>AbortPolicy（默认）：抛异常RejectedExecutionException<li>DiscardPolicy：扔掉，不抛异常。<li>DiscardOldestPolicy：扔掉排队时间最久的。但是线程池如果关闭了，任务就会被丢弃。<li>CallerRunsPolicy：调用者来处理被拒绝的任务，比如主线程调用submit方法任务，但任务被拒绝，则主线程直接执行。但是线程池如果关闭了，任务就会被丢弃。</ol> <p>除此之外还可以自定义拒绝策略，方式为：实现接口<code>RejectedExecutionHandler</code>，并重写其<code>rejectedExecution(Runnable r, ThreadPoolExecutor executor)</code>方法。</p><li><p>boolean allowCoreThreadTimeOut：是否允许核心线程超时销毁，该参数不在构造函数中，但也极其重要。</p> <p><font color=orange>取值定义</font>：如果为false（默认），则表示即使处于空闲状态，核心线程也保持活动状态（不销毁）。如果为true，则核心线程使用keepAliveTime来超时等待工作（时间过后就销毁）。</p></ol> <h3 id=6-4-2、使用示例><a class=headerlink href=#6-4-2、使用示例 title=6.4.2、使用示例></a>6.4.2、使用示例</h3><p>拒绝策略使用示例：</p> <figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>ThreadPoolExecutor</span> <span class=variable>executor</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class=number>2</span>, <span class=number>4</span>, <span class=number>60</span>, TimeUnit.SECONDS, <span class=keyword>new</span> <span class="title class_">ArrayBlockingQueue</span><>(<span class=number>4</span>),Executors.defaultThreadFactory(),<span class=keyword>new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br></pre></table></figure> <h3 id=6-4-3、最合适的线程数量><a class=headerlink href=#6-4-3、最合适的线程数量 title=6.4.3、最合适的线程数量></a>6.4.3、最合适的线程数量</h3><h4 id=6-4-3-1、CPU密集型运算><a class=headerlink href=#6-4-3-1、CPU密集型运算 title=6.4.3.1、CPU密集型运算></a>6.4.3.1、CPU密集型运算</h4><p><strong>CPU密集型业务通常采用 cpu核数+1 的数量值作为合适的线程数量。</strong>这样可以实现最优的CPU利用率，加1是保证当线程由于页缺失或其它问题导致暂停时，额外的线程就能顶上去，保证CPU时钟周期不浪费。</p> <h4 id=6-4-3-2、IO密集型运算><a class=headerlink href=#6-4-3-2、IO密集型运算 title=6.4.3.2、IO密集型运算></a>6.4.3.2、IO密集型运算</h4><p>CPU不总是处于繁忙状态，例如，当执行业务计算时会使用CPU资源，但当执行IO操作、RPC远程调用、数据库操作时，CPU不会工作会空闲下来，此时可以利用多线程来提高CPU利用率。</p> <p>经验公式如下：<br>$$<br>线程数量 = 核数 * CPU期望利用率 * 总时间(CPU计算时间+等待时间) / CPU计算时间。<br>$$<br>例如：4核CPU计算时间50%，其它等待时间是50%，期望CPU被100%利用，则</p> <p>线程数量 = 4 * 100% * 100% / 50% = 8个。</p> <p>例如：4核 CPU计算时间10%，其它等待时间是90%，期望CPU被100%利用，则</p> <p>线程数量 = 4 * 100% * 100% / 10% = 40个。</p> <h2 id=6-5、线程池监控><a class=headerlink href=#6-5、线程池监控 title=6.5、线程池监控></a>6.5、线程池监控</h2><h3 id=6-5-1、简介><a class=headerlink href=#6-5-1、简介 title=6.5.1、简介></a>6.5.1、简介</h3><p><strong>如果在系统中大量使用线程池，则有必要对线程池进行监控</strong>，方便在出现问题时，可以根据线程池的使用状况快速定位问题。</p> <h3 id=6-5-2、监控方式><a class=headerlink href=#6-5-2、监控方式 title=6.5.2、监控方式></a>6.5.2、监控方式</h3><h4 id=参数监控><a class=headerlink href=#参数监控 title=参数监控></a>参数监控</h4><p><strong>可以通过线程池提供的参数进行监控</strong>，监控线程池时可以使用以下属性。</p> <ul><li>taskCount：线程池需要执行的任务数量。<li>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。<li>largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是 否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。<li>getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。<li>getActiveCount：获取活动的线程数。</ul> <h4 id=扩展监控><a class=headerlink href=#扩展监控 title=扩展监控></a>扩展监控</h4><p>通过扩展线程池进行监控。可以通过继承线程池来自定义线程池，重写线程池的 beforeExecute、afterExecute和terminated方法，也可以在任务执行前、执行后和线程池关闭前执 行一些代码来进行监控。</p> <p>例如，监控任务的平均执行时间、最大执行时间和最小执行时间等。 这几个方法在线程池里是空方法。</p> <h2 id=6-6、Executor框架><a class=headerlink href=#6-6、Executor框架 title=6.6、Executor框架></a>6.6、Executor框架</h2><h3 id=6-6-1、Executor类结构图><a class=headerlink href=#6-6-1、Executor类结构图 title=6.6.1、Executor类结构图></a>6.6.1、Executor类结构图</h3><p><img alt=Executor类结构图01 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/Executor%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE01.png?token=AIGEF3NWRCARP7IVE37JHV3EZZZKE></p> <h3 id=6-6-2、ThreadPoolExecutor源码解析（JDK8）><a class=headerlink href=#6-6-2、ThreadPoolExecutor源码解析（JDK8） title=6.6.2、ThreadPoolExecutor源码解析（JDK8）></a>6.6.2、ThreadPoolExecutor源码解析（JDK8）</h3><h4 id=addWorker><a class=headerlink href=#addWorker title=addWorker></a>addWorker</h4><p>addWorker的源码分两部分：</p> <ol><li>上面的嵌套for死循环，目的就是把worker数量加1。<ol><li>外层for循环：遍历检测状态值是否符合条件，如果状态值 >= shutdown，说明不符合条件，执行return false退出。<li>内层for循环：添加线程。先判断当前WC线程数量是否超过上限（数量 > 536870911或者 >= (corePoolSize /maximumPoolSize)），如果超过就不再添加，否则通过CAS方式进行添加。如果添加成功了，则执行break retr跳出双层循环，这说明第一步算是完成了；如果没有添加成功就继续AtomicInteger的get方法，然后跳到最外层循环处进行重新处理；</ol><li>创建一个Worker并执行这个Worker。</ol> <h4 id=execute><a class=headerlink href=#execute title=execute></a>execute</h4><ol><li><p>如果任务为null，则抛出异常。</p><li><p>工作线程数 是否小于 核心线程数，若小于则直接创建核心线程。否则将任务放入队列中。</p><li><p>如果线程池不是运行状态，或者任务进入队列失败了，则创建非核心线程执行任务。</p></ol> <p><font color=red>注意事项：</font></p> <ol><li>线程非运行状态时，addWorker内部会判断线程池状态。<li>addWorker的第二个参数表示是否创建核心线程。<li>addWorker返回false，说明任务执行失败，需要进行reject操作。</ol> <h4 id=runWorker><a class=headerlink href=#runWorker title=runWorker></a>runWorker</h4><p><strong>启动线程后会通过该方法去执行任务，期间需要加锁</strong>。</p> <ol><li><p>先执行Worker.unlock()方法来允许中断操作；变量boolean completedAbruptly 用于表示是否自旋。</p><li><p>自旋过程。如果firstTask不为null 或者 任务队列不为空，则从队列拿任务来执行，否则将 completedAbruptly设为false; 且最终执行processWorkerExit(w, completedAbruptly);</p> <p>从队列拿到任务后，执行任务的过程如下：</p> <ol><li>w.lock()加锁，任务执行的原子性。<li>如果线程池正在停止，则对当前线程进行中断操作。<li>执行任务的前后通过beforeExecute()、afterExecute()来扩展功能。但要注意这两个方法在该类中默认是空实现。<li>执行 completedAbruptly = false; 和 processWorkerExit(w, completedAbruptly);</ol></ol> <h3 id=6-6-3、ScheduledThreadPoolExecutor><a class=headerlink href=#6-6-3、ScheduledThreadPoolExecutor title=6.6.3、ScheduledThreadPoolExecutor></a>6.6.3、ScheduledThreadPoolExecutor</h3><h4 id=简介-12><a class=headerlink href=#简介-12 title=简介></a>简介</h4><p>继承自ThreadPoolExecutor，<strong>可在指定延迟之后运行任务，或者定期执行任务。</strong>其功能与Timer类似，但 ScheduledThreadPoolExecutor功能更强大、更灵活。Timer对应的是单个后台线程，而 ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。</p> <h4 id=运行机制><a class=headerlink href=#运行机制 title=运行机制></a>运行机制</h4><p>ScheduledThreadPoolExecutor的执行主要分为两大部分：</p> <ol><li>当调用ScheduledThreadPoolExecutor的scheduleAtFixedRate()方法或者scheduleWithFixedDelay()方法时，会向ScheduledThreadPoolExecutor的DelayQueue添加一个实现了 RunnableScheduledFutur接口的ScheduledFutureTask。<li>线程池中的线程从DelayQueue中获取ScheduledFutureTask，然后执行任务。</ol> <h4 id=底层实现-3><a class=headerlink href=#底层实现-3 title=底层实现></a>底层实现</h4><p>ScheduledThreadPoolExecutor会把待调度的任务（ScheduledFutureTask） 放到一个DelayQueue中。</p> <p>ScheduledFutureTask主要包含3个成员变量：</p> <ul><li>long型成员变量time，表示这个任务将要被执行的具体时间。<li>long型成员变量sequenceNumber，表示这个任务被添加到ScheduledThreadPoolExecutor中的序号。<li>long型成员变量period，表示任务执行的间隔周期。</ul> <h3 id=6-6-4、FutureTask><a class=headerlink href=#6-6-4、FutureTask title=6.6.4、FutureTask></a>6.6.4、FutureTask</h3><p>Future接口和实现Future接口的FutureTask类，代表异步计算的结果。</p> <h4 id=简介-13><a class=headerlink href=#简介-13 title=简介></a>简介</h4><p>FutureTask除了实现Future接口外，还实现了Runnable接口。因此，<strong>FutureTask可以交给 Executor执行，也可以由调用线程直接执行（FutureTask.run()）。</strong></p> <p>根据FutureTask.run()方法被执行的时机，FutureTask可处于3种状态：</p> <ul><li>未启动<ol><li>FutureTask.get()方法将导致调用线程阻塞；<li>FutureTask.cancel()方法将导致此任务永远不会被执行；</ol><li>已启动<ol><li>FutureTask.get()方法将导致调用线程阻塞；<li>FutureTask.cancel（true）方法将以中断执行此任务线程 的方式来试图停止任务；<li>FutureTask.cancel（false）方法将 不会对正在执行此任务的线程产生影响（让正在执行的任务运行完成）；</ol><li>已完成<ol><li>FutureTask.get()方法将导致调用线程立即返回结果或抛出异常；<li>FutureTask.cancel（…）方法将返回false。</ol></ul> <h4 id=底层实现-4><a class=headerlink href=#底层实现-4 title=底层实现></a>底层实现</h4><p>FutureTask的实现基于AbstractQueuedSynchronizer。</p> <p>AQS被作为“模板方法模式”的基础类提供给FutureTask的内部子类Sync，这个内部子类只需要实现状态检查和状态更新的方法即可，这些方法将控制FutureTask的获取和释放操作。具体来说，Sync实现了AQS的tryAcquireShared(int) 方法和 tryReleaseShared(int) 方法，Sync通过这两个方法来检查和更新同步状态。</p> <h2 id=6-7、总结><a class=headerlink href=#6-7、总结 title=6.7、总结></a>6.7、总结</h2><h3 id=6-7-1、建议使用ThreadPoolExecutor创建线程池？><a class=headerlink href=#6-7-1、建议使用ThreadPoolExecutor创建线程池？ title=6.7.1、建议使用ThreadPoolExecutor创建线程池？></a>6.7.1、建议使用ThreadPoolExecutor创建线程池？</h3><ol><li><p>Executors提供的线程池使用场景有限。</p><li><p>Executors底层还是调用ThreadPoolExecutor创建线程池。</p><li><p>OOM问题（阿里手册）</p> <ol><li><p>FixedThreadPool 和 SingleThreadPool</p> <p>两者允许的队列长度为Integer.MAX_VALUE，可能堆积大量请求，进而导致OOM。</p><li><p>CachedThreadPool</p> <p>允许创建的线程数量为Integer.MAX_VALUE，可能创建大量的线程，进而导致OOM。</p></ol></ol> <h3 id=6-7-2、生产中如何选择使用正确的队列？><a class=headerlink href=#6-7-2、生产中如何选择使用正确的队列？ title=6.7.2、生产中如何选择使用正确的队列？></a>6.7.2、生产中如何选择使用正确的队列？</h3><p>根据实际情况来选择：</p> <ol><li>高峰期的任务，建议使用LinkedBlockingQueue，这个是无界队列，不限制任务数量。<li>重要性较低的任务，建议使用ArrayBlockingQueue，这个队列需要指定大小，如果任务超出，会创建非核心线程执行任务。</ol> <h3 id=6-7-3、生产中如何保证线程池队列的可用性？><a class=headerlink href=#6-7-3、生产中如何保证线程池队列的可用性？ title=6.7.3、生产中如何保证线程池队列的可用性？></a>6.7.3、生产中如何保证线程池队列的可用性？</h3><ol><li>设计一个线程管理器，通过一个定时任务 定时检测 Map中线程池当前任务队列的状态，会设置一个报警阈值（waterThreshold - 水位线），超过该阈值就会报警，然后根据实际情况去应对。<li>线程池压测，如果发生超水位现象，就对线程按线程名做降级，动态调整核心线程数和队列，当然还有限流等保障。</ol> <h3 id=6-7-4、如何拆分线程池、核心任务数、队列大小呢？><a class=headerlink href=#6-7-4、如何拆分线程池、核心任务数、队列大小呢？ title=6.7.4、如何拆分线程池、核心任务数、队列大小呢？></a>6.7.4、如何拆分线程池、核心任务数、队列大小呢？</h3><ol><li><p>按照 任务类型 拆分任务，使用不同的线程池，分别命名。</p><li><p>区分 任务类型。其是 CPU密集型 还是 IO密集型，CPU密集型 可以设置 核心线程数为CPU核心数，上下文切换少；IO密集型则可以设置核心线程数大一点。</p><li><p>压测并估算，可以参考线程池变量largestPoolSize，它表示线程池达到过的最大线程任务。</p><li><p>设置核心线程数参考公式如下：</p> <p><strong>最佳线程数 = ((线程等待时间 + 线程CPU时间) / 线程CPU时间) * CPU数量;</strong></p></ol> <h1 id=7、高效存储工具><a class=headerlink href=#7、高效存储工具 title=7、高效存储工具></a>7、高效存储工具</h1><h2 id=7-1、Disruptor><a class=headerlink href=#7-1、Disruptor title=7.1、Disruptor></a>7.1、Disruptor</h2><h3 id=7-1-1、简介><a class=headerlink href=#7-1-1、简介 title=7.1.1、简介></a>7.1.1、简介</h3><p><strong>Disruptor是分裂、瓦解的意思。Disruptor是一个做金融、做股票的公司开发的，开源后受到广泛认可，2011年获得Duke奖。</strong>如果将之用作MQ的话，其是单机最快的MQ。该工具性能非常高，因为内部用了大量的CAS，另外把各种各样的性能开发到了极致。</p> <p><strong>Disruptor存储在内存中，简单理解就是内存中用于存储元素的一个高效队列。</strong></p> <p>Disruptor称为无锁的、高并发的、环形Buffer，直接覆盖旧数据，降低GC频率，用于生产者消费者模式。</p> <h3 id=7-1-2、核心及特点><a class=headerlink href=#7-1-2、核心及特点 title=7.1.2、核心及特点></a>7.1.2、核心及特点</h3><p><strong>Disruptor是一个环形队列、环形Buffer。</strong>Disruptor是用数组实现的一个队列，你也可以认为Disruptor就是用数组实现的ConcurrentArrayQueue，另外这个Queue是首尾相连。</p> <h3 id=7-1-3、实现原理><a class=headerlink href=#7-1-3、实现原理 title=7.1.3、实现原理></a>7.1.3、实现原理</h3><h4 id=Disruptor为啥快？><a class=headerlink href=#Disruptor为啥快？ title=Disruptor为啥快？></a>Disruptor为啥快？</h4><p>环形结构 只需维护 一个位置，就是sequence序列，该序列表示下一个元素在哪里，相当于只有一个指针在移动定位。位置可以通过数值与环形队列容量取模获得。</p> <p>由于采用覆盖方式，所以没有必要记录头指针和尾指针。我只需要一个指针就够用了，就这一点来说依然比ConcurrentLinkedQueue要快。</p> <h4 id=生产者装满数据后继续装会覆盖吗？><a class=headerlink href=#生产者装满数据后继续装会覆盖吗？ title=生产者装满数据后继续装会覆盖吗？></a>生产者装满数据后继续装会覆盖吗？</h4><p>不会覆盖的，因为有等待策略——生产者生产满了就要停止生产并进入等待状态。等待策略共有8种，详情见总结部分。</p> <h3 id=7-1-4、开发步骤><a class=headerlink href=#7-1-4、开发步骤 title=7.1.4、开发步骤></a>7.1.4、开发步骤</h3><p>开发步骤是比较固定的。</p> <ol><li>定义Event：队列中需要处理的元素。<li>定义Event工厂：用于填充队列。<li>定义EventHandle（消费者）：处理容器中的元素。</ol> <h3 id=7-1-5、入门案例><a class=headerlink href=#7-1-5、入门案例 title=7.1.5、入门案例></a>7.1.5、入门案例</h3><h4 id=OrderEvent-java><a class=headerlink href=#OrderEvent-java title=OrderEvent.java></a>OrderEvent.java</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">OrderEvent</span>{</span><br><span class=line>    <span class=keyword>private</span> <span class=type>long</span> value;</span><br><span class=line>    <span class=keyword>public</span> <span class=type>long</span> <span class="title function_">getValue</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> value;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setValue</span><span class=params>(<span class=type>long</span> value)</span> {</span><br><span class=line>        <span class=built_in>this</span>.value = value;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=OrderEventFactory-java><a class=headerlink href=#OrderEventFactory-java title=OrderEventFactory.java></a>OrderEventFactory.java</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">OrderEventFactory</span> <span class=keyword>implements</span> <span class="title class_">EventFactory</span>&LTOrderEvent> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> OrderEvent <span class="title function_">newInstance</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">OrderEvent</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=OrderEventHandler-java><a class=headerlink href=#OrderEventHandler-java title=OrderEventHandler.java></a>OrderEventHandler.java</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">OrderEventHandler</span> <span class=keyword>implements</span> <span class="title class_">EventHandler</span>&LTOrderEvent> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">onEvent</span><span class=params>(OrderEvent event, <span class=type>long</span> sequence, <span class=type>boolean</span> endOfBatch)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        System.out.println(<span class=string>"消费者："</span> + event.getValue());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=OrderEventProducer-java><a class=headerlink href=#OrderEventProducer-java title=OrderEventProducer.java></a>OrderEventProducer.java</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">OrderEventProducer</span> {</span><br><span class=line>    <span class=keyword>private</span> RingBuffer&LTOrderEvent> ringBuffer;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">OrderEventProducer</span><span class=params>(RingBuffer&LTOrderEvent> ringBuffer)</span> {</span><br><span class=line>        <span class=built_in>this</span>.ringBuffer = ringBuffer;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">sendData</span><span class=params>(ByteBuffer data)</span>{</span><br><span class=line>        <span class=type>long</span> <span class=variable>sequence</span> <span class=operator>=</span> ringBuffer.next();</span><br><span class=line>        <span class=keyword>try</span>{</span><br><span class=line>            <span class=comment>//1. 在生产者发送消息的时候，首先需要从ringBuffer里面获取一个可用的序号</span></span><br><span class=line>            <span class=comment>//2. 根据这个序号 找到具体的“orderEvent”元素 此时获取的OrderEvent是一个空的对象</span></span><br><span class=line>            <span class=type>OrderEvent</span> <span class=variable>event</span> <span class=operator>=</span> ringBuffer.get(sequence);</span><br><span class=line>            <span class=comment>//3 进行实际的赋值操作</span></span><br><span class=line>            event.setValue(data.getLong(<span class=number>0</span>));</span><br><span class=line>        }<span class=keyword>finally</span> {</span><br><span class=line>            <span class=comment>// 4 提交操作</span></span><br><span class=line>            ringBuffer.publish(sequence);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h4 id=App-java><a class=headerlink href=#App-java title=App.java></a>App.java</h4><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">App</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        <span class=type>OrderEventFactory</span> <span class=variable>orderEventFactory</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">OrderEventFactory</span>();</span><br><span class=line>        <span class=type>ExecutorService</span> <span class=variable>executor</span> <span class=operator>=</span> Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class=line>        <span class=type>int</span> <span class=variable>ringBufferSize</span> <span class=operator>=</span> <span class=number>1024</span> * <span class=number>1024</span>;</span><br><span class=line></span><br><span class=line>        <span class=comment>/**</span></span><br><span class=line><span class=comment>         *  1 eventFacotry 消息工厂对象</span></span><br><span class=line><span class=comment>         *  2 ringBufferSize 容器的长度</span></span><br><span class=line><span class=comment>         *  3 executor 线程池</span></span><br><span class=line><span class=comment>         *  4 ProducerType 生产者类型</span></span><br><span class=line><span class=comment>         *  5 waitStartegy 等待策略</span></span><br><span class=line><span class=comment>         */</span></span><br><span class=line>        <span class=comment>// 1 实例化一个disruptor的对象</span></span><br><span class=line>        Disruptor&LTOrderEvent> disruptor = <span class=keyword>new</span> <span class="title class_">Disruptor</span><>(orderEventFactory, ringBufferSize, executor, ProducerType.SINGLE, <span class=keyword>new</span> <span class="title class_">BlockingWaitStrategy</span>());</span><br><span class=line>        <span class=comment>// 2 添加消费者的监听(Disruptor 与消费者的一个关联关系)</span></span><br><span class=line>        disruptor.handleEventsWith(<span class=keyword>new</span> <span class="title class_">OrderEventHandler</span>());</span><br><span class=line>        <span class=comment>// 3 启动disruptor</span></span><br><span class=line>        disruptor.start();</span><br><span class=line></span><br><span class=line>        <span class=comment>// 4 获取实际存储数据的容器 RingBuffer</span></span><br><span class=line>        RingBuffer&LTOrderEvent> ringBuffer = disruptor.getRingBuffer();</span><br><span class=line>        <span class=type>OrderEventProducer</span> <span class=variable>producer</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">OrderEventProducer</span>(ringBuffer);</span><br><span class=line>        <span class=comment>// 生成一百个数 然后丢给producer</span></span><br><span class=line>        <span class=type>ByteBuffer</span> <span class=variable>bb</span> <span class=operator>=</span> ByteBuffer.allocate(<span class=number>8</span>);</span><br><span class=line>        <span class=keyword>for</span>(<span class=type>long</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < <span class=number>100</span>; i++){</span><br><span class=line>            bb.putLong(<span class=number>0</span>, i);</span><br><span class=line>            producer.sendData(bb);</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=comment>// 关闭disruptor和线程池</span></span><br><span class=line>        disruptor.shutdown();</span><br><span class=line>        executor.shutdown();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <h3 id=7-1-6、总结><a class=headerlink href=#7-1-6、总结 title=7.1.6、总结></a>7.1.6、总结</h3><h4 id=ProducerType（生产者线程模式）><a class=headerlink href=#ProducerType（生产者线程模式） title=ProducerType（生产者线程模式）></a>ProducerType（生产者线程模式）</h4><p><strong>ProducerType有两种模式：Producer.MULTI 和 Producer.SINGLE。默认为MULTI，表示在多线程模式下产生sequence。如果确定是单线程生产者，可以指定SINGLE，效率会有提升。</strong></p> <h4 id=等待策略（8种）><a class=headerlink href=#等待策略（8种） title=等待策略（8种）></a>等待策略（8种）</h4><ol><li>BlockingWaitStrategy（常用）：通过线程阻塞的方式，等待生产者被唤醒，唤醒后再次检查依赖的sequence是否已经消费。<li>BusySpinWaitStrategy：线程一直自旋等待，可能比较消耗CPU。<li>LiteBlockingWaitStrategy：线程阻塞等待生产者被唤醒。与第1个的区别是——如果两个线程同时访问一个waitfor，一个访问signalAll时，可以减少lock加锁次数。<li>LiteTimeoutBlockingWaitStrategy：与第3个相比，该策略设置了阻塞时间，超过时间后抛出异常。<li>PhasedBackoffWaitStrategy：根据时间参数和等待的策略来决定使用哪种等待策略。<li>TimeoutBlockingWaitStrategy：相对于第1个来说，该策略设置了等待时间，超过后抛出异常。<li>YieldingWatitStrategy（常用）：尝试100次，然后Thread.yield()让出CPU。<li>SleepingWaitStrategy（常用）：sleep。</ol> <h4 id=消费者异常处理><a class=headerlink href=#消费者异常处理 title=消费者异常处理></a>消费者异常处理</h4><ol><li>默认：disruptor.setDefaultExceptionHandler()；<li>覆盖：disruptor.handleExceptionFor().wait()；</ol> <h1 id=8、高效测试工具><a class=headerlink href=#8、高效测试工具 title=8、高效测试工具></a>8、高效测试工具</h1><h2 id=8-1、JMH><a class=headerlink href=#8-1、JMH title=8.1、JMH></a>8.1、JMH</h2><h4 id=8-1-1、简介><a class=headerlink href=#8-1-1、简介 title=8.1.1、简介></a>8.1.1、简介</h4><p><strong>JMH全程为 java Microbenchmark Harness，意为Java微基准测试。它测试的是一个方法的性能，换了一种实现后再次观察其性能好坏。</strong></p> <p><font color=red>注意：该测试框架于2013年由JLT人员开发而成，后来归到了OpenJDK下面。</font></p> <h4 id=8-1-2、JMH相关概念><a class=headerlink href=#8-1-2、JMH相关概念 title=8.1.2、JMH相关概念></a>8.1.2、JMH相关概念</h4><ol><li>Benchmark mode：基准测试的模式。<li>Warmup：预热，由于JVM会对特定代码进行优化，预热对于测试很重要。<li>Measurement：共执行多少次测试。<li>Timeout：超时时间。<li>Threads：线程数，由fork指定。<li>Benchmark：测试哪一段代码。</ol> <h3 id=8-1-3、使用示例><a class=headerlink href=#8-1-3、使用示例 title=8.1.3、使用示例></a>8.1.3、使用示例</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br><span class=line>98</span><br><span class=line>99</span><br><span class=line>100</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.Benchmark;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.BenchmarkMode;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.Mode;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.OutputTimeUnit;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.State;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.Scope;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.Setup;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.annotations.TearDown;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.runner.Runner;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class=line><span class=keyword>import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> java.util.ArrayList;</span><br><span class=line><span class=keyword>import</span> java.util.List;</span><br><span class=line><span class=keyword>import</span> java.util.Random;</span><br><span class=line><span class=keyword>import</span> java.util.concurrent.TimeUnit;</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * JMH工具测试</span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=meta>@State(Scope.Thread)</span></span><br><span class=line><span class=meta>@BenchmarkMode(Mode.AverageTime)</span>    <span class=comment>// 测试模式</span></span><br><span class=line><span class=meta>@OutputTimeUnit(TimeUnit.MILLISECONDS)</span>  <span class=comment>// 时间单位</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">JMHUseTest</span> {</span><br><span class=line>    <span class=keyword>private</span> List&LTInteger> list;</span><br><span class=line>    <span class=keyword>private</span> Random random;</span><br><span class=line></span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 测试前的初始化</span></span><br><span class=line><span class=comment>     *</span></span><br><span class=line><span class=comment>     * 初始化了一个由1000个随机整数组成的List</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=meta>@Setup</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setup</span><span class=params>()</span> {</span><br><span class=line>        list = <span class=keyword>new</span> <span class="title class_">ArrayList</span><>();</span><br><span class=line>        random = <span class=keyword>new</span> <span class="title class_">Random</span>();</span><br><span class=line>        <span class=keyword>for</span> (<span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> <span class=number>0</span>; i < <span class=number>1000</span>; i++) {</span><br><span class=line>            list.add(random.nextInt());</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 测试后的清理动作</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=meta>@TearDown</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">teardown</span><span class=params>()</span> {</span><br><span class=line>        list = <span class=literal>null</span>;</span><br><span class=line>        random = <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 排序</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=meta>@Benchmark</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testSort</span><span class=params>()</span> {</span><br><span class=line>        list.sort(Integer::compare);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 并行排序</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=meta>@Benchmark</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">testParallelSort</span><span class=params>()</span> {</span><br><span class=line>        list.parallelStream().sorted(Integer::compare).toArray();</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * 常用方法解析：</span></span><br><span class=line><span class=comment>     * - `include(String classNameRegex)`：指定要测试的类，可以使用正则表达式来匹配多个类。</span></span><br><span class=line><span class=comment>     * - `forks(int count)`：指定测试时进行的fork数量，即测试时重复运行基准测试的次数。</span></span><br><span class=line><span class=comment>     * - `warmupIterations(int count)`：指定预热迭代次数，即在测量迭代次数前进行的预热迭代次数。</span></span><br><span class=line><span class=comment>     * - `measurementIterations(int count)`：指定测量迭代次数，即每个基准测试运行的迭代次数。</span></span><br><span class=line><span class=comment>     * - `mode(Mode mode)`：指定测试模式，包括平均时间（AverageTime）、平均吞吐量（Througput）、平均延迟（SampleTime）等。</span></span><br><span class=line><span class=comment>     * - `timeUnit(TimeUnit unit)`：指定测试结果的时间单位，包括纳秒（NANOSECONDS）、微秒（MICROSECONDS）、毫秒（MILLISECONDS）等。</span></span><br><span class=line><span class=comment>     * - `threads(int count)`：指定测试时使用的线程数。</span></span><br><span class=line><span class=comment>     * - `verbosity(VerboseMode mode)`：指定测试结果的详细程度，包括默认（NORMAL）、详细（EXTRA）、极度详细（DEBUG）等。</span></span><br><span class=line><span class=comment>     * - `jvmArgs(String... args)`：指定测试时使用的Java虚拟机参数。</span></span><br><span class=line><span class=comment>     * - `addProfiler(Class&LT? extends Profiler> profilerClass)`：指定测试时使用的分析器.</span></span><br><span class=line><span class=comment>     * - `resultFormat(ResultFormatType type)`：指定测试结果的输出格式，包括文本（TEXT）、CSV、JSON等。</span></span><br><span class=line><span class=comment>     *</span></span><br><span class=line><span class=comment>     * 创建`Options`对象后，可以使用`Runner`类来运行基准测试。`Runner`类提供了多个方法来运行基准测试，如：</span></span><br><span class=line><span class=comment>     * - `run()`：运行基准测试并输出测试结果。</span></span><br><span class=line><span class=comment>     * - `runAsync()`：异步运行基准测试。</span></span><br><span class=line><span class=comment>     * - `runTo(TimeValue time)`：运行基准测试并在指定时间后停止。</span></span><br><span class=line><span class=comment>     * - `runTo(TimeValue time, TimeUnit timeUnit)`：运行基准测试并在指定时间后停止。</span></span><br><span class=line><span class=comment>     *</span></span><br><span class=line><span class=comment>     * <span class=doctag>@param</span> args</span></span><br><span class=line><span class=comment>     * <span class=doctag>@throws</span> RunnerException</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> RunnerException {</span><br><span class=line>        <span class=type>Options</span> <span class=variable>options</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">OptionsBuilder</span>()</span><br><span class=line>                .include(JMHUseTest.class.getSimpleName())</span><br><span class=line>                .forks(<span class=number>1</span>)   <span class=comment>// 运行基准测试的次数</span></span><br><span class=line>                .warmupIterations(<span class=number>1</span>)    <span class=comment>// 预热次数</span></span><br><span class=line>                .measurementIterations(<span class=number>3</span>)   <span class=comment>// 基准测试执行的次数</span></span><br><span class=line>                .build();</span><br><span class=line>        <span class=keyword>new</span> <span class="title class_">Runner</span>(options).run();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure> <footer class=post-footer><div class=post-eof></div></footer> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/%E5%AD%98%E5%82%A8%E5%99%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/%E5%AD%98%E5%82%A8%E5%99%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ itemprop=url>计算机系列-存储器</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-06 11:05:16" datetime=2023-10-06T11:05:16+08:00 itemprop=dateModified>2023-10-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/ itemprop=url rel=index><span itemprop=name>计算机</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、概述><a class=headerlink href=#1、概述 title=1、概述></a>1、概述</h1><p><strong>计算机的第二个主要部件就是存储器。</strong><p>理想情形下，存储器应该快、大 且便宜。但无法同时满足这三项，于是存储器系统采用一种分层结构，如下图所示。<p><img alt=存储管理-存储器分层结构图示 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86-%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%E5%9B%BE%E7%A4%BA.jpg?token=AIGEF3MKCMMKF6RE7JQNMQDEZZM4O><h1 id=2、存储分类><a class=headerlink href=#2、存储分类 title=2、存储分类></a>2、存储分类</h1><h2 id=2-1、寄存器><a class=headerlink href=#2-1、寄存器 title=2.1、寄存器></a>2.1、寄存器</h2><p><strong>存储器系统顶层一般说的是CPU中的寄存器。</strong><p>寄存器使用与CPU相同的材料制成，与CPU一样快。<p>寄存器存储容量在32位CPU中为32×32位，在64位CPU中为64×64位。在两种情形下，其存储容量都小于1 KB。程序必须在软件中自行管理这些寄存器（即决定如何使用它们）。<h2 id=2-2、高速缓存><a class=headerlink href=#2-2、高速缓存 title=2.2、高速缓存></a>2.2、高速缓存</h2><h3 id=2-2-1、简介><a class=headerlink href=#2-2-1、简介 title=2.2.1、简介></a>2.2.1、简介</h3><p><strong>高速缓存由硬件控制。高速缓存行大小通常为64个字节，地址0至63对应高速缓存行0，地址64至127对应高速缓存行1，以此类推。</strong><p>高速缓存行通常会放在CPU内部或接近CPU的高速缓存中。<h3 id=2-2-2、缓存命中><a class=headerlink href=#2-2-2、缓存命中 title=2.2.2、缓存命中></a>2.2.2、缓存命中</h3><p><strong>当程序需要读一个存储字时，高速缓存会检查自己的内存中是否存在需要的高速缓存行。如果存在，则称之为高速缓存命中。</strong><blockquote><p>高速缓存命中 通常需要两个时钟周期。<p>缓存满足了请求，就不需要通过总线把访问请求送往主存。高速缓存未命中就必须访问内存，这要消耗大量时间。</blockquote><h3 id=2-2-3、缓存功能><a class=headerlink href=#2-2-3、缓存功能 title=2.2.3、缓存功能></a>2.2.3、缓存功能</h3><p><strong>缓存通常可以提高性能。</strong><ol><li>在内存中保存频繁使用的文件，以避免从磁盘中重复调取这些文件。<li>长路径名转换成文件所在磁盘地址的结果，也可以放入缓存，以避免重复寻找地址。<li>一个Web页面（URL）地址 转换为 网络地址（IP地址）后，转换结果可以缓存起来以供将来使用。</ol><h3 id=2-2-4、L1-L2-L3><a class=headerlink href=#2-2-4、L1-L2-L3 title=2.2.4、L1/L2/L3></a>2.2.4、L1/L2/L3</h3><h4 id=2-2-4-1、简介><a class=headerlink href=#2-2-4-1、简介 title=2.2.4.1、简介></a>2.2.4.1、简介</h4><ul><li><p>L1：L1缓存在CPU内部，其使命通常是将已解码指令调入CPU执行引擎。对于频繁使用的数据字，大多芯片都会有第二个L1缓存。通常L1缓存大小为16KB。</p><li><p>L2：L2缓存 用来存放 最近所使用过若干兆字节 内存字。</p><li><p>L3：L3缓存 通常作为共享内存 来为所有CPU提供服务。</p></ul><h4 id=2-2-4-2、所属位置><a class=headerlink href=#2-2-4-2、所属位置 title=2.2.4.2、所属位置></a>2.2.4.2、所属位置</h4><p><img alt=存储管理-CPU中L1L2L3缓存的位置 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86-CPU%E4%B8%ADL1L2L3%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%8D%E7%BD%AE.jpg?token=AIGEF3JOEGZ6PAAZUO2QDT3EZZM66><p>L1缓存通常位于内核中。L2缓存所属位置通常有2种类型：<ul><li><p>所有核 共享L2缓存</p> <p>应用案例：Intel多核芯片采用了这个方法。</p> <p>缺点：共享L2缓存 依赖于复杂的缓存控制器。</p><li><p>所有核中 都存在L2缓存</p> <p>应用案例：AMD采用这个方法。</p> <p>缺点：很难设法保持L2缓存的一致性。</p></ul><p><strong>L3缓存位置通常在CPU外，L3缓存作为共享内存为所有CPU提供服务。</strong><h2 id=2-3、主存><a class=headerlink href=#2-3、主存 title=2.3、主存></a>2.3、主存</h2><h3 id=2-3-1、简介><a class=headerlink href=#2-3-1、简介 title=2.3.1、简介></a>2.3.1、简介</h3><p><strong>主存位于第五层，是存储系统的主力。主存通常称为随机访问存储器（Random Access Memory，RAM）。</strong><blockquote><p>过去有时称磁芯存储器，因为在20世纪50年代和60年代，通常使用很小的可磁化的铁磁体制作主存。</blockquote><h3 id=2-3-2、非易失性存储器><a class=headerlink href=#2-3-2、非易失性存储器 title=2.3.2、非易失性存储器></a>2.3.2、非易失性存储器</h3><p>除了主存之外，许多计算机已经在使用少量的非易失性随机访问存储器。它们与RAM不同，在电源切断之后，非易失性随机访问存储器并不丢失其内容。<p>只读存储器（Read Only Memory，ROM）在工厂中就被编程完毕，然后再也不能被修改。ROM速度快且便宜。<blockquote><p>个别计算机中，启动计算机 的引导加载模块 就存放在ROM中。另外，一些I/O卡也采用ROM处理底层设备控制。</blockquote><p>EEPROM（Electrically Erasable PROM，电可擦除可编程ROM）和闪存（flash memory）也是非易失性的，但与ROM相反的是它们可以擦除和重写。重写它们比写入RAM需要更多时间，所以其使用方式与ROM相同，而其与众不同的特点使它们有可能通过字段重写方式纠正所保存程序中的错误。<h3 id=2-3-3、易失性存储器><a class=headerlink href=#2-3-3、易失性存储器 title=2.3.3、易失性存储器></a>2.3.3、易失性存储器</h3><h4 id=2-3-3-1、简介><a class=headerlink href=#2-3-3-1、简介 title=2.3.3.1、简介></a>2.3.3.1、简介</h4><p><strong>CMOS是易失性存储器。</strong><p>CMOS存储器可以保存 当前时间和日期。CMOS存储器和递增时间的时钟电路由一块小电池驱动，所以，即使计算机没有上电，时间也仍然可以正确地更新。<p>CMOS存储器还可以保存配置参数，诸如，哪一个是启动磁盘等。<h4 id=2-3-3-2、CMOS优缺点><a class=headerlink href=#2-3-3-2、CMOS优缺点 title=2.3.3.2、CMOS优缺点></a>2.3.3.2、CMOS优缺点</h4><p>CMOS耗电量非常少，一块工厂原装电池能使用若干年。但当电池失效时计算机就会出现“Alzheimer病症”。<h2 id=2-4、磁盘><a class=headerlink href=#2-4、磁盘 title=2.4、磁盘></a>2.4、磁盘</h2><p><font color=red>详情内容请参考 【磁盘管理知识总结.md】文档。</font><h2 id=2-5、磁带><a class=headerlink href=#2-5、磁带 title=2.5、磁带></a>2.5、磁带</h2><h3 id=2-5-1、简介><a class=headerlink href=#2-5-1、简介 title=2.5.1、简介></a>2.5.1、简介</h3><p><strong>存储器体系最后一层是磁带。该种介质通常用于磁盘备份，且可保存大量数据集。</strong><p>访问磁带前要把磁带装到磁带机上，可人工安装也可机器安装（在大型数据库中通常安装有自动磁带处理设备）。磁带可能还需要向前绕转以便读取所请求的数据块。<h3 id=2-5-2、特点><a class=headerlink href=#2-5-2、特点 title=2.5.2、特点></a>2.5.2、特点</h3><p>磁带的每个二进制位成本极其便宜、可移动，为了在火灾、洪水、地震等灾害中能存活下来，离线存储的备份磁带非常重要。<h3 id=2-5-3、总结><a class=headerlink href=#2-5-3、总结 title=2.5.3、总结></a>2.5.3、总结</h3><p>上面说过存储器体系结构是典型的，但有的安装系统并不具备所有层次，或者有所差别（诸如光盘）。不过，在所有的系统中，当层次下降时，其随机访问时间 会 明显增加，容量也增加，而每个二进制位的成本则大幅度下降。</div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ itemprop=url>计算机系列-磁盘管理</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-06 10:54:18" datetime=2023-10-06T10:54:18+08:00 itemprop=dateModified>2023-10-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/ itemprop=url rel=index><span itemprop=name>计算机</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、磁盘存储><a class=headerlink href=#1、磁盘存储 title=1、磁盘存储></a>1、磁盘存储</h1><h2 id=1-1、磁盘存储简介><a class=headerlink href=#1-1、磁盘存储简介 title=1.1、磁盘存储简介></a>1.1、磁盘存储简介</h2><p><strong>为了提高计算机的IO性能，一般会通过一些容器将数据存储起来，这些容器我们称之为“磁盘”或“硬盘”。</strong><p>磁盘和硬盘 两者是有区别的，它们的区别如下：<ul><li>主体不同<ul><li>磁盘：利用 磁记录技术 存储数据的存储器；<li>硬盘：计算机主要存储设备；</ul><li>范围不同<ul><li>磁盘：计算机主要存储介质，包括软盘和硬盘；<li>硬盘：属于磁盘的一种，采用 温彻斯特式结构；</ul><li>发展不同<ul><li>磁盘：软盘已经被淘汰，磁盘也正在被固态硬盘所取代；<li>硬盘：发展成 固态硬盘与机械硬盘相结合；</ul></ul><h2 id=1-2、硬盘分类><a class=headerlink href=#1-2、硬盘分类 title=1.2、硬盘分类></a>1.2、硬盘分类</h2><h3 id=1-2-1、原理划分><a class=headerlink href=#1-2-1、原理划分 title=1.2.1、原理划分></a>1.2.1、原理划分</h3><p>按原理可将硬盘类型分为以下几种：<ul><li>机械硬盘（Hard Disk Drive，HDD）<li>固态硬盘（Solid State Disk，SSD）<li>固态混合硬盘（Solid State Hybrid Driver，SSHD）</ul><h4 id=1-2-1-1、机械硬盘（HDD）><a class=headerlink href=#1-2-1-1、机械硬盘（HDD） title=1.2.1.1、机械硬盘（HDD）></a>1.2.1.1、机械硬盘（HDD）</h4><p><strong>机械硬盘 是 传统硬盘，是电脑主要存储媒介之一。</strong>由一个或者多个铝制或玻璃制成的磁性碟片、磁头、转轴、控制电机、磁头控制器、数据转换器、接口和缓存等几个部分组成。机械硬盘 是集精密机械、微电子电路、电磁转换为一体 的电脑存储设备。<p>机械硬盘工作时，磁头悬浮在高速旋转的碟片上进行读写数据。<p>机械硬盘物理结构 如下图所示：<p><img alt=机械磁盘（HDD）物理结构02 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E6%9C%BA%E6%A2%B0%E7%A3%81%E7%9B%98%EF%BC%88HDD%EF%BC%89%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%8402.jpg?token=AIGEF3MH47FDUXPTESS2I3TEZZLSE><h4 id=1-2-1-2、固态硬盘（SSD）><a class=headerlink href=#1-2-1-2、固态硬盘（SSD） title=1.2.1.2、固态硬盘（SSD）></a>1.2.1.2、固态硬盘（SSD）</h4><p><strong>固态硬盘是由多个 闪存芯片、主控、缓存 组成的阵列存储，属于以 固态电子存储芯片阵列 制成的硬盘。</strong>相对机械硬盘，读取速度更快，寻道时间更少，可加快操作系统启动速度和软件启动速度。<p>固态硬盘物理结构 如下图所示：<p><img alt=固态硬盘（SSD）物理结构02 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%EF%BC%88SSD%EF%BC%89%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%8402.jpg?token=AIGEF3KSQDXRITM43CFV4B3EZZLV2><h4 id=1-2-1-3、混合硬盘（SSHD）><a class=headerlink href=#1-2-1-3、混合硬盘（SSHD） title=1.2.1.3、混合硬盘（SSHD）></a>1.2.1.3、混合硬盘（SSHD）</h4><p><strong>混合硬盘是 机械硬盘 与 固态硬盘 的结合体，采用 容量较小的闪存颗粒 来存储常用文件。</strong>磁盘是重要的存储介质，闪存仅起到了缓冲作用，将更多的常用文件保存到闪存内减小寻道时间，从而提升效率。<p>混合硬盘物理结构 如下图所示：<p><img alt=混合硬盘（SSHD）物理结构02 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E6%B7%B7%E5%90%88%E7%A1%AC%E7%9B%98%EF%BC%88SSHD%EF%BC%89%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%8402.jpg?token=AIGEF3KDVWN32JGEBFOYCX3EZZMLA><h3 id=1-2-2、接口划分><a class=headerlink href=#1-2-2、接口划分 title=1.2.2、接口划分></a>1.2.2、接口划分</h3><p>按接口可将硬盘类型分为以下几种：<ul><li>IDE：井口；<li>SATA：串口；<li>SCSI：SCSI 全称是 Small Computer System Interface，即 小型计算机系统接口；<li>SAS：SAS 全称是 Serial Attached SCSI，即 串行连接SCSI，是新一代SCSI技术<li>FC：光纤通道；</ul><h4 id=1-2-2-1、IDE><a class=headerlink href=#1-2-2-1、IDE title=1.2.2.1、IDE></a>1.2.2.1、IDE</h4><p>IDE 全称是 Integrated Drive Electronics，<strong>是指 控制器与盘体集成在一起的硬盘驱动器，是一种硬盘传输接口</strong>。另一种叫法是ATA，全称是 Advanced Technology Attachment，即相同的东西。<p><img alt=IDE src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/IDE.jpg?token=AIGEF3OXSS5DIDUQXPD2J73EZZMNQ><h4 id=1-2-2-2、SATA><a class=headerlink href=#1-2-2-2、SATA title=1.2.2.2、SATA></a>1.2.2.2、SATA</h4><p>SATA 全称是 Serial ATA，<strong>SATA口硬盘又叫串口硬盘，SATA以它串行的数据发送方式而得名</strong>。在数据传输过程中，数据线和信号线独立使用，并且传输的时钟频率保持独立，因此同PATA相比，SATA传输速率 可以 达到并行的30倍。可以说：SATA技术并非是PATA技术的改进，而是一种全新的总线架构。<p><img alt=SATA src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/SATA.jpg?token=AIGEF3MGUPQZDDSOLBEV4XLEZZMO6><h4 id=1-2-2-3、SCSI><a class=headerlink href=#1-2-2-3、SCSI title=1.2.2.3、SCSI></a>1.2.2.3、SCSI</h4><p>SCSI 全称是 Small Computer System Interface，它的出现<strong>主要是为了解决 IDE接口硬盘 转速太慢，传输速率太低 的问题</strong>。其实SCSI并不是专为硬盘设计，实际上它是一种【总线型接口】，独立于系统总线工作。<p><img alt=image-20230805091954853 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20230805091954853.png?token=AIGEF3MHJD7EHIGM5O5G4XDEZZMQ6><h4 id=1-2-2-4、SAS><a class=headerlink href=#1-2-2-4、SAS title=1.2.2.4、SAS></a>1.2.2.4、SAS</h4><p>SAS（Serial Attached SCSI）<strong>意为 串行连接SCSI，是新一代SCSI技术</strong>。与Serial ATA（SATA）硬盘相同，同样采用串行技术来获得更高的传输速度，并通过缩短连结线改善内部空间等。SAS是 并行SCSI接口 之后开发出的全新接口。其目的是改善存储系统的效能、可用性和扩充性，并且提升与SATA硬盘的兼容性。<p><strong>SAS接口技术可向下兼容SATA。具体来说，二者的兼容性主要体现在 物理层和协议层 的兼容。</strong><p><img alt=SAS src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/SAS.jpg?token=AIGEF3JMKUGI4VEYDTP2GELEZZMSK><h4 id=1-2-2-5、FC><a class=headerlink href=#1-2-2-5、FC title=1.2.2.5、FC></a>1.2.2.5、FC</h4><p>光纤通道的英文拼写是Fibre Channel，与SCIS接口一样，<strong>光纤通道最初是专门为网络系统设计</strong>，而并非是为磁盘设计。<strong>但随着存储系统对速度的需求和要求越来越高，后来才逐渐应用到硬盘系统中</strong>。<p>光纤通道硬盘 是为提高 多硬盘存储系统 速度和灵活性 而开发，它大大提高了多硬盘系统的通信速度。它以点对点(或是交换)的配置方式在系统之间采用了光缆连接。<p><font color=red>注意：硬盘本身不具备FC接口，而插硬盘的机柜上会带有FC接口，通过光纤与光纤交换机互联。</font><h1 id=2、硬盘结构><a class=headerlink href=#2、硬盘结构 title=2、硬盘结构></a>2、硬盘结构</h1><h2 id=2-1、机械硬盘><a class=headerlink href=#2-1、机械硬盘 title=2.1、机械硬盘></a>2.1、机械硬盘</h2><p>机械硬盘结构 主要由盘片、磁头、磁道、扇区、柱面等更部件组成。<h3 id=2-1-1、盘片与磁头><a class=headerlink href=#2-1-1、盘片与磁头 title=2.1.1、盘片与磁头></a>2.1.1、盘片与磁头</h3><p>硬盘一般会由多个盘片组成，每个盘片都有上下两个面，每个面都有一个读/写磁头。受到硬盘整体体积和生产成本的限制，<strong>盘片数量一般限制在5片以内</strong>。<p><strong>盘片的编号自下向上从0递增</strong>，例如 最下边的盘片有0面和1面，那么相邻的上一个盘片就是2面和3面，其它同理。<p>硬盘整体结构 如下图所示：<p><img alt=硬盘与整体结构 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E7%A1%AC%E7%9B%98%E4%B8%8E%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.jpg?token=AIGEF3MEJ4E262VSTOBQ27LEZZMUE><h3 id=2-1-2、扇区与磁道><a class=headerlink href=#2-1-2、扇区与磁道 title=2.1.2、扇区与磁道></a>2.1.2、扇区与磁道</h3><p>以下图为例，该图是一个盘面。盘面中一圈圈灰色同心圆就是 磁道。从圆心向外画直线，可以将磁道划分为若干个弧段，每个磁道上的一个弧段就是一个扇区（绿色填充部分）。<strong>扇区是磁盘的最小组成单元，通常是512字节。</strong>（如今由于磁盘容量越来越大，故每个扇区大小提高至4096字节）。<p>扇区与磁道 结构图 如下所示：<p><img alt=磁盘盘面结构图02 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E7%A3%81%E7%9B%98%E7%9B%98%E9%9D%A2%E7%BB%93%E6%9E%84%E5%9B%BE02.png?token=AIGEF3P4INJI6MLXKYMIUYTEZZMV4><h3 id=2-1-3、磁头和柱面><a class=headerlink href=#2-1-3、磁头和柱面 title=2.1.3、磁头和柱面></a>2.1.3、磁头和柱面</h3><p>硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。磁盘的柱面数与一个盘面上的磁道数是相等的。由于每个盘面都有自己的磁头，因此，盘面数 = 磁头总数。<p>磁盘与柱面 结构图 如下所示：<p><img alt=磁盘与柱面 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/%E7%A3%81%E7%9B%98%E4%B8%8E%E6%9F%B1%E9%9D%A2.jpg?token=AIGEF3MPEFYJXNZJKCV54DDEZZMXO><h3 id=2-1-4、磁盘容量计算><a class=headerlink href=#2-1-4、磁盘容量计算 title=2.1.4、磁盘容量计算></a>2.1.4、磁盘容量计算</h3><h4 id=2-1-4-1、计算公式><a class=headerlink href=#2-1-4-1、计算公式 title=2.1.4.1、计算公式></a>2.1.4.1、计算公式</h4><p>磁盘存储容量 可通过 如下公式 计算获得：<br>$$<br>磁盘存储容量 = 磁头数量 * 磁道(柱面)数量 * 每个磁道扇区数量 * 每个扇区字节数;<br>$$<h4 id=2-1-4-2、计算示例><a class=headerlink href=#2-1-4-2、计算示例 title=2.1.4.2、计算示例></a>2.1.4.2、计算示例</h4><p>环境：磁盘DISKA有 3个盘片、6个磁头、7个柱面，每个磁道有 12个扇区，每个扇区512字节。<p>磁盘DISKA的存储容量计算如下：<br>$$<br>DISKA存储容量 = 6 * 7 * 12 * 512 = 258048字节;<br>$$<h3 id=2-1-5、磁盘读取时间><a class=headerlink href=#2-1-5、磁盘读取时间 title=2.1.5、磁盘读取时间></a>2.1.5、磁盘读取时间</h3><p>磁盘读取涉及以下几个时间：<ul><li><p>寻道时间</p> <p>磁头从最初位置 移动到 数据所在位置所消耗的时间 称为 寻道时间。目前寻道时间一般在3－15ms之间。</p><li><p>旋转延迟</p> <p>将 请求盘片扇区中的数据 移动到 读写磁头下方 所消耗的时间 称为 旋转延迟。旋转延迟取决于磁盘转速，磁盘转速一般在5000rpm - 7200rpm之间。</p><li><p>数据传输时间</p> <p>传输完请求数据 所消耗的时间 称为 数据传输时间。</p></ul><p><strong>为提高磁盘传输效率，软件应着重考虑减少 寻道时间 和 延迟时间。</strong><h2 id=2-2、固态硬盘><a class=headerlink href=#2-2、固态硬盘 title=2.2、固态硬盘></a>2.2、固态硬盘</h2><h2 id=2-3、混合硬盘><a class=headerlink href=#2-3、混合硬盘 title=2.3、混合硬盘></a>2.3、混合硬盘</h2><h1 id=3、文件系统><a class=headerlink href=#3、文件系统 title=3、文件系统></a>3、文件系统</h1><h2 id=3-1、文件系统简介><a class=headerlink href=#3-1、文件系统简介 title=3.1、文件系统简介></a>3.1、文件系统简介</h2><h2 id=3-2、文件系统分类><a class=headerlink href=#3-2、文件系统分类 title=3.2、文件系统分类></a>3.2、文件系统分类</h2><h2 id=3-3、块与族><a class=headerlink href=#3-3、块与族 title=3.3、块与族></a>3.3、块与族</h2><h3 id=3-3-1、块><a class=headerlink href=#3-3-1、块 title=3.3.1、块></a>3.3.1、块</h3><p>扇区容量少且数量多，导致寻址较长，所以将 相邻的扇区组合在一起组成一个块，并以块为单位来执行相关操作。<p>Linux下，如Ext4等文件系统中称为块（block）。 操作系统与磁盘打交道的最小单位是磁盘块。<p>3.3.2、族<p>Windows下，如NTFS等文件系统中称为簇。每个簇或者块可以包括2、4、8、16、32、64…2的n次方个扇区。<h2 id=3-4、Page页><a class=headerlink href=#3-4、Page页 title=3.4、Page页></a>3.4、Page页</h2><h3 id=3-4-1、概述><a class=headerlink href=#3-4-1、概述 title=3.4.1、概述></a>3.4.1、概述</h3><p>操作系统常与内存和硬盘打交道，故以“页”为单位的内存操作模式就出现了。<p><strong>注意：内存操作最小单位是“页”，硬盘操作最小单位是“块”。</strong><h2 id=3-5、总结><a class=headerlink href=#3-5、总结 title=3.5、总结></a>3.5、总结</h2><h3 id=3-5-1、扇区、块-族、Page页之间的关系><a class=headerlink href=#3-5-1、扇区、块-族、Page页之间的关系 title=3.5.1、扇区、块/族、Page页之间的关系></a>3.5.1、扇区、块/族、Page页之间的关系</h3><ul><li>扇区：硬盘读写 最小单位；<li>块/族：操作系统 读写磁盘 的最小单位；<li>Page：操作系统 读写内存 的最小单位；</ul></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Zookeeper%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Zookeeper%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/ itemprop=url>Zookeeper系列-Zookeeper基础应用</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 17:38:21" datetime=2023-10-02T17:38:21+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Zookeeper/ itemprop=url rel=index><span itemprop=name>Zookeeper</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、概述><a class=headerlink href=#1、概述 title=1、概述></a>1、概述</h1><h2 id=1-1、何为Zookeeper><a class=headerlink href=#1-1、何为Zookeeper title=1.1、何为Zookeeper></a>1.1、何为Zookeeper</h2><p>官方文档解释：<strong>Zookeeper是一个分布式服务框架，是Apache Hadoop 的一个子项目，主要用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项管理等。</strong><p>简单来说，zookeeper = 文件系统 + 监听通知机制。<h2 id=1-2、使用场景><a class=headerlink href=#1-2、使用场景 title=1.2、使用场景></a>1.2、使用场景</h2><p><strong>zookeeper可实现 分布式应用配置管理、统一命名服务、状态同步服务、集群管理等功能。</strong><p>分布式系统中配置信息放入zookeeper中，所有系统都从zookeeper中读取配置信息。当配置信息修改后，<strong>通过 监听触发机制 通知每一个系统 重新读取最新配置。</strong><h2 id=1-3、文件系统架构><a class=headerlink href=#1-3、文件系统架构 title=1.3、文件系统架构></a>1.3、文件系统架构</h2><p>一个Zookeeper内部由一个根目录和多个子目录组成。每个子目录称为 znode，可以自由增加、删除znode，也可在znode中存储数据。<p>znode有四种类型：<ol><li><p><strong>PERSISTENT - 持久化目录节点</strong></p> <p>客户端与zookeeper断开连接后，该节点依旧存在。</p> <p>创建 持久目录节点 命令：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>create /tmp_zk01 data01</span><br></pre></table></figure><li><p><strong>PERSISTENT_SEQUENTIAL - 持久化 顺序编号 目录节点</strong></p> <p>客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号。</p> <p>创建 持久顺序目录节点 命令：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>create -s /tmp_zk01 data01 1</span><br></pre></table></figure> <ul><li>-s：SEQUENTIAL的简写，代表顺序节点。</ul><li><p><strong>EPHEMERAL-临时目录节点</strong></p> <p>客户端与zookeeper断开连接后，该节点被删除。</p> <p>创建 临时目录节点 命令：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>create -e /tmp_zk01 data01</span><br></pre></table></figure> <ul><li>-e：EPHEMERAL的简写，代表临时节点。</ul><li><p><strong>EPHEMERAL_SEQUENTIAL-临时 顺序编号 目录节点</strong></p> <p>客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号。</p> <p>创建 临时顺序目录节点 命令：</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>create -e -s /tmp_zk01 data01</span><br></pre></table></figure></ol><blockquote><p>顺序节点：创建znode时设置顺序标识，znode名称后会附加一个顺序号，顺序号是一个单调递增的计数器，由父节点维护。</blockquote><h2 id=1-4、监听通知机制><a class=headerlink href=#1-4、监听通知机制 title=1.4、监听通知机制></a>1.4、监听通知机制</h2><h3 id=1-4-1、监听机制简介><a class=headerlink href=#1-4-1、监听机制简介 title=1.4.1、监听机制简介></a>1.4.1、监听机制简介</h3><p>Watcher 监听机制是 Zookeeper 中非常重要的特性，节点可以绑定监听事件，比如可以监听<strong>节点数据变更、节点删除、子节点状态变更</strong>等事件，<strong>通过事件机制可以实现分布式锁、集群管理等功能。</strong><h3 id=1-4-2、watcher特性><a class=headerlink href=#1-4-2、watcher特性 title=1.4.2、watcher特性></a>1.4.2、watcher特性</h3><p><strong>当数据发生变化时会触发一个 watcher 事件 并通知客户端。但客户端只会收到一次通知，后续同一节点再次发生变化时客户端将不会再收到消息。不过可以通过循环监听 来达到 永久监听效果。</strong><h3 id=1-4-3、注册事件机制><a class=headerlink href=#1-4-3、注册事件机制 title=1.4.3、注册事件机制></a>1.4.3、注册事件机制</h3><p>ZooKeeper 的 Watcher 机制可分为三个过程：<ol><li>客户端注册 Watcher；<li>服务器处理 Watcher；<li>客户端回调 Watcher；</ol><p>注册 watcher 有 3 种方式：<ol><li><strong>getData</strong><li><strong>exists</strong><li><strong>getChildren</strong></ol><h3 id=1-4-4、watcher事件类型><a class=headerlink href=#1-4-4、watcher事件类型 title=1.4.4、watcher事件类型></a>1.4.4、watcher事件类型</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>None (-<span class=number>1</span>), 				  <span class=comment>// 客户端连接状态发生变化的时候 会收到none事件</span></span><br><span class=line>NodeCreated (<span class=number>1</span>), 		  <span class=comment>// 节点创建事件</span></span><br><span class=line>NodeDeleted (<span class=number>2</span>), 		  <span class=comment>// 节点删除事件</span></span><br><span class=line>NodeDataChanged (<span class=number>3</span>), 	   <span class=comment>// 节点数据变化</span></span><br><span class=line>NodeChildrenChanged (<span class=number>4</span>);   <span class=comment>// 子节点被创建，删除触发该事件</span></span><br></pre></table></figure><h1 id=3、Zookeeper单机安装><a class=headerlink href=#3、Zookeeper单机安装 title=3、Zookeeper单机安装></a>3、Zookeeper单机安装</h1><h2 id=3-1、zookeeper启动><a class=headerlink href=#3-1、zookeeper启动 title=3.1、zookeeper启动></a>3.1、zookeeper启动</h2><p>1、配置Java环境。<p>2、安装zookeeper。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># cd /usr/local</span></span><br><span class=line><span class=comment># wget http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz</span></span><br><span class=line><span class=comment># tar -zxvf zookeeper-3.4.12.tar.gz</span></span><br><span class=line><span class=comment># cd zookeeper-3.4.12</span></span><br></pre></table></figure><p>3、重命名配置文件zoo_sample.cfg。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=comment># cp conf/zoo_sample.cfg conf/zoo.cfg</span></span><br></pre></table></figure><p>4、启动zookeeper。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=comment># bin/zkServer.sh start</span></span><br></pre></table></figure><p>5、检测是否成功启动，用zookeeper客户端连接服务端。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=comment># bin/zkCli.sh</span></span><br></pre></table></figure><h2 id=3-2、zookeeper使用><a class=headerlink href=#3-2、zookeeper使用 title=3.2、zookeeper使用></a>3.2、zookeeper使用</h2><h3 id=3-2-1、客户端命令操作><a class=headerlink href=#3-2-1、客户端命令操作 title=3.2.1、客户端命令操作></a>3.2.1、客户端命令操作</h3><h4 id=3-2-1-1、ls命令><a class=headerlink href=#3-2-1-1、ls命令 title=3.2.1.1、ls命令></a>3.2.1.1、ls命令</h4><p>作用：查看某个路径下目录列表。<p>命令格式如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>ls</span> path</span><br></pre></table></figure><p>path代表路径，查看/runoob节点示例：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>ls</span> /runoob</span><br></pre></table></figure><h4 id=3-2-1-2、ls2命令><a class=headerlink href=#3-2-1-2、ls2命令 title=3.2.1.2、ls2命令></a>3.2.1.2、ls2命令</h4><p>作用：查看某个路径下的目录列表，它比ls命令列出更多信息。用法和<code>ls</code>命令相同。<h4 id=3-2-1-3、get命令><a class=headerlink href=#3-2-1-3、get命令 title=3.2.1.3、get命令></a>3.2.1.3、get命令</h4><p>作用：获取节点数据和状态信息。<p>命令格式及示例如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># 格式：</span></span><br><span class=line>get path [watch]</span><br><span class=line><span class=comment># 示例：</span></span><br><span class=line>get /runoob watch</span><br></pre></table></figure><ul><li>path：代表路径。<li>watch：对节点进行事件监听。</ul><h4 id=3-2-1-4、stat命令><a class=headerlink href=#3-2-1-4、stat命令 title=3.2.1.4、stat命令></a>3.2.1.4、stat命令</h4><p>作用：查看节点状态信息。<p>命令格式及示例如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># 格式：</span></span><br><span class=line><span class=built_in>stat</span> path [watch]</span><br><span class=line><span class=comment># 示例：</span></span><br><span class=line><span class=built_in>stat</span> /runoob</span><br></pre></table></figure><ul><li>path：代表路径。<li>watch：对节点进行事件监听。</ul><h4 id=3-2-1-5、create命令><a class=headerlink href=#3-2-1-5、create命令 title=3.2.1.5、create命令></a>3.2.1.5、create命令</h4><p>作用：创建节点并赋值。<p>命令格式及示例如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># 格式</span></span><br><span class=line>create [-s] [-e] path data acl</span><br><span class=line><span class=comment># 示例（添加临时顺序节点）</span></span><br><span class=line>create -s -e /runoob 0</span><br></pre></table></figure><ul><li>[-s] [-e]：两者都是可选项。-s代表顺序节点，-e代表临时节点，两者可同时使用，并且临时节点不能创建子节点。<li>path：指定要创建节点的路径。<li>data：要在此节点存储的数据。<li>acl：访问权限相关，默认是world，相当于全世界都能访问。</ul><h4 id=3-2-1-6、set命令><a class=headerlink href=#3-2-1-6、set命令 title=3.2.1.6、set命令></a>3.2.1.6、set命令</h4><p>作用：修改节点数据。<p>命令格式及示例如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment># 格式</span></span><br><span class=line><span class=built_in>set</span> path data [version]</span><br><span class=line><span class=comment># 示例（只有正确的版本号才能设置成功）</span></span><br><span class=line><span class=built_in>set</span> /runoob 0 1</span><br><span class=line><span class=built_in>set</span> /runoob 0 2</span><br><span class=line><span class=built_in>set</span> /runoob 0 10</span><br><span class=line><span class=built_in>set</span> /runoob 0 6</span><br></pre></table></figure><ul><li>path：节点路径。<li>data：要存储的数据。<li>[version]：可选项，版本号（可用于乐观锁）。</ul><h4 id=3-2-1-7、delete命令><a class=headerlink href=#3-2-1-7、delete命令 title=3.2.1.7、delete命令></a>3.2.1.7、delete命令</h4><p>作用：删除某节点。<p>命令格式及示例如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment># 格式</span></span><br><span class=line>delete path [version]</span><br><span class=line><span class=comment># 示例</span></span><br><span class=line><span class=built_in>ls</span> /runoob</span><br><span class=line>delete /runoob/child</span><br><span class=line>get /runoob/child</span><br></pre></table></figure><ul><li>path：节点路径。<li>[version]：可选项，版本号（同set命令）。</ul><h3 id=3-2-2、Java操作><a class=headerlink href=#3-2-2、Java操作 title=3.2.2、Java操作></a>3.2.2、Java操作</h3><p>1、加入Maven依赖<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>   <span class=tag><<span class=name>groupId</span>></span>org.apache.zookeeper<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>   <span class=tag><<span class=name>artifactId</span>></span>zookeeper<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>   <span class=tag><<span class=name>version</span>></span>3.4.12<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><p>2、添加一个目录节点<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>create /test demo01</span><br></pre></table></figure><p>3、启动两个zookeeper客户端程序<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> java.util.concurrent.CountDownLatch;</span><br><span class=line><span class=keyword>import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class=line><span class=keyword>import</span> org.apache.zookeeper.Watcher;</span><br><span class=line><span class=keyword>import</span> org.apache.zookeeper.Watcher.Event.EventType;</span><br><span class=line><span class=keyword>import</span> org.apache.zookeeper.Watcher.Event.KeeperState;</span><br><span class=line><span class=keyword>import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class=line><span class=keyword>import</span> org.apache.zookeeper.data.Stat;</span><br><span class=line> </span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ZooKeeperProSync</span> <span class=keyword>implements</span> <span class="title class_">Watcher</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>CountDownLatch</span> <span class=variable>connectedSemaphore</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">CountDownLatch</span>(<span class=number>1</span>);</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>ZooKeeper</span> <span class=variable>zk</span> <span class=operator>=</span> <span class=literal>null</span>;</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>Stat</span> <span class=variable>stat</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Stat</span>();</span><br><span class=line> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=comment>//zookeeper配置数据存放路径</span></span><br><span class=line>        <span class=type>String</span> <span class=variable>path</span> <span class=operator>=</span> <span class=string>"/username"</span>;</span><br><span class=line>        <span class=comment>//连接zookeeper并且注册一个默认的监听器</span></span><br><span class=line>        zk = <span class=keyword>new</span> <span class="title class_">ZooKeeper</span>(<span class=string>"192.168.31.100:2181"</span>, <span class=number>5000</span>, <span class=comment>//</span></span><br><span class=line>                <span class=keyword>new</span> <span class="title class_">ZooKeeperProSync</span>());</span><br><span class=line>        <span class=comment>//等待zk连接成功的通知</span></span><br><span class=line>        connectedSemaphore.await();</span><br><span class=line>        <span class=comment>//获取path目录节点的配置数据，并注册默认的监听器</span></span><br><span class=line>        System.out.println(<span class=keyword>new</span> <span class="title class_">String</span>(zk.getData(path, <span class=literal>true</span>, stat)));</span><br><span class=line> </span><br><span class=line>        Thread.sleep(Integer.MAX_VALUE);</span><br><span class=line>    }</span><br><span class=line> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">process</span><span class=params>(WatchedEvent event)</span> {</span><br><span class=line>        <span class=keyword>if</span> (KeeperState.SyncConnected == event.getState()) {  <span class=comment>//zk连接成功通知事件</span></span><br><span class=line>            <span class=keyword>if</span> (EventType.None == event.getType() && <span class=literal>null</span> == event.getPath()) {</span><br><span class=line>                connectedSemaphore.countDown();</span><br><span class=line>            } <span class=keyword>else</span> <span class=keyword>if</span> (event.getType() == EventType.NodeDataChanged) {  <span class=comment>//zk目录节点数据变化通知事件</span></span><br><span class=line>                <span class=keyword>try</span> {</span><br><span class=line>                    System.out.println(<span class=string>"配置已修改，新值为："</span> + <span class=keyword>new</span> <span class="title class_">String</span>(zk.getData(event.getPath(), <span class=literal>true</span>, stat)));</span><br><span class=line>                } <span class=keyword>catch</span> (Exception e) {</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>两个程序启动后都读到了<code>/test</code>目录节点下的数据<code>demo01</code>。<p>4、修改test节点下的数据。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>set</span> /test demo02</span><br></pre></table></figure><p>修改完成后，我们看见两个程序后台都及时收到了他们监听的目录节点数据变更后的值。<h1 id=4、数据类型><a class=headerlink href=#4、数据类型 title=4、数据类型></a>4、数据类型</h1><h2 id=4-1、数据结构><a class=headerlink href=#4-1、数据结构 title=4.1、数据结构></a>4.1、数据结构</h2><p><strong>zookeeper以 key/value 形式存储数据。</strong>整体结构类似于linux文件系统的模式以树形结构存储。其中根路径以<code>/</code>开头。<h2 id=4-2、znode状态属性><a class=headerlink href=#4-2、znode状态属性 title=4.2、znode状态属性></a>4.2、znode状态属性</h2><ol><li><font color=orange>ctime</font>：创建节点的时间。<li><font color=orange>mZxid</font>：最后修改节点时的事务ID。<li><font color=orange>mtime</font>：最后修改节点时的时间。<li><font color=orange>pZxid</font>：鄙视该节点的子节点列表最后以此修改的事务ID，添加子节点或删除子节点就会影响子节点列表，但是修改子节点的数据内容则不影响ID（注意，只有子节点列表变更了才会变更pzxid，子节点内容变更不会影响paxid）。<li><font color=orange>cversion</font>：子节点版本号，子节点每次修改时该版本号加1。<li><font color=orange>dataversion</font>：数据版本号，数据每次修改时该版本号加1，<li><font color=orange>aclversion</font>：权限版本号，权限每次修改时该版本号加1。<li><font color=orange>ephemeralOwner</font>：创建该临时节点的会话的sessionID。（如果该节点为持久节点，那么这个属性值为0。）<li><font color=orange>dataLength</font>：节点数据长度。<li><font color=orange>numChildren</font>：该节点拥有子节点数量。（只统计第一级子节点的数量）</ol><h1 id=5、zookeeper-session><a title="5、zookeeper session" class=headerlink href=#5、zookeeper-session></a>5、zookeeper session</h1><p><strong>客户端与服务端之间的连接是基于 TCP长连接，默认端口2181。第一次连接建立后，每个会话都可设置超时时间。</strong><h2 id=5-1、Session创建><a class=headerlink href=#5-1、Session创建 title=5.1、Session创建></a>5.1、Session创建</h2><ul><li><p>sessionID</p> <p>会话ID，用来唯一标识一个会话，每次客户端创建会话时，zookeeper都会为其分配一个全局唯一的sessionID。zookeeper创建sessionID类SessionTrackerImpl中的源码。</p><li><p>Timeout</p> <p>会话超时时间。客户端在构造Zookeeper实例时，向服务端发送配置的超时时间，server端会根据自己的超时时间限制最终确认会话的超时时间。</p><li><p>TickTime</p> <p>下次会话超时时间点，默认2000毫秒。可在zoo.cfg配置文件中进行配置，便于server端对session会话实行分桶策略管理。</p><li><p>isClosing</p> <p>该属性标记一个会话是否已经被关闭，当server端检测到会话已经超时失效，该会话标记为“已关闭”，不再处理该会话的新请求。</p></ul><h2 id=5-2、Session状态><a class=headerlink href=#5-2、Session状态 title=5.2、Session状态></a>5.2、Session状态</h2><ul><li><p>connecting</p> <p>连接中，session一旦建立，状态就是connecting状态，时间短。</p><li><p>connected</p> <p>已连接，连接成功之后的状态。</p><li><p>closed</p> <p>已关闭，session过期，因 网络故障 客户端重连失败，服务器宕机 或 客户端主动断开。</p></ul><h2 id=5-3、会话超时管理><a class=headerlink href=#5-3、会话超时管理 title=5.3、会话超时管理></a>5.3、会话超时管理</h2><p>zookeeper的 leader服务器 在运行期间会定时执行会话超时检查，时间间隔是<code>ExpirationInterval</code>，单位是毫秒，默认值为<code>tickTime</code>，每隔<code>tickTime</code>进行一次会话超时检查。<p><code>ExpirationTime</code>计算方式：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=attr>ExpirationTime</span> = <span class=string>CurrentTime + SessionTimeout;</span></span><br><span class=line><span class=attr>ExpirationTime</span> = <span class=string>(ExpirationTime / ExpirationInterval + 1) * ExpirationInterval;</span></span><br></pre></table></figure><p>客户端在会话超时前向服务器发送请求来完成 会话激活，进而保持会话有效性。<h1 id=6、Zookeeper四字命令><a class=headerlink href=#6、Zookeeper四字命令 title=6、Zookeeper四字命令></a>6、Zookeeper四字命令</h1><h2 id=6-1、简介><a class=headerlink href=#6-1、简介 title=6.1、简介></a>6.1、简介</h2><p><strong>在客户端可以通过<code>telnet</code>或<code>nc（netcat）</code>向 zookeeper 提交命令。</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># centos</span></span><br><span class=line>yum install nc</span><br><span class=line><span class=comment># ubuntu</span></span><br><span class=line><span class=built_in>sudo</span> apt install netcat</span><br></pre></table></figure><p><strong>四字命令格式：</strong><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>echo</span> [<span class=built_in>command</span>] | nc [ip] [port]</span><br></pre></table></figure><p><strong>常用四字命令如下：</strong><ol><li>conf：3.3.0版本引入，打印服务相关配置的详细信息。<li>cons：3.3.0版本引入，列出所有连接到这台服务器的客户端全部连接/会话详细信息。包括“接收/发送”的包数量、会话ID、操作延迟、最后的操作执行等信息。<li>crst：3.3.0版本引入。重置所有连接的连接和会话统计信息。<li>dump：列出那些比较重要的会话和临时节点。该命令只限于leader节点上使用。<li>envi：打印出服务环境的详细信息。<li>reqs：列出未经处理的请求。<li>ruok：测试服务是否处于正确状态。如果确实如此，那么服务返回“imok”，否则不做任何响应。<li>stat：输入关于性能和连接的客户端的列表。<li>srst：重置服务器的统计。<li>srvr：3.3.0版本引入。列出连接服务器的详细信息。<li>wchs：3.3.0版本引入。列出服务器watch的详细信息。<li>wchc：3.3.0版本引入。通过session列出服务器watch的详细信息，它的输出是一个与watch相关的会话的列表。<li>wchp：3.3.0版本引入。通过路径列出服务器watch的详细i信息。它输出一个与session相关的路径。<li>mntr：3.4.0版本引入，输出可用于检测集群健康状态的变量列表。</ol><h2 id=6-2、四字命令使用><a class=headerlink href=#6-2、四字命令使用 title=6.2、四字命令使用></a>6.2、四字命令使用</h2><h3 id=6-2-1、stat命令><a class=headerlink href=#6-2-1、stat命令 title=6.2.1、stat命令></a>6.2.1、stat命令</h3><p>查看zk状态信息。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>echo</span> <span class=built_in>stat</span> | nc 192.168.3.38 2181</span><br></pre></table></figure><h3 id=6-2-2、ruok命令><a class=headerlink href=#6-2-2、ruok命令 title=6.2.2、ruok命令></a>6.2.2、ruok命令</h3><p>查看zk是否启动，若返回imok表示正常。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>echo</span> ruok | nc 192.168.3.38 2181</span><br></pre></table></figure><h3 id=6-2-3、dump命令><a class=headerlink href=#6-2-3、dump命令 title=6.2.3、dump命令></a>6.2.3、dump命令</h3><p>列出未经处理的会话和临时节点。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>echo</span> dump | nc 192.168.3.38 2181</span><br></pre></table></figure><h3 id=6-2-4、conf命名><a class=headerlink href=#6-2-4、conf命名 title=6.2.4、conf命名></a>6.2.4、conf命名</h3><p>查看服务器配置。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>echo</span> conf | nc 192.168.3.38 2181</span><br></pre></table></figure><h3 id=6-2-5、cons命令><a class=headerlink href=#6-2-5、cons命令 title=6.2.5、cons命令></a>6.2.5、cons命令</h3><p>展示连接到服务器的客户端信息。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>echo</span> cons | nc 192.168.3.38 2181</span><br></pre></table></figure><h3 id=6-2-6、envi命令><a class=headerlink href=#6-2-6、envi命令 title=6.2.6、envi命令></a>6.2.6、envi命令</h3><p>查看环境变量。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>echo</span> envi | nc 192.168.3.38 2181</span><br></pre></table></figure><h1 id=7、Zookeeper安全管理><a class=headerlink href=#7、Zookeeper安全管理 title=7、Zookeeper安全管理></a>7、Zookeeper安全管理</h1><h2 id=7-1、安全简介><a class=headerlink href=#7-1、安全简介 title=7.1、安全简介></a>7.1、安全简介</h2><p><strong>ZooKeeper节点有5种操作权限：CREATE(增)、READ(查)、WRITE(改)、DELETE(删)、ADMIN(管理)等权限，这5种权限可以简写为crwda，每个单词的首字符拼接而成。</strong><h2 id=7-2、权限><a class=headerlink href=#7-2、权限 title=7.2、权限></a>7.2、权限</h2><p><strong>Zookeeper 权限由 scheme : id : permissions 三部分组成。</strong><p>Scheme可选项：<ul><li><strong>world</strong>：默认模式，所有客户端都拥有指定的权限。world 下只有一个 id 选项，就是 anyone，通常组合写法为 <code>world:anyone:[permissons]</code>；<li><strong>auth</strong>：只有经过认证的用户才拥有指定的权限。通常组合写法为 <code>auth:user:password:[permissons]</code>，使用这种模式时，你需要先进行登录，之后采用 auth 模式设置权限时，<code>user</code> 和 <code>password</code> 都将使用登录的用户名和密码；<li><strong>digest</strong>：只有经过认证的用户才拥有指定的权限。通常组合写法为 <code>auth:user:BASE64(SHA1(password)):[permissons]</code>，这种形式下的密码必须通过 SHA1 和 BASE64 进行双重加密；<li><strong>ip</strong>：限制只有特定 IP 的客户端才拥有指定的权限。通常组成写法为 <code>ip:182.168.0.168:[permissions]</code>；<li><strong>super</strong>：代表超级管理员，拥有所有的权限，需要修改 Zookeeper 启动脚本进行配置。</ul><p>Permissions可选项：<ul><li><strong>CREATE</strong>：允许创建子节点；<li><strong>READ</strong>：允许从节点获取数据并列出其子节点；<li><strong>WRITE</strong>：允许为节点设置数据；<li><strong>DELETE</strong>：允许删除子节点；<li><strong>ADMIN</strong>：允许为节点设置权限。</ul><h2 id=7-3、授权><a class=headerlink href=#7-3、授权 title=7.3、授权></a>7.3、授权</h2><h3 id=7-3-1、授权流程><a class=headerlink href=#7-3-1、授权流程 title=7.3.1、授权流程></a>7.3.1、授权流程</h3><p>操作流程分析如下：<p>1）添加授权用户。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>addauth digest smile:123456</span><br></pre></table></figure><p>2）创建节点。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>create /cicada cicada</span><br></pre></table></figure><p>3）节点授权。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>setAcl /cicada auth:smile:123456:cdrwa</span><br></pre></table></figure><p>4）查看授权。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>getAcl /cicada</span><br></pre></table></figure><h1 id=8、Zookeeper事件监听><a class=headerlink href=#8、Zookeeper事件监听 title=8、Zookeeper事件监听></a>8、Zookeeper事件监听</h1><h2 id=8-1、简介><a class=headerlink href=#8-1、简介 title=8.1、简介></a>8.1、简介</h2><p><strong>接口类<code>Watcher</code>表示一个事件处理器，定义了事件通知相关逻辑，包含<code>KeeperState</code>和<code>EventType</code>两个枚举类。</strong><p>Watcher接口定义了事件回调方法 <code>process(WatchedEvent event)</code>。定义一个Watcher实例很简单，代码如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=type>Watcher</span> <span class=variable>w</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Watcher</span>() {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">process</span><span class=params>(WatchedEvent watchedEvent)</span> {</span><br><span class=line>        log.info(<span class=string>"监听器watchedEvent："</span> + watchedEvent);</span><br><span class=line>    }</span><br><span class=line>};</span><br></pre></table></figure><p>使用Watcher监听器很简单，在Curator调用链上使用<code>usingWatcher</code>方法即可，代码如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>byte</span>[] content = client.getData().usingWatcher(w).forPath(workerPath);</span><br></pre></table></figure><h2 id=8-2、事件触发监听><a class=headerlink href=#8-2、事件触发监听 title=8.2、事件触发监听></a>8.2、事件触发监听</h2><h3 id=8-2-1、事件触发><a class=headerlink href=#8-2-1、事件触发 title=8.2.1、事件触发></a>8.2.1、事件触发</h3><h4 id=8-2-1-1、事件类型><a class=headerlink href=#8-2-1-1、事件类型 title=8.2.1.1、事件类型></a>8.2.1.1、事件类型</h4><ul><li>节点创建（NodeCreated）<li>节点删除（NodeDeleted）<li>节点数据变化（NodeDateChanged）<li>子节点变化（NodeChildrenChanged）</ul><h4 id=8-2-1-2、监听事件><a class=headerlink href=#8-2-1-2、监听事件 title=8.2.1.2、监听事件></a>8.2.1.2、监听事件</h4><p><font color=red>注意：事件监听是一次性的。</font><p>（1）监听节点创建、删除。<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=comment># 监听节点 /test，当节点 /test 创建或删除时会通知。</span></span><br><span class=line><span class=comment># java API：exists()</span></span><br><span class=line><span class=built_in>stat</span> -w /test</span><br></pre></table></figure><p>（2）监听节点数据变化<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=comment># 监听节点 /test 的数据变化，当节点 /test 的数据发生变化时会通知。</span></span><br><span class=line><span class=comment># java API：get()</span></span><br><span class=line>get -w /test</span><br></pre></table></figure><p>（3）监听子节点变化<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=comment># 监听节点 /test 的子节点是否发生变化，当节点 /test 的子节点发生变化时会通知。</span></span><br><span class=line><span class=comment># java API：getChildren()</span></span><br><span class=line><span class=built_in>ls</span> -w /test</span><br></pre></table></figure><h3 id=8-2-2、watcher机制><a class=headerlink href=#8-2-2、watcher机制 title=8.2.2、watcher机制></a>8.2.2、watcher机制</h3><p>zookeeper 的 watcher 机制，可分为四个过程：<ol><li><p>客户端注册 watcher；客户端注册watcher有3种方式：getData、exists、getCildren。</p><li><p>服务端处理 watcher；</p><li><p>服务端触发 watcher 事件；</p><li><p>客户端回调 watcher；</p></ol><p>以exists注册方式为例，客户端注册事件并触发事件通知的流程分析如下：<ol><li><p>客户端 发送 事件通知请求；</p> <p>调用 exists 方法会把事件监听封装到 request 对象中，watch 属性设置为 true，待服务端返回 response 后把监听事件封装到客户端类<code>ZKWatchManager</code>中。</p><li><p>服务端 处理 watcher事件请求；</p> <ol><li>服务端<code>NIOServerCnxn</code>类用来处理客户端请求，最终调用<code>FinalRequestProcessor</code>。<li>在类<code>DataTree</code>方法中添加 watcher 事件，并保存至<code>WatchManager</code>的<code>watchTable</code>与<code>watchTable</code>中。</ol><li><p>服务端 触发 watcher事件；</p> <ol><li>若服务端某个被监听的节点发生事务请求，服务端处理请求时调用<code>FinalRequestProcessor</code>类<code>processRequest</code>方法。<li>删除调用链最终到 DataTree 类中删除节点分支的触发代码段。<li>进入 WatchManager 类的 triggerWatch 方法。<li>构建了一个 xid 为 -1，zxid 为 -1 的 ReplyHeader 对象，然后再调用 sendResponse 方法。</ol><li><p>客户端 回调 watcher事件；</p> <p>客户端类<code>SendThread</code>的<code>readResponse</code>方法接收服务端触发的事件通知，进入 xid 为 -1 流程，处理 Event 事件。</p></ol></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Tomcat%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Tomcat%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/ itemprop=url>Tomcat系列-Tomcat原理解析</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-03 10:24:21" datetime=2023-10-03T10:24:21+08:00 itemprop=dateModified>2023-10-03</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Tomcat/ itemprop=url rel=index><span itemprop=name>Tomcat</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、启动初始化><a class=headerlink href=#1、启动初始化 title=1、启动初始化></a>1、启动初始化</h1><p><strong>入口是Connector.start()方法，但实际调用的是父类 LifecycleBase.start() 方法</strong>。<p><strong>（1）LifecycleBase.start()</strong><p>调用Connector.startInternal()方法来处理。<p><strong>（2）Connector.startInternal()</strong><p>调用AbstractProtocol.start()方法来处理。<p><strong>（3）AbstractProtocol.start()</strong><p>调用AbstractEndpoint.start()方法来处理。<p>使用ScheduledExecutorService开启一个延迟60秒调用一次AbstractProtocol.startAsyncTimeout()方法的线程。startAsyncTimeout()方法会判断当前Socket对应的web应用是否不再使用，如果不再使用那么进行超时处理。该方法会开启一个固定速率为1s执行一次的线程，该线程会遍历所有Processor，并对那些不再使用的web应用进行超时处理。<p><strong>（4）AbstractEndpoint.start()</strong><p>如果还没有绑定ip和端口，那么执行AbstractEndpoint.bindWithCleanup()方法，在该方法中一般会调用NioEndpoint.bind()方法进行绑定处理。调用NioEndpoint.startInternal()方法来初始化开启Acceptor、Poller线程等操作。<p><strong>（5）NioEndpoint.bind()</strong><p>调用NioEndpoint.initServerSocket()方法来初始化ServerSocket，设置该ServerSocket是阻塞式的。<p>为NioEndpoint创建一个CountDownLatch(2)。<p>如果开启了Ssl功能，那么初始化Ssl并进行相关操作。默认没有开启。<p><strong>（6）NioEndpoint.startInternal()</strong><p><strong>第一步：创建 Executor，初始化线程池</strong>。线程池默认参数值如下：<ul><li>最小线程数量：10。<li>最大线程数量：200。<li>超时时间：60秒。<li>队列：使用Tomcat重写的<code>TaskQueue</code>队列，该队列实现了<code>LinkedBlockingQueue</code>。<li>线程工厂：实现Tomcat重写的<code>TaskThreadFactory</code>。线程名字前缀是<code>http-nio-9001-exec-</code>，线程工厂生产的线程是守护线程，线程优先级是5。</ul><p><strong>第二步：初始化 LimitLatch 实例，设置其最大连接数量为 8192</strong>。<p><strong>第三步：创建 Poller 线程</strong>，线程名字是 <code>http-nio-9001-Poller</code>，线程优先级为5，是守护线程，然后启动该线程。<p><strong>第四步：调用 AbstractEndpoint.startAcceptorThread() 方法开启 Acceptor 线程</strong>。创建Acceptor线程，线程名字是<code>http-nio-9001-Acceptor</code>，线程优先级为5，是守护线程，然后启动该线程。<h1 id=2、HTTP请求处理><a class=headerlink href=#2、HTTP请求处理 title=2、HTTP请求处理></a>2、HTTP请求处理</h1><p>入口是<code>NioEndPoint.Poller.run()</code>方法。<p><strong>（1）NioEndPoint.Poller.events()</strong><p>从<code>Poller</code>的阻塞队列<code>SynchronizedQueue&LTPollerEvent></code>中不断获取<code>PollerEvent</code>，拿到<code>PollerEvent</code>中的<code>NioSocketWrapper</code>，将该<code>NioSocketWrapper</code>作为附件注册到<code>Poller</code>的<code>Selector</code>上，并设置要关注【读事件】。<p>调用selec()方法获取准备就绪的Socket，然后获取其selectedKey，并拿到该selectedKey上的附件NioSocketWrapper。将key和wrapper作为参数调用Poller的processKey方法来处理。<p><strong>（2）NioEndPoint.Poller.processKey()</strong><p>processKey方法会根据读事件或写事件调用AbstractEndpint的processSocket方法来处理，且将wrapper、事件类型等作为参数传给它。<p><strong>（3）AbstractEndpint.processSocket()</strong><p>processSocket方法会将wrapper、事件类型包装成实现了Runnable接口的SocketProcessorBase，然后调用线程池Executor的execute方法来执行该封装好的SocketProcessorBase，其实就是执行SocketProcessorBase的run()方法。<p><strong>（4）SocketProcessorBase.run()</strong><p><strong>run()方法中会先调用 ReentrantLock 的 lock 方法加锁，然后调用 NioEndpoint.SocketProcessor.doRun() 方法，最后再调用 unlock 方法解锁</strong>。<p><strong>（5）NioEndpoint.SocketProcessor.doRun()</strong><p>先处理三次握手，然后将Socket事件改为OPEN_READ。接下来调用AbstractProtoccol.ConnectionHandler.Process()方法来处理。<p><strong>（6）AbstractProtoccol.ConnectionHandler.process()</strong><p>调用AbstractProcessorLight.process()方法来处理。<p><strong>（7）AbstractProcessorLight.process()</strong><p>调用Http11Processor.service(socketWrapper)<p><strong>（8）Http11Processor.service(socketWrapper)</strong><p>调用CoyoteAdapter.service(request, response)方法来处理。<p><strong>（9）CoyoteAdapter.service(request, response)</strong><p>调用StandardEngineValue.invoke(request, response)方法来处理。<p><strong>（10）StandardEngineValue.invoke(request, response)</strong><p>调用ErrorReportValue.invoke(request, response)方法来处理。<p><strong>（11）ErrorReportValue.invoke(request, response)</strong><p>调用StandardHostValue.invoke(request, response)方法来处理<p><strong>（12）StandardHostValue.invoke(request, response)</strong><p>调用NonLoginAuthenticator.invoke(request, response)方法来处理，实际调用其父类AuthenticatorBase.invoke()方法来处理。<p><strong>（13）AuthenticatorBase.invoke(request, response)</strong><p>调用StandardContextValue.invoke(request, response)方法来处理。<p><strong>（14）StandardContextValue.invoke(request, response)</strong><p>调用StandardWrapperValue.invoke()(request, response)方法来处理<p><strong>（15）StandardWrapperValue.invoke()</strong><p>调用StandardWrapperd.allocate()方法来处理。<p>调用ApplicationFilterChain.doFilter(ServletRequest, ServletResponse)方法来处理。<p><strong>（16）StandardWrapperd.allocate()</strong><p>该方法内部会调用StandardWrapperd.initServlet(Servlet servlet)来初始化Servlet，如果使用SpringMVC，那么这里的servlet就是DispatcherServlet。该方法会调用GenericServlet.init()方法来初始化，然后内部再调用HttpServletBean.init()方法来初始化，然后内部再调用FrameworkServlet.initServletBean()方法来初始化，然后内部再调用initWebApplicationContext()方法来初始化Web容器。initWebApplicationContext()方法中会调用DispatcherServlet.initStrategies()方法来初始化9大组件，然后以<code>org.springframework.web.servlet.FrameworkServlet.CONTEXT.dispatcherServlet</code>为名字，以AnnotationConfigServletWebServerApplicationContext实例为值，将该键值对放入ApplicationContextFacade的Attribute中。<p><strong>（17）ApplicationFilterChain.doFilter(ServletRequest, ServletResponse)</strong><p>形参ServletRequest, ServletResponse其实是RequestFacade, ResponseFacade。<p>调用ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse)方法来处理。<p><strong>（18）ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse)</strong><p>形参ServletRequest, ServletResponse其实是RequestFacade, ResponseFacade。<p>调用OncePerRequestFilter.doFilter(ServletRequest, ServletResponse, this)<p><strong>（19）OncePerRequestFilter.doFilter(ServletRequest, ServletResponse, this)</strong><p>形参ServletRequest, ServletResponse其实是RequestFacade, ResponseFacade，this是ApplicationFilterChain。<p>调用CharacterEncodingFilter.doFilterInternal(HttpServletRequest, HttpServletResponse, FilterChain)方法来处理。<p><strong>（20）CharacterEncodingFilter.doFilterInternal(HttpServletRequest, HttpServletResponse, FilterChain)</strong><p>形参HttpServletRequest, HttpServletResponse其实是RequestFacade, ResponseFacade，FilterChain是ApplicationFilterChain。<p>为当前request设置字符集为UTF-8。<p>调用ApplicationFilterChain.doFilter(ServletRequest, ServletResponse)方法来处理。<p><strong>（21）ApplicationFilterChain.doFilter(ServletRequest, ServletResponse)</strong><p>调用ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse)方法来处理。<p><strong>（22）ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse)</strong><p>调用WsFilter.doFilter(ServletRequest, ServletResponse, FilterChain)方法来处理<p><strong>（23）WsFilter.doFilter(ServletRequest, ServletResponse, FilterChain)</strong><p>调用ApplicationFilterChain.doFilter(ServletRequest, ServletResponse)方法来处理。<p><strong>（24）ApplicationFilterChain.doFilter(ServletRequest, ServletResponse)</strong><p>调用ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse)方法来处理。<p><strong>（25）ApplicationFilterChain.internalDoFilter(ServletRequest, ServletResponse)</strong><p><em><strong>调用 HttpServlet.service(ServletRequest, ServletResponse) 方法来处理</strong></em>。<p><strong>（26）HttpServlet.service(ServletRequest, ServletResponse)</strong><p>调用FrameworkServlet.service(HttpServletRequest, HttpServletResponse)方法来处理。<p><strong>（27）FrameworkServlet.service(HttpServletRequest, HttpServletResponse)</strong><p>调用HttpServlet.service(HttpServletRequest, HttpServletResponse)方法来处理。<p><strong>（28）HttpServlet.service(HttpServletRequest, HttpServletResponse)</strong><p>调用FrameworkServlet.doXXX()方法，在方法内调用FrameworkServlet.processRequest(HttpServletRequest, HttpServletResponse)方法来处理。<p><strong>（29）FrameworkServlet.processRequest(HttpServletRequest, HttpServletResponse)</strong><p>调用DispatcherServlet.doService(HttpServletRequest, HttpServletResponse)方法来处理。<p><strong>（30）DispatcherServlet.doService(HttpServletRequest, HttpServletResponse)</strong><p>调用DispatcherServlet.doDispatch(HttpServletRequest, HttpServletResponse)方法来处理。<p><strong>（31）DispatcherServlet.doDispatch(HttpServletRequest, HttpServletResponse)</strong><p>通过HandlerExecutionChain来处理请求，详情见SpringMVC章节。</div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Vue%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E5%9F%BA%E7%A1%80%E7%AF%87/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Vue%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97-%E5%9F%BA%E7%A1%80%E7%AF%87/ itemprop=url>前端系列-Vue使用指南</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-11-09 23:26:32" datetime=2023-11-09T23:26:32+08:00 itemprop=dateModified>2023-11-09</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Vue/ itemprop=url rel=index><span itemprop=name>Vue</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=概述><a class=headerlink href=#概述 title=概述></a>概述</h1><h2 id=Vue生命周期><a class=headerlink href=#Vue生命周期 title=Vue生命周期></a>Vue生命周期</h2><p>vue生命周期图示如下：<p><img alt=Vue生命周期图 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/11/06/lifecycle.16e4c08e.png><h1 id=环境搭建><a class=headerlink href=#环境搭建 title=环境搭建></a>环境搭建</h1><h2 id=基础工程><a class=headerlink href=#基础工程 title=基础工程></a>基础工程</h2><h3 id=搭建步骤><a class=headerlink href=#搭建步骤 title=搭建步骤></a>搭建步骤</h3><p>（1）<strong>初始化vue项目</strong>。通过命令<code>npm init vue@latest</code>可实现创建一个基础工程。<p>（2）<strong>安装依赖</strong>。通过命令<code>npm install</code>可安装能使项目运行起来的核心基础依赖。<p>（3）<strong>启动项目，访问服务</strong>。通过命令<code>npm run dev</code>可启动运行项目，启动成功后访问指定IP和端口即可实现访问项目。<h3 id=工程目录说明><a class=headerlink href=#工程目录说明 title=工程目录说明></a>工程目录说明</h3><p>刚搭建好的基础工程目录如下，其个目录定义解释如下图所示。<p><img alt=image-20231106211310902 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/11/06/image-20231106211310902.png><h1 id=基础功能><a class=headerlink href=#基础功能 title=基础功能></a>基础功能</h1><h2 id=路由><a class=headerlink href=#路由 title=路由></a>路由</h2><h3 id=前言><a class=headerlink href=#前言 title=前言></a>前言</h3><p>Vue中关于路由的实现方案有多种，这里以Vue Router为例。<h3 id=使用步骤><a class=headerlink href=#使用步骤 title=使用步骤></a>使用步骤</h3><p><strong>（1）安装vue-router</strong>。安装命令为<code>npm install vue-router@4</code>。<p><strong>（2）创建配置路由</strong><p>在src/router路径下创建index.js文件，文件内容参考如下：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> { createRouter, createWebHistory } <span class=keyword>from</span> <span class=string>'vue-router'</span></span><br><span class=line><span class=keyword>import</span> { useUserStore } <span class=keyword>from</span> <span class=string>'@/stores'</span></span><br><span class=line></span><br><span class=line><span class=comment>// createRouter 创建路由实例</span></span><br><span class=line><span class=comment>// 配置 history 模式</span></span><br><span class=line><span class=comment>// 1. history模式：createWebHistory  地址栏不带 #</span></span><br><span class=line><span class=comment>// 2. hash模式：createWebHashHistory 地址栏带 #</span></span><br><span class=line><span class=comment>// console.log(import.meta.env.DEV)</span></span><br><span class=line></span><br><span class=line><span class=comment>// vite 中的环境变量 import.meta.env.BASE_URL  就是 vite.config.js 中的 base 配置项</span></span><br><span class=line><span class=keyword>const</span> router = <span class="title function_">createRouter</span>({</span><br><span class=line>  <span class=attr>history</span>: <span class="title function_">createWebHistory</span>(<span class=keyword>import</span>.<span class=property>meta</span>.<span class=property>env</span>.<span class=property>BASE_URL</span>),</span><br><span class=line>  <span class=attr>routes</span>: [</span><br><span class=line>    { <span class=attr>path</span>: <span class=string>'/login'</span>, <span class=attr>component</span>: <span class=function>() =></span> <span class=keyword>import</span>(<span class=string>'@/views/login/LoginPage.vue'</span>) }, <span class=comment>// 登录页</span></span><br><span class=line>    {</span><br><span class=line>      <span class=attr>path</span>: <span class=string>'/'</span>,</span><br><span class=line>      <span class=attr>component</span>: <span class=function>() =></span> <span class=keyword>import</span>(<span class=string>'@/views/layout/LayoutContainer.vue'</span>),</span><br><span class=line>      <span class=attr>redirect</span>: <span class=string>'/article/manage'</span>,</span><br><span class=line>      <span class=attr>children</span>: [</span><br><span class=line>        {</span><br><span class=line>          <span class=attr>path</span>: <span class=string>'/article/manage'</span>,</span><br><span class=line>          <span class=attr>component</span>: <span class=function>() =></span> <span class=keyword>import</span>(<span class=string>'@/views/article/ArticleManage.vue'</span>)</span><br><span class=line>        },</span><br><span class=line>        {</span><br><span class=line>          <span class=attr>path</span>: <span class=string>'/article/channel'</span>,</span><br><span class=line>          <span class=attr>component</span>: <span class=function>() =></span> <span class=keyword>import</span>(<span class=string>'@/views/article/ArticleChannel.vue'</span>)</span><br><span class=line>        },</span><br><span class=line>        {</span><br><span class=line>          <span class=attr>path</span>: <span class=string>'/user/profile'</span>,</span><br><span class=line>          <span class=attr>component</span>: <span class=function>() =></span> <span class=keyword>import</span>(<span class=string>'@/views/user/UserProfile.vue'</span>)</span><br><span class=line>        },</span><br><span class=line>        {</span><br><span class=line>          <span class=attr>path</span>: <span class=string>'/user/avatar'</span>,</span><br><span class=line>          <span class=attr>component</span>: <span class=function>() =></span> <span class=keyword>import</span>(<span class=string>'@/views/user/UserAvatar.vue'</span>)</span><br><span class=line>        },</span><br><span class=line>        {</span><br><span class=line>          <span class=attr>path</span>: <span class=string>'/user/password'</span>,</span><br><span class=line>          <span class=attr>component</span>: <span class=function>() =></span> <span class=keyword>import</span>(<span class=string>'@/views/user/UserPassword.vue'</span>)</span><br><span class=line>        }</span><br><span class=line>      ]</span><br><span class=line>    }</span><br><span class=line>  ]</span><br><span class=line>})</span><br><span class=line></span><br><span class=line><span class=comment>// 登录访问拦截</span></span><br><span class=line>router.<span class="title function_">beforeEach</span>(<span class=function>(<span class=params>to</span>) =></span> {</span><br><span class=line>  <span class=keyword>const</span> userStore = <span class="title function_">useUserStore</span>()</span><br><span class=line>  <span class=keyword>if</span> (!userStore.<span class=property>token</span> && to.<span class=property>path</span> !== <span class=string>'/login'</span>) <span class=keyword>return</span> <span class=string>'/login'</span></span><br><span class=line>})</span><br><span class=line></span><br><span class=line><span class=keyword>export</span> <span class=keyword>default</span> router</span><br></pre></table></figure><p><strong>（3）集成至Vue</strong><p>在<code>main.js</code>文件中加入路由相关配置，内容参考如下：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> <span class=string>'@/assets/main.scss'</span></span><br><span class=line><span class=keyword>import</span> <span class=string>'@/stores'</span></span><br><span class=line><span class=keyword>import</span> { createApp } <span class=keyword>from</span> <span class=string>'vue'</span></span><br><span class=line><span class=keyword>import</span> <span class="title class_">App</span> <span class=keyword>from</span> <span class=string>'@/App.vue'</span></span><br><span class=line><span class=comment>// 引入创建的路由,index.js名字可以省略，前提名字是index.js</span></span><br><span class=line><span class=keyword>import</span> router <span class=keyword>from</span> <span class=string>'@/router'</span></span><br><span class=line></span><br><span class=line><span class=keyword>const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class=line>app.<span class="title function_">use</span>(router)	<span class=comment>// 使用路由</span></span><br><span class=line>app.<span class="title function_">mount</span>(<span class=string>'#app'</span>)</span><br></pre></table></figure><p><strong>（4）使用router标签</strong><p>在App.vue文件中使用router标签，实现路由功能。参考内容如下：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line>&LTscript setup></span><br><span class=line>import zh from 'element-plus/es/locale/lang/zh-cn.mjs'</span><br><span class=line>&LT/script></span><br><span class=line></span><br><span class=line>&LTtemplate></span><br><span class=line>  &LTdiv></span><br><span class=line>    &LTel-config-provider :locale="zh"></span><br><span class=line>      &LTrouter-view>&LT/router-view></span><br><span class=line>    &LT/el-config-provider></span><br><span class=line>  &LT/div></span><br><span class=line>&LT/template></span><br><span class=line></span><br><span class=line>&LTstyle lang="scss">&LT/style></span><br></pre></table></figure><p>（5）vue页面中使用<p>在vue页面的script模块中使用路由来实现页面跳转，示例如下：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>&LTscript setup></span><br><span class=line>import { useRouter } from 'vue-router'</span><br><span class=line></span><br><span class=line>const router = useRouter();</span><br><span class=line>// 跳转到请求路径为/的vue页面，这里就是首页。</span><br><span class=line>// 这句代码可以作为登录逻辑处理中登录成功后要执行的代码。</span><br><span class=line>router.push('/');</span><br><span class=line>&LT/script></span><br></pre></table></figure><h2 id=Pinia管理库><a class=headerlink href=#Pinia管理库 title=Pinia管理库></a>Pinia管理库</h2><h3 id=概述-1><a class=headerlink href=#概述-1 title=概述></a>概述</h3><p>Pinia是Vue专属状态管理库，允许跨组件或页面共享状态。<p><font color=red>Pinia缺点</font>：默认是内存存储，刷新浏览器会丢失数据。对于该问题，可通过使用Persist插件持久化存储来解决。Persist插件使用步骤参考如下：<ol><li>通过命令<code>npm install pinia-persistedstate-plugin</code>可安装Persist插件。<li>在pinia实例中使用persist。详情可参考pinia使用步骤中的第（2）步。<li>定义store时通过持久化参数来设置。</ol><h3 id=使用步骤-1><a class=headerlink href=#使用步骤-1 title=使用步骤></a>使用步骤</h3><p>（1）安装Pinia。安装命令为<code>npm install pinia --save</code><p>（2）vue实例中使用pinia<p>想要自定义pinia实例时可以另外创建一个<code>stores/index.js</code>文件来配置，最终导出即可。自定义配置内容参考：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>// stores/index.js</span></span><br><span class=line><span class=keyword>import</span> { createPinia } <span class=keyword>from</span> <span class=string>'pinia'</span></span><br><span class=line><span class=keyword>import</span> { createPersistedState } <span class=keyword>from</span> <span class=string>'pinia-persistedstate=plugin'</span></span><br><span class=line><span class=keyword>const</span> persist = <span class="title function_">createPersistedState</span>()</span><br><span class=line><span class=keyword>const</span> pinia = <span class="title function_">createPinia</span>()</span><br><span class=line>pinia.<span class="title function_">use</span>(persist)</span><br><span class=line><span class=keyword>export</span> <span class=keyword>default</span> pinia</span><br></pre></table></figure><p>在<code>main.js</code>文件中编写如下内容：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> { createApp } <span class=keyword>from</span> <span class=string>'vue'</span></span><br><span class=line><span class=keyword>import</span> <span class="title class_">App</span> <span class=keyword>from</span> <span class=string>'@/App.vue'</span></span><br><span class=line><span class=keyword>import</span> pinia <span class=keyword>from</span> <span class=string>'./stores'</span>	<span class=comment>// 这里导入的就是自定义pinia实例的配置</span></span><br><span class=line></span><br><span class=line><span class=keyword>const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class=line>app.<span class="title function_">use</span>(pinia)</span><br><span class=line>app.<span class="title function_">mount</span>(<span class=string>'#app'</span>)</span><br></pre></table></figure><p>（3）pinia使用实例：定义store<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br></pre><td class=code><pre><span class=line><span class=comment>// 路径 stores/user.js</span></span><br><span class=line><span class=keyword>import</span> { defineStore } <span class=keyword>from</span> <span class=string>'pinia'</span></span><br><span class=line><span class=keyword>import</span> { ref } <span class=keyword>from</span> <span class=string>'vue'</span></span><br><span class=line><span class=keyword>import</span> { userGetInfoService } <span class=keyword>from</span> <span class=string>'@/apis/user'</span></span><br><span class=line></span><br><span class=line><span class=comment>//用户模块</span></span><br><span class=line><span class=keyword>export</span> <span class=keyword>const</span> useUserStore = <span class="title function_">defineStore</span>(</span><br><span class=line>  <span class=string>'big-user'</span>,	<span class=comment>// 当前store的名字，具备唯一性。</span></span><br><span class=line>  <span class=function>() =></span> {		<span class=comment>// 函数</span></span><br><span class=line>    <span class=comment>// 配置token</span></span><br><span class=line>    <span class=keyword>const</span> token = <span class="title function_">ref</span>(<span class=string>''</span>)</span><br><span class=line>    <span class=keyword>const</span> <span class="title function_">setToken</span> = (<span class=params>newToken</span>) => {</span><br><span class=line>      token.<span class=property>value</span> = newToken</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>const</span> <span class="title function_">removeToken</span> = (<span class=params></span>)=>{</span><br><span class=line>        token.<span class=property>value</span>=<span class=string>''</span>;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>const</span> userInfo = <span class="title function_">ref</span>({})</span><br><span class=line>    <span class=keyword>const</span> <span class="title function_">getUserInfo</span> = <span class=keyword>async</span> (<span class=params></span>) => {</span><br><span class=line>      <span class=keyword>const</span> { data } = <span class=keyword>await</span> <span class="title function_">userGetInfoService</span>()</span><br><span class=line>      <span class=comment>// console.log(data);</span></span><br><span class=line>      userInfo.<span class=property>value</span> = data.<span class=property>code</span> === <span class=number>0</span> ? data.<span class=property>data</span> : {}</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>const</span> <span class="title function_">setUserInfo</span> = (<span class=params></span>) => {</span><br><span class=line>      userInfo.<span class=property>value</span> = {}</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> {</span><br><span class=line>      token,</span><br><span class=line>      setToken,</span><br><span class=line>      removeToken,</span><br><span class=line>      getUserInfo,</span><br><span class=line>      userInfo,</span><br><span class=line>      setUserInfo</span><br><span class=line>    }</span><br><span class=line>  },</span><br><span class=line>  {</span><br><span class=line>    <span class=attr>persist</span>: <span class=literal>true</span>,	<span class=comment>// 使用pinia persist插件配置持久化存储</span></span><br><span class=line>  }</span><br><span class=line>)</span><br></pre></table></figure><p>（4）頁面中使用store<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line>&LTscript setup></span><br><span class=line>import { useUserStore } from '@/stores/user.js'</span><br><span class=line>const userStore = useUserStore();</span><br><span class=line>const login = async()=>{</span><br><span class=line>    let result = await userLoginService(loginParam.value);</span><br><span class=line>    // 设置token</span><br><span class=line>    userStore.setToken(result.data);</span><br><span class=line>    router.push('/');</span><br><span class=line>}</span><br><span class=line>&LT/script></span><br></pre></table></figure><h1 id=工具整合><a class=headerlink href=#工具整合 title=工具整合></a>工具整合</h1><h2 id=前言-1><a class=headerlink href=#前言-1 title=前言></a>前言</h2><p>package.json中的dependencies和devdependencies的解释：<ul><li>dependencies：开发和上线都需要的第三方包，安装时推荐使用参数<code>--save</code>。<li>devdependencies：仅在开发阶段需要的第三方包，安装时推荐使用参数<code>--save-dev</code>。</ul><p>安装框架或第三方包时通常会使用一些参数，下面对这些参数进行总结和说明：<ul><li>-S：<code>--save</code>的缩写形式，表示将安装的包放在文件package.json里面的<code>dependencies</code>下。<li>-D：<code>--save-dev</code>的缩写形式，表示将安装的第三方包放在文件package.json里面的<code>devdependencies</code>下。</ul><h2 id=框架整合><a class=headerlink href=#框架整合 title=框架整合></a>框架整合</h2><h3 id=整合Element-Plus><a class=headerlink href=#整合Element-Plus title=整合Element-Plus></a>整合Element-Plus</h3><h4 id=概述-2><a class=headerlink href=#概述-2 title=概述></a>概述</h4><h4 id=使用步骤-2><a class=headerlink href=#使用步骤-2 title=使用步骤></a>使用步骤</h4><p><strong>（1）安装Element-Plus</strong><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>npm install element-plus --save</span><br></pre></table></figure><p>参数解析：<ul><li>save：将下载的包放在文件<code>package.json</code>里面的<code>dependencies</code>下。</ul><p><strong>（2）集成</strong><p><strong>完整引入</strong>只需在<code>main.ts</code>文件中加入如下内容：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=comment>// main.ts</span></span><br><span class=line><span class=keyword>import</span> { createApp } <span class=keyword>from</span> <span class=string>'vue'</span></span><br><span class=line><span class=keyword>import</span> <span class="title class_">ElementPlus</span> <span class=keyword>from</span> <span class=string>'element-plus'</span></span><br><span class=line><span class=keyword>import</span> <span class=string>'element-plus/dist/index.css'</span></span><br><span class=line><span class=keyword>import</span> <span class="title class_">App</span> <span class=keyword>from</span> <span class=string>'./App.vue'</span></span><br><span class=line></span><br><span class=line><span class=keyword>const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class=line></span><br><span class=line>app.<span class="title function_">use</span>(<span class="title class_">ElementPlus</span>)</span><br><span class=line>app.<span class="title function_">mount</span>(<span class=string>'#app'</span>)</span><br></pre></table></figure><p><strong>按需自动导入</strong>使用步骤如下：<ol><li><p>安装<code>unplugin-vue-components</code> 和 <code>unplugin-auto-import</code>这两款插件。安装命令：<code>npm install -D unplugin-vue-components unplugin-auto-import</code>。</p><li><p>在vite.config.ts中加入如下内容：</p> <figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line><span class=comment>// vite.config.ts</span></span><br><span class=line><span class=keyword>import</span> { defineConfig } <span class=keyword>from</span> <span class=string>'vite'</span></span><br><span class=line><span class=keyword>import</span> <span class="title class_">AutoImport</span> <span class=keyword>from</span> <span class=string>'unplugin-auto-import/vite'</span></span><br><span class=line><span class=keyword>import</span> <span class="title class_">Components</span> <span class=keyword>from</span> <span class=string>'unplugin-vue-components/vite'</span></span><br><span class=line><span class=keyword>import</span> { <span class="title class_">ElementPlusResolver</span> } <span class=keyword>from</span> <span class=string>'unplugin-vue-components/resolvers'</span></span><br><span class=line></span><br><span class=line><span class=keyword>export</span> <span class=keyword>default</span> <span class="title function_">defineConfig</span>({</span><br><span class=line>  <span class=comment>// ...</span></span><br><span class=line>  <span class=attr>plugins</span>: [</span><br><span class=line>    <span class=comment>// ...</span></span><br><span class=line>    <span class="title class_">AutoImport</span>({</span><br><span class=line>      <span class=attr>resolvers</span>: [<span class="title class_">ElementPlusResolver</span>()],</span><br><span class=line>    }),</span><br><span class=line>    <span class="title class_">Components</span>({</span><br><span class=line>      <span class=attr>resolvers</span>: [<span class="title class_">ElementPlusResolver</span>()],</span><br><span class=line>    }),</span><br><span class=line>  ],</span><br><span class=line>})</span><br></pre></table></figure></ol><h4 id=切换语言包><a class=headerlink href=#切换语言包 title=切换语言包></a>切换语言包</h4><p>这里以中文语言包为例。使用中文语言包可实现分页小插件提示信息中文展示。<p>使用方法很简单，首先在<code>src/main.js</code>文件中导入中文包的js文件，然后在配置vue实例使用element时传递进去即可。内容参考如下：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> { createApp } <span class=keyword>from</span> <span class=string>'vue'</span></span><br><span class=line><span class=keyword>import</span> <span class="title class_">ElementPlus</span> <span class=keyword>from</span> <span class=string>'element-plus'</span></span><br><span class=line><span class=keyword>import</span> locale <span class=keyword>from</span> <span class=string>'element-plus/dist/locale/zh-cn.js'</span></span><br><span class=line><span class=keyword>import</span> <span class="title class_">App</span> <span class=keyword>from</span> <span class=string>'./App.vue'</span></span><br><span class=line><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">use</span>(<span class="title class_">ElementPlus</span>, {locale});</span><br></pre></table></figure><h3 id=整合Axios><a class=headerlink href=#整合Axios title=整合Axios></a>整合Axios</h3><p>官网文档：<a href=https://axios-http.com/zh/docs/intro rel=noopener target=_blank>https://axios-http.com/zh/docs/intro</a><p><strong>（1）安装Axios</strong><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>npm install axios</span><br></pre></table></figure><p><strong>（2）集成封装</strong><p>通常情况下，可以基于axios创建一个API请求调用工具类来来使用。下面将创建一个工具类request.js来示范：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> axios <span class=keyword>from</span> <span class=string>'axios'</span></span><br><span class=line><span class=keyword>import</span> { useUserStore } <span class=keyword>from</span> <span class=string>'@/stores'</span></span><br><span class=line><span class=keyword>import</span> { <span class="title class_">ElMessage</span> } <span class=keyword>from</span> <span class=string>'element-plus'</span></span><br><span class=line><span class=keyword>import</span> router <span class=keyword>from</span> <span class=string>'@/router'</span></span><br><span class=line></span><br><span class=line><span class=keyword>const</span> baseURL = <span class=string>'http://big-event-vue-api-t.itheima.net'</span></span><br><span class=line></span><br><span class=line><span class=keyword>const</span> instance = axios.<span class="title function_">create</span>({</span><br><span class=line>  <span class=comment>// TODO 1. 基础地址，超时时间</span></span><br><span class=line>  baseURL,</span><br><span class=line>  <span class=attr>timeout</span>: <span class=number>10000</span></span><br><span class=line>})</span><br><span class=line></span><br><span class=line><span class=comment>//请求拦截器</span></span><br><span class=line>instance.<span class=property>interceptors</span>.<span class=property>request</span>.<span class="title function_">use</span>(</span><br><span class=line>  <span class=function>(<span class=params>config</span>) =></span> {</span><br><span class=line>    <span class=comment>// TODO 2. 携带token</span></span><br><span class=line>    <span class=keyword>const</span> userStore = <span class="title function_">useUserStore</span>()</span><br><span class=line>    <span class=keyword>if</span> (userStore.<span class=property>token</span>) {</span><br><span class=line>      config.<span class=property>headers</span>.<span class=property>Authorization</span> = userStore.<span class=property>token</span></span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> config</span><br><span class=line>  },</span><br><span class=line>  <span class=function>(<span class=params>err</span>) =></span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class=line>)</span><br><span class=line></span><br><span class=line><span class=comment>//响应拦截器</span></span><br><span class=line>instance.<span class=property>interceptors</span>.<span class=property>response</span>.<span class="title function_">use</span>(</span><br><span class=line>  <span class=function>(<span class=params>res</span>) =></span> {</span><br><span class=line>    <span class=comment>// TODO 3. 处理业务失败</span></span><br><span class=line>    <span class=comment>// TODO 4. 摘取核心响应数据</span></span><br><span class=line>    <span class=keyword>if</span> (res.<span class=property>data</span>.<span class=property>code</span> === <span class=number>0</span>) <span class=keyword>return</span> res</span><br><span class=line>    <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(res.<span class=property>data</span>.<span class=property>message</span> || <span class=string>'服务异常'</span>)</span><br><span class=line>    <span class=keyword>return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(res.<span class=property>data</span>)</span><br><span class=line>  },</span><br><span class=line>  <span class=function>(<span class=params>err</span>) =></span> {</span><br><span class=line>    <span class=comment>// TODO 5. 处理401错误</span></span><br><span class=line>    <span class=comment>//错误的特殊情况 => 权限不足 或 token过期 => 拦截到登录</span></span><br><span class=line>    <span class=keyword>if</span> (err.<span class=property>response</span>?.<span class=property>status</span> === <span class=number>401</span>) {</span><br><span class=line>      router.<span class="title function_">push</span>(<span class=string>'/login'</span>)</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>//错误的默认提示</span></span><br><span class=line>    <span class="title class_">ElMessage</span>.<span class="title function_">error</span>(err.<span class=property>response</span>.<span class=property>data</span>.<span class=property>message</span> || <span class=string>'服务异常'</span>)</span><br><span class=line>    <span class=keyword>return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class=line>  }</span><br><span class=line>)</span><br><span class=line></span><br><span class=line><span class=keyword>export</span> <span class=keyword>default</span> instance</span><br><span class=line><span class=keyword>export</span> { baseURL }</span><br></pre></table></figure><p><strong>（3）使用示例</strong><p>js文件：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> request <span class=keyword>from</span> <span class=string>'@/utils/request'</span></span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 用户注册接口</span></span><br><span class=line><span class=comment> * <span class=doctag>@param</span> {<span class=type>*</span>} <span class=variable>param0</span></span></span><br><span class=line><span class=comment> * <span class=doctag>@returns</span></span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>export</span> <span class=keyword>const</span> <span class="title function_">userRegisterService</span> = (<span class=params>{ username, password, repassword }</span>) => {</span><br><span class=line>  <span class=keyword>return</span> request.<span class="title function_">post</span>(<span class=string>'/api/reg'</span>, { username, password, repassword })</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>/**</span></span><br><span class=line><span class=comment> * 用户登录接口</span></span><br><span class=line><span class=comment> * <span class=doctag>@param</span> {<span class=type>*</span>} <span class=variable>param0</span></span></span><br><span class=line><span class=comment> * <span class=doctag>@returns</span></span></span><br><span class=line><span class=comment> */</span></span><br><span class=line><span class=keyword>export</span> <span class=keyword>const</span> <span class="title function_">userLoginService</span> = (<span class=params>{ username, password }</span>) => {</span><br><span class=line>  <span class=keyword>return</span> request.<span class="title function_">post</span>(<span class=string>'/api/login'</span>, { username, password })</span><br><span class=line>}</span><br></pre></table></figure><p>vue页面文件：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br></pre><td class=code><pre><span class=line>&LTscript setup></span><br><span class=line>import { ref, watch } from 'vue'</span><br><span class=line>import { useRouter } from 'vue-router'</span><br><span class=line>import { useUserStore } from '@/stores'</span><br><span class=line>import { userRegisterService, userLoginService } from '@/apis/user'</span><br><span class=line></span><br><span class=line>// 模型数据定义</span><br><span class=line>const userStore = useUserStore()</span><br><span class=line>const isRegister = ref(false)</span><br><span class=line>const refObj = ref(null)</span><br><span class=line>const formModel = ref({</span><br><span class=line>  username: '',</span><br><span class=line>  password: '',</span><br><span class=line>  repassword: '',</span><br><span class=line>  rememberme: false</span><br><span class=line>})</span><br><span class=line></span><br><span class=line>// 注册</span><br><span class=line>const registerFn = async () => {</span><br><span class=line>  // console.log("register");</span><br><span class=line>  await refObj.value.validate()</span><br><span class=line>  const { data } = await userRegisterService(formModel.value)</span><br><span class=line>  // console.log(res);</span><br><span class=line>  if (data.code === 0) {</span><br><span class=line>    ElMessage.success(data.message)</span><br><span class=line>    isRegister.value = false</span><br><span class=line>    clearFormModel()</span><br><span class=line>  } else {</span><br><span class=line>    ElMessage.error(data.message)</span><br><span class=line>  }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line>// 登录</span><br><span class=line>const router = useRouter()</span><br><span class=line>const loginFn = async () => {</span><br><span class=line>  await refObj.value.validate()</span><br><span class=line>  const { data } = await userLoginService(formModel.value)</span><br><span class=line>  if (data.code === 0) {</span><br><span class=line>    ElMessage.success(data.message)</span><br><span class=line>    // console.log(data);</span><br><span class=line>    userStore.setToken(data.token)</span><br><span class=line>    clearFormModel()</span><br><span class=line>    router.push('/')</span><br><span class=line>  } else {</span><br><span class=line>    ElMessage.error(data.message)</span><br><span class=line>  }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line>const clearFormModel = () => {</span><br><span class=line>  formModel.value.username = ''</span><br><span class=line>  formModel.value.password = ''</span><br><span class=line>  formModel.value.repassword = ''</span><br><span class=line>  formModel.value.rememberme = false</span><br><span class=line>}</span><br><span class=line></span><br><span class=line>watch(isRegister, () => {</span><br><span class=line>  clearFormModel()</span><br><span class=line>})</span><br><span class=line>&LT/script></span><br><span class=line>&LTtemplate>&LT/template></span><br><span class=line>&LTstyle lang="scss" scoped>&LT/style></span><br></pre></table></figure><h3 id=整合Sass><a class=headerlink href=#整合Sass title=整合Sass></a>整合Sass</h3><p><strong>（1）安装Sass</strong><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>npm install sass sass-loader -D</span><br></pre></table></figure><p><strong>（2）集成</strong><p>全局使用可在<code>vite.config.js</code>文件添加如下内容：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> { defineConfig } <span class=keyword>from</span> <span class=string>'vite'</span>;</span><br><span class=line><span class=keyword>import</span> vue <span class=keyword>from</span> <span class=string>'@vitejs/plugin-vue'</span>;</span><br><span class=line></span><br><span class=line><span class=keyword>export</span> <span class=keyword>default</span> <span class="title function_">defineConfig</span>({</span><br><span class=line>  <span class=attr>plugins</span>: [<span class="title function_">vue</span>()],</span><br><span class=line>  <span class=attr>css</span>: {</span><br><span class=line>    <span class=attr>preprocessorOptions</span>: {</span><br><span class=line>      <span class=attr>scss</span>: {</span><br><span class=line>        <span class=attr>additionalData</span>: <span class=string>`@import '@/styles/main.scss';`</span></span><br><span class=line>      }</span><br><span class=line>    }</span><br><span class=line>  }</span><br><span class=line>});</span><br></pre></table></figure><p><strong>（3）使用示例</strong><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line>&LTtemplate></span><br><span class=line>  &LTdiv class="demo-component"></span><br><span class=line>    &LT!-- Component HTML code here --></span><br><span class=line>  &LT/div></span><br><span class=line>&LT/template></span><br><span class=line></span><br><span class=line>&LTscript></span><br><span class=line>export default {</span><br><span class=line>  // Component configuration options</span><br><span class=line>};</span><br><span class=line></span><br><span class=line>&LTstyle lang="scss" module></span><br><span class=line>.demo-component {</span><br><span class=line>  // Sass code for the component</span><br><span class=line>}</span><br><span class=line>&LT/style></span><br></pre></table></figure><p>注意：vue3中<code>scoped</code>属性已被<code>module</code>属性替换。<h2 id=插件整合><a class=headerlink href=#插件整合 title=插件整合></a>插件整合</h2><h3 id=整合vue-quill（富文本编辑器）><a class=headerlink href=#整合vue-quill（富文本编辑器） title=整合vue-quill（富文本编辑器）></a>整合vue-quill（富文本编辑器）</h3><h4 id=概述-3><a class=headerlink href=#概述-3 title=概述></a>概述</h4><p>官网地址：<a href=https://vueup.github.io/vue-quill rel=noopener target=_blank>https://vueup.github.io/vue-quill</a><h4 id=使用步骤-3><a class=headerlink href=#使用步骤-3 title=使用步骤></a>使用步骤</h4><p>（1）安装vueup。安装命令为<code>npm install @vueup/vue-quill@latest --save</code>。<p>（2）导入组件和样式。<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> { <span class="title class_">QuillEditor</span> } <span class=keyword>from</span> <span class=string>'@vueup/vue-quill'</span></span><br><span class=line><span class=keyword>import</span> <span class=string>'@vueup/vue-quill/dist/vue-quill.snow.css'</span></span><br></pre></table></figure><p>（3）使用quill组件<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>&LTquill-editor </span><br><span class=line>	ref="editRef"</span><br><span class=line>	theme="snow"</span><br><span class=line>	v-model:content="formModel.content"</span><br><span class=line>	contentType="html"></span><br><span class=line>&LT/quill-editor></span><br></pre></table></figure><h3 id=整合js-cookie（cookie管理）><a class=headerlink href=#整合js-cookie（cookie管理） title=整合js-cookie（cookie管理）></a>整合js-cookie（cookie管理）</h3><h4 id=概述-4><a class=headerlink href=#概述-4 title=概述></a>概述</h4><p>相关文档及教程：<a href=https://www.npmjs.com/package/js-cookie rel=noopener target=_blank>点我直达</a>。<h4 id=使用步骤-4><a class=headerlink href=#使用步骤-4 title=使用步骤></a>使用步骤</h4><p>（1）安装js-cookie。安装命令<code>npm install js-cookie --save</code>。<p>（2）使用<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> cookie <span class=keyword>from</span> <span class=string>'js-cookie'</span></span><br><span class=line><span class=comment>// 存储cookie，对当前页面路径有效</span></span><br><span class=line>cookie.<span class="title function_">set</span>(<span class=string>'name'</span>, <span class=string>'value'</span>, { <span class=attr>expires</span>: <span class=number>7</span>, <span class=attr>path</span>: <span class=string>''</span> });</span><br><span class=line><span class=comment>// 获取cookie</span></span><br><span class=line>cookie.<span class="title function_">get</span>(<span class=string>'name'</span>);</span><br><span class=line><span class=comment>// 删除对当前页面路径有效的cookie</span></span><br><span class=line>cookie.<span class="title function_">remove</span>(<span class=string>'name'</span>, {<span class=attr>path</span>: <span class=string>''</span>});</span><br></pre></table></figure><blockquote><p><em>注意：删除不存在的 cookie 既不会引发任何异常，也不会返回任何值。</em></blockquote><h3 id=整合vue-qriously（二维码）><a class=headerlink href=#整合vue-qriously（二维码） title=整合vue-qriously（二维码）></a>整合vue-qriously（二维码）</h3><h4 id=概述-5><a class=headerlink href=#概述-5 title=概述></a>概述</h4><p>相关文档及教程：<a href=%5Bhttps://www.npmjs.com/package/@bitfirer/vue-qriously>点我直达</a>。<h4 id=使用步骤-5><a class=headerlink href=#使用步骤-5 title=使用步骤></a>使用步骤</h4><p>（1）安装vue-qriously。安装命令<code>npm install vue-qriously --save</code>。<p>（2）集成到Vue实例<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> <span class="title class_">Vue</span> <span class=keyword>from</span> <span class=string>'vue'</span></span><br><span class=line><span class=keyword>import</span> <span class="title class_">VueQriously</span> <span class=keyword>from</span> <span class=string>'vue-qriously'</span></span><br><span class=line><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueQriously</span>);</span><br></pre></table></figure><p>（3）使用<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line>&LTscript setup></span><br><span class=line>import { ref } from 'vue'</span><br><span class=line>const wxpay = ref({</span><br><span class=line>    codeUrl:""</span><br><span class=line>})</span><br><span class=line>const getPayCode = async()=>{</span><br><span class=line>    const { data } = generatePayCodeUrl();</span><br><span class=line>    wxpay.value.codeUrl = data;</span><br><span class=line>}</span><br><span class=line>&LT/script></span><br><span class=line>&LTtemplate></span><br><span class=line>    &LTdiv></span><br><span class=line>        &LTqriously :value="wxpay.codeUrl" :size="200" /></span><br><span class=line>    &LT/div></span><br><span class=line>&LT/template></span><br></pre></table></figure><h3 id=整合echarts（图表）><a class=headerlink href=#整合echarts（图表） title=整合echarts（图表）></a>整合echarts（图表）</h3><h4 id=概述-6><a class=headerlink href=#概述-6 title=概述></a>概述</h4><p><a href=https://echarts.apache.org/handbook/zh/get-started/ rel=noopener target=_blank>快速上手 - Apache ECharts</a><h4 id=使用步骤-6><a class=headerlink href=#使用步骤-6 title=使用步骤></a>使用步骤</h4><p>（1）安装echarts。安装命令<code>npm install echarts --save</code>。<p>（2）使用<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line>&LTscript></span><br><span class=line>import * as echarts from 'echarts';</span><br><span class=line></span><br><span class=line>// 基于准备好的dom，初始化echarts实例</span><br><span class=line>var myChart = echarts.init(document.getElementById('main'));</span><br><span class=line>// 绘制图表</span><br><span class=line>myChart.setOption({</span><br><span class=line>  title: {</span><br><span class=line>    text: 'ECharts 入门示例'</span><br><span class=line>  },</span><br><span class=line>  tooltip: {},</span><br><span class=line>  xAxis: {</span><br><span class=line>    data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子']</span><br><span class=line>  },</span><br><span class=line>  yAxis: {},</span><br><span class=line>  series: [</span><br><span class=line>    {</span><br><span class=line>      name: '销量',</span><br><span class=line>      type: 'bar',</span><br><span class=line>      data: [5, 20, 36, 10, 10, 20]</span><br><span class=line>    }</span><br><span class=line>  ]</span><br><span class=line>});</span><br><span class=line>&LT/script></span><br><span class=line>&LTtemplate>&LT/template></span><br></pre></table></figure><h1 id=常见问题><a class=headerlink href=#常见问题 title=常见问题></a>常见问题</h1><h2 id=跨域问题><a class=headerlink href=#跨域问题 title=跨域问题></a>跨域问题</h2><h3 id=定义><a class=headerlink href=#定义 title=定义></a>定义</h3><p>当一个请求url的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面url不同时即为跨域。<h3 id=解决方法><a class=headerlink href=#解决方法 title=解决方法></a>解决方法</h3><p>解决该问题的方法有多种，这里以vue通过代理解决跨域为例来说明。<p>在<code>vite.config.js</code>文件中配置如下代码可实现通过代理解决跨域：<figure class="highlight js"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=keyword>import</span> { fileURLToPath, <span class="variable constant_">URL</span> } <span class=keyword>from</span> <span class=string>'node:url'</span></span><br><span class=line><span class=keyword>import</span> {defineConfig} <span class=keyword>from</span> <span class=string>'vite'</span></span><br><span class=line><span class=keyword>import</span> vue <span class=keyword>from</span> <span class=string>'@/vitejs/plugin-vue'</span></span><br><span class=line></span><br><span class=line><span class=comment>// https://vitejs.dev/config/</span></span><br><span class=line><span class=keyword>export</span> <span class=keyword>default</span> <span class="title function_">defineConfig</span>({</span><br><span class=line>  <span class=attr>plugins</span>: {</span><br><span class=line>    <span class="title function_">vue</span>(),  </span><br><span class=line>  },</span><br><span class=line>  <span class=attr>resolve</span>: {</span><br><span class=line>    <span class=attr>alias</span>: {</span><br><span class=line>      <span class=string>'@'</span>: <span class="title function_">fileURLToPath</span>(<span class=keyword>new</span> <span class="title function_">URL</span>(<span class=string>'./src'</span>, <span class=keyword>import</span>.<span class=property>meta</span>.<span class=property>url</span>))</span><br><span class=line>    }</span><br><span class=line>  },</span><br><span class=line>  <span class=attr>server</span>:{</span><br><span class=line>      <span class=attr>proxy</span>:{</span><br><span class=line>          <span class=string>'/api'</span>: {</span><br><span class=line>              <span class=attr>target</span>: <span class=string>'http://localhost:8080'</span>,</span><br><span class=line>              <span class=attr>changeOrigin</span>: <span class=literal>true</span>,</span><br><span class=line>              <span class=attr>rewrite</span>: <span class=function>(<span class=params>path</span>) =></span> path.<span class="title function_">replace</span>(<span class=string>'/^\/api/'</span>,<span class=string>''</span>)</span><br><span class=line>          }</span><br><span class=line>      }</span><br><span class=line>  }</span><br><span class=line>})</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Tomcat%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Tomcat%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/ itemprop=url>Tomcat系列-Tomcat优化</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-03 10:15:46" datetime=2023-10-03T10:15:46+08:00 itemprop=dateModified>2023-10-03</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Tomcat/ itemprop=url rel=index><span itemprop=name>Tomcat</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=Tomcat优化><a class=headerlink href=#Tomcat优化 title=Tomcat优化></a>Tomcat优化</h1><h2 id=1、内存优化><a class=headerlink href=#1、内存优化 title=1、内存优化></a>1、内存优化</h2><p><strong>启动时告诉JVM需要一块大内存（调优内存是最直接的方式）</strong>。<p>修改配置文件catalina.sh（Windows下为catalina.bat，Linux下为catalina.sh）：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>JAVA_OPTS=<span class=string>'-Xms512m -Xmx1024m'</span></span><br></pre></table></figure><ul><li><code>-Xms&LTsize></code> ：JVM 初始化堆的大小；<li><code>-Xmx&LTsize></code>：JVM 堆的最大值；</ul><h2 id=2、线程优化><a class=headerlink href=#2、线程优化 title=2、线程优化></a>2、线程优化</h2><h3 id=2-1、连接线程优化><a class=headerlink href=#2-1、连接线程优化 title=2.1、连接线程优化></a>2.1、连接线程优化</h3><p>在 server.xml 中进行如下配置：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>Connector</span> <span class=attr>port</span>=<span class=string>"80"</span> <span class=attr>protocol</span>=<span class=string>"HTTP/1.1"</span>  </span></span><br><span class=line><span class=tag>    <span class=attr>connectionTimeout</span>=<span class=string>"20000"</span> </span></span><br><span class=line><span class=tag>    <span class=attr>redirectPort</span>=<span class=string>"8443"</span>   </span></span><br><span class=line><span class=tag>    <span class=attr>executor</span>=<span class=string>"tomcatThreadPool"</span>  </span></span><br><span class=line><span class=tag>    <span class=attr>enableLookups</span>=<span class=string>"false"</span>   </span></span><br><span class=line><span class=tag>    <span class=attr>maxIdleTime</span>= <span class=string>"60000"</span></span></span><br><span class=line><span class=tag>    <span class=attr>acceptCount</span>=<span class=string>"100"</span>   </span></span><br><span class=line><span class=tag>    <span class=attr>maxPostSize</span>=<span class=string>"10485760"</span> </span></span><br><span class=line><span class=tag>    <span class=attr>acceptorThreadCount</span>=<span class=string>"2"</span>    </span></span><br><span class=line><span class=tag>    <span class=attr>disableUploadTimeout</span>=<span class=string>"true"</span>   </span></span><br><span class=line><span class=tag>    <span class=attr>URIEncoding</span>=<span class=string>"utf-8"</span></span></span><br><span class=line><span class=tag>    <span class=attr>keepAliveTimeout</span> =<span class=string>"6000"</span>  </span></span><br><span class=line><span class=tag>    <span class=attr>maxKeppAliveRequests</span>=<span class=string>"500"</span> /></span></span><br></pre></table></figure><ul><li><strong>port</strong>：连接端口；<li><strong>protocol</strong>：连接器使用的传输方式；<li><strong>executor</strong>： 连接器使用的线程池名称；<li><strong>enableLookups</strong>：禁用 DNS查询；<li><strong>maxIdleTime</strong>：线程空闲时间，超过该时间后，空闲线程会被销毁；（默认值为6000（1分钟），单位毫秒。）<li><strong>acceptCount</strong>：当没有处理请求的空闲线程时，可以放到队列中的请求数量，超过该阈值的请求将不予处理；（默认设置 100 。）<li><strong>maxPostSize</strong>：限制 FORM URL参数方式的POST请求的内容大小；（单位字节，默认是 2097152(2兆)，10485760 为 10M。如果要禁用限制，则可以设置为 -1。）<li><strong>acceptorThreadCount</strong>： 接收连接的线程数量；（默认值是1，如果是多核 CPU，则一般配置为 2）<li><strong>disableUploadTimeOut</strong>：允许Servlet容器使用一个较长的连接超时值来完成复杂的逻辑；（默认值为false）<li><strong>keepAliveTimeout</strong>：连接持续存活时间；<li><strong>maxKeepAliveRequests</strong>：连接能承受的最大请求数量，超过该阈值的连接将被关闭；（该参数值为1时表示禁用，-1表示不限制个数，默认100个。一般设置在100~200之间。）</ul><h3 id=2-2、业务处理线程优化><a class=headerlink href=#2-2、业务处理线程优化 title=2.2、业务处理线程优化></a>2.2、业务处理线程优化</h3><p>在server.xml中进行如下编辑：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>Executor</span> <span class=attr>name</span>=<span class=string>"tomcatThreadPool"</span> <span class=attr>namePrefix</span>=<span class=string>"catalina-exec-"</span></span></span><br><span class=line><span class=tag>    <span class=attr>maxThreads</span>=<span class=string>"150"</span> </span></span><br><span class=line><span class=tag>    <span class=attr>minSpareThreads</span>=<span class=string>"100"</span></span></span><br><span class=line><span class=tag>    <span class=attr>prestartminSpareThreads</span>=<span class=string>"true"</span></span></span><br><span class=line><span class=tag>    <span class=attr>maxQueueSize</span>=<span class=string>"100"</span>/></span></span><br></pre></table></figure><ul><li>name：线程名称；<li>namePrefix：线程前缀；<li>maxThreads：最大并发连接数；（默认200，一般设置为500~ 800 ，要根据实际情况来定）<li><strong>minSpareThreads</strong>：Tomcat启动初始化的线程数；（默认值25）<li><strong>prestartminSpareThreads</strong>：tomcat初始化时会初始化参数<code>minSpareThreads</code>值，不设置就不会初始化；<li><strong>maxQueueSize</strong>：最大的等待队列数，超过则拒绝请求；</ul><p>相关参数解析如下：<ol><li>maxThreads：客户请求最大线程数；<li>minSpareThreads：Tomcat初始化时创建的 socket 线程数；<li>maxSpareThreads：Tomcat连接器的最大空闲 socket 线程数；<li>enableLookups：若设为true, 则支持域名解析，可把 ip 地址解析为主机名；<li>redirectPort：在需要基于安全通道的场合，把客户请求转发到基于SSL 的 redirectPort 端口；<li>acceptAccount：监听端口队列最大数，满了之后客户请求会被拒绝（不能小于maxSpareThreads ）；<li>connectionTimeout：连接超时；<li>minProcessors：服务器创建时的最小处理线程数；<li>maxProcessors：服务器同时最大处理线程数；<li>URIEncoding：URL统一编码；</ol><h2 id=3、IO优化><a class=headerlink href=#3、IO优化 title=3、IO优化></a>3、IO优化</h2><p>IO类型主要有如下三种：<ol><li><p><strong>同步阻塞（BIO）</strong>：一个线程一个连接，当然可以通过线程池机制改善；</p> <p>适用场景：<strong>BIO适用于 连接少且固定 的场景</strong>。这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</p><li><p><em><strong>异步阻塞（NIO）</strong></em>：同一个线程处理多个连接(多路复用)；</p> <p>适用场景：<strong>NIO适用于 连接多且连接短 的场景</strong>。比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</p><li><p><strong>异步非阻塞（NIO2，又叫AIO）</strong>：与NIO的区别主要在操作系统底层；</p> <p>适用场景：<strong>AIO适用于 连接多且连接长 的场景</strong>。比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p></ol><p>如下配置可实现 Tomcat IO 模型的切换：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>Connector</span> <span class=attr>port</span>=<span class=string>"80"</span> <span class=attr>protocol</span>=<span class=string>"org.apache.coyote.http11.Http11NioProtocol"</span> </span></span><br><span class=line><span class=tag>           <span class=attr>connectionTimeout</span>=<span class=string>"20000"</span> </span></span><br><span class=line><span class=tag>           <span class=attr>URIEncoding</span>=<span class=string>"UTF-8"</span> </span></span><br><span class=line><span class=tag>           <span class=attr>useBodyEncodingForURI</span>=<span class=string>"true"</span> </span></span><br><span class=line><span class=tag>           <span class=attr>enableLookups</span>=<span class=string>"false"</span> </span></span><br><span class=line><span class=tag>           <span class=attr>redirectPort</span>=<span class=string>"8443"</span> /></span></span><br></pre></table></figure><p>Connector使用哪种protocol，可以通过<code>&LTconnector></code>元素中的protocol属性进行指定，也可以使用默认值。<p>protocol取值及对应协议如下：<ul><li>HTTP/1.1：<strong>默认值，使用的协议与Tomcat版本有关</strong><li>org.apache.coyote.http11.Http11Protocol：BIO<li>org.apache.coyote.http11.Http11NioProtocol：NIO<li>org.apache.coyote.http11.Http11Nio2Protocol：NIO2<li>org.apache.coyote.http11.Http11AprProtocol：APR</ul><p>如果没有指定protocol，则默认HTTP/1.1，其含义如下：在Tomcat7中，自动选取使用BIO或APR（如果找到APR需要的本地库，则使用APR，否则使用BIO）；在Tomcat8中，自动选取使用NIO或APR（如果找到APR需要的本地库，则使用APR，否则使用NIO）<h2 id=4、缓存压缩优化><a class=headerlink href=#4、缓存压缩优化 title=4、缓存压缩优化></a>4、缓存压缩优化</h2><h3 id=4-1、压缩优化定义><a class=headerlink href=#4-1、压缩优化定义 title=4.1、压缩优化定义></a>4.1、压缩优化定义</h3><p>压缩优化是指：<strong>将返回的 html 页面等内容压缩成 gzip 格式后发送给浏览器，浏览器在本地解压缩的过程</strong>。<h3 id=4-2、开启压缩优化><a class=headerlink href=#4-2、开启压缩优化 title=4.2、开启压缩优化></a>4.2、开启压缩优化</h3><p>可以根据自己的业务场景在 server.xml 中进行如下相关配置：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>Connector</span> <span class=attr>port</span>=<span class=string>"9027"</span></span></span><br><span class=line><span class=tag>           <span class=attr>protocol</span>=<span class=string>"HTTP/1.1"</span></span></span><br><span class=line><span class=tag>           <span class=attr>maxHttpHeaderSize</span>=<span class=string>"8192"</span></span></span><br><span class=line><span class=tag>           <span class=attr>maxThreads</span>=<span class=string>"1000"</span></span></span><br><span class=line><span class=tag>           <span class=attr>minSpareThreads</span>=<span class=string>"100"</span></span></span><br><span class=line><span class=tag>           <span class=attr>maxSpareThreads</span>=<span class=string>"1000"</span></span></span><br><span class=line><span class=tag>           <span class=attr>minProcessors</span>=<span class=string>"100"</span></span></span><br><span class=line><span class=tag>           <span class=attr>maxProcessors</span>=<span class=string>"1000"</span></span></span><br><span class=line><span class=tag>           <span class=attr>enableLookups</span>=<span class=string>"false"</span></span></span><br><span class=line><span class=tag>           <span class=attr>compression</span>=<span class=string>"on"</span></span></span><br><span class=line><span class=tag>           <span class=attr>compressionMinSize</span>=<span class=string>"2048"</span></span></span><br><span class=line><span class=tag>           <span class=attr>compressableMimeType</span>=<span class=string>"text/html,text/xml,text/javascript,text/css,text/plain"</span></span></span><br><span class=line><span class=tag>           <span class=attr>connectionTimeout</span>=<span class=string>"20000"</span></span></span><br><span class=line><span class=tag>           <span class=attr>URIEncoding</span>=<span class=string>"utf-8"</span></span></span><br><span class=line><span class=tag>           <span class=attr>acceptCount</span>=<span class=string>"1000"</span></span></span><br><span class=line><span class=tag>           <span class=attr>redirectPort</span>=<span class=string>"8443"</span></span></span><br><span class=line><span class=tag>           <span class=attr>disableUploadTimeout</span>=<span class=string>"true"</span>/></span></span><br></pre></table></figure><p>参数解析：<ul><li>**compression=”on”**：打开压缩功能；<li>**compressionMinSize=”2048”**：启用压缩的输出内容大小，默认为2KB；<li>**noCompressionUserAgents=”gozilla,traviata”**：对于以下的浏览器，不启用压缩；<li>**compressableMimeType=”text/html,text/xml,text/javascript,text/css,text/plain”**：哪些资源类型需要压缩；</ul><h3 id=4-3、缓存策略><a class=headerlink href=#4-3、缓存策略 title=4.3、缓存策略></a>4.3、缓存策略</h3><p>开启浏览器缓存，可以快速读取webapps文件夹里的静态内容，提高了整体性能。<ol><li>浏览器第一次请求tomcat服务器某资源。<li>tomcat拿到资源后将该资源最后修改的时间保存在响应头的Last-Modified中 （Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT）。<li>浏览器第二次访问tomcat请求该资源时将该资源的最后修改时间放入If-Modified-Since请求头中。<li>服务器收到请求并比较请求中的If-Modified-Since与资源最后修改时间 Last-Modified 是否一致，如果一致则发送响应代码304，告知其在本地缓存拿就可以了。</ol><h2 id=5、安全优化><a class=headerlink href=#5、安全优化 title=5、安全优化></a>5、安全优化</h2><p>安全优化参考如下：<ol><li><p><strong>降权启动</strong></p><li><p><strong>修改端口号</strong></p><li><p><strong>更改 tomcat 关闭指令</strong></p><li><p><strong>修改管理员用户名、密码</strong></p><li><p><strong>清空站点目录root下的管理页面等</strong></p><li><p><strong>错误页面的优雅展示</strong></p><li><p><strong>隐藏版本号</strong></p><li><p><strong>禁用DNS查询</strong></p> <p>当web应用记录客户端信息时，它也会记录客户端IP地址或通过域名服务器查找机器名然后转为IP地址。DNS查询需要网络开销，且还有远距离获取IP的开销。</p> <p>关闭DNS查询可提高性能，关闭DNS查询的方式是：<strong>将 server.xml 文件中参数 enableLookups 的值设为false即可</strong>。</p><li><p><strong>设置session过期时间</strong><br>Tomcat采用数据库连接池技术，该技术的执行逻辑是：<strong>当用户在设置的 session 超时时间内没有对数据库执行操作时，就会自动关闭该连接，避免浪费宝贵的数据库连接资源</strong>。设置 session 过期时间的方法是 <strong>在 tomcat_home / conf / web.xml文件中找到 session-config 标签的子标签 session-timeout 标签，为该子标签设置超时时间即可，单位是分钟</strong>。</p><li><p>server.xml中进行如下定义：</p></ol><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>Context</span> <span class=attr>path</span>=<span class=string>"/test"</span> <span class=attr>docBase</span>=<span class=string>"/test"</span> </span></span><br><span class=line><span class=tag>         <span class=attr>isWARExpanded</span>=<span class=string>"true"</span></span></span><br><span class=line><span class=tag>         <span class=attr>isWARValidated</span>=<span class=string>"false"</span> </span></span><br><span class=line><span class=tag>         <span class=attr>isInvokerEnabled</span>=<span class=string>"true"</span></span></span><br><span class=line><span class=tag>         <span class=attr>isWorkDirPersistent</span>=<span class=string>"false"</span> </span></span><br><span class=line><span class=tag>         <span class=attr>defaultSessionTimeOut</span>=<span class=string>"3600"</span> /></span></span><br></pre></table></figure><p>项目所在目录下的web.xml中定义：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>session-config</span>></span></span><br><span class=line>　　<span class=tag><<span class=name>session-timeout</span>></span>20<span class=tag>&LT/<span class=name>session-timeout</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>session-config</span>></span></span><br></pre></table></figure><p>在程序中定义：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>session.setMaxInactiveInterval(<span class=number>30</span>*<span class=number>60</span>);   <span class=comment>// 单位：秒，设为-1表示永不过期。</span></span><br></pre></table></figure><h2 id=6、APR（大杀器）><a class=headerlink href=#6、APR（大杀器） title=6、APR（大杀器）></a>6、APR（大杀器）</h2><h2 id=6-1、概述><a class=headerlink href=#6-1、概述 title=6.1、概述></a>6.1、概述</h2><p><strong>APR（Apache Portable Runtime）是Apache的一个库，它提供了跨平台的API，用于支持Apache HTTP Server 及其它Apache项目。</strong>APR通过对操作系统底层功能的封装，提供了一种高效、可移植和可靠的编程接口。<p><strong>Tomcat 中 APR 通常指的是 APR/native 组件，它是一个与操作系统级别的库进行交互的接口</strong>。APR/native 组件可以与Tomcat一起使用，以提高性能和可扩展性。<p>APR/native 组件的主要功能包括：<ul><li><strong>提供高效的网络IO操作</strong>：通过操作系统级别的多路复用技术，可以显著提高网络性能。<li><strong>支持更高级的加密功能</strong>：可以利用操作系统提供的高级加密库，提供更好的加密性和安全性。<li><strong>提供更好的静态资源服务功能</strong>：利用操作系统的高性能文件IO接口，提供高效的静态资源服务能力。</ul><h2 id=6-2、安装使用><a class=headerlink href=#6-2、安装使用 title=6.2、安装使用></a>6.2、安装使用</h2><p>安装使用步骤参考如下：<ol><li><p>从Apache官网下载APR的库。</p><li><p>编译安装APR库</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>./configure</span><br><span class=line>make</span><br><span class=line>make install</span><br></pre></table></figure><li><p>编译安装APR/native模块</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>./configure --with-apr=/path/to/apr/source</span><br><span class=line>make</span><br><span class=line>make install</span><br></pre></table></figure> <p><code>/path/to/apr/source</code>是APR库源代码的路径。</p><li><p>配置Tomcat使用APR/native模块</p> <p>打开 conf/server.xml 文件，在该文件中找到标签 Connector，在该标签中配置属性 <code>protocol=org.apache.coyote.http11.Http11AprProtocol</code>，修改完后保存server.xml文件。</p><li><p>重启Tomcat服务使其生效</p></ol><h1 id=Tomcat之JVM优化><a class=headerlink href=#Tomcat之JVM优化 title=Tomcat之JVM优化></a>Tomcat之JVM优化</h1><p>在catalina.sh 文件中加入如下配置：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>JAVA_OPTS=<span class=string>"-Xms2G -Xmx2G -Xmn512m -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=512M -XX:+UseConcMarkSweepGC -XX:+CMSClassUnloadingEnabled -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:+HeapDumpOnOutOfMemoryError -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -Xloggc:/appl/gc.log"</span></span><br></pre></table></figure><p>参数解析：<ul><li>-Xms2G：初始堆内存；<li>-Xmx2G：最大堆内存；<li>-Xmn512m：年轻代大小；<li>-XX:MetaspaceSize=512M：初始元空间大小，达到该值会触发垃圾回收并进行类型卸载，同时GC会对该值进行动态调整：如果垃圾回收后释放了大量空间就降低该值；如果释放了少量空间，那么就在不超过 MaxMetaspaceSize设定值的前提下适当提高该值。<li>-XX:+UseConcMarkSweepGC：使用 并发标记清除类型的 CMS垃圾回收器；<li>-XX:+CMSClassUnloadingEnabled： 表示 是否启用类卸载；（+表示启用，-表示关闭，默认关闭。该功能只有在使用CM回收器时才有效。）<li>-XX:+HeapDumpOnOutOfMemoryError：表示 发生OOM时会自动生成DUMP文件；<li>-XX:HeapDumpPath=${目录}：表示生成DUMP文件的路径，也可以指定文件名称，例如：<code>-XX:HeapDumpPath=${目录}/java_heapdump.hprof</code>。如果不指定文件名，默认为：<code>java_&LTpid>_&LTdate>_&LTtime>_heapDump.hprof</code>；<li>-verbose:gc：输出GC日志 ， -XX:+PrintGC 与 -verbose:gc 是一样的，可以认为-verbose:gc 是 -XX:+PrintGC的别名；<li>-XX:+PrintGCDetails：打印GC详细信息；<li>-XX:+PrintGCTimeStamps：输出GC时间戳；（以JVM启动到当期的总时长的时间戳形式）<li>-XX:+PrintGCDateStamps：输出GC的时间戳；（以日期的形式，如 2013-05-04T21:53:59.234+0800）<li>-Xloggc:/appl/gc.log：定义gc日志目录；<li>-XX:CMSInitiatingOccupancyFraction=75：内存占用率达到75%时开启CMS GC；<li>-XX:+UseCMSInitiatingOccupancyOnly：设定该选项 表示 CMS始终使用参数<code>&LTfont color='orange'>-XX:CMSInitiatingOccupancyFraction</code>指定的垃圾回收阈值，如果不设定该选项，则表示只有在最开始阶段使用上面参数指定的垃圾回收阈值，后期会根据实际情况动态调整垃圾回收阈值；</ul><h1 id=操作系统优化（Linux）><a class=headerlink href=#操作系统优化（Linux） title=操作系统优化（Linux）></a>操作系统优化（Linux）</h1><h2 id=1、最大打开文件数><a class=headerlink href=#1、最大打开文件数 title=1、最大打开文件数></a>1、最大打开文件数</h2><h3 id=1-1、系统级句柄数量><a class=headerlink href=#1-1、系统级句柄数量 title=1.1、系统级句柄数量></a>1.1、系统级句柄数量</h3><p>（1）查看<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>cat</span> /proc/sys/fs/file-max</span><br></pre></table></figure><p>（2）修改<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>echo</span> 数量 > /proc/sys/fs/file-max</span><br></pre></table></figure><p>（3）永久生效<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment># 1、修改文件</span></span><br><span class=line>vim /etc/sysctl.conf</span><br><span class=line><span class=comment># 2、在文件末尾添加如下内容</span></span><br><span class=line>fs.file-max = 2000000</span><br><span class=line><span class=comment># 3、执行如下命令，使修改配置立即生效</span></span><br><span class=line>sysctl -p</span><br></pre></table></figure><h3 id=1-2、进程级句柄数量><a class=headerlink href=#1-2、进程级句柄数量 title=1.2、进程级句柄数量></a>1.2、进程级句柄数量</h3><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment># 1、打开文件</span></span><br><span class=line>vim /etc/security/limits.conf</span><br><span class=line><span class=comment># 2、在文件最后添加如下内容</span></span><br><span class=line>* soft <span class=built_in>nproc</span> 100001     <span class=comment># 警告设定 所有用户最大打开进程数为10001</span></span><br><span class=line>* hard <span class=built_in>nproc</span> 100001     <span class=comment># 严格设定 所有用户最大打开进程数为100001</span></span><br><span class=line>* soft nofile 100001    <span class=comment># 警告设定 所有用户最大打开文件数为100001</span></span><br><span class=line>* hard nofile 100002    <span class=comment># 严格设定 所有用户最大打开文件数为100002</span></span><br></pre></table></figure><ul><li><strong>soft</strong> 表示警告设定，超过该值会有警告信息；<li><strong>hard</strong> 表示严格设定，不能超过该值；</ul><p><font color=red>注意：修改后，要重启服务器才生效。</font><h2 id=2、TCP参数优化><a class=headerlink href=#2、TCP参数优化 title=2、TCP参数优化></a>2、TCP参数优化</h2><p>以下命令参数的修改全部基于<code>/etc/sysctl.conf</code>文件，修改完后，通过命令<code>sysctl -p</code>使其修改生效。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br></pre><td class=code><pre><span class=line><span class=comment>#（4G 内存机器 使用，TCP连接最多约使用1.6GB内存 ， 393216*4096/1024/1024=1.6G）</span></span><br><span class=line><span class=comment>#内核分配给TCP连接的内存，单位是Page，1 Page = 4096 Bytes</span></span><br><span class=line>net.ipv4.tcp_mem = 196608  262144  393216  </span><br><span class=line></span><br><span class=line><span class=comment>#（8G 内存使用，TCP连接最多约使用4GB内存）     </span></span><br><span class=line>net.ipv4.tcp_mem = 524288  699050  1048576      </span><br><span class=line></span><br><span class=line><span class=comment>#为每个TCP连接分配的读、写缓冲区内存大小，单位是Byte</span></span><br><span class=line><span class=comment># 一般按照缺省值分配，上面的例子就是读写均为8KB，共16KB</span></span><br><span class=line><span class=comment>#1.6G 内存服务器， TCP内存能容纳的连接数，约为  1600MB/16KB = 100K = 10万</span></span><br><span class=line><span class=comment>#4.G TCP内存能容纳的连接数，约为  4000MB/16KB = 250K = 25万</span></span><br><span class=line><span class=comment>#                  最小内存  缺省内存  最大内存</span></span><br><span class=line>net.ipv4.tcp_rmem = 4096     8192    4194304</span><br><span class=line>net.ipv4.tcp_wmem = 4096     8192    4194304</span><br><span class=line></span><br><span class=line><span class=comment>#（端口最大的监听队列长度）</span></span><br><span class=line><span class=comment>#同时，修改下全局配置</span></span><br><span class=line><span class=comment># echo 4000 > /proc/sys/net/core/somaxconn 定义了系统中每一个端口最大的监听队列的长度,这是个全局的参数,默认值为128,</span></span><br><span class=line>net.core.somaxconn= 4000</span><br><span class=line></span><br><span class=line><span class=comment>#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</span></span><br><span class=line>net.ipv4.tcp_syncookies = 1</span><br><span class=line></span><br><span class=line><span class=comment>#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</span></span><br><span class=line>net.ipv4.tcp_tw_reuse = 1</span><br><span class=line></span><br><span class=line><span class=comment>#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；</span></span><br><span class=line>net.ipv4.tcp_tw_recycle = 1</span><br><span class=line></span><br><span class=line><span class=comment>#修改系統默认的 TIMEOUT 时间。</span></span><br><span class=line>net.ipv4.tcp_fin_timeout = 30</span><br><span class=line></span><br><span class=line><span class=comment>#表示当keepalive起作用时，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。</span></span><br><span class=line>net.ipv4.tcp_keepalive_time = 1200  </span><br><span class=line></span><br><span class=line><span class=comment>#表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。</span></span><br><span class=line><span class=comment>#（注意：不要将最低值设太低，否则可能会占用正常端口！）</span></span><br><span class=line>net.ipv4.ip_local_port_range = 10000 65000  </span><br><span class=line></span><br><span class=line><span class=comment>#表示SYN队列长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。</span></span><br><span class=line>net.ipv4.tcp_max_syn_backlog = 8192</span><br><span class=line></span><br><span class=line><span class=comment>#表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默认为180000，改为5000。</span></span><br><span class=line>net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class=line></span><br><span class=line><span class=comment>#当orphans达到32768个时，会报Out of socket memory，此时占用内存 32K*64KB=2048MB=2GB</span></span><br><span class=line><span class=comment>#（每个孤儿socket可占用多达64KB内存），实际可能小一些</span></span><br><span class=line>net.ipv4.tcp_max_orphans = 65536</span><br><span class=line></span><br><span class=line><span class=comment>#孤儿socket废弃前重试的次数，重负载web服务器建议调小，设置较小的数值，可以有效降低orphans的数量</span></span><br><span class=line>net.ipv4.tcp_orphan_retries = 1</span><br><span class=line></span><br><span class=line><span class=comment>#活动TCP连接重传次数，超过次数视为掉线，放弃连接。缺省值：15，建议设为 2或者3.</span></span><br><span class=line>net.ipv4.tcp_retries=2</span><br><span class=line></span><br><span class=line><span class=comment>#TCP三次握手的syn/ack阶段，重试次数，缺省5，设为2-3</span></span><br><span class=line>net.ipv4.tcp_synack_retries=2</span><br><span class=line></span><br><span class=line><span class=comment># 网络设备的收发包的队列大小</span></span><br><span class=line>net.core.netdev_max_backlog = 2048</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Tomcat%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Tomcat%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/ itemprop=url>Tomcat系列-Tomcat基础</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-03 09:51:04" datetime=2023-10-03T09:51:04+08:00 itemprop=dateModified>2023-10-03</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Tomcat/ itemprop=url rel=index><span itemprop=name>Tomcat</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=Tomcat架构流程图><a class=headerlink href=#Tomcat架构流程图 title=Tomcat架构流程图></a>Tomcat架构流程图</h1><h2 id=1-1、整体架构图><a class=headerlink href=#1-1、整体架构图 title=1.1、整体架构图></a>1.1、整体架构图</h2><p>图1：<strong>整体架构</strong><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/1.1.1.1-Tomcat-%E6%9E%B6%E6%9E%84%E5%9B%BE-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE-%E5%9B%BE1.png><p>图2：connector访问engine，engine可以看作是container。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/1.1.1.2-Tomcat-%E6%9E%B6%E6%9E%84%E5%9B%BE-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE-%E5%9B%BE2.png><p>图3：connector内部结构及请求执行流程。<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/1.1.1.3-Tomcat-%E6%9E%B6%E6%9E%84%E5%9B%BE-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE-%E5%9B%BE3.png><h2 id=1-2、初始化流程图><a class=headerlink href=#1-2、初始化流程图 title=1.2、初始化流程图></a>1.2、初始化流程图</h2><p><img alt=1.1.1.1-Tomcat-请求处理-请求处理流程-流程图 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/1.2.1.1-Tomcat-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86-HTTP%E8%AF%B7%E6%B1%82-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%9B%BE.png><h2 id=1-3、类结构图><a class=headerlink href=#1-3、类结构图 title=1.3、类结构图></a>1.3、类结构图</h2><p>类架构简图如下：<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/1.1.2.1-Tomcat-%E6%9E%B6%E6%9E%84%E5%9B%BE-%E7%B1%BB%E7%BB%93%E6%9E%84%E5%9B%BE-%E5%9B%BE1.png><p>组件嵌套图如下：<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/1.1.3.1-Tomcat-%E6%9E%B6%E6%9E%84%E5%9B%BE-%E7%BB%84%E4%BB%B6%E5%B5%8C%E5%A5%97%E5%9B%BE-%E5%9B%BE1.png><h1 id=Tomcat启动初始化><a class=headerlink href=#Tomcat启动初始化 title=Tomcat启动初始化></a>Tomcat启动初始化</h1><h2 id=1-1、执行流程><a class=headerlink href=#1-1、执行流程 title=1.1、执行流程></a>1.1、执行流程</h2><p><strong>（1）<code>org.apache.catalina.startup.Bootstrap.main(String[] args)</code></strong><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=comment>// 1.1、创建Catalina实例对象，设置父类加载器为this.sharedLoader</span></span><br><span class=line><span class=comment>// 1.2、初始化 this.catalinaDaemon = Catalina实例对象。</span></span><br><span class=line><span class=type>Bootstrap</span> <span class=variable>bootstrap</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Bootstrap</span>();</span><br><span class=line>bootstrap.init();</span><br><span class=line></span><br><span class=line><span class=comment>// 1.3、为当前线程设置上下文类加载器为daemon.catalinaLoader</span></span><br><span class=line>Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);</span><br><span class=line></span><br><span class=line>daemon.load(args);</span><br><span class=line>daemon.start();</span><br></pre></table></figure><h1 id=请求处理><a class=headerlink href=#请求处理 title=请求处理></a>请求处理</h1><h2 id=1-1、Protocol><a class=headerlink href=#1-1、Protocol title=1.1、Protocol></a>1.1、Protocol</h2><h3 id=1-1-1、概述><a class=headerlink href=#1-1-1、概述 title=1.1.1、概述></a>1.1.1、概述</h3><p><strong>Connector 处理 HTTP 请求时会使用不同的 protocol。不同版本的 Tomcat 支持不同的 protocol，其中最典型的 protocol 包括 BIO、NIO 和 APR（Tomcat7支持这 3 种，Tomcat8增加了对 NIO2 的支持，Tomcat8.5和Tomcat9.0 去掉了对 BIO 的支持</strong>）。<p>BIO说的是Blocking IO，即阻塞式IO。NIO说的是Non-blocking IO，即非阻塞式IO。<strong>APR说的是 Apache Portable Runtime，是Apache可移植运行库，利用本地库可以实现高可扩展性、高性能</strong>。APR是Tomcat运行高并发应用的首选模式，但需要安装apr、apr-utils、tomcat-native等包。<h3 id=1-1-2、设置Protocol><a class=headerlink href=#1-1-2、设置Protocol title=1.1.2、设置Protocol></a>1.1.2、设置Protocol</h3><p><strong>通过<code>&LTconnector></code>标签中的 protocol 属性可以配置 Connector 使用哪种 protocol，也可以使用默认值</strong>。<p>protocol取值及对应协议如下：<ul><li><strong>HTTP/1.1</strong>：默认值，使用的协议与Tomcat版本有关<li><strong>org.apache.coyote.http11.Http11Protocol</strong>：BIO<li><strong>org.apache.coyote.http11.Http11NioProtocol</strong>：NIO<li><strong>org.apache.coyote.http11.Http11Nio2Protocol</strong>：NIO2<li><strong>org.apache.coyote.http11.Http11AprProtocol</strong>：APR</ul><p><strong>如果没有指定 protocol，默认使用 HTTP/1.1。Tomcat7 会优先使用APR，没有APR才用 BIO。Tomcat8会优先使用 APR，没有 APR 才用 NIO</strong>。<h2 id=1-2、请求处理流程><a class=headerlink href=#1-2、请求处理流程 title=1.2、请求处理流程></a>1.2、请求处理流程</h2><h3 id=1-2-1、请求处理流程堆栈><a class=headerlink href=#1-2-1、请求处理流程堆栈 title=1.2.1、请求处理流程堆栈></a>1.2.1、请求处理流程堆栈</h3><p>堆栈信息如下图所示：</p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/1.2.1.2-Tomcat-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86-HTTP%E8%AF%B7%E6%B1%82-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%A0%86%E6%A0%88.jpg style=zoom:150%;><h3 id=1-2-2、流程分析><a class=headerlink href=#1-2-2、流程分析 title=1.2.2、流程分析></a>1.2.2、流程分析</h3><p><strong>无论是BIO，还是NIO，Connector处理请求的流程基本一样</strong>。<p>Accept 队列中接收连接（当客户端向服务器发送请求时，如果客户端与OS完成三次握手建立了连接，OS会将该连接放入accept队列）；在连接中获取请求数据，生成request；调用 servlet 容器处理请求并返回 response。首先明确连接与请求的关系：<strong>连接是TCP层面的（传输层），对应socket；请求是HTTP层面（应用层），依赖于TCP；一个TCP连接中可能传输多个HTTP请求</strong>。<p>BIO实现的Connector中，处理请求的主要实体是 JIoEndpoint 对象。JIoEndpoint 维护了 Acceptor 和 Worker。<strong>Acceptor接收socket，然后从Worker线程池中找出空闲线程处理socket，如果worker线程池没有空闲线程，则Acceptor将阻塞</strong>。其中Worker是Tomcat自己的线程池，如果通过<code>&LTExecutor></code>配置了其他线程池，原理与Worker类似。</div><footer class=post-footer><div class=post-eof></div></footer></article></div> <div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Spring%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Spring%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/ itemprop=url>Spring系列-Spring原理解析</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:14" datetime=2024-08-21T21:39:14+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-04 15:59:52" datetime=2023-10-04T15:59:52+08:00 itemprop=dateModified>2023-10-04</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Spring/ itemprop=url rel=index><span itemprop=name>Spring</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=IOC（控制反转）><a class=headerlink href=#IOC（控制反转） title=IOC（控制反转）></a>IOC（控制反转）</h1><h2 id=1、refresh><a class=headerlink href=#1、refresh title=1、refresh()></a>1、refresh()</h2><h3 id=0、源码><a class=headerlink href=#0、源码 title=0、源码></a>0、源码</h3><p><code>org.springframework.context.support.AbstractApplication.refresh()</code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">refresh</span><span class=params>()</span> <span class=keyword>throws</span> BeansException, IllegalStateException {</span><br><span class=line>    <span class=keyword>synchronized</span> (<span class=built_in>this</span>.startupShutdownMonitor) {</span><br><span class=line>        <span class=comment>// 1、准备容器</span></span><br><span class=line>        prepareRefresh();</span><br><span class=line>        <span class=comment>// 2、告知子类刷新内部BeanFactory</span></span><br><span class=line>        <span class=type>ConfigurableListableBeanFactory</span> <span class=variable>beanFactory</span> <span class=operator>=</span> obtainFreshBeanFactory();</span><br><span class=line>        <span class=comment>// 3、准备BeanFactory</span></span><br><span class=line>        prepareBeanFactory(beanFactory);</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            <span class=comment>// 4、Allows post-processing of the bean factory in context subclasses.</span></span><br><span class=line>            postProcessBeanFactory(beanFactory);</span><br><span class=line>            <span class=comment>// 5、Invoke factory processors registered as beans in the context.</span></span><br><span class=line>            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=line>            <span class=comment>// 6、Register bean processors that intercept bean creation.</span></span><br><span class=line>            registerBeanPostProcessors(beanFactory);</span><br><span class=line>            <span class=comment>// 7、Initialize message source for this context.</span></span><br><span class=line>            initMessageSource();</span><br><span class=line>            <span class=comment>// 8、Initialize event multicaster for this context.</span></span><br><span class=line>            initApplicationEventMulticaster();</span><br><span class=line>            <span class=comment>// 9、Initialize other special beans in specific context subclasses.</span></span><br><span class=line>            onRefresh();</span><br><span class=line>            <span class=comment>// 10、Check for listener beans and register them.</span></span><br><span class=line>            registerListeners();</span><br><span class=line>            <span class=comment>// 11、Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class=line>            finishBeanFactoryInitialization(beanFactory);</span><br><span class=line>            <span class=comment>// 12、Last step: publish corresponding event.</span></span><br><span class=line>            finishRefresh();</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 省略部分代码，不重要 //</span></span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=1、prepareRefresh><a class=headerlink href=#1、prepareRefresh title=1、prepareRefresh()></a>1、prepareRefresh()</h3><p>刷新前的预处理：<strong>初始化属性，检验属性合法性，保存容器中的事件</strong>。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>1）、initPropertySources()初始化一些属性设置;子类自定义个性化的属性设置方法；</span><br><span class=line>2）、getEnvironment().validateRequiredProperties();检验属性的合法等</span><br><span class=line>3）、earlyApplicationEvents= new LinkedHashSet&LTApplicationEvent>();保存容器中的一些早期的事件；</span><br></pre></table></figure><h3 id=2、beanFactory-obtainFreshBeanFactory><a title="2、beanFactory = obtainFreshBeanFactory()" class=headerlink href=#2、beanFactory-obtainFreshBeanFactory></a>2、beanFactory = obtainFreshBeanFactory()</h3><p>获取BeanFactory。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>1）、refreshBeanFactory();</span><br><span class=line>	刷新【创建】BeanFactory（this.beanFactory = new DefaultListableBeanFactory();）</span><br><span class=line>	设置id；</span><br><span class=line>2）、getBeanFactory();返回刚才GenericApplicationContext创建的BeanFactory对象；</span><br><span class=line>3）、将创建的BeanFactory【DefaultListableBeanFactory】返回；</span><br></pre></table></figure><h3 id=3、prepareBeanFactory-beanFactory><a class=headerlink href=#3、prepareBeanFactory-beanFactory title=3、prepareBeanFactory(beanFactory)></a>3、prepareBeanFactory(beanFactory)</h3><p>BeanFactory的预准备工作（BeanFactory进行一些设置）。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>1）、设置BeanFactory的类加载器、支持表达式解析器...</span><br><span class=line>2）、添加部分BeanPostProcessor【ApplicationContextAwareProcessor】</span><br><span class=line>3）、设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、xxx；</span><br><span class=line>4）、注册可以解析的自动装配；我们能直接在任何组件中自动注入：</span><br><span class=line>	BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext</span><br><span class=line>5）、添加BeanPostProcessor【ApplicationListenerDetector】</span><br><span class=line>6）、添加编译时的AspectJ；</span><br><span class=line>7）、给BeanFactory中注册一些能用的组件；</span><br><span class=line>	environment【ConfigurableEnvironment】、</span><br><span class=line>	systemProperties【Map&LTString, Object>】、</span><br><span class=line>	systemEnvironment【Map&LTString, Object>】</span><br></pre></table></figure><h3 id=4、postProcessBeanFactory-beanFactory><a class=headerlink href=#4、postProcessBeanFactory-beanFactory title=4、postProcessBeanFactory(beanFactory)></a>4、postProcessBeanFactory(beanFactory)</h3><p><strong>BeanFactory准备完成后的后置处理工作，默认空，留给子类重写实现</strong>；<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>1）、子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置。</span><br></pre></table></figure><h3 id=5、invokeBeanFactoryPostProcessors-beanFactory><a class=headerlink href=#5、invokeBeanFactoryPostProcessors-beanFactory title=5、invokeBeanFactoryPostProcessors(beanFactory)></a>5、invokeBeanFactoryPostProcessors(beanFactory)</h3><p>执行BeanFactoryPostProcessor方法；<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line>BeanFactoryPostProcessor：BeanFactory后置处理器在BeanFactory标准初始化之后执行；</span><br><span class=line>两个接口：BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor</span><br><span class=line></span><br><span class=line>1）、执行BeanFactoryPostProcessor的方法；</span><br><span class=line>先执行BeanDefinitionRegistryPostProcessor</span><br><span class=line>	1）、获取所有的BeanDefinitionRegistryPostProcessor；</span><br><span class=line>	2）、先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor、</span><br><span class=line>		postProcessor.postProcessBeanDefinitionRegistry(registry)</span><br><span class=line>	3）、再执行实现了Ordered顺序接口的BeanDefinitionRegistryPostProcessor；</span><br><span class=line>		postProcessor.postProcessBeanDefinitionRegistry(registry)</span><br><span class=line>	4）、最后执行没有实现任何优先级或者是顺序接口的BeanDefinitionRegistryPostProcessors；</span><br><span class=line>		postProcessor.postProcessBeanDefinitionRegistry(registry)</span><br><span class=line>再执行BeanFactoryPostProcessor的方法</span><br><span class=line>	1）、获取所有的BeanFactoryPostProcessor</span><br><span class=line>	2）、先执行实现了PriorityOrdered优先级接口的BeanFactoryPostProcessor、</span><br><span class=line>		postProcessor.postProcessBeanFactory()</span><br><span class=line>	3）、在执行实现了Ordered顺序接口的BeanFactoryPostProcessor；</span><br><span class=line>		postProcessor.postProcessBeanFactory()</span><br><span class=line>	4）、最后执行没有实现任何优先级或者是顺序接口的BeanFactoryPostProcessor；</span><br><span class=line>		postProcessor.postProcessBeanFactory()</span><br></pre></table></figure><h3 id=6、registerBeanPostProcessors-beanFactory><a class=headerlink href=#6、registerBeanPostProcessors-beanFactory title=6、registerBeanPostProcessors(beanFactory)></a>6、registerBeanPostProcessors(beanFactory)</h3><p>注册BeanPostProcessor（Bean后置处理器）<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line>不同接口类型的BeanPostProcessor；在Bean创建前后的执行时机是不一样的</span><br><span class=line>	BeanPostProcessor、</span><br><span class=line>	DestructionAwareBeanPostProcessor、</span><br><span class=line>	InstantiationAwareBeanPostProcessor、</span><br><span class=line>	SmartInstantiationAwareBeanPostProcessor、</span><br><span class=line>	MergedBeanDefinitionPostProcessor【internalPostProcessors】、</span><br><span class=line>		</span><br><span class=line>1）、获取所有的BeanPostProcessor;增强器可以通过PriorityOrdered、Ordered接口来设置执行优先级。</span><br><span class=line>2）、先注册实现PriorityOrdered接口的BeanPostProcessor，把每一个BeanPostProcessor添加到BeanFactory中。</span><br><span class=line>3）、再注册实现Ordered接口BeanPostProcessor。</span><br><span class=line>4）、最后注册没有实现任何优先级接口的BeanPostProcessor。</span><br><span class=line>5）、最终注册MergedBeanDefinitionPostProcessor；</span><br><span class=line>6）、注册一个ApplicationListenerDetector；在Bean创建完成后检查是否是ApplicationListener，如果是则将其添加到上下文中。</span><br></pre></table></figure><h3 id=7、initMessageSource><a class=headerlink href=#7、initMessageSource title=7、initMessageSource()></a>7、initMessageSource()</h3><p>初始化MessageSource组件（做国际化功能；消息绑定，消息解析）；<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line>1）、获取BeanFactory</span><br><span class=line>2）、检查容器中是否有id为messageSource，类型是MessageSource的组件。</span><br><span class=line>	如果有赋值给messageSource，如果没有自己创建一个DelegatingMessageSource；</span><br><span class=line>	MessageSource：取出国际化配置文件中的某个key的值；能按照区域信息获取；</span><br><span class=line>3）、把创建好的MessageSource注册到容器中，以后获取国际化配置文件值时，可自动注入MessageSource；</span><br></pre></table></figure><h3 id=8、initApplicationEventMulticaster><a class=headerlink href=#8、initApplicationEventMulticaster title=8、initApplicationEventMulticaster()></a>8、initApplicationEventMulticaster()</h3><p>初始化事件派发器；<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>1）、获取BeanFactory</span><br><span class=line>2）、从BeanFactory中获取ApplicationEventMulticaster；</span><br><span class=line>3）、如果上一步没有配置；则会创建一个SimpleApplicationEventMulticaster</span><br><span class=line>4）、将创建的ApplicationEventMulticaster添加到BeanFactory中，以后其他组件直接自动注入</span><br></pre></table></figure><h3 id=9、onRefresh><a class=headerlink href=#9、onRefresh title=9、onRefresh()></a>9、onRefresh()</h3><p>默认为空，留给子容器（子类）实现。<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>1、子类可重写该方法，容器刷新时可自定义逻辑；</span><br></pre></table></figure><h3 id=10、registerListeners><a class=headerlink href=#10、registerListeners title=10、registerListeners()></a>10、registerListeners()</h3><p>把容器中所有ApplicationListener注册进来；<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>1、从容器中拿到所有的ApplicationListener</span><br><span class=line>2、将每个监听器添加到事件派发器中；</span><br><span class=line>	getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class=line>3、派发之前生成的事件；</span><br></pre></table></figure><h3 id=11、finishBeanFactoryInitialization-beanFactory><a class=headerlink href=#11、finishBeanFactoryInitialization-beanFactory title=11、finishBeanFactoryInitialization(beanFactory)></a>11、finishBeanFactoryInitialization(beanFactory)</h3><p><strong>初始化剩下的所有单实例 bean</strong>；<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br></pre><td class=code><pre><span class=line>1、beanFactory.preInstantiateSingletons();初始化后剩下的单实例bean</span><br><span class=line>	1）、获取容器中的所有Bean，依次进行初始化和创建对象</span><br><span class=line>	2）、获取Bean定义信息；RootBeanDefinition</span><br><span class=line>	3）、Bean不是抽象的，是单实例的，不是懒加载；</span><br><span class=line>		1）、判断是否是FactoryBean（是否是实现FactoryBean接口的Bean）</span><br><span class=line>		2）、若不是工厂Bean，则利用getBean(beanName)创建对象</span><br><span class=line>			0、getBean(beanName)； ioc.getBean();</span><br><span class=line>			1、doGetBean(name, null, null, false);</span><br><span class=line>			2、先获取缓存中的单例Bean。若缓存中有说明先前已经创建过。</span><br><span class=line>				从singletonObjects = new ConcurrentHashMap&LTString, Object>(256);中获取</span><br><span class=line>			3、缓存中没有，执行Bean创建流程；</span><br><span class=line>			4、标记当前bean已经被创建</span><br><span class=line>			5、获取Bean定义信息；</span><br><span class=line>			6、【获取当前Bean依赖的其他Bean;如果有按照getBean()把依赖的Bean先创建出来；】</span><br><span class=line>			7、启动单实例Bean的创建流程；</span><br><span class=line>				1）、createBean(beanName, mbd, args);</span><br><span class=line>				2）、resolveBeforeInstantiation(beanName, mbdToUse);让Bean增强器先拦截返回代理对象；</span><br><span class=line>				【InstantiationAwareBeanPostProcessor】：提前执行；</span><br><span class=line>					- 先触发：postProcessBeforeInstantiation()；看是否已经创建过Bean。</span><br><span class=line>					- 如果已经创建过Bean，那么触发postProcessAfterInitialization()；看是否需要代理，若需要代理则创建代理对象并返回，否则直接返回原始对象。</span><br><span class=line>				    - 如果没有创建过Bean，则调用3）</span><br><span class=line>				3）、Object beanInstance = doCreateBean(beanName, mbdToUse, args);创建Bean</span><br><span class=line>					 1）、【创建Bean实例】；createBeanInstance(beanName, mbd, args);</span><br><span class=line>						利用 工厂方法 或 构造器 创建出Bean实例；</span><br><span class=line>					 2）、applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class=line>						调用MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class=line>					 3）、【Bean属性赋值】populateBean(beanName, mbd, instanceWrapper);</span><br><span class=line>						赋值之前：</span><br><span class=line>						1）、拿到InstantiationAwareBeanPostProcessor后置处理器；</span><br><span class=line>							postProcessAfterInstantiation()；</span><br><span class=line>						2）、拿到InstantiationAwareBeanPostProcessor后置处理器；</span><br><span class=line>							postProcessPropertyValues()；</span><br><span class=line>						3）、设置Bean的属性值；利用setter方法等为属性赋值；</span><br><span class=line>							applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class=line>					 4）、【Bean初始化】initializeBean(beanName, exposedObject, mbd);</span><br><span class=line>						1）、【执行Aware接口方法】invokeAwareMethods(beanName, bean);</span><br><span class=line>							BeanNameAware\BeanClassLoaderAware\BeanFactoryAware</span><br><span class=line>						2）、【执行后置处理器的初始化之前】applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class=line>							BeanPostProcessor.postProcessBeforeInitialization（）;</span><br><span class=line>						3）、【执行初始化方法】invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class=line>							1）、是否实现了InitializingBean接口；是则执行该接口的初始化方法；</span><br><span class=line>							2）、是否自定义初始化方法；</span><br><span class=line>						4）、【执行后置处理器初始化之后】applyBeanPostProcessorsAfterInitialization</span><br><span class=line>							BeanPostProcessor.postProcessAfterInitialization()；</span><br><span class=line>					 5）、注册Bean的销毁方法；</span><br><span class=line>				4）、将创建的Bean添加到缓存中singletonObjects；</span><br><span class=line>			ioc容器就是这些Map；很多的Map里面保存了单实例Bean，环境信息。。。。；</span><br><span class=line></span><br><span class=line>所有Bean都利用getBean创建完成以后；</span><br><span class=line>检查所有的Bean是否是SmartInitializingSingleton接口的，如果是，就执行afterSingletonsInstantiated()；</span><br></pre></table></figure><h3 id=12、finishRefresh><a class=headerlink href=#12、finishRefresh title=12、finishRefresh()></a>12、finishRefresh()</h3><p>最后一步：<strong>发布相应的事件</strong>。（完成此上下文的刷新，调用<code>LifecycleProcessor.onRefresh()</code>方法并发布org.springframework.context.event.ContextRefreshedEvent 事件）<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line>1）、initLifecycleProcessor();初始化与生命周期有关的后置处理器（LifecycleProcessor）</span><br><span class=line>	默认从容器中找是否有lifecycleProcessor的组件【LifecycleProcessor】，如果没有new DefaultLifecycleProcessor()加入到容器；</span><br><span class=line>	写一个LifecycleProcessor实现类，可以在BeanFactory</span><br><span class=line>		void onRefresh();</span><br><span class=line>		void onClose();	</span><br><span class=line>2）、getLifecycleProcessor().onRefresh();</span><br><span class=line>	拿到前面定义的生命周期处理器（BeanFactory），回调onRefresh()；</span><br><span class=line>3）、publishEvent(new ContextRefreshedEvent(this));发布容器刷新完成事件；</span><br><span class=line>4）、liveBeansView.registerApplicationContext(this);</span><br></pre></table></figure><h3 id=13、总结><a class=headerlink href=#13、总结 title=13、总结></a>13、总结</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line>1）、Spring容器启动时，会先保存所有Bean定义信息；</span><br><span class=line>	1）、xml注册bean；&LTbean></span><br><span class=line>	2）、注解注册Bean；@Service、@Component、@Bean、xxx</span><br><span class=line>2）、Spring容器会在合适时机创建Bean</span><br><span class=line>	1）、用到某个bean时，用getBean创建bean，建好以后保存在容器中；</span><br><span class=line>	2）、统一创建剩下的所有bean：inishBeanFactoryInitialization()；</span><br><span class=line>3）、后置处理器；BeanPostProcessor</span><br><span class=line>	1）、每一个bean创建完成，都会使用各种后置处理器进行处理；来增强bean的功能；</span><br><span class=line>		AutowiredAnnotationBeanPostProcessor:处理自动注入</span><br><span class=line>		AnnotationAwareAspectJAutoProxyCreator:来做AOP功能；</span><br><span class=line>		xxx....</span><br><span class=line>		增强的功能注解：</span><br><span class=line>		AsyncAnnotationBeanPostProcessor</span><br><span class=line>		....</span><br><span class=line>4）、事件驱动模型；</span><br><span class=line>	ApplicationListener；事件监听；</span><br><span class=line>	ApplicationEventMulticaster；事件派发：</span><br></pre></table></figure><h2 id=2、BeanPostProcessor与BeanFactoryPostProcessor><a class=headerlink href=#2、BeanPostProcessor与BeanFactoryPostProcessor title=2、BeanPostProcessor与BeanFactoryPostProcessor></a>2、BeanPostProcessor与BeanFactoryPostProcessor</h2><h3 id=2-1、简介><a class=headerlink href=#2-1、简介 title=2.1、简介></a>2.1、简介</h3><p><strong>BeanPostProcessor是bean后置处理器，会在bean创建过程中的初始化前后执行</strong>。<p><strong>BeanFactoryPostProcessor是beanFactory后置处理器，会在BeanFactory标准初始化之后执行</strong>，此时所有的bean定义已经保存加载到beanFactory，但还未创建bean实例。其作用就是增强扩展BeanFactory的功能；<h3 id=2-2、BeanFactoryPostProcessor原理><a class=headerlink href=#2-2、BeanFactoryPostProcessor原理 title=2.2、BeanFactoryPostProcessor原理></a>2.2、BeanFactoryPostProcessor原理</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line>1、BeanFactoryPostProcessor</span><br><span class=line>	1)、ioc容器创建对象</span><br><span class=line>    2)、invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=line>        找到所有的BeanFactoryPostProcessor并执行他们的方法：</span><br><span class=line>            1）、在BeanFactory中找到所有类型是BeanFactoryPostProcessor的组件，并执行他们的方法</span><br><span class=line>            2）、在 初始化创建其他组件前 执行。</span><br><span class=line>            </span><br><span class=line>2、BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor</span><br><span class=line>	postProcessBeanDefinitionRegistry();</span><br><span class=line>	在所有bean定义将要被加载，且bean实例还未创建时执行；</span><br><span class=line>	优先于BeanFactoryPostProcessor执行；</span><br><span class=line>	利用BeanDefinitionRegistryPostProcessor给容器中再额外添加一些组件；</span><br><span class=line>	</span><br><span class=line>原理：</span><br><span class=line>	1）、ioc创建对象</span><br><span class=line>	2）、refresh()-》invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class=line>	3）、从容器中获取到所有的BeanDefinitionRegistryPostProcessor组件。</span><br><span class=line>		1、依次触发所有的postProcessBeanDefinitionRegistry()方法</span><br><span class=line>		2、再来触发postProcessBeanFactory()方法（BeanFactoryPostProcessor）；</span><br><span class=line>	4）、再来从容器中找到BeanFactoryPostProcessor组件；然后依次触发postProcessBeanFactory()方法</span><br></pre></table></figure><h2 id=3、ApplicationListener><a class=headerlink href=#3、ApplicationListener title=3、ApplicationListener></a>3、ApplicationListener</h2><h3 id=3-1、简介><a class=headerlink href=#3-1、简介 title=3.1、简介></a>3.1、简介</h3><p>监听容器中发布的事件。<code>public interface ApplicationListener&LTE extends ApplicationEvent></code>用来<br>监听 ApplicationEvent 及其子事件；<h3 id=3-2、开发步骤><a class=headerlink href=#3-2、开发步骤 title=3.2、开发步骤></a>3.2、开发步骤</h3><pre><code>1）、写一个监听器（ApplicationListener实现类）来监听某个事件（ApplicationEvent及其子类）
    @EventListener;
    原理：使用EventListenerMethodProcessor处理器来解析方法上的@EventListener；
2）、把监听器加入到容器；
3）、只要容器中有相关事件的发布，我们就能监听到这个事件；
    ContextRefreshedEvent：容器刷新完成（所有bean都完全创建）会发布这个事件；
    ContextClosedEvent：关闭容器会发布这个事件；
4）、发布一个事件：
    applicationContext.publishEvent()；
</code></pre><h3 id=3-3、原理><a class=headerlink href=#3-3、原理 title=3.3、原理></a>3.3、原理</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line>【事件发布流程】：</span><br><span class=line>1、publishEvent(new ContextRefreshedEvent(this));</span><br><span class=line>	1）、获取事件的多播器（派发器）：getApplicationEventMulticaster()</span><br><span class=line>	2）、multicastEvent派发事件：</span><br><span class=line>		1）、获取到所有的ApplicationListener，遍历每一项。</span><br><span class=line>			for (final ApplicationListener&LT?> listener : getApplicationListeners(event, type)) </span><br><span class=line>		2）、如果有Executor，使用Executor进行异步派发；</span><br><span class=line>			Executor executor = getTaskExecutor();</span><br><span class=line>		3）、否则，同步执行listener方法；invokeListener(listener, event);</span><br><span class=line>			 拿到listener回调onApplicationEvent方法；</span><br><span class=line></span><br><span class=line>【事件多播器（派发器）】</span><br><span class=line>容器创建对象：refresh();</span><br><span class=line>    1）、initApplicationEventMulticaster();初始化ApplicationEventMulticaster；</span><br><span class=line>        1）、先看容器中 是否有id=“applicationEventMulticaster”的组件；</span><br><span class=line>        2）、如果没有则创建 this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);</span><br><span class=line>        3）、将之加入到容器，后期可在其他组件要派发事件时自动注入这个applicationEventMulticaster；</span><br><span class=line></span><br><span class=line>【容器中有哪些监听器】</span><br><span class=line>容器创建对象：refresh();</span><br><span class=line>    1）、registerListeners();</span><br><span class=line>        从容器中拿到所有的监听器，把他们注册到applicationEventMulticaster中；</span><br><span class=line>        String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);</span><br><span class=line>        //将listener注册到ApplicationEventMulticaster中</span><br><span class=line>        getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class=line>	</span><br><span class=line>SmartInitializingSingleton 原理：->afterSingletonsInstantiated();</span><br><span class=line>	1）、ioc容器创建对象并refresh()；</span><br><span class=line>	2）、finishBeanFactoryInitialization(beanFactory);初始化剩下的单实例bean；</span><br><span class=line>		1）、先创建所有的单实例bean；getBean();</span><br><span class=line>		2）、获取所有创建好的单实例bean，判断是否是SmartInitializingSingleton类型的；</span><br><span class=line>			如果是就调用afterSingletonsInstantiated();</span><br></pre></table></figure><h2 id=3、组件注入><a class=headerlink href=#3、组件注入 title=3、组件注入></a>3、组件注入</h2><h3 id=3-1、注入类型><a class=headerlink href=#3-1、注入类型 title=3.1、注入类型></a>3.1、注入类型</h3><h4 id=setter注入><a class=headerlink href=#setter注入 title=setter注入></a>setter注入</h4><h4 id=构造注入><a class=headerlink href=#构造注入 title=构造注入></a>构造注入</h4><h4 id=接口注入><a class=headerlink href=#接口注入 title=接口注入></a>接口注入</h4><h4 id=注解注入><a class=headerlink href=#注解注入 title=注解注入></a>注解注入</h4><p>（1）Spring注解<ol><li><p><strong>@Autowired / @Qualifier</strong></p> <p>@Autowired默认按照类型装配注入，默认情况下它要求依赖对象必须存在，如果允许为null，可以设置它的required属性为false，如果想按照名称来注入，则需要结合@Qualifier一起使用；</p><li><p><strong>@Primary</strong></p> <p>自动装配时要使用的首选bean。</p><li><p><strong>@Import</strong></p> <p>可通过多种方式（class）导入多个组件。</p><li><p><strong>@ImportResource</strong></p> <p>通过导入bean.xml文件来注入组件。</p></ol><p>（2）Java注解<ol><li><strong>@Resource（JSR 250）</strong></ol><p>@Resource默认按照名称注入，只有找不到与名称匹配的bean时才会按照类型来注入；<ol start=2><li><p><strong>@Inject（JSR 330）</strong></p> <p>需要导入javax.inject包，和Autowired的功能一样。没有required=false的功能；</p></ol><h4 id=文件属性注入><a class=headerlink href=#文件属性注入 title=文件属性注入></a>文件属性注入</h4><ul><li><p><strong>@PropertySource(value = {“jdbc.properties”})</strong></p> <p>加载properties文件中配置的以 db 开头的属性配置信息，并会自动赋值给变量。</p><li><p><strong>@ConfigurationProperties(prefix = “db”) + @EnableConfigurationProperties(xxx.class)</strong></p> <p>xxx类上需要加注解<code>@ConfigurationProperties(prefix = "db")</code>，然后在配置类中加注解<code>@EnableConfigurationProperties(xxx.class)</code>来开启属性填充配置。这样会将文件配置信息赋值给变量。</p></ul><h3 id=3-2、Autowired注解><a class=headerlink href=#3-2、Autowired注解 title=3.2、Autowired注解></a>3.2、Autowired注解</h3><p>@Autowired相关类架构如下所示：<p><img alt=image-20210320173030372 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20210320173030372.png><h2 id=4、循环依赖><a class=headerlink href=#4、循环依赖 title=4、循环依赖></a>4、循环依赖</h2><h3 id=4-1、前言><a class=headerlink href=#4-1、前言 title=4.1、前言></a>4.1、前言</h3><p>创建Spring bean本质上是创建对象，一个完整对象包含两部分：<strong>对象实例化和对象属性初始化</strong>。<p>Spring Bean的创建分为三步：<ol><li><strong>实例化</strong>：对应方法 AbstractAutowireCapableBeanFactory中的createBeanInstance方法。<li><strong>属性注入</strong>：对应方法 AbstractAutowireCapableBeanFactory的populateBean方法。<li><strong>初始化</strong>：对应方法 AbstractAutowireCapableBeanFactory的initializeBean方法。</ol><p><strong>Spring Bean通过 反射 实现序列化，对象属性在 对象实例化后 设置</strong>。<h3 id=4-2、循环依赖问题><a class=headerlink href=#4-2、循环依赖问题 title=4.2、循环依赖问题></a>4.2、循环依赖问题</h3><p>循环依赖的产生可能有多种情况，例如：<ul><li>A的构造方法中依赖了B的实例对象，同时B的构造方法中依赖了A的实例对象。<li>A的构造方法中依赖了B的实例对象，同时B的某个field或者setter需要A的实例对象，以及反之。<li>A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象，以及反之。</ul><p>以 第三种为例 来 分析：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">A</span> {</span><br><span class=line>    <span class=keyword>private</span> B b;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setB</span><span class=params>(B b)</span> {</span><br><span class=line>        <span class=built_in>this</span>.b = b;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line>---</span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">B</span> {</span><br><span class=line>  <span class=keyword>private</span> A a;</span><br><span class=line>  <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setA</span><span class=params>(A a)</span> {</span><br><span class=line>    <span class=built_in>this</span>.a = a;</span><br><span class=line>  }</span><br><span class=line>}</span><br></pre></table></figure><p><strong>首先，Spring实例化bean是通过ApplicationContext.getBean()方法触发开启</strong>。<p>如果 所需对象 依赖 另一对象，那么会先创建所需对象，然后递归调用<code>ApplicationContext.getBean()</code>来获取依赖对象，然后将依赖对象注入当前所需对象。<p>以先初始化对象A为例，Spring执行逻辑如下：<ol><li>首先Spring尝试通过ApplicationContext.getBean()方法 获取A对象实例，由于Spring容器中还没有A对象实例，因此会去创建一个A对象。创建A对象的过程中发现依赖了B对象，然后通过ApplicationContext.getBean()方法获取B对象实例。但此时Spring容器中没有B对象实例，因此会先创建一个B对象的实例。<li>Spring创建B对象之后，发现B对象依赖了A对象实例，故调用ApplicationContext.getBean()方法获取A对象实例。因为Spring中已经有了A对象实例，虽然只是半成品（其属性b还未初始化），但也是目标bean，故会将该A对象实例返回。此时，B对象的属性a就设置进去了，然后将B对象实例返回，并设置到A对象的属性b中，最终完成对象A和对象B的实例化。</ol><h3 id=4-3、解决循环依赖><a class=headerlink href=#4-3、解决循环依赖 title=4.3、解决循环依赖></a>4.3、解决循环依赖</h3><p><strong>单例对象在IOC容器生命周期内只有一个实例，为解决 单例 循环依赖问题，可以使用三级缓存</strong>（DefaultSingletonBeanRegistry.java中定义）。<p>三级缓存源码定义如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment>/** 一级缓存 - 存放完整的Bean，直接可以使用。 */</span></span><br><span class=line><span class=keyword>private</span> <span class=keyword>final</span> Map&LTString, Object> singletonObjects = <span class=keyword>new</span> <span class="title class_">ConcurrentHashMap</span>&LTString, Object>(<span class=number>256</span>);</span><br><span class=line><span class=comment>/** 二级缓存 - 存放早期Bean的引用，Bean的属性还没有初始化。 */</span></span><br><span class=line><span class=keyword>private</span> <span class=keyword>final</span> Map&LTString, Object> earlySingletonObjects = <span class=keyword>new</span> <span class="title class_">HashMap</span>&LTString, Object>(<span class=number>16</span>);</span><br><span class=line><span class=comment>/** 三级缓存 - 存放实例化完成的Bean工厂。 */</span></span><br><span class=line><span class=keyword>private</span> <span class=keyword>final</span> Map&LTString, ObjectFactory&LT?>> singletonFactories = <span class=keyword>new</span> <span class="title class_">HashMap</span>&LTString, ObjectFactory&LT?>>(<span class=number>16</span>);</span><br></pre></table></figure><p>Spring首先从一级缓存<strong>singletonObjects</strong>中获取，如果获取不到，且对象正在创建中，就会从二级缓存<strong>earlySingletonObjects</strong>中获取，如果还是获取不到且允许通过<strong>调用 <code>singletonFactories</code> 的 <code>getObject()</code>方法获取</strong>，那就从三级缓存获取，<strong>如果获取到了，那就放入二级缓存，并将三级缓存中的删除</strong>。具体逻辑如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=meta>@Nullable</span></span><br><span class=line><span class=keyword>protected</span> Object <span class="title function_">getSingleton</span><span class=params>(String beanName, <span class=type>boolean</span> allowEarlyReference)</span> {</span><br><span class=line>    <span class=comment>// Quick check for existing instance without full singleton lock</span></span><br><span class=line>    <span class=type>Object</span> <span class=variable>singletonObject</span> <span class=operator>=</span> <span class=built_in>this</span>.singletonObjects.get(beanName);</span><br><span class=line>    <span class=keyword>if</span> (singletonObject == <span class=literal>null</span> && isSingletonCurrentlyInCreation(beanName)) {</span><br><span class=line>        singletonObject = <span class=built_in>this</span>.earlySingletonObjects.get(beanName);</span><br><span class=line>        <span class=keyword>if</span> (singletonObject == <span class=literal>null</span> && allowEarlyReference) {</span><br><span class=line>            <span class=keyword>synchronized</span> (<span class=built_in>this</span>.singletonObjects) {</span><br><span class=line>                <span class=comment>// Consistent creation of early reference within full singleton lock</span></span><br><span class=line>                singletonObject = <span class=built_in>this</span>.singletonObjects.get(beanName);</span><br><span class=line>                <span class=keyword>if</span> (singletonObject == <span class=literal>null</span>) {</span><br><span class=line>                    singletonObject = <span class=built_in>this</span>.earlySingletonObjects.get(beanName);</span><br><span class=line>                    <span class=keyword>if</span> (singletonObject == <span class=literal>null</span>) {</span><br><span class=line>                        ObjectFactory&LT?> singletonFactory = <span class=built_in>this</span>.singletonFactories.get(beanName);</span><br><span class=line>                        <span class=keyword>if</span> (singletonFactory != <span class=literal>null</span>) {</span><br><span class=line>                            singletonObject = singletonFactory.getObject();</span><br><span class=line>                            <span class=built_in>this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class=line>                            <span class=built_in>this</span>.singletonFactories.remove(beanName);</span><br><span class=line>                        }</span><br><span class=line>                    }</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> singletonObject;</span><br><span class=line>}</span><br></pre></table></figure><p><strong>Spring解决循环依赖的诀窍就在于三级缓存——singletonFactories。这个cache类型是接口ObjectFactory。</strong>这个接口在下面代码中被引用：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>protected</span> <span class=keyword>void</span> <span class="title function_">addSingletonFactory</span><span class=params>(String beanName, ObjectFactory&LT?> singletonFactory)</span> {</span><br><span class=line>    Assert.notNull(singletonFactory, <span class=string>"Singleton factory must not be null"</span>);</span><br><span class=line>    <span class=keyword>synchronized</span> (<span class=built_in>this</span>.singletonObjects) {</span><br><span class=line>        <span class=keyword>if</span> (!<span class=built_in>this</span>.singletonObjects.containsKey(beanName)) {</span><br><span class=line>            <span class=built_in>this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class=line>            <span class=built_in>this</span>.earlySingletonObjects.remove(beanName);</span><br><span class=line>            <span class=built_in>this</span>.registeredSingletons.add(beanName);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>上面代码是解决循环依赖的关键，这段代码发生在 createBeanInstance 之后，也就是说此时单例对象已经被创建出来(调用了构造器)，虽然还不完整，但是已经能被认出来了（根据对象引用能定位到堆中的对象），所以Spring此时将这个对象提前曝光出来让大家认识，让大家使用。<h3 id=4-4、为何需要三级缓存><a class=headerlink href=#4-4、为何需要三级缓存 title=4.4、为何需要三级缓存></a>4.4、为何需要三级缓存</h3><p>Spring处理AOP代理的规则是：<strong>通过后置处理器 <code>AnnotationAwareAspectJAutoProxyCreator</code>在Bean生命周期最后一步完成AOP代理，而并非实例化后就立马进行AOP代理</strong>。<p>如果对A进行了AOP代理，那么意味着 B对象中注入的A将是一个A的代理对象而并非A的原始对象。<p>所以，Spring定义一个缓存 <strong>singletonFactories</strong> 来存放Bean工厂对象ObjectFactory。该工厂对象的作用是<strong>延迟实例化阶段对象代理的生成，而只有真正发生循环依赖时才会生成代理对象，否则只会创建一个工厂对象并放入到三级缓存中</strong>。<p>注意事项：<ol><li><strong>如果A被代理了，但没有发生循环依赖。那么依然会将其添加到三级缓存中。</strong><li><strong>如果使用二级缓存，那么Bean实例化后会立即创建代理。这样做也就违背了Spring在Bean生命周期最后完成AOP代理的设计。</strong></ol><h3 id=4-5、三级缓存会提高效率吗？><a class=headerlink href=#4-5、三级缓存会提高效率吗？ title=4.5、三级缓存会提高效率吗？></a>4.5、三级缓存会提高效率吗？</h3><p>不会提高，下面分两种场景来讨论。<ul><li><p>场景一：没有AOP代理的循环依赖</p> <p>该情况下三级缓存根本没用，所以不存在提高效率。</p><li><p>场景二：存在AOP代理的循环依赖</p> <ul><li>如果使用三级缓存，那么只会在B依赖A时才会为A创建代理。<li>如果不使用三级缓存，则会在A实例化后立即为A创建代理，并将代理放入二级缓存。</ul></ul><h3 id=4-6、总结><a class=headerlink href=#4-6、总结 title=4.6、总结></a>4.6、总结</h3><p><strong>如果使用二级缓存解决循环依赖，意味着所有Bean在实例化后就要完成AOP代理，这样就违背了Spring设计原则</strong>。（Spring的设计规则就是通过后置处理器<code>AnnotationAwareAspectJAutoProxyCreator</code>在Bean生命周期最后一步完成AOP代理，而并非是在实例化后来执行AOP代理。）<h1 id=AOP（切面编程）><a class=headerlink href=#AOP（切面编程） title=AOP（切面编程）></a>AOP（切面编程）</h1><h2 id=2、AOP动态代理><a class=headerlink href=#2、AOP动态代理 title=2、AOP动态代理></a>2、AOP动态代理</h2><h3 id=2-1、简介-1><a class=headerlink href=#2-1、简介-1 title=2.1、简介></a>2.1、简介</h3><p>切面编程是指<strong>程序运行期间在指定方法的指定位置动态植入增强逻辑的编程方式。</strong><h3 id=2-2、代码实现><a class=headerlink href=#2-2、代码实现 title=2.2、代码实现></a>2.2、代码实现</h3><ol><li>导入aop模块；Spring AOP：(spring-aspects)<li>定义一个业务逻辑类（MathCalculator）；在业务逻辑运行的时候将日志进行打印（方法之前、方法运行结束、方法出现异常，xxx）<li>定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知MathCalculator.div运行到哪里然后执行；<ul><li>前置通知(@Before)：logStart：在目标方法(div)运行之前运行<li>后置通知(@After)：logEnd：在目标方法(div)运行结束之后运行（无论方法正常结束还是异常结束）<li>返回通知(@AfterReturning)：logReturn：在目标方法(div)正常返回之后运行<li>异常通知(@AfterThrowing)：logException：在目标方法(div)出现异常以后运行<li>环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()）</ul><li>给切面类的目标方法标注何时何地运行（通知注解）；<li>将切面类和业务逻辑类（目标方法所在类）都加入到容器中;<li>必须告诉Spring哪个类是切面类（给切面类上加一个注解：@Aspect）<li>给配置类中加 @EnableAspectJAutoProxy 【开启基于注解的aop模式】</ol><h2 id=3、AOP原理><a class=headerlink href=#3、AOP原理 title=3、AOP原理></a>3、AOP原理</h2><h3 id=3-1、-EnableAspectJAutoProxy><a class=headerlink href=#3-1、-EnableAspectJAutoProxy title=3.1、@EnableAspectJAutoProxy></a>3.1、@EnableAspectJAutoProxy</h3><p>@EnableAspectJAutoProxy是什么？<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line>1、@Import(AspectJAutoProxyRegistrar.class)：给容器中导入AspectJAutoProxyRegistrar</span><br><span class=line>   利用AspectJAutoProxyRegistrar自定义给容器中注册bean；BeanDefinetion</span><br><span class=line>   internalAutoProxyCreator=AnnotationAwareAspectJAutoProxyCreator</span><br><span class=line>   给容器中注册一个AnnotationAwareAspectJAutoProxyCreator；</span><br><span class=line>2、AnnotationAwareAspectJAutoProxyCreator：</span><br><span class=line>     AnnotationAwareAspectJAutoProxyCreator</span><br><span class=line>     	->AspectJAwareAdvisorAutoProxyCreator</span><br><span class=line>     		->AbstractAdvisorAutoProxyCreator</span><br><span class=line>     			->AbstractAutoProxyCreator</span><br><span class=line>     				implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware</span><br><span class=line>     				关注后置处理器（在bean初始化完成前后做事情）、自动装配BeanFactory</span><br><span class=line></span><br><span class=line>AbstractAutoProxyCreator.setBeanFactory()</span><br><span class=line>AbstractAutoProxyCreator.有后置处理器的逻辑；</span><br><span class=line>AbstractAdvisorAutoProxyCreator.setBeanFactory()-》initBeanFactory()</span><br><span class=line>AnnotationAwareAspectJAutoProxyCreator.initBeanFactory()</span><br></pre></table></figure><h3 id=3-2、流程><a class=headerlink href=#3-2、流程 title=3.2、流程></a>3.2、流程</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br></pre><td class=code><pre><span class=line>1）、传入配置类，创建ioc容器</span><br><span class=line>2）、注册配置类，调用refresh（）刷新容器；</span><br><span class=line>3）、registerBeanPostProcessors(beanFactory);注册bean后置处理器来拦截bean的创建；</span><br><span class=line>  	1）、先获取ioc容器已经定义了的需要创建对象的所有BeanPostProcessor</span><br><span class=line>  	2）、给容器中注册其它BeanPostProcessor。</span><br><span class=line>  	3）、优先注册实现了PriorityOrdered接口的BeanPostProcessor；</span><br><span class=line>  	4）、再注册实现了Ordered接口的BeanPostProcessor；</span><br><span class=line>  	5）、再注册没有实现任何优先级接口的BeanPostProcessor；</span><br><span class=line>  	6）、注册BeanPostProcessor，实际上就是创建BeanPostProcessor对象并注入到容器中；</span><br><span class=line>  			创建internalAutoProxyCreator的BeanPostProcessor【AnnotationAwareAspectJAutoProxyCreator】</span><br><span class=line>  			1）、创建Bean的实例</span><br><span class=line>  			2）、populateBean；给bean的各种属性赋值</span><br><span class=line>  			3）、initializeBean：初始化bean；</span><br><span class=line>  					1）、invokeAwareMethods()：处理Aware接口的方法回调</span><br><span class=line>  					2）、applyBeanPostProcessorsBeforeInitialization()：应用后置处理器的postProcessBeforeInitialization（）</span><br><span class=line>  					3）、invokeInitMethods()；执行自定义的初始化方法</span><br><span class=line>  					4）、applyBeanPostProcessorsAfterInitialization()；执行后置处理器的postProcessAfterInitialization（）；</span><br><span class=line>  			4）、BeanPostProcessor(AnnotationAwareAspectJAutoProxyCreator)创建成功；--》aspectJAdvisorsBuilder</span><br><span class=line>  	7）、把BeanPostProcessor注册到BeanFactory中；</span><br><span class=line>  		beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class=line></span><br><span class=line>=====以上是创建和注册AnnotationAwareAspectJAutoProxyCreator的过程====</span><br><span class=line></span><br><span class=line>  	   AnnotationAwareAspectJAutoProxyCreator => InstantiationAwareBeanPostProcessor</span><br><span class=line>4）、finishBeanFactoryInitialization(beanFactory);完成BeanFactory初始化工作；创建剩下的单实例bean</span><br><span class=line>  	1）、遍历获取容器中所有的Bean，依次创建对象getBean(beanName);</span><br><span class=line>  		getBean->doGetBean()->getSingleton()-></span><br><span class=line>  	2）、执行 创建bean 逻辑</span><br><span class=line>  		【AnnotationAwareAspectJAutoProxyCreator在所有bean创建之前会有一个拦截，InstantiationAwareBeanPostProcessor会调用postProcessBeforeInstantiation()】</span><br><span class=line>  		1）、先从缓存中获取当前bean，如果能获取到，说明bean是之前被创建过的，直接使用，否则再创建；只要创建好的Bean都会被缓存起来。</span><br><span class=line>  		2）、创建bean：createBean（）</span><br><span class=line>  			AnnotationAwareAspectJAutoProxyCreator 会在任何bean创建之前先尝试返回bean的实例</span><br><span class=line>  			【BeanPostProcessor是在Bean对象创建完成后的初始化前后调用的】</span><br><span class=line>  			【InstantiationAwareBeanPostProcessor是在创建Bean实例之前先尝试用后置处理器返回对象】</span><br><span class=line>  			1）、resolveBeforeInstantiation(beanName, mbdToUse);解析BeforeInstantiation</span><br><span class=line>  				希望后置处理器在此能返回一个代理对象；如果能返回代理对象就使用，如果不能就继续</span><br><span class=line>  				1）、后置处理器先尝试返回对象；</span><br><span class=line>  					bean = applyBeanPostProcessorsBeforeInstantiation（）：</span><br><span class=line>  					拿到所有后置处理器，如果是InstantiationAwareBeanPostProcessor;</span><br><span class=line>  					就执行postProcessBeforeInstantiation</span><br><span class=line>  					if (bean != null) {</span><br><span class=line>						bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class=line>					}</span><br><span class=line>  				2）、doCreateBean(beanName, mbdToUse, args);真正的去创建一个bean实例；和3.6流程一样；</span><br></pre></table></figure><h3 id=3-3、AnnotationAwareAspectJAutoProxyCreator><a class=headerlink href=#3-3、AnnotationAwareAspectJAutoProxyCreator title=3.3、AnnotationAwareAspectJAutoProxyCreator></a>3.3、AnnotationAwareAspectJAutoProxyCreator</h3><p>AnnotationAwareAspectJAutoProxyCreator底层就是一个InstantiationAwareBeanPostProcessor。<h4 id=3-3-1、bean创建前，调用postProcessBeforeInstantiation><a class=headerlink href=#3-3-1、bean创建前，调用postProcessBeforeInstantiation title=3.3.1、bean创建前，调用postProcessBeforeInstantiation()></a>3.3.1、bean创建前，调用postProcessBeforeInstantiation()</h4><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>关心MathCalculator和LogAspect的创建</span><br><span class=line>1）、判断当前bean是否在advisedBeans中（保存了所有需要增强bean）</span><br><span class=line>2）、判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean，或者是否是切面（@Aspect）</span><br><span class=line>3）、是否需要跳过</span><br><span class=line>  	1）、获取候选的增强器（切面里面的通知方法）【List&LTAdvisor> candidateAdvisors】</span><br><span class=line>  		每一个封装的通知方法的增强器是 InstantiationModelAwarePointcutAdvisor；</span><br><span class=line>  		判断每一个增强器是否是 AspectJPointcutAdvisor 类型的；返回true</span><br><span class=line>  	2）、永远返回false</span><br></pre></table></figure><h4 id=3-3-2、创建对象><a class=headerlink href=#3-3-2、创建对象 title=3.3.2、创建对象></a>3.3.2、创建对象</h4><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line>postProcessAfterInitialization；</span><br><span class=line>return wrapIfNecessary(bean, beanName, cacheKey);//包装如果需要的情况下</span><br><span class=line>1）、获取当前bean的所有增强器（通知方法）  Object[]  specificInterceptors</span><br><span class=line>  	1、找到候选的所有的增强器（找哪些通知方法是需要切入当前bean方法的）</span><br><span class=line>  	2、获取到能在bean使用的增强器。</span><br><span class=line>  	3、给增强器排序</span><br><span class=line>2）、保存当前bean在advisedBeans中；</span><br><span class=line>3）、如果当前bean需要增强，创建当前bean的代理对象；</span><br><span class=line>  	1）、获取所有增强器（通知方法）</span><br><span class=line>  	2）、保存到proxyFactory</span><br><span class=line>  	3）、创建代理对象：Spring自动决定</span><br><span class=line>  		JdkDynamicAopProxy(config);jdk动态代理；</span><br><span class=line>  		ObjenesisCglibAopProxy(config);cglib的动态代理；</span><br><span class=line>4）、给容器中返回当前组件使用cglib增强了的代理对象；</span><br><span class=line>5）、以后容器中获取到的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程；</span><br></pre></table></figure><h4 id=3-3-3、目标方法执行><a class=headerlink href=#3-3-3、目标方法执行 title=3.3.3、目标方法执行></a>3.3.3、目标方法执行</h4><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line>容器中保存了组件的代理对象（cglib增强后的对象），这个对象里面保存了详细信息（比如增强器，目标对象，xxx）；</span><br><span class=line>1）、CglibAopProxy.intercept();拦截目标方法的执行</span><br><span class=line>2）、根据ProxyFactory对象获取将要执行的目标方法拦截器链；</span><br><span class=line>  	List&LTObject> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class=line>  	1）、List&LTObject> interceptorList保存所有拦截器 5</span><br><span class=line>  		一个默认的ExposeInvocationInterceptor 和 4个增强器；</span><br><span class=line>  	2）、遍历所有的增强器，将其转为Interceptor；</span><br><span class=line>  		registry.getInterceptors(advisor);</span><br><span class=line>  	3）、将增强器转为List&LTMethodInterceptor>；</span><br><span class=line>  		如果是MethodInterceptor，直接加入到集合中</span><br><span class=line>  		如果不是，使用AdvisorAdapter将增强器转为MethodInterceptor；</span><br><span class=line>  		转换完成返回MethodInterceptor数组；</span><br><span class=line>3）、如果没有拦截器链，直接执行目标方法;</span><br><span class=line>  	拦截器链（每一个通知方法又被包装为方法拦截器，利用MethodInterceptor机制）</span><br><span class=line>4）、如果有拦截器链，把需要执行的目标对象，目标方法，拦截器链等信息传入创建一个 CglibMethodInvocation 对象，</span><br><span class=line>  	并调用 Object retVal =  cglibMehthodInvocation.proceed();</span><br><span class=line>5）、拦截器链的触发过程;</span><br><span class=line>  	1)、如果没有拦截器执行目标方法，或者拦截器的索引和拦截器数组大小一样（指定到了最后一个拦截器）执行目标方法；</span><br><span class=line>  	2)、链式获取每一个拦截器，拦截器执行invoke方法，每一个拦截器等待下一个拦截器执行完成返回以后再来执行；</span><br><span class=line>  		拦截器链的机制，保证通知方法与目标方法的执行顺序；</span><br></pre></table></figure><h3 id=3-4、总结><a class=headerlink href=#3-4、总结 title=3.4、总结></a>3.4、总结</h3><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre><td class=code><pre><span class=line>1）、@EnableAspectJAutoProxy 开启AOP功能</span><br><span class=line>2）、@EnableAspectJAutoProxy 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator</span><br><span class=line>3）、AnnotationAwareAspectJAutoProxyCreator是一个后置处理器；</span><br><span class=line>4）、容器创建流程：</span><br><span class=line>  	1）、registerBeanPostProcessors（）注册后置处理器；创建AnnotationAwareAspectJAutoProxyCreator对象</span><br><span class=line>  	2）、finishBeanFactoryInitialization（）初始化剩下的单实例bean</span><br><span class=line>  		1）、创建业务逻辑组件和切面组件</span><br><span class=line>  		2）、AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程</span><br><span class=line>  		3）、组件创建完之后，判断组件是否需要增强</span><br><span class=line>  			是：切面的通知方法，包装成增强器（Advisor）；给业务逻辑组件创建一个代理对象（cglib）；</span><br><span class=line>5）、执行目标方法：</span><br><span class=line>  	1）、代理对象执行目标方法</span><br><span class=line>  	2）、CglibAopProxy.intercept()；</span><br><span class=line>  		1）、得到目标方法的拦截器链（增强器包装成拦截器MethodInterceptor）</span><br><span class=line>  		2）、利用拦截器的链式机制，依次进入每一个拦截器进行执行；</span><br><span class=line>  		3）、效果：</span><br><span class=line>  			正常执行：前置通知-》目标方法-》后置通知-》返回通知</span><br><span class=line>  			出现异常：前置通知-》目标方法-》后置通知-》异常通知</span><br></pre></table></figure><h1 id=MVC><a class=headerlink href=#MVC title=MVC></a>MVC</h1><h2 id=1、请求匹配><a class=headerlink href=#1、请求匹配 title=1、请求匹配></a>1、请求匹配</h2><ol><li>拿到处理器执行器链：getHandler(HttpServletRequest)。<ul><li>拿到所有HandlerMapping（默认一开始时有5个），进行遍历<ul><li>拿到处理器执行器链，如果没有则返回空：mapping.getHandler(HttpServletRequest)<ul><li>基于HttpServletRequest来匹配handlerMapping（RequestMappingHadnlerMapping）<li>路径与方法的映射信息保存在RMHM.mappingRegistry.mappingLookup（LinkedHashMap）中。<li>拿到与路径<code>/xxx</code>匹配的所有映射项，如果匹配项有多个，那么报错。否则将之保存起来候用。</ul></ul></ul></ol><blockquote><p><strong>默认5个HandlerMapping</strong>：RequestMappingHadnlerMapping、WelcomePageHandlerMapping、BeanNameUril xxx、RouterFunction xxx、SimpleUrl xxx</blockquote><h2 id=2、参数解析-返回结果><a class=headerlink href=#2、参数解析-返回结果 title=2、参数解析/返回结果></a>2、参数解析/返回结果</h2><ol><li><p>从处理器执行器链中找到能处理请求的Hadnler</p><li><p>通过handler拿到对应的 处理器适配器（HandlerAdapter）</p> <p>默认适配器有4种：RequestMappingHandlerAdapter、HandlerFunction-xxx、HttpRequest-xxx、SimpleController-xxx）</p><li><p>判断请求方式（Get/POST/HEAD…）</p><li><p>调用适配器的handler()方法:ha.handler(…)</p> <figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line>执行目标方法：invokeHandlerMethod(request, response, HandlerMethod)</span><br><span class=line>	- 设置 参数解析器（ArgumentResover，默认26个）解析参数</span><br><span class=line>	  （找到匹配的解析器和参数时，会将之缓存起来，以后来请求就不要重复解析了。）</span><br><span class=line>	  - Map/Model类型的参数，会返回一个BindingAwareModelMap，它既是Mode也是Map。</span><br><span class=line>		两者都可以通过mavContainer.getModel()获取到值。</span><br><span class=line>	- 设置 返回值处理器（ReturnValueHandlers，默认15个）处理返回结果</span><br><span class=line>		- 获取返回值类型</span><br><span class=line>		- 调用handlerReturnValue(...)方法 处理返回结果。</span><br><span class=line>			- 找到能处理结果的处理器（），然后处理。</span><br><span class=line>			 （比如处理@ResponseBody返回json结果的处理器是 RequestResponseBodyMethodProcessor）</span><br><span class=line>				- 利用MessageConvert（默认10个）来处理结果</span><br><span class=line>					- 拿到spring支持的返回结果类型 和 客户端浏览器支持的 接收结果类型</span><br><span class=line>					- 拿到两者匹配兼容的转换类型，然后转换。</span><br><span class=line>					- 将转换结果 封装到 OutputMessage中，并返回。</span><br><span class=line>	- 执行目标方法：invokeAndHandler(webRequest, mavContainer)</span><br><span class=line>		- invokeForRequest(...)--->会跳到目标方法执行</span><br><span class=line>			- 获取 所有参数的值</span><br><span class=line>			- 通过 反射 调用目标方法</span><br><span class=line>	- 最终处理结果会放到 ModelAndViewContainer中，其中包含 页面 和 数据。</span><br></pre></table></figure><li><p>调用处理器执行器链的applyPostHandler()方法。</p><li><p>调用processDispatcherResult()：处理最终结果。</p><li><p>最终，将数据保存到请求域中并返回。</p></ol><h2 id=3、内容协商><a class=headerlink href=#3、内容协商 title=3、内容协商></a>3、内容协商</h2><ol><li>判断当前响应头中是否有确定的媒体类型，MediaType。<li>获取 客户端支持接收的内容类型（获取客户端Accepte请求头字段）。<li>获取 spring 可以提供的 媒体类型。<ul><li>遍历当前系统中所有的MessageConverter，拿到支持操作当前对象的MessageConverter。<li>将支持的MC的媒体类型统计出来并保存。</ul><li>进行 客户端和服务器 媒体类型 的 最佳匹配。<li>拿到 支持当前内容转换的 具体Converter，然后进行转换。</ol><h2 id=4、异常处理><a class=headerlink href=#4、异常处理 title=4、异常处理></a>4、异常处理</h2><p>ErrorMvcAutoConfiguration 自动配置异常处理规则：<ul><li>注入 DefatultErrorAttributes：定义错误页面可以包含哪些数据。<li>注入 BasicErrorController<ul><li>处理 /error 的请求（server.error.path/error.path），视图响应 ModelAndView(error)<li>组件View<li>注入组件BeanNameViewResolver，以 返回的视图名作为ID去找View对象。</ul><li>注入 DefaultErrorViewResolver<br> - 发生错误时，会以HTTP状态码 作为视图地址。（error/viewName.html）</ul><p>异常处理流程：<ol><li>目标方法执行期间，有异常时会被catch，并标记当前请求已结束，然后启用dispatchException。<li>进入视图解析逻辑。<li>执行处理器的异常并返回一个MV<ul><li>遍历所有handlerExceptionResolvers，找到可以处理当前异常的resolver。<li>遍历所有的默认异常解析器，找到可以解析当前异常的。<ul><li>DefaultErrorAttributes先处理异常，把异常保存到request域，并返回空。<li>默认没有任何组件能处理该异常，所以异常会抛出。<ul><li>如果没有人处理该异常，那么会发送 /error 请求。<li>解析错误视图，遍历 ErrorViewResolver，找到可以解析的resolver，然后解析。</ul></ul><li>封装错误视图，并返回。</ul></ol><h2 id=5、总结><a class=headerlink href=#5、总结 title=5、总结></a>5、总结</h2><h3 id=5-1、初始化阶段><a class=headerlink href=#5-1、初始化阶段 title=5.1、初始化阶段></a>5.1、初始化阶段</h3><ol><li>首次用到<code>DispatcherServlet</code>时，会初始化Web容器 WebApplicationContext。然后调用 onRefresh() 方法刷新 WebApplicationContext。<li>刷新过程会初始化一些重要组件（9个）：MultipartResolver、LocaleResolver、ThemeResolver、HandlerMapping、HandlerAdapters、HandlerExceptionResolvers、RequestToViewNameTranslator、ViewResolvers、FlashMapManager。<li>将初始化好后的组件赋值给DispatcherServlet，留待后用。</ol><h3 id=5-2、匹配阶段><a class=headerlink href=#5-2、匹配阶段 title=5.2、匹配阶段></a>5.2、匹配阶段</h3><ol><li>用户请求首先被DispatcherServlet拦截。<li>DispatcherServlet遍历所有HandlerMapping，找到与请求匹配的处理器。<ol><li><code>HandlerMapping</code>有多个，不同的<code>HandlerMapping</code>对应有不同的处理器对象。请求路径与处理器的映射在HandlerMapping初始化期间就已经被设置好。<li><code>@RequestMapping</code>注解优先级较高会被优先匹配到，其对应的处理器是<code>HandlerMethod</code>，该处理器包含 控制器对象 和 控制器方法 等信息。</ol><li>将<code>HandlerMethod</code>和 拦截器 封装成 处理执行器链<code>HandlerExecutionChain</code>。<li>找到可以处理当前<code>HandlerMethod</code>的适配器对象<code>HandlerAdapter</code>，通过该 适配器对象 来处理请求。</ol><h3 id=5-3、执行阶段><a class=headerlink href=#5-3、执行阶段 title=5.3、执行阶段></a>5.3、执行阶段</h3><ol><li><p>执行拦截器的<code>preHandler()</code>方法。</p><li><p>通过<code>HandlerAdapter</code>调用<code>HandlerMethod</code></p> <ol><li><p>调用前处理请求参数</p> <p>提取Request中的模型数据，填充Handler入参：</p> <ul><li>数据转换：如 String 转 Integer、Double等。<li>数据格式化：如 将 字符串 转为 格式化数字 或 日期 等。<li>数据验证：验证数据的有效性（长度、格式），验证结果存储到<code>BindingResult</code>或<code>Error</code>中。</ul><li><p>开始执行Handler（Controller）方法处理请求</p><li><p>处理返回值。如果控制器标注了ResponseBody注解，那么会生成json结果，并标记ModelAndView已经处理，这样就不再走视图渲染流程。</p></ol><li><p>若返回的视图不存在，则创建保存一个默认视图，若存在则继续执行。</p><li><p>执行拦截器<code>postHandler</code>方法</p><li><p>处理返回结果</p> <ul><li>执行流程中有异常会进入<code>HandlerExceptionResolver</code>异常处理流程。<li>没有异常会执行下列操作：<ol><li>拿到<code>ModelAndView</code>对象。<li>通过<code>ViewResolver</code>来解析视图，根据Model和View 来渲染视图。</ol><li>执行拦截器的<code>afterCompletion</code>方法。</ul><li><p>将渲染结果返回给客户端。</p></ol><h1 id=Transaction（事务）><a class=headerlink href=#Transaction（事务） title=Transaction（事务）></a>Transaction（事务）</h1><h2 id=1、环境搭建><a class=headerlink href=#1、环境搭建 title=1、环境搭建></a>1、环境搭建</h2><p>（1）导入相关依赖：数据源、数据库驱动、Spring-jdbc模块<p>（2）配置数据源、JdbcTemplate（Spring提供的简化数据库操作的工具）操作数据<p>（3）给方法上标注 @Transactional 表示当前方法是一个事务方法；<p>（4）@EnableTransactionManagement 开启基于注解的事务管理功能；@EnableXXX<p>（5）配置事务管理器来控制事务;<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta>@Bean</span></span><br><span class=line><span class=keyword>public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class=params>()</span></span><br></pre></table></figure><h2 id=2、原理><a class=headerlink href=#2、原理 title=2、原理></a>2、原理</h2><figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line>1）、@EnableTransactionManagement</span><br><span class=line>	利用TransactionManagementConfigurationSelector给容器中导入两个组件</span><br><span class=line>		AutoProxyRegister</span><br><span class=line>		ProxyTransactionManagementConfiguration</span><br><span class=line></span><br><span class=line>2）、AutoProxyRegistrar：</span><br><span class=line>	给容器中注册一个 InfrastructureAdvisorAutoProxyCreator 组件；</span><br><span class=line>	InfrastructureAdvisorAutoProxyCreator：？</span><br><span class=line>	利用后置处理器机制在对象创建以后，包装对象，返回一个代理对象（增强器），代理对象执行方法利用拦截器链进行调用；</span><br><span class=line></span><br><span class=line>3）、ProxyTransactionManagementConfiguration 做了什么？</span><br><span class=line>	1、给容器中注册事务增强器；</span><br><span class=line>		1）、事务增强器要用事务注解的信息，AnnotationTransactionAttributeSource解析事务注解</span><br><span class=line>		2）、事务拦截器：TransactionInterceptor；保存了事务属性、事务管理器信息；底层是MethodInterceptor；</span><br><span class=line>			在目标方法执行的时执行拦截器链；</span><br><span class=line>				事务拦截器：</span><br><span class=line>					1）、先获取事务相关的属性</span><br><span class=line>					2）、再获取PlatformTransactionManager，如果事先没有添加指定任何transactionmanger，最终会从容器中按照类型获取一个PlatformTransactionManager；</span><br><span class=line>					3）、执行目标方法</span><br><span class=line>						如果异常，获取到事务管理器，利用事务管理回滚操作；</span><br><span class=line>						如果正常，利用事务管理器，提交事务</span><br></pre></table></figure><h1 id=XML配置原理解析><a class=headerlink href=#XML配置原理解析 title=XML配置原理解析></a>XML配置原理解析</h1><p>以自定义标签<code>&LThaoge:haoge-driver /></code>为例进行分析。<p>要想使得spring配置文件中的标签生效，需要满足以下几点：<ol><li><strong>创建命名空间对应的xsd文件</strong>。比如context的xsd文件<code>org.springframework.context.config.spring-context.xsd</code><li><strong>创建命名空间处理器处理指定的命名空间</strong>。比如<code>context</code>命名空间；<li><strong>创建命名空间下各个标签的解析器，解析标签使其生效</strong>。比如解析<code>&LTcontext:component-scan base-package="xxx"/></code>标签；</ol><h2 id=1-1、创建并配置xsd文件><a class=headerlink href=#1-1、创建并配置xsd文件 title=1.1、创建并配置xsd文件></a>1.1、创建并配置xsd文件</h2><p>在路径<code>resources/cn/shh/spring/haoge/config</code>下创建文件<code>spring-haoge.xsd</code>，文件内容如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line></span><br><span class=line><span class=tag><<span class=name>xsd:schema</span> <span class=attr>xmlns</span>=<span class=string>"http://www.shihaohan.com/schema/haoge"</span></span></span><br><span class=line><span class=tag>		<span class=attr>xmlns:xsd</span>=<span class=string>"http://www.w3.org/2001/XMLSchema"</span></span></span><br><span class=line><span class=tag>		<span class=attr>targetNamespace</span>=<span class=string>"http://www.shihaohan.com/schema/haoge"</span>></span></span><br><span class=line></span><br><span class=line>	<span class=tag><<span class=name>xsd:element</span> <span class=attr>name</span>=<span class=string>"haoge-driver"</span>></span><span class=tag>&LT/<span class=name>xsd:element</span>></span></span><br><span class=line></span><br><span class=line><span class=tag>&LT/<span class=name>xsd:schema</span>></span></span><br></pre></table></figure><h2 id=1-2、创建spring-schemas文件><a class=headerlink href=#1-2、创建spring-schemas文件 title=1.2、创建spring.schemas文件></a>1.2、创建spring.schemas文件</h2><p>在路径<code>resources/META-INF</code>下创建<code>spring.schemas</code>文件，文件内容如下：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>http\://www.shihaohan.com/schema/haoge/spring-haoge.xsd</span>=<span class=string>cn.shh.spring.haoge.config/spring-haoge.xsd</span></span><br></pre></table></figure><h2 id=1-3、创建命名空间处理器><a class=headerlink href=#1-3、创建命名空间处理器 title=1.3、创建命名空间处理器></a>1.3、创建命名空间处理器</h2><p>创建Java类<code>HaogeNamespaceHandler</code>来处理命令自定义空间<code>haoge</code>，详细内容如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">HaogeNamespaceHandler</span> <span class=keyword>extends</span> <span class="title class_">NamespaceHandlerSupport</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">init</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>this</span>.registerBeanDefinitionParser(<span class=string>"haoge-driver"</span>, <span class=keyword>new</span> <span class="title class_">HaogeDriverBeanDefinitionParser</span>());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>创建Java类<code>HaogeDriverBeanDefinitionParser</code>来解析处理标签<code>haoge-driver</code>，该标签的功能就是向容器中注入一个<code>HaogeBeanPostProcessor</code>，详细内容如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">HaogeDriverBeanDefinitionParser</span> <span class=keyword>implements</span> <span class="title class_">BeanDefinitionParser</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> BeanDefinition <span class="title function_">parse</span><span class=params>(Element element, ParserContext parserContext)</span> {</span><br><span class=line>        <span class=type>RootBeanDefinition</span> <span class=variable>beanDefinition</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">RootBeanDefinition</span>();</span><br><span class=line>        beanDefinition.setBeanClassName(<span class=string>"cn.shh.demo.spring.ioc.customenamespace.HaogeBeanPostProcessor"</span>);</span><br><span class=line>        parserContext.getRegistry().registerBeanDefinition(<span class=string>"haogeBeanPostProcessor"</span>, beanDefinition);</span><br><span class=line>        <span class=keyword>return</span> beanDefinition;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>//================================</span></span><br><span class=line><span class=meta>@Slf4j</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">HaogeBeanPostProcessor</span> <span class=keyword>implements</span> <span class="title class_">BeanPostProcessor</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class=params>(Object bean, String beanName)</span> <span class=keyword>throws</span> BeansException {</span><br><span class=line>        log.info(<span class=string>"HaogeBeanPostProcessor.postProcessBeforeInitialization"</span>);</span><br><span class=line>        <span class=keyword>return</span> bean;</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class=params>(Object bean, String beanName)</span> <span class=keyword>throws</span> BeansException {</span><br><span class=line>        log.info(<span class=string>"HaogeBeanPostProcessor.postProcessAfterInitialization"</span>);</span><br><span class=line>        <span class=keyword>return</span> bean;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=1-4、创建spring-handlers文件><a class=headerlink href=#1-4、创建spring-handlers文件 title=1.4、创建spring.handlers文件></a>1.4、创建spring.handlers文件</h2><p>在路径<code>resources/META-INF</code>下创建<code>spring.handlers</code>文件，文件内容如下：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=attr>http\://www.shihaohan.com/schema/haoge</span>=<span class=string>cn.shh.demo.spring.ioc.customenamespace.HaogeNamespaceHandler</span></span><br></pre></table></figure><h2 id=1-5、测试效果><a class=headerlink href=#1-5、测试效果 title=1.5、测试效果></a>1.5、测试效果</h2><p>在spring配置文件中编写自定义标签：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>	   <span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>	   <span class=attr>xmlns:haoge</span>=<span class=string>"http://www.shihaohan.com/schema/haoge"</span></span></span><br><span class=line><span class=tag>	   <span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>	                       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>						   http://www.shihaohan.com/schema/haoge</span></span></span><br><span class=line><span class=string><span class=tag>	                       http://www.shihaohan.com/schema/haoge/spring-haoge.xsd"</span>></span></span><br><span class=line></span><br><span class=line>	<span class=comment>&LT!--扫描到该标签会向容器中注入一个HaogeBeanPostProcessor--></span></span><br><span class=line>	<span class=tag><<span class=name>haoge:haoge-driver</span> ></span><span class=tag>&LT/<span class=name>haoge:haoge-driver</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure><p>在Java的main方法中扫描spring配置文件，检测自定义标签功能是否实现。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">App</span> {</span><br><span class=line>	<span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>		<span class=type>ApplicationContext</span> <span class=variable>context</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class=string>"beans.xml"</span>);</span><br><span class=line>	}</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 如果打印结果中出现如下信息，则表示自定义标签成功。</span></span><br><span class=line>HaogeBeanPostProcessor.postProcessBeforeInitialization</span><br><span class=line>HaogeBeanPostProcessor.postProcessAftereforeInitialization</span><br></pre></table></figure><h1 id=Spring整合MyBatis><a class=headerlink href=#Spring整合MyBatis title=Spring整合MyBatis></a>Spring整合MyBatis</h1><h2 id=1-1、概述><a class=headerlink href=#1-1、概述 title=1.1、概述></a>1.1、概述</h2><p>Spring整合MyBatis的底层原理由以下4个类完成：<ul><li>SqlSessionFactoryBean<li>MapperScannerConfigurer<li>MapperFactoryBean<li>ClassPathMapperScanner</ul><h2 id=1-2、流程分析><a class=headerlink href=#1-2、流程分析 title=1.2、流程分析></a>1.2、流程分析</h2><p><strong>（1）通过<code>SqlSessionFactoryBean</code>创建<code>SqlSessionFactory</code></strong><p><code>SqlSessionFactoryBean</code>实现了<code>InitializingBean</code>的<code>afterPropertiesSet()</code>方法，会在该方法中构建<code>SqlSessionFactory</code>。<p><code>SqlSessionFactoryBean</code>实现了<code>FactoryBean</code>的<code>getObject()</code>方法，在该方法中获取构建好的<code>SqlSessionFactory</code>。<p><strong>（2）通过MapperScannerConfigurer扫描Mapper，将其包装成MapperFactoryBean</strong><p><code>MapperScannerConfigurer</code>实现了<code>BeanDefinitionRegistryPostProcessor</code>的<code>postProcessBeanDefinitionRegistry</code>方法，在该方法中通过<code>ClassPathMapperScanner</code>的<code>scan</code>方法来扫描并包装Mapper。<p><code>ClassPathMapperScanner</code>通过调用父类<code>ClassPathBeanDefinitionScanner</code>的<code>doScan</code>方法将所有Mapper的Bean定义信息放到容器中并返回给<code>ClassPathMapperScanner</code>。<p><code>ClassPathMapperScanner</code>通过调用自己<code>processBeanDefinitions(beanDefinitions)</code>方法对每一个Mapper的Beean定义信息进行配置，将每一个Mapper包装成一个<code>MapperFactoryBean</code>。<p><code>MapperFactoryBean</code>实现了<code>FactoryBean</code>的<code>getObject()</code>方法，在该方法中通过<code>SqlSession</code>获取Mapper。在获取Mapper时会通过<code>MapperProxyFactory</code>的<code>newInstance(mapperProxy)</code>方法并<strong>使用JDK代理</strong>为当前Mapper创建代理对象，所以这里获取的Mapper是代理对象，而并非是原始Mapper。<h1 id=Spring工具类><a class=headerlink href=#Spring工具类 title=Spring工具类></a>Spring工具类</h1><h2 id=1-1、PropertiesLoaderUtils><a class=headerlink href=#1-1、PropertiesLoaderUtils title=1.1、PropertiesLoaderUtils></a>1.1、PropertiesLoaderUtils</h2></div><footer class=post-footer><div class=post-eof></div></footer></article></div> <nav class=pagination><a class="extend prev" aria-label=上一页 href=/page/2/ rel=prev title=上一页><i class="fa fa-angle-left"></i></a><a class=page-number href=/>1</a><a class=page-number href=/page/2/>2</a><span class="page-number current">3</span><a class=page-number href=/page/4/>4</a><span class=space>…</span><a class=page-number href=/page/12/>12</a><a class="extend next" aria-label=下一页 href=/page/4/ rel=next title=下一页><i class="fa fa-angle-right"></i></a></nav> <footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer> <div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div> <div class=sidebar-dimmer></div> <div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div> <noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript> <script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script> <script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script> <script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script> <script src=/js/third-party/search/local-search.js></script> 