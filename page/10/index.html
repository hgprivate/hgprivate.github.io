<!doctypehtml><html lang=zh-CN><meta charset=UTF-8><meta content=width=device-width name=viewport><meta media="(prefers-color-scheme: light)" content=#222 name=theme-color><meta media="(prefers-color-scheme: dark)" content=#222 name=theme-color><meta content="Hexo 7.3.0" name=generator><link href=/images/apple-touch-icon-next.png rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg rel=mask-icon><link href=/css/main.css rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css integrity=sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA= rel=stylesheet><link crossorigin=anonymous href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css integrity=sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE= rel=stylesheet><script class=next-config data-name=main type=application/json>{"hostname":"hshz21.gitee.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src=/js/config.js></script><meta content=豪哥博客 name=description><meta content=website property=og:type><meta content=豪哥博客 property=og:title><meta content=https://hshz21.gitee.io/page/10/index.html property=og:url><meta content=豪哥博客 property=og:site_name><meta content=豪哥博客 property=og:description><meta content=zh_CN property=og:locale><meta content=豪哥 property=article:author><meta content=HG property=article:tag><meta content=summary name=twitter:card><link href=https://hshz21.gitee.io/page/10/ rel=canonical><script class=next-config data-name=page type=application/json>{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/10/index.html","title":""}</script><script class=next-config data-name=calendar type=application/json>""</script><title>豪哥博客</title><noscript><link href=/css/noscript.css rel=stylesheet></noscript><body class=use-motion itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><div class=column><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=site-brand-container><div class=site-nav-toggle><div aria-label=切换导航栏 class=toggle role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div></div><div class=site-meta><a class=brand href=/ rel=start> <i class=logo-line></i> <h1 class=site-title>豪哥博客</h1> <i class=logo-line></i> </a><p class=site-subtitle itemprop=description>豪哥博客</div><div class=site-nav-right><div class="toggle popup-trigger" aria-label=搜索 role=button><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ rel=section><i class="fa fa-home fa-fw"></i>首页</a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section><i class="fa fa-tags fa-fw"></i>标签</a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section><i class="fa fa-th fa-fw"></i>分类</a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section><i class="fa fa-archive fa-fw"></i>归档</a><li class="menu-item menu-item-search"><a class=popup-trigger role=button><i class="fa fa-search fa-fw"></i>搜索 </a></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon> <i class="fa fa-search"></i> </span><div class=search-input-container><input autocapitalize=off autocomplete=off class=search-input maxlength=80 placeholder=搜索... spellcheck=false type=search></div><span class=popup-btn-close role=button> <i class="fa fa-times-circle"></i> </span></div><div class=search-result-container><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class=sidebar><div class="sidebar-inner sidebar-overview-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录<li class=sidebar-nav-overview>站点概览</ul><div class=sidebar-panel-container><!--noindex--><div class="post-toc-wrap sidebar-panel"></div><!--/noindex--><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop=author itemscope itemtype=http://schema.org/Person><img alt=豪哥 class=site-author-image itemprop=image src=/static/imgs/avatar.png><p class=site-author-name itemprop=name>豪哥<div class=site-description itemprop=description>豪哥博客</div></div><div class="site-state-wrap animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/> <span class=site-state-item-count>109</span> <span class=site-state-item-name>日志</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/> <span class=site-state-item-count>33</span> <span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/> <span class=site-state-item-count>126</span> <span class=site-state-item-name>标签</span></a></div></nav></div></div></div></div></aside></div><div class="main-inner index posts-expand"><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Docker%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Docker%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/ itemprop=url>Docker系列-Docker基础应用</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-09-30 21:27:43" datetime=2023-09-30T21:27:43+08:00 itemprop=dateModified>2023-09-30</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Docker/ itemprop=url rel=index><span itemprop=name>Docker</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=0、初识Docker><a class=headerlink href=#0、初识Docker title=0、初识Docker></a>0、初识Docker</h1><h2 id=0-1、Docker是什么><a class=headerlink href=#0-1、Docker是什么 title=0.1、Docker是什么></a>0.1、Docker是什么</h2><p><strong>Docker 是一个开源的应用容器引擎</strong>。诞生于 2013 年初，基于 Go 语言实现， dotCloud 公司出品（后改名为Docker Inc）。<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上。容器是完全使用沙箱机制，相互隔离容器性能开销极低。<p><strong>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版）</strong>。<h2 id=0-2、Docker架构><a class=headerlink href=#0-2、Docker架构 title=0.2、Docker架构></a>0.2、Docker架构</h2><ul><li><strong>镜像（Image）</strong>：相当于一个 root 文件系统。<li><strong>容器（Container）</strong>：镜像 和 容器 关系，如同 类和对象，镜像是静态定义，容器是镜像运行时的实体。<li><strong>仓库（Repository）</strong>：保存镜像的地方。</ul><h2 id=0-3、Docker容器与虚拟机><a class=headerlink href=#0-3、Docker容器与虚拟机 title=0.3、Docker容器与虚拟机></a>0.3、Docker容器与虚拟机</h2><h3 id=0-3-1、Docker容器特点><a class=headerlink href=#0-3-1、Docker容器特点 title=0.3.1、Docker容器特点></a>0.3.1、Docker容器特点</h3><ol><li>容器 可将软件 打包成标准化单元，便于开发、交付和部署。<li>容器镜像是 轻量可执行 的独立软件包 ，包含 软件运行 所需所有内容：代码、运行时环境、系统工具、系统库和设置。<li>容器化软件在任何环境中都能够运行。<li>容器 赋予软件 独立性，使其免受外在环境影响，减少运行冲突等问题。</ol><h3 id=0-3-2、两者的异同><a class=headerlink href=#0-3-2、两者的异同 title=0.3.2、两者的异同></a>0.3.2、两者的异同</h3><ul><li><p>相同</p> <p>容器和虚拟机具有相似的<strong>资源隔离和分配优势</strong>。</p><li><p>不同：</p> <ol><li>容器 虚拟化的是 操作系统，虚拟机虚拟化的是硬件。<li>传统虚拟机可以运行不同的操作系统，容器只能运行同一类型操作系统。</ol></ul><p><img alt=image-20230807165037560 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20230807165037560.png><h1 id=1、容器和镜像><a class=headerlink href=#1、容器和镜像 title=1、容器和镜像></a>1、容器和镜像</h1><h2 id=1-1、镜像命令><a class=headerlink href=#1-1、镜像命令 title=1.1、镜像命令></a>1.1、镜像命令</h2><h3 id=1-1-1、查看镜像><a class=headerlink href=#1-1-1、查看镜像 title=1.1.1、查看镜像></a>1.1.1、查看镜像</h3><p>查看本地所有镜像：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>docker images</span><br><span class=line>docker images –q 	# 查看所用镜像id</span><br></pre></table></figure><h3 id=1-1-2、搜索镜像><a class=headerlink href=#1-1-2、搜索镜像 title=1.1.2、搜索镜像></a>1.1.2、搜索镜像</h3><p>从网络中查找需要的镜像：<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker search 镜像名称</span><br></pre></table></figure><h3 id=1-1-3、拉取镜像><a class=headerlink href=#1-1-3、拉取镜像 title=1.1.3、拉取镜像></a>1.1.3、拉取镜像</h3><p>从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本。如果不知道镜像版本，可以去 docker hub 搜索对应镜像查看。<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker pull 镜像名称</span><br></pre></table></figure><h3 id=1-1-4、删除镜像><a class=headerlink href=#1-1-4、删除镜像 title=1.1.4、删除镜像></a>1.1.4、删除镜像</h3><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_"># </span><span class=language-bash>命令1：删除指定镜像</span></span><br><span class=line>docker rmi 镜像id</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>命令2：删除所有镜像</span></span><br><span class=line>docker rmi $(docker images | awk '{print $3}' |tail -n +2)</span><br></pre></table></figure><h3 id=1-1-5、保存镜像><a class=headerlink href=#1-1-5、保存镜像 title=1.1.5、保存镜像></a>1.1.5、保存镜像</h3><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_"># </span><span class=language-bash>将镜像elasticsearch保存为本地文件es.tar，在其它设备docker环境下可直接加载该tar文件进行使用。</span></span><br><span class=line>docker save -o es.tar elasticsearch</span><br></pre></table></figure><h2 id=1-2、容器命令><a class=headerlink href=#1-2、容器命令 title=1.2、容器命令></a>1.2、容器命令</h2><h3 id=1-2-1、查看容器><a class=headerlink href=#1-2-1、查看容器 title=1.2.1、查看容器></a>1.2.1、查看容器</h3><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>docker ps       # 查看正在运行的容器</span><br><span class=line>docker ps –a    # 查看所有容器</span><br></pre></table></figure><h3 id=1-2-2、运行容器><a class=headerlink href=#1-2-2、运行容器 title=1.2.2、运行容器></a>1.2.2、运行容器</h3><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker run [options] IMAGE [COMMAND] [ARG...]</span><br></pre></table></figure><p>options说明：<ul><li>-a stdin：指定标准输入输出内容类型，可选STDIN/STDOUT/STDERR三项。<li>-i：以交互模式运行容器，通常与-t同时使用。容器创建后自动进入容器中，退出容器后，容器自动关闭。<li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用。<li>-d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容器不会关闭。<li>-it 创建的容器一般称为交互式容器；<li>-id 创建的容器一般称为守护式容器；<li>-P：随机端口映射，容器内部端口随机映射到主机的端口。<li>-p：指定端口映射，格式为：主机端口：容器端口。<li>–name=“容器名称”：为创建的容器指定一个临时名称。<li>-dns 8.8.8.8：指定容器使用的DNS服务器，默认和宿主机一致。<li>-dns-search example.com：指定容器DNS搜索域名，默认和宿主机一样。<li>-h “mars”：指定容器的hostname；<li>-e username=“ritchie”：设置环境变量；<li>-env-file=[]：从指定文件读入环境变量；<li>-cpuset=“0-2” or –cpuset=”0,1,2”：绑定容器到指定CPU运行；<li>-m：设置容器使用内存最大值；<li>–net=”bridge”：指定容器的网络连接类型，支持bridge/host/none/container四种类型；<li>–like=[]：添加链接到另一个容器；<li>–expose=[]：开放一个端口或一组端口；<li>–volume, -v：绑定一个卷；</ul><h3 id=1-2-3、关闭容器><a class=headerlink href=#1-2-3、关闭容器 title=1.2.3、关闭容器></a>1.2.3、关闭容器</h3><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_"># </span><span class=language-bash>命令1：关闭指定容器</span></span><br><span class=line>docker stop 容器名</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>命令2：关闭所有容器</span></span><br><span class=line>docker stop $(docker ps -a | awk '{ print $1}' | tail -n +2)</span><br></pre></table></figure><h3 id=1-2-4、启动容器><a class=headerlink href=#1-2-4、启动容器 title=1.2.4、启动容器></a>1.2.4、启动容器</h3><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_"># </span><span class=language-bash>命令1：启动指定容器</span></span><br><span class=line>docker start 容器名称</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>命令2：启动所有容器</span></span><br><span class=line>docker start $(docker ps -a | awk '{ print $1}' | tail -n +2)</span><br></pre></table></figure><h3 id=1-2-5、进入容器><a class=headerlink href=#1-2-5、进入容器 title=1.2.5、进入容器></a>1.2.5、进入容器</h3><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker exec 参数        # 退出容器，容器不会关闭</span><br></pre></table></figure><h3 id=1-2-6、查看容器信息><a class=headerlink href=#1-2-6、查看容器信息 title=1.2.6、查看容器信息></a>1.2.6、查看容器信息</h3><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker inspect 容器名称</span><br></pre></table></figure><h3 id=1-2-7、删除容器><a class=headerlink href=#1-2-7、删除容器 title=1.2.7、删除容器></a>1.2.7、删除容器</h3><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_"># </span><span class=language-bash>命令1：删除指定容器</span></span><br><span class=line>docker rm 容器名称</span><br><span class=line><span class="meta prompt_"></span></span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>命令2：删除所有容器</span></span><br><span class=line>docker rm $(docker ps -a | awk '{ print $1}' | tail -n +2)</span><br></pre></table></figure><h2 id=1-3、环境部署><a class=headerlink href=#1-3、环境部署 title=1.3、环境部署></a>1.3、环境部署</h2><h3 id=1-3-1、部署MySQL><a class=headerlink href=#1-3-1、部署MySQL title=1.3.1、部署MySQL></a>1.3.1、部署MySQL</h3><p>（1）搜索MySQL镜像<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker search mysql</span><br></pre></table></figure><p>（2）拉取MySQL镜像<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker pull mysql:5.7</span><br></pre></table></figure><p>（3）创建容器，设置端口映射、目录映射<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=comment># 在/root目录下创建mysql目录用于存储mysql数据信息</span></span><br><span class=line><span class=built_in>mkdir</span> ~/mysql</span><br><span class=line><span class=built_in>cd</span> ~/mysql</span><br></pre></table></figure><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>docker run -<span class=built_in>id</span> \</span><br><span class=line>-p 3360:3306 \</span><br><span class=line>--name=c_mysql \</span><br><span class=line>-v <span class=variable>$PWD</span>/conf:/etc/mysql/conf.d \</span><br><span class=line>-v <span class=variable>$PWD</span>/logs:/logs \</span><br><span class=line>-v <span class=variable>$PWD</span>/data:/var/lib/mysql \</span><br><span class=line>-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class=line>mysql:5.7</span><br></pre></table></figure><p>参数解析：<ul><li><strong>-p 3307:3306</strong>：将容器的 3306 端口映射到宿主机的 3307 端口。<li><strong>-v $PWD/conf:/etc/mysql/conf.d</strong>：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。配置目录<li><strong>-v $PWD/logs:/logs</strong>：将主机当前目录下的 logs 目录挂载到容器的 /logs。日志目录<li><strong>-v $PWD/data:/var/lib/mysql</strong> ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。数据目录<li><strong>-e MYSQL_ROOT_PASSWORD=123456</strong>：初始化 root 用户的密码。</ul><p>（4）进入容器，操作MySQL<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker <span class=built_in>exec</span> –it c_mysql /bin/bash</span><br></pre></table></figure><p>（5）使用外部机器连接容器中的MySQL服务<h3 id=1-3-2、部署Tomcat><a class=headerlink href=#1-3-2、部署Tomcat title=1.3.2、部署Tomcat></a>1.3.2、部署Tomcat</h3><p>（1）搜索tomcat镜像<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker search tomcat</span><br></pre></table></figure><p>（2）拉取tomcat镜像<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker pull tomcat</span><br></pre></table></figure><p>（3）创建容器，设置端口，目录映射<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_"># </span><span class=language-bash>在/root目录下创建tomcat目录用于存储tomcat数据信息</span></span><br><span class=line>mkdir ~/tomcat</span><br><span class=line>cd ~/tomcat</span><br></pre></table></figure><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>docker run -id --name=c_tomcat \</span><br><span class=line>-p 8080:8080 \</span><br><span class=line>-v $PWD:/usr/local/tomcat/webapps \</span><br><span class=line>tomcat </span><br></pre></table></figure><p>参数解析：<ul><li><strong>-p 8080:8080</strong>：将容器的8080端口映射到主机的8080端口。<li><strong>-v $PWD:/usr/local/tomcat/webapps</strong>：将主机中当前目录挂载到容器的webapps。</ul><p>（4）使用外部机器连接容器中的tomcat服务<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 使用浏览器访问下面地址</span></span><br><span class=line>192.168.93.129:8080/test/index.html</span><br></pre></table></figure><h3 id=1-3-3、部署Nginx><a class=headerlink href=#1-3-3、部署Nginx title=1.3.3、部署Nginx></a>1.3.3、部署Nginx</h3><p>（1）搜索nginx镜像<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker search nginx</span><br></pre></table></figure><p>（2）拉取nginx镜像<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker pull nginx</span><br></pre></table></figure><p>（3）创建容器，设置端口映射、目录映射<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment># 在/root目录下创建nginx目录用于存储nginx数据信息</span></span><br><span class=line><span class=built_in>mkdir</span> ~/nginx</span><br><span class=line><span class=built_in>cd</span> ~/nginx</span><br><span class=line><span class=built_in>mkdir</span> conf</span><br><span class=line><span class=built_in>cd</span> conf</span><br><span class=line><span class=comment># 在~/nginx/conf/下创建nginx.conf文件,粘贴下面内容</span></span><br><span class=line>vim nginx.conf</span><br></pre></table></figure><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre><td class=code><pre><span class=line><span class=attr>user</span>  <span class=string>nginx;</span></span><br><span class=line><span class=attr>worker_processes</span>  <span class=string>1;</span></span><br><span class=line></span><br><span class=line><span class=attr>error_log</span>  <span class=string>/var/log/nginx/error.log warn;</span></span><br><span class=line><span class=attr>pid</span>        <span class=string>/var/run/nginx.pid;</span></span><br><span class=line></span><br><span class=line><span class=attr>events</span> <span class=string>{</span></span><br><span class=line>    <span class=attr>worker_connections</span>  <span class=string>1024;</span></span><br><span class=line><span class=attr>}</span></span><br><span class=line></span><br><span class=line><span class=attr>http</span> <span class=string>{</span></span><br><span class=line>    <span class=attr>include</span>       <span class=string>/etc/nginx/mime.types;</span></span><br><span class=line>    <span class=attr>default_type</span>  <span class=string>application/octet-stream;</span></span><br><span class=line></span><br><span class=line>    <span class=attr>log_format</span>  <span class=string>main  '$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class=line>                      <span class=attr>'$status</span> <span class=string>$body_bytes_sent "$http_referer" '</span></span><br><span class=line>                      <span class=attr>'"$http_user_agent"</span> <span class=string>"$http_x_forwarded_for"';</span></span><br><span class=line></span><br><span class=line>    <span class=attr>access_log</span>  <span class=string>/var/log/nginx/access.log  main;</span></span><br><span class=line>    <span class=attr>sendfile</span>        <span class=string>on;</span></span><br><span class=line><span class=comment>    #tcp_nopush     on;</span></span><br><span class=line>    <span class=attr>keepalive_timeout</span>  <span class=string>65;</span></span><br><span class=line><span class=comment>    #gzip  on;</span></span><br><span class=line>    <span class=attr>include</span> <span class=string>/etc/nginx/conf.d/*.conf;</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>docker run -<span class=built_in>id</span> --name=c_nginx \</span><br><span class=line>-p 80:80 \</span><br><span class=line>-v <span class=variable>$PWD</span>/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class=line>-v <span class=variable>$PWD</span>/logs:/var/log/nginx \</span><br><span class=line>-v <span class=variable>$PWD</span>/html:/usr/share/nginx/html \</span><br><span class=line>nginx</span><br></pre></table></figure><p>参数解析：<ul><li><strong>-p 80:80</strong>：容器80端口 映射 宿主机80端口。<li><strong>-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf</strong>：当前目录下的 /conf/nginx.conf 挂载到 容器/etc/nginx/nginx.conf目录。<li><strong>-v $PWD/logs:/var/log/nginx</strong>：当前目录下的logs目录 挂载到 容器/var/log/nginx目录。</ul><h3 id=1-3-4、部署Redis><a class=headerlink href=#1-3-4、部署Redis title=1.3.4、部署Redis></a>1.3.4、部署Redis</h3><p>（1）搜索redis镜像<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker search redis</span><br></pre></table></figure><p>（2）拉取redis镜像<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker pull redis</span><br></pre></table></figure><p>（3）创建容器，设置端口映射<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker run -id --name=c_redis -p 6379:6379 redis</span><br></pre></table></figure><p>（4）使用外部机器连接redis<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>./redis-cli.exe -h 192.168.149.135 -p 6379</span><br></pre></table></figure><p>（5）保存修改<p>对容器做一定修改后，可以将修改后的容器保存为新镜像，下次可直接使用。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=comment># 命令格式：docker commit 正在运行的容器ID(CONTAINER ID) 新镜像名称:镜像版本</span></span><br><span class=line><span class=comment># 具体示例如下：</span></span><br><span class=line>docker commit -a <span class=string>"shh"</span> -m <span class=string>"shh-redis"</span> 939e05aa934e shh/redis:v1.0</span><br></pre></table></figure><h1 id=2、DockerFile><a class=headerlink href=#2、DockerFile title=2、DockerFile></a>2、DockerFile</h1><h2 id=2-1、Docker镜像原理><a class=headerlink href=#2-1、Docker镜像原理 title=2.1、Docker镜像原理></a>2.1、Docker镜像原理</h2><ol><li>Docker镜像由特殊文件系统叠加而成。<li>最底端是bootfs，并使用宿主机bootfs 。<li>第二层是 root文件系统rootfs，称为base image。<li>往上 可叠加 其它镜像文件。<li>统一文件系统（Union File System）技术能够将不同层整合成一个文件系统，对外提供统一视角，用户角度看只是一个文件系统。<li>一个镜像可以放在另一镜像上面。位于<strong>下面的镜像称为父镜像，最底部镜像称为基础镜像</strong>。<li><strong>当从一个镜像启动容器时，Docker会在最顶层加载一个读写文件系统作为容器</strong>。</ol><h2 id=2-2、Docker镜像制作><a class=headerlink href=#2-2、Docker镜像制作 title=2.2、Docker镜像制作></a>2.2、Docker镜像制作</h2><h3 id=2-2-1、容器转镜像><a class=headerlink href=#2-2-1、容器转镜像 title=2.2.1、容器转镜像></a>2.2.1、容器转镜像</h3><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>docker</span> <span class=string>commit 容器id 镜像名称:版本号</span></span><br><span class=line><span class=attr>docker</span> <span class=string>save -o 压缩文件名称 镜像名称:版本号</span></span><br><span class=line><span class=attr>docker</span> <span class=string>load –i 压缩文件名称</span></span><br></pre></table></figure><h3 id=2-2-2、Dockerfile><a class=headerlink href=#2-2-2、Dockerfile title=2.2.2、Dockerfile></a>2.2.2、Dockerfile</h3><h2 id=2-3、Dockerfile概念><a class=headerlink href=#2-3、Dockerfile概念 title=2.3、Dockerfile概念></a>2.3、Dockerfile概念</h2><p><strong>Dockerfile 是一个文本文件，其包含一条条指令，每条指令构建一层，基于基础镜像可构建出一个新镜像。</strong><ul><li>开发人员：可提供一个完全一致的开发环境。<li>测试人员：在 开发时构建镜像 或 基于Dockerfile文件构建新镜 就可开始工作。<li>运维人员：可实现应用无缝移植。</ul><h2 id=2-4、Dockerfile使用><a class=headerlink href=#2-4、Dockerfile使用 title=2.4、Dockerfile使用></a>2.4、Dockerfile使用</h2><h3 id=2-4-1、创建Dockerfile><a class=headerlink href=#2-4-1、创建Dockerfile title=2.4.1、创建Dockerfile></a>2.4.1、创建Dockerfile</h3><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>touch</span> springboot_dockerfile</span><br></pre></table></figure><h3 id=2-4-2、添加如下内容至Dockerfile，并保存><a class=headerlink href=#2-4-2、添加如下内容至Dockerfile，并保存 title=2.4.2、添加如下内容至Dockerfile，并保存></a>2.4.2、添加如下内容至Dockerfile，并保存</h3><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=attr>FROM</span> <span class=string>java:8</span></span><br><span class=line><span class=attr>MAINTAINER</span> <span class=string>shh &LTshihaohan368@gmail.com></span></span><br><span class=line><span class=attr>COPY</span> <span class=string>springboot-hello-0.0.1-SNAPSHOT.jar /tmp/app.jar</span></span><br><span class=line><span class=attr>EXPOSE</span> <span class=string>8090</span></span><br><span class=line><span class=attr>ENTRYPOINT</span> <span class=string>java -jar /tmp/app.jar</span></span><br></pre></table></figure><h3 id=2-4-3、开始构建><a class=headerlink href=#2-4-3、开始构建 title=2.4.3、开始构建></a>2.4.3、开始构建</h3><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># 如果构建的文件名为Dockerfile</span></span><br><span class=line>docker build -t app:1.0 .</span><br><span class=line><span class=comment># 如果构建的文件名不是Dockerfile，而是其它名字，比如名字是springboot_dockerfile，那么：</span></span><br><span class=line>docker build -f ./springboot_dockerfile -t app:1.0 .</span><br></pre></table></figure><h2 id=2-5、Dockerfile模板><a class=headerlink href=#2-5、Dockerfile模板 title=2.5、Dockerfile模板></a>2.5、Dockerfile模板</h2><h3 id=2-5-1、常用参数><a class=headerlink href=#2-5-1、常用参数 title=2.5.1、常用参数></a>2.5.1、常用参数</h3><table><thead><tr><th align=center>关键字<th align=center>作用<th>备注<tbody><tr><td align=center>FROM<td align=center>指定父镜像<td>指定dockerfile基于那个image构建<tr><td align=center>MAINTAINER<td align=center>作者信息<td>用来标明这个dockerfile谁写的<tr><td align=center>LABEL<td align=center>标签<td>用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看<tr><td align=center>RUN<td align=center>执行命令<td>执行一段命令 默认是/bin/sh 格式: RUN command 或者 RUN [“command” , “param1”,”param2”]<tr><td align=center>CMD<td align=center>容器启动命令<td>启动容器时的默认命令，和ENTRYPOINT配合使用。格式 CMD command param1 param2 或者 CMD [“command” , “param1”,”param2”]<tr><td align=center>ENTRYPOINT<td align=center>入口<td>一般在制作一些执行就关闭的容器中会使用<tr><td align=center>COPY<td align=center>复制文件<td>build的时候复制文件到image中<tr><td align=center>ADD<td align=center>添加文件<td>build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务<tr><td align=center>ENV<td align=center>环境变量<td>指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name=value<tr><td align=center>ARG<td align=center>构建参数<td>构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数<tr><td align=center>VOLUME<td align=center>定义外部可以挂载的数据卷<td>指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [“目录”]<tr><td align=center>EXPOSE<td align=center>暴露端口<td>定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080/udp<tr><td align=center>WORKDIR<td align=center>工作目录<td>指定容器内部的工作目录 如果没有创建则自动创建 如果指定/ 使用的是绝对地址 如果不是/开头那么是在上一条workdir的路径的相对路径<tr><td align=center>USER<td align=center>指定执行用户<td>指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户<tr><td align=center>HEALTHCHECK<td align=center>健康检查<td>指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制<tr><td align=center>ONBUILD<td align=center>触发器<td>当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大<tr><td align=center>STOPSIGNAL<td align=center>发送信号量到宿主机<td>该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。<tr><td align=center>SHELL<td align=center>指定执行脚本的shell<td>指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell</table><h3 id=2-5-2、模板><a class=headerlink href=#2-5-2、模板 title=2.5.2、模板></a>2.5.2、模板</h3><p>Dockerfile文件模板示例，根据实际需求进行修改即可使用：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line></span><br></pre></table></figure><h1 id=3、镜像仓库><a class=headerlink href=#3、镜像仓库 title=3、镜像仓库></a>3、镜像仓库</h1><h2 id=3-1、私有仓库搭建><a class=headerlink href=#3-1、私有仓库搭建 title=3.1、私有仓库搭建></a>3.1、私有仓库搭建</h2><h3 id=3-1-1、简单搭建><a class=headerlink href=#3-1-1、简单搭建 title=3.1.1、简单搭建></a>3.1.1、简单搭建</h3><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_"># </span><span class=language-bash>1、拉取私有仓库镜像</span> </span><br><span class=line>docker pull registry</span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>2、启动私有仓库容器</span> </span><br><span class=line>docker run -id --name=registry -p 5000:5000 registry</span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>3、打开浏览器 输入地址http://私有仓库服务器ip:5000/v2/_catalog，看到{<span class=string>"repositories"</span>:[]} 表示私有仓库 搭建成功</span></span><br></pre></table></figure><h3 id=3-1-2、可视化搭建><a class=headerlink href=#3-1-2、可视化搭建 title=3.1.2、可视化搭建></a>3.1.2、可视化搭建</h3><p>使用<code>DockerCompose</code>部署带有图象界面的<code>DockerRegistry</code>，<code>docker-compose.yml</code>文件内容如下：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=attr>version:</span> <span class=string>'3.0'</span></span><br><span class=line><span class=attr>services:</span></span><br><span class=line>  <span class=attr>registry:</span></span><br><span class=line>    <span class=attr>image:</span> <span class=string>registry</span></span><br><span class=line>    <span class=attr>volumes:</span></span><br><span class=line>      <span class=bullet>-</span> <span class=string>./registry-data:/var/lib/registry</span></span><br><span class=line>  <span class=attr>ui:</span></span><br><span class=line>    <span class=attr>image:</span> <span class=string>joxit/docker-registry-ui:static</span></span><br><span class=line>    <span class=attr>ports:</span></span><br><span class=line>      <span class=bullet>-</span> <span class=number>8080</span><span class=string>:80</span></span><br><span class=line>    <span class=attr>environment:</span></span><br><span class=line>      <span class=bullet>-</span> <span class=string>REGISTRY_TITLE=传智教育私有仓库</span></span><br><span class=line>      <span class=bullet>-</span> <span class=string>REGISTRY_URL=http://registry:5000</span></span><br><span class=line>    <span class=attr>depends_on:</span></span><br><span class=line>      <span class=bullet>-</span> <span class=string>registry</span></span><br></pre></table></figure><h3 id=3-1-3、配置并启动><a class=headerlink href=#3-1-3、配置并启动 title=3.1.3、配置并启动></a>3.1.3、配置并启动</h3><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=comment># 1、修改daemon.json   </span></span><br><span class=line><span class=attr>vim</span> <span class=string>/etc/docker/daemon.json</span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment># 2、添加内容</span></span><br><span class=line><span class=attr>{"insecure-registries"</span>:<span class=string>["私有仓库服务器ip:5000"]} </span></span><br><span class=line><span class=comment></span></span><br><span class=line><span class=comment># 3、重启docker 服务 </span></span><br><span class=line><span class=attr>systemctl</span> <span class=string>restart docker</span></span><br><span class=line><span class=attr>docker</span> <span class=string>start registry</span></span><br></pre></table></figure><p>编排<code>docker-compose.yml</code>文件：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker-compose up -d</span><br></pre></table></figure><h3 id=3-1-4、将镜像上传至私有仓库><a class=headerlink href=#3-1-4、将镜像上传至私有仓库 title=3.1.4、将镜像上传至私有仓库></a>3.1.4、将镜像上传至私有仓库</h3><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=comment># 1、标记镜像为私有仓库的镜像     </span></span><br><span class=line>docker tag centos:7 私有仓库服务器IP:5000/centos:7</span><br><span class=line> </span><br><span class=line><span class=comment># 2、上传标记的镜像     </span></span><br><span class=line>docker push 私有仓库服务器IP:5000/centos:7</span><br></pre></table></figure><h3 id=3-1-5、-从私有仓库拉取镜像><a title="3.1.5、 从私有仓库拉取镜像" class=headerlink href=#3-1-5、-从私有仓库拉取镜像></a>3.1.5、 从私有仓库拉取镜像</h3><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 拉取镜像 </span></span><br><span class=line>docker pull 私有仓库服务器ip:5000/centos:7</span><br></pre></table></figure><h2 id=3-2、阿里云镜像仓库><a class=headerlink href=#3-2、阿里云镜像仓库 title=3.2、阿里云镜像仓库></a>3.2、阿里云镜像仓库</h2><h3 id=3-2-1、搭建仓库环境><a class=headerlink href=#3-2-1、搭建仓库环境 title=3.2.1、搭建仓库环境></a>3.2.1、搭建仓库环境</h3><p><img alt=image-20220603095404618 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20220603095404618.png><p><img alt=image-20220603105318459 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20220603105318459.png><h3 id=3-2-2、登录阿里云Docker-Registry><a title="3.2.2、登录阿里云Docker Registry" class=headerlink href=#3-2-2、登录阿里云Docker-Registry></a>3.2.2、登录阿里云Docker Registry</h3><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>$ docker login --username=7874*****@qq.com registry.cn-shanghai.aliyuncs.com</span><br></pre></table></figure><p>用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。（可以在访问凭证页面修改密码。）<h3 id=3-2-3、-从Registry中拉取镜像><a title="3.2.3、 从Registry中拉取镜像" class=headerlink href=#3-2-3、-从Registry中拉取镜像></a>3.2.3、 从Registry中拉取镜像</h3><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>$ docker pull registry.cn-shanghai.aliyuncs.com/shh-docker-images/gulimall-nginx:[镜像版本号]</span><br></pre></table></figure><h3 id=3-2-4、将镜像推送到Registry><a class=headerlink href=#3-2-4、将镜像推送到Registry title=3.2.4、将镜像推送到Registry></a>3.2.4、将镜像推送到Registry</h3><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>$ docker login --username=7874*****@qq.com registry.cn-shanghai.aliyuncs.com</span><br><span class=line>$ docker tag [ImageId] registry.cn-shanghai.aliyuncs.com/shh-docker-images/gulimall-nginx:[镜像版本号]</span><br><span class=line>$ docker push registry.cn-shanghai.aliyuncs.com/shh-docker-images/gulimall-nginx:[镜像版本号]</span><br></pre></table></figure><p>请根据实际镜像信息替换示例中的ImageId和镜像版本号参数。<h3 id=3-2-5、选择合适的镜像仓库地址><a class=headerlink href=#3-2-5、选择合适的镜像仓库地址 title=3.2.5、选择合适的镜像仓库地址></a>3.2.5、选择合适的镜像仓库地址</h3><p>从ECS推送镜像时，可以选择使用镜像仓库内网地址。推送速度将得到提升并且不会损耗您的公网流量。<p>如果您使用的机器位于VPC网络，请使用 registry-vpc.cn-shanghai.aliyuncs.com 作为Registry的域名登录。<h3 id=3-2-6、示例><a class=headerlink href=#3-2-6、示例 title=3.2.6、示例></a>3.2.6、示例</h3><p>使用”docker tag”命令重命名镜像，并将它通过专有网络地址推送至Registry。<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>$ docker images</span><br><span class=line>REPOSITORY          TAG             IMAGE ID         CREATED           VIRTUAL SIZE</span><br><span class=line>registry.aliyuncs.com/acs/agent     0.7-dfb6816       37bb9c63c8b2       7 days ago     37.89 MB$ docker tag 37bb9c63c8b2 registry-vpc.cn-shanghai.aliyuncs.com/acs/agent:0.7-dfb6816</span><br></pre></table></figure><p>使用 “docker push” 命令将该镜像推送至远程。<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>$ docker push registry-vpc.cn-shanghai.aliyuncs.com/acs/agent:0.7-dfb6816</span><br></pre></table></figure><h1 id=4、服务编排><a class=headerlink href=#4、服务编排 title=4、服务编排></a>4、服务编排</h1><h2 id=4-1、简介><a class=headerlink href=#4-1、简介 title=4.1、简介></a>4.1、简介</h2><p>按照业务规则批量管理容器。常见服务编排工具是Docker Compose。<p><strong>Docker Compose是一个编排多容器分布式部署工具，提供命令集管理容器化应用的完整开发周期，包括服务构建，启动和停止。</strong><p>Docker Compose 使用步骤：<ol><li>利用 Dockerfile 定义运行环境镜像。<li>使用 docker-compose.yml 定义组成应用的各服务。<li>运行 docker-compose up 启动应用。</ol><h2 id=4-2、安装Docker-Compose><a title="4.2、安装Docker Compose" class=headerlink href=#4-2、安装Docker-Compose></a>4.2、安装Docker Compose</h2><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=comment># Compose目前已经完全支持Linux、Mac OS和Windows，在我们安装Compose之前，需要先安装Docker。下面我们以编译好的二进制包方式安装在Linux系统中。 </span></span><br><span class=line>curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`<span class=built_in>uname</span> -s`-`<span class=built_in>uname</span> -m` -o /usr/local/bin/docker-compose</span><br><span class=line></span><br><span class=line><span class=comment># 设置文件可执行权限 </span></span><br><span class=line><span class=built_in>chmod</span> +x /usr/local/bin/docker-compose</span><br><span class=line></span><br><span class=line><span class=comment># 查看版本信息 </span></span><br><span class=line>docker-compose -version</span><br></pre></table></figure><h2 id=4-3、卸载Docker-Compose><a title="4.3、卸载Docker Compose" class=headerlink href=#4-3、卸载Docker-Compose></a>4.3、卸载Docker Compose</h2><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment># 如果通过二进制包方式安装，则删除二进制文件即可</span></span><br><span class=line><span class=built_in>rm</span> /usr/local/bin/docker-compose</span><br></pre></table></figure><h2 id=4-4、编排nginx-springboot项目><a class=headerlink href=#4-4、编排nginx-springboot项目 title=4.4、编排nginx+springboot项目></a>4.4、编排nginx+springboot项目</h2><h3 id=4-4-1、创建docker-compose目录><a class=headerlink href=#4-4-1、创建docker-compose目录 title=4.4.1、创建docker-compose目录></a>4.4.1、创建docker-compose目录</h3><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=built_in>mkdir</span> ~/docker-compose</span><br><span class=line><span class=built_in>cd</span> ~/docker-compose</span><br></pre></table></figure><h3 id=4-4-2、编写-docker-compose-yml-文件><a title="4.4.2、编写 docker-compose.yml 文件" class=headerlink href=#4-4-2、编写-docker-compose-yml-文件></a>4.4.2、编写 docker-compose.yml 文件</h3><figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=attr>version:</span> <span class=string>'3'</span></span><br><span class=line><span class=attr>services:</span></span><br><span class=line>  <span class=attr>nginx:</span></span><br><span class=line>   <span class=attr>image:</span> <span class=string>nginx</span></span><br><span class=line>   <span class=attr>ports:</span></span><br><span class=line>    <span class=bullet>-</span> <span class=number>80</span><span class=string>:80</span></span><br><span class=line>   <span class=attr>links:</span></span><br><span class=line>    <span class=bullet>-</span> <span class=string>app</span></span><br><span class=line>   <span class=attr>volumes:</span></span><br><span class=line>    <span class=bullet>-</span> <span class=string>./nginx/conf.d:/etc/nginx/conf.d</span></span><br><span class=line>  <span class=attr>app:</span></span><br><span class=line>    <span class=attr>image:</span> <span class=string>app</span></span><br><span class=line>    <span class=attr>expose:</span></span><br><span class=line>      <span class=bullet>-</span> <span class=string>"8080"</span></span><br></pre></table></figure><h3 id=4-4-3、创建-nginx-conf-d目录><a class=headerlink href=#4-4-3、创建-nginx-conf-d目录 title=4.4.3、创建./nginx/conf.d目录></a>4.4.3、创建./nginx/conf.d目录</h3><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>mkdir</span> -p ./nginx/conf.d</span><br></pre></table></figure><h3 id=4-4-4、在-nginx-conf-d目录下-编写itheima-conf文件><a title="4.4.4、在./nginx/conf.d目录下 编写itheima.conf文件" class=headerlink href=#4-4-4、在-nginx-conf-d目录下-编写itheima-conf文件></a>4.4.4、在./nginx/conf.d目录下 编写itheima.conf文件</h3><figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=attr>server</span> <span class=string>{</span></span><br><span class=line>    <span class=attr>listen</span> <span class=string>80;</span></span><br><span class=line>    <span class=attr>access_log</span> <span class=string>off;</span></span><br><span class=line>    <span class=attr>location</span> <span class=string>/ {</span></span><br><span class=line>        <span class=attr>proxy_pass</span> <span class=string>http://app:8080;</span></span><br><span class=line>    <span class=attr>}</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><h3 id=4-4-5、在-docker-compose-目录下-使用docker-compose-启动容器><a title="4.4.5、在~/docker-compose 目录下 使用docker-compose 启动容器" class=headerlink href=#4-4-5、在-docker-compose-目录下-使用docker-compose-启动容器></a>4.4.5、在~/docker-compose 目录下 使用docker-compose 启动容器</h3><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker-compose up -d</span><br></pre></table></figure><h3 id=4-4-6、测试访问><a class=headerlink href=#4-4-6、测试访问 title=4.4.6、测试访问></a>4.4.6、测试访问</h3><figure class="highlight http"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>http://192.168.149.135/hello</span><br></pre></table></figure><h2 id=4-5、文件模板><a class=headerlink href=#4-5、文件模板 title=4.5、文件模板></a>4.5、文件模板</h2><p>模板文件，仅供查询使用。<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br></pre><td class=code><pre><span class=line><span class=attr>version:</span> <span class=string>'3'</span></span><br><span class=line><span class=attr>services:</span></span><br><span class=line>  <span class=attr>webapp:</span></span><br><span class=line>    <span class=attr>build:</span>	<span class=comment># 指定为从上下文路径 ./dir/Dockerfile 所构建的镜像：</span></span><br><span class=line>      <span class=attr>context:</span> <span class=string>./dir</span> 	<span class=comment>#上下文路径。</span></span><br><span class=line>      <span class=attr>dockerfile:</span> <span class=string>Dockerfile-alternate</span>	<span class=comment>#指定构建镜像的 Dockerfile 文件名。</span></span><br><span class=line>      <span class=attr>args:</span>		<span class=comment>#添加构建参数，这是只能在构建过程中访问的环境变量。</span></span><br><span class=line>        <span class=attr>buildno:</span> <span class=number>1</span></span><br><span class=line>      <span class=attr>labels:</span>	<span class=comment>#设置构建镜像的标签。</span></span><br><span class=line>        <span class=bullet>-</span> <span class=string>"com.example.description=Accounting webapp"</span></span><br><span class=line>        <span class=bullet>-</span> <span class=string>"com.example.department=Finance"</span></span><br><span class=line>        <span class=bullet>-</span> <span class=string>"com.example.label-with-empty-value"</span></span><br><span class=line>      <span class=attr>target:</span> <span class=string>prod</span>	<span class=comment>#多层构建，可以指定构建哪一层。</span></span><br><span class=line>    <span class=attr>cap_add:</span></span><br><span class=line>      <span class=bullet>-</span> <span class=string>ALL</span> <span class=comment># 开启全部权限</span></span><br><span class=line>	<span class=attr>cap_drop:</span></span><br><span class=line>      <span class=bullet>-</span> <span class=string>SYS_PTRACE</span> <span class=comment># 关闭 ptrace权限</span></span><br><span class=line>	<span class=attr>cgroup_parent:</span> <span class=string>m-executor-abcd</span>		<span class=comment>#为容器指定父 cgroup 组，意味着将继承该组的资源限制。</span></span><br><span class=line>    <span class=attr>command:</span> [<span class=string>"bundle"</span>, <span class=string>"exec"</span>, <span class=string>"thin"</span>, <span class=string>"-p"</span>, <span class=string>"3000"</span>]	<span class=comment>#覆盖容器启动的默认命令。</span></span><br><span class=line>	<span class=attr>container_name:</span> <span class=string>my-web-container</span>	<span class=comment>#指定自定义容器名称，而不是生成的默认名称。</span></span><br><span class=line>	<span class=attr>depends_on:</span>		<span class=comment># 设置依赖关系。先启动 db 和 redis ，才会启动 webapp。注意：web 服务不会等待 redis db 完全启动 之后才启动。</span></span><br><span class=line>      <span class=bullet>-</span> <span class=string>db</span></span><br><span class=line>      <span class=bullet>-</span> <span class=string>redis</span></span><br><span class=line>  <span class=attr>db:</span></span><br><span class=line>    <span class=attr>image:</span> <span class=string>postgres</span></span><br><span class=line>	<span class=attr>devices:</span>	<span class=comment>#指定设备映射列表。</span></span><br><span class=line>      <span class=bullet>-</span> <span class=string>"/dev/ttyUSB0:/dev/ttyUSB0"</span></span><br><span class=line>	<span class=attr>dns:</span>	<span class=comment>#自定义 DNS 服务器，可以是单个值或列表的多个值。</span></span><br><span class=line>      <span class=bullet>-</span> <span class=number>8.8</span><span class=number>.8</span><span class=number>.8</span></span><br><span class=line>      <span class=bullet>-</span> <span class=number>9.9</span><span class=number>.9</span><span class=number>.9</span></span><br><span class=line>	<span class=attr>dns_search:</span>		<span class=comment>#自定义 DNS 搜索域。可以是单个值或列表。</span></span><br><span class=line>      <span class=bullet>-</span> <span class=string>dc1.example.com</span></span><br><span class=line>      <span class=bullet>-</span> <span class=string>dc2.example.com</span></span><br><span class=line>	<span class=attr>entrypoint:</span> <span class=string>/code/entrypoint.sh</span>		<span class=comment>#覆盖容器默认的 entrypoint。</span></span><br><span class=line>    <span class=attr>env_file:</span> <span class=string>.env</span>		<span class=comment>#从文件添加环境变量。可以是单个值或列表的多个值。</span></span><br><span class=line>	<span class=attr>environment:</span>	<span class=comment>#添加环境变量。</span></span><br><span class=line>      <span class=attr>RACK_ENV:</span> <span class=string>development</span></span><br><span class=line>      <span class=attr>SHOW:</span> <span class=string>'true'</span></span><br><span class=line>	<span class=attr>expose:</span>		<span class=comment>#暴露端口，但不映射到宿主机，只被连接的服务访问。</span></span><br><span class=line>      <span class=bullet>-</span> <span class=string>"3000"</span></span><br><span class=line>      <span class=bullet>-</span> <span class=string>"8000"</span></span><br><span class=line>	<span class=attr>extra_hosts:</span>		<span class=comment>#添加主机名映射。类似 docker client --add-host。</span></span><br><span class=line>      <span class=bullet>-</span> <span class=string>"somehost:162.242.195.82"</span></span><br><span class=line>      <span class=bullet>-</span> <span class=string>"otherhost:50.31.209.229"</span></span><br><span class=line>	<span class=attr>network_mode:</span> <span class=string>"bridge/host/none/service:[service name]/container:[container name/id]"</span>	<span class=comment>#设置网络模式。</span></span><br><span class=line>    <span class=attr>restart:</span> <span class=string>"no/always/on-failure/unless-stopped"</span>	<span class=comment>#注：swarm 集群模式，请改用 restart_policy。</span></span><br><span class=line>  <span class=attr>redis:</span></span><br><span class=line>    <span class=attr>image:</span> <span class=string>redis:alpine</span></span><br><span class=line>    <span class=attr>deploy:</span>		<span class=comment>#指定与服务的部署和运行有关的配置。只在 swarm 模式下才会有用。</span></span><br><span class=line>      <span class=string>mode：replicated</span></span><br><span class=line>      <span class=attr>replicas:</span> <span class=number>6</span>	<span class=comment>#mode 为 replicated 时，需要使用此参数配置具体运行的节点数量。</span></span><br><span class=line>      <span class=attr>endpoint_mode:</span> <span class=string>dnsrr</span>	<span class=comment>#访问集群服务的方式。</span></span><br><span class=line>      <span class=attr>labels:</span> 		<span class=comment>#在服务上设置标签。可以用容器上的 labels（跟 deploy 同级的配置） 覆盖 deploy 下的 labels。</span></span><br><span class=line>        <span class=attr>description:</span> <span class=string>"This redis service label"</span></span><br><span class=line>      <span class=attr>resources:</span>		<span class=comment>#配置服务器资源使用的限制</span></span><br><span class=line>        <span class=attr>limits:</span></span><br><span class=line>          <span class=attr>cpus:</span> <span class=string>'0.50'</span></span><br><span class=line>          <span class=attr>memory:</span> <span class=string>50M</span></span><br><span class=line>        <span class=attr>reservations:</span></span><br><span class=line>          <span class=attr>cpus:</span> <span class=string>'0.25'</span></span><br><span class=line>          <span class=attr>memory:</span> <span class=string>20M</span></span><br><span class=line>      <span class=attr>restart_policy:</span>		<span class=comment>#配置如何在退出容器时重新启动容器。</span></span><br><span class=line>        <span class=attr>condition:</span> <span class=string>on-failure</span></span><br><span class=line>        <span class=attr>delay:</span> <span class=string>5s</span></span><br><span class=line>        <span class=attr>max_attempts:</span> <span class=number>3</span></span><br><span class=line>        <span class=attr>window:</span> <span class=string>120s</span></span><br><span class=line>  <span class=attr>secrets:</span></span><br><span class=line>	  <span class=attr>my_secret:</span></span><br><span class=line>		<span class=attr>file:</span> <span class=string>./my_secret.txt</span>	<span class=comment>##存储敏感数据，可以写在文件中，然后在其他地方引用。</span></span><br><span class=line>  <span class=attr>mysql:</span></span><br><span class=line>    <span class=attr>image:</span> <span class=string>mysql</span></span><br><span class=line>	<span class=attr>secrets:</span>	<span class=comment>#存储敏感数据，例如密码：</span></span><br><span class=line>      <span class=bullet>-</span> <span class=string>my_secret</span></span><br><span class=line>	<span class=string>security-opt：</span>		<span class=comment>#修改容器默认的 schema 标签。</span></span><br><span class=line>	  <span class=bullet>-</span> <span class=string>label:user:USER</span>   <span class=comment># 设置容器的用户标签</span></span><br><span class=line>	  <span class=bullet>-</span> <span class=string>label:role:ROLE</span>   <span class=comment># 设置容器的角色标签</span></span><br><span class=line>	  <span class=bullet>-</span> <span class=string>label:type:TYPE</span>   <span class=comment># 设置容器的安全策略标签</span></span><br><span class=line>	  <span class=bullet>-</span> <span class=string>label:level:LEVEL</span>  <span class=comment># 设置容器的安全等级标签</span></span><br><span class=line>    <span class=attr>stop_grace_period:</span> <span class=string>1m30s</span> <span class=comment># 等待 1 分 30 秒 		#指定在容器无法处理 SIGTERM (或者任何 stop_signal 的信号)，等待多久后发送 SIGKILL 信号关闭容器。</span></span><br><span class=line>	<span class=attr>stop_signal:</span> <span class=string>SIGUSR1</span>	<span class=comment>#设置停止容器的替代信号。默认情况下使用 SIGTERM 。</span></span><br><span class=line>	<span class=attr>sysctls:</span>		<span class=comment>#设置容器中的内核参数，可以使用数组或字典格式。</span></span><br><span class=line>	  <span class=bullet>-</span> <span class=string>net.core.somaxconn=1024</span></span><br><span class=line>	  <span class=bullet>-</span> <span class=string>net.ipv4.tcp_syncookies=0</span></span><br><span class=line>	<span class=attr>tmpfs:</span>		<span class=comment>#在容器内安装一个临时文件系统。可以是单个值或列表的多个值。</span></span><br><span class=line>	  <span class=bullet>-</span> <span class=string>/run</span></span><br><span class=line>	  <span class=bullet>-</span> <span class=string>/tmp</span></span><br><span class=line>	<span class=attr>ulimits:</span>		<span class=comment>#覆盖容器默认的 ulimit。</span></span><br><span class=line>	  <span class=attr>nproc:</span> <span class=number>65535</span></span><br><span class=line>	  <span class=attr>nofile:</span></span><br><span class=line>		<span class=attr>soft:</span> <span class=number>20000</span></span><br><span class=line>		<span class=attr>hard:</span> <span class=number>40000</span></span><br><span class=line>    <span class=attr>volumes:</span>		<span class=comment>#将主机的数据卷或着文件挂载到容器里。</span></span><br><span class=line>      <span class=bullet>-</span> <span class=string>"/localhost/postgres.sock:/var/run/postgres/postgres.sock"</span></span><br><span class=line>      <span class=bullet>-</span> <span class=string>"/localhost/data:/var/lib/postgresql/data"</span></span><br></pre></table></figure><h1 id=5、数据卷><a class=headerlink href=#5、数据卷 title=5、数据卷></a>5、数据卷</h1><h2 id=5-1、概述><a class=headerlink href=#5-1、概述 title=5.1、概述></a>5.1、概述</h2><ol><li>数据卷是宿主机中的一个目录或文件。<li>当容器目录和数据卷目录绑定后，对方的修改会立即同步。<li>一个数据卷可以被多个容器同时挂载。<li>一个容器也可以挂载多个数据卷。</ol><h2 id=5-2、数据卷作用><a class=headerlink href=#5-2、数据卷作用 title=5.2、数据卷作用></a>5.2、数据卷作用</h2><ol><li>容器数据持久化。<li>外部机器和容器间接通信。<li>容器之间数据交换。</ol><h2 id=5-3、常用命令><a class=headerlink href=#5-3、常用命令 title=5.3、常用命令></a>5.3、常用命令</h2><p>数据卷常用命令如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=comment># 创建数据卷对象</span></span><br><span class=line>docker volume create</span><br><span class=line><span class=comment># 查看数据卷详细信息</span></span><br><span class=line>docker volume inspect</span><br><span class=line><span class=comment># 查看已经创建的数据卷对象</span></span><br><span class=line>docker volume <span class=built_in>ls</span></span><br><span class=line><span class=comment># 删除没有被使用的数据卷对象</span></span><br><span class=line>docker volume prune</span><br><span class=line><span class=comment># 删除一个或多个数据卷对象</span></span><br><span class=line>docker volume <span class=built_in>rm</span></span><br></pre></table></figure><h2 id=5-4、数据卷管理><a class=headerlink href=#5-4、数据卷管理 title=5.4、数据卷管理></a>5.4、数据卷管理</h2><p>挂载数据卷的方式主要有三种：<ul><li><strong>bind mounts</strong>：将宿主机中的一个文件或目录 挂载到 容器中。<li><strong>volumes</strong>：由docker创建和管理，使用docker volume命令来管理。<li><strong>tmpfs mounts</strong>：tmpfs是一种基于内存的临时文件系统，该系统的数据不会存在硬盘中。</ul><h3 id=5-4-1、bind-mounts><a title="5.4.1、bind mounts" class=headerlink href=#5-4-1、bind-mounts></a>5.4.1、bind mounts</h3><p>使用方式如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># 方式1</span></span><br><span class=line>-v 宿主机文件或文件夹路径:容器中的文件或文件夹路径</span><br><span class=line><span class=comment># 方式2</span></span><br><span class=line>--mount <span class=built_in>type</span>=<span class=built_in>bind</span>, src=宿主机文件或文件夹路径, dst=容器中文件或文件夹路径</span><br></pre></table></figure><p>注意事项：<ul><li>src指定的文件或文件夹必须事先存在。</ul><h3 id=5-4-2、volumes><a class=headerlink href=#5-4-2、volumes title=5.4.2、volumes></a>5.4.2、volumes</h3><p>使用方式如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment># 方式1</span></span><br><span class=line>-v VOLUME-NAME:容器中的文件或文件夹路径</span><br><span class=line><span class=comment># 方式2</span></span><br><span class=line>--mount <span class=built_in>type</span>=volume, src=VOLUME-NAME, dst=容器中的文件或文件夹路径</span><br></pre></table></figure><p>注意事项：<ol><li>目录必须是绝对路径。<li>如果目录不存在，会自动创建。<li>可以挂载多个数据卷。</ol><h3 id=5-4-3、tmpfs-mount><a title="5.4.3、tmpfs mount" class=headerlink href=#5-4-3、tmpfs-mount></a>5.4.3、tmpfs mount</h3><p>使用方式如下：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>--mount <span class=built_in>type</span>=tmpfs, dst=PATH</span><br></pre></table></figure><h2 id=5-5、数据卷容器><a class=headerlink href=#5-5、数据卷容器 title=5.5、数据卷容器></a>5.5、数据卷容器</h2><h3 id=5-5-1、数据卷容器作用><a class=headerlink href=#5-5-1、数据卷容器作用 title=5.5.1、数据卷容器作用></a>5.5.1、数据卷容器作用</h3><ol><li>多容器进行数据交换。<li>容器数据持久化。<li>容器间数据交换。</ol><h3 id=5-5-2、配置数据卷容器><a class=headerlink href=#5-5-2、配置数据卷容器 title=5.5.2、配置数据卷容器></a>5.5.2、配置数据卷容器</h3><ol><li><p>创建启动c3数据卷容器，使用 –v 参数 设置数据卷。</p> <figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker run –it --name=c3 –v /data:/data centos:7 /bin/bash </span><br></pre></table></figure><li><p>创建启动 c1、c2 容器，使用 –-volumes-from 参数 设置数据卷。</p> <figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>docker run –it --name=c1 --volumes-from c3 centos:7 /bin/bash</span><br><span class=line>docker run –it --name=c2 --volumes-from c3 centos:7 /bin/bash</span><br></pre></table></figure><li><p>在各个容器的根目录下会有一个volume文件夹，该文件夹就是共享文件夹，赶紧共享一些东西试试吧。</p></ol><h2 id=5-6、注意事项><a class=headerlink href=#5-6、注意事项 title=5.6、注意事项></a>5.6、注意事项</h2><p>在使用数据券时需要注意以下几点：<ul><li>如果挂载一个空数据卷到容器中的一个非空目录，那么该目录下的文件会被复制到数据卷中。<li>如果挂载一个非空的数据卷到容器中的一个目录，那么该目录下会显示数据卷中的内容。如果该目录最初已经存在数据，那么这些数据会被隐藏。</ul><h1 id=6、容器监控Potainer><a class=headerlink href=#6、容器监控Potainer title=6、容器监控Potainer></a>6、容器监控Potainer</h1><h2 id=6-1、安装运行><a class=headerlink href=#6-1、安装运行 title=6.1、安装运行></a>6.1、安装运行</h2><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>docker run -d \</span><br><span class=line>--name portainer \</span><br><span class=line>-p 8000:8000 -p 9000:9000 \</span><br><span class=line>--restart=always \</span><br><span class=line>-v /tmp/docker/run/docker.sock:/var/run/docker.sock \</span><br><span class=line>-v /tmp/docker/data:/data \</span><br><span class=line>portainer/portainer-ce:latest</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Docker%E5%AE%89%E8%A3%85%E4%BC%98%E5%8C%96/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Docker%E5%AE%89%E8%A3%85%E4%BC%98%E5%8C%96/ itemprop=url>Docker系列-Docker安装优化</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-07 16:47:02" datetime=2023-08-07T16:47:02+08:00 itemprop=dateModified>2023-08-07</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Docker/ itemprop=url rel=index><span itemprop=name>Docker</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、安装><a class=headerlink href=#1、安装 title=1、安装></a>1、安装</h1><h2 id=1-1、yum包更新到最新><a class=headerlink href=#1-1、yum包更新到最新 title=1.1、yum包更新到最新></a>1.1、yum包更新到最新</h2><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>yum update</span><br></pre></table></figure><h2 id=1-2、安装前置依赖。><a class=headerlink href=#1-2、安装前置依赖。 title=1.2、安装前置依赖。></a>1.2、安装前置依赖。</h2><p>yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动需要依赖。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></table></figure><h2 id=1-3、设置yum源><a class=headerlink href=#1-3、设置yum源 title=1.3、设置yum源></a>1.3、设置yum源</h2><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></table></figure><p><strong>注意</strong>：如果以上命令执行完后没有报错，则下面命令可省略，否则执行下面命令后再次执行上面命令。<figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>yum install https://download.docker.com/linux/fedora/30/x86_64/stable/Packages/containerd.io-1.2.6-3.3.fc30.x86_64.rpm</span><br></pre></table></figure><h2 id=1-4、安装docker并启动><a class=headerlink href=#1-4、安装docker并启动 title=1.4、安装docker并启动></a>1.4、安装docker并启动</h2><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class="meta prompt_"># </span><span class=language-bash>安装</span></span><br><span class=line>yum install -y docker-ce</span><br><span class=line><span class="meta prompt_"># </span><span class=language-bash>启动</span></span><br><span class=line>systemctl start docker</span><br></pre></table></figure><h2 id=1-5、查看docker版本><a class=headerlink href=#1-5、查看docker版本 title=1.5、查看docker版本></a>1.5、查看docker版本</h2><figure class="highlight shell"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker -v</span><br></pre></table></figure><h1 id=2、优化><a class=headerlink href=#2、优化 title=2、优化></a>2、优化</h1><h2 id=2-1、配置国内Docker镜像源><a class=headerlink href=#2-1、配置国内Docker镜像源 title=2.1、配置国内Docker镜像源></a>2.1、配置国内Docker镜像源</h2><h3 id=2-1-1、国内镜像源><a class=headerlink href=#2-1-1、国内镜像源 title=2.1.1、国内镜像源></a>2.1.1、国内镜像源</h3><p>目前国内常用的docker镜像源如下：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=comment>#网易：</span></span><br><span class=line><span class=attr>http</span>:<span class=string>//hub-mirror.c.163.com</span></span><br><span class=line><span class=comment>#中科大镜像地址：</span></span><br><span class=line><span class=attr>http</span>:<span class=string>//mirrors.ustc.edu.cn/</span></span><br><span class=line><span class=comment>#中科大github地址：</span></span><br><span class=line><span class=attr>https</span>:<span class=string>//github.com/ustclug/mirrorrequest</span></span><br><span class=line><span class=comment>#Azure中国镜像地址：</span></span><br><span class=line><span class=attr>http</span>:<span class=string>//mirror.azure.cn/</span></span><br><span class=line><span class=comment>#Azure中国github地址：</span></span><br><span class=line><span class=attr>https</span>:<span class=string>//github.com/Azure/container-service-for-azure-china</span></span><br><span class=line><span class=comment>#DockerHub镜像仓库: </span></span><br><span class=line><span class=attr>https</span>:<span class=string>//hub.docker.com/ </span></span><br><span class=line><span class=comment>#阿里云镜像仓库： </span></span><br><span class=line><span class=attr>https</span>:<span class=string>//cr.console.aliyun.com </span></span><br><span class=line><span class=comment>#google镜像仓库（前提可以连接google）： </span></span><br><span class=line><span class=attr>https</span>:<span class=string>//console.cloud.google.com/gcr/images/google-containers/GLOBAL</span></span><br><span class=line><span class=comment>#coreos镜像仓库： </span></span><br><span class=line><span class=attr>https</span>:<span class=string>//quay.io/repository/ </span></span><br><span class=line><span class=comment>#RedHat镜像仓库： </span></span><br><span class=line><span class=attr>https</span>:<span class=string>//access.redhat.com/containers</span></span><br></pre></table></figure><h3 id=2-1-2、配置镜像源><a class=headerlink href=#2-1-2、配置镜像源 title=2.1.2、配置镜像源></a>2.1.2、配置镜像源</h3><p>直接执行如下命令即可：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=built_in>sudo</span> <span class=built_in>mkdir</span> -p /etc/docker</span><br><span class=line><span class=built_in>sudo</span> <span class=built_in>tee</span> /etc/docker/daemon.json <&LT-<span class=string>'EOF'</span></span><br><span class=line>{</span><br><span class=line>    <span class=string>"registry-mirrors"</span>: [</span><br><span class=line>        <span class=string>"http://hub-mirror.c.163.com"</span>,</span><br><span class=line>        <span class=string>"https://docker.mirrors.ustc.edu.cn"</span>,</span><br><span class=line>        <span class=string>"https://registry.docker-cn.com"</span></span><br><span class=line>    ]</span><br><span class=line>}</span><br><span class=line>EOF</span><br><span class=line><span class=built_in>sudo</span> systemctl daemon-reload</span><br><span class=line><span class=built_in>sudo</span> systemctl restart docker</span><br></pre></table></figure><p>通过如下命令的输出结果可查看配置是否生效：<figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker info</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/CPU%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/CPU%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/ itemprop=url>计算机系列-CPU</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-06 11:28:26" datetime=2023-10-06T11:28:26+08:00 itemprop=dateModified>2023-10-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/ itemprop=url rel=index><span itemprop=name>计算机</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、CPU><a class=headerlink href=#1、CPU title=1、CPU></a>1、CPU</h1><h2 id=1-1、认识CPU><a class=headerlink href=#1-1、认识CPU title=1.1、认识CPU></a>1.1、认识CPU</h2><h3 id=1-1-1、CPU简介><a class=headerlink href=#1-1-1、CPU简介 title=1.1.1、CPU简介></a>1.1.1、CPU简介</h3><p><strong>CPU 是英文 Central Processing Unit 的首字母缩写，意为中央处理器。</strong><p>CPU相当于计算机的大脑，其内部由 数百万 至 数亿 个晶体管组成。<strong>CPU是各种功能寄存器的集合体。</strong><h3 id=1-1-2、CPU周期><a class=headerlink href=#1-1-2、CPU周期 title=1.1.2、CPU周期></a>1.1.2、CPU周期</h3><p>CPU周期可描述为：<strong>首先从内存中取出指令，解码以确定其类型和操作数，接着执行，然后取指令、解码并执行下一条指令。</strong>按照该方式，程序被执行完成。<h3 id=1-1-3、CPU指令集><a class=headerlink href=#1-1-3、CPU指令集 title=1.1.3、CPU指令集></a>1.1.3、CPU指令集</h3><p><strong>每个CPU都有一套可执行的专属指令集。</strong>所以，Pentium不能执行SPARC程序，而SPARC也不能执行Pentium程序。<p>由于用来访问内存以得到指令或数据的时间要比执行指令花费的时间长得多，因此，<strong>所有的CPU内都有一些用来保存关键变量和临时数据的寄存器。</strong><h3 id=1-1-4、CPU流水线><a class=headerlink href=#1-1-4、CPU流水线 title=1.1.4、CPU流水线></a>1.1.4、CPU流水线</h3><p>一个CPU可以有分开的取指单元、解码单元和执行单元，当它执行指令n时，它还可以对指令n+1解码，并且读取指令n+2。这样一种机制称为流水线(pipeline)。<p>对于多数流水线来说，一旦一条指令被 放入 流水线中，它就必须被执行完毕，即便前一条指令是条件转移，它也必须被执行完毕。<p><strong>比流水线更先进的设计是一种 超标量CPU。</strong><p>超标量CPU 中有 多个执行单元，两个或更多的指令被同时取出、解码并装入一个保持缓冲区中，直至它们执行完毕。只要有一个执行单元空闲，就检查保持缓冲区中是否还有可处理的指令，如果有，就把指令从缓冲区中移出并执行之。<p>这种设计存在一种隐含的作用，即<strong>程序指令经常不按顺序执行。</strong>在多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同，但是，仍然有部分令人烦恼的复杂情形被强加给操作系统处理<h3 id=1-1-5、用户态与内核态><a class=headerlink href=#1-1-5、用户态与内核态 title=1.1.5、用户态与内核态></a>1.1.5、用户态与内核态</h3><p><strong>多数CPU都有 用户态 和 内核态 两种模式。程序状态字(Program Status Word，PSW)寄存器中有一个二进制位控制这两种模式。</strong><p>用户态和内核态的权限也不同，区别分析如下：<ul><li><p><strong>内核态</strong>：当在内核态运行时，CPU可以执行指令集中的每一条指令，并且使用硬件的每种功能。</p><li><p><strong>用户态</strong>：在用户态下运行时，仅允许执行整个指令集的一个子集和访问所有功能的一个子集。</p></ul><h2 id=1-2、CPU内部组成><a class=headerlink href=#1-2、CPU内部组成 title=1.2、CPU内部组成></a>1.2、CPU内部组成</h2><p>CPU和内存是由许多晶体管组成的<strong>电子部件</strong>，通常称为 IC(Integrated Circuit，集成电路)。从功能上来说，<strong>CPU内部由寄存器、控制器、运算器、时钟四个部分构成，各部分之间通过电流信号相互连通</strong>。<h3 id=1-2-1、寄存器><a class=headerlink href=#1-2-1、寄存器 title=1.2.1、寄存器></a>1.2.1、寄存器</h3><h4 id=1-2-1-1、寄存器简介><a class=headerlink href=#1-2-1-1、寄存器简介 title=1.2.1.1、寄存器简介></a>1.2.1.1、寄存器简介</h4><p><strong>寄存器中存储的是 指令 和 数据。数据分为用于运算的数值和表示内存地址的数值两种。</strong><p>寄存器特点如下：<ol><li>不同类型的CPU，其内部寄存器的数量、种类 以及 寄存器存储的数值范围 都不相同。<li>CPU中每个寄存器的功能都不同。<li>数据种类不同，存储该数据的寄存器也不同。</ol><h4 id=1-2-1-2、寄存器分类><a class=headerlink href=#1-2-1-2、寄存器分类 title=1.2.1.2、寄存器分类></a>1.2.1.2、寄存器分类</h4><p>根据功能不同，寄存器可大致分为以下八种：<ol><li>**累加寄存器(accumulator register)**：存储 运算数据 和 运算后数据。<li>**标志寄存器(flag register)**：存储 运算处理后的 CPU状态。<li>**程序计数器(program counter)**：存储 下一条指令所在内存的 地址。<li>**基址寄存器(base register)**：存储 数据内存的 起始地址。<li>**变址寄存器(index register)**：存储 基址寄存器的 相对地址。<li>**通用寄存器(general purpose register)**：存储 任意数据。<li>**指令寄存器(instruction register)**：存储 指令。CPU内部使用，程序员无法干预。<li>**栈寄存器(stack register)**：存储 栈区域的 起始地址。</ol><p><strong>每一种寄存器允许存在的数量也有限制</strong>，分析如下：<ul><li>允许一个：累加寄存器、标志寄存器、程序计数器、指令寄存器、栈寄存器；<li>允许多个：基址寄存器、变址寄存器、通用寄存器。</ul><p>除了以上寄存器外，还有一个 <strong>程序状态字（Program Status Word，PSW）寄存器。该寄存器包含了条件码位（由比较指令设置）、CPU优先级、模式（用户态或内核态），以及各种其他控制位。用户程序通常读入整个PSW，但只对其中的少量字段写入。在系统调用和I/O中，PSW的作用很重要。</strong><h3 id=1-2-2、控制器><a class=headerlink href=#1-2-2、控制器 title=1.2.2、控制器></a>1.2.2、控制器</h3><p>控制器使命：把内存中的指令、数据等读入寄存器，并根据指令结果来控制整个计算机。<h3 id=1-2-3、运算器><a class=headerlink href=#1-2-3、运算器 title=1.2.3、运算器></a>1.2.3、运算器</h3><p>运算器使命：运算从内存读入寄存器的数据。<h3 id=1-2-4、时钟><a class=headerlink href=#1-2-4、时钟 title=1.2.4、时钟></a>1.2.4、时钟</h3><p>时钟使命：负责发出CPU开始计时的时钟信号。<blockquote><p>时钟信号 英文叫做 clock puzzle。Pentium 2GHz 表示 时钟信号的频率为 2GHz（1GHz = 10亿次/秒）。也就是说，时钟信号的频率越高，CPU运行速度越快。</blockquote><p><font color=red>注意：有些计算机的时钟 位于 CPU外部。</font><h3 id=1-2-5、总结><a class=headerlink href=#1-2-5、总结 title=1.2.5、总结></a>1.2.5、总结</h3><p>寄存器、控制器、运算器和时钟之间的工作方式和关系 可描述如下：<p><strong>程序启动后，控制器 会根据 时钟信号 从内存中 读取 指令和数据。通过 对这些 指令加以 解释和运行，运算器 会 运算这些数据，控制器 根据 运算结果 来控制计算机。</strong><blockquote><p>控制 指的是 数据运算外的处理（主要是 数据输入输出的 时机控制）。</blockquote><h2 id=1-3、内存><a class=headerlink href=#1-3、内存 title=1.3、内存></a>1.3、内存</h2><h3 id=1-3-1、简介><a class=headerlink href=#1-3-1、简介 title=1.3.1、简介></a>1.3.1、简介</h3><p><strong>通常所说的内存指的是计算机主存储器(main memory)，简称 主存。主存通过控制芯片与CPU 相连，主要负责存储指令和数据。</strong><p>主存 由 可读写的元素 构成，每个字节都带有一个地址编号。CPU可以通过 该地址 读取主存中的指令和数据 和 写入数据。<p><font color=red>注意：主存中存储的 指令和数据 会随着计算机的 关机 而 自动清除。</font><h2 id=1-4、CPU是寄存器集合体><a class=headerlink href=#1-4、CPU是寄存器集合体 title=1.4、CPU是寄存器集合体></a>1.4、CPU是寄存器集合体</h2><h3 id=1-4-1、简介><a class=headerlink href=#1-4-1、简介 title=1.4.1、简介></a>1.4.1、简介</h3><p>CPU四个组成部分中，需要重点了解 寄存器，其余三个可不用太过关注。因为 程序是把寄存器 作为对象 来描述的。<h3 id=1-4-2、汇编与反汇编><a class=headerlink href=#1-4-2、汇编与反汇编 title=1.4.2、汇编与反汇编></a>1.4.2、汇编与反汇编</h3><p><strong>汇编语言采用 助记符(memonic) 来编写程序，每一个原本是电信号的机器语言指令 都会有一个相应的 助记符，助记符通常是 指令功能的英语单词的简写。</strong>例如 mov 和 add 分别是数据的 存储(move) 和 相加(addition) 的简写。<p>汇编语言 和 机器语言 基本上是 一一对应。<ul><li><strong>汇编</strong>：将 汇编语言编写的程序 转化成 机器语言 的过程 称为 汇编。<li><strong>反汇编</strong>：将 机器语言程序 转化成 汇编语言程序 的过程 称为 反汇编。</ul><p><font color=red>注意：汇编语言是80386以上的CPU所使用的语言。</font><p>汇编示例程序如下所示：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>mov eax, dword ptr [ebp-8]     ; 把 数值 从内存 复制到 eax</span><br><span class=line>add eax, dword ptr [ebp-0Ch]   ; exa的数值 和 内存数值 相加</span><br><span class=line>mov dword ptr [ebp-4], eax     ; 把 eax的数值（上一步计算结果）存储在内存中</span><br></pre></table></figure><p>示例代码解析如下：<ul><li><strong>eax</strong>：表示 累加寄存器。<li><strong>ebp</strong>：表示 基址寄存器。</ul><h3 id=1-4-3、程序计数器><a class=headerlink href=#1-4-3、程序计数器 title=1.4.3、程序计数器></a>1.4.3、程序计数器</h3><p>对于 123 和 456 两个数值相加，内存内容模型如下图所示：<p><img alt=image-20210808233333149 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/05/image-20210808233333149.png?token=AIGEF3PSMSQDORNYKQSVDTTEZZVZM><p><strong>存储 指令和数据 的内存是通过 地址 来划分。</strong>一个命令和数据 通常被存储于 多个地址上，但为了便于说明，上图中把 指令、数据 分配到了一个地址中。<p>程序执行过程中，内存内容变化描述如下：<p><strong>地址0100 是程序运行的开始位置。Windows等操作系统 把 程序 从硬盘复制到内存后，会将 程序计数器 设定为0100，然后程序开始运行。CPU每执行一个指令，程序计数器的值 就会自动加 1。</strong><h3 id=1-4-4、条件分支和循环机制><a class=headerlink href=#1-4-4、条件分支和循环机制 title=1.4.4、条件分支和循环机制></a>1.4.4、条件分支和循环机制</h3><p><strong>程序的流程分为顺序执行、条件分支和循环 三种。</strong><ul><li><strong>顺序执行</strong>：按照 地址内容的顺序 执行指令。<li><strong>条件分支</strong>：根据条件 执行 任意地址的 指令。<li><strong>循环</strong>：重复执行同一地址的指令。</ul><p><strong>条件分支 和 循环 中使用的跳转指令，会参照当前执行的运算结果来判断是否跳转。</strong><p><strong>无论当前累加寄存器运算结果是负数、零还是正数，标志寄存器都会将其保存。</strong><p><strong>CPU运算时，标志寄存器 的数值 会根据 运算结果 自动设定。条件分支 在跳转指令前 会进行 比较运算。是否跳转指令，则由CPU 参考 寄存器数值 后进行判断。运行结果的正、零、负三种状态由标志寄存器的三个位来表示。</strong><ol><li>第一字节位为1时，表示 正数。<li>第二字节位为1时，表示 零。<li>第三字节位为1时，表示 负数。</ol><h3 id=1-4-5、函数调用><a class=headerlink href=#1-4-5、函数调用 title=1.4.5、函数调用></a>1.4.5、函数调用</h3><h4 id=1-4-5-1、简介><a class=headerlink href=#1-4-5-1、简介 title=1.4.5.1、简介></a>1.4.5.1、简介</h4><p><strong>函数调用一般是通过 把程序计数器的值设定成函数存储地址来实现。</strong><p><strong>函数调用需要在完成函数内部处理后，使得处理流程再返回到函数调用点。</strong><p><strong>函数调用原点 和 被调用函数地址 之间的数据传递可通过 内存 或 寄存器 来实现。</strong><h4 id=1-4-5-2、调用指令><a class=headerlink href=#1-4-5-2、调用指令 title=1.4.5.2、调用指令></a>1.4.5.2、调用指令</h4><p><strong>函数调用使用的是call指令，而不是跳转指令。</strong><p>在将 函数入口地址 设定到 程序计数器 之前，call指令 会把 调用函数后要执行的 指令地址 存储在 名为栈的主内存。函数处理完毕后，再通过 函数出口 来执行 return命令。return命令 功能是 把保存在栈中的地址 设定到 程序计数器中。<h3 id=1-4-6、CPU可执行的指令><a class=headerlink href=#1-4-6、CPU可执行的指令 title=1.4.6、CPU可执行的指令></a>1.4.6、CPU可执行的指令</h3><p>按照功能划分，可将CPU能执行的机器语言指令分以下几种：<ul><li><strong>数据转送指令</strong>：寄存器和内存、内存和内存、寄存器和外围设备 之间的 数据读写操作。<li><strong>运算指令</strong>：使用 累加寄存器 执行算术运算、逻辑运算、比较运算 和 移位运算。<li><strong>跳转指令</strong>：实现 条件分支、循环、强制跳转。<li><strong>call/return指令</strong>：函数调用 / 返回调用前的地址。</ul><p>CPU可以执行的指令非常少。虽然编写的程序看起来非常复杂，但CPU实际处理很简单。</div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Consul%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Consul%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/ itemprop=url>Consul系列-Consul基础应用</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 15:14:39" datetime=2023-10-02T15:14:39+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Consul/ itemprop=url rel=index><span itemprop=name>Consul</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、注册中心搭建><a class=headerlink href=#1、注册中心搭建 title=1、注册中心搭建></a>1、注册中心搭建</h1><h2 id=1-1、启动Consul服务><a class=headerlink href=#1-1、启动Consul服务 title=1.1、启动Consul服务></a>1.1、启动Consul服务</h2><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>consule/consul.exe</span><br></pre></table></figure><h1 id=2、注册服务><a class=headerlink href=#2、注册服务 title=2、注册服务></a>2、注册服务</h1><h2 id=2-1、添加依赖><a class=headerlink href=#2-1、添加依赖 title=2.1、添加依赖></a>2.1、添加依赖</h2><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.springframework.cloud<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>spring-cloud-starter-consul-discovery<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><h2 id=2-2、编写配置><a class=headerlink href=#2-2、编写配置 title=2.2、编写配置></a>2.2、编写配置</h2><figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=attr>server:</span></span><br><span class=line>  <span class=attr>port:</span> <span class=number>8070</span></span><br><span class=line></span><br><span class=line><span class=attr>spring:</span></span><br><span class=line>  <span class=attr>application:</span></span><br><span class=line>    <span class=attr>name:</span> <span class=string>shhsca-registry-consul-service</span></span><br><span class=line>  <span class=attr>cloud:</span></span><br><span class=line>    <span class=attr>consul:</span></span><br><span class=line>      <span class=attr>host:</span> <span class=string>localhost</span></span><br><span class=line>      <span class=attr>port:</span> <span class=number>8500</span></span><br><span class=line>      <span class=attr>discovery:</span></span><br><span class=line>        <span class=attr>service-name:</span> <span class=string>${spring.application.name}</span></span><br></pre></table></figure><h2 id=2-3、main方法><a class=headerlink href=#2-3、main方法 title=2.3、main方法></a>2.3、main方法</h2><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@SpringBootApplication</span></span><br><span class=line><span class=meta>@EnableDiscoveryClient</span> <span class=comment>// 基于consul或zookeeper作为注册中心时，提供注册服务支持。</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ConsulRegistryApplication</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        SpringApplication.run(ConsulRegistryServerApplication.class, args);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Canal%E7%9B%91%E6%8E%A7MySQL/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Canal%E7%9B%91%E6%8E%A7MySQL/ itemprop=url>Canal系列-Canal监听MySQL</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-07 17:02:30" datetime=2023-08-07T17:02:30+08:00 itemprop=dateModified>2023-08-07</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Canal/ itemprop=url rel=index><span itemprop=name>Canal</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、搭建MySQL服务><a class=headerlink href=#1、搭建MySQL服务 title=1、搭建MySQL服务></a>1、搭建MySQL服务</h1><p>本实例基于Docker来安装分析。<h2 id=1-1、运行MySQL实例><a class=headerlink href=#1-1、运行MySQL实例 title=1.1、运行MySQL实例></a>1.1、运行MySQL实例</h2><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>docker run -<span class=built_in>id</span> \</span><br><span class=line>-p 3360:3306 \</span><br><span class=line>--name=mysql-node1 \</span><br><span class=line>-v <span class=variable>$PWD</span>/conf:/etc/mysql/conf.d \</span><br><span class=line>-v <span class=variable>$PWD</span>/logs:/logs \</span><br><span class=line>-v <span class=variable>$PWD</span>/data:/var/lib/mysql \</span><br><span class=line>-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class=line>mysql:5.7</span><br></pre></table></figure><h2 id=1-2、开启MySQL主从><a class=headerlink href=#1-2、开启MySQL主从 title=1.2、开启MySQL主从></a>1.2、开启MySQL主从</h2><p>让canal作为slave，mysql作为master。<h3 id=1-2-1、修改配置文件><a class=headerlink href=#1-2-1、修改配置文件 title=1.2.1、修改配置文件></a>1.2.1、修改配置文件</h3><p>修改mysql配置文件，添加如下内容：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>log-bin=/var/lib/mysql/mysql-bin</span><br><span class=line>binlog-do-db=heima</span><br></pre></table></figure><ul><li><code>log-bin=/var/lib/mysql/mysql-bin</code>：设置binary log文件的存放地址和文件名，叫做mysql-bin<li><code>binlog-do-db=heima</code>：指定对哪个database记录binary log events，这里记录heima这个库</ul><p>最终效果：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>[mysqld]</span><br><span class=line>skip-name-resolve</span><br><span class=line>character_set_server=utf8</span><br><span class=line>datadir=/var/lib/mysql</span><br><span class=line>server-id=1000</span><br><span class=line>log-bin=/var/lib/mysql/mysql-bin</span><br><span class=line>binlog-do-db=heima</span><br></pre></table></figure><h3 id=1-2-2、配置用户权限><a class=headerlink href=#1-2-2、配置用户权限 title=1.2.2、配置用户权限></a>1.2.2、配置用户权限</h3><figure class="highlight sql"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=keyword>create</span> <span class=keyword>user</span> canal@<span class=string>'%'</span> IDENTIFIED <span class=keyword>by</span> <span class=string>'canal'</span>;</span><br><span class=line><span class=keyword>GRANT</span> <span class=keyword>SELECT</span>, REPLICATION SLAVE, REPLICATION CLIENT,SUPER <span class=keyword>ON</span> <span class=operator>*</span>.<span class=operator>*</span> <span class=keyword>TO</span> <span class=string>'canal'</span>@<span class=string>'%'</span> identified <span class=keyword>by</span> <span class=string>'canal'</span>;</span><br><span class=line>FLUSH PRIVILEGES;</span><br></pre></table></figure><h3 id=1-2-3、重启mysql><a class=headerlink href=#1-2-3、重启mysql title=1.2.3、重启mysql></a>1.2.3、重启mysql</h3><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker restart mysql</span><br></pre></table></figure><h2 id=1-3、测试><a class=headerlink href=#1-3、测试 title=1.3、测试></a>1.3、测试</h2><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>show master status;</span><br></pre></table></figure><h1 id=2、搭建Canal服务><a class=headerlink href=#2、搭建Canal服务 title=2、搭建Canal服务></a>2、搭建Canal服务</h1><h2 id=2-1、创建网络><a class=headerlink href=#2-1、创建网络 title=2.1、创建网络></a>2.1、创建网络</h2><p>创建一个网络，将MySQL、Canal、MQ放到一个网络中。<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker network create canal-mysql</span><br></pre></table></figure><p>将 MySQL 加入到这个网络：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>docker network connect canal-mysql mysql</span><br></pre></table></figure><h2 id=2-2、运行Canal实例><a class=headerlink href=#2-2、运行Canal实例 title=2.2、运行Canal实例></a>2.2、运行Canal实例</h2><figure class="highlight sh"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line>docker run -p 11111:11111 --name canal \</span><br><span class=line>-e canal.destinations=heima \</span><br><span class=line>-e canal.instance.master.address=mysql:3306  \</span><br><span class=line>-e canal.instance.dbUsername=canal  \</span><br><span class=line>-e canal.instance.dbPassword=canal  \</span><br><span class=line>-e canal.instance.connectionCharset=UTF-8 \</span><br><span class=line>-e canal.instance.tsdb.enable=<span class=literal>true</span> \</span><br><span class=line>-e canal.instance.gtidon=<span class=literal>false</span>  \</span><br><span class=line>-e canal.instance.filter.regex=heima\\..* \</span><br><span class=line>--network canal-mysql \</span><br><span class=line>-d canal/canal-server:v1.1.5</span><br></pre></table></figure><p>参数解析：<ul><li><code>-p 11111:11111</code>：这是canal的默认监听端口<li><code>-e canal.instance.master.address=mysql:3306</code>：数据库地址和端口，如果不知道mysql容器地址，可以通过<code>docker inspect 容器id</code>来查看<li><code>-e canal.instance.dbUsername=canal</code>：数据库用户名<li><code>-e canal.instance.dbPassword=canal</code> ：数据库密码<li><code>-e canal.instance.filter.regex=</code>：要监听的表名称</ul><p>监听 表名 支持的语法：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=comment># mysql 数据解析关注的表，Perl正则表达式，多个正则之间以逗号(,)分隔，转义符需要双斜杠(\\) 。常见例子：</span></span><br><span class=line><span class=attr>1.</span>  <span class=string>所有表：.*   or  .*\\..*</span></span><br><span class=line><span class=attr>2.</span>  <span class=string>canal schema下所有表： canal\\..*</span></span><br><span class=line><span class=attr>3.</span>  <span class=string>canal下的以canal打头的表：canal\\.canal.*</span></span><br><span class=line><span class=attr>4.</span>  <span class=string>canal schema下的一张表：canal.test1</span></span><br><span class=line><span class=attr>5.</span>  <span class=string>多个规则组合使用然后以逗号隔开：canal\\..*,mysql.test1,mysql.test2 </span></span><br></pre></table></figure><h1 id=3、监听MySQL><a class=headerlink href=#3、监听MySQL title=3、监听MySQL></a>3、监听MySQL</h1><h2 id=3-1、加入依赖><a class=headerlink href=#3-1、加入依赖 title=3.1、加入依赖></a>3.1、加入依赖</h2><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>top.javatool<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>canal-spring-boot-starter<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>1.2.1-RELEASE<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><h2 id=3-2、编写配置><a class=headerlink href=#3-2、编写配置 title=3.2、编写配置></a>3.2、编写配置</h2><figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>canal:</span></span><br><span class=line>  <span class=attr>destination:</span> <span class=string>heima</span> <span class=comment># canal的集群名字，要与安装canal时设置的名称一致</span></span><br><span class=line>  <span class=attr>server:</span> <span class=number>192.168</span><span class=number>.150</span><span class=number>.101</span><span class=string>:11111</span> <span class=comment># canal服务地址</span></span><br></pre></table></figure><h2 id=3-3、修改实体类><a class=headerlink href=#3-3、修改实体类 title=3.3、修改实体类></a>3.3、修改实体类</h2><p>通过@Id、@Column等注解，来完成Item与数据库表字段的映射：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=meta>@Data</span></span><br><span class=line><span class=meta>@TableName("tb_item")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Item</span> {</span><br><span class=line>    <span class=meta>@TableId(type = IdType.AUTO)</span></span><br><span class=line>    <span class=meta>@Id</span></span><br><span class=line>    <span class=keyword>private</span> Long id;<span class=comment>//商品id</span></span><br><span class=line>    <span class=meta>@Column(name = "name")</span></span><br><span class=line>    <span class=keyword>private</span> String name;<span class=comment>//商品名称</span></span><br><span class=line>    <span class=keyword>private</span> String title;<span class=comment>//商品标题</span></span><br><span class=line>    <span class=keyword>private</span> Long price;<span class=comment>//价格（分）</span></span><br><span class=line>    <span class=keyword>private</span> String image;<span class=comment>//商品图片</span></span><br><span class=line>    <span class=keyword>private</span> String category;<span class=comment>//分类名称</span></span><br><span class=line>    <span class=keyword>private</span> String brand;<span class=comment>//品牌名称</span></span><br><span class=line>    <span class=keyword>private</span> String spec;<span class=comment>//规格</span></span><br><span class=line>    <span class=keyword>private</span> Integer status;<span class=comment>//商品状态 1-正常，2-下架</span></span><br><span class=line>    <span class=keyword>private</span> Date createTime;<span class=comment>//创建时间</span></span><br><span class=line>    <span class=keyword>private</span> Date updateTime;<span class=comment>//更新时间</span></span><br><span class=line>    <span class=meta>@TableField(exist = false)</span></span><br><span class=line>    <span class=meta>@Transient</span></span><br><span class=line>    <span class=keyword>private</span> Integer stock;</span><br><span class=line>    <span class=meta>@TableField(exist = false)</span></span><br><span class=line>    <span class=meta>@Transient</span></span><br><span class=line>    <span class=keyword>private</span> Integer sold;</span><br><span class=line>}</span><br></pre></table></figure><h2 id=3-4、编写监听器><a class=headerlink href=#3-4、编写监听器 title=3.4、编写监听器></a>3.4、编写监听器</h2><p>通过实现<code>EntryHandler&LTT></code>接口编写监听器，监听Canal消息。<p>注意两点：<ul><li>实现类通过注解<code>@CanalTable("tbl_item")</code>设置需要监听的表信息。<li>EntryHandler的泛型是与表对应的实体类。</ul><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br></pre><td class=code><pre><span class=line><span class=meta>@CanalTable("tbl_item")</span></span><br><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ItemHandler</span> <span class=keyword>implements</span> <span class="title class_">EntryHandler</span>&LTItem> {</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> RedisHandler redisHandler;</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> Cache&LTLong, Item> itemCache;</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">insert</span><span class=params>(Item item)</span> {</span><br><span class=line>        <span class=comment>// 写数据到JVM进程缓存</span></span><br><span class=line>        itemCache.put(item.getId(), item);</span><br><span class=line>        <span class=comment>// 写数据到redis</span></span><br><span class=line>        redisHandler.saveItem(item);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">update</span><span class=params>(Item before, Item after)</span> {</span><br><span class=line>        <span class=comment>// 写数据到JVM进程缓存</span></span><br><span class=line>        itemCache.put(after.getId(), after);</span><br><span class=line>        <span class=comment>// 写数据到redis</span></span><br><span class=line>        redisHandler.saveItem(after);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">delete</span><span class=params>(Item item)</span> {</span><br><span class=line>        <span class=comment>// 删除数据到JVM进程缓存</span></span><br><span class=line>        itemCache.invalidate(item.getId());</span><br><span class=line>        <span class=comment>// 删除数据到redis</span></span><br><span class=line>        redisHandler.deleteItemById(item.getId());</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>对Redis的操作都封装到了RedisHandler对象中：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br></pre><td class=code><pre><span class=line><span class=meta>@Component</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RedisHandler</span> <span class=keyword>implements</span> <span class="title class_">InitializingBean</span> {</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> StringRedisTemplate redisTemplate;</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> IItemService itemService;</span><br><span class=line>    <span class=meta>@Autowired</span></span><br><span class=line>    <span class=keyword>private</span> IItemStockService stockService;</span><br><span class=line></span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=keyword>final</span> <span class=type>ObjectMapper</span> <span class=variable>MAPPER</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class=line></span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">afterPropertiesSet</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=comment>// 初始化缓存</span></span><br><span class=line>        <span class=comment>// 1.查询商品信息</span></span><br><span class=line>        List&LTItem> itemList = itemService.list();</span><br><span class=line>        <span class=comment>// 2.放入缓存</span></span><br><span class=line>        <span class=keyword>for</span> (Item item : itemList) {</span><br><span class=line>            <span class=comment>// 2.1.item序列化为JSON</span></span><br><span class=line>            <span class=type>String</span> <span class=variable>json</span> <span class=operator>=</span> MAPPER.writeValueAsString(item);</span><br><span class=line>            <span class=comment>// 2.2.存入redis</span></span><br><span class=line>            redisTemplate.opsForValue().set(<span class=string>"item:id:"</span> + item.getId(), json);</span><br><span class=line>        }</span><br><span class=line></span><br><span class=line>        <span class=comment>// 3.查询商品库存信息</span></span><br><span class=line>        List&LTItemStock> stockList = stockService.list();</span><br><span class=line>        <span class=comment>// 4.放入缓存</span></span><br><span class=line>        <span class=keyword>for</span> (ItemStock stock : stockList) {</span><br><span class=line>            <span class=comment>// 2.1.item序列化为JSON</span></span><br><span class=line>            <span class=type>String</span> <span class=variable>json</span> <span class=operator>=</span> MAPPER.writeValueAsString(stock);</span><br><span class=line>            <span class=comment>// 2.2.存入redis</span></span><br><span class=line>            redisTemplate.opsForValue().set(<span class=string>"item:stock:id:"</span> + stock.getId(), json);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">saveItem</span><span class=params>(Item item)</span> {</span><br><span class=line>        <span class=keyword>try</span> {</span><br><span class=line>            <span class=type>String</span> <span class=variable>json</span> <span class=operator>=</span> MAPPER.writeValueAsString(item);</span><br><span class=line>            redisTemplate.opsForValue().set(<span class=string>"item:id:"</span> + item.getId(), json);</span><br><span class=line>        } <span class=keyword>catch</span> (JsonProcessingException e) {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">deleteItemById</span><span class=params>(Long id)</span> {</span><br><span class=line>        redisTemplate.delete(<span class=string>"item:id:"</span> + id);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/ASM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/ASM%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/ itemprop=url>Java系列-ASM</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-06 10:57:52" datetime=2023-08-06T10:57:52+08:00 itemprop=dateModified>2023-08-06</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/ASM/ itemprop=url rel=index><span itemprop=name>ASM</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=0、前言><a class=headerlink href=#0、前言 title=0、前言></a>0、前言</h1><p>本文档基于ASM4.0来分析。<h1 id=1、简介><a class=headerlink href=#1、简介 title=1、简介></a>1、简介</h1><h2 id=1-1、简析><a class=headerlink href=#1-1、简析 title=1.1、简析></a>1.1、简析</h2><p>ASM不是生成和转换已编译Java的唯一工具类，但它是最新且有效的类之一。其主要优点如下：<ol><li>它具有易使用、简单、精心设计的模块化API。<li>并且具有关联的Eclipse插件。<li>它支持最新的Java版本Java 7<li>它体积小，速度快且非常稳定。<li>庞大的社区支持。<li>完全开源。</ol><h2 id=1-2、总述><a class=headerlink href=#1-2、总述 title=1.2、总述></a>1.2、总述</h2><h3 id=1-2-1、作用域><a class=headerlink href=#1-2-1、作用域 title=1.2.1、作用域></a>1.2.1、作用域</h3><p>ASM库的目标是生成、转换和分析以字节数组表示的已编译Java类（因为它们存储在磁盘上并已加载到Java虚拟机中）。为此，ASM提供了使用比字节更高的概念来读取，写入和转换此类字节数组的工具，例如数字常量，字符串，Java标识符，Java类型，Java类结构元素等。请注意，ASM的范围图书馆严格限于阅读，写作，转换和分析类。特别是类加载过程超出了范围。<h3 id=1-2-2、模块><a class=headerlink href=#1-2-2、模块 title=1.2.2、模块></a>1.2.2、模块</h3><p>ASM库提供了两个用于生成和转换已编译类的API：核心API提供基于事件的类表示，而树API提供基于对象的表示。<p>这两个API可以与XML文档的简单API（SAX）和XML文档的文档对象模型（DOM）API进行比较：基于事件的API与SAX类似，而基于对象的API与DOM类似。基于对象的API建立在基于事件的API之上，就像可以在SAX之上提供DOM一样。<p>优缺点：<ul><li>与基于对象的API相比，基于事件的API更快，并且所需的内存更少，因为不需要创建并在内存中存储代表该类的对象树（SAX和DOM之间也存在相同的区别）。<li>但是，使用基于事件的API来实现类转换可能会更加困难，因为在任何给定时间只有该类的一个元素（与当前事件相对应的元素）才可用，而整个类可以在基于对象的内存中使用API。</ul><h3 id=1-2-3、结构><a class=headerlink href=#1-2-3、结构 title=1.2.3、结构></a>1.2.3、结构</h3><p>ASM应用程序具有强大的体系结构方面。实际上，基于事件的API是围绕事件生成器（类解析器），事件使用者（类编写器）和各种预定义的事件过滤器组织的，可以向其中添加用户定义的生产者，使用者和过滤器。因此，使用此API分为两个步骤：<ol><li>将事件产生器，过滤器和使用者组件组装成可能复杂的架构。<li>然后启动事件生产者以运行生成或转换过程。</ol><h2 id=1-3、组织><a class=headerlink href=#1-3、组织 title=1.3、组织></a>1.3、组织</h2><p>ASM库组织在几个包中，这些包分布在几个jar文件中：<ol><li>asm.jar<li>asm-util.jar<li>asm-commons.jar<li>asm-tree.jar<li>asm-analysis.jar</ol><h1 id=2、类><a class=headerlink href=#2、类 title=2、类></a>2、类</h1><h2 id=2-1、结构><a class=headerlink href=#2-1、结构 title=2.1、结构></a>2.1、结构</h2><h3 id=2-1-3、类型描述符><a class=headerlink href=#2-1-3、类型描述符 title=2.1.3、类型描述符></a>2.1.3、类型描述符</h3><p>内部名称仅用于约束为类或接口类型的类型。在所有其他情况下，例如字段类型，Java类型都在带有类型描述符的已编译类中表示：<p><img alt=image-20200905140752294 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200905140752294.png?token=AIGEF3IRGWSRIZT72N35LHDEZZZXO><h3 id=2-1-4、方法描述符><a class=headerlink href=#2-1-4、方法描述符 title=2.1.4、方法描述符></a>2.1.4、方法描述符</h3><p>方法描述符是类型描述符的列表，这些类型描述符在单个字符串中描述方法的参数类型和返回类型。方法描述符以左括号开头，然后是每个形式参数的类型描述符，然后是右括号，然后是返回类型的类型描述符，如果该方法返回void，则返回V（方法描述符不包含方法名称或参数名称）。<p><img alt=image-20200905141030231 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200905141030231.png?token=AIGEF3NN3ZCLCO7OIRB5P5TEZZZYO><h2 id=2-2、接口与组件><a class=headerlink href=#2-2、接口与组件 title=2.2、接口与组件></a>2.2、接口与组件</h2><h3 id=2-2-1、简介><a class=headerlink href=#2-2-1、简介 title=2.2.1、简介></a>2.2.1、简介</h3><p>用于生成和转换已编译类的 ASM API 基于 ClassVisitor 抽象类。此类中的每个方法都对应于同名的类文件结构部分。通过单个方法调用可以访问简单部分，该方法的参数描述其内容，并返回void。使用初始方法调用（其返回辅助访问者类）访问其内容可以具有任意长度和复杂度的节。 visitAnnotation，visitField和visitMethod方法就是这种情况，它们分别返回AnnotationVisitor，FieldVisitor和MethodVisitor。<p>这些辅助类递归使用相同的原理。例如，FieldVisitor抽象类中的每个方法（请参见图2.5）对应于具有相同名称的类文件子结构，并且与ClassVisitor中一样，返回一个辅助AnnotationVisitor。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ClassVisitor</span><span class=params>(<span class=type>int</span> api)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ClassVisitor</span><span class=params>(<span class=type>int</span> api, ClassVisitor cv)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(<span class=type>int</span> version, <span class=type>int</span> access, String name,String signature, String superName, String[] interfaces)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitSource</span><span class=params>(String source, String debug)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitOuterClass</span><span class=params>(String owner, String name, String desc)</span>;</span><br><span class=line>    AnnotationVisitor <span class="title function_">visitAnnotation</span><span class=params>(String desc, <span class=type>boolean</span> visible)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitAttribute</span><span class=params>(Attribute attr)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInnerClass</span><span class=params>(String name, String outerName,String innerName, <span class=type>int</span> access)</span>;</span><br><span class=line>    <span class=keyword>public</span> FieldVisitor <span class="title function_">visitField</span><span class=params>(<span class=type>int</span> access, String name, String desc,String signature, Object value)</span>;</span><br><span class=line>    <span class=keyword>public</span> MethodVisitor <span class="title function_">visitMethod</span><span class=params>(<span class=type>int</span> access, String name, String desc,String signature, String[] exceptions)</span>;</span><br><span class=line>    <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">FieldVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">FieldVisitor</span><span class=params>(<span class=type>int</span> api)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">FieldVisitor</span><span class=params>(<span class=type>int</span> api, FieldVisitor fv)</span>;</span><br><span class=line>    <span class=keyword>public</span> AnnotationVisitor <span class="title function_">visitAnnotation</span><span class=params>(String desc, <span class=type>boolean</span> visible)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitAttribute</span><span class=params>(Attribute attr)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><p>ASM提供了三个基于ClassVisitor API的核心组件，用于生成和转换类：<ol><li>ClassReader类解析以字节数组形式给出的已编译类，并在作为参数传递给其accept方法的ClassVisitor实例上调用相应的visitXxx方法。可以将其视为事件产生器。<li>ClassWriter类是ClassVisitor抽象类的子类，该类直接以二进制形式构建编译的类。它产生包含已编译类的字节数组作为输出，可以使用toByteArray方法进行检索。可以将其视为事件消费者。<li>ClassVisitor类将它收到的所有方法调用委托给另一个ClassVisitor实例。可以将其视为事件过滤器。</ol><h3 id=2-2-2、解析类><a class=headerlink href=#2-2-2、解析类 title=2.2.2、解析类></a>2.2.2、解析类</h3><p>解析现有类的唯一必需组件是ClassReader组件。让我们以一个例子来说明这一点。假设我们希望以类似于javap工具的方式打印类的内容。第一步是编写ClassVisitor类的子类，该子类打印有关其访问的类的信息。这是一个可能的，过于简化的实现：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ClassPrinter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ClassPrinter</span><span class=params>()</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(<span class=type>int</span> version, <span class=type>int</span> access, String name,String signature, String superName, String[] interfaces)</span> {</span><br><span class=line>    	System.out.println(name + <span class=string>" extends "</span> + superName + <span class=string>" {"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitSource</span><span class=params>(String source, String debug)</span> {}</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitOuterClass</span><span class=params>(String owner, String name, String desc)</span> {}</span><br><span class=line>    <span class=keyword>public</span> AnnotationVisitor <span class="title function_">visitAnnotation</span><span class=params>(String desc,<span class=type>boolean</span> visible)</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitAttribute</span><span class=params>(Attribute attr)</span> {}</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInnerClass</span><span class=params>(String name, String outerName, String innerName, <span class=type>int</span> access)</span> {}</span><br><span class=line>    <span class=keyword>public</span> FieldVisitor <span class="title function_">visitField</span><span class=params>(<span class=type>int</span> access, String name, String desc,String signature, Object value)</span> {</span><br><span class=line>    	System.out.println(<span class=string>" "</span> + desc + <span class=string>" "</span> + name);</span><br><span class=line>    	<span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> MethodVisitor <span class="title function_">visitMethod</span><span class=params>(<span class=type>int</span> access, String name,String desc, String signature, String[] exceptions)</span> {</span><br><span class=line>    	System.out.println(<span class=string>" "</span> + name + desc);</span><br><span class=line>    	<span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span> {</span><br><span class=line>    	System.out.println(<span class=string>"}"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><p>第二步是将该ClassPrinter与ClassReader组件结合起来，以便ClassReader产生的事件由我们的ClassPrinter消耗：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>ClassPrinter</span> <span class=variable>cp</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassPrinter</span>();</span><br><span class=line><span class=type>ClassReader</span> <span class=variable>cr</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassReader</span>(<span class=string>"java.lang.Runnable"</span>);</span><br><span class=line>cr.accept(cp, <span class=number>0</span>);</span><br></pre></table></figure><p>请注意，有几种方法可以构造ClassReader实例。可以通过名称（如上所述）或通过值（字节数组或InputStream）指定必须读取的类。可以使用ClassLoader的getResourceAsStream方法通过以下方式获取用于读取类内容的输入流：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>cl.getResourceAsStream(classname.replace(’.’, ’/’) + <span class=string>".class"</span>);</span><br></pre></table></figure><h3 id=2-2-3、生成类><a class=headerlink href=#2-2-3、生成类 title=2.2.3、生成类></a>2.2.3、生成类</h3><p>生成类的唯一必需组件是ClassWriter组件。让我们以一个例子来说明这一点。考虑以下接口：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Comparable</span> <span class=keyword>extends</span> <span class="title class_">Mesurable</span> {</span><br><span class=line>    <span class=type>int</span> <span class=variable>LESS</span> <span class=operator>=</span> -<span class=number>1</span>;</span><br><span class=line>    <span class=type>int</span> <span class=variable>EQUAL</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=type>int</span> <span class=variable>GREATER</span> <span class=operator>=</span> <span class=number>1</span>;</span><br><span class=line>    <span class=type>int</span> <span class="title function_">compareTo</span><span class=params>(Object o)</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>它可以通过对ClassVisitor的六个方法调用来生成：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line>cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, <span class=string>"pkg/Comparable"</span>, <span class=literal>null</span>, <span class=string>"java/lang/Object"</span>,<span class=keyword>new</span> <span class="title class_">String</span>[] { <span class=string>"pkg/Mesurable"</span> });</span><br><span class=line>cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class=string>"LESS"</span>, <span class=string>"I"</span>, <span class=literal>null</span>, <span class=keyword>new</span> <span class="title class_">Integer</span>(-<span class=number>1</span>)).visitEnd();</span><br><span class=line>cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class=string>"EQUAL"</span>, <span class=string>"I"</span>, <span class=literal>null</span>, <span class=keyword>new</span> <span class="title class_">Integer</span>(<span class=number>0</span>)).visitEnd();</span><br><span class=line>cw.visitField(ACC_PUBLIC + ACC_FINAL + ACC_STATIC, <span class=string>"GREATER"</span>, <span class=string>"I"</span>, <span class=literal>null</span>, <span class=keyword>new</span> <span class="title class_">Integer</span>(<span class=number>1</span>)).visitEnd();</span><br><span class=line>cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, <span class=string>"compareTo"</span>, <span class=string>"(Ljava/lang/Object;)I"</span>, <span class=literal>null</span>, <span class=literal>null</span>).visitEnd();</span><br><span class=line>cw.visitEnd();</span><br><span class=line><span class=type>byte</span>[] b = cw.toByteArray();</span><br></pre></table></figure><h4 id=2-2-3-1、使用生成的类：><a class=headerlink href=#2-2-3-1、使用生成的类： title=2.2.3.1、使用生成的类：></a>2.2.3.1、使用生成的类：</h4><p>先前的字节数组可以存储在Comparable.class文件中，以备将来使用。另外，也可以使用ClassLoader动态加载它。一种方法是定义ClassLoader子类，其defineClass方法是公共的：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">MyClassLoader</span> <span class=keyword>extends</span> <span class="title class_">ClassLoader</span> {</span><br><span class=line>    <span class=keyword>public</span> Class <span class="title function_">defineClass</span><span class=params>(String name, <span class=type>byte</span>[] b)</span> {</span><br><span class=line>    	<span class=keyword>return</span> defineClass(name, b, <span class=number>0</span>, b.length);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br></pre></table></figure><p>然后，可以使用以下命令直接加载生成的类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=type>Class</span> <span class=variable>c</span> <span class=operator>=</span> myClassLoader.defineClass(<span class=string>"pkg.Comparable"</span>, b);</span><br></pre></table></figure><p>加载生成的类的另一种方法（可能更干净）是定义ClassLoader子类，该类的findClass方法被重写，以便动态生成请求的类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">StubClassLoader</span> <span class=keyword>extends</span> <span class="title class_">ClassLoader</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>protected</span> Class <span class="title function_">findClass</span><span class=params>(String name)</span> <span class=keyword>throws</span> ClassNotFoundException {</span><br><span class=line>        <span class=keyword>if</span> (name.endsWith(<span class=string>"_Stub"</span>)) {</span><br><span class=line>            <span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line>            <span class=comment>//...</span></span><br><span class=line>            <span class=type>byte</span>[] b = cw.toByteArray();</span><br><span class=line>            <span class=keyword>return</span> defineClass(name, b, <span class=number>0</span>, b.length);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> <span class=built_in>super</span>.findClass(name);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>实际上，使用生成的类的方式取决于上下文，并且超出了ASM API的范围。如果正在编写编译器，则类生成过程将由表示要编译的程序的抽象语法树驱动，并且生成的类将存储在磁盘上。如果要编写动态代理类生成器或Aspect Weaver，则将以一种或另一种方式使用ClassLoader。<h3 id=2-2-4、转换类><a class=headerlink href=#2-2-4、转换类 title=2.2.4、转换类></a>2.2.4、转换类</h3><p>到目前为止，仅单独使用了ClassReader和ClassWriter组件。这些事件是“手动”产生的，并由ClassWriter直接消耗，或者对称地，它们是由ClassReader产生并“手动”消耗的，即由自定义的ClassVisitor实现。当这些组件一起使用时，事情开始变得非常有趣。第一步是将ClassReader产生的事件定向到ClassWriter。结果是由类编写器重构了由类读取器解析的类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=type>byte</span>[] b1 = ...;</span><br><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line><span class=type>ClassReader</span> <span class=variable>cr</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassReader</span>(b1);</span><br><span class=line>cr.accept(cw, <span class=number>0</span>);</span><br><span class=line><span class=type>byte</span>[] b2 = cw.toByteArray();  <span class=comment>// b2 represents the same class as b1</span></span><br></pre></table></figure><p>下一步是在类读取器和类写入器之间引入ClassVisitor：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>byte</span>[] b1 = ...;</span><br><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line><span class=comment>// cv forwards all events to cw</span></span><br><span class=line><span class=type>ClassVisitor</span> <span class=variable>cv</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassVisitor</span>(ASM4, cw) { };</span><br><span class=line><span class=type>ClassReader</span> <span class=variable>cr</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassReader</span>(b1);</span><br><span class=line>cr.accept(cv, <span class=number>0</span>);</span><br><span class=line><span class=type>byte</span>[] b2 = cw.toByteArray(); <span class=comment>// b2 represents the same class as b1</span></span><br></pre></table></figure><p>但是，结果不会改变，因为ClassVisitor事件过滤器不过滤任何内容。但是，现在可以通过重写某些方法来过滤某些事件，以便能够转换类。例如，考虑以下ClassVisitor子类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">ChangeVersionAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">ChangeVersionAdapter</span><span class=params>(ClassVisitor cv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(<span class=type>int</span> version, <span class=type>int</span> access, String name, String signature, String superName, String[] interfaces)</span> {</span><br><span class=line>    	cv.visit(V1_5, access, name, signature, superName, interfaces);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>此类仅覆盖ClassVisitor类的一个方法。结果，除了对visit方法的调用之外，所有调用均以不变的方式转发给传递给构造函数的类visitor cv，后者以修改后的类版本号转发。<h4 id=2-2-4-1、优化><a class=headerlink href=#2-2-4-1、优化 title=2.2.4.1、优化></a>2.2.4.1、优化</h4><p>上一个转换仅更改原始类中的四个字节。但是，使用上面的代码，b1被完全解析，并且相应的事件用于从头开始构造b2，这不是很有效。复制不直接转换为b2的b1部分，而无需解析这些部分并且不生成相应的事件，将更加有效。 ASM自动为方法执行此优化：<ol><li>如果ClassReader组件检测到作为参数传递给其accept方法的ClassVisitor返回的MethodVisitor来自ClassWriter，则这意味着该方法的内容将不会被转换，并且实际上甚至不会被应用程序看到。<li>在这种情况下，ClassReader组件不会解析此方法的内容，不会生成相应的事件，而只是复制ClassWriter中此方法的字节数组表示形式</ol><p>如果ClassReader和ClassWriter组件具有相互引用，则可以通过以下方式进行此优化：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=type>byte</span>[] b1 = ...</span><br><span class=line><span class=type>ClassReader</span> <span class=variable>cr</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassReader</span>(b1);</span><br><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(cr, <span class=number>0</span>);</span><br><span class=line><span class=type>ChangeVersionAdapter</span> <span class=variable>ca</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ChangeVersionAdapter</span>(cw);</span><br><span class=line>cr.accept(ca, <span class=number>0</span>);</span><br><span class=line><span class=type>byte</span>[] b2 = cw.toByteArray();</span><br></pre></table></figure><h4 id=2-2-4-2、使用转换类><a class=headerlink href=#2-2-4-2、使用转换类 title=2.2.4.2、使用转换类></a>2.2.4.2、使用转换类</h4><p>可以将转换后的类b2存储在磁盘上或用ClassLoader加载。但是在ClassLoader内部完成的类转换只能转换由此类加载器加载的类。如果要转换所有类，则必须将转换放入ClassFileTransformer内，如java.lang.instrument包中所定义（有关更多详细信息，请参见此包的文档）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">premain</span><span class=params>(String agentArgs, Instrumentation inst)</span> {</span><br><span class=line>    inst.addTransformer(<span class=keyword>new</span> <span class="title class_">ClassFileTransformer</span>() {</span><br><span class=line>    	<span class=keyword>public</span> <span class=type>byte</span>[] transform(ClassLoader l, String name, Class c, ProtectionDomain d, <span class=type>byte</span>[] b)<span class=keyword>throws</span> IllegalClassFormatException {</span><br><span class=line>            <span class=type>ClassReader</span> <span class=variable>cr</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassReader</span>(b);</span><br><span class=line>            <span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(cr, <span class=number>0</span>);</span><br><span class=line>            <span class=type>ClassVisitor</span> <span class=variable>cv</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ChangeVersionAdapter</span>(cw);</span><br><span class=line>            cr.accept(cv, <span class=number>0</span>);</span><br><span class=line>            <span class=keyword>return</span> cw.toByteArray();</span><br><span class=line>    	}</span><br><span class=line>    });</span><br><span class=line>}</span><br></pre></table></figure><h3 id=2-2-5、删除类成员><a class=headerlink href=#2-2-5、删除类成员 title=2.2.5、删除类成员></a>2.2.5、删除类成员</h3><p>例如，以下类适配器删除有关外部类和内部类的信息，以及从中编译该类的源文件的名称（生成的类保持完整的功能，因为这些元素仅用于调试目的）。这是通过不以适当的访问方法转发任何内容来完成的：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoveDebugAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RemoveDebugAdapter</span><span class=params>(ClassVisitor cv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitSource</span><span class=params>(String source, String debug)</span> {}</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitOuterClass</span><span class=params>(String owner, String name, String desc)</span> {}</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInnerClass</span><span class=params>(String name, String outerName, String innerName, <span class=type>int</span> access)</span> {}</span><br><span class=line>}</span><br></pre></table></figure><p>该策略不适用于字段和方法，因为visitField和visitMethod方法必须返回结果。为了删除字段或方法，您必须不要转发方法调用，并且必须将null返回给调用方。例如，以下类适配器删除由其名称和其描述符指定的单个方法（该名称不足以标识一个方法，因为一个类可以包含多个同名但参数不同的方法）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoveMethodAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>private</span> String mName;</span><br><span class=line>    <span class=keyword>private</span> String mDesc;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RemoveMethodAdapter</span><span class=params>(ClassVisitor cv, String mName, String mDesc)</span> {</span><br><span class=line>        <span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>        <span class=built_in>this</span>.mName = mName;</span><br><span class=line>        <span class=built_in>this</span>.mDesc = mDesc;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> MethodVisitor <span class="title function_">visitMethod</span><span class=params>(<span class=type>int</span> access, String name, String desc, String signature, String[] exceptions)</span> {</span><br><span class=line>        <span class=keyword>if</span> (name.equals(mName) && desc.equals(mDesc)) {</span><br><span class=line>            <span class=comment>// do not delegate to next visitor -> this removes the method</span></span><br><span class=line>            <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=2-2-6、添加类成员><a class=headerlink href=#2-2-6、添加类成员 title=2.2.6、添加类成员></a>2.2.6、添加类成员</h3><p>这里是一个类适配器，它将一个字段添加到类中，除非该字段已经存在：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AddFieldAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> fAcc;</span><br><span class=line>    <span class=keyword>private</span> String fName;</span><br><span class=line>    <span class=keyword>private</span> String fDesc;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>boolean</span> isFieldPresent;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AddFieldAdapter</span><span class=params>(ClassVisitor cv, <span class=type>int</span> fAcc, String fName, String fDesc)</span> {</span><br><span class=line>        <span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>        <span class=built_in>this</span>.fAcc = fAcc;</span><br><span class=line>        <span class=built_in>this</span>.fName = fName;</span><br><span class=line>        <span class=built_in>this</span>.fDesc = fDesc;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> FieldVisitor <span class="title function_">visitField</span><span class=params>(<span class=type>int</span> access, String name, String desc, String signature, Object value)</span> {</span><br><span class=line>        <span class=keyword>if</span> (name.equals(fName)) {</span><br><span class=line>            isFieldPresent = <span class=literal>true</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cv.visitField(access, name, desc, signature, value);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>if</span> (!isFieldPresent) {</span><br><span class=line>            <span class=type>FieldVisitor</span> <span class=variable>fv</span> <span class=operator>=</span> cv.visitField(fAcc, fName, fDesc, <span class=literal>null</span>, <span class=literal>null</span>);</span><br><span class=line>            <span class=keyword>if</span> (fv != <span class=literal>null</span>) {</span><br><span class=line>            	fv.visitEnd();</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        cv.visitEnd();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=2-2-7、转型链><a class=headerlink href=#2-2-7、转型链 title=2.2.7、转型链></a>2.2.7、转型链</h3><p>到目前为止，我们已经看到了由ClassReader，类适配器和ClassWriter组成的简单转换链。当然，可以使用更复杂的链，将多个类适配器链在一起。链接多个适配器可让您组成多个独立的类转换，以执行复杂的转换。还要注意，转换链不一定是线性的。您可以编写一个ClassVisitor，将它同时收到的所有方法调用转发到多个ClassVisitor：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MultiClassAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>protected</span> ClassVisitor[] cvs;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MultiClassAdapter</span><span class=params>(ClassVisitor[] cvs)</span> {</span><br><span class=line>        <span class=built_in>super</span>(ASM4);</span><br><span class=line>        <span class=built_in>this</span>.cvs = cvs;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(<span class=type>int</span> version, <span class=type>int</span> access, String name, String signature, String superName, String[] interfaces)</span> {</span><br><span class=line>        <span class=keyword>for</span> (ClassVisitor cv : cvs) {</span><br><span class=line>        	cv.visit(version, access, name, signature, superName, interfaces);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    ...</span><br><span class=line>}</span><br></pre></table></figure><h2 id=2-3、工具><a class=headerlink href=#2-3、工具 title=2.3、工具></a>2.3、工具</h2><h3 id=2-3-1、Type><a class=headerlink href=#2-3-1、Type title=2.3.1、Type></a>2.3.1、Type</h3><p>如前几节所述，ASM API公开了Java类型，因为它们存储在编译的类中，即作为内部名称或类型描述符。可以将它们公开显示在源代码中，以使代码更具可读性。但这需要在ClassReader和ClassWriter中的两种表示形式之间进行系统的转换，这会降低性能。这就是ASM不会将内部名称和类型描述符透明转换为等效的源代码形式的原因。但是，它提供了Type类，以便在必要时手动执行此操作。<p>Type对象表示Java类型，可以从类型描述符或从Class对象构造。 Type类还包含表示原始类型的静态变量。例如，Type.INT_TYPE是表示int类型的Type对象。<h3 id=2-3-2、TraceClassVisitor><a class=headerlink href=#2-3-2、TraceClassVisitor title=2.3.2、TraceClassVisitor></a>2.3.2、TraceClassVisitor</h3><p>为了检查生成的或转换的类是否符合您的期望，ClassWriter返回的字节数组并没有真正的帮助，因为它是人类无法读取的。文本表示将更易于使用。这是TraceClassVisitor类提供的。顾名思义，该类扩展了ClassVisitor类，并构造了所访问类的文本表示形式。因此，可以使用TraceClassVisitor而不是使用ClassWriter来生成类，以便获得对实际生成内容的可读记录。或者，甚至更好的是，您可以同时使用两者。实际上，TraceClassVisitor除了其默认行为外，还可以将对其方法的所有调用委派给另一个访问者，例如ClassWriter：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line><span class=type>TraceClassVisitor</span> <span class=variable>cv</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TraceClassVisitor</span>(cw, printWriter);</span><br><span class=line>cv.visit(...);</span><br><span class=line>...</span><br><span class=line>cv.visitEnd();</span><br><span class=line><span class=type>byte</span> b[] = cw.toByteArray();</span><br><span class=line></span><br></pre></table></figure><p>这段代码创建了一个TraceClassVisitor，它将接收到的所有调用委托给cw，并将这些调用的文本表示输出到printWriter。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=comment>// class version 49.0 (49)</span></span><br><span class=line><span class=comment>// access flags 1537</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>interface</span> <span class="title class_">pkg</span>/Comparable <span class=keyword>implements</span> <span class="title class_">pkg</span>/Mesurable {</span><br><span class=line>    <span class=comment>// access flags 25</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>I</span> <span class=variable>LESS</span> <span class=operator>=</span> -<span class=number>1</span></span><br><span class=line>    <span class=comment>// access flags 25</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>I</span> <span class=variable>EQUAL</span> <span class=operator>=</span> <span class=number>0</span></span><br><span class=line>    <span class=comment>// access flags 25</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>I</span> <span class=variable>GREATER</span> <span class=operator>=</span> <span class=number>1</span></span><br><span class=line>    <span class=comment>// access flags 1025</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>abstract</span> <span class="title function_">compareTo</span><span class=params>(Ljava/lang/Object;)</span>I</span><br><span class=line>}</span><br></pre></table></figure><h3 id=2-3-3、CheckClassAdapter><a class=headerlink href=#2-3-3、CheckClassAdapter title=2.3.3、CheckClassAdapter></a>2.3.3、CheckClassAdapter</h3><p>为了检查一个类，打印该类的文本表示形式，最后创建一个字节数组表示形式，您应该使用类似以下内容的方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line><span class=type>TraceClassVisitor</span> <span class=variable>tcv</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TraceClassVisitor</span>(cw, printWriter);</span><br><span class=line><span class=type>CheckClassAdapter</span> <span class=variable>cv</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">CheckClassAdapter</span>(tcv);</span><br><span class=line>cv.visit(...);</span><br><span class=line>...</span><br><span class=line>cv.visitEnd();</span><br><span class=line><span class=type>byte</span> b[] = cw.toByteArray();</span><br></pre></table></figure><p>请注意，如果以不同的顺序链接这些类访问者，则它们执行的操作也将以不同的顺序进行。例如，使用以下代码，检查将在跟踪之后进行：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line><span class=type>CheckClassAdapter</span> <span class=variable>cca</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">CheckClassAdapter</span>(cw);</span><br><span class=line><span class=type>TraceClassVisitor</span> <span class=variable>cv</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">TraceClassVisitor</span>(cca, printWriter);</span><br></pre></table></figure><p>与TraceClassVisitor一样，您可以在生成或转换链中的任何点使用CheckClassAdapter，不仅可以在ClassWriter之前使用，还可以在链中此点检查类。<h3 id=2-3-4、ASMifier><a class=headerlink href=#2-3-4、ASMifier title=2.3.4、ASMifier></a>2.3.4、ASMifier</h3><p>可以从命令行使用ASMifier类。例如使用：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>java -classpath asm.jar:asm-util.jar \</span><br><span class=line>org.objectweb.asm.util.ASMifier \</span><br><span class=line>java.lang.Runnable</span><br></pre></table></figure><p>产生缩进后的代码为：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> asm.java.lang;</span><br><span class=line><span class=keyword>import</span> org.objectweb.asm.*;</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RunnableDump</span> <span class=keyword>implements</span> <span class="title class_">Opcodes</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=type>byte</span>[] dump() <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line>        FieldVisitor fv;</span><br><span class=line>        MethodVisitor mv;</span><br><span class=line>        AnnotationVisitor av0;</span><br><span class=line>        cw.visit(V1_5, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE, <span class=string>"java/lang/Runnable"</span>, <span class=literal>null</span>, <span class=string>"java/lang/Object"</span>, <span class=literal>null</span>);</span><br><span class=line>    {</span><br><span class=line>        mv = cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, <span class=string>"run"</span>, <span class=string>"()V"</span>, <span class=literal>null</span>, <span class=literal>null</span>);</span><br><span class=line>        mv.visitEnd();</span><br><span class=line>    }</span><br><span class=line>    cw.visitEnd();</span><br><span class=line>    <span class=keyword>return</span> cw.toByteArray();</span><br><span class=line>}</span><br></pre></table></figure><h1 id=3、方法><a class=headerlink href=#3、方法 title=3、方法></a>3、方法</h1><p>本章介绍如何使用核心ASM API生成和转换编译方法。它首先介绍了已编译的方法，然后提供了许多说明性示例，介绍了相应的ASM接口，组件以及生成和转换它们的工具。<h2 id=3-1、结构><a class=headerlink href=#3-1、结构 title=3.1、结构></a>3.1、结构</h2><p>在已编译的类中，方法的代码存储为一系列字节码指令。为了生成和转换类，了解这些指令并理解它们的工作原理至关重要。<h3 id=3-1-1、执行模式><a class=headerlink href=#3-1-1、执行模式 title=3.1.1、执行模式></a>3.1.1、执行模式</h3><p>在呈现字节码指令之前，必须呈现Java虚拟机执行模型。如您所知，Java代码是在线程内部执行的。每个线程都有其自己的执行堆栈，该堆栈由框架组成。每个框架代表一个方法调用：每次调用一个方法时，都会在当前线程的执行堆栈上推送一个新框架。当方法返回时，无论是正常情况还是由于异常而返回，都会从执行堆栈弹出该框架，并在调用方法中继续执行（其框架现在位于堆栈的顶部）。<p>局部变量和操作数堆栈部分的大小取决于方法的代码。它是在编译时计算的，并与字节码指令一起存储在已编译的类中。结果，与给定方法的调用相对应的所有框架都具有相同的大小，但是与不同方法相对应的框架的局部变量和操作数堆栈部分可以具有不同的大小。<h3 id=3-1-2、字节码指令><a class=headerlink href=#3-1-2、字节码指令 title=3.1.2、字节码指令></a>3.1.2、字节码指令</h3><p>字节码指令由标识该指令的操作码和固定数量的参数组成：<ul><li>操作码是一个无符号的字节值（因此为字节码名称），并由助记符标识。例如，操作码值0由助记符NOP设计，并且对应于不执行任何操作的指令。<li>参数是定义精确指令行为的静态值。它们在操作码之后给出。例如，操作码值为167的GOTO标签指令将自变量标签指定为要执行的下一条指令。指令参数不能与指令操作数混淆：参数值是静态已知的，并存储在编译后的代码中，而操作数值来自操作数堆栈，并且仅在运行时才知道。</ul><p>字节码指令可分为两类：一小组指令旨在将值从局部变量传输到操作数堆栈，反之亦然；其他指令仅作用于操作数堆栈：它们从堆栈中弹出一些值，根据这些值计算结果，然后将其推回堆栈。<p>所有其他字节码指令仅在操作数堆栈上工作。它们可以分为以下类别：<ul><li>Stack<li>Constants<li>Arithmetic and logic<li>Casts<li>Objects<li>Fields<li>Methods<li>Arrays<li>Jumps<li>Return</ul><h3 id=3-1-3、实例><a class=headerlink href=#3-1-3、实例 title=3.1.3、实例></a>3.1.3、实例</h3><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> pkg;</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Bean</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> f;</span><br><span class=line>    <span class=keyword>public</span> <span class=type>int</span> <span class="title function_">getF</span><span class=params>()</span> {</span><br><span class=line>    	<span class=keyword>return</span> <span class=built_in>this</span>.f;</span><br><span class=line>    }	</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">setF</span><span class=params>(<span class=type>int</span> f)</span> {</span><br><span class=line>    	<span class=built_in>this</span>.f = f;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>getter方法的字节码为：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>ALOAD <span class=number>0</span></span><br><span class=line>GETFIELD pkg/Bean f I</span><br><span class=line>IRETURN</span><br></pre></table></figure><p>第一条指令读取局部变量0，该局部变量在创建此方法调用的帧期间已初始化为0，并将此值压入操作数堆栈。第二条指令从堆栈中弹出此值，即this，并压入此对象的f字段，即this.f.最后一条指令从堆栈中弹出该值，并将其返回给调用方。此方法的执行帧的连续状态如下图所示：<p><img alt=image-20200906150115558 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200906150115558.png?token=AIGEF3PER5BJHXJG27CVUGDEZZZ2Q><p>setter方法的字节码为：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>ALOAD <span class=number>0</span></span><br><span class=line>ILOAD <span class=number>1</span></span><br><span class=line>PUTFIELD pkg/Bean f I</span><br><span class=line>RETURN</span><br></pre></table></figure><p>第一条指令将其压入操作数堆栈。第二条指令压入局部变量1，该局部变量在创建用于此方法调用的框架期间使用f参数值初始化。第三条指令弹出这两个值，并将int值存储在所引用对象的f字段中，即在this.f中。最后一条指令在源代码中是隐式的，而在编译后的代码中是强制性的，它会破坏当前执行框架并返回给调用者。此方法的执行帧的连续状态如图3.3所示。<p><img alt=image-20200906150426003 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200906150426003.png?token=AIGEF3MGQCPQK5TETM4YJWDEZZZ32><p>现在让我们考虑一个稍微复杂一些的setter方法<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">checkAndSetF</span><span class=params>(<span class=type>int</span> f)</span> {</span><br><span class=line>    <span class=keyword>if</span> (f >= <span class=number>0</span>) {</span><br><span class=line>    	<span class=built_in>this</span>.f = f;</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>    	<span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>对应字节码如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line>    ILOAD <span class=number>1</span></span><br><span class=line>    IFLT label</span><br><span class=line>    ALOAD <span class=number>0</span></span><br><span class=line>    ILOAD <span class=number>1</span></span><br><span class=line>    PUTFIELD pkg/Bean f I</span><br><span class=line>    GOTO end</span><br><span class=line>label:</span><br><span class=line>    NEW java/lang/IllegalArgumentException</span><br><span class=line>    DUP</span><br><span class=line>    INVOKESPECIAL java/lang/IllegalArgumentException &LTinit> ()V</span><br><span class=line>    ATHROW</span><br><span class=line>end:</span><br><span class=line>	RETURN</span><br></pre></table></figure><h3 id=3-1-4、异常处理><a class=headerlink href=#3-1-4、异常处理 title=3.1.4、异常处理></a>3.1.4、异常处理</h3><p>例如下面的源代码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">sleep</span><span class=params>(<span class=type>long</span> d)</span> {</span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>    	Thread.sleep(d);</span><br><span class=line>    } <span class=keyword>catch</span> (InterruptedException e) {</span><br><span class=line>    	e.printStackTrace();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>其可以编译成：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>TRYCATCHBLOCK <span class=keyword>try</span> <span class=keyword>catch</span> <span class=keyword>catch</span> java/lang/InterruptedException</span><br><span class=line><span class=keyword>try</span>:</span><br><span class=line>LLOAD <span class=number>0</span></span><br><span class=line>INVOKESTATIC java/lang/Thread <span class="title function_">sleep</span> <span class=params>(J)</span>V</span><br><span class=line>RETURN</span><br><span class=line><span class=keyword>catch</span>:</span><br><span class=line>INVOKEVIRTUAL java/lang/InterruptedException <span class="title function_">printStackTrace</span> <span class=params>()</span>V</span><br><span class=line>RETURN</span><br></pre></table></figure><h3 id=3-1-5、Frames><a class=headerlink href=#3-1-5、Frames title=3.1.5、Frames></a>3.1.5、Frames</h3><p>例如，如果考虑上一节的getF方法，则可以定义三个堆栈映射框架，这些框架映射框架给出了执行框架的状态，这些状态仅在ALOAD之前，在GETFIELD之前和在IRETURN之前。这三个堆栈映射框架对应于图3.2中所示的三种情况，可以描述如下，其中第一个方括号之间的类型对应于局部变量，其他类型对应于操作数堆栈：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line>State of the execution frame before 	Instruction</span><br><span class=line>[pkg/Bean] [] 						  ALOAD <span class=number>0</span></span><br><span class=line>[pkg/Bean] [pkg/Bean] 				   GETFIELD</span><br><span class=line>[pkg/Bean] [I] 						  IRETURN</span><br></pre></table></figure><p>我们可以对checkAndSetF方法做同样的事情：<p><img alt=image-20200906151656565 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/06/image-20200906151656565.png?token=AIGEF3NVDVSTEU3H4PJNRM3EZZZ5W><p>为了节省更多空间，通过仅存储与前一帧的差异来压缩每个帧，并且不存储初始帧，因为它可以很容易地从方法参数类型推导出来。在使用checkAndSetF方法的情况下，必须存储的两个帧相等并且等于初始帧，因此将它们存储为F_SAME助记符指定的单字节值。这些帧可以在它们关联的字节码指令之前被表示。这给出了checkAndSetF方法的最终字节码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line>ILOAD <span class=number>1</span></span><br><span class=line>IFLT label</span><br><span class=line>ALOAD <span class=number>0</span></span><br><span class=line>ILOAD <span class=number>1</span></span><br><span class=line>PUTFIELD pkg/Bean f I</span><br><span class=line>GOTO end</span><br><span class=line>label:</span><br><span class=line>F_SAME</span><br><span class=line>NEW java/lang/IllegalArgumentException</span><br><span class=line>DUP</span><br><span class=line>INVOKESPECIAL java/lang/IllegalArgumentException &LTinit> ()V</span><br><span class=line>ATHROW</span><br><span class=line>end:</span><br><span class=line>F_SAME</span><br><span class=line>RETURN</span><br></pre></table></figure><h2 id=3-2、接口与组件><a class=headerlink href=#3-2、接口与组件 title=3.2、接口与组件></a>3.2、接口与组件</h2><h3 id=3-2-2、生成方法><a class=headerlink href=#3-2-2、生成方法 title=3.2.2、生成方法></a>3.2.2、生成方法</h3><p>如果mv是MethodVisitor，则可以使用以下方法调用生成3.1.3节中定义的getF方法的字节码：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>mv.visitCode();</span><br><span class=line>mv.visitVarInsn(ALOAD, <span class=number>0</span>);</span><br><span class=line>mv.visitFieldInsn(GETFIELD, <span class=string>"pkg/Bean"</span>, <span class=string>"f"</span>, <span class=string>"I"</span>);</span><br><span class=line>mv.visitInsn(IRETURN);</span><br><span class=line>mv.visitMaxs(<span class=number>1</span>, <span class=number>1</span>);</span><br><span class=line>mv.visitEnd();</span><br></pre></table></figure><p>setF方法和构造函数的字节码可以类似的方式生成。一个更有趣的示例是checkAndSetF方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line>mv.visitCode();</span><br><span class=line>mv.visitVarInsn(ILOAD, <span class=number>1</span>);</span><br><span class=line><span class=type>Label</span> <span class=variable>label</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Label</span>();</span><br><span class=line>mv.visitJumpInsn(IFLT, label);</span><br><span class=line>mv.visitVarInsn(ALOAD, <span class=number>0</span>);</span><br><span class=line>mv.visitVarInsn(ILOAD, <span class=number>1</span>);</span><br><span class=line>mv.visitFieldInsn(PUTFIELD, <span class=string>"pkg/Bean"</span>, <span class=string>"f"</span>, <span class=string>"I"</span>);</span><br><span class=line><span class=type>Label</span> <span class=variable>end</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">Label</span>();</span><br><span class=line>mv.visitJumpInsn(GOTO, end);</span><br><span class=line>mv.visitLabel(label);</span><br><span class=line>mv.visitFrame(F_SAME, <span class=number>0</span>, <span class=literal>null</span>, <span class=number>0</span>, <span class=literal>null</span>);</span><br><span class=line>mv.visitTypeInsn(NEW, <span class=string>"java/lang/IllegalArgumentException"</span>);</span><br><span class=line>mv.visitInsn(DUP);</span><br><span class=line>mv.visitMethodInsn(INVOKESPECIAL,</span><br><span class=line><span class=string>"java/lang/IllegalArgumentException"</span>, <span class=string>"&LTinit>"</span>, <span class=string>"()V"</span>);</span><br><span class=line>mv.visitInsn(ATHROW);</span><br><span class=line>mv.visitLabel(end);</span><br><span class=line>mv.visitFrame(F_SAME, <span class=number>0</span>, <span class=literal>null</span>, <span class=number>0</span>, <span class=literal>null</span>);</span><br><span class=line>mv.visitInsn(RETURN);</span><br><span class=line>mv.visitMaxs(<span class=number>2</span>, <span class=number>2</span>);</span><br><span class=line>mv.visitEnd();</span><br></pre></table></figure><blockquote><p>注意：Label对象指定该标签的visitLabel调用之后的指令。例如，end指定RETURN指令，而不是紧随其后访问的帧，因为这不是指令。拥有多个指定同一条指令的标签是完全合法的，但是标签必须精确地指定一条指令。换句话说，可以使用不同的标签连续调用visitLabel，但是指令中使用的标签必须使用visitLabel进行一次精确的访问。最后一个约束是不能共享标签：每个方法必须具有自己的标签。</blockquote><h3 id=3-2-3、转换方法><a class=headerlink href=#3-2-3、转换方法 title=3.2.3、转换方法></a>3.2.3、转换方法</h3><p>为了了解如何使用方法适配器，让我们考虑一个非常简单的适配器，它删除了方法内部的NOP指令（可以删除它们，因为它们什么都不做，因此不会出现问题）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoveNopAdapter</span> <span class=keyword>extends</span> <span class="title class_">MethodVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RemoveNopAdapter</span><span class=params>(MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        <span class=keyword>if</span> (opcode != NOP) {</span><br><span class=line>        	mv.visitInsn(opcode);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>可以在类适配器内部使用此适配器，如下所示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoveNopClassAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RemoveNopClassAdapter</span><span class=params>(ClassVisitor cv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> MethodVisitor <span class="title function_">visitMethod</span><span class=params>(<span class=type>int</span> access, String name,</span></span><br><span class=line><span class=params>        String desc, String signature, String[] exceptions)</span> {</span><br><span class=line>        MethodVisitor mv;</span><br><span class=line>        mv = cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class=line>        <span class=keyword>if</span> (mv != <span class=literal>null</span>) {</span><br><span class=line>        	mv = <span class=keyword>new</span> <span class="title class_">RemoveNopAdapter</span>(mv);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> mv;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>但是请注意，这不是强制性的：完全有可能构建与类适配器链不同的方法适配器链。每个方法甚至可以具有不同的方法适配器链。例如，类适配器可以选择仅在方法中而不在构造函数中删除NOP。可以按照以下步骤进行：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>...</span><br><span class=line>mv = cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class=line><span class=keyword>if</span> (mv != <span class=literal>null</span> && !name.equals(<span class=string>"&LTinit>"</span>)) {</span><br><span class=line>mv = <span class=keyword>new</span> <span class="title class_">RemoveNopAdapter</span>(mv);</span><br><span class=line>}</span><br><span class=line>...</span><br></pre></table></figure><p>方法适配器链甚至可以具有与类适配器链不同的拓扑。例如，类适配器链可以是线性的，而方法适配器链具有分支：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> MethodVisitor <span class="title function_">visitMethod</span><span class=params>(<span class=type>int</span> access, String name, String desc, String signature, String[] exceptions)</span> {</span><br><span class=line>    MethodVisitor mv1, mv2;</span><br><span class=line>    mv1 = cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class=line>    mv2 = cv.visitMethod(access, <span class=string>"_"</span> + name, desc, signature, exceptions);</span><br><span class=line>    <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">MultiMethodAdapter</span>(mv1, mv2);</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-2-4、无状态转换><a class=headerlink href=#3-2-4、无状态转换 title=3.2.4、无状态转换></a>3.2.4、无状态转换</h3><p>假设我们要衡量一个程序的每个类所花费的时间。我们需要在每个类中添加一个静态计时器字段，并且需要将该类的每个方法的执行时间添加到此计时器字段中。换句话说，我们要转换一个诸如C的类：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">C</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">m</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>    	Thread.sleep(<span class=number>100</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>转为：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">C</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=type>long</span> timer;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">m</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        timer -= System.currentTimeMillis();</span><br><span class=line>        Thread.sleep(<span class=number>100</span>);</span><br><span class=line>        timer += System.currentTimeMillis();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>为了了解如何在ASM中实现这一点，我们可以编译这两个类，并比较这两个版本上的TraceClassVisitor的输出（使用默认的Textifier后端或使用ASMifier后端）。使用默认后端，我们得到以下差异（粗体）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line>GETSTATIC C.timer : J</span><br><span class=line>INVOKESTATIC java/lang/System.currentTimeMillis()J</span><br><span class=line>LSUB</span><br><span class=line>PUTSTATIC C.timer : J</span><br><span class=line>LDC <span class=number>100</span></span><br><span class=line>INVOKESTATIC java/lang/Thread.sleep(J)V</span><br><span class=line>GETSTATIC C.timer : J</span><br><span class=line>INVOKESTATIC java/lang/System.currentTimeMillis()J</span><br><span class=line>LADD</span><br><span class=line>PUTSTATIC C.timer : J</span><br><span class=line><span class=type>RETURN</span></span><br><span class=line><span class=variable>MAXSTACK</span> <span class=operator>=</span> <span class=number>4</span></span><br><span class=line>MAXLOCALS = <span class=number>1</span></span><br></pre></table></figure><p>我们看到必须在方法的开头添加四个指令，在返回指令之前添加四个其他指令。我们还需要更新最大操作数堆栈大小。该方法代码的开头是通过visitCode方法访问的。因此，我们可以通过在方法适配器中重写此方法来添加前四个指令：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitCode</span><span class=params>()</span> {</span><br><span class=line>    mv.visitCode();</span><br><span class=line>    mv.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>    mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>    mv.visitInsn(LSUB);</span><br><span class=line>    mv.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>}</span><br></pre></table></figure><p>必须将owner设置为要转换的类的名称。现在，我们必须在任何RETURN之前，任何xRETURN或ATHROW之前添加其他四条指令，它们都是终止该方法执行的所有指令。这些指令没有任何参数，因此可以在visitInsn方法中进行访问。然后，我们可以覆盖此方法以添加我们的说明：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>    <span class=keyword>if</span> ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {</span><br><span class=line>        mv.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>        mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>        mv.visitInsn(LADD);</span><br><span class=line>        mv.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>    }</span><br><span class=line>    mv.visitInsn(opcode);</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-2-5、有状态转换><a class=headerlink href=#3-2-5、有状态转换 title=3.2.5、有状态转换></a>3.2.5、有状态转换</h3><p>为了实现删除或替换某些指令序列的转换，可以方便地引入MethodVisitor子类，该子类的visitXxx Insn方法调用通用的visitInsn（）方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">PatternMethodAdapter</span> <span class=keyword>extends</span> <span class="title class_">MethodVisitor</span> {</span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>int</span> <span class=variable>SEEN_NOTHING</span> <span class=operator>=</span> <span class=number>0</span>;</span><br><span class=line>    <span class=keyword>protected</span> <span class=type>int</span> state;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">PatternMethodAdapter</span><span class=params>(<span class=type>int</span> api, MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(api, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Overrid</span> <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        visitInsn();</span><br><span class=line>        mv.visitInsn(opcode);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitIntInsn</span><span class=params>(<span class=type>int</span> opcode, <span class=type>int</span> operand)</span> {</span><br><span class=line>        visitInsn();</span><br><span class=line>        mv.visitIntInsn(opcode, operand);</span><br><span class=line>    }</span><br><span class=line>    ...</span><br><span class=line>    <span class=keyword>protected</span> <span class=keyword>abstract</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>然后可以像这样实现上面的转换：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoveAddZeroAdapter</span> <span class=keyword>extends</span> <span class="title class_">PatternMethodAdapter</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>static</span> <span class=type>int</span> <span class=variable>SEEN_ICONST_0</span> <span class=operator>=</span> <span class=number>1</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RemoveAddZeroAdapter</span><span class=params>(MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        <span class=keyword>if</span> (state == SEEN_ICONST_0) {</span><br><span class=line>            <span class=keyword>if</span> (opcode == IADD) {</span><br><span class=line>            	state = SEEN_NOTHING;</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>        visitInsn();</span><br><span class=line>        <span class=keyword>if</span> (opcode == ICONST_0) {</span><br><span class=line>            state = SEEN_ICONST_0;</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>        mv.visitInsn(opcode);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> <span class=keyword>protected</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>if</span> (state == SEEN_ICONST_0) {</span><br><span class=line>        	mv.visitInsn(ICONST_0);</span><br><span class=line>        }</span><br><span class=line>        state = SEEN_NOTHING;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=3-3、工具><a class=headerlink href=#3-3、工具 title=3.3、工具></a>3.3、工具</h2><h3 id=3-3-1、基础工具><a class=headerlink href=#3-3-1、基础工具 title=3.3.1、基础工具></a>3.3.1、基础工具</h3><ul><li>Type<li>TraceClassVisitor<li>CheckClassAdapter<li>ASMifier</ul><h3 id=3-3-2、分析适配器><a class=headerlink href=#3-3-2、分析适配器 title=3.3.2、分析适配器></a>3.3.2、分析适配器</h3><p>在我们的AddTimerAdapter示例中，可以使用此适配器来获取RETURN指令之前的操作数堆栈的大小，从而允许为visitMaxs中的maxStack计算最佳转换值（实际上，不建议使用此方法，因为它比使用COMPUTE_MAXS效率低得多）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">AddTimerMethodAdapter2</span> <span class=keyword>extends</span> <span class="title class_">AnalyzerAdapter</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> maxStack;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AddTimerMethodAdapter2</span><span class=params>(String owner, <span class=type>int</span> access, String name, String desc, MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, owner, access, name, desc, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitCode</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>super</span>.visitCode();</span><br><span class=line>        mv.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>        mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>        mv.visitInsn(LSUB);</span><br><span class=line>        mv.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>        maxStack = <span class=number>4</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        <span class=keyword>if</span> ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {</span><br><span class=line>            mv.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>            mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>            mv.visitInsn(LADD);</span><br><span class=line>            mv.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>            maxStack = Math.max(maxStack, stack.size() + <span class=number>4</span>);</span><br><span class=line>        }</span><br><span class=line>    	<span class=built_in>super</span>.visitInsn(opcode);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitMaxs</span><span class=params>(<span class=type>int</span> maxStack, <span class=type>int</span> maxLocals)</span> {</span><br><span class=line>    	<span class=built_in>super</span>.visitMaxs(Math.max(<span class=built_in>this</span>.maxStack, maxStack), maxLocals);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>或者，可以通过调用超类的方法来插入新指令：结果是这些指令的帧将由AnalyzerAdapter计算。此外，由于此适配器基于其计算的帧来更新visitMaxs的参数，因此我们不需要自己更新它们：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">AddTimerMethodAdapter3</span> <span class=keyword>extends</span> <span class="title class_">AnalyzerAdapter</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AddTimerMethodAdapter3</span><span class=params>(String owner, <span class=type>int</span> access, String name, String desc, MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, owner, access, name, desc, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitCode</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>super</span>.visitCode();</span><br><span class=line>        <span class=built_in>super</span>.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>        <span class=built_in>super</span>.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>        <span class=built_in>super</span>.visitInsn(LSUB);</span><br><span class=line>        <span class=built_in>super</span>.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        <span class=keyword>if</span> ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {</span><br><span class=line>            <span class=built_in>super</span>.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>            <span class=built_in>super</span>.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>            <span class=built_in>super</span>.visitInsn(LADD);</span><br><span class=line>            <span class=built_in>super</span>.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>        }</span><br><span class=line>        <span class=built_in>super</span>.visitInsn(opcode);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-3-3、LocalVariablesSorter><a class=headerlink href=#3-3-3、LocalVariablesSorter title=3.3.3、LocalVariablesSorter></a>3.3.3、LocalVariablesSorter</h3><p>为了展示如何使用此适配器，假设我们要使用局部变量来实现AddTimerAdapter：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">C</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=type>long</span> timer;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">m</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>long</span> <span class=variable>t</span> <span class=operator>=</span> System.currentTimeMillis();</span><br><span class=line>        Thread.sleep(<span class=number>100</span>);</span><br><span class=line>        timer += System.currentTimeMillis() - t;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>通过扩展LocalVariablesSorter并使用此类中定义的newLocal方法，可以轻松完成此操作：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">AddTimerMethodAdapter4</span> <span class=keyword>extends</span> <span class="title class_">LocalVariablesSorter</span> {</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> time;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AddTimerMethodAdapter4</span><span class=params>(<span class=type>int</span> access, String desc, MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, access, desc, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitCode</span><span class=params>()</span> {</span><br><span class=line>        <span class=built_in>super</span>.visitCode();</span><br><span class=line>        mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>        time = newLocal(Type.LONG_TYPE);</span><br><span class=line>        mv.visitVarInsn(LSTORE, time);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        <span class=keyword>if</span> ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {</span><br><span class=line>            mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>            mv.visitVarInsn(LLOAD, time);</span><br><span class=line>            mv.visitInsn(LSUB);</span><br><span class=line>            mv.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>            mv.visitInsn(LADD);</span><br><span class=line>            mv.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>        }</span><br><span class=line>        <span class=built_in>super</span>.visitInsn(opcode);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitMaxs</span><span class=params>(<span class=type>int</span> maxStack, <span class=type>int</span> maxLocals)</span> {</span><br><span class=line>    	<span class=built_in>super</span>.visitMaxs(maxStack + <span class=number>4</span>, maxLocals);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>使用局部变量不能解决我们在此类的原始版本中遇到的问题，该问题涉及maxStack的最坏情况。如果要使用AnalyzerAdapter来解决此问题，除了LocalVariablesSorter之外，还必须通过委派而不是通过继承使用这些适配器（因为无法进行多重继承）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br></pre><td class=code><pre><span class=line><span class=keyword>class</span> <span class="title class_">AddTimerMethodAdapter5</span> <span class=keyword>extends</span> <span class="title class_">MethodVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> LocalVariablesSorter lvs;</span><br><span class=line>    <span class=keyword>public</span> AnalyzerAdapter aa;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> time;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>int</span> maxStack;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AddTimerMethodAdapter5</span><span class=params>(MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitCode</span><span class=params>()</span> {</span><br><span class=line>        mv.visitCode();</span><br><span class=line>        mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>        time = lvs.newLocal(Type.LONG_TYPE);</span><br><span class=line>        mv.visitVarInsn(LSTORE, time);</span><br><span class=line>        maxStack = <span class=number>4</span>;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInsn</span><span class=params>(<span class=type>int</span> opcode)</span> {</span><br><span class=line>        <span class=keyword>if</span> ((opcode >= IRETURN && opcode <= RETURN) || opcode == ATHROW) {</span><br><span class=line>            mv.visitMethodInsn(INVOKESTATIC, <span class=string>"java/lang/System"</span>, <span class=string>"currentTimeMillis"</span>, <span class=string>"()J"</span>);</span><br><span class=line>            mv.visitVarInsn(LLOAD, time);</span><br><span class=line>            mv.visitInsn(LSUB);</span><br><span class=line>            mv.visitFieldInsn(GETSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>            mv.visitInsn(LADD);</span><br><span class=line>            mv.visitFieldInsn(PUTSTATIC, owner, <span class=string>"timer"</span>, <span class=string>"J"</span>);</span><br><span class=line>            maxStack = Math.max(aa.stack.size() + <span class=number>4</span>, maxStack);</span><br><span class=line>        }</span><br><span class=line>        mv.visitInsn(opcode);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitMaxs</span><span class=params>(<span class=type>int</span> maxStack, <span class=type>int</span> maxLocals)</span> {</span><br><span class=line>    	mv.visitMaxs(Math.max(<span class=built_in>this</span>.maxStack, maxStack), maxLocals);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>为了使用此适配器，您必须将LocalVariablesSorter链接到AnalyzerAdapter，后者本身也链接到您的适配器：第一个适配器将对局部变量进行排序并相应地更新帧，分析器适配器将计算中间帧，并考虑到前一个适配器中完成的重新编号，您的适配器将可以访问这些重新编号的中间框架。该链可以在visitMethod中构造如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line>mv = cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class=line><span class=keyword>if</span> (!isInterface && mv != <span class=literal>null</span> && !name.equals(<span class=string>"&LTinit>"</span>)) {</span><br><span class=line>    <span class=type>AddTimerMethodAdapter5</span> <span class=variable>at</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AddTimerMethodAdapter5</span>(mv);</span><br><span class=line>    at.aa = <span class=keyword>new</span> <span class="title class_">AnalyzerAdapter</span>(owner, access, name, desc, at);</span><br><span class=line>    at.lvs = <span class=keyword>new</span> <span class="title class_">LocalVariablesSorter</span>(access, desc, at.aa);</span><br><span class=line>    <span class=keyword>return</span> at.lvs;</span><br><span class=line>}</span><br></pre></table></figure><h3 id=3-3-4、AdviceAdapter><a class=headerlink href=#3-3-4、AdviceAdapter title=3.3.4、AdviceAdapter></a>3.3.4、AdviceAdapter</h3><h1 id=4、元数据><a class=headerlink href=#4、元数据 title=4、元数据></a>4、元数据</h1><p>本章说明如何使用核心API生成和转换已编译的Java类元数据，例如注释。每个部分都以一种类型的元数据开始呈现，然后以一些说明性示例呈现相应的ASM接口，组件和工具以生成和转换这些元数据。<h2 id=4-1、泛型><a class=headerlink href=#4-1、泛型 title=4.1、泛型></a>4.1、泛型</h2><p>诸如List之类的通用类以及使用它们的类包含有关它们声明或使用的通用类型的信息。字节码指令在运行时不使用此信息，但是可以通过反射API进行访问。编译器还使用它进行单独的编译。<h3 id=4-1-2、接口与组件><a class=headerlink href=#4-1-2、接口与组件 title=4.1.2、接口与组件></a>4.1.2、接口与组件</h3><p>与描述符一样，出于相同的效率原因（请参阅第2.3.1节），ASM API公开存储在已编译类中的签名（签名的主要出现位置是ClassVisitor类的visit，visitField和visitMethod方法，作为可选的类，类型或方法签名参数）。希望它还在org.objectweb.asm.signature包中基于SignatureVisitor抽象类提供了一些生成和转换签名的工具。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">SignatureVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>char</span> <span class=variable>EXTENDS</span> <span class=operator>=</span> ’+’;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>char</span> <span class=variable>SUPER</span> <span class=operator>=</span> ’-’;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>final</span> <span class=keyword>static</span> <span class=type>char</span> <span class=variable>INSTANCEOF</span> <span class=operator>=</span> ’=’;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">SignatureVisitor</span><span class=params>(<span class=type>int</span> api)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitFormalTypeParameter</span><span class=params>(String name)</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitClassBound</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitInterfaceBound</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitSuperclass</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitInterface</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitParameterType</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitReturnType</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitExceptionType</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitBaseType</span><span class=params>(<span class=type>char</span> descriptor)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitTypeVariable</span><span class=params>(String name)</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitArrayType</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitClassType</span><span class=params>(String name)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInnerClassType</span><span class=params>(String name)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitTypeArgument</span><span class=params>()</span>;</span><br><span class=line>    <span class=keyword>public</span> SignatureVisitor <span class="title function_">visitTypeArgument</span><span class=params>(<span class=type>char</span> wildcard)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>以下代码的结果为“ LA.B;”：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=type>String</span> <span class=variable>s</span> <span class=operator>=</span> <span class=string>"Ljava/util/HashMap&LTTK;TV;>.HashIterator&LTTK;>;"</span>;</span><br><span class=line>Map&LTString, String> renaming = <span class=keyword>new</span> <span class="title class_">HashMap</span>&LTString, String>();</span><br><span class=line>renaming.put(<span class=string>"java/util/HashMap"</span>, <span class=string>"A"</span>);</span><br><span class=line>renaming.put(<span class=string>"java/util/HashMap.HashIterator"</span>, <span class=string>"B"</span>);</span><br><span class=line><span class=type>SignatureWriter</span> <span class=variable>sw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SignatureWriter</span>();</span><br><span class=line><span class=type>SignatureVisitor</span> <span class=variable>sa</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">RenameSignatureAdapter</span>(sw, renaming);</span><br><span class=line><span class=type>SignatureReader</span> <span class=variable>sr</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">SignatureReader</span>(s);</span><br><span class=line>sr.acceptType(sa);</span><br><span class=line>sw.toString();</span><br></pre></table></figure><h3 id=4-1-3、工具><a class=headerlink href=#4-1-3、工具 title=4.1.3、工具></a>4.1.3、工具</h3><p>2.3节中介绍的TraceClassVisitor和ASMifier类以内部形式打印类文件中包含的签名。它们可以通过以下方式用于查找与给定泛型类型相对应的签名：编写具有某些泛型类型的Java类，对其进行编译，然后使用这些命令行工具来找到相应的签名。<h2 id=4-2、注解><a class=headerlink href=#4-2、注解 title=4.2、注解></a>4.2、注解</h2><p>如果类，字段，方法和方法参数的注释（例如@Deprecated或@Override）存储在已编译的类中，则其保留策略不是RetentionPolicy.SOURCE。该信息在运行时不会由字节码指令使用，但是如果保留策略为RetentionPolicy.RUNTIME，则可以通过反射API进行访问。编译器也可以使用它。<h3 id=4-2-1、结构><a class=headerlink href=#4-2-1、结构 title=4.2.1、结构></a>4.2.1、结构</h3><p>源代码中的注释可以采用各种形式，例如@ Deprecated，@ Retention（RetentionPolicy.CLASS）或@Task（desc =“ refactor”，id = 1）。但是，在内部，所有注释都具有相同的形式，并由注释类型和一组名称值对指定，其中值限于：<ol><li>基本值，字符串或类值。<li>枚举值。<li>注释值。<li>以上值的数组。</ol><p>请注意，注释可以包含其他注释，甚至可以包含注释数组。因此，注释可能非常复杂。<h3 id=4-2-2、接口与组件><a class=headerlink href=#4-2-2、接口与组件 title=4.2.2、接口与组件></a>4.2.2、接口与组件</h3><p>用于生成和转换注释的ASM API基于AnnotationVisitor抽象类。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>abstract</span> <span class=keyword>class</span> <span class="title class_">AnnotationVisitor</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AnnotationVisitor</span><span class=params>(<span class=type>int</span> api)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AnnotationVisitor</span><span class=params>(<span class=type>int</span> api, AnnotationVisitor av)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(String name, Object value)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnum</span><span class=params>(String name, String desc, String value)</span>;</span><br><span class=line>    <span class=keyword>public</span> AnnotationVisitor <span class="title function_">visitAnnotation</span><span class=params>(String name, String desc)</span>;</span><br><span class=line>    <span class=keyword>public</span> AnnotationVisitor <span class="title function_">visitArray</span><span class=params>(String name)</span>;</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure><p><strong>添加，删除和检测注释：</strong><p>像字段和方法一样，可以通过在visitAnnotation方法中返回null来删除注释：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">RemoveAnnotationAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>private</span> String annDesc;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">RemoveAnnotationAdapter</span><span class=params>(ClassVisitor cv, String annDesc)</span> {</span><br><span class=line>        <span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>        <span class=built_in>this</span>.annDesc = annDesc;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> AnnotationVisitor <span class="title function_">visitAnnotation</span><span class=params>(String desc, <span class=type>boolean</span> vis)</span> {</span><br><span class=line>        <span class=keyword>if</span> (desc.equals(annDesc)) {</span><br><span class=line>            <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cv.visitAnnotation(desc, vis);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>由于必须调用ClassVisitor类的方法的限制，添加类注释会更加困难。实际上，必须重写所有在visitAnnotation之后的方法，以检测何时访问了所有注释（由于使用了visitCode方法，方法注释更易于添加）：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">AddAnnotationAdapter</span> <span class=keyword>extends</span> <span class="title class_">ClassVisitor</span> {</span><br><span class=line>    <span class=keyword>private</span> String annotationDesc;</span><br><span class=line>    <span class=keyword>private</span> <span class=type>boolean</span> isAnnotationPresent;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">AddAnnotationAdapter</span><span class=params>(ClassVisitor cv, String annotationDesc)</span> {</span><br><span class=line>        <span class=built_in>super</span>(ASM4, cv);</span><br><span class=line>        <span class=built_in>this</span>.annotationDesc = annotationDesc;</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visit</span><span class=params>(<span class=type>int</span> version, <span class=type>int</span> access, String name, String signature, String superName, String[] interfaces)</span> {</span><br><span class=line>        <span class=type>int</span> <span class=variable>v</span> <span class=operator>=</span> (version & <span class=number>0xFF</span>) < V1_5 ? V1_5 : version;</span><br><span class=line>        cv.visit(v, access, name, signature, superName, interfaces);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> AnnotationVisitor <span class="title function_">visitAnnotation</span><span class=params>(String desc, <span class=type>boolean</span> visible)</span> {</span><br><span class=line>        <span class=keyword>if</span> (visible && desc.equals(annotationDesc)) {</span><br><span class=line>            isAnnotationPresent = <span class=literal>true</span>;</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>return</span> cv.visitAnnotation(desc, visible);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitInnerClass</span><span class=params>(String name, String outerName, String innerName, <span class=type>int</span> access)</span> {</span><br><span class=line>        addAnnotation();</span><br><span class=line>        cv.visitInnerClass(name, outerName, innerName, access);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> FieldVisitor <span class="title function_">visitField</span><span class=params>(<span class=type>int</span> access, String name, String desc, String signature, Object value)</span> {</span><br><span class=line>        addAnnotation();</span><br><span class=line>        <span class=keyword>return</span> cv.visitField(access, name, desc, signature, value);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> MethodVisitor <span class="title function_">visitMethod</span><span class=params>(<span class=type>int</span> access, String name, String desc, String signature, String[] exceptions)</span> {</span><br><span class=line>        addAnnotation();</span><br><span class=line>        <span class=keyword>return</span> cv.visitMethod(access, name, desc, signature, exceptions);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span> </span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitEnd</span><span class=params>()</span> {</span><br><span class=line>        addAnnotation();</span><br><span class=line>        cv.visitEnd();</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">addAnnotation</span><span class=params>()</span> {</span><br><span class=line>        <span class=keyword>if</span> (!isAnnotationPresent) {</span><br><span class=line>            <span class=type>AnnotationVisitor</span> <span class=variable>av</span> <span class=operator>=</span> cv.visitAnnotation(annotationDesc, <span class=literal>true</span>);</span><br><span class=line>            <span class=keyword>if</span> (av != <span class=literal>null</span>) {</span><br><span class=line>            	av.visitEnd();</span><br><span class=line>            }</span><br><span class=line>            isAnnotationPresent = <span class=literal>true</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h3 id=4-2-3、工具><a class=headerlink href=#4-2-3、工具 title=4.2.3、工具></a>4.2.3、工具</h3><p>2.3节中介绍的TraceClassVisitor，CheckClassAdapter和ASMifier类也支持注释（与方法一样，也可以使用TraceAnnotationVisitor或CheckAnnotationAdapter在单个注释级别而不是在类级别使用）。它们可以用来查看如何生成一些特定的注释。例如使用：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>java -classpath asm.jar:asm-util.jar \</span><br><span class=line>org.objectweb.asm.util.ASMifier \</span><br><span class=line>java.lang.Deprecated</span><br></pre></table></figure><p>打印经过少量重构后的代码，其内容为：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> asm.java.lang;</span><br><span class=line><span class=keyword>import</span> org.objectweb.asm.*;</span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DeprecatedDump</span> <span class=keyword>implements</span> <span class="title class_">Opcodes</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=type>byte</span>[] dump() <span class=keyword>throws</span> Exception {</span><br><span class=line>        <span class=type>ClassWriter</span> <span class=variable>cw</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ClassWriter</span>(<span class=number>0</span>);</span><br><span class=line>        AnnotationVisitor av;</span><br><span class=line>        cw.visit(V1_5, ACC_PUBLIC + ACC_ANNOTATION + ACC_ABSTRACT + ACC_INTERFACE, <span class=string>"java/lang/Deprecated"</span>, <span class=literal>null</span>, <span class=string>"java/lang/Object"</span>, <span class=keyword>new</span> <span class="title class_">String</span>[] {<span class=string>"java/lang/annotation/Annotation"</span> });</span><br><span class=line>        {</span><br><span class=line>            av = cw.visitAnnotation(<span class=string>"Ljava/lang/annotation/Documented;"</span>, <span class=literal>true</span>);</span><br><span class=line>            av.visitEnd();</span><br><span class=line>        }</span><br><span class=line>        {</span><br><span class=line>            av = cw.visitAnnotation(<span class=string>"Ljava/lang/annotation/Retention;"</span>, <span class=literal>true</span>);</span><br><span class=line>            av.visitEnum(<span class=string>"value"</span>, <span class=string>"Ljava/lang/annotation/RetentionPolicy;"</span>,</span><br><span class=line>            <span class=string>"RUNTIME"</span>);</span><br><span class=line>            av.visitEnd();</span><br><span class=line>        }</span><br><span class=line>        cw.visitEnd();</span><br><span class=line>        <span class=keyword>return</span> cw.toByteArray();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h2 id=4-3、Debug><a class=headerlink href=#4-3、Debug title=4.3、Debug></a>4.3、Debug</h2><p>用javac -g编译的类包含其源文件的名称，源行号和字节码指令之间的映射以及源代码中的本地变量名称和字节码中的本地变量槽之间的映射。此可选信息在调试器中使用，并且在可用时在异常堆栈跟踪中使用。<h3 id=4-3-2、接口与组件><a class=headerlink href=#4-3-2、接口与组件 title=4.3.2、接口与组件></a>4.3.2、接口与组件</h3><p>使用ClassVisitor和MethodVisitor类的三种方法访问调试信息：<ul><li>使用ClassVisitor类的visitSource方法访问源文件名；<li>使用MethodVisitor类的visitLineNumber方法访问源行号和字节码指令之间的映射，一次一对。<li>使用MethodVisitor类的visitLocalVariable方法访问源代码中的局部变量名称和字节码中的局部变量槽之间的映射，一次访问一个元组。</ul><p>在访问作为参数传递的标签之后，必须调用visitLineNumber方法。实际上，在该标签之后调用它，这使得在方法访问者中很容易知道当前指令的源代码行：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">MyAdapter</span> <span class=keyword>extends</span> <span class="title class_">MethodVisitor</span> {</span><br><span class=line>    <span class=type>int</span> currentLine;</span><br><span class=line>    <span class=keyword>public</span> <span class="title function_">MyAdapter</span><span class=params>(MethodVisitor mv)</span> {</span><br><span class=line>    	<span class=built_in>super</span>(ASM4, mv);</span><br><span class=line>    }</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">visitLineNumber</span><span class=params>(<span class=type>int</span> line, Label start)</span> {</span><br><span class=line>        mv.visitLineNumber(line, start);</span><br><span class=line>        currentLine = line;</span><br><span class=line>    }</span><br><span class=line>    ...</span><br><span class=line>}</span><br></pre></table></figure><p>同样，在访问作为参数传递的标签之后，必须调用visitLocalVariable方法。这是与上一节中介绍的对和元组相对应的示例方法调用：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line>visitLineNumber(n1, l1);</span><br><span class=line>visitLineNumber(n2, l2);</span><br><span class=line>visitLineNumber(n3, l3);</span><br><span class=line>visitLocalVariable(<span class=string>"i"</span>, <span class=string>"I"</span>, <span class=literal>null</span>, l1, l2, <span class=number>1</span>);</span><br><span class=line>visitLocalVariable(<span class=string>"j"</span>, <span class=string>"I"</span>, <span class=literal>null</span>, l2, l3, <span class=number>1</span>);</span><br><span class=line>visitLocalVariable(<span class=string>"i"</span>, <span class=string>"I"</span>, <span class=literal>null</span>, l3, end, <span class=number>1</span>);</span><br></pre></table></figure><p><strong>忽略调试信息</strong><p>注意：ClassReader类提供其他选项，例如SKIP_CODE跳过对已编译代码的访问（如果您只需要类结构，这将很有用），SKIP_FRAMES跳过堆栈映射框架，以及EXPAND_FRAMES取消压缩这些框架。<h3 id=4-3-3、工具><a class=headerlink href=#4-3-3、工具 title=4.3.3、工具></a>4.3.3、工具</h3><p>与通用类型和注释一样，您可以使用TraceClassVisitor，CheckClassAdapter和ASMifier类来查找如何使用调试信息。<h1 id=5、向后兼容（Backward-compatibility）><a title="5、向后兼容（Backward compatibility）" class=headerlink href=#5、向后兼容（Backward-compatibility）></a>5、向后兼容（Backward compatibility）</h1><h2 id=5-1、简介><a class=headerlink href=#5-1、简介 title=5.1、简介></a>5.1、简介</h2><p>ASM 4.0中引入的向后兼容机制，需要将ClassVisitor，FieldVisitor，MethodVisitor等从接口更改为抽象类，并使用构造函数以ASM版本作为参数。如果您的代码是针对ASM 3.x实施的，则可以通过在代码分析器和适配器中将扩展替换为工具，并在其构造函数中指定ASM版本，将其升级到ASM 4.0。此外，ClassAdapter和MethodAdapter已合并为ClassVisitor和MethodVisitor。要转换代码，只需要将ClassAdapter替换为ClassVisitor，并将MethodAdapter替换为MethodVisitor。另外，如果定义了自定义FieldAdapter或AnnotationAdapter类，则现在可以将它们替换为FieldVisitor和AnnotationVisitor。<h3 id=5-1-1、Backward-compatibility-contract><a title="5.1.1、Backward compatibility contract" class=headerlink href=#5-1-1、Backward-compatibility-contract></a>5.1.1、Backward compatibility contract</h3><p>实际上，对于类生成器，分析器和适配器，影响是不同的：<ul><li>类生成器不受影响：它们生成具有某些固定类版本的代码，并且这些生成的类将在将来的JVM版本中保持有效，因为JVM确保了向后二进制兼容性。<li>•类分析器可能会受到影响，也可能不会受到影响。例如，尽管引入了注释，但是分析针对Java 4编写的字节码指令的代码可能仍将适用于Java 5类。但是，这些相同的代码可能不再适用于Java 7类，因为它不能忽略新的invokedynamic指令。<li>类适配器可能会受到影响，也可能不会受到影响。无效代码删除工具不受注释的引入甚至新的invokedynamic指令的影响。另一方面，类重命名工具受这两者的影响。类适配器可能会受到影响，也可能不会受到影响。无效代码删除工具不受注释的引入甚至新的invokedynamic指令的影响。另一方面，类重命名工具受这两者的影响。</ul><p>所有这些导致了以下向后兼容协议的定义：<ul><li>ASM版本X是为版本小于或等于x的Java类编写的。它不能生成版本y> x的类，并且在ClassReader.accept中输入大于x的类作为输入时必须失败。<li>为ASM X编写的代码并遵循下面介绍的准则，必须继续使用未经修改的输入类，并且输入类的版本必须为x，且ASM的将来版本为Y> X。<li>为ASM X编写并遵循下面介绍的准则的代码必须继续使用未经声明的输入类，它们的声明版本为y，但仅使用具有ASM Y或更高版本的旧版本或等于x的版本中定义的功能。<li>如果将使用ASM X或任何其他将来版本的，使用类版本y> x中引入的功能的输入作为输入，则为ASM X编写并遵循下面介绍的准则的代码必须失败。</ul><p>请注意，最后三点与类别生成器无关，后者没有类别输入。<h3 id=5-1-2、例子><a class=headerlink href=#5-1-2、例子 title=5.1.2、例子></a>5.1.2、例子</h3><p>为了说明用户指南和确保向后兼容性的内部ASM机制，我们在本章中假设将向Java 8类添加两个新的虚构属性，一个用于存储类作者，另一个用于存储其许可证。 。我们还假设这些新属性将通过ASM 5.0中的ClassVisitor中的两个新方法公开：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> <span class="title function_">visitLicense</span><span class=params>(String license)</span>;</span><br></pre></table></figure><p>来访问许可证，并使用新版本的visitSource来与源文件名和调试信息1一起访问作者：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>void</span> <span class="title function_">visitSource</span><span class=params>(String author, String source, String debug)</span>;</span><br></pre></table></figure><p>旧的visitSource方法仍然有效，但是在ASM 5.0中声明为已弃用：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=meta>@Deprecated</span> </span><br><span class=line><span class=keyword>void</span> <span class="title function_">visitSource</span><span class=params>(String source, String debug)</span>;</span><br></pre></table></figure><p>author和license属性是可选的，即，调用visitLicense不是必需的，在visitSource调用中author可以为null。<h2 id=5-2、指导><a class=headerlink href=#5-2、指导 title=5.2、指导></a>5.2、指导</h2><h3 id=5-2-1、基本规则><a class=headerlink href=#5-2-1、基本规则 title=5.2.1、基本规则></a>5.2.1、基本规则</h3><p>准则1：为ASM版本X编写ClassVisitor子类，以该确切版本作为参数调用ClassVisitor构造函数，并且永远不要覆盖或调用在此版本的ClassVisitor类中不推荐使用的方法（或在更高版本中引入的方法）。<h3 id=5-2-2、继承规则><a class=headerlink href=#5-2-2、继承规则 title=5.2.2、继承规则></a>5.2.2、继承规则</h3><p>准则2：不要使用访问者的继承，而应使用委派（即访问者链）。一种好的做法是，默认情况下将您的访问者班级定为最终班，以确保做到这一点。<p>实际上，该规则有两个例外：<ol><li>如果您自己完全控制继承链，并同时释放层次结构的所有类，则可以使用访问者的继承。然后，您必须确保为同一ASM版本编写层次结构中的所有类。尽管如此，将层次结构的叶类定为最终类。<li>如果除叶子类之外没有其他类重写任何访问方法，则可以使用“访问者”的继承（例如，如果您在ClassVisitor和具体访问者类之间使用中间类只是为了引入便捷方法）。仍然，使层次结构的叶类成为最终类（除非它们也不覆盖任何访问方法；在这种情况下，请提供一个构造器，以ASM版本作为参数，以便子类可以指定为其编写的版本）。</ol></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Apache%20Dubbo%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Apache%20Dubbo%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/ itemprop=url>Dubbo系列-Dubbo基础应用</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 15:13:46" datetime=2023-10-02T15:13:46+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Dubbo/ itemprop=url rel=index><span itemprop=name>Dubbo</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、软件架构演进><a class=headerlink href=#1、软件架构演进 title=1、软件架构演进></a>1、软件架构演进</h1><p>软件架构的发展经历了由单体架构、垂直架构、SOA架构到微服务架构的演进过程，下面我们分别了解一下这几个架构。<h2 id=1-1、单体架构><a class=headerlink href=#1-1、单体架构 title=1.1、单体架构></a>1.1、单体架构</h2><p><img alt=image-20210523002635007 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210523002635007.png><h3 id=1-1-1、架构说明><a class=headerlink href=#1-1-1、架构说明 title=1.1.1、架构说明></a>1.1.1、架构说明</h3><p>全部功能集中在一个项目内（All in one）。<h3 id=1-1-2、架构优劣><a class=headerlink href=#1-1-2、架构优劣 title=1.1.2、架构优劣></a>1.1.2、架构优劣</h3><p><strong>优点</strong><p>架构简单，前期开发成本低、开发周期短，适合小型项目。<p><strong>缺点</strong><ol><li>全部功能集成在一个工程中，对于大型项目不易开发、扩展和维护。<li>技术栈受限，只能使用一种语言开发。<li>系统性能扩展只能通过扩展集群节点，成本高。</ol><h2 id=1-2、垂直架构><a class=headerlink href=#1-2、垂直架构 title=1.2、垂直架构></a>1.2、垂直架构</h2><p><img alt=image-20230807163107976 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20230807163107976.png><h3 id=1-2-1、架构说明><a class=headerlink href=#1-2-1、架构说明 title=1.2.1、架构说明></a>1.2.1、架构说明</h3><p>按照业务进行切割，形成小型单体项目。<h3 id=1-2-2、架构优劣><a class=headerlink href=#1-2-2、架构优劣 title=1.2.2、架构优劣></a>1.2.2、架构优劣</h3><p><strong>优点</strong><p>技术栈可扩展（不同的系统可以用不同的编程语言编写）。<p><strong>缺点</strong><ol><li>功能集中在一个项目中，不利于开发、扩展、维护。<li>系统扩张只能通过集群的方式。<li>项目之间功能冗余、数据冗余、耦合性强。</ol><h2 id=1-3、SOA架构><a class=headerlink href=#1-3、SOA架构 title=1.3、SOA架构></a>1.3、SOA架构</h2><img alt=image-20210523003707628 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023%2F08%2F07%2Fimage-20210523003707628.png style=zoom:150%;><h3 id=1-3-1、简介><a class=headerlink href=#1-3-1、简介 title=1.3.1、简介></a>1.3.1、简介</h3><p><strong>SOA 全称是 Service-Oriented Architecture，意为面向服务的架构。它可以 根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用。一个服务通常以独立的形式存在于操作系统进程中。</strong><p>站在功能角度，把业务逻辑抽象成可复用的服务，通过 服务编排 实现 业务快速再生，目的：把原先固有的业务功能转变为通用的业务服务，实现业务逻辑的快速复用。<h3 id=1-3-2、架构说明><a class=headerlink href=#1-3-2、架构说明 title=1.3.2、架构说明></a>1.3.2、架构说明</h3><p>将 重复功能 或 模块 抽取成 组件 形式，对外提供服务，项目与服务间 使用ESB（企业服务总线）形式作为 通信桥梁。<h3 id=1-3-3、架构优劣><a class=headerlink href=#1-3-3、架构优劣 title=1.3.3、架构优劣></a>1.3.3、架构优劣</h3><p><strong>优点</strong><ol><li>重复功能或模块抽取为服务，提高开发效率。<li>可重用性高。<li>可维护性高。</ol><p><strong>缺点</strong><ol><li>各系统之间业务不同，很难确认功能或模块是重复的。<li>抽取服务的粒度大。<li>系统和服务之间耦合度高。</ol><h2 id=1-4、微服务架构><a class=headerlink href=#1-4、微服务架构 title=1.4、微服务架构></a>1.4、微服务架构</h2><p><img alt=image-20210523002853420 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210523002853420.png><h3 id=1-4-1、架构说明><a class=headerlink href=#1-4-1、架构说明 title=1.4.1、架构说明></a>1.4.1、架构说明</h3><p>将系统服务层完全独立出来，抽取为一个一个的微服务。抽取的粒度更细，遵循单一原则。采用轻量级框架协议传输。<h3 id=1-4-2、架构优劣><a class=headerlink href=#1-4-2、架构优劣 title=1.4.2、架构优劣></a>1.4.2、架构优劣</h3><p><strong>优点</strong><ol><li>服务拆分粒度更细，有利于提高开发效率。<li>可以针对不同服务制定对应的优化方案。<li>适用于互联网时代，产品迭代周期更短。</ol><p><strong>缺点</strong><ol><li>粒度太细导致服务太多，维护成本高。<li>分布式系统开发的技术成本高，对团队的挑战大。</ol><h1 id=2、Apache-Dubbo概述><a title="2、Apache Dubbo概述" class=headerlink href=#2、Apache-Dubbo概述></a>2、Apache Dubbo概述</h1><h2 id=2-1、Dubbo简介><a class=headerlink href=#2-1、Dubbo简介 title=2.1、Dubbo简介></a>2.1、Dubbo简介</h2><p>Apache Dubbo是一款高性能的<em><strong>Java RPC框架</strong></em>。其前身是阿里巴巴公司开源的一个高性能、轻量级的开源Java RPC框架，可以和Spring框架无缝集成。<p>RPC全称为 <code>remote procedure call</code>，即<em><strong>远程过程调用</strong></em>。比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上的应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和传达调用数据。<blockquote><p>注意：RPC并不是一个具体的技术，而是指整个网络远程调用过程。</blockquote><p>RPC是一个泛化概念，严格来说一切远程过程调用手段都属于RPC范畴。各种开发语言都有自己的RPC框架。Java中的RPC框架比较多，广泛使用的有RMI、Hessian、Dubbo等。<blockquote><p>Dubbo官网地址：<a href=http://dubbo.apache.org/ rel=noopener target=_blank>http://dubbo.apache.org</a></blockquote><p>Dubbo三大核心能力：<strong>面向接口的远程方法调用、智能容错和负载均衡、服务自动注册和发现。</strong><h2 id=2-2、Dubbo架构><a class=headerlink href=#2-2、Dubbo架构 title=2.2、Dubbo架构></a>2.2、Dubbo架构</h2><p>Dubbo架构图：<p><img alt=image-20230807164309565 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20230807164309565.png><p>节点角色说明：<table><thead><tr><th>节点<th>角色名称<tbody><tr><td>Provider<td>服务提供方<tr><td>Consumer<td>服务消费方<tr><td>Registry<td>注册中心<tr><td>Monitor<td>监控中心（统计服务调用次数和调用时间）<tr><td>Container<td>服务运行容器</table><blockquote><p>1、虚线表示异步访问，实线表示同步访问。<br>2、蓝色虚线表示在启动时完成的功能。<br>3、红色虚线(实线)都表示程序运行过程中执行的功能。</blockquote><p>调用关系说明：<ol start=0><li>服务容器负责启动，加载，运行服务提供者。<li>服务提供者在启动时，向注册中心注册自己为服务。<li>服务消费者在启动时，从注册中心订阅自己所需服务。<li>注册中心 返回服务提供者地址列表 给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<li>服务消费者 从 服务提供者地址列表中 基于软负载均衡算法 挑选一个服务提供者来调用，如果调用失败，就尝试其它服务提供者。<li>服务消费者和提供者在内存中的 累计 <strong>调用次数 和 调用时间 等统计数据会被定时每分钟发送一次到监控中心</strong>。</ol><h1 id=3、服务注册中心Zookeeper><a class=headerlink href=#3、服务注册中心Zookeeper title=3、服务注册中心Zookeeper></a>3、服务注册中心Zookeeper</h1><p>Dubbo官方推荐使用Zookeeper作为服务注册中心。<h2 id=3-1、Zookeeper介绍><a class=headerlink href=#3-1、Zookeeper介绍 title=3.1、Zookeeper介绍></a>3.1、Zookeeper介绍</h2><p>Zookeeper 是 Apache Hadoop 的子项目，是一个树型目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心。<p>流程说明：<ul><li>服务提供者(Provider)启动时：向 <code>/dubbo/com.foo.BarService/providers</code> 目录下写入自己的 URL 地址。<li>服务消费者(Consumer)启动时：订阅 <code>/dubbo/com.foo.BarService/providers</code> 目录下的提供者 URL 地址。并向 <code>/dubbo/com.foo.BarService/consumers</code> 目录下写入自己的 URL 地址。<li>监控中心（Monitor）启动时：订阅 <code>/dubbo/com.foo.BarService</code> 目录下的所有提供者和消费者 URL 地址。</ul><h2 id=3-2、安装Zookeeper><a class=headerlink href=#3-2、安装Zookeeper title=3.2、安装Zookeeper></a>3.2、安装Zookeeper</h2><p>下载地址：<a href=http://archive.apache.org/dist/zookeeper/ rel=noopener target=_blank>http://archive.apache.org/dist/zookeeper/</a><p>安装步骤：<ol><li><p>第一步：安装 jdk（略）。</p><li><p>第二步：把 zookeeper 的压缩包（zookeeper-3.4.6.tar.gz）上传到 linux 系统。</p><li><p>第三步：解压缩压缩包。</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>tar -zxvf zookeeper-3.4.6.tar.gz</span><br></pre></table></figure><li><p>第四步：进入zookeeper-3.4.6目录，创建data目录。</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=built_in>mkdir</span> data</span><br></pre></table></figure><li><p>第五步：进入conf目录 ，把zoo_sample.cfg 改名为zoo.cfg。</p> <figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=built_in>cd</span> conf</span><br><span class=line><span class=built_in>mv</span> zoo_sample.cfg zoo.cfg</span><br></pre></table></figure><li><p>第六步：打开zoo.cfg文件, 修改data属性：dataDir=/root/zookeeper-3.4.6/data。</p></ol><h2 id=3-3、常用操作><a class=headerlink href=#3-3、常用操作 title=3.3、常用操作></a>3.3、常用操作</h2><h3 id=3-3-1、启动><a class=headerlink href=#3-3-1、启动 title=3.3.1、启动></a>3.3.1、启动</h3><p>进入Zookeeper的bin目录，启动服务命令：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>./zkServer.sh start</span><br></pre></table></figure><h3 id=3-3-2、停止><a class=headerlink href=#3-3-2、停止 title=3.3.2、停止></a>3.3.2、停止</h3><p>停止服务命令：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>./zkServer.sh stop</span><br></pre></table></figure><h3 id=3-3-3、查看状态><a class=headerlink href=#3-3-3、查看状态 title=3.3.3、查看状态></a>3.3.3、查看状态</h3><p>查看服务状态：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>./zkServer.sh status</span><br></pre></table></figure><h1 id=4、Dubbo快速入门><a class=headerlink href=#4、Dubbo快速入门 title=4、Dubbo快速入门></a>4、Dubbo快速入门</h1><p>Dubbo最核心的功能就是实现跨网络远程调用。通过Dubbo来实现服务消费方远程调用服务提供方的方法。<h2 id=4-1、服务提供方开发><a class=headerlink href=#4-1、服务提供方开发 title=4.1、服务提供方开发></a>4.1、服务提供方开发</h2><p>开发步骤：<p>1、创建maven工程（打包方式为war）dubbodemo_provider，在pom.xml文件中导入如下坐标<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>properties</span>></span></span><br><span class=line>  <span class=tag><<span class=name>project.build.sourceEncoding</span>></span>UTF-8<span class=tag>&LT/<span class=name>project.build.sourceEncoding</span>></span></span><br><span class=line>  <span class=tag><<span class=name>maven.compiler.source</span>></span>1.8<span class=tag>&LT/<span class=name>maven.compiler.source</span>></span></span><br><span class=line>  <span class=tag><<span class=name>maven.compiler.target</span>></span>1.8<span class=tag>&LT/<span class=name>maven.compiler.target</span>></span></span><br><span class=line>  <span class=tag><<span class=name>spring.version</span>></span>5.0.5.RELEASE<span class=tag>&LT/<span class=name>spring.version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>properties</span>></span></span><br><span class=line><span class=tag><<span class=name>dependencies</span>></span></span><br><span class=line>  <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.springframework<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>spring-context<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>${spring.version}<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>  <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.springframework<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>spring-beans<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>${spring.version}<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>  <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.springframework<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>spring-webmvc<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>${spring.version}<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>  <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.springframework<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>spring-jdbc<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>${spring.version}<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>  <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.springframework<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>spring-aspects<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>${spring.version}<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>  <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.springframework<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>spring-jms<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>${spring.version}<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>  <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.springframework<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>spring-context-support<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>${spring.version}<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>  <span class=comment>&LT!-- dubbo相关 --></span></span><br><span class=line>  <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>com.alibaba<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>dubbo<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>2.6.0<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>  <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.apache.zookeeper<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>zookeeper<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>3.4.7<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>  <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>com.github.sgroschupf<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>zkclient<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>0.1<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>  <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>javassist<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>javassist<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>3.12.1.GA<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line>  <span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>com.alibaba<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>fastjson<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>1.2.47<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependencies</span>></span></span><br><span class=line><span class=tag><<span class=name>build</span>></span></span><br><span class=line>  <span class=tag><<span class=name>plugins</span>></span></span><br><span class=line>    <span class=tag><<span class=name>plugin</span>></span></span><br><span class=line>      <span class=tag><<span class=name>groupId</span>></span>org.apache.maven.plugins<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>      <span class=tag><<span class=name>artifactId</span>></span>maven-compiler-plugin<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>      <span class=tag><<span class=name>version</span>></span>2.3.2<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line>      <span class=tag><<span class=name>configuration</span>></span></span><br><span class=line>        <span class=tag><<span class=name>source</span>></span>1.8<span class=tag>&LT/<span class=name>source</span>></span></span><br><span class=line>        <span class=tag><<span class=name>target</span>></span>1.8<span class=tag>&LT/<span class=name>target</span>></span></span><br><span class=line>      <span class=tag>&LT/<span class=name>configuration</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>plugin</span>></span></span><br><span class=line>    <span class=tag><<span class=name>plugin</span>></span></span><br><span class=line>      <span class=tag><<span class=name>groupId</span>></span>org.apache.tomcat.maven<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>      <span class=tag><<span class=name>artifactId</span>></span>tomcat7-maven-plugin<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>      <span class=tag><<span class=name>configuration</span>></span></span><br><span class=line>        <span class=comment>&LT!-- 指定端口 --></span></span><br><span class=line>        <span class=tag><<span class=name>port</span>></span>8081<span class=tag>&LT/<span class=name>port</span>></span></span><br><span class=line>        <span class=comment>&LT!-- 请求路径 --></span></span><br><span class=line>        <span class=tag><<span class=name>path</span>></span>/<span class=tag>&LT/<span class=name>path</span>></span></span><br><span class=line>      <span class=tag>&LT/<span class=name>configuration</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>plugin</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>plugins</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>build</span>></span></span><br></pre></table></figure><p>（2）配置web.xml文件<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT!DOCTYPE <span class=keyword>web-app</span> <span class=keyword>PUBLIC</span></span></span><br><span class=line><span class=meta> <span class=string>"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span></span><br><span class=line><span class=meta> <span class=string>"http://java.sun.com/dtd/web-app_2_3.dtd"</span> ></span></span><br><span class=line><span class=tag><<span class=name>web-app</span>></span></span><br><span class=line>  <span class=tag><<span class=name>display-name</span>></span>Archetype Created Web Application<span class=tag>&LT/<span class=name>display-name</span>></span></span><br><span class=line>  <span class=tag><<span class=name>context-param</span>></span></span><br><span class=line>    <span class=tag><<span class=name>param-name</span>></span>contextConfigLocation<span class=tag>&LT/<span class=name>param-name</span>></span></span><br><span class=line>    <span class=tag><<span class=name>param-value</span>></span>classpath:applicationContext*.xml<span class=tag>&LT/<span class=name>param-value</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>context-param</span>></span></span><br><span class=line>  <span class=tag><<span class=name>listener</span>></span></span><br><span class=line>    <span class=tag><<span class=name>listener-class</span>></span>org.springframework.web.context.ContextLoaderListener<span class=tag>&LT/<span class=name>listener-class</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>listener</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>web-app</span>></span></span><br><span class=line></span><br></pre></table></figure><p>（3）创建服务接口<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.itheima.service;</span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">HelloService</span> {</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">sayHello</span><span class=params>(String name)</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>（4）创建服务实现类<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.itheima.service.impl;</span><br><span class=line><span class=keyword>import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class=line><span class=keyword>import</span> com.itheima.service.HelloService;</span><br><span class=line></span><br><span class=line><span class=meta>@Service</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">HelloServiceImpl</span> <span class=keyword>implements</span> <span class="title class_">HelloService</span> {</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">sayHello</span><span class=params>(String name)</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"hello "</span> + name;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>注意：服务实现类上使用的Service注解由 Dubbo提供，其作用是对外发布服务。<p>5、在<code>src/main/resources</code>下创建<code>applicationContext-service.xml</code><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>		<span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>	    <span class=attr>xmlns:p</span>=<span class=string>"http://www.springframework.org/schema/p"</span></span></span><br><span class=line><span class=tag>		<span class=attr>xmlns:context</span>=<span class=string>"http://www.springframework.org/schema/context"</span></span></span><br><span class=line><span class=tag>		<span class=attr>xmlns:dubbo</span>=<span class=string>"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class=line><span class=tag>	    <span class=attr>xmlns:mvc</span>=<span class=string>"http://www.springframework.org/schema/mvc"</span></span></span><br><span class=line><span class=tag>		<span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>		http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>         http://www.springframework.org/schema/mvc</span></span></span><br><span class=line><span class=string><span class=tag>         http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class=line><span class=string><span class=tag>         http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class=line><span class=string><span class=tag>         http://code.alibabatech.com/schema/dubbo/dubbo.xsd</span></span></span><br><span class=line><span class=string><span class=tag>         http://www.springframework.org/schema/context</span></span></span><br><span class=line><span class=string><span class=tag>         http://www.springframework.org/schema/context/spring-context.xsd"</span>></span></span><br><span class=line>	<span class=comment>&LT!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --></span></span><br><span class=line>	<span class=tag><<span class=name>dubbo:application</span> <span class=attr>name</span>=<span class=string>"dubbodemo_provider"</span> /></span></span><br><span class=line>	<span class=comment>&LT!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--></span></span><br><span class=line>	<span class=tag><<span class=name>dubbo:registry</span> <span class=attr>address</span>=<span class=string>"zookeeper://192.168.134.129:2181"</span>/></span></span><br><span class=line>	<span class=comment>&LT!-- 注册  协议和port   端口默认是20880 --></span></span><br><span class=line>	<span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"dubbo"</span> <span class=attr>port</span>=<span class=string>"20881"</span>></span><span class=tag>&LT/<span class=name>dubbo:protocol</span>></span></span><br><span class=line>	<span class=comment>&LT!-- 扫描指定包，加入@Service注解的类会被发布为服务  --></span></span><br><span class=line>	<span class=tag><<span class=name>dubbo:annotation</span> <span class=attr>package</span>=<span class=string>"com.itheima.service.impl"</span> /></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure><p>6、启动服务<p>tomcat7:run<h2 id=4-2、服务消费方开发><a class=headerlink href=#4-2、服务消费方开发 title=4.2、服务消费方开发></a>4.2、服务消费方开发</h2><p>开发步骤：<p>（1）创建maven工程（打包方式为war）dubbodemo_consumer，pom.xml配置和上面服务提供者相同，只需要将Tomcat插件的端口号改为8082即可<p>（2）配置web.xml文件<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT!DOCTYPE <span class=keyword>web-app</span> <span class=keyword>PUBLIC</span></span></span><br><span class=line><span class=meta> <span class=string>"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span></span><br><span class=line><span class=meta> <span class=string>"http://java.sun.com/dtd/web-app_2_3.dtd"</span> ></span></span><br><span class=line><span class=tag><<span class=name>web-app</span>></span></span><br><span class=line>  <span class=tag><<span class=name>display-name</span>></span>Archetype Created Web Application<span class=tag>&LT/<span class=name>display-name</span>></span></span><br><span class=line>  <span class=tag><<span class=name>servlet</span>></span></span><br><span class=line>    <span class=tag><<span class=name>servlet-name</span>></span>springmvc<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>    <span class=tag><<span class=name>servlet-class</span>></span>org.springframework.web.servlet.DispatcherServlet<span class=tag>&LT/<span class=name>servlet-class</span>></span></span><br><span class=line>    <span class=comment>&LT!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载 --></span></span><br><span class=line>    <span class=tag><<span class=name>init-param</span>></span></span><br><span class=line>      <span class=tag><<span class=name>param-name</span>></span>contextConfigLocation<span class=tag>&LT/<span class=name>param-name</span>></span></span><br><span class=line>      <span class=tag><<span class=name>param-value</span>></span>classpath:applicationContext-web.xml<span class=tag>&LT/<span class=name>param-value</span>></span></span><br><span class=line>    <span class=tag>&LT/<span class=name>init-param</span>></span></span><br><span class=line>    <span class=tag><<span class=name>load-on-startup</span>></span>1<span class=tag>&LT/<span class=name>load-on-startup</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>servlet</span>></span></span><br><span class=line>  <span class=tag><<span class=name>servlet-mapping</span>></span></span><br><span class=line>    <span class=tag><<span class=name>servlet-name</span>></span>springmvc<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>    <span class=tag><<span class=name>url-pattern</span>></span>*.do<span class=tag>&LT/<span class=name>url-pattern</span>></span></span><br><span class=line>  <span class=tag>&LT/<span class=name>servlet-mapping</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>web-app</span>></span></span><br></pre></table></figure><p>（3）将服务提供者工程中的HelloService接口复制到当前工程<p>4、编写Controller<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.itheima.controller;</span><br><span class=line><span class=keyword>import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class=line><span class=keyword>import</span> com.itheima.service.HelloService;</span><br><span class=line><span class=keyword>import</span> org.springframework.stereotype.Controller;</span><br><span class=line><span class=keyword>import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=line><span class=keyword>import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class=line></span><br><span class=line><span class=meta>@Controller</span></span><br><span class=line><span class=meta>@RequestMapping("/demo")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">HelloController</span> {</span><br><span class=line>    <span class=meta>@Reference</span></span><br><span class=line>    <span class=keyword>private</span> HelloService helloService;</span><br><span class=line></span><br><span class=line>    <span class=meta>@RequestMapping("/hello")</span></span><br><span class=line>    <span class=meta>@ResponseBody</span></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getName</span><span class=params>(String name)</span>{</span><br><span class=line>        <span class=comment>//远程调用</span></span><br><span class=line>        <span class=type>String</span> <span class=variable>result</span> <span class=operator>=</span> helloService.sayHello(name);</span><br><span class=line>        System.out.println(result);</span><br><span class=line>        <span class=keyword>return</span> result;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>注意：Controller中注入HelloService使用的是Dubbo提供的@Reference注解<p>（5）在src/main/resources下创建applicationContext-web.xml<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=meta>&LT?xml version=<span class=string>"1.0"</span> encoding=<span class=string>"UTF-8"</span>?></span></span><br><span class=line><span class=tag><<span class=name>beans</span> <span class=attr>xmlns</span>=<span class=string>"http://www.springframework.org/schema/beans"</span></span></span><br><span class=line><span class=tag>	<span class=attr>xmlns:xsi</span>=<span class=string>"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class=line><span class=tag>	<span class=attr>xmlns:p</span>=<span class=string>"http://www.springframework.org/schema/p"</span></span></span><br><span class=line><span class=tag>	<span class=attr>xmlns:context</span>=<span class=string>"http://www.springframework.org/schema/context"</span></span></span><br><span class=line><span class=tag>	<span class=attr>xmlns:dubbo</span>=<span class=string>"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class=line><span class=tag>	<span class=attr>xmlns:mvc</span>=<span class=string>"http://www.springframework.org/schema/mvc"</span></span></span><br><span class=line><span class=tag>	<span class=attr>xsi:schemaLocation</span>=<span class=string>"http://www.springframework.org/schema/beans</span></span></span><br><span class=line><span class=string><span class=tag>			http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class=line><span class=string><span class=tag>			http://www.springframework.org/schema/mvc</span></span></span><br><span class=line><span class=string><span class=tag>			http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class=line><span class=string><span class=tag>			http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class=line><span class=string><span class=tag>			http://code.alibabatech.com/schema/dubbo/dubbo.xsd</span></span></span><br><span class=line><span class=string><span class=tag>			http://www.springframework.org/schema/context</span></span></span><br><span class=line><span class=string><span class=tag>			http://www.springframework.org/schema/context/spring-context.xsd"</span>></span></span><br><span class=line></span><br><span class=line>	<span class=comment>&LT!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --></span></span><br><span class=line>	<span class=tag><<span class=name>dubbo:application</span> <span class=attr>name</span>=<span class=string>"dubbodemo-consumer"</span> /></span></span><br><span class=line>	<span class=comment>&LT!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--></span></span><br><span class=line>	<span class=tag><<span class=name>dubbo:registry</span> <span class=attr>address</span>=<span class=string>"zookeeper://192.168.134.129:2181"</span>/></span></span><br><span class=line>	<span class=comment>&LT!-- 扫描的方式暴露接口  --></span></span><br><span class=line>	<span class=tag><<span class=name>dubbo:annotation</span> <span class=attr>package</span>=<span class=string>"com.itheima.controller"</span> /></span></span><br><span class=line><span class=tag>&LT/<span class=name>beans</span>></span></span><br></pre></table></figure><p>（6）运行测试<p><code>tomcat7:run</code>启动<p>在浏览器输入<code>http://localhost:8082/demo/hello.do?name=Jack</code>，查看浏览器输出结果。<blockquote><p><strong>思考一：</strong>上面的Dubbo入门案例中我们是将HelloService接口从服务提供者工程(dubbodemo_provider)复制到服务消费者工程(dubbodemo_consumer)中，这种做法是否合适？还有没有更好的方式？<p><strong>答：</strong>这种做法显然是不好的，同一个接口被复制了两份，不利于后期维护。更好的方式是单独创建一个maven工程，将此接口创建在这个maven工程中。需要依赖此接口的工程只需要在自己工程的pom.xml文件中引入maven坐标即可。<p><strong>思考二：</strong>在服务消费者工程(dubbodemo_consumer)中只是引用了HelloService接口，并没有提供实现类，Dubbo是如何做到远程调用的？<p><strong>答：</strong>Dubbo底层是基于代理技术为HelloService接口创建代理对象，远程调用是通过此代理对象完成的。可以通过开发工具的debug功能查看此代理对象的内部结构。另外，Dubbo实现网络传输底层是基于Netty框架完成的。<p><strong>思考三：</strong>上面的Dubbo入门案例中我们使用Zookeeper作为服务注册中心，服务提供者需要将自己的服务信息注册到Zookeeper，服务消费者需要从Zookeeper订阅自己所需要的服务，此时Zookeeper服务就变得非常重要了，那如何防止Zookeeper单点故障呢？<p><strong>答：</strong>Zookeeper其实是支持集群模式的，可以配置Zookeeper集群来达到Zookeeper服务的高可用，防止出现单点故障。</blockquote><h1 id=5、Dubbo管理控制台><a class=headerlink href=#5、Dubbo管理控制台 title=5、Dubbo管理控制台></a>5、Dubbo管理控制台</h1><p>Zookeeper注册中心中注册了哪些服务提供者和消费者，可以通过一个管理中心来进行管理。该管理中心是一个springboot项目，直接启动即可。<h2 id=5-1、安装><a class=headerlink href=#5-1、安装 title=5.1、安装></a>5.1、安装</h2><p>安装步骤：<ol><li><p>将资料中的dubbo-admin-2.6.0.war文件复制到tomcat的webapps目录下</p><li><p>启动tomcat，此war文件会自动解压</p><li><p>修改WEB-INF下的dubbo.properties文件，注意dubbo.registry.address对应的值需要对应当前使用的Zookeeper的ip地址和端口号</p> <figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line><span class=attr>dubbo.registry.address</span>=<span class=string>zookeeper://192.168.134.129:2181</span></span><br><span class=line><span class=attr>dubbo.admin.root.password</span>=<span class=string>root</span></span><br><span class=line><span class=attr>dubbo.admin.guest.password</span>=<span class=string>guest</span></span><br></pre></table></figure><li><p>重启tomcat</p></ol><h2 id=5-2、使用><a class=headerlink href=#5-2、使用 title=5.2、使用></a>5.2、使用</h2><p>操作步骤：<ol><li>访问<code>http://localhost:8080/dubbo-admin-2.6.0/</code>，输入用户名(<code>root</code>)和密码(<code>root</code>)。<li>启动服务提供者工程和服务消费者工程，可以在查看到对应的信息。</ol><h1 id=6、Dubbo相关配置><a class=headerlink href=#6、Dubbo相关配置 title=6、Dubbo相关配置></a>6、Dubbo相关配置</h1><h2 id=6-1、包扫描><a class=headerlink href=#6-1、包扫描 title=6.1、包扫描></a>6.1、包扫描</h2><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:annotation</span> <span class=attr>package</span>=<span class=string>"com.itheima.service"</span> /></span></span><br></pre></table></figure><p>服务提供者和服务消费者都需要配置，表示包扫描，作用是扫描指定包(包括子包)下的类。<p>如果不使用包扫描，也可以通过如下配置的方式来发布服务：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>bean</span> <span class=attr>id</span>=<span class=string>"helloService"</span> <span class=attr>class</span>=<span class=string>"com.itheima.service.impl.HelloServiceImpl"</span> /></span></span><br><span class=line><span class=tag><<span class=name>dubbo:service</span> <span class=attr>interface</span>=<span class=string>"com.itheima.api.HelloService"</span> <span class=attr>ref</span>=<span class=string>"helloService"</span> /></span></span><br></pre></table></figure><p>作为服务消费者，可以通过如下配置来引用服务：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- 生成远程服务代理，可以和本地bean一样使用helloService --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"helloService"</span> <span class=attr>interface</span>=<span class=string>"com.itheima.api.HelloService"</span> /></span></span><br></pre></table></figure><p>上面这种方式发布和引用服务，一个配置项(<a href=dubbo:service>dubbo:service</a>、<a href=dubbo:reference>dubbo:reference</a>)只能发布或者引用一个服务，如果有多个服务，这种方式就比较繁琐了。推荐使用包扫描方式。<h2 id=6-2、协议><a class=headerlink href=#6-2、协议 title=6.2、协议></a>6.2、协议</h2><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"dubbo"</span> <span class=attr>port</span>=<span class=string>"20880"</span>/></span></span><br></pre></table></figure><p>一般在服务提供者一方配置，可以指定使用的协议名称和端口号。<p>其中Dubbo支持的协议有：dubbo、rmi、hessian、http、webservice、rest、redis等。<p>推荐使用的是dubbo协议。<p>dubbo 协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。<p>也可以在同一个工程中配置多个协议，不同服务可以使用不同的协议，例如：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- 多协议配置 --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"dubbo"</span> <span class=attr>port</span>=<span class=string>"20880"</span> /></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"rmi"</span> <span class=attr>port</span>=<span class=string>"1099"</span> /></span></span><br><span class=line><span class=comment>&LT!-- 使用dubbo协议暴露服务 --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:service</span> <span class=attr>interface</span>=<span class=string>"com.itheima.api.HelloService"</span> <span class=attr>ref</span>=<span class=string>"helloService"</span> <span class=attr>protocol</span>=<span class=string>"dubbo"</span> /></span></span><br><span class=line><span class=comment>&LT!-- 使用rmi协议暴露服务 --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:service</span> <span class=attr>interface</span>=<span class=string>"com.itheima.api.DemoService"</span> <span class=attr>ref</span>=<span class=string>"demoService"</span> <span class=attr>protocol</span>=<span class=string>"rmi"</span> /></span> </span><br></pre></table></figure><h2 id=6-3、启动时检查><a class=headerlink href=#6-3、启动时检查 title=6.3、启动时检查></a>6.3、启动时检查</h2><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:consumer</span> <span class=attr>check</span>=<span class=string>"false"</span>/></span></span><br></pre></table></figure><p>上面这个配置需要配置在服务消费者一方，如果不配置默认check值为true。Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题。可以通过将check值改为false来关闭检查。<p>建议在开发阶段将check值设置为false，在生产环境下改为true。<h2 id=6-4、负载均衡><a class=headerlink href=#6-4、负载均衡 title=6.4、负载均衡></a>6.4、负载均衡</h2><p>负载均衡（Load Balance）就是<strong>将请求分摊到多个操作单元上进行执行，从而共同完成工作任务</strong>。<p>Dubbo 提供了多种均衡策略（随机、轮询、最少活跃调用数、一致性Hash等），缺省为random随机调用。<p>配置负载均衡策略，既可以在服务提供者一方配置，也可以在服务消费者一方配置，如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre><td class=code><pre><span class=line><span class=meta>@Controller</span></span><br><span class=line><span class=meta>@RequestMapping("/demo")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">HelloController</span> {</span><br><span class=line>    <span class=comment>//在服务消费者一方配置负载均衡策略</span></span><br><span class=line>    <span class=meta>@Reference(check = false,loadbalance = "random")</span></span><br><span class=line>    <span class=keyword>private</span> HelloService helloService;</span><br><span class=line></span><br><span class=line>    <span class=meta>@RequestMapping("/hello")</span></span><br><span class=line>    <span class=meta>@ResponseBody</span></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">getName</span><span class=params>(String name)</span>{</span><br><span class=line>        <span class=comment>//远程调用</span></span><br><span class=line>        <span class=type>String</span> <span class=variable>result</span> <span class=operator>=</span> helloService.sayHello(name);</span><br><span class=line>        System.out.println(result);</span><br><span class=line>        <span class=keyword>return</span> result;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=comment>//在服务提供者一方配置负载均衡</span></span><br><span class=line><span class=meta>@Service(loadbalance = "random")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">HelloServiceImpl</span> <span class=keyword>implements</span> <span class="title class_">HelloService</span> {</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">sayHello</span><span class=params>(String name)</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"hello "</span> + name;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>可以通过启动多个服务提供者来观察Dubbo负载均衡效果。<p>注意：因为我们是在一台机器上启动多个服务提供者，所以需要修改tomcat的端口号和Dubbo服务的端口号来防止端口冲突。<p>在实际生产环境中，多个服务提供者分别部署在不同的机器上，所以不存在端口冲突问题。</div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Apache%20Dubbo%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Apache%20Dubbo%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/ itemprop=url>Dubbo系列-Dubbo原理解析</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 15:10:28" datetime=2023-10-02T15:10:28+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Dubbo/ itemprop=url rel=index><span itemprop=name>Dubbo</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、Dubbo底层架构><a class=headerlink href=#1、Dubbo底层架构 title=1、Dubbo底层架构></a>1、Dubbo底层架构</h1><h2 id=1-1、官方解释><a class=headerlink href=#1-1、官方解释 title=1.1、官方解释></a>1.1、官方解释</h2><p>Dubbo官方架构图如下：<p><img alt=image-20210523002015383 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20210523002015383.png><p>节点角色说明：<table><thead><tr><th>节点<th>角色名称<tbody><tr><td>Provider<td>服务提供方<tr><td>Consumer<td>服务消费方<tr><td>Registry<td>注册中心<tr><td>Monitor<td>监控中心（统计服务调用次数和调用时间）<tr><td>Container<td>服务运行容器</table><blockquote><p>1、虚线表示异步访问，实线表示同步访问。<br>2、蓝色虚线表示在启动时完成的功能。<br>3、红色虚线(实线)都表示程序运行过程中执行的功能。</blockquote><p>调用关系说明：<ol start=0><li>服务容器负责启动，加载，运行服务提供者。<li>服务提供者在启动时，向注册中心注册自己。<li>服务消费者在启动时，向注册中心订阅自己所需的服务。<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于【长连接】推送变更数据给消费者。<li>服务消费者基于【软负载均衡算法】从服务提供者地址列表中挑选一个来调用，如果调用失败，则再选另一个。<li>服务消费者和提供者在内存中的【累计调用次数和调用时间】等统计数据会被定时每分钟发送一次到监控中心。</ol><h2 id=1-2、调用流程><a class=headerlink href=#1-2、调用流程 title=1.2、调用流程></a>1.2、调用流程</h2><p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/dubbo%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE01.jpg><p>对照上面的整体架构图可以大致分为以下步骤：<ol><li>服务提供者启动，开启Netty服务，创建Zookeeper客户端，向注册中心注册服务。<li>服务消费者启动，通过Zookeeper注册中心获取服务提供者列表，并与服务提供者通过Netty建立长连接。<li>服务消费者通过接口调用远程服务，ProxyFactory通过初始化Proxy对象，Proxy通过创建动态代理对象。<li>动态代理对象通过invoke方法，层层包装生成一个Invoker对象，该对象包含了代理对象。<li>Invoker通过路由，负载均衡选择了一个最合适的服务提供者，在通过加入各种过滤器，协议层包装生成一个新的DubboInvoker对象。<li>再通过交换将DubboInvoker对象包装成一个Reuqest对象，该对象被序列化后通过NettyClient传输到服务提供者的NettyServer端。<li>到了服务提供者这边，再通过反序列化、协议解密等操作生成一个DubboExporter对象，再经过层层传递处理后会生成一个服务提供端的Invoker对象。<li>这个Invoker对象会调用本地服务，获得结果后再通过层层回调返回至服务消费者，服务消费者拿到结果后，再解析获得最终结果。</ol><h1 id=2、Dubbo协议><a class=headerlink href=#2、Dubbo协议 title=2、Dubbo协议></a>2、Dubbo协议</h1><p>dubbo支持的协议如下：<ol><li>dubbo 协议 (默认)（单-长-T-N异-H）<li>rmi 协议（多-短-T-同-J）<li>hessian 协议（多-短-H-同-表）<li>http 协议（多-短-H-同-表）<li>WebService 协议（多-短-H-同-SOAP）<li>thrift 协议（）<li>memcached 协议<li>redis 协议</ol><h2 id=2-1、dubbo协议><a class=headerlink href=#2-1、dubbo协议 title=2.1、dubbo协议></a>2.1、dubbo协议</h2><h3 id=特点><a class=headerlink href=#特点 title=特点></a>特点</h3><p>缺省协议，使用基于mina1.1.7+hessian3.2.1的tbremoting交互。<ul><li>连接个数：<strong>单连接</strong><li>连接方式：<strong>长连接</strong><li>传输协议：<strong>TCP</strong><li>传输方式：NIO异步传输<li>序列化：<strong>Hessian 二进制序列化</strong><li>适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者数量多，单一消费者无法压满提供者，尽量不要用dubbo协议传输大文件或超大字符串。<li>适用场景：常规远程服务方法调用</ul><h3 id=总结><a class=headerlink href=#总结 title=总结></a>总结</h3><ol><li><p>dubbo默认采用dubbo协议，dubbo协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。</p><li><p>他不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"dubbo"</span> <span class=attr>port</span>=<span class=string>"20880"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Set default protocol: --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:provider</span> <span class=attr>protocol</span>=<span class=string>"dubbo"</span> /></span></span><br><span class=line><~-- Set service protocol --></span><br><span class=line><span class=tag><<span class=name>dubbo:service</span> <span class=attr>protocol</span>=<span class=string>"dubbo"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Multi port --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>id</span>=<span class=string>"dubbo1"</span> <span class=attr>name</span>=<span class=string>"dubbo"</span> <span class=attr>port</span>=<span class=string>"20880"</span> /></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>id</span>=<span class=string>"dubbo2"</span> <span class=attr>name</span>=<span class=string>"dubbo"</span> <span class=attr>port</span>=<span class=string>"20881"</span> /></span>.</span><br><span class=line><span class=comment>&LT!-- Dubbo protocol options: --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"dubbo"</span> <span class=attr>port</span>=<span class=string>"9090"</span> <span class=attr>server</span>=<span class=string>"netty"</span> <span class=attr>client</span>=<span class=string>"netty"</span> <span class=attr>codec</span>=<span class=string>“dubbo”</span> </span></span><br><span class=line><span class=tag><span class=attr>serialization</span>=<span class=string>“hessian2”</span> <span class=attr>charset</span>=<span class=string>“UTF-8”</span> <span class=attr>threadpool</span>=<span class=string>“fixed”</span> <span class=attr>threads</span>=<span class=string>“100”</span> <span class=attr>queues</span>=<span class=string>“0”</span> <span class=attr>iothreads</span>=<span class=string>“9”</span> </span></span><br><span class=line><span class=tag><span class=attr>buffer</span>=<span class=string>“8192”</span> <span class=attr>accepts</span>=<span class=string>“1000”</span> <span class=attr>payload</span>=<span class=string>“8388608”</span> /></span></span><br></pre></table></figure><li><p>Dubbo协议缺省每服务每提供者每消费者使用单一长连接，如果数据量较大，可以使用多个连接。</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"dubbo"</span> <span class=attr>connections</span>=<span class=string>"2"</span>/></span></span><br><span class=line></span><br><span class=line><span class=comment>&LT!-- 表示该服务使用JVM共享长连接。(缺省)  --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:service</span> <span class=attr>connections</span>=<span class=string>”0”</span>></span>或<span class=tag><<span class=name>dubbo:reference</span> <span class=attr>connections</span>=<span class=string>”0”</span>></span></span><br><span class=line><span class=comment>&LT!-- 表示该服务使用独立长连接。  --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:service</span> <span class=attr>connections</span>=<span class=string>”1”</span>></span>或<span class=tag><<span class=name>dubbo:reference</span> <span class=attr>connections</span>=<span class=string>”1”</span>></span></span><br><span class=line><span class=comment>&LT!-- 表示该服务使用独立两条长连接 --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:service</span> <span class=attr>connections</span>=<span class=string>”2”</span>></span>或<span class=tag><<span class=name>dubbo:reference</span> <span class=attr>connections</span>=<span class=string>”2”</span>></span></span><br></pre></table></figure><li><p>为防止被大量连接压死，可在服务提供方限制最大连接数，以实现服务提供方自我保护。</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"dubbo"</span> <span class=attr>accepts</span>=<span class=string>"1000"</span> /></span></span><br></pre></table></figure></ol><blockquote><p>**为什么消费者比提供者数量多？ **<br>因dubbo协议采用单一长连接，假设网络为千兆网卡(1024Mbit=128MByte)，根据测试经验数据每条连接最多只能压满7MByte(不同的环境可能不一样，供参考)，理论上1个服务提供者需要20个服务消费者才能压满网卡<p><strong>为什么不能传大包？</strong><br>因dubbo协议采用单一长连接，如果每次请求的数据包大小为500KByte，假设网络为千兆网卡(1024Mbit=128MByte)，每条连接最大7MByte(不同的环境可能不一样，供参考)，单个服务提供者的TPS(每秒处理事务数)最大为：128MByte / 500KByte = 262。单个消费者调用单个服务提供者的TPS(每秒处理事务数)最大为：7MByte / 500KByte = 14。如果能接受，可以考虑使用，否则网络将成为瓶颈。<p><strong>为什么采用异步单一长连接？</strong><br>因为服务的现状大都是服务提供者少，通常只有几台机器，而服务的消费者多，可能整个网站都在访问该服务。比如Morgan的提供者只有6个，但却有上百个消费者，每天1.5亿次调用，如果采用常规的hessian服务，服务提供者很容易就被压跨，通过单一连接，保证单一消费者不会压死提供者，长连接，减少连接握手验证等，并使用异步IO，复用线程池，防止C10K问题。<p>接口增加方法，对客户端无影响，如果该方法不是客户端需要的，客户端不需要重新部署； 输入参数和结果集中增加属性，对客户端无影响，如果客户端并不需要新属性，不用重新部署；<p>输入参数和结果集属性名变化，对客户端序列化无影响，但是如果客户端不重新部署，不管输入还是输出，属性名变化的属性值是获取不到的。<p>总结：服务器端 和 客户端 对 领域对象 来说并不要求必须完全一致，而是按照最大匹配原则。<p>如果不集成Spring，单独配置如：<code>dubbo.service.protocol=dubbo</code></blockquote><h2 id=2-2、rmi协议><a class=headerlink href=#2-2、rmi协议 title=2.2、rmi协议></a>2.2、rmi协议</h2><h3 id=特点-1><a class=headerlink href=#特点-1 title=特点></a>特点</h3><p>Java标准的远程调用协议。<ul><li>连接个数：多连接<li>连接方式：短连接<li>传输协议：TCP<li>传输方式：同步传输<li>序列化：Java标准二进制序列化<li>适用范围：传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。<li>适用场景：常规远程服务方法调用，与原生RMI服务互操作</ul><h3 id=总结-1><a class=headerlink href=#总结-1 title=总结></a>总结</h3><p>RMI协议采用JDK标准的<code>java.rmi.*</code>实现，采用阻塞式短连接和JDK标准序列化方式<br>注： 如果正在使用RMI提供服务给外部访问（公司内网环境应该不会有攻击风险），同时应用里依赖了老的common-collections包（dubbo不会依赖这个包，请排查自己的应用有没有使用）的情况下，存在反序列化安全风险。 请检查应用：<ol><li>将commons-collections3 请升级到3.2.2版本：<br><a href=https://commons.apache.org/proper/commons-collections/release_3_2_2.html rel=noopener target=_blank>https://commons.apache.org/proper/commons-collections/release_3_2_2.html</a><li>将commons-collections4 请升级到4.1版本：<a href=https://commons.apache.org/proper/commons-collections/release_4_1.html rel=noopener target=_blank>https://commons.apache.org/proper/commons-collections/release_4_1.html</a><br>新版本的commons-collections解决了该问题</ol><p>如果服务接口继承了<code>java.rmi.Remote</code>接口，可以和原生RMI互操作，即： 提供者用Dubbo的RMI协议暴露服务，消费者直接用标准RMI接口调用，或者提供方用标准RMI暴露服务，消费方用Dubbo的RMI协议调用。<p>如果服务接口没有继承<code>java.rmi.Remote</code>接口，缺省Dubbo将自动生成一个com.xxx.XxxService$Remote的接口，并继承<code>java.rmi.Remote</code>接口，并以此接口暴露服务，<p>但如果设置了<code>&LTdubbo:protocol name="rmi" codec="spring" /></code>，将不生成$Remote接口，而使用Spring的<code>RmiInvocationHandler</code>接口暴露服务，和Spring兼容。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- Define rmi protocol --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"rmi"</span> <span class=attr>port</span>=<span class=string>"1099"</span> /></span>.</span><br><span class=line><span class=comment>&LT!-- Set default protocol: --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:provider</span> <span class=attr>protocol</span>=<span class=string>"rmi"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Set service protocol: --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:service</span> <span class=attr>protocol</span>=<span class=string>"rmi"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Multi port --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>id</span>=<span class=string>"rmi1"</span> <span class=attr>name</span>=<span class=string>"rmi"</span> <span class=attr>port</span>=<span class=string>"1099"</span> /></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>id</span>=<span class=string>"rmi2"</span> <span class=attr>name</span>=<span class=string>"rmi"</span> <span class=attr>port</span>=<span class=string>"2099"</span> /></span></span><br><span class=line><span class=tag><<span class=name>dubbo:service</span> <span class=attr>protocol</span>=<span class=string>"rmi1"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Spring compatible: --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"rmi"</span> <span class=attr>codec</span>=<span class=string>"spring"</span> /></span></span><br></pre></table></figure><h2 id=2-3、hessian协议><a class=headerlink href=#2-3、hessian协议 title=2.3、hessian协议></a>2.3、hessian协议</h2><h3 id=特点-2><a class=headerlink href=#特点-2 title=特点></a>特点</h3><p>基于Hessian的远程调用协议。Hessian 协议用于集成 Hessian 服务，Hessian 底层采用 Http 通讯，采用Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器并实现基于 Hessian 的远程调用协议。<ul><li>连接个数：多连接<li>连接方式：短连接<li>传输协议：HTTP<li>传输方式：同步传输<li>序列化：表单序列化<li>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。<li>适用场景：需同时给应用程序和浏览器JS使用的服务。</ul><h3 id=总结-2><a class=headerlink href=#总结-2 title=总结></a>总结</h3><ol><li><p>Hessian协议用于集成Hessian服务，Hessian底层通过Http通讯，通过Servlet暴露服务，Dubbo缺省内嵌Jetty服务器实现。</p><li><p>Hessian是Caucho开源的一个RPC框架：<a href=http://hessian.caucho.com,其通讯效率高于webservice和java自带的序列化./ rel=noopener target=_blank>http://hessian.caucho.com，其通讯效率高于WebService和Java自带的序列化。</a> 需要的依赖：</p></ol><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>com.caucho<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>hessian<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>4.0.7<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><p>可以和原生Hessian服务互操作，即： 提供者用Dubbo的Hessian协议暴露服务，消费者直接用标准Hessian接口调用，或者提供方用标准Hessian暴露服务，消费方用Dubbo的Hessian协议调用。<p>约束<ol><li><p>参数及返回值需实现Serializable接口。</p><li><p>参数及返回值不能自定义实现List、Map、Number、Date、Calendar等接口，只能用JDK自带的实现，因为hessian会做特殊处理，自定义实现类中的属性值都会丢失。</p> <figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- Define hessian protocol: --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"hessian"</span> <span class=attr>port</span>=<span class=string>"8080"</span> <span class=attr>server</span>=<span class=string>"jetty"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Set default protocol: --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:provider</span> <span class=attr>protocol</span>=<span class=string>"hessian"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Set service protocol: --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:service</span> <span class=attr>protocol</span>=<span class=string>"hessian"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Multi port: --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>id</span>=<span class=string>"hessian1"</span> <span class=attr>name</span>=<span class=string>"hessian"</span> <span class=attr>port</span>=<span class=string>"8080"</span> /></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>id</span>=<span class=string>"hessian2"</span> <span class=attr>name</span>=<span class=string>"hessian"</span> <span class=attr>port</span>=<span class=string>"8081"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Directly provider: --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"helloService"</span> <span class=attr>interface</span>=<span class=string>"HelloWorld"</span> <span class=attr>url</span>=<span class=string>"hessian://10.20.153.10:8080/helloWorld"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Jetty Server --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>...</span> <span class=attr>server</span>=<span class=string>"jetty"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Servlet Bridge Server --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>...</span> <span class=attr>server</span>=<span class=string>"servlet"</span> /></span></span><br></pre></table></figure></ol><p>web.xml配置:<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>servlet</span>></span></span><br><span class=line>     <span class=tag><<span class=name>servlet-name</span>></span>dubbo<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>     <span class=tag><<span class=name>servlet-class</span>></span>com.alibaba.dubbo.remoting.http.servlet.DispatcherServlet<span class=tag>&LT/<span class=name>servlet-class</span>></span></span><br><span class=line>     <span class=tag><<span class=name>load-on-startup</span>></span>1<span class=tag>&LT/<span class=name>load-on-startup</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet</span>></span></span><br><span class=line><span class=tag><<span class=name>servlet-mapping</span>></span></span><br><span class=line>     <span class=tag><<span class=name>servlet-name</span>></span>dubbo<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>     <span class=tag><<span class=name>url-pattern</span>></span>/*<span class=tag>&LT/<span class=name>url-pattern</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet-mapping</span>></span></span><br></pre></table></figure><p><font color=red>注意：使用servlet派发请求协议的端口必须与servlet容器的端口相同， 协议的上下文路径必须与servlet应用的上下文路径相同。</font><h2 id=2-4、http协议><a class=headerlink href=#2-4、http协议 title=2.4、http协议></a>2.4、http协议</h2><h3 id=特点-3><a class=headerlink href=#特点-3 title=特点></a>特点</h3><p>基于http表单的远程调用协议。<ul><li>连接个数：多连接<li>连接方式：短连接<li>传输协议：HTTP<li>传输方式：同步传输<li>序列化：表单序列化<li>适用范围：传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。<li>适用场景：需同时给应用程序和浏览器JS使用的服务。</ul><h3 id=总结-3><a class=headerlink href=#总结-3 title=总结></a>总结</h3><p>采用Spring的 HttpInvoker 实现配置：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"http"</span> <span class=attr>port</span>=<span class=string>"8080"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Jetty Server --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>...</span> <span class=attr>server</span>=<span class=string>"jetty"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Servlet Bridge Server --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>...</span> <span class=attr>server</span>=<span class=string>"servlet"</span> /></span></span><br></pre></table></figure><p>web.xml配置：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>servlet</span>></span></span><br><span class=line>     <span class=tag><<span class=name>servlet-name</span>></span>dubbo<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>     <span class=tag><<span class=name>servlet-class</span>></span>com.alibaba.dubbo.remoting.http.servlet.DispatcherServlet<span class=tag>&LT/<span class=name>servlet-class</span>></span></span><br><span class=line>     <span class=tag><<span class=name>load-on-startup</span>></span>1<span class=tag>&LT/<span class=name>load-on-startup</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet</span>></span></span><br><span class=line><span class=tag><<span class=name>servlet-mapping</span>></span></span><br><span class=line>     <span class=tag><<span class=name>servlet-name</span>></span>dubbo<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>     <span class=tag><<span class=name>url-pattern</span>></span>/*<span class=tag>&LT/<span class=name>url-pattern</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet-mapping</span>></span></span><br></pre></table></figure><p><font color=red>注意：如果使用 servlet 派发请求 协议的端口<code>&LTdubbo:protocol port="8080" /></code>必须与servlet容器的端口相同， 协议的上下文路径<code>&LTdubbo:protocol contextpath="foo" /></code>必须与servlet应用的上下文路径相同。</font><h2 id=2-5、webservice协议><a class=headerlink href=#2-5、webservice协议 title=2.5、webservice协议></a>2.5、webservice协议</h2><h3 id=特点-4><a class=headerlink href=#特点-4 title=特点></a>特点</h3><p>基于WebService的远程调用协议<ul><li>连接个数：多连接<li>连接方式：短连接<<li>传输协议：HTTP<li>传输方式：同步传输<li>序列化：SOAP文本序列化<li>适用场景：系统集成，跨语言调用</ul><h3 id=总结-4><a class=headerlink href=#总结-4 title=总结></a>总结</h3><ol><li>基于CXF的 frontend-simple 和 transports-http 实现。<li>CXF是Apache开源的一个RPC框架：<a href=http://cxf.apache.org,由xfire和celtix合并而来/ rel=noopener target=_blank>http://cxf.apache.org，由Xfire和Celtix合并而来</a> 。</ol><p>依赖如下：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.apache.cxf<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>cxf-rt-frontend-simple<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>2.6.1<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.apache.cxf<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>cxf-rt-transports-http<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>2.6.1<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><p>可以和原生WebService服务互操作，即： 提供者用Dubbo的WebService协议暴露服务，消费者直接用标准WebService接口调用，或者提供方用标准WebService暴露服务，消费方用Dubbo的WebService协议调用。<p>约束：<ol><li>参数及返回值需实现Serializable接口。<li>参数尽量使用基本类型和POJO。</ol><figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- Define webservice protocol --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"webservice"</span> <span class=attr>port</span>=<span class=string>"8080"</span> <span class=attr>server</span>=<span class=string>"jetty"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Set default protocol --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:provider</span> <span class=attr>protocol</span>=<span class=string>"webservice"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Set service protocol --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:service</span> <span class=attr>protocol</span>=<span class=string>"webservice"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Multi port --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>id</span>=<span class=string>"webservice1"</span> <span class=attr>name</span>=<span class=string>"webservice"</span> <span class=attr>port</span>=<span class=string>"8080"</span> /></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>id</span>=<span class=string>"webservice2"</span> <span class=attr>name</span>=<span class=string>"webservice"</span> <span class=attr>port</span>=<span class=string>"8081"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Directly provider --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"helloService"</span> <span class=attr>interface</span>=<span class=string>"HelloWorld"</span> <span class=attr>url</span>=<span class=string>"webservice://10.20.153.10:8080/com.foo.HelloWorld"</span> /></span></span><br><span class=line><span class=comment>&LT!-- WSDL --></span></span><br><span class=line>http://10.20.153.10:8080/com.foo.HelloWorld?wsdl</span><br><span class=line><span class=comment>&LT!-- Jetty Server: (default) --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>...</span> <span class=attr>server</span>=<span class=string>"jetty"</span> /></span></span><br><span class=line><span class=comment>&LT!-- Servlet Bridge Server: (recommend) --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>...</span> <span class=attr>server</span>=<span class=string>"servlet"</span> /></span></span><br></pre></table></figure><p>web.xml：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>servlet</span>></span></span><br><span class=line>     <span class=tag><<span class=name>servlet-name</span>></span>dubbo<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>     <span class=tag><<span class=name>servlet-class</span>></span>com.alibaba.dubbo.remoting.http.servlet.DispatcherServlet<span class=tag>&LT/<span class=name>servlet-class</span>></span></span><br><span class=line>     <span class=tag><<span class=name>load-on-startup</span>></span>1<span class=tag>&LT/<span class=name>load-on-startup</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet</span>></span></span><br><span class=line><span class=tag><<span class=name>servlet-mapping</span>></span></span><br><span class=line>     <span class=tag><<span class=name>servlet-name</span>></span>dubbo<span class=tag>&LT/<span class=name>servlet-name</span>></span></span><br><span class=line>     <span class=tag><<span class=name>url-pattern</span>></span>/*<span class=tag>&LT/<span class=name>url-pattern</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>servlet-mapping</span>></span></span><br></pre></table></figure><p>注意:如果使用servlet派发请求： 协议的端口必须与servlet容器的端口相同，协议的上下文路径必须与servlet应用的上下文路径相同。<h2 id=2-6、thrift协议><a class=headerlink href=#2-6、thrift协议 title=2.6、thrift协议></a>2.6、thrift协议</h2><p><strong>当前 dubbo 支持的 thrift 协议是对 thrift 原生协议的扩展，在原生协议的基础上添加了一些额外的头信息，比如service name，magic number等。</strong>使用dubbo thrift协议同样需要使用thrift的idl compiler编译生成相应的java代码，后续版本中会在这方面做一些增强。<p>依赖：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dependency</span>></span></span><br><span class=line>    <span class=tag><<span class=name>groupId</span>></span>org.apache.thrift<span class=tag>&LT/<span class=name>groupId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>artifactId</span>></span>libthrift<span class=tag>&LT/<span class=name>artifactId</span>></span></span><br><span class=line>    <span class=tag><<span class=name>version</span>></span>0.8.0<span class=tag>&LT/<span class=name>version</span>></span></span><br><span class=line><span class=tag>&LT/<span class=name>dependency</span>></span></span><br></pre></table></figure><p>配置：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"thrift"</span> <span class=attr>port</span>=<span class=string>"3030"</span> /></span></span><br></pre></table></figure><p><font color=red>注意：Thrift不支持null值，不能在协议中传null。</font><h2 id=2-7、memcached协议><a class=headerlink href=#2-7、memcached协议 title=2.7、memcached协议></a>2.7、memcached协议</h2><p>可以通过脚本或监控中心手工填写表单注册memcached服务的地址：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</span><br><span class=line>Registry registry = registryFactory.getRegistry(URL.valueOf(<span class=string>"zookeeper://10.20.153.10:2181"</span>));</span><br><span class=line>registry.register(URL.valueOf(<span class=string>"memcached://10.20.153.11/com.foo.BarService?category=providers&dynamic=false&application=foo&group=member&loadbalance=consistenthash"</span>));</span><br></pre></table></figure><p>然后在客户端使用时，不需要感知Memcached的地址：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"cache"</span> </span></span><br><span class=line><span class=tag>            <span class=attr>interface</span>=<span class=string>"http://10.20.160.198/wiki/display/dubbo/java.util.Map"</span> <span class=attr>group</span>=<span class=string>"member"</span> /></span></span><br></pre></table></figure><p>或者点对点直连<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"cache"</span> <span class=attr>interface</span>=<span class=string>"http://10.20.160.198/wiki/display/dubbo/java.util.Map"</span> <span class=attr>url</span>=<span class=string>"memcached://10.20.153.10:11211"</span> /></span></span><br></pre></table></figure><p>自定义接口<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"cache"</span> <span class=attr>interface</span>=<span class=string>"com.foo.CacheService"</span> <span class=attr>url</span>=<span class=string>"memcached://10.20.153.10:11211"</span> /></span></span><br></pre></table></figure><p>方法名建议和memcached的标准方法名相同，即：get(key), set(key, value), delete(key)。<br>如果方法名和memcached的标准方法名不相同，则需要配置映射关系：(其中”p:xxx”为spring的标准p标签)<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"cache"</span> <span class=attr>interface</span>=<span class=string>"com.foo.CacheService"</span> <span class=attr>url</span>=<span class=string>"memcached://10.20.153.10:11211"</span> <span class=attr>p:set</span>=<span class=string>"putFoo"</span> <span class=attr>p:get</span>=<span class=string>"getFoo"</span> <span class=attr>p:delete</span>=<span class=string>"removeFoo"</span> /></span></span><br></pre></table></figure><h2 id=2-8、redis协议><a class=headerlink href=#2-8、redis协议 title=2.8、redis协议></a>2.8、redis协议</h2><p>可通过脚本或监控中心手工填写表单注册redis服务地址：<figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre><td class=code><pre><span class=line>RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();</span><br><span class=line>Registry registry = registryFactory.getRegistry(URL.valueOf(<span class=string>"zookeeper://10.20.153.10:2181"</span>));</span><br><span class=line>registry.register(URL.valueOf(<span class=string>"redis://10.20.153.11/com.foo.BarService?category=providers&dynamic=false&application=foo&group=member&loadbalance=consistenthash"</span>));</span><br></pre></table></figure><p>然后在客户端使用时，不需要感知Redis的地址：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"store"</span> <span class=attr>interface</span>=<span class=string>"http://10.20.160.198/wiki/display/dubbo/java.util.Map"</span> <span class=attr>group</span>=<span class=string>"member"</span> /></span></span><br></pre></table></figure><p>点对点直连<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"store"</span> <span class=attr>interface</span>=<span class=string>"http://10.20.160.198/wiki/display/dubbo/java.util.Map"</span> <span class=attr>url</span>=<span class=string>"redis://10.20.153.10:6379"</span> /></span></span><br></pre></table></figure><p>自定义接口<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"store"</span> <span class=attr>interface</span>=<span class=string>"com.foo.StoreService"</span> <span class=attr>url</span>=<span class=string>"redis://10.20.153.10:6379"</span> /></span></span><br></pre></table></figure><p>方法名建议和redis的标准方法名相同，即：get(key), set(key, value), delete(key)。<br>如果方法名和redis的标准方法名不相同，则需要配置映射关系：(其中”p:xxx”为spring的标准p标签)<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:reference</span> <span class=attr>id</span>=<span class=string>"cache"</span> <span class=attr>interface</span>=<span class=string>"com.foo.CacheService"</span> <span class=attr>url</span>=<span class=string>"memcached://10.20.153.10:11211"</span> <span class=attr>p:set</span>=<span class=string>"putFoo"</span> <span class=attr>p:get</span>=<span class=string>"getFoo"</span> <span class=attr>p:delete</span>=<span class=string>"removeFoo"</span> /></span></span><br></pre></table></figure><h1 id=3、Dubbo序列化><a class=headerlink href=#3、Dubbo序列化 title=3、Dubbo序列化></a>3、Dubbo序列化</h1><h2 id=3-1、简介><a class=headerlink href=#3-1、简介 title=3.1、简介></a>3.1、简介</h2><p><strong>dubbo 跨JVM调用需要进行网络通信，故需要使用序列化与反序列化。</strong><p>dubbo 中定义ObjectInput、ObjectOutput 与 Serialization 来进行数据的序列化与反序列化。<p>Serialization接口定义如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@SPI("hessian2")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Serialization</span> {</span><br><span class=line>    <span class=type>byte</span> <span class="title function_">getContentTypeId</span><span class=params>()</span>;</span><br><span class=line>    String <span class="title function_">getContentType</span><span class=params>()</span>;</span><br><span class=line>    <span class=meta>@Adaptive</span></span><br><span class=line>    ObjectOutput <span class="title function_">serialize</span><span class=params>(URL url, OutputStream output)</span> <span class=keyword>throws</span> IOException;</span><br><span class=line>    <span class=meta>@Adaptive</span></span><br><span class=line>    ObjectInput <span class="title function_">deserialize</span><span class=params>(URL url, InputStream input)</span> <span class=keyword>throws</span> IOException;</span><br><span class=line>}</span><br></pre></table></figure><p>这个接口里面定义了 4 个方法：<ul><li>getContentTypeId：获取序列化 ContextType 的 id。<li>getContentType：获取序列化的 ContentType。<li>serialize：创建一个 ObjectOutput (序列化器)，用于把对象转换序列化字节序列。<li>deserialize：创建一个 ObjectInput (反序列化器)，用于把字节序列恢复成对象。</ul><h2 id=3-2、序列化类型><a class=headerlink href=#3-2、序列化类型 title=3.2、序列化类型></a>3.2、序列化类型</h2><p>Dubbo序列化支持java、compactedjava、nativejava、fastjson、dubbo、fst、hessian2、kryo，其中默认hessian2。其中java、compactedjava、nativejava属于原生Java序列化。<ol><li><font color=orange>dubbo序列化</font>：阿里开发，尚未成熟，生产中不建议使用。<li><font color=orange>hessian2序列化</font>：hessian是一种跨语言高效二进制序列化方式。但该序列化方式不是原生的hessian2序列化，而是阿里修改过的，它是dubbo RPC默认启用的序列化方式。<li><font color=orange>json序列化</font>：一种是阿里的fastjson库，另一种是dubbo自己实现的json库，但都不是特别成熟，且json这种文本序列化性能一般，不如前两种二进制序列化。<li><font color=orange>java序列化</font>：JDK自带的序列化实现，性能不理想。</ol><p>以上 四种序列化方式的性能从上到下依次递减，dubbo默认采用hessian2序列化方式。<p>除了上面那些序列化方式外，新的高效序列化方式层出不穷，典型的包括：<ul><li>专门针对Java语言的：Kryo，FST等。<li>跨语言的：Protostuff，ProtoBuf，Thrift，Avro，MsgPack等。</ul><p>使用Kryo和FST非常简单，只需要在dubbo RPC的XML配置中添加一个属性即可：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"dubbo"</span> <span class=attr>serialization</span>=<span class=string>"kryo"</span>/></span></span><br></pre></table></figure><p>或者<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>name</span>=<span class=string>"dubbo"</span> <span class=attr>serialization</span>=<span class=string>"fst"</span>/></span></span><br></pre></table></figure><h2 id=3-3、序列化扩展><a class=headerlink href=#3-3、序列化扩展 title=3.3、序列化扩展></a>3.3、序列化扩展</h2><p><strong>可以通过扩展 Serialization、ObjectInput、ObjectOutput 来进行 dubbo 序列化的扩展。</strong><p>项目目录：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line>src</span><br><span class=line> |-main</span><br><span class=line>    |-java</span><br><span class=line>        |-com</span><br><span class=line>            |-xxx</span><br><span class=line>                |-XxxSerialization.java (实现Serialization接口)</span><br><span class=line>                |-XxxObjectInput.java (实现ObjectInput接口)</span><br><span class=line>                |-XxxObjectOutput.java (实现ObjectOutput接口)</span><br><span class=line>    |-resources</span><br><span class=line>        |-META-INF</span><br><span class=line>            |-dubbo</span><br><span class=line>                |-com.alibaba.dubbo.common.serialize.Serialization (纯文本文件，内容为：xxx=com.xxx.XxxSerialization)</span><br></pre></table></figure><p>XxxSerialization.java：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre><td class=code><pre><span class=line><span class=keyword>package</span> com.xxx;</span><br><span class=line></span><br><span class=line><span class=keyword>import</span> com.alibaba.dubbo.common.serialize.Serialization;</span><br><span class=line><span class=keyword>import</span> com.alibaba.dubbo.common.serialize.ObjectInput;</span><br><span class=line><span class=keyword>import</span> com.alibaba.dubbo.common.serialize.ObjectOutput;</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">XxxSerialization</span> <span class=keyword>implements</span> <span class="title class_">Serialization</span> {</span><br><span class=line>    <span class=keyword>public</span> ObjectOutput <span class="title function_">serialize</span><span class=params>(Parameters parameters, OutputStream output)</span> <span class=keyword>throws</span> IOException {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">XxxObjectOutput</span>(output);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>public</span> ObjectInput <span class="title function_">deserialize</span><span class=params>(Parameters parameters, InputStream input)</span> <span class=keyword>throws</span> IOException {</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">XxxObjectInput</span>(input);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>META-INF/dubbo/com.alibaba.dubbo.common.serialize.Serialization：<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line>xxx=com.xxx.XxxSerialization</span><br></pre></table></figure><p>并且通过以下配置来使用新扩展。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!-- 协议 序列化方式 --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:protocol</span> <span class=attr>serialization</span>=<span class=string>"xxx"</span> /></span></span><br><span class=line><span class=comment>&LT!-- 缺省值设置，当&LTdubbo:protocol>没有配置serialization时，使用此配置 --></span></span><br><span class=line><span class=tag><<span class=name>dubbo:provider</span> <span class=attr>serialization</span>=<span class=string>"xxx"</span> /></span></span><br></pre></table></figure><h1 id=4、底层实现><a class=headerlink href=#4、底层实现 title=4、底层实现></a>4、底层实现</h1><h2 id=4-1、服务注册中心><a class=headerlink href=#4-1、服务注册中心 title=4.1、服务注册中心></a>4.1、服务注册中心</h2><p>分布式系统的必备组件，服务提供者和服务消费者在启动时都会注册自己至服务注册中心。<h2 id=4-2、动态代理Proxy><a class=headerlink href=#4-2、动态代理Proxy title=4.2、动态代理Proxy></a>4.2、动态代理Proxy</h2><p>该类框架基本思想：接口生成一个代理对象，然后在代理对象中编写功能实现。<p>所以只需每个服务都提供接口，且在消费者调用时创建一个动态代理对象，然后消费者可通过该代理对象进行调用。<h2 id=4-3、Cluster集群层><a class=headerlink href=#4-3、Cluster集群层 title=4.3、Cluster集群层></a>4.3、Cluster集群层</h2><h3 id=4-3-1、简介><a class=headerlink href=#4-3-1、简介 title=4.3.1、简介></a>4.3.1、简介</h3><p><img alt=image-20230807161954071 src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/image-20230807161954071.png><p>各节点关系：<ul><li><p>Cluster</p> <p>将Directory中的多个Invoker伪装成一个 Invoker，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个；</p><li><p>Invoker</p> <p>是Provider的一个可调用Service的抽象，Invoker封装了Provider地址及Service接口信息；</p><li><p>Directory</p> <p>代表多个Invoker，可以看成是List ，但与List不同的是，它的值可能动态变化，比如注册中心推送变更；</p><li><p>Router</p> <p>负责从多个Invoker中按路由规则选出子集，比如读写分离，应用隔离等；</p><li><p>LoadBalance</p> <p>负责从多个Invoker中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选；</p></ul><p><strong>Cluster层使命：挑选并返回一个服务提供者。</strong><p>Cluster层在选择一个服务时，必须先获取所有服务提供者，获取的过程称为 动态感知。成功获取后，会通过Cluster层中的负载均衡组件<code>LoadBlance</code>（Cluster层有很多组件，比如 Directory、Router、LoadBalance等）来挑选一个服务。<h3 id=4-3-2、LoadBlance组件><a class=headerlink href=#4-3-2、LoadBlance组件 title=4.3.2、LoadBlance组件></a>4.3.2、LoadBlance组件</h3><p>dubbo默认提供了多种策略：<ul><li><font color=orange>Random LoadBalance（随机）</font>：按权重设置随机概率，在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重；<li><font color=orange>RoundRobin LoadBalance（轮询）</font>：按公约后的权重设置轮询比率；存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上；<li><font color=orange>LeastActive LoadBalance（最小活跃数，相同则随机）</font>：活跃数是指调用前后计数差；使得 效率低的服务提供者收到更少请求，因为提供者效率越低其调用前后计数差就会越大；<li><font color=orange>ConsistentHash LoadBalance（一致性hash）</font>：相同参数的请求会被提交给同一提供者；当某一台提供者挂时，原本发往该提供者的请求会基于虚拟节点平摊给其它提供者，不会引起剧烈变动；</ul><p>SPI定义默认策略为<code>Random LoadBalance</code>，提供了一个select方法，通过策略 从服务列表中选择一个invoker。可以自行扩展负载均衡策略；接口类如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre><td class=code><pre><span class=line><span class=meta>@SPI(RandomLoadBalance.NAME)</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">LoadBalance</span> {</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * select one invoker in list.</span></span><br><span class=line><span class=comment>     *</span></span><br><span class=line><span class=comment>     * <span class=doctag>@param</span> invokers   invokers.</span></span><br><span class=line><span class=comment>     * <span class=doctag>@param</span> url        refer url</span></span><br><span class=line><span class=comment>     * <span class=doctag>@param</span> invocation invocation.</span></span><br><span class=line><span class=comment>     * <span class=doctag>@return</span> selected invoker.</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    <span class=meta>@Adaptive("loadbalance")</span></span><br><span class=line>    &LTT> Invoker&LTT> <span class="title function_">select</span><span class=params>(List&LTInvoker&LTT>> invokers, URL url, Invocation invocation)</span> <span class=keyword>throws</span> RpcException;</span><br><span class=line>}</span><br></pre></table></figure><h2 id=4-4、Exchange信息交换层><a class=headerlink href=#4-4、Exchange信息交换层 title=4.4、Exchange信息交换层></a>4.4、Exchange信息交换层</h2><p>该层使命：<strong>把我们的请求数据包装成 Request 或 Response</strong> 。<h2 id=4-5、Transport-网络通信层><a title="4.5、Transport 网络通信层" class=headerlink href=#4-5、Transport-网络通信层></a>4.5、Transport 网络通信层</h2><p>该层使命： <strong>消费者将封装好的请求先进行序列化，再通过一个网络通信框架（比如netty） 发送至某一个服务提供者。</strong><blockquote><p>序列化方式有多种，比如Json、Protobuf、Protostuff、Hessian、Kryo等、Java序列化等。</blockquote><h2 id=4-6、服务消费者接收到响应><a class=headerlink href=#4-6、服务消费者接收到响应 title=4.6、服务消费者接收到响应></a>4.6、服务消费者接收到响应</h2><p>服务提供者也需要通过一个网络通信框架（比如netty）去监听消费者开放的端口。收到请求后先反序列化再解析，然后创建一个动态代理对象，并调用我们的服务提供者接口来返回数据。<h1 id=5、Dubbo-SPI机制><a title="5、Dubbo SPI机制" class=headerlink href=#5、Dubbo-SPI机制></a>5、Dubbo SPI机制</h1><h2 id=5-1、SPI定义><a class=headerlink href=#5-1、SPI定义 title=5.1、SPI定义></a>5.1、SPI定义</h2><p><strong>SPI 是 Service Provider Interface 的缩写，意为服务提供接口，是一种服务发现机制。SPI的本质是将接口的实现类全限定名定义在配置文件中，然后服务器读取配置文件并加载实现类。这样就可以在运行时动态为接口修改实现类。</strong><h2 id=5-2、JDK-SPI-和-Dubbo-SPI><a title="5.2、JDK SPI 和 Dubbo SPI" class=headerlink href=#5-2、JDK-SPI-和-Dubbo-SPI></a>5.2、JDK SPI 和 Dubbo SPI</h2><h3 id=5-2-1、JDK-SPI><a title="5.2.1、JDK SPI" class=headerlink href=#5-2-1、JDK-SPI></a>5.2.1、JDK SPI</h3><h4 id=简介><a class=headerlink href=#简介 title=简介></a>简介</h4><p><strong>Java SPI 实际上是 接口编程＋策略模式＋配置文件 组合实现的动态加载机制。</strong><p>定义一个接口和两个实现：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">User</span> {</span><br><span class=line>    String <span class="title function_">showName</span><span class=params>()</span>;</span><br><span class=line>}</span><br><span class=line><span class=comment>// ---</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Student</span> <span class=keyword>implements</span> <span class="title class_">User</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">showName</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"my name is laowang"</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=comment>// ---</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">Teacher</span> <span class=keyword>implements</span> <span class="title class_">User</span> {</span><br><span class=line>    <span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">showName</span><span class=params>()</span> {</span><br><span class=line>        System.out.println(<span class=string>"my name is zhangsan"</span>);</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>null</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>在resources目录下创建文件夹META-INF.services，并在该文件夹下创建一个名称与User的全路径一致的文件，例如cn.shh.service.User，然后在文件中写入，两个实现类的全路径名：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>cn.shh.service.impl.Student</span><br><span class=line>cn.shh.service.impl.Teacher</span><br></pre></table></figure><p>编写一个测试类来测试其效果：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">SpiTest</span> {</span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>static</span> <span class=keyword>void</span> <span class="title function_">main</span><span class=params>(String[] args)</span> {</span><br><span class=line>        ServiceLoader&LTUser> serviceLoader = ServiceLoader.load(User.class);</span><br><span class=line>        serviceLoader.forEach(User::showName);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>通过SPI机制，可以自动运行两个实现类。通过查看源码可知其原理：<strong>读取配置文件中实现类的全路径类名，然后通过反射创建对象并放入providers容器中。</strong><h4 id=总结-5><a class=headerlink href=#总结-5 title=总结></a>总结</h4><ul><li><p>调用过程</p> <p>调用<code>ServiceLoader.load</code>创建一个新ServiceLoader，并实例化该类中的成员变量，通过迭代器获取对象实例。ServiceLoader先判断成员变量 providers 对象中（LinkedHashMap&LTString,S>类型）是否有缓存实例对象，如果有缓存，直接返回。如果没有缓存，执行类的装载。</p><li><p>优点</p> <ol><li>Java SPI 优点是解耦，使得接口的定义与具体业务实现分离。<li>应用进程可以根据实际业务情况启用或替换具体组件。</ol><li><p>缺点</p> <ol><li>不能按需加载。虽然ServiceLoader 做了延迟载入，但是基本只能通过遍历全部来获取，也就是接口的实现类得全部载入并实例化一遍。<li>获取某个实现类的方式不够灵活，只能通过Iterator 遍历来获取，不能根据某个参数来获取对应的实现类。<li>多线程使用ServiceLoader实例，不安全。<li>加载不到实现类时会抛出一个无关异常，很难定位错误。</ol></ul><h3 id=5-2-2、Dubbo-SPI><a title="5.2.2、Dubbo SPI" class=headerlink href=#5-2-2、Dubbo-SPI></a>5.2.2、Dubbo SPI</h3><h4 id=简介-1><a class=headerlink href=#简介-1 title=简介></a>简介</h4><p>Dubbo 并未使用Java SPI，而是重新实现了一套功能更强的SPI 机制。Dubbo SPI 的相关逻辑被封装在了ExtensionLoader 类中，通过ExtensionLoader可以加载指定的实现类。<p><strong>与Java SPI不同，Dubbo SPI是通过键值对方式进行配置，这样可以按需加载指定实现类。</strong>比如：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line>optimusPrime=org.apache.spi.OptimusPrime</span><br><span class=line>bumblebee=org.apache.spi.Bumblebee</span><br></pre></table></figure><p><strong>在使用Dubbo SPI 时，需要在接口上标注@SPI 注解。</strong>例如：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@SPI</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Robot</span> {</span><br><span class=line>	<span class=keyword>void</span> <span class="title function_">sayHello</span><span class=params>()</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>通过ExtensionLoader，我们可以加载指定的实现类，下面来演示：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">DubboSPITest</span> {</span><br><span class=line>   <span class=meta>@Test</span></span><br><span class=line>   <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">sayHello</span><span class=params>()</span> <span class=keyword>throws</span> Exception {</span><br><span class=line>       ExtensionLoader&LTRobot> extensionLoader = ExtensionLoader.getExtensionLoader(Robot.class);</span><br><span class=line>       <span class=type>Robot</span> <span class=variable>optimusPrime</span> <span class=operator>=</span> extensionLoader.getExtension(<span class=string>"optimusPrime"</span>);</span><br><span class=line>       optimusPrime.sayHello();</span><br><span class=line>       <span class=type>Robot</span> <span class=variable>bumblebee</span> <span class=operator>=</span> extensionLoader.getExtension(<span class=string>"bumblebee"</span>);</span><br><span class=line>       bumblebee.sayHello();</span><br><span class=line>   }</span><br><span class=line>}</span><br></pre></table></figure><p><font color=red>注意：Dubbo SPI 除了支持按需加载接口实现类外，还增加了IOC 和AOP 等特性。</font><h4 id=源码分析><a class=headerlink href=#源码分析 title=源码分析></a>源码分析</h4><p>ExtensionLoader 的getExtensionLoader 方法获取一个ExtensionLoader 实例，然后再通过ExtensionLoader 的getExtension 方法获取拓展类对象。<p>下面我们从ExtensionLoader 的getExtension 方法作为入口，对拓展类对象的获取过程进行详细的分析。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> T <span class="title function_">getExtension</span><span class=params>(String name)</span> {</span><br><span class=line>       <span class=keyword>if</span> (StringUtils.isEmpty(name)) {</span><br><span class=line>           <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalArgumentException</span>(<span class=string>"Extension name == null"</span>);</span><br><span class=line>       }</span><br><span class=line>       <span class=keyword>if</span> (<span class=string>"true"</span>.equals(name)) {</span><br><span class=line>            <span class=comment>// 获取默认的拓展实现类</span></span><br><span class=line>           <span class=keyword>return</span> getDefaultExtension();</span><br><span class=line>       }</span><br><span class=line>       <span class=comment>// Holder，顾名思义，用于持有目标对象 就是从容器中获取,如果没有直接new一个Holder</span></span><br><span class=line>       Holder&LTObject> holder = getOrCreateHolder(name);</span><br><span class=line>       <span class=comment>//获取目标对象实例</span></span><br><span class=line>       <span class=type>Object</span> <span class=variable>instance</span> <span class=operator>=</span> holder.get();</span><br><span class=line>        <span class=comment>// 如果目标对象实例为null 就需要通过双重检查创建实例</span></span><br><span class=line>       <span class=keyword>if</span> (instance == <span class=literal>null</span>) {</span><br><span class=line>           <span class=keyword>synchronized</span> (holder) {</span><br><span class=line>               instance = holder.get();</span><br><span class=line>               <span class=keyword>if</span> (instance == <span class=literal>null</span>) {</span><br><span class=line>                   <span class=comment>// 创建拓展实例</span></span><br><span class=line>                   instance = createExtension(name);</span><br><span class=line>                   <span class=comment>// 设置实例到 holder 中</span></span><br><span class=line>                   holder.set(instance);</span><br><span class=line>               }</span><br><span class=line>           }</span><br><span class=line>       }</span><br><span class=line>       <span class=keyword>return</span> (T) instance;</span><br><span class=line>}</span><br></pre></table></figure><p>上面代码逻辑比较简单，首先检查缓存，缓存未命中则创建拓展对象。<p>下面我们来看一下创建拓展对象的过程是怎样的。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> T <span class="title function_">createExtension</span><span class=params>(String name)</span> {</span><br><span class=line>   <span class=comment>// 从配置文件中加载所有的拓展类，可得到“配置项名称”到“配置类”的映射关系表</span></span><br><span class=line>   Class&LT?> clazz = getExtensionClasses().get(name);</span><br><span class=line>   <span class=keyword>if</span> (clazz == <span class=literal>null</span>) {</span><br><span class=line>       <span class=keyword>throw</span> findException(name);</span><br><span class=line>   }</span><br><span class=line>   <span class=keyword>try</span> {</span><br><span class=line>       <span class=comment>//从容器中获取对应的实例对象 如果不存在就通过反射创建</span></span><br><span class=line>       <span class=type>T</span> <span class=variable>instance</span> <span class=operator>=</span> (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class=line>       <span class=keyword>if</span> (instance == <span class=literal>null</span>) {</span><br><span class=line>           <span class=comment>// 通过反射创建实例</span></span><br><span class=line>           EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class=line>           instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class=line>       }</span><br><span class=line>       <span class=comment>// 向实例中注入依赖 下面是IOC和AOP的实现</span></span><br><span class=line>       injectExtension(instance);</span><br><span class=line>       Set&LTClass&LT?>> wrapperClasses = cachedWrapperClasses;</span><br><span class=line>       <span class=keyword>if</span> (CollectionUtils.isNotEmpty(wrapperClasses)) {</span><br><span class=line>             <span class=comment>// 循环创建 Wrapper 实例</span></span><br><span class=line>           <span class=keyword>for</span> (Class&LT?> wrapperClass : wrapperClasses) {</span><br><span class=line>               <span class=comment>// 将当前 instance 作为参数传给 Wrapper 的构造方法，并通过反射创建Wrapper 实例。</span></span><br><span class=line>               <span class=comment>// 然后向 Wrapper 实例中注入依赖，最后将 Wrapper 实例再次赋值给instance 变量</span></span><br><span class=line>               instance = injectExtension(</span><br><span class=line>                   (T)</span><br><span class=line>wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class=line>           }</span><br><span class=line>}</span><br></pre></table></figure><p>createExtension 方法的逻辑稍复杂一下，包含了如下的步骤：<ol><li>通过getExtensionClasses 获取所有的拓展类<li>通过反射创建拓展对象<li>向拓展对象中注入依赖<li>将拓展对象包裹在相应的Wrapper 对象中</ol><p>以上步骤中，第一个步骤是加载拓展类的关键，第三和第四个步骤是Dubbo IOC 与AOP 的具体实现。由于此类设计源码较多，这里简单的总结下ExtensionLoader整个执行逻辑：<figure class="highlight plaintext"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line>getExtension(String name)  #根据key获取拓展对象</span><br><span class=line>    -->createExtension(String name) #创建拓展实例</span><br><span class=line>        -->getExtensionClasses #根据路径获取所有的拓展类</span><br><span class=line>            -->loadExtensionClasses #加载拓展类</span><br><span class=line>                -->cacheDefaultExtensionName #解析@SPI注解</span><br><span class=line>            -->loadDirectory #方法加载指定文件夹配置文件</span><br><span class=line>                -->loadResource #加载资源</span><br><span class=line>                    -->loadClass #加载类，并通过 loadClass 方法对类进行缓存</span><br></pre></table></figure><h2 id=5-3、Dubbo-SPI-实现-IOC和AOP><a title="5.3、Dubbo SPI 实现 IOC和AOP" class=headerlink href=#5-3、Dubbo-SPI-实现-IOC和AOP></a>5.3、Dubbo SPI 实现 IOC和AOP</h2><h3 id=5-3-1、Dubbo-IOC><a title="5.3.1、Dubbo IOC" class=headerlink href=#5-3-1、Dubbo-IOC></a>5.3.1、Dubbo IOC</h3><p><strong>Dubbo IOC 是通过 setter方式 注入依赖。Dubbo 首先会通过反射获取实例所有方法，然后再遍历方法列表，检测方法名是否具有setter 方法特征。若有，则通过 ObjectFactory 获取依赖对象，最后通过反射调用setter 方法将依赖设置到目标对象中。</strong><h3 id=5-3-2、Dubbo-AOP><a title="5.3.2、Dubbo AOP" class=headerlink href=#5-3-2、Dubbo-AOP></a>5.3.2、Dubbo AOP</h3><p>分析之前先了解一下装饰者模式<p>装饰者模式：在不改变原类文件以及不使用继承的情况下，动态地将责任附加到对象上，从而实现动态拓展一个对象的功能。它是通过创建一个包装对象来包裹真实对象。<p>Dubbo Aop原理：<strong>Dubbo支持AOP得益于Dubbo中称为Wrapper的类。通过装饰者模式，使用包装类包装原始的扩展点实例，在原始扩展点实现前后插入其他逻辑，实现AOP功能。</strong><p>装饰者模式 一般有如下参与者：<ol><li><font color=orange>Component</font>：装饰者和被装饰者共同的父类，是一个接口或者抽象类，用来定义基本行为。<li><font color=orange>ConcreteComponent</font>：定义具体对象，即被装饰者。<li><font color=orange>Decorator</font>：抽象装饰者，继承自Component，从外类来扩展ConcreteComponent。对于ConcreteComponent来说，不需要知道Decorator的存在，Decorator是一个接口或抽象类。<li><font color=orange>ConcreteDecorator</font>：具体装饰者，用于扩展ConcreteComponent。</ol><p>cachedWrapperClasses是一个set集合，那么集合何时添加元素呢?<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> Set&LTClass&LT?>> cachedWrapperClasses;</span><br></pre></table></figure><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">cacheWrapperClass</span><span class=params>(Class&LT?> clazz)</span> {</span><br><span class=line>    <span class=keyword>if</span> (cachedWrapperClasses == <span class=literal>null</span>) {</span><br><span class=line>        cachedWrapperClasses = <span class=keyword>new</span> <span class="title class_">ConcurrentHashSet</span><>();</span><br><span class=line>    }</span><br><span class=line>    cachedWrapperClasses.add(clazz);</span><br><span class=line>}</span><br></pre></table></figure><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=type>boolean</span> <span class="title function_">isWrapperClass</span><span class=params>(Class&LT?> clazz)</span> {</span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        clazz.getConstructor(type);</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>true</span>;</span><br><span class=line>    } <span class=keyword>catch</span> (NoSuchMethodException e) {</span><br><span class=line>        <span class=keyword>return</span> <span class=literal>false</span>;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><h1 id=6、Dubbo动态编译><a class=headerlink href=#6、Dubbo动态编译 title=6、Dubbo动态编译></a>6、Dubbo动态编译</h1><p>Dubbo很多拓展 都是通过【SPI 机制】加载，比如Protocol、Cluster、LoadBalance、ProxyFactory 等。但是有些拓展并不希望在框架启动时就去加载，而是希望在拓展方法被调用时根据参数来进行加载，即根据参数动态加载实现类。<p><strong>运行时根据方法参数动态决定使用何种拓展方式就叫 扩展点自适应实例。</strong>其实就是一个扩展点代理，将扩展的选择时机从Dubbo启动时延迟到RPC调用时。Dubbo中每一个扩展点都有一个自适应类，如果没有显式提供，Dubbo会自动为我们创建一个，默认使用Javaassist。<p>自适应拓展机制 实现逻辑 如下：<ol><li>首先Dubbo 会为拓展接口生成具有代理功能的代码；<li>通过Javassist 或JDK编译这段代码，得到Class 类；<li>通过反射创建代理类；<li>在代理类中，通过URL对象的参数来确定到底调用哪个实现类；</ol><h2 id=6-1、Javassist><a class=headerlink href=#6-1、Javassist title=6.1、Javassist></a>6.1、Javassist</h2><p><strong>Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科学系的Shigeru Chiba （千叶滋）创建。</strong><p>Javassist是Jboss的一个子项目，其主要优点是简单、快速。直接通过Java编码而不需要了解虚拟机指令就能动态改变类的结构，或者动态生成类。<h2 id=6-2、源码分析><a class=headerlink href=#6-2、源码分析 title=6.2、源码分析></a>6.2、源码分析</h2><p>Adaptive注解：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=meta>@Documented</span></span><br><span class=line><span class=meta>@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=line><span class=meta>@Target({ElementType.TYPE, ElementType.METHOD})</span></span><br><span class=line><span class=keyword>public</span> <span class=meta>@interface</span> Adaptive {</span><br><span class=line>   String[] value() <span class=keyword>default</span> {};</span><br><span class=line>}</span><br></pre></table></figure><p>Adaptive 可注解在类或方法上。<ul><li>标注在类上：Dubbo 不会为该类生成代理类。<li>标注在方法上：Dubbo 会为该方法生成代理逻辑，表示当前方法需要根据 参数URL 调用对应的扩展点实现。</ul><p>dubbo中每一个扩展点都有一个自适应类，如果没有显式提供，Dubbo会自动为我们创建一个，默认使用Javaassist。 先来看下创建自适应扩展类的代码。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br></pre><td class=code><pre><span class=line><span class=comment>// 1、看下extensionLoader的获取方法</span></span><br><span class=line>ExtensionLoader&LTRobot>extensionLoader=ExtensionLoader.getExtensionLoader(Robot.class);</span><br><span class=line></span><br><span class=line><span class=comment>// 2、最终调用的是ExtensionLoader的构造方法</span></span><br><span class=line><span class=keyword>private</span> <span class="title function_">ExtensionLoader</span><span class=params>(Class&LT?> type)</span> {</span><br><span class=line>        <span class=built_in>this</span>.type = type;</span><br><span class=line>        objectFactory = (type == ExtensionFactory.class ? <span class=literal>null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>// 3、getAdaptiveExtension()看看干了什么事</span></span><br><span class=line><span class=keyword>public</span> T <span class="title function_">getAdaptiveExtension</span><span class=params>()</span> {</span><br><span class=line>    <span class=comment>// 获取自适应扩展类，如果没有就初始化一个</span></span><br><span class=line>    <span class=type>Object</span> <span class=variable>instance</span> <span class=operator>=</span> cachedAdaptiveInstance.get();</span><br><span class=line>    <span class=keyword>if</span> (instance == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>if</span> (createAdaptiveInstanceError == <span class=literal>null</span>) {</span><br><span class=line>            <span class=keyword>synchronized</span> (cachedAdaptiveInstance) {</span><br><span class=line>                instance = cachedAdaptiveInstance.get();</span><br><span class=line>                <span class=keyword>if</span> (instance == <span class=literal>null</span>) {</span><br><span class=line>                    <span class=keyword>try</span> {</span><br><span class=line>                        <span class=comment>// 创建一个自适应扩展类</span></span><br><span class=line>                        instance = createAdaptiveExtension();</span><br><span class=line>                        cachedAdaptiveInstance.set(instance);</span><br><span class=line>                    } <span class=keyword>catch</span> (Throwable t) {</span><br><span class=line>                        createAdaptiveInstanceError = t;</span><br><span class=line>                        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalStateException</span>(<span class=string>"Failed to create adaptive instance: "</span> + t.toString(), t);</span><br><span class=line>                    }</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalStateException</span>(<span class=string>"Failed to create adaptive instance: "</span> + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>return</span> (T) instance;</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>//看看createAdaptiveExtension()</span></span><br><span class=line><span class=keyword>private</span> T <span class="title function_">createAdaptiveExtension</span><span class=params>()</span> {</span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        <span class=keyword>return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class=line>    } <span class=keyword>catch</span> (Exception e) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalStateException</span>(<span class=string>"Can't create adaptive extension "</span> + type + <span class=string>", cause: "</span> + e.getMessage(), e);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>//再进到getAdaptiveExtensionClass()</span></span><br><span class=line><span class=keyword>private</span> Class&LT?> getAdaptiveExtensionClass() {</span><br><span class=line>    getExtensionClasses();</span><br><span class=line>    <span class=keyword>if</span> (cachedAdaptiveClass != <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>return</span> cachedAdaptiveClass;</span><br><span class=line>    }</span><br><span class=line>    <span class=type>return</span> <span class=variable>cachedAdaptiveClass</span> <span class=operator>=</span> createAdaptiveExtensionClass();</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>//继续追进去createAdaptiveExtensionClass()</span></span><br><span class=line><span class=keyword>private</span> Class&LT?> createAdaptiveExtensionClass() {</span><br><span class=line>        <span class=type>String</span> <span class=variable>code</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">AdaptiveClassCodeGenerator</span>(type, cachedDefaultName).generate();</span><br><span class=line>        <span class=type>ClassLoader</span> <span class=variable>classLoader</span> <span class=operator>=</span> findClassLoader();</span><br><span class=line>        org.apache.dubbo.common.compiler.<span class=type>Compiler</span> <span class=variable>compiler</span> <span class=operator>=</span> ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class=line>        <span class=keyword>return</span> compiler.compile(code, classLoader);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>//看看compiler</span></span><br><span class=line><span class=meta>@SPI("javassist")</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>interface</span> <span class="title class_">Compiler</span> {</span><br><span class=line>    <span class=comment>/**</span></span><br><span class=line><span class=comment>     * Compile java source code.</span></span><br><span class=line><span class=comment>     *</span></span><br><span class=line><span class=comment>     * <span class=doctag>@param</span> code        Java source code</span></span><br><span class=line><span class=comment>     * <span class=doctag>@param</span> classLoader classloader</span></span><br><span class=line><span class=comment>     * <span class=doctag>@return</span> Compiled class</span></span><br><span class=line><span class=comment>     */</span></span><br><span class=line>    Class&LT?> compile(String code, ClassLoader classLoader);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=comment>//其实到这里就知道了,通过生成一个类的字符串,再通过javassist生成一个对象</span></span><br></pre></table></figure><p>createAdaptiveExtensionClassCode()方法中使用一个 StringBuilder 来构建自适应类的Java源码。这种生成字节码的方式是：先生成Java源代码，然后编译并加载到JVM中。<p>通过这种方式，可以更好的控制生成的Java类。而且不用关心字节码框架API的使用。因为xxx.java文件是Java通用的，也是我们最熟悉的。只是代码的可读性不强，需要一点一点构建xx.java的内容。<h1 id=7、服务暴漏与发现><a class=headerlink href=#7、服务暴漏与发现 title=7、服务暴漏与发现></a>7、服务暴漏与发现</h1><h2 id=7-1、服务暴漏><a class=headerlink href=#7-1、服务暴漏 title=7.1、服务暴漏></a>7.1、服务暴漏</h2><h3 id=7-1-1、名词解释><a class=headerlink href=#7-1-1、名词解释 title=7.1.1、名词解释></a>7.1.1、名词解释</h3><ul><li><font color=orange>Invoker实体域</font>：它是Dubbo 的核心模型，其它模型可转换成它，它代表一个可执行体，可向它发起invoke 调用，它有可能是一个本地实现、或远程实现、或集群实现。在服务提供方，Invoker用于调用服务提供类。在服务消费方，Invoker用于执行远程调用。<li><font color=orange>Protocol 服务域</font>：它是Invoker 暴露和引用的主功能入口，负责Invoker 的生命周期管理。<ul><li>export：暴露远程服务；<li>refer：引用远程服务；</ul><li><font color=orange>proxyFactory</font>：获取一个接口的代理类；<ul><li>getInvoker：针对server端，将服务对象，如DemoServiceImpl包装成一个Invoker对象；<li>getProxy：针对client端，创建接口的代理对象，例如DemoService的接口；</ul><li><font color=orange>Invocation会话域</font>：它持有调用过程中的变量，比如方法名，参数等；</ul><h3 id=7-1-2、整体流程><a class=headerlink href=#7-1-2、整体流程 title=7.1.2、整体流程></a>7.1.2、整体流程</h3><p><strong>Dubbo 服务暴露分两分：第一步 将持有的服务实例 通过代理 转换成 Invoker，第二步将Invoker 通过具体的协议（比如Dubbo）转换成Exporter，框架做了这层抽象也大大方便了功能扩展。</strong><p>服务提供方暴露服务的初始化链，时序图如下：<p><img src=https://raw.githubusercontent.com/lucky2shh/blog-haogeblogs-image/master/2023/08/07/dubbo%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E6%9A%B4%E6%BC%8F%E6%9C%8D%E5%8A%A1%E6%B5%81%E7%A8%8B01.jpg><h3 id=7-1-3、源码分析><a class=headerlink href=#7-1-3、源码分析 title=7.1.3、源码分析></a>7.1.3、源码分析</h3><p>服务导出 入口方法是 ServiceBean 的 onApplicationEvent。onApplicationEvent 是一个事件响应方法，该方法会在收到Spring 上下文刷新事件后执行服务导出操作。方法代码如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line>    <span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">onApplicationEvent</span><span class=params>(ContextRefreshedEvent event)</span> {</span><br><span class=line>        <span class=keyword>if</span> (!isExported() && !isUnexported()) {</span><br><span class=line>            <span class=keyword>if</span> (logger.isInfoEnabled()) {</span><br><span class=line>                logger.info(<span class=string>"The service ready on spring started. service: "</span> + getInterface());</span><br><span class=line>            }</span><br><span class=line>            export();</span><br><span class=line>        }</span><br><span class=line>    }</span><br></pre></table></figure><p>通过export最终找到doExportUrls()方法：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">doExportUrls</span><span class=params>()</span> {</span><br><span class=line>    	<span class=comment>//加载配置文件中的所有注册中心，并且封装为dubbo内部的URL对象列表</span></span><br><span class=line>        List&LTURL> registryURLs = loadRegistries(<span class=literal>true</span>);</span><br><span class=line>        <span class=comment>//循环所有协议配置，根据不同的协议，向注册中心中发起注册</span></span><br><span class=line>        <span class=keyword>for</span> (ProtocolConfig protocolConfig : protocols) {</span><br><span class=line>            <span class=type>String</span> <span class=variable>pathKey</span> <span class=operator>=</span> URL.buildKey(getContextPath(protocolConfig).map(p -> p + <span class=string>"/"</span> + path).orElse(path), group, version);</span><br><span class=line>            <span class=type>ProviderModel</span> <span class=variable>providerModel</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">ProviderModel</span>(pathKey, ref, interfaceClass);</span><br><span class=line>            ApplicationModel.initProviderModel(pathKey, providerModel);</span><br><span class=line>            <span class=comment>//服务暴露方法</span></span><br><span class=line>            doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class=line>        }</span><br><span class=line>    }</span><br></pre></table></figure><p>doExportUrlsFor1Protocol()方法代码老多了，我们只关系核心的地方：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br></pre><td class=code><pre><span class=line><span class=keyword>if</span> (!SCOPE_NONE.equalsIgnoreCase(scope)) {</span><br><span class=line>    <span class=comment>//本地暴露，将服务数据记录到本地JVM中</span></span><br><span class=line>    <span class=keyword>if</span> (!SCOPE_REMOTE.equalsIgnoreCase(scope)) {</span><br><span class=line>        exportLocal(url);</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>//远程暴露，向注册中心发送数据</span></span><br><span class=line>    <span class=keyword>if</span> (!SCOPE_LOCAL.equalsIgnoreCase(scope)) {</span><br><span class=line>        <span class=keyword>if</span> (!isOnlyInJvm() && logger.isInfoEnabled()) {</span><br><span class=line>            logger.info(<span class=string>"Export dubbo service "</span> + interfaceClass.getName() + <span class=string>" to url "</span> + url);</span><br><span class=line>        }</span><br><span class=line>        <span class=keyword>if</span> (CollectionUtils.isNotEmpty(registryURLs)) {</span><br><span class=line>            <span class=keyword>for</span> (URL registryURL : registryURLs) {</span><br><span class=line>                <span class=comment>//if protocol is only injvm ,not register</span></span><br><span class=line>                <span class=keyword>if</span> (LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) {</span><br><span class=line>                    <span class=keyword>continue</span>;</span><br><span class=line>                }</span><br><span class=line>                url = url.addParameterIfAbsent(DYNAMIC_KEY, registryURL.getParameter(DYNAMIC_KEY));</span><br><span class=line>                <span class=type>URL</span> <span class=variable>monitorUrl</span> <span class=operator>=</span> loadMonitor(registryURL);</span><br><span class=line>                <span class=keyword>if</span> (monitorUrl != <span class=literal>null</span>) {</span><br><span class=line>                    url = url.addParameterAndEncoded(MONITOR_KEY, monitorUrl.toFullString());</span><br><span class=line>                }</span><br><span class=line>                <span class=keyword>if</span> (logger.isInfoEnabled()) {</span><br><span class=line>                    logger.info(<span class=string>"Register dubbo service "</span> + interfaceClass.getName() + <span class=string>" url "</span> + url + <span class=string>" to registry "</span> + registryURL);</span><br><span class=line>                }</span><br><span class=line></span><br><span class=line>                <span class=comment>// For providers, this is used to enable custom proxy to generate invoker</span></span><br><span class=line>                <span class=type>String</span> <span class=variable>proxy</span> <span class=operator>=</span> url.getParameter(PROXY_KEY);</span><br><span class=line>                <span class=keyword>if</span> (StringUtils.isNotEmpty(proxy)) {</span><br><span class=line>                    registryURL = registryURL.addParameter(PROXY_KEY, proxy);</span><br><span class=line>                }</span><br><span class=line>                <span class=comment>// 为服务提供类(ref)生成 Invoker</span></span><br><span class=line>                Invoker&LT?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));</span><br><span class=line>                <span class=comment>// DelegateProviderMetaDataInvoker 用于持有 Invoker 和ServiceConfig</span></span><br><span class=line>                <span class=type>DelegateProviderMetaDataInvoker</span> <span class=variable>wrapperInvoker</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">DelegateProviderMetaDataInvoker</span>(invoker, <span class=built_in>this</span>);</span><br><span class=line>                <span class=comment>// 导出服务，并生成 Exporter</span></span><br><span class=line>                Exporter&LT?> exporter = protocol.export(wrapperInvoker);</span><br><span class=line>                exporters.add(exporter);</span><br><span class=line>            }</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=comment>//不存在注册中心,仅导出服务</span></span><br><span class=line>            ....</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>/**</span></span><br><span class=line><span class=comment>                 * <span class=doctag>@since</span> 2.7.0</span></span><br><span class=line><span class=comment>                 * ServiceData Store</span></span><br><span class=line><span class=comment>                 */</span></span><br><span class=line>        <span class=type>MetadataReportService</span> <span class=variable>metadataReportService</span> <span class=operator>=</span> <span class=literal>null</span>;</span><br><span class=line>        <span class=keyword>if</span> ((metadataReportService = getMetadataReportService()) != <span class=literal>null</span>) {</span><br><span class=line>            metadataReportService.publishProvider(url);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=built_in>this</span>.urls.add(url);</span><br></pre></table></figure><p>上面代码根据url 中的scope 参数决定服务导出方式，分别如下：<ul><li>scope = none，不导出服务；<li>scope != remote，导出到本地；<li>scope != local，导出到远程；</ul><p><strong>不管是导出到本地，还是远程。服务导出之前一定要先创建Invoker。</strong>因此下面先来分析Invoker 的创建过程。Invoker 是由ProxyFactory 创建而来，Dubbo 默认的ProxyFactory 实现类是JavassistProxyFactory。下面我从JavassistProxyFactory 源码中分析Invoker 的创建过程。源码如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> &LTT> Invoker&LTT> <span class="title function_">getInvoker</span><span class=params>(T proxy, Class&LTT> type, URL url)</span> {</span><br><span class=line>    <span class=comment>// 为目标类创建warpper</span></span><br><span class=line>    <span class=keyword>final</span> <span class=type>Wrapper</span> <span class=variable>wrapper</span> <span class=operator>=</span> Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class=string>'$'</span>) < <span class=number>0</span> ? proxy.getClass() : type);</span><br><span class=line>    <span class=comment>// 创建匿名才invoker对象，并实现doinvoke方法</span></span><br><span class=line>    <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">AbstractProxyInvoker</span>&LTT>(proxy, type, url) {</span><br><span class=line>        <span class=meta>@Override</span></span><br><span class=line>        <span class=keyword>protected</span> Object <span class="title function_">doInvoke</span><span class=params>(T proxy, String methodName,</span></span><br><span class=line><span class=params>                                  Class&LT?>[] parameterTypes,</span></span><br><span class=line><span class=params>                                  Object[] arguments)</span> <span class=keyword>throws</span> Throwable {</span><br><span class=line>            <span class=comment>// 调用 Wrapper 的 invokeMethod 方法，invokeMethod 最终会调用目标方法</span></span><br><span class=line>            <span class=keyword>return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);</span><br><span class=line>        }</span><br><span class=line>    };</span><br><span class=line>}</span><br></pre></table></figure><p>Invoke创建成功之后，接下来我们来看本地导出：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">exportLocal</span><span class=params>(URL url)</span> {</span><br><span class=line>    <span class=type>URL</span> <span class=variable>local</span> <span class=operator>=</span> URLBuilder.from(url)</span><br><span class=line>        .setProtocol(LOCAL_PROTOCOL)  <span class=comment>// 设置协议头为 injvm</span></span><br><span class=line>        .setHost(LOCALHOST_VALUE)     <span class=comment>// 本地ip:127.0.0.1</span></span><br><span class=line>        .setPort(<span class=number>0</span>)</span><br><span class=line>        .build();</span><br><span class=line>    <span class=comment>// 创建 Invoker 并导出服务，protocol会在运行时调用InjvmProtocol的export方法</span></span><br><span class=line>    Exporter&LT?> exporter = protocol.export(</span><br><span class=line>        proxyFactory.getInvoker(ref, (Class) interfaceClass, local));</span><br><span class=line>    exporters.add(exporter);</span><br><span class=line>    logger.info(<span class=string>"Export dubbo service "</span> + interfaceClass.getName() + <span class=string>" to local registry url : "</span> + local);</span><br><span class=line>}</span><br></pre></table></figure><p>exportLocal 方法比较简单，首先根据URL 协议头决定是否导出服务。若需导出，则创建一个新的URL并将协议头、主机名以及端口设置成新的值。然后创建Invoker，并调用InjvmProtocol 的export 方法导出服务。下面我们来看一下InjvmProtocol 的export 方法都做了哪些事情。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> &LTT> Exporter&LTT> <span class="title function_">export</span><span class=params>(Invoker&LTT> invoker)</span> <span class=keyword>throws</span> RpcException {</span><br><span class=line>	<span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">InjvmExporter</span>&LTT>(invoker, invoker.getUrl().getServiceKey(), exporterMap);</span><br><span class=line>}</span><br></pre></table></figure><p>如上，InjvmProtocol 的export 方法仅创建了一个InjvmExporter，无其他逻辑。到此导出服务到本地就分析完了。<p>接下来，我们继续分析导出服务到远程的过程。导出服务到远程包含了服务导出与服务注册两个过程。先来分析服务导出逻辑。我们把目光移动到RegistryProtocol 的export 方法上。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> &LTT> Exporter&LTT> <span class="title function_">export</span><span class=params>(<span class=keyword>final</span> Invoker&LTT> originInvoker)</span> <span class=keyword>throws</span> RpcException {</span><br><span class=line>    <span class=comment>// 获取注册中心 URL</span></span><br><span class=line>    <span class=type>URL</span> <span class=variable>registryUrl</span> <span class=operator>=</span> getRegistryUrl(originInvoker);</span><br><span class=line>    <span class=type>URL</span> <span class=variable>providerUrl</span> <span class=operator>=</span> getProviderUrl(originInvoker);</span><br><span class=line>    <span class=keyword>final</span> <span class=type>URL</span> <span class=variable>overrideSubscribeUrl</span> <span class=operator>=</span> getSubscribedOverrideUrl(providerUrl);</span><br><span class=line>    <span class=keyword>final</span> <span class=type>OverrideListener</span> <span class=variable>overrideSubscribeListener</span> <span class=operator>=</span> <span class=keyword>new</span> <span class="title class_">OverrideListener</span>(overrideSubscribeUrl, originInvoker);</span><br><span class=line>    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class=line>    providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);</span><br><span class=line>    <span class=comment>//导出服务</span></span><br><span class=line>    <span class=keyword>final</span> ExporterChangeableWrapper&LTT> exporter = doLocalExport(originInvoker, providerUrl);</span><br><span class=line>    <span class=comment>// 根据 URL 加载 Registry 实现类，比如 ZookeeperRegistry</span></span><br><span class=line>    <span class=keyword>final</span> <span class=type>Registry</span> <span class=variable>registry</span> <span class=operator>=</span> getRegistry(originInvoker);</span><br><span class=line>    <span class=comment>//获取已注册的服务提供者 URL，</span></span><br><span class=line>    <span class=keyword>final</span> <span class=type>URL</span> <span class=variable>registeredProviderUrl</span> <span class=operator>=</span> getRegisteredProviderUrl(providerUrl, registryUrl);</span><br><span class=line>    ProviderInvokerWrapper&LTT> providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,</span><br><span class=line>                                                                                                 registryUrl, registeredProviderUrl);</span><br><span class=line>    <span class=comment>//to judge if we need to delay publish</span></span><br><span class=line>    <span class=type>boolean</span> <span class=variable>register</span> <span class=operator>=</span> registeredProviderUrl.getParameter(<span class=string>"register"</span>, <span class=literal>true</span>);</span><br><span class=line>    <span class=keyword>if</span> (register) {</span><br><span class=line>        <span class=comment>// 向注册中心注册服务</span></span><br><span class=line>        register(registryUrl, registeredProviderUrl);</span><br><span class=line>        providerInvokerWrapper.setReg(<span class=literal>true</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>//  向注册中心进行订阅 override 数据</span></span><br><span class=line>    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class=line>    exporter.setRegisterUrl(registeredProviderUrl);</span><br><span class=line>    exporter.setSubscribeUrl(overrideSubscribeUrl);</span><br><span class=line>    <span class=comment>// 创建并返回 DestroyableExporter</span></span><br><span class=line>    <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">DestroyableExporter</span><>(exporter);</span><br><span class=line>}</span><br></pre></table></figure><p>上面代码看起来比较复杂，主要做如下一些操作：<ol><li>调用doLocalExport 导出服务<li>向注册中心注册服务<li>向注册中心进行订阅override 数据<li>创建并返回DestroyableExporter</ol><p>看看doLocalExport 做了什么<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> &LTT> ExporterChangeableWrapper&LTT> <span class="title function_">doLocalExport</span><span class=params>(<span class=keyword>final</span> Invoker&LTT> originInvoker, URL providerUrl)</span> {</span><br><span class=line>    <span class=type>String</span> <span class=variable>key</span> <span class=operator>=</span> getCacheKey(originInvoker);</span><br><span class=line>    <span class=keyword>return</span> (ExporterChangeableWrapper&LTT>) bounds.computeIfAbsent(key, s -> {</span><br><span class=line>        Invoker&LT?> invokerDelegate = <span class=keyword>new</span> <span class="title class_">InvokerDelegate</span><>(originInvoker, providerUrl);</span><br><span class=line>        <span class=comment>//protocol和配置的协议相关（dubbo：DubboProtocol）</span></span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">ExporterChangeableWrapper</span><>((Exporter&LTT>) protocol.export(invokerDelegate), originInvoker);</span><br><span class=line>    });</span><br><span class=line>}</span><br></pre></table></figure><p>接下来，我们把重点放在Protocol 的export 方法上。假设运行时协议为dubbo，此处的protocol 变量会在运行时加载DubboProtocol，并调用DubboProtocol 的export 方法。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> &LTT> Exporter&LTT> <span class="title function_">export</span><span class=params>(Invoker&LTT> invoker)</span> <span class=keyword>throws</span> RpcException {</span><br><span class=line>    <span class=type>URL</span> <span class=variable>url</span> <span class=operator>=</span> invoker.getUrl();</span><br><span class=line>    <span class=comment>// export service.获取服务标识，理解成服务坐标也行。由服务组名，服务名，服务版本号以及端口组成。比如：demoGroup/com.alibaba.dubbo.demo.DemoService:1.0.1:20880</span></span><br><span class=line>    <span class=type>String</span> <span class=variable>key</span> <span class=operator>=</span> serviceKey(url);</span><br><span class=line>    <span class=comment>//创建DubboExporter</span></span><br><span class=line>    DubboExporter&LTT> exporter = <span class=keyword>new</span> <span class="title class_">DubboExporter</span>&LTT>(invoker, key, exporterMap);</span><br><span class=line>    exporterMap.put(key, exporter); <span class=comment>//key：接口 （DemoService）</span></span><br><span class=line></span><br><span class=line>    <span class=comment>//export an stub service for dispatching event</span></span><br><span class=line>    <span class=type>Boolean</span> <span class=variable>isStubSupportEvent</span> <span class=operator>=</span> url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT);</span><br><span class=line>    <span class=type>Boolean</span> <span class=variable>isCallbackservice</span> <span class=operator>=</span> url.getParameter(IS_CALLBACK_SERVICE, <span class=literal>false</span>);</span><br><span class=line>    <span class=keyword>if</span> (isStubSupportEvent && !isCallbackservice) {</span><br><span class=line>        <span class=type>String</span> <span class=variable>stubServiceMethods</span> <span class=operator>=</span> url.getParameter(STUB_EVENT_METHODS_KEY);</span><br><span class=line>        <span class=keyword>if</span> (stubServiceMethods == <span class=literal>null</span> || stubServiceMethods.length() == <span class=number>0</span>) {</span><br><span class=line>            <span class=keyword>if</span> (logger.isWarnEnabled()) {</span><br><span class=line>                logger.warn(<span class=keyword>new</span> <span class="title class_">IllegalStateException</span>(<span class=string>"consumer ["</span> + url.getParameter(INTERFACE_KEY) +</span><br><span class=line>                                                      <span class=string>"], has set stubproxy support event ,but no stub methods founded."</span>));</span><br><span class=line>            }</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>//启动服务</span></span><br><span class=line>    openServer(url);</span><br><span class=line>    <span class=comment>//优化序列器</span></span><br><span class=line>    optimizeSerialization(url);</span><br><span class=line>    <span class=keyword>return</span> exporter;</span><br><span class=line>}</span><br></pre></table></figure><p>如上，我们重点关注DubboExporter 的创建以及openServer 方法，其他逻辑看不懂也没关系，不影响理解服务导出过程。下面分析openServer 方法。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> <span class=keyword>void</span> <span class="title function_">openServer</span><span class=params>(URL url)</span> {</span><br><span class=line>    <span class=comment>// find server.</span></span><br><span class=line>    <span class=type>String</span> <span class=variable>key</span> <span class=operator>=</span> url.getAddress();</span><br><span class=line>    <span class=comment>//client can export a service which's only for server to invoke</span></span><br><span class=line>    <span class=type>boolean</span> <span class=variable>isServer</span> <span class=operator>=</span> url.getParameter(IS_SERVER_KEY, <span class=literal>true</span>);</span><br><span class=line>    <span class=keyword>if</span> (isServer) {</span><br><span class=line>        <span class=comment>//访问缓存</span></span><br><span class=line>        <span class=type>ExchangeServer</span> <span class=variable>server</span> <span class=operator>=</span> serverMap.get(key);</span><br><span class=line>        <span class=keyword>if</span> (server == <span class=literal>null</span>) {</span><br><span class=line>            <span class=keyword>synchronized</span> (<span class=built_in>this</span>) {</span><br><span class=line>                server = serverMap.get(key);</span><br><span class=line>                <span class=keyword>if</span> (server == <span class=literal>null</span>) {</span><br><span class=line>                    <span class=comment>//创建服务器实例</span></span><br><span class=line>                    serverMap.put(key, createServer(url));</span><br><span class=line>                }</span><br><span class=line>            }</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=comment>// server supports reset, use together with override</span></span><br><span class=line>            server.reset(url);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>接下来分析服务器实例的创建过程。如下<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre><td class=code><pre><span class=line><span class=keyword>private</span> ExchangeServer <span class="title function_">createServer</span><span class=params>(URL url)</span> {</span><br><span class=line>    url = URLBuilder.from(url)</span><br><span class=line>        <span class=comment>// send readonly event when server closes, it's enabled by default</span></span><br><span class=line>        .addParameterIfAbsent(CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString())</span><br><span class=line>        <span class=comment>// enable heartbeat by default</span></span><br><span class=line>        .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT))</span><br><span class=line>        .addParameter(CODEC_KEY, DubboCodec.NAME)</span><br><span class=line>        .build();</span><br><span class=line>    <span class=type>String</span> <span class=variable>str</span> <span class=operator>=</span> url.getParameter(SERVER_KEY, DEFAULT_REMOTING_SERVER);</span><br><span class=line></span><br><span class=line>    <span class=comment>// 通过 SPI 检测是否存在 server 参数所代表的 Transporter 拓展，不存在则抛出异常</span></span><br><span class=line>    <span class=keyword>if</span> (str != <span class=literal>null</span> && str.length() > <span class=number>0</span> && !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">RpcException</span>(<span class=string>"Unsupported server type: "</span> + str + <span class=string>", url: "</span> + url);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    ExchangeServer server;</span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        <span class=comment>// 创建 ExchangeServer</span></span><br><span class=line>        server = Exchangers.bind(url, requestHandler);</span><br><span class=line>    } <span class=keyword>catch</span> (RemotingException e) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">RpcException</span>(<span class=string>"Fail to start server(url: "</span> + url + <span class=string>") "</span> + e.getMessage(), e);</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=comment>// 获取 client 参数，可指定 netty，mina</span></span><br><span class=line>    str = url.getParameter(CLIENT_KEY);</span><br><span class=line>    <span class=keyword>if</span> (str != <span class=literal>null</span> && str.length() > <span class=number>0</span>) {</span><br><span class=line>        <span class=comment>// 获取所有的 Transporter 实现类名称集合，比如 supportedTypes = [netty, mina]</span></span><br><span class=line>        Set&LTString> supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();</span><br><span class=line>        <span class=comment>// 检测当前 Dubbo 所支持的 Transporter 实现类名称列表中，</span></span><br><span class=line>        <span class=comment>// 是否包含 client 所表示的 Transporter，若不包含，则抛出异常</span></span><br><span class=line>        <span class=keyword>if</span> (!supportedTypes.contains(str)) {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">RpcException</span>(<span class=string>"Unsupported client type: "</span> + str);</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> server;</span><br><span class=line>}</span><br></pre></table></figure><p>createServer 包含三个核心逻辑：<ol><li>检测是否存在server 参数所代表的Transporter 拓展，不存在则抛出异常。<li>创建服务器实例。<li>检测是否支持client 参数所表示的Transporter 拓展，不存在也是抛出异常。两次检测操作所对应的代码较直白了，无需多说。但创建服务器的操作目前还不是很清晰，我们继续往下看。</ol><figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> ExchangeServer <span class="title function_">bind</span><span class=params>(URL url, ExchangeHandler handler)</span> <span class=keyword>throws</span> RemotingException {</span><br><span class=line>    <span class=keyword>if</span> (url == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalArgumentException</span>(<span class=string>"url == null"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>if</span> (handler == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalArgumentException</span>(<span class=string>"handler == null"</span>);</span><br><span class=line>    }</span><br><span class=line>    url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class=string>"exchange"</span>);</span><br><span class=line>    <span class=comment>// 获取 Exchanger，默认为 HeaderExchanger。</span></span><br><span class=line>    <span class=comment>// 紧接着调用 HeaderExchanger 的 bind 方法创建 ExchangeServer 实例</span></span><br><span class=line>    <span class=keyword>return</span> getExchanger(url).bind(url, handler);</span><br><span class=line>}</span><br></pre></table></figure><p>上面代码比较简单，就不多说了。下面看一下HeaderExchanger 的bind 方法。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> ExchangeServer <span class="title function_">bind</span><span class=params>(URL url, ExchangeHandler handler)</span> <span class=keyword>throws</span> RemotingException {</span><br><span class=line>    <span class=comment>// 创建 HeaderExchangeServer 实例，该方法包含了多个逻辑，分别如下：</span></span><br><span class=line>    <span class=comment>//   1. new HeaderExchangeHandler(handler)</span></span><br><span class=line>    <span class=comment>//   2. new DecodeHandler(new HeaderExchangeHandler(handler))</span></span><br><span class=line>    <span class=comment>//   3. Transporters.bind(url, new DecodeHandler(new</span></span><br><span class=line>    HeaderExchangeHandler(handler)))</span><br><span class=line>        <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">HeaderExchangeServer</span>(Transporters.bind(url, <span class=keyword>new</span> <span class="title class_">ChannelHandler</span>[]{<span class=keyword>new</span> <span class="title class_">DecodeHandler</span>(<span class=keyword>new</span> <span class="title class_">HeaderExchangeHandler</span>(handler))}));</span><br><span class=line>}</span><br></pre></table></figure><p>HeaderExchanger 的bind 方法包含的逻辑比较多，但目前我们仅需关心Transporters 的bind 方法逻<br>辑即可。该方法的代码如下：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>static</span> Server <span class="title function_">bind</span><span class=params>(URL url, ChannelHandler... handlers)</span> <span class=keyword>throws</span> RemotingException {</span><br><span class=line>    <span class=keyword>if</span> (url == <span class=literal>null</span>) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalArgumentException</span>(<span class=string>"url == null"</span>);</span><br><span class=line>    } <span class=keyword>else</span> <span class=keyword>if</span> (handlers != <span class=literal>null</span> && handlers.length != <span class=number>0</span>) {</span><br><span class=line>        Object handler;</span><br><span class=line>        <span class=keyword>if</span> (handlers.length == <span class=number>1</span>) {</span><br><span class=line>            handler = handlers[<span class=number>0</span>];</span><br><span class=line>        } <span class=keyword>else</span> {</span><br><span class=line>            <span class=comment>// 如果 handlers 元素数量大于1，则创建 ChannelHandler 分发器</span></span><br><span class=line>            handler = <span class=keyword>new</span> <span class="title class_">ChannelHandlerDispatcher</span>(handlers);</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>// 获取自适应 Transporter 实例，并调用实例方法</span></span><br><span class=line>        <span class=keyword>return</span> getTransporter().bind(url, (ChannelHandler)handler);</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalArgumentException</span>(<span class=string>"handlers == null"</span>);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>如上，getTransporter() 方法获取的Transporter 是在运行时动态创建的，类名为TransporterAdaptive，也就是自适应拓展类。TransporterAdaptive 会在运行时根据传入的URL 参数决定加载什么类型的Transporter，默认为NettyTransporter。调用 NettyTransporter.bind(URL,ChannelHandler) 方法。创建一个 NettyServer 实例。调用 NettyServer.doOPen() 方法，服务器被开启，服务也被暴露出来了。<h3 id=7-1-4、服务注册><a class=headerlink href=#7-1-4、服务注册 title=7.1.4、服务注册></a>7.1.4、服务注册</h3><p>以Zookeeper 注册中心为例，从服务注册的入口方法开始分析。<p>我们把目光再次移到RegistryProtocol 的export 方法上。如下：<p>进入到register()方法<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">register</span><span class=params>(URL registryUrl, URL registeredProviderUrl)</span> {</span><br><span class=line>    <span class=comment>//获得注册中心实例</span></span><br><span class=line>    <span class=type>Registry</span> <span class=variable>registry</span> <span class=operator>=</span> registryFactory.getRegistry(registryUrl);</span><br><span class=line>    <span class=comment>//进行注册</span></span><br><span class=line>    registry.register(registeredProviderUrl);</span><br><span class=line>}</span><br></pre></table></figure><p>看看getRegistry()方法<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> Registry <span class="title function_">getRegistry</span><span class=params>(URL url)</span> {</span><br><span class=line>    url = URLBuilder.from(url)</span><br><span class=line>        .setPath(RegistryService.class.getName())</span><br><span class=line>        .addParameter(INTERFACE_KEY, RegistryService.class.getName())</span><br><span class=line>        .removeParameters(EXPORT_KEY, REFER_KEY)</span><br><span class=line>        .build();</span><br><span class=line>    <span class=type>String</span> <span class=variable>key</span> <span class=operator>=</span> url.toServiceStringWithoutResolving();</span><br><span class=line>    <span class=comment>// Lock the registry access process to ensure a single instance of the registry</span></span><br><span class=line>    LOCK.lock();</span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        <span class=type>Registry</span> <span class=variable>registry</span> <span class=operator>=</span> REGISTRIES.get(key);</span><br><span class=line>        <span class=keyword>if</span> (registry != <span class=literal>null</span>) {</span><br><span class=line>            <span class=keyword>return</span> registry;</span><br><span class=line>        }</span><br><span class=line>        <span class=comment>//create registry by spi/ioc</span></span><br><span class=line>        registry = createRegistry(url);</span><br><span class=line>        <span class=keyword>if</span> (registry == <span class=literal>null</span>) {</span><br><span class=line>            <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalStateException</span>(<span class=string>"Can not create registry "</span> + url);</span><br><span class=line>        }</span><br><span class=line>        REGISTRIES.put(key, registry);</span><br><span class=line>        <span class=keyword>return</span> registry;</span><br><span class=line>    } <span class=keyword>finally</span> {</span><br><span class=line>        <span class=comment>// Release the lock</span></span><br><span class=line>        LOCK.unlock();</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>进入createRegistry()方法<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br></pre><td class=code><pre><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> Registry <span class="title function_">createRegistry</span><span class=params>(URL url)</span> {</span><br><span class=line>    <span class=keyword>return</span> <span class=keyword>new</span> <span class="title class_">ZookeeperRegistry</span>(url, zookeeperTransporter);</span><br><span class=line>}</span><br><span class=line></span><br><span class=line><span class=keyword>public</span> <span class="title function_">ZookeeperRegistry</span><span class=params>(URL url, ZookeeperTransporter zookeeperTransporter)</span> {</span><br><span class=line>    <span class=built_in>super</span>(url);</span><br><span class=line>    <span class=keyword>if</span> (url.isAnyHost()) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">IllegalStateException</span>(<span class=string>"registry address == null"</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>//// 获取组名，默认为 dubbo</span></span><br><span class=line>    <span class=type>String</span> <span class=variable>group</span> <span class=operator>=</span> url.getParameter(GROUP_KEY, DEFAULT_ROOT);</span><br><span class=line>    <span class=keyword>if</span> (!group.startsWith(PATH_SEPARATOR)) {</span><br><span class=line>        group = PATH_SEPARATOR + group;</span><br><span class=line>    }</span><br><span class=line>    <span class=built_in>this</span>.root = group;</span><br><span class=line>    <span class=comment>// 创建 Zookeeper 客户端，默认为 CuratorZookeeperTransporter</span></span><br><span class=line>    zkClient = zookeeperTransporter.connect(url);</span><br><span class=line>    <span class=comment>// 添加状态监听器</span></span><br><span class=line>    zkClient.addStateListener(state -> {</span><br><span class=line>        <span class=keyword>if</span> (state == StateListener.RECONNECTED) {</span><br><span class=line>            <span class=keyword>try</span> {</span><br><span class=line>                recover();</span><br><span class=line>            } <span class=keyword>catch</span> (Exception e) {</span><br><span class=line>                logger.error(e.getMessage(), e);</span><br><span class=line>            }</span><br><span class=line>        }</span><br><span class=line>    });</span><br><span class=line>}</span><br></pre></table></figure><p>上面代码要重点关注ZookeeperTransporter 的 connect方法的调用，该方法用于创建 Zookeeper 客户端。创建好Zookeeper 客户端意味着注册中心的创建过程就结束了。<p>搞懂了服务注册的本质，接下来就可以去阅读服务注册的代码了。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">doRegister</span><span class=params>(URL url)</span> {</span><br><span class=line>    <span class=keyword>try</span> {</span><br><span class=line>        <span class=comment>// 通过 Zookeeper 客户端创建节点，节点路径由 toUrlPath 方法生成，路径格式如下:</span></span><br><span class=line>        <span class=comment>//  /${group}/${serviceInterface}/providers/${url}</span></span><br><span class=line>        <span class=comment>// 比如 /dubbo/org.apache.dubbo.DemoService/providers/dubbo%3A%2F%2F127.0.0.1......</span></span><br><span class=line>        zkClient.create(toUrlPath(url), url.getParameter(DYNAMIC_KEY, <span class=literal>true</span>));</span><br><span class=line>    } <span class=keyword>catch</span> (Throwable e) {</span><br><span class=line>        <span class=keyword>throw</span> <span class=keyword>new</span> <span class="title class_">RpcException</span>(<span class=string>"Failed to register "</span> + url + <span class=string>" to zookeeper "</span> + getUrl() + <span class=string>", cause: "</span> + e.getMessage(), e);</span><br><span class=line>    }</span><br><span class=line>}</span><br><span class=line><span class=meta>@Override</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>void</span> <span class="title function_">create</span><span class=params>(String path, <span class=type>boolean</span> ephemeral)</span> {</span><br><span class=line>    <span class=keyword>if</span> (!ephemeral) {</span><br><span class=line>        <span class=comment>// 如果要创建的节点类型非临时节点，那么这里要检测节点是否存在</span></span><br><span class=line>        <span class=keyword>if</span> (checkExists(path)) {</span><br><span class=line>            <span class=keyword>return</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=type>int</span> <span class=variable>i</span> <span class=operator>=</span> path.lastIndexOf(<span class=string>'/'</span>);</span><br><span class=line>    <span class=keyword>if</span> (i > <span class=number>0</span>) {</span><br><span class=line>        <span class=comment>// 递归创建上一级路径</span></span><br><span class=line>        create(path.substring(<span class=number>0</span>, i), <span class=literal>false</span>);</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 根据 ephemeral 的值创建临时或持久节点</span></span><br><span class=line>    <span class=keyword>if</span> (ephemeral) {</span><br><span class=line>        createEphemeral(path);</span><br><span class=line>    } <span class=keyword>else</span> {</span><br><span class=line>        createPersistent(path);</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p>整个过程可总结为：<strong>先创建注册中心实例，再将服务提供者注册至注册中心。</strong><h1 id=X、总结><a class=headerlink href=#X、总结 title=X、总结></a>X、总结</h1><ol><li>注册 服务提供者 时，ServiceConfig 解析出的URL 格式为：<code>registry:// registry-host/org.apache.dubbo.registry.RegistryService?export=URL.encode("dubbo://service-host/{服务名}/{版本号}")</code>。<li>基于Dubbo SPI 自适应机制，通过<code>URL registry:// 协议头</code>识别，就调用<code>RegistryProtocol#export()</code> 方法。<li>将具体服务类名，比如<code>DubboServiceRegistryImpl</code>，通过ProxyFactory 包装成Invoker 实例。<li>调用doLocalExport 方法，使用 <code>DubboProtocol</code> 将Invoker 转化为Exporter 实例，并打开Netty 服务端监听客户请求。<li>创建Registry 实例，连接Zookeeper，并在服务节点下写入提供者的URL 地址，注册服务。<li>向注册中心订阅override 数据，并返回一个Exporter 实例。<li>根据URL 格式中的 <code>"dubbo://service-host/{服务名}/{版本号}"</code> 中协议头 dubbo:// 识别，调用<code>DubboProtocol#export()</code>方法，开放服务端口。<li><code>RegistryProtocol#export()</code> 返回的Exporter 实例存放到ServiceConfig 的 <code>List&LTExporter>exporters</code> 中。</ol></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/Apache%20Dubbo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E5%BA%94%E5%AF%B9/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/Apache%20Dubbo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E5%BA%94%E5%AF%B9/ itemprop=url>Dubbo系列-Dubbo常见问题</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-10-02 11:11:02" datetime=2023-10-02T11:11:02+08:00 itemprop=dateModified>2023-10-02</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/Dubbo/ itemprop=url rel=index><span itemprop=name>Dubbo</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=1、-无法发布被事务代理的Service问题><a title="1、 无法发布被事务代理的Service问题" class=headerlink href=#1、-无法发布被事务代理的Service问题></a>1、 无法发布被事务代理的Service问题</h1><h2 id=1-1、问题描述><a class=headerlink href=#1-1、问题描述 title=1.1、问题描述></a>1.1、问题描述</h2><p><strong>通过Dubbo标签配置就可以实现包扫描，被注解@Service标注的类可以作为服务。</strong><p>如果 服务提供者类 被注解@Transactional标注，就会导致 服务发布失败。原因是：事务控制的底层原理是为服务提供者类创建代理对象，而默认情况下Spring是基于JDK动态代理方式创建代理对象，而此代理对象的完整类名为com.sun.proxy.$Proxy42（最后两位数字不是固定的），导致Dubbo在发布服务前进行包匹配时无法完成匹配，进而无法实现 服务发布。<h2 id=1-2、解决方案><a class=headerlink href=#1-2、解决方案 title=1.2、解决方案></a>1.2、解决方案</h2><p>问题分析：Spring基于JDK动态代理 为服务提供者创建代理对象的完整类名为com.sun.proxy.$Proxy35，发布服务时扫描的包为其它包，所以发布服务的代码没有执行。<h3 id=1-2-1、设置-属性proxy-target-class的值为true><a title="1.2.1、设置 属性proxy-target-class的值为true" class=headerlink href=#1-2-1、设置-属性proxy-target-class的值为true></a>1.2.1、设置 属性proxy-target-class的值为true</h3><p>修改applicationContext-service.xml配置文件，开启事务控制注解时指定proxy-target-class属性值为true，作用是通过cglib代理为Service类创建代理对象。<figure class="highlight xml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre><td class=code><pre><span class=line><span class=comment>&LT!--开启事务控制的注解支持--></span></span><br><span class=line><span class=tag><<span class=name>tx:annotation-driven</span> <span class=attr>transaction-manager</span>=<span class=string>"transactionManager"</span> <span class=attr>proxy-target-class</span>=<span class=string>"true"</span>/></span></span><br></pre></table></figure><h3 id=1-2-2、添加注解-Service，并设置属性interfaceClass的值><a class=headerlink href=#1-2-2、添加注解-Service，并设置属性interfaceClass的值 title=1.2.2、添加注解@Service，并设置属性interfaceClass的值></a>1.2.2、添加注解@Service，并设置属性interfaceClass的值</h3><p>修改HelloServiceImpl类，在Service注解中加入interfaceClass属性，值为HelloService.class，作用是指定服务的接口类型。<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br></pre><td class=code><pre><span class=line><span class=meta>@Service(interfaceClass = HelloService.class)</span></span><br><span class=line><span class=meta>@Transactional</span></span><br><span class=line><span class=keyword>public</span> <span class=keyword>class</span> <span class="title class_">HelloServiceImpl</span> <span class=keyword>implements</span> <span class="title class_">HelloService</span> {</span><br><span class=line>    <span class=keyword>public</span> String <span class="title function_">sayHello</span><span class=params>(String name)</span> {</span><br><span class=line>        <span class=keyword>return</span> <span class=string>"hello "</span> + name;</span><br><span class=line>    }</span><br><span class=line>}</span><br></pre></table></figure><p><font color=red>注意：此处必须修改，否则会导致发布的服务接口为SpringProxy，而不是HelloService接口。</font></div><footer class=post-footer><div class=post-eof></div></footer></article></div><div class=post-block><article class=post-content itemscope itemtype=http://schema.org/Article><link href=https://hshz21.gitee.io/2024/08/21/12-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta content=/static/imgs/avatar.png itemprop=image> <meta content=豪哥 itemprop=name> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=豪哥博客 itemprop=name> <meta content=豪哥博客 itemprop=description> </span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork> <meta content="undefined | 豪哥博客" itemprop=name> <meta itemprop=description> </span><header class=post-header><h2 itemprop="name headline" class=post-title><a class=post-title-link href=/2024/08/21/12-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/ itemprop=url>微服务业务功能系列-分布式事务</a></h2><div class=post-meta-container><div class=post-meta><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar"></i> </span> <span class=post-meta-item-text>发表于</span> <time itemprop="dateCreated datePublished" title="创建时间：2024-08-21 21:39:13" datetime=2024-08-21T21:39:13+08:00>2024-08-21</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-calendar-check"></i> </span> <span class=post-meta-item-text>更新于</span> <time title="修改时间：2023-08-07 15:56:49" datetime=2023-08-07T15:56:49+08:00 itemprop=dateModified>2023-08-07</time> </span><span class=post-meta-item> <span class=post-meta-item-icon> <i class="far fa-folder"></i> </span> <span class=post-meta-item-text>分类于</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/ itemprop=url rel=index><span itemprop=name>微服务</span></a> </span> </span></div></div></header><div class=post-body itemprop=articleBody><h1 id=Seata><a class=headerlink href=#Seata title=Seata></a>Seata</h1><h2 id=1-1、加入依赖><a class=headerlink href=#1-1、加入依赖 title=1.1、加入依赖></a>1.1、加入依赖</h2><h2 id=1-2、配置><a class=headerlink href=#1-2、配置 title=1.2、配置></a>1.2、配置</h2><h3 id=1-2-1、seata服务器配置><a class=headerlink href=#1-2-1、seata服务器配置 title=1.2.1、seata服务器配置></a>1.2.1、seata服务器配置</h3><p>在register.conf文件中编写如下配置：<figure class="highlight properties"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre><td class=code><pre><span class=line><span class=comment># 注册中心</span></span><br><span class=line><span class=attr>registry</span> <span class=string>{</span></span><br><span class=line><span class=comment>  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span></span><br><span class=line>  <span class=attr>type</span> = <span class=string>"nacos"</span></span><br><span class=line>  <span class=attr>nacos</span> <span class=string>{</span></span><br><span class=line>    <span class=attr>application</span> = <span class=string>"seata-tc-server"</span></span><br><span class=line>    <span class=attr>serverAddr</span> = <span class=string>"127.0.0.1:8848"</span></span><br><span class=line>    <span class=attr>namespace</span> = <span class=string>"37d6d15b-ee13-4bb6-8dfb-101f2281d479"</span></span><br><span class=line>    <span class=attr>group</span> = <span class=string>"gulimall-seata"</span></span><br><span class=line>    <span class=attr>cluster</span> = <span class=string>"SH"</span></span><br><span class=line>    <span class=attr>username</span> = <span class=string>"nacos"</span></span><br><span class=line>    <span class=attr>password</span> = <span class=string>"nacos"</span></span><br><span class=line>  <span class=attr>}</span></span><br><span class=line><span class=attr>}</span></span><br><span class=line><span class=comment># 配置中心</span></span><br><span class=line><span class=attr>config</span> <span class=string>{</span></span><br><span class=line><span class=comment>  # file、nacos 、apollo、zk、consul、etcd3</span></span><br><span class=line>  <span class=attr>type</span> = <span class=string>"nacos"</span></span><br><span class=line>  <span class=attr>nacos</span> <span class=string>{</span></span><br><span class=line>    <span class=attr>serverAddr</span> = <span class=string>"127.0.0.1:8848"</span></span><br><span class=line>    <span class=attr>namespace</span> = <span class=string>"37d6d15b-ee13-4bb6-8dfb-101f2281d479"</span></span><br><span class=line>    <span class=attr>group</span> = <span class=string>"gulimall-seata"</span></span><br><span class=line>    <span class=attr>username</span> = <span class=string>"nacos"</span></span><br><span class=line>    <span class=attr>password</span> = <span class=string>"nacos"</span></span><br><span class=line>    <span class=attr>dataId</span> = <span class=string>"seataServer.properties"</span></span><br><span class=line>  <span class=attr>}</span></span><br><span class=line><span class=attr>}</span></span><br></pre></table></figure><p><font color=red>注意：配置完成后，启动seata服务。</font><h3 id=1-2-2、微服务配置><a class=headerlink href=#1-2-2、微服务配置 title=1.2.2、微服务配置></a>1.2.2、微服务配置</h3><p>application.yml文件配置：<figure class="highlight yml"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre><td class=code><pre><span class=line><span class=attr>seata:</span></span><br><span class=line>  <span class=attr>registry:</span></span><br><span class=line>    <span class=attr>type:</span> <span class=string>nacos</span></span><br><span class=line>    <span class=attr>nacos:</span></span><br><span class=line>      <span class=attr>server-addr:</span> <span class=number>127.0</span><span class=number>.0</span><span class=number>.1</span><span class=string>:8848</span></span><br><span class=line>      <span class=attr>namespace:</span> <span class=string>37d6d15b-ee13-4bb6-8dfb-101f2281d479</span></span><br><span class=line>      <span class=attr>group:</span> <span class=string>gulimall-seata</span></span><br><span class=line>      <span class=attr>application:</span> <span class=string>seata-tc-server</span></span><br><span class=line>      <span class=attr>username:</span> <span class=string>nacos</span></span><br><span class=line>      <span class=attr>password:</span> <span class=string>nacos</span></span><br><span class=line>  <span class=attr>tx-service-group:</span> <span class=string>seata-order</span></span><br><span class=line>  <span class=attr>service:</span></span><br><span class=line>    <span class=attr>vgroup-mapping:</span></span><br><span class=line>      <span class=attr>seata-demo:</span> <span class=string>SH</span></span><br><span class=line>  <span class=attr>data-source-proxy-mode:</span> <span class=string>XA</span> <span class=comment># 或AT模式</span></span><br></pre></table></figure><h2 id=1-3、代码示例><a class=headerlink href=#1-3、代码示例 title=1.3、代码示例></a>1.3、代码示例</h2><p>1、在分布式事务入口方法上添加注解<code>@@GlobalTransactional</code>：<figure class="highlight java"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=meta>@GlobalTransactional</span></span><br><span class=line><span class=keyword>public</span> String <span class="title function_">createOrder</span><span class=params>()</span>{</span><br><span class=line>    stockService.hello();</span><br><span class=line>    creditService.hello();</span><br><span class=line>    wmsService.hello();</span><br><span class=line>    log.info(<span class=string>"订单创建成功"</span>);</span><br><span class=line>    <span class=keyword>return</span> <span class=string>"success"</span>;</span><br><span class=line>}</span><br></pre></table></figure><p>2、在其它微服务中添加注解<code>@Transactional</code>即可。</div><footer class=post-footer><div class=post-eof></div></footer></article></div><nav class=pagination><a class="extend prev" aria-label=上一页 href=/page/9/ rel=prev title=上一页><i class="fa fa-angle-left"></i></a><a class=page-number href=/>1</a><span class=space>…</span><a class=page-number href=/page/9/>9</a><span class="page-number current">10</span><a class=page-number href=/page/11/>11</a><a class="extend next" aria-label=下一页 href=/page/11/ rel=next title=下一页><i class="fa fa-angle-right"></i></a></nav></div></main><footer class=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-heart"></i> </span><span class=author itemprop=copyrightHolder>豪哥</span></div></div></footer><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span><span class=toggle-line></span><span class=toggle-line></span></div><div class=sidebar-dimmer></div><div aria-label=返回顶部 class=back-to-top role=button><i class="fa fa-arrow-up fa-lg"></i><span>0%</span></div><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><script crossorigin=anonymous integrity=sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY= src=https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js></script><script src=/js/comments.js></script><script src=/js/utils.js></script><script src=/js/motion.js></script><script src=/js/sidebar.js></script><script src=/js/next-boot.js></script><script crossorigin=anonymous integrity=sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc= src=https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js></script><script src=/js/third-party/search/local-search.js></script>